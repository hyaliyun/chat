import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-a1771b8b"]]),F=JSON.parse('[{"question":"You are given a list of cities and their respective temperatures over the past week. Each city\'s temperature is represented as a list of seven integers. Your task is to identify the city with the **most stable** temperature, defined as the city with the smallest temperature range (i.e., the difference between the maximum and minimum temperature for that city). If there are multiple cities with the same temperature range, return the alphabetically **first** city name. You are given two inputs: * `cities`, a list of strings where each string represents the name of a city. * `temperatures`, a list of lists of integers where `temperatures[i]` represents the temperature of the `i`th city over the past week. Return _the name of the city with the most stable temperature_.","solution":"def most_stable_temperature_city(cities, temperatures): Returns the name of the city with the most stable temperature. Args: cities (list): List of city names. temperatures (list): List of Lists of temperatures for each city. Returns: str: Name of the most stable temperature city. min_range = float(\'inf\') stable_city = \\"\\" for i, temp in enumerate(temperatures): temp_range = max(temp) - min(temp) if temp_range < min_range or (temp_range == min_range and cities[i] < stable_city): min_range = temp_range stable_city = cities[i] return stable_city"},{"question":"Write a function that takes an integer array `arr` and returns `true` if the array is sorted in non-decreasing order, and `false` otherwise. Non-decreasing order means that for all `i` in the range `[1, arr.length - 1]`, `arr[i - 1] <= arr[i]`.","solution":"def is_sorted(arr): Returns True if the integer array arr is sorted in non-decreasing order, and False otherwise. for i in range(1, len(arr)): if arr[i - 1] > arr[i]: return False return True"},{"question":"You are given an array `logs` where each entry represents a user log in the form `[userID, timestamp, action]`. Each user can perform two types of actions: \\"login\\" and \\"logout\\". Write a function to process the logs and return a list of tuples, where each tuple contains a `userID` and the total time spent logged in for that user. Assume no user logs in more than once without logging out and that all timestamps are in non-decreasing order. The output should be sorted by `userID` in ascending order.","solution":"def calculate_time_spent(logs): Processes logs of user actions and calculates total time spent logged in for each user. Args: logs (list): List of lists where each inner list is of the form [userID, timestamp, action] Returns: list: List of tuples where each tuple contains a userID and the total time spent logged in for that user, sorted by userID in ascending order. from collections import defaultdict time_spent = defaultdict(int) login_times = {} for log in logs: user_id, timestamp, action = log if action == \\"login\\": login_times[user_id] = timestamp elif action == \\"logout\\": if user_id in login_times: time_spent[user_id] += timestamp - login_times[user_id] del login_times[user_id] # Remove the user from login_times once they log out # Convert the defaultdict to a sorted list of tuples result = sorted(time_spent.items()) return result"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array of `queries`, where each `query[i] = [li, ri]`. The answer to the `i-th` query is the number of distinct characters in the substring `s[li...ri]`. Return _an integer array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `i-th` _query_.","solution":"def count_distinct_characters(s, queries): Given a string `s` and an array of queries, each query contains two indices `li` and `ri`. For each query, count the distinct characters in the substring `s[li...ri]`. Parameters: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): The array of queries, each containing two integers `li` and `ri`. Returns: List[int]: An array containing the number of distinct characters for each query. answer = [] for query in queries: li, ri = query substring = s[li:ri+1] distinct_chars = set(substring) answer.append(len(distinct_chars)) return answer"},{"question":"You are given a list of `points` in the 2D plane, each represented as a tuple `(x, y)`. A **square** is defined as a quadrilateral with four equal sides and four 90-degree angles. Write a function that determines if any four points from the list can form a square. Return _true if there exists such a square and false otherwise._ If the list contains fewer than four points, return false.","solution":"def is_square(points): Determines if any four points can form a square. :param points: List of tuples representing points in 2D plane. :return: Boolean value, True if any four points can form a square, False otherwise. from itertools import combinations from math import dist if len(points) < 4: return False for comb in combinations(points, 4): p1, p2, p3, p4 = comb dists = [dist(p1, p2), dist(p1, p3), dist(p1, p4), dist(p2, p3), dist(p2, p4), dist(p3, p4)] dists.sort() if dists[0] > 0 and all(d == dists[0] for d in dists[:4]) and all(d == dists[4] for d in dists[4:]): return True return False"},{"question":"You are given a list of non-negative integers `nums` and an integer `sum`. Write a function to determine the number of pairs `(i, j)` where `i < j` such that `nums[i] + nums[j] = sum`. For example, given `nums = [1, 2, 3, 4, 5]` and `sum = 6`, the pairs that satisfy the condition are `(1, 5)`, `(2, 4)`, and `(3, 3)` resulting in a count of 2 (since `nums[2] + nums[4]` and `nums[1] + nums[3]` sum to 6). Return the count of such pairs. Implement the function `countPairs(nums, sum) -> int` to solve the problem.","solution":"def countPairs(nums, target_sum): Returns the number of pairs (i, j) where i < j such that nums[i] + nums[j] == target_sum. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target_sum: count += 1 return count"},{"question":"Given a string `s` representing a nested list of integers, implement a function that returns the sum of all integers in the list weighted by their depth. Each integer in the list is multiplied by the depth of the integer. You may assume that the input string is well-formed and contains only integers and nested lists, where the depth increases by 1 for each level of nesting.","solution":"import ast def depth_sum(s): def helper(nested_list, depth): total = 0 for item in nested_list: if isinstance(item, list): total += helper(item, depth + 1) else: total += item * depth return total nested_list = ast.literal_eval(s) return helper(nested_list, 1)"},{"question":"You are given an integer array `arr` consisting of `n` elements, where each element represents the size of a file in megabytes. You need to distribute these files into two folders such that the absolute difference between the total sizes of the files in the two folders is minimized. Return _the minimum possible absolute difference_.","solution":"def min_diff_partition(arr): total_sum = sum(arr) n = len(arr) # Using dynamic programming to solve partition problem dp = [False] * (total_sum + 1) dp[0] = True for num in arr: for j in range(total_sum, num-1, -1): if dp[j - num]: dp[j] = True min_diff = float(\'inf\') # Find the largest j such that dp[j] is True and j <= total_sum//2 for j in range(total_sum // 2, -1, -1): if dp[j]: min_diff = total_sum - 2 * j break return min_diff"},{"question":"Given an array of integers `arr` and an integer `k`, return _the maximum length of a contiguous subarray that contains at most `k` different integers_.","solution":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray that contains at most k different integers. Parameters: arr (list): List of integers k (int): Maximum number of unique integers allowed Returns: int: Maximum length of subarray from collections import defaultdict if k == 0: return 0 left = 0 right = 0 max_length = 0 freq_map = defaultdict(int) while right < len(arr): freq_map[arr[right]] += 1 while len(freq_map) > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given an integer array `heights` representing the height of each person standing in a line. The heights array is not necessarily sorted. You are also given an integer `k` which represents the allowable difference in height between two people standing next to each other in the line. You need to determine if it is possible to rearrange the people in the line such that the difference in height between any two adjacent people is at most `k`. Return `true` if such a rearrangement is possible, and `false` otherwise.","solution":"def can_rearrange_heights(heights, k): Determines if it is possible to rearrange the people in the line such that the difference in height between any two adjacent people is at most k. :param heights: List[int] - a list of integers representing the heights of people :param k: int - the allowable difference in height between two adjacent people :return: bool - True if such a rearrangement is possible, False otherwise # Sort heights in ascending order heights.sort() # Check the differences between each adjacent height for i in range(len(heights) - 1): if abs(heights[i] - heights[i + 1]) > k: return False return True"},{"question":"You are given a list of integers `arr` and an integer `k`. You need to determine if you can partition the list into exactly `k` non-empty subsets such that the sum of the elements in each subset is the same. If such a partition is possible, return `True`, otherwise return `False`. For example, given `arr = [4, 3, 2, 3, 5, 2, 1]` and `k = 4`, one possible partition is `[[5], [1, 4], [2, 3], [2, 3]]`, all of which have a sum of `5`.","solution":"def can_partition_k_subsets(arr, k): total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def backtrack(start, k, current_sum): if k == 1: return True if current_sum == target_sum: return backtrack(0, k - 1, 0) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i + 1, k, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"Given an integer array `prices` representing the prices of products at different stores, and an integer `budget` representing your total budget, implement a function to determine the **maximum number of different products** you can buy without exceeding your budget. You must purchase exactly one item from each store. If it\'s not possible to buy one product from each store within the given budget, return `-1`. Example 1: Input: `prices = [[3, 5, 7], [10, 12, 20], [1, 2, 10]]`, `budget = 15` Output: `3` Example 2: Input: `prices = [[5, 9], [6, 12], [1, 3]]`, `budget = 10` Output: `-1` The function signature is: ```python def maxProducts(prices: List[List[int]], budget: int) -> int: pass ```","solution":"from typing import List def maxProducts(prices: List[List[int]], budget: int) -> int: min_prices = [min(store) for store in prices] total_min_cost = sum(min_prices) if total_min_cost > budget: return -1 return len(prices)"},{"question":"A mobile app company is planning to implement a new feature tracking the completion of user tasks across multiple categories. Each user has multiple tasks that belong to different categories. Companies want to incentivize users to complete tasks from as many different categories as possible to earn rewards. Given a list of user tasks where each task is represented with a unique ID paired with its category ID, return the **maximum number of distinct categories** from which the user completes at least one task. Use an empty list to represent no tasks completed. ---","solution":"def max_distinct_categories(tasks): Returns the maximum number of distinct categories from which the user completes at least one task. :param tasks: List of tuples (task_id, category_id). :return: Maximum number of distinct categories. if not tasks: return 0 category_set = set() for task in tasks: _, category_id = task category_set.add(category_id) return len(category_set)"},{"question":"You are given a 2D grid of size `m x n` representing a maze with two types of cells: 0 represents an empty cell you can walk through and 1 represents a wall you cannot cross. You start at the top-left corner of the grid (i.e., at position (0, 0)) and an exit is located at the bottom-right corner of the grid (i.e., at position (m-1, n-1)). You can move up, down, left, or right. Return _the shortest path from the start to the exit_ in terms of the number of cells you need to walk through, or return `_if there is no path._","solution":"from collections import deque def shortest_path_maze(grid): Returns the shortest path from the start to the exit in terms of the number of cells in a given 2D grid maze, or -1 if there is no path. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given an integer array `nums`, return the number of subsequences that sum to a given target value `S`. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Note that the solution set must be unique.","solution":"def count_subsequences(nums, S): Returns the number of subsequences that sum to the given target value S. nums: List[int] - List of integers S: int - target sum value return: int - number of subsequences summing to S from collections import defaultdict # This will store the number of subsequences that achieve each possible sum dp = defaultdict(int) dp[0] = 1 # There\'s one subsequence (empty subsequence) that has a sum of 0 for num in nums: # We should iterate in reverse to avoid counting each number more than once for subsum in list(dp.keys())[::-1]: dp[subsum + num] += dp[subsum] return dp[S]"},{"question":"A company is planning to organize its employees into teams for a project. You are given an integer `n`, representing the number of employees, where each employee is labeled from `0` to `n-1`. You are also given a 2D integer array `relations`, where `relations[i] = [a, b]` denotes that employee `a` and employee `b` can work well together in a team. Your task is to determine the number of ways to form teams such that each team consists of exactly `k` employees who can all work well together. Return the total number of valid teams possible. If it\'s not possible to form such teams, return `0`. Note that each employee can be in only one team, and the order of employees in a team does not matter.","solution":"from collections import defaultdict from itertools import combinations def count_valid_teams(n, relations, k): # Create an adjacency list for relations adj_list = defaultdict(set) for a, b in relations: adj_list[a].add(b) adj_list[b].add(a) def is_clique(team): # Check if every pair in the team works well together for u, v in combinations(team, 2): if v not in adj_list[u]: return False return True if k > n: return 0 employees = list(range(n)) valid_teams = 0 # Find all combinations of k employees for team in combinations(employees, k): if is_clique(team): valid_teams += 1 return valid_teams"},{"question":"You are given a list of `n` courses labeled from `0` to `n-1` and a list of prerequisites `prereq`, where `prereq[i] = [ai, bi]` indicates that you must complete course `bi` before taking course `ai`. Determine if it is possible to finish all courses given the prerequisite conditions. If it is possible, return `true`. Otherwise, return `false`.","solution":"def can_finish(num_courses, prerequisites): from collections import defaultdict, deque def has_cycle(vertex, adj_list, visited, rec_stack): visited[vertex] = True rec_stack[vertex] = True for neighbor in adj_list[vertex]: if not visited[neighbor]: if has_cycle(neighbor, adj_list, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[vertex] = False return False adj_list = defaultdict(list) for course, prereq in prerequisites: adj_list[prereq].append(course) visited = [False] * num_courses rec_stack = [False] * num_courses for course in range(num_courses): if not visited[course]: if has_cycle(course, adj_list, visited, rec_stack): return False return True"},{"question":"Write a function that takes in a non-negative integer `num` and returns its next higher permutation. A permutation of a number is just a rearrangement of its digits. The next higher permutation of a number is the smallest number that is greater than `num` that can be formed by rearranging its digits. If no such permutation exists, return `-1`.","solution":"def next_higher_permutation(num): Given a non-negative integer, returns its next higher permutation. If no such permutation exists, returns -1. # Convert the number to a list of digits digits = list(str(num)) # Find the pivot, the point (from right) where the digit decreases pivot = -1 for i in range(len(digits) - 2, -1, -1): if digits[i] < digits[i + 1]: pivot = i break if pivot == -1: return -1 # No higher permutation possible # Find the smallest digit on the right side of the pivot which is larger than digits[pivot] for j in range(len(digits) - 1, pivot, -1): if digits[j] > digits[pivot]: # Swap digits[j] and digits[pivot] digits[j], digits[pivot] = digits[pivot], digits[j] break # Reverse the digits to the right of the pivot next_perm = digits[:pivot + 1] + digits[pivot + 1:][::-1] return int(\\"\\".join(next_perm))"},{"question":"You are given a string `s` representing a sequence of characters, and a string `t` representing a sequence of characters that you need to form using the characters from `s`. Find the minimum length of the contiguous substring of `s` that contains all the characters of `t` (including duplicates). If there is no such substring, return an empty string.","solution":"from collections import Counter def min_window(s, t): Finds the minimum length of the contiguous substring of s that contains all characters of t. If no such substring exists, returns an empty string. if not t or not s: return \\"\\" t_count = Counter(t) required = len(t_count) l, r = 0, 0 formed = 0 window_counts = {} min_len = float(\\"inf\\") min_window = (0, 0) while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in t_count and window_counts[character] == t_count[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_len: min_len = r - l + 1 min_window = (l, r) window_counts[character] -= 1 if character in t_count and window_counts[character] < t_count[character]: formed -= 1 l += 1 r += 1 l, r = min_window return s[l:r+1] if min_len != float(\\"inf\\") else \\"\\""},{"question":"- [Question 4]: You are implementing a library system where users can borrow and return books. Each `book` is a **string** representing its title. The system keeps track of which books are currently borrowed and which ones are available. Implement the `LibrarySystem` class: - `LibrarySystem()` Initializes the object. - `int addBook(String book)` Adds a `book` to the library\'s collection. Return the `bookId` associated with the book. - `void removeBook(int bookId)` If there is a book associated with `bookId`, remove the book from the library\'s collection. - `boolean borrowBook(int bookId)` If the book associated with `bookId` is available, mark it as borrowed and return `true`. Otherwise, return `false`. - `boolean returnBook(int bookId)` If the book associated with `bookId` is currently borrowed, mark it as available and return `true`. Otherwise, return `false`. - `List<String> getAvailableBooks()` Return the list of currently available book titles sorted in alphabetical order.","solution":"class LibrarySystem: def __init__(self): self.books = {} self.next_book_id = 1 self.borrowed_books = set() def addBook(self, book): book_id = self.next_book_id self.books[book_id] = book self.next_book_id += 1 return book_id def removeBook(self, book_id): if book_id in self.books: del self.books[book_id] self.borrowed_books.discard(book_id) def borrowBook(self, book_id): if book_id in self.books and book_id not in self.borrowed_books: self.borrowed_books.add(book_id) return True return False def returnBook(self, book_id): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) return True return False def getAvailableBooks(self): available_books = [self.books[book_id] for book_id in self.books if book_id not in self.borrowed_books] return sorted(available_books)"},{"question":"You are designing an online shopping cart system for a bookstore. The system keeps a list of book prices in an array, where each element represents the price of a single book. You are required to implement a feature that applies a special discount on certain books. The discount applies only once per book and is represented as another array of the same length where each element denotes the discount for the corresponding book. Your task is to calculate the total cost after applying the discount rule. The discount for a book can only be applied if the book’s price is at least twice the discount amount. If it cannot be applied, the original book price is used. Given two arrays of integers, `prices` and `discounts` of the same length, return _the total cost of the books after applying the discounts appropriately_.","solution":"def total_cost(prices, discounts): This function calculates the total cost of books after applying the discounts appropriately. Parameters: prices (list of int): List of book prices. discounts (list of int): List of discounts corresponding to each book. Returns: int: The total cost after applying the discounts. total = 0 for price, discount in zip(prices, discounts): if price >= 2 * discount: total += price - discount else: total += price return total"},{"question":"You are given a binary matrix `grid` of size `m x n` where each cell is either `0` (representing an empty space) or `1` (representing an obstacle). You want to find the shortest path from the top-left corner of the grid (i.e., `grid[0][0]`) to the bottom-right corner (i.e., `grid[m-1][n-1]`) while avoiding obstacles. You can move up, down, left, or right at each step. Return _the length of the shortest path that avoids obstacles_, or `-1` if there is no such path. Note: The path must not pass through any obstacles, and the start and end cells are always empty.","solution":"from collections import deque def shortestPathBinaryMaze(grid): Finds the shortest path in a binary maze avoiding obstacles. :param grid: List[List[int]] A binary matrix where 0 is an empty cell and 1 is an obstacle. :return: Integer The length of the shortest path from the top-left to the bottom-right avoiding obstacles, or -1 if there is no such path. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given an integer array `nums` sorted in non-decreasing order and an integer `target`. Suppose an integer is inserted into this array, the positions of the other elements do not change, you need to find the indices of the `target` value in the array after the insertion. If the `target` is not found in the array, return `[-1, -1]`. The positions should be given in a list `[first_occurrence, last_occurrence]`. For example, given `nums = [1, 2, 2, 3, 4]` and `target = 2`, the output should be `[1, 2]`, as the target `2` is found at indices `1` and `2`. If the target is not in the list, for instance, `target = 5`, the output should be `[-1, -1]`.","solution":"def find_target_indices(nums, target): Returns the first and last indices of the target in the sorted list of nums. If target is not found, return [-1, -1] if not nums: return [-1, -1] first_occurrence = -1 last_occurrence = -1 # Find first occurrence for i in range(len(nums)): if nums[i] == target: first_occurrence = i break # If target is not found, return [-1, -1] if first_occurrence == -1: return [-1, -1] # Find last occurrence for j in range(len(nums) - 1, -1, -1): if nums[j] == target: last_occurrence = j break return [first_occurrence, last_occurrence]"},{"question":"Given a list of strings `words` and an integer `k`, return the `k` most frequent strings. If there are multiple strings with the same frequency, the strings should be ordered lexicographically. You must answer this with a time complexity better than O(n log n), where n is the length of `words`. Implement the following method: * `List<String> topKFrequent(String[] words, int k)` - Returns a list of the `k` most frequent strings in the given array of `words` following the mentioned criteria.","solution":"from typing import List, Tuple import collections import heapq def topKFrequent(words: List[str], k: int) -> List[str]: Returns the k most frequent strings in the given array of words. If there are multiple strings with the same frequency, they are ordered lexicographically. # Count the frequency of each word count = collections.Counter(words) # Create a heap based on (-frequency, word) to get the k most frequent elements heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) # Extracting the top k elements from the heap result = [heapq.heappop(heap)[1] for _ in range(k)] return result"},{"question":"You are given an array of `n` integers. A **domino pair** is defined as a pair of integers `(a, b)` in the array such that both `a` and `b` have the same digits in some order. For example, `(123, 321)` and `(142, 241)` are domino pairs, while `(123, 124)` is not. Return the number of unique domino pairs in the array.","solution":"from collections import defaultdict def count_domino_pairs(arr): Returns the number of unique domino pairs in the array such that both integers in the pair have the same digits in some order. :param arr: List of integers :return: Number of unique domino pairs def get_canonical_form(num): Return the canonical form of a number by sorting its digits. return \'\'.join(sorted(str(num))) # Dictionary to count occurrences of each canonical form canonical_count = defaultdict(int) # Count occurrences of each canonical form for num in arr: canonical_form = get_canonical_form(num) canonical_count[canonical_form] += 1 # Calculate the number of unique domino pairs pairs_count = 0 for count in canonical_count.values(): if count > 1: pairs_count += count * (count - 1) // 2 return pairs_count"},{"question":"A robot can move in a grid represented by a matrix where each cell contains a non-negative integer minimum cost to enter. The robot starts at the top-left corner and aims to reach the bottom-right corner of the grid. The robot can only move either down or right at any point in time. Given a `m x n` grid `cost`, return the minimum cost required for the robot to reach the bottom-right corner from the top-left corner.","solution":"def min_cost_path(cost): Returns the minimum cost required for the robot to reach the bottom-right corner from the top-left corner. The robot can only move either down or right at any point in time. Args: cost: List of List of ints, representing the cost grid. Returns: int, the minimum cost to reach the bottom-right corner. if not cost or not cost[0]: return 0 m, n = len(cost), len(cost[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = cost[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[m-1][n-1]"},{"question":"A warehouse has a rectangular grid of `m x n` cells representing storage units, where each cell is either empty or filled with inventory. Each cell in the grid is represented by a 1 if it is filled and a 0 if it is empty. Starting from the top-left corner, you can only move right or down to another empty cell (0). Your goal is to find the number of unique paths from the top-left corner to the bottom-right corner of the grid. Given a binary matrix `grid`, return an integer representing the number of unique paths to reach the bottom-right corner from the top-left corner. If there is no valid path, return 0.","solution":"def unique_paths(grid): Given a binary matrix grid, returns the number of unique paths from the top-left corner to the bottom-right corner. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # DP table for storing the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given a **0-indexed** array of integers `temperatures` representing the daily temperatures for a given period. Write an algorithm to determine the number of days one would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` in that spot instead. For example, given the array `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. Return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_.","solution":"def daily_temperatures(temperatures): Returns an array where each element is the number of days one would have to wait until a warmer temperature. If there is no future day for which this is possible, the element is 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: previous_day = stack.pop() answer[previous_day] = i - previous_day stack.append(i) return answer"},{"question":"You have a string `s` consisting only of letters \'x\' and \'y.\' You can swap any two characters in the string at most once. Return the minimum number of \'xy\' or \'yx\' pairs that can be formed in the resulting string.","solution":"def min_pairs(s): Returns the minimum number of \'xy\' or \'yx\' pairs that can be formed by swapping any two characters in the string at most once. x_count = s.count(\'x\') y_count = s.count(\'y\') # In case both counts are zero, no pairs can be formed if x_count == 0 or y_count == 0: return 0 # The minimum number of pairs is the smaller count of \'x\' or \'y\' pairs = min(x_count, y_count) return pairs"},{"question":"Given an array of integers `arr` of length `n`, create a function that returns the **length of the shortest subarray** such that the sum of its elements is equal to a given target value `s`. If no such subarray exists, return `-1`. Note that a subarray is a contiguous part of an array.","solution":"def shortest_subarray_with_sum(arr, s): Returns the length of the shortest subarray with sum equal to s. If no such subarray exists, returns -1. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **rooted binary tree** with `n` nodes, where each node is uniquely labeled from `1` to `n`. The root node is labeled `1`, and each node `i` has a value represented by `val[i]`. A **good subtree** is defined as a subtree where the maximum value of its nodes is equal to the minimum value of its nodes. Given the binary tree **root** node and the array `val` of length `n`, return the number of **good subtrees** in the binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def countGoodSubtrees(root, val): Returns the number of good subtrees in the binary tree. A good subtree is defined as one in which all the nodes have the same value. :param root: The root of the binary tree. :param val: List of node values indexed by node labels. :return: Number of good subtrees. def dfs(node): if not node: return 0, True left_count, is_left_good = dfs(node.left) right_count, is_right_good = dfs(node.right) is_good = is_left_good and is_right_good if node.left and val[node.left.val] != val[node.val]: is_good = False if node.right and val[node.right.val] != val[node.val]: is_good = False total_count = left_count + right_count if is_good: total_count += 1 return total_count, is_good total_good_subtrees, _ = dfs(root) return total_good_subtrees"},{"question":"Given a matrix `mat` of size m x n, where `mat[i][j]` is either 0 or 1. If a cell has the value 0, then the cell is considered dead, otherwise, it is alive. A cell can become alive or dead in the next generation based on the following rules derived from its 8 neighboring cells: - Any live cell with fewer than two live neighbors dies as if caused by under-population. - Any live cell with two or three live neighbors lives on to the next generation. - Any live cell with more than three live neighbors dies, as if by over-population. - Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Given these rules, return the resulting matrix after one generation.","solution":"def game_of_life(mat): Returns the resulting matrix after one generation. def count_live_neighbors(mat, x, y, m, n): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: count += mat[nx][ny] return count m, n = len(mat), len(mat[0]) new_mat = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(mat, i, j, m, n) if mat[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3): new_mat[i][j] = 0 elif mat[i][j] == 1 and (live_neighbors == 2 or live_neighbors == 3): new_mat[i][j] = 1 elif mat[i][j] == 0 and live_neighbors == 3: new_mat[i][j] = 1 return new_mat"},{"question":"Given an integer array `arr` of length `n` where each element represents the number of chocolates in a box, distribute these boxes among `K` children such that: - Each child gets at least one chocolate box. - The total number of chocolates each child receives is as balanced as possible. Return the **minimum possible difference** between the maximum number of chocolates received by a child and the minimum number of chocolates received by a child. Note: You may assume that it is always possible to distribute the chocolates to meet the above conditions.","solution":"def min_difference_in_chocolates(arr, K): Returns the minimum possible difference between the maximum number of chocolates received by a child and the minimum number of chocolates received by a child when the chocolate boxes are distributed among K children. if K == 0 or len(arr) == 0 or K > len(arr): return 0 arr.sort() min_diff = float(\'inf\') for i in range(len(arr) - K + 1): min_diff = min(min_diff, arr[i + K - 1] - arr[i]) return min_diff"},{"question":"Given a linked list, return _the node where the cycle begins_. If there is no cycle, return `null`. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Implement a function `ListNode* detectCycle(ListNode* head)` where `ListNode` is a struct of a singly linked list. To represent a cycle, the `next` pointer for the last node in the list points back to one of the previous nodes.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detect the node where the cycle begins in a linked list. If there is no cycle, return None. if not head or not head.next: return None slow = head fast = head # Check if there\'s a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # No cycle # Find the entrance to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a list of `n` integers, where each integer represents the number of chocolates in a box. Your task is to divide these chocolates into `k` groups such that the difference between the group with the highest number of chocolates and the group with the lowest number of chocolates is minimized. Write a function that returns the minimum possible difference between the largest and the smallest group after dividing the chocolates. Each group must contain at least one box, and each box must belong to exactly one group.","solution":"def min_diff_chocolates(chocolates, k): Given a list of chocolates and an integer k, returns the minimum possible difference between the group with the highest number of chocolates and the group with the lowest number of chocolates after dividing the chocolates into k groups. # Sort the list first chocolates.sort() # The initial solution can be the difference between the highest and the lowest in the subarray min_diff = float(\'inf\') # We iterate through the sorted list to check for possible groupings of size k for i in range(len(chocolates) - k + 1): current_diff = chocolates[i + k - 1] - chocolates[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"You are given an array of strings `words` representing a list of words. Two words are considered to be \\"similar\\" if they can be made identical by swapping at most two characters within one word. Write a function to determine the number of distinct sets of \\"similar\\" words in the given list. A set of \\"similar\\" words is defined as a group of words where each word is similar to at least one other word in the group. Return _the number of distinct sets of similar words_ as an integer.","solution":"def are_similar(word1, word2): Check if two words are similar by swapping at most two characters. if word1 == word2: return True if len(word1) != len(word2): return False # Finding the positions where the characters differ different_chars = [(w1, w2) for w1, w2 in zip(word1, word2) if w1 != w2] # If there are exactly 2 positions where the characters differ, # check if they can be swapped to make the words identical. if len(different_chars) == 2 and different_chars[0] == different_chars[1][::-1]: return True return False def find_similar_word_sets(words): Determine the number of distinct sets of similar words in the given list. from collections import defaultdict similar_sets = [] for word in words: added = False # Compare the current word with all sets for s in similar_sets: if any(are_similar(word, w) for w in s): s.add(word) added = True break if not added: similar_sets.append({word}) return len(similar_sets)"},{"question":"You are given a list of `n` strings called `words` and an integer `m`. Your task is to determine the length of the **longest** subsequence of `words` where the length of each word in the subsequence is equal to or less than `m`. A subsequence is derived by deleting some or none of the elements in `words` without changing the order of the remaining elements. Return the length of the longest such subsequence.","solution":"def longest_subsequence(words, m): Determines the length of the longest subsequence where the length of each word is less than or equal to m. Args: words (list): List of strings. m (int): The maximum allowed length of the words in the subsequence. Returns: int: The length of the longest subsequence. # Initialize the subsequence length counter length = 0 for word in words: if len(word) <= m: length += 1 return length"},{"question":"You are given an integer array `arr`. A **wave** in the array is defined as a subarray that is either strictly increasing or strictly decreasing. Write a function to find the **longest wave** in `arr`. Return _the length of the longest wave_ found in the array.","solution":"def longest_wave(arr): Finds the length of the longest wave in the given array. A wave is defined as a subarray that is either strictly increasing or strictly decreasing. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest wave in the array. if not arr: # If the array is empty, return 0 return 0 n = len(arr) max_length = 1 current_length = 1 # Loop to find the strictly increasing waves for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) current_length = 1 # Loop to find the strictly decreasing waves for i in range(1, n): if arr[i] < arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"Given a **0-indexed** integer array `arr` of size `n`, return the length of the shortest subarray containing at least one instance of each distinct element in `arr`. You may assume that the array contains at least one element and all elements have counts of at least one.","solution":"def shortest_subarray_with_all_distinct_elements(arr): Returns the length of the shortest subarray containing at least one instance of each distinct element in the array. from collections import defaultdict # Get the set of all distinct elements distinct_elements = set(arr) num_distinct = len(distinct_elements) n = len(arr) # Dictionary to store the count of each element in the current window current_counts = defaultdict(int) left = 0 shortest_length = n # Number of distinct elements in the current window distinct_in_window = 0 # Expand the window with right pointer for right in range(n): current_counts[arr[right]] += 1 if current_counts[arr[right]] == 1: distinct_in_window += 1 # If the current window contains all distinct elements, contract the window from the left while distinct_in_window == num_distinct: shortest_length = min(shortest_length, right - left + 1) current_counts[arr[left]] -= 1 if current_counts[arr[left]] == 0: distinct_in_window -= 1 left += 1 return shortest_length"},{"question":"Given an integer `num`, find the largest palindrome that is less than `num` and return it. A palindrome is a number that reads the same backward as forward (e.g., `121`, `1221`). If there is no such palindrome, return `-1`. Your solution should have a time complexity of `O(log(num))`.","solution":"def largest_palindrome_less_than(num): Returns the largest palindrome less than the given num. If no such palindrome exists, it returns -1. if num <= 10: # The smallest 2-digit palindrome is 11, hence num should be > 10 return -1 def is_palindrome(x): s = str(x) return s == s[::-1] for candidate in range(num - 1, 9, -1): if is_palindrome(candidate): return candidate return -1"},{"question":"You are given an array `points` where `points[i]` represents the number of points scored by player `i` in a series of games. There are 2 players named Alice and Bob. Alice always scores in even-indexed games (0, 2, 4, ...) and Bob always scores in odd-indexed games (1, 3, 5, ...). Write a function to determine the winner by returning the name of the player with the higher total score. If both players have the same score, return \\"Tie\\".","solution":"def determine_winner(points): alice_score = sum(points[i] for i in range(0, len(points), 2)) bob_score = sum(points[i] for i in range(1, len(points), 2)) if alice_score > bob_score: return \\"Alice\\" elif bob_score > alice_score: return \\"Bob\\" else: return \\"Tie\\""},{"question":"Given a string `s`, find the length of the longest substring without repeating characters. Analyze the time complexity of your solution.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_index_map and char_index_map[char] >= left: left = char_index_map[char] + 1 char_index_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array `jobs` where `jobs[i]` represents the amount of time required to complete the `i-th` job. There are `k` workers available to complete these jobs. Each worker can be assigned one or more consecutive jobs. However, they can only work on one job at a time. Your task is to minimize the time it takes for the last worker to finish all their jobs. Return the minimum possible time needed for the last worker to complete their assigned jobs.","solution":"def min_time(jobs, k): def is_feasible(time_limit): worker_count = 1 current_time = 0 for job in jobs: if current_time + job <= time_limit: current_time += job else: worker_count += 1 current_time = job if worker_count > k: return False return True left, right = max(jobs), sum(jobs) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a **0-indexed** integer array `arr`. A **mountain subarray** is a subarray that includes at least three elements and satisfies the following condition: there exists some index `k` with `0 < k < length of subarray - 1` such that: - arr[k] > arr[k-1] - arr[k] > arr[k+1] - arr[i] < arr[i+1] for all `0 <= i < k` - arr[j] > arr[j+1] for all `k <= j < length of subarray - 1` Return _the length of the longest **mountain subarray** in `arr`_. If there is no **mountain subarray**, return `0`.","solution":"def longest_mountain(arr): if len(arr) < 3: return 0 longest = 0 n = len(arr) for i in range(1, n - 1): if arr[i-1] < arr[i] > arr[i+1]: left = i - 1 right = i + 1 while left > 0 and arr[left-1] < arr[left]: left -= 1 while right < n - 1 and arr[right+1] < arr[right]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"A company is scheduling interviews for a list of candidates. Each candidate is represented by their availability as a list of integer pairs where each pair `[startTime, endTime]` denotes a time slot during which the candidate is available. Given a 2D array `schedules`, where `schedules[i]` is the list of availability pairs for candidate `i`, find the common free time slots across all candidates for scheduling a meeting. A free time slot is defined as a time period that is common to all candidates and during which at least one hour is available. Return a list of all common free time slots sorted by the start time. Note: The free time slots should be represented as a list of integer pairs `[startTime, endTime]`. [Example input/output specifications can be used to clarify the question, and additional constraints or edge cases might be provided as necessary based on your guidelines.]","solution":"def common_free_time(schedules): from heapq import merge # Merge all availability slots across all candidates into one list merged_schedules = list(merge(*schedules, key=lambda x: x[0])) # Consolidate overlapping intervals from the merged list consolidated_intervals = [] for interval in merged_schedules: if not consolidated_intervals or consolidated_intervals[-1][1] < interval[0]: consolidated_intervals.append(interval) else: consolidated_intervals[-1][1] = max(consolidated_intervals[-1][1], interval[1]) # Find common free time slots from the consolidated intervals common_free_intervals = [] for i in range(1, len(consolidated_intervals)): if consolidated_intervals[i][0] - consolidated_intervals[i-1][1] >= 1: common_free_intervals.append([consolidated_intervals[i-1][1], consolidated_intervals[i][0]]) return common_free_intervals"},{"question":"You are given a weighted, directed graph with `n` nodes and `m` edges. Each edge is represented as a tuple `(u, v, w)` indicating an edge from node `u` to node `v` with weight `w`. The nodes are numbered from `0` to `n-1`. You are also given a starting node `start`. Implement a class `ShortestPathCalculator` that provides the following functionalities: * `ShortestPathCalculator(int n, int[][] edges, int start)` Initializes the object with the number of nodes, the edges array, and the starting node. * `int getShortestPath(int target)` Returns the shortest path from the starting node to the target node using Dijkstra\'s algorithm. If the target node is not reachable, return `-1`. To clarify, the graph does not have negative weights, and you can assume that the input graph is correctly formatted and that the starting node is always a valid node within the graph.","solution":"import heapq class ShortestPathCalculator: def __init__(self, n, edges, start): self.n = n self.edges = edges self.start = start self.adj_list = {i: [] for i in range(n)} for u, v, w in edges: self.adj_list[u].append((v, w)) def getShortestPath(self, target): distances = {i: float(\'inf\') for i in range(self.n)} distances[self.start] = 0 priority_queue = [(0, self.start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.adj_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[target] if distances[target] != float(\'inf\') else -1"},{"question":"You are given an integer array `cards`, where `cards[i]` represents the number on the `i-th` card. We need to pick a pair of indices `(i, j)` such that `i != j` and both `cards[i]` and `cards[j]` have the same value. Return _the minimum distance between such a pair of indices_. If no such pair exists, return `-1`.","solution":"def minimumCardPickup(cards): Returns the minimum distance between pairs of indices (i, j) such that cards[i] == cards[j]. If no such pairs exist, returns -1. last_seen = {} min_distance = float(\'inf\') for i, card in enumerate(cards): if card in last_seen: min_distance = min(min_distance, i - last_seen[card]) last_seen[card] = i return min_distance if min_distance != float(\'inf\') else -1"},{"question":"You are given a list of meeting time intervals `intervals` where `intervals[i] = [start_i, end_i]`, representing the start and end times of the `i`-th meeting. You need to determine if a person could attend all meetings without any overlap. Implement the function `canAttendMeetings(int[][] intervals)`: * `boolean canAttendMeetings(int[][] intervals)` Returns `true` if the person can attend all meetings without any overlap, otherwise return `false`. The function should efficiently determine whether any two meeting intervals overlap.","solution":"def canAttendMeetings(intervals): Determine if a person can attend all meetings without any overlap. Args: intervals (List[List[int]]): List of meeting time intervals Returns: bool: True if a person can attend all meetings without overlap, False otherwise if not intervals: return True # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # If the current meeting starts before the previous one ends, there\'s an overlap if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"You are given a **0-indexed** array of integers `nums`. You need to find the length of the longest subarray that contains at most two distinct integers. The subarray should be contiguous, and you must maintain the relative order of the original elements. Return _the length of the longest subarray with at most two distinct integers_.","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray with at most two distinct integers. if not nums: return 0 left = 0 right = 0 max_len = 0 count = {} while right < len(nums): if nums[right] in count: count[nums[right]] += 1 else: count[nums[right]] = 1 while len(count) > 2: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"You are given a string `s` and an array `queries` where each query is represented as an array of two integers `[start, end]`. Each query represents a substring of `s` starting at index `start` and ending at index `end` (inclusive). Return an array where each element is the length of the longest palindromic substring within the respective query substring. A palindrome is a string that reads the same forward and backward.","solution":"def longest_palindromic_substring(s, queries): def find_longest_palindrome_at(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] def longest_palindrome(s): result = \\"\\" for i in range(len(s)): # Find the longest odd-length palindrome with center at i palindrome_odd = find_longest_palindrome_at(s, i, i) if len(palindrome_odd) > len(result): result = palindrome_odd # Find the longest even-length palindrome with centers at i and i+1 palindrome_even = find_longest_palindrome_at(s, i, i + 1) if len(palindrome_even) > len(result): result = palindrome_even return len(result) results = [] for start, end in queries: substring = s[start:end+1] results.append(longest_palindrome(substring)) return results"},{"question":"You are given a string `s` consisting of lowercase alphabets. A substring is defined as a continuous segment of a string. Your task is to find the length of the longest substring of `s` such that the frequency of each character in this substring is an even number. Return the length of the longest such substring. If no such substring exists, return 0.","solution":"def longest_even_frequency_substring(s): Finds the length of the longest substring where the frequency of each character is even. Args: s (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest substring with each character\'s frequency even. def is_even_frequency(substring): Checks if all characters in the substring have even frequencies. Args: substring (str): The input substring. Returns: bool: True if all characters have even frequencies, False otherwise. from collections import Counter counter = Counter(substring) for count in counter.values(): if count % 2 != 0: return False return True n = len(s) max_length = 0 for i in range(n): for j in range(i + 1, n + 1): if is_even_frequency(s[i:j]): max_length = max(max_length, j - i) return max_length"},{"question":"Given an array of positive integers `arr` and a number `m`, partition the array into _m contiguous subarrays_ such that the largest sum of any subarray among the m subarrays is minimized. Return this minimized largest sum. For example, if `arr = [7, 2, 5, 10, 8]` and `m = 2`, one optimal way to partition the array is `[7, 2, 5]` and `[10, 8]`, with the sums `14` and `18`. The minimized largest sum is `18`.","solution":"def splitArray(nums, m): Partition the array into m contiguous subarrays such that the largest sum of any subarray among the m subarrays is minimized. Return this minimized largest sum. def canPartition(arr, m, maxSum): count, subarraySum = 1, 0 for n in arr: subarraySum += n if subarraySum > maxSum: count += 1 subarraySum = n if count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canPartition(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `arr` and an integer `x`. A **subsequence** of `arr` is any sequence that can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements. Return _the length of the longest increasing subsequence_ of `arr` such that the sum of the subsequence elements is less than or equal to `x`.","solution":"def length_of_lis_with_sum_constraint(arr, x): Returns the length of the longest increasing subsequence (LIS) of arr such that the sum of the subsequence elements is less than or equal to x. n = len(arr) dp = [[0] * (x + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(x + 1): if arr[i - 1] <= j: dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - arr[i - 1]]) else: dp[i][j] = dp[i - 1][j] return max(dp[n])"},{"question":"You are given a 2D integer array `intervals` where `intervals[i] = [start_i, end_i]` represents the `i-th` interval. A single query is represented by an integer `point` which needs to be checked against these intervals. Implement the `Intervals` class: * `Intervals(int[][] intervals)` Initializes the object with the given 2D integer array `intervals`. * `boolean query(int point)` Returns `true` if the given `point` is within any of the intervals in `intervals` (inclusive), otherwise returns `false`. For example, given `intervals = [[1, 3], [5, 8]]`, a query with `point = 4` should return `false`, and a query with `point = 5` should return `true`.","solution":"class Intervals: def __init__(self, intervals): Initializes the object with the given 2D integer array intervals. self.intervals = intervals def query(self, point): Returns true if the given point is within any of the intervals in intervals (inclusive), otherwise returns false. for start, end in self.intervals: if start <= point <= end: return True return False"},{"question":"You are given a **string** `s` consisting solely of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Determine if the input string is valid. An input string is valid if: * Open brackets must be closed by the same type of brackets. * Open brackets must be closed in the correct order. * Every close bracket has a corresponding open bracket of the same type. Return _true_ if the string is valid, and _false_ otherwise. Use a stack data structure to solve this problem.","solution":"def is_valid(s): Determine if the input string s consisting of brackets is valid. :param s: A string consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' :return: True if the string is valid, False otherwise stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given a list of unique integers `numbers` and an integer `target`. Your goal is to find all unique pairs of integers in the list that sum up to the `target`. Return these pairs as a list of tuples. Each pair should be ordered such that the smaller number appears first. The list of tuples itself should be sorted in lexicographical order. For example, given the list `numbers = [2, 4, 3, 5, 7, 1, -1, 0]` and `target = 6`, the function should return `[(1, 5), (-1, 7), (2, 4)]`.","solution":"def find_pairs(numbers, target): Returns a list of tuples where each tuple contains pairs of numbers that add up to the target. Each pair is sorted in ascending order and the list of pairs is sorted lexicographically. found_pairs = set() numbers_set = set(numbers) for num in numbers: complement = target - num if complement in numbers_set: pair = tuple(sorted((num, complement))) if pair[0] != pair[1]: found_pairs.add(pair) return sorted(found_pairs)"},{"question":"You are given a linked list where the nodes contain an integer value `val` and a pointer to the next node. Implement a function to remove nodes from the linked list that have duplicate values, keeping only the last occurrence of each number. Return the new head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from the linked list, keeping only the last occurrence of each number. Returns the new head of the modified linked list. if not head: return None # Use a dictionary to remember the last occurrence of each value last_occurrence = {} current = head while current: last_occurrence[current.val] = current current = current.next # Create a dummy node to handle the edge case of head removal dummy = ListNode(0) dummy.next = head prev = dummy current = head while current: if current == last_occurrence[current.val]: prev = current else: prev.next = current.next current = current.next return dummy.next"},{"question":"You are given a list of `n` integers, `nums`, and an integer `target`. Return _all unique combinations of elements from `nums` that add up to `target`, where each element may be used an unlimited number of times_. The combinations can be returned in **any order**.","solution":"def combinationSum(nums, target): Returns all unique combinations of elements from nums that add up to target, where each element may be used an unlimited number of times. result = [] def backtrack(remaining, combination, start): if remaining == 0: result.append(list(combination)) return elif remaining < 0: return for i in range(start, len(nums)): combination.append(nums[i]) backtrack(remaining - nums[i], combination, i) combination.pop() backtrack(target, [], 0) return result"},{"question":"Given a circular array `nums` of positive integers, return the array consisting of the cumulative sums in the circular manner. Specifically, for each `i` in `0` to `n-1` (where `n` is the length of `nums`), the cumulative sum at index `i` should be `nums[i]` plus all preceding elements considering the circular nature of the array.","solution":"def circular_cumulative_sums(nums): Returns the cumulative sums in a circular manner for the given array of positive integers. n = len(nums) cumulative_sum = [0] * n for i in range(n): total = 0 for j in range(n): total += nums[(i + j) % n] cumulative_sum[i] = total return cumulative_sum"},{"question":"Given an integer array `nums`, find the sum of the elements between indices `i` and `j` (i ≤ j), inclusive. The array is immutable. Implement the `NumArray` class: ```python class NumArray: def __init__(self, nums: List[int]): Initialize your data structure here. def sumRange(self, i: int, j: int) -> int: Return the sum of the elements between indices i and j (i ≤ j), inclusive. ``` You need to implement the `__init__` method to store the array and the `sumRange` method to return the sum of the specified range.","solution":"class NumArray: def __init__(self, nums): Initialize your data structure here. self.nums = nums self.pre_sum = [0] * (len(nums) + 1) for i in range(len(nums)): self.pre_sum[i + 1] = self.pre_sum[i] + nums[i] def sumRange(self, i, j): Return the sum of the elements between indices i and j (i ≤ j), inclusive. return self.pre_sum[j + 1] - self.pre_sum[i]"},{"question":"A frog is currently located at the origin of a number line (`0`). The frog can make jumps of exactly `k` units to either the left or the right. Given a destination point `d` on the number line, determine whether the frog can reach the destination `d` using any number of `k`-unit jumps, and return a boolean value. Example: For `k = 3` and `d = 9`, the return value should be `True` as the frog can jump three times to the right (3 + 3 + 3 = 9). For `k = 5` and `d = 7`, the return value should be `False` as the frog cannot reach 7 with jumps of 5 units.","solution":"def can_frog_reach_destination(k, d): Determines if the frog can reach the destination `d` with jumps of `k` units. Parameters: k (int): The unit length of each jump d (int): The destination point on the number line Returns: bool: True if the frog can reach the destination, False otherwise # If the distance to the destination is a multiple of k, the frog can reach it return d % k == 0"},{"question":"Given a list of `n` integers, divide the list into exactly `k` contiguous subarrays so as to maximize the minimum sum among these subarrays. _Return the maximum possible value of the minimum sum among these subarrays._ This can be done using binary search and greedy algorithms if needed.","solution":"def maximize_min_sum(nums, k): def is_possible(mid): current_sum, cnt = 0, 1 for num in nums: if current_sum + num > mid: cnt += 1 current_sum = 0 if cnt > k: return False current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if is_possible(mid): high = mid else: low = mid + 1 return low"},{"question":"Given a `2D` integer matrix `grid`, find the maximum sum of a rectangle in the matrix. A rectangle is defined as any group of contiguous cells in the `grid` that forms a rectangle. The selection of cells must form a proper rectangular shape with sides parallel to the grid. Return _the maximum sum of any rectangle in the grid_.","solution":"def max_sum_rectangle(grid): Returns the maximum sum of any rectangular subarray within a 2D integer matrix `grid`. if not grid: return 0 rows, cols = len(grid), len(grid[0]) max_sum = float(\'-inf\') # Iterate over all pairs of rows for top in range(rows): row_sum = [0] * cols for bottom in range(top, rows): for col in range(cols): row_sum[col] += grid[bottom][col] # Apply Kadane\'s algorithm on the row_sum array to find the # maximum sum subarray which will represent the maximum # sum rectangle for the current pair of rows current_sum = 0 max_current_sum = float(\'-inf\') for value in row_sum: current_sum = max(value, current_sum + value) max_current_sum = max(max_current_sum, current_sum) max_sum = max(max_sum, max_current_sum) return max_sum"},{"question":"You are given two strings `s1` and `s2`. A valid transformation from `s1` to `s2` is defined by the following operations: 1. **Insert** a character at any position. 2. **Remove** any character. 3. **Replace** any character with another character. Return the minimum number of operations required to transform `s1` into `s2`.","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. The operations are insert, remove, or replace a character. m = len(s1) n = len(s2) # Create a DP table to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases for i in range(m + 1): for j in range(n + 1): if i == 0: # Transform empty string to s2[:j] requires j insertions dp[i][j] = j elif j == 0: # Transform s1[:i] to empty string requires i deletions dp[i][j] = i elif s1[i - 1] == s2[j - 1]: # No operation needed if characters match dp[i][j] = dp[i - 1][j - 1] else: # Calculate minimum edit distance if characters don\'t match insert_op = dp[i][j - 1] remove_op = dp[i - 1][j] replace_op = dp[i - 1][j - 1] dp[i][j] = 1 + min(insert_op, remove_op, replace_op) return dp[m][n]"},{"question":"A sequence of integers is called a **zigzag sequence** if the differences between successive elements strictly alternate between positive and negative. For example, `[1, 3, 2, 4, 3]` is a zigzag sequence because the differences `(2, -1, 2, -1)` alternate between positive and negative. Given an array `nums`, return _the length of the longest zigzag subsequence of the array_. A **subsequence** is obtained by deleting some number of elements (possibly zero) from the array, leaving the remaining elements in their original order.","solution":"def longest_zigzag_subsequence(nums): Returns the length of the longest zigzag subsequence of the array nums. if not nums: return 0 n = len(nums) if n == 1: return 1 up = 1 down = 1 for i in range(1, n): if nums[i] > nums[i - 1]: up = down + 1 elif nums[i] < nums[i - 1]: down = up + 1 return max(up, down)"},{"question":"Given a 2D integer grid `grid` consisting of `0`s (empty space) and `1`s (obstacles), count the number of unique paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time and cannot move through obstacles. Return the total number of unique paths. If there is no valid path, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right of the grid. You can only move either down or right at any point in time and cannot move through obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"You are given a **0-indexed** array of positive integers `nums` and an integer `goal`. Your task is to find the length of the smallest contiguous subarray whose sum is greater than or equal to `goal`. If no such subarray exists, return `-1`. **Example**: ```plaintext Input: nums = [2,3,1,2,4,3], goal = 7 Output: 2 Explanation: The subarray [4,3] has the minimum length under the problem\'s constraints. ``` **Example**: ```plaintext Input: nums = [1,1,1,1,1,1,1,1], goal = 11 Output: -1 Explanation: No subarray has a sum greater than or equal to 11. ```","solution":"def min_subarray_length(nums, goal): n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= goal: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Consider a binary search tree (BST) with unique values. Design and implement a class `BSTIterator` that iterates through the elements of the BST in ascending order. The `BSTIterator` class should have the following methods: * `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class with the root node of the binary search tree. * `int next()` Returns the next smallest number in the BST. * `boolean hasNext()` Returns `true` if there exists a next number in the BST, otherwise returns `false`. The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"You are given a string `s` representing an encoded message. The message is encoded by replacing each letter with its corresponding number (\'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26) and then combining several such numbers into a single string. Determine the total number of ways to decode the string `s`, where valid decodings match the original letter-number mapping. For example, given the string `s = \\"12\\"`, it can be decoded as `\\"AB\\"` (1 2) or `\\"L\\"` (12). Return the number of possible decodings for the given string. The input string `s` will only contain numeric characters and will be non-empty.","solution":"def num_decodings(s): Returns the number of ways to decode the given encoded message. :param s: A string representing an encoded message :type s: str :return: The number of possible decodings :rtype: int if not s or s[0] == \\"0\\": return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Given a string `s` consisting of only letters \'a\' and \'b\', you can delete any two adjacent letters if they are different. Your goal is to delete the minimum number of characters so that you can make the string empty. Return the minimum number of deletions needed to make the string empty. If it is not possible to make the string empty, return `-1`.","solution":"def min_deletions_to_empty(s): Returns the minimum number of deletions needed to make the string empty. Deletions can only occur if two adjacent letters are different. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(s) - len(stack) if not stack else -1"},{"question":"You are given a linked list where each node contains an integer value. Write a function to **reverse** the linked list and return the new head of the reversed list. Do not use any extra space for another linked list but reverse the pointers in-place. For example, if the linked list is `1 -> 2 -> 3 -> 4 -> 5`, then after reversing it, it should become `5 -> 4 -> 3 -> 2 -> 1`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head): Reverses the linked list and returns the new head of the reversed list. previous = None current = head while current: next_node = current.next current.next = previous previous = current current = next_node return previous"},{"question":"Given an unsorted array `arr` of length `n`, find the length of the longest consecutive elements sequence. Returning only the length of the sequence. The consecutive numbers can be in any order in the array. Example: For `arr = [100, 4, 200, 1, 3, 2]` Output: `4` (The longest consecutive sequence is [1, 2, 3, 4]). Return the length of the longest consecutive elements sequence. You must implement a solution with a linear runtime complexity.","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence. if not arr: return 0 num_set = set(arr) max_length = 0 for num in arr: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a list of student `results` where each element is a tuple containing a student\'s name and their score on a test. Write a program to determine the highest and second highest scores among the students and return the corresponding student names in a list. If there is a tie for the highest or second highest scores, consider the student who first achieved the score. If no second highest score exists, return a list containing only the name of the student with the highest score.","solution":"def find_top_two_students(results): Given a list of tuples (student_name, score), return a list containing the names of the students with the highest and second highest scores. If no second highest score exists, return only the highest scoring student\'s name. if not results: return [] first = second = float(\'-inf\') first_student = second_student = None for name, score in results: if score > first: second, second_student = first, first_student first, first_student = score, name elif first > score > second: second, second_student = score, name if second_student is not None: return [first_student, second_student] else: return [first_student]"},{"question":"You are given a 2D grid of size `m x n` representing a map of land (`1`) and water (`0`). An island is a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. You need to remove exactly one island from the grid so that there is at most one island left. An island is removed by changing all `1`s to `0`s in that area. Return the minimum number of `1`s that need to be changed to `0`s in order to achieve this. If it is not possible to have at most one island left after removing exactly one island, return `-1`.","solution":"def min_island_removal(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): stack = [(x, y)] island_cells = [] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and not visited[cx][cy] and grid[cx][cy] == 1: visited[cx][cy] = True island_cells.append((cx, cy)) for nx, ny in [(cx - 1, cy), (cx + 1, cy), (cx, cy - 1), (cx, cy + 1)]: stack.append((nx, ny)) return island_cells islands = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: islands.append(dfs(i, j)) if len(islands) <= 1: return -1 min_cells = min(len(island) for island in islands) return min_cells"},{"question":"A robot is placed on a 2D grid at the origin (0,0). It is designed to move based on a set of directions: `\'U\'` for up, `\'D\'` for down, `\'L\'` for left, and `\'R\'` for right. Each direction moves the robot one unit in the corresponding direction. However, the robot is a bit defective and sometimes misinterprets a command. Given a string `commands` representing the sequence of directions the robot should follow, and an integer `k` representing the maximum number of moves where the robot can misinterpret the instruction (i.e., a move can result in the robot moving in a random direction any number of times up to `k`), determine if the robot can still return to the origin after following the given commands (considering the possible misinterpretations). Return `true` if the robot can return to the origin, otherwise return `false`.","solution":"def can_return_to_origin(commands, k): Determines if the robot can return to the origin considering possible misinterpretations of up to k moves. Params: commands: str : a string representing sequence of directions (\'U\', \'D\', \'L\', \'R\') k: int : maximum number of moves that can be misinterpreted Returns: bool : True if the robot can return to the origin, False otherwise x, y = 0, 0 # Process the commands to calculate the final position for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 # Calculate the distance from the origin distance = abs(x) + abs(y) # Check if the distance can be adjusted to zero with k misinterpretations if distance <= k: return True return False"},{"question":"You are given an array of integers `heights` representing the heights of trees in a straight row. Your task is to determine if you can cut down every other tree starting from either the first or the second tree while ensuring that no two consecutive trees are left standing. Return `true` if it is possible to perform such an operation, otherwise return `false`.","solution":"def can_cut_trees(heights): Determines if it is possible to cut down every other tree starting from either the first or the second tree such that no two consecutive trees are left standing. Parameters: heights (List[int]): List of integers representing the heights of trees. Returns: bool: True if it is possible to cut down trees as specified, otherwise False. n = len(heights) if n <= 2: return True # Check starting from the first tree valid_from_first = all(heights[i] > max(heights[i+1:i+2]) for i in range(0, n-1, 2)) # Check starting from the second tree valid_from_second = all(heights[i] > max(heights[i+1:i+2]) for i in range(1, n-1, 2)) return valid_from_first or valid_from_second"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. You are also given two integers `start` and `end` such that `0 <= start, end < n`. You can perform the following operation on the array: choose any index `i` (where `0 <= i < n` and `i` is not equal to `start` or `end`), and swap `arr[i]` with `arr[0]`. Your goal is to transform the array such that `arr[start]` and `arr[end]` are swapped. Return _the minimum number of operations required to achieve this transformation_, or `-1` if it is not possible.","solution":"def min_operations_to_swap(arr, start, end): Returns the minimum number of operations required to swap arr[start] with arr[end], or -1 if it is not possible to do so. if start == end: return 0 if 0 in (start, end): return 1 return 2"},{"question":"You are given a list of integers `numbers` representing the prices of items you want to buy. However, due to limited funds, you can only buy two items. Find the maximum sum of money you can spend on exactly two items. If you are unable to buy exactly two items (i.e., the list contains fewer than two items), return `-1`.","solution":"def max_sum_of_two(numbers): Returns the maximum sum of money that can be spent on exactly two items. If fewer than two items are available, returns -1. if len(numbers) < 2: return -1 # Sort the list in descending order and sum the first two elements numbers_sorted = sorted(numbers, reverse=True) return numbers_sorted[0] + numbers_sorted[1]"},{"question":"You are playing a video game where you are a robot stationed at the bottom-left corner of a `m x n` grid. Certain squares on the grid may contain obstacles. The robot can only move either up or right at any point in time. The robot is trying to reach the top-right corner of the grid. Write a function that returns the number of possible unique paths that the robot can take to reach the top-right corner. The obstacles are marked in the grid as `1` and free spaces as `0`. The starting point and the destination are not obstacles. Given a `m x n` integer grid representing the obstacle grid, return the number of unique paths from the bottom-left to the top-right corner.","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of possible unique paths from the bottom-left to the top-right corner of a grid considering obstacles. m = len(obstacleGrid) n = len(obstacleGrid[0]) if obstacleGrid[m-1][0] == 1 or obstacleGrid[0][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[m-1][0] = 1 for i in range(m-1, -1, -1): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i + 1 < m: dp[i][j] += dp[i + 1][j] if j - 1 >= 0: dp[i][j] += dp[i][j - 1] return dp[0][n-1]"},{"question":"You are given a binary tree with `n` nodes. Each node in the binary tree has a value represented by `val`, and a target integer `target`. Your task is to delete all nodes in the tree that have a value equal to `target`, and return the modified tree. Note that after deleting a node with value `target`, you need to attach its children (if any) to the parent of the deleted node. If the deleted node is the root, the new root will be the leftmost child of the deleted node. Write a function to solve this problem and return the root of the resulting binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def delete_node_with_target(root, target): Deletes nodes with the value \'target\' from the binary tree and returns the modified tree root. :param root: TreeNode, the root of the binary tree :param target: int, the target value to delete :return: TreeNode, the root of the modified binary tree if not root: return None # Post-order traversal to process the child nodes first root.left = delete_node_with_target(root.left, target) root.right = delete_node_with_target(root.right, target) if root.val == target: # If the node is a target node if root.left: # Attach right child to the rightmost node of the left subtree rightmost = root.left while rightmost.right: rightmost = rightmost.right rightmost.right = root.right # Return the left child as the new root in case the current root is deleted return root.left else: # If there\'s no left child, return the right child (can be None) return root.right # Return the node itself if it\'s not deleted return root"},{"question":"You are given a binary string `s` that can be transformed by flipping exactly one bit (changing `0` to `1` or `1` to `0`). Your goal is to make the count of `1`s and `0`s in the string as equal as possible after performing the flip operation. If there are multiple positions to flip the bit and achieve the same balance, choose the position that occurs first. Return the index (0-based) of the bit to be flipped in the string to achieve this balance. If the string is already balanced, return -1.","solution":"def flip_to_balance(s): Given a binary string `s`, return the index of the bit to flip to balance the count of \'1\'s and \'0\'s. If the string is already balanced, return -1. count_0 = s.count(\'0\') count_1 = s.count(\'1\') if count_0 == count_1: return -1 if count_0 > count_1: target = \'0\' else: target = \'1\' for index, char in enumerate(s): if char == target: return index return -1 # Default return value, should never hit this line # Example usage: # s = \\"11010\\" # print(flip_to_balance(s)) # Output: 2"},{"question":"Given a binary tree where each node contains an integer value, find the maximum possible sum of the values of nodes on a path such that no two adjacent nodes on the path are directly connected in the tree. A path can start and end at any node in the tree. A node is considered adjacent to another node if it is directly connected to it by an edge in the tree. Return the maximum sum of values for any such path in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_non_adjacent_sum(root): def helper(node): if not node: return 0, 0 left_with, left_without = helper(node.left) right_with, right_without = helper(node.right) with_node = node.val + left_without + right_without without_node = max(left_with, left_without) + max(right_with, right_without) return with_node, without_node return max(helper(root))"},{"question":"You are given a `matrix` of size `m x n` that contains integers. Implement a function to **rotate** the matrix by `90 degrees clockwise`. The rotation should be done i**n-place** with constant extra space usage. The rotated matrix should be returned as the result.","solution":"def rotate_matrix(matrix): Rotates the given m x n matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the matrix to be rotated :return: List[List[int]], the rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given an integer array `arr` consisting of distinct numbers from `1` to `n`, where `n` is the length of the array. Your task is to generate the next lexicographical permutation of the array. If no such permutation exists, return the array sorted in ascending order. The replacement must be performed in place and only use constant extra memory. Return the array after modifying it based on the above rules.","solution":"def nextPermutation(arr): Modifies the input array to its next lexicographical permutation or sorts it if no such permutation exists. n = len(arr) if n <= 1: return arr # Step 1: Find the largest index k such that arr[k] < arr[k + 1] k = n - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # Step 4: If no such k exists, reverse the array to get the smallest permutation arr[:] = arr[::-1] return arr # Step 2: Find the largest index l greater than k such that arr[k] < arr[l] l = n - 1 while arr[k] >= arr[l]: l -= 1 # Step 3: Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4: Reverse the sequence from arr[k + 1] to the end arr[k + 1:] = reversed(arr[k + 1:]) return arr"},{"question":"You are given an array of integers `nums`. A subarray is called a _wiggle_ subarray if the differences between successive elements strictly alternate between positive and negative. In other words, a subarray [x1, x2, ..., xk] is a wiggle subarray if the differences (x2 - x1), (x3 - x2), ..., (xk - xk-1) strictly alternate between positive and negative. Return the length of the longest wiggle subarray in the given array.","solution":"def longest_wiggle_subarray(nums): Returns the length of the longest wiggle subarray. Args: nums: List[int] - a list of integers Returns: int - the length of the longest wiggle subarray if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): if nums[i] > nums[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif nums[i] < nums[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: up[i] = up[i - 1] down[i] = down[i - 1] return max(up[n-1], down[n-1])"},{"question":"You are given two arrays `target` and `arr`, both of which consist of distinct integers. You can rearrange the elements of `arr` in any order. For each operation, you can select any subarray of `arr` and reverse it. _Return_ `true` _if you can transform `arr` into `target` using any number of operations, or_ `false` _otherwise__.","solution":"def can_be_equal(target, arr): Returns True if arr can be transformed into target by reversing any subarray any number of times, False otherwise. return sorted(target) == sorted(arr)"},{"question":"You are given a list of non-negative integers `stations` representing the amount of power each station provides in a line. You have an electric car starting at position 0 and your goal is to reach the farthest position you can using these stations. However, your car can only travel `k` units of distance between stopping at stations to recharge. Return the maximum distance you can reach with the given constraints.","solution":"def max_distance_reachable(stations, k): Returns the maximum distance that can be reached given the stations and maximum distance k. Parameters: - stations: List[int] : a list of non-negative integers representing the power of each station. - k: int : the maximum distance that can be traveled between stops to recharge. Returns: - int : the farthest position that can be reached. max_distance = 0 for i in range(len(stations)): if stations[i] > 0: max_distance = max(max_distance, i + k) return min(max_distance, len(stations) - 1)"},{"question":"You are given a matrix `matrix` where each row and each column is sorted in **ascending order**. The matrix contains **non-negative integers**. Given an integer `target`, determine if `target` is present in the matrix. Return `true` if `target` is found, otherwise return `false`. **Note:** * Each row may have a different number of columns. * An algorithm with a runtime complexity of O(n + m) is required where `n` is the number of rows and `m` is the number of columns in the matrix.","solution":"def search_matrix(matrix, target): if not matrix: return False num_rows = len(matrix) num_cols = len(matrix[0]) row = 0 col = num_cols - 1 while row < num_rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given a matrix `grid` of size `m x n` filled with non-negative integers representing the number of coins in each cell, Martin wants to collect the maximum number of coins when he travels from the **top-left** cell to the **bottom-right** cell. Martin can only move **rightward** or **downward** at each step. Return _the maximum number of coins Martin can collect by the time he reaches the bottom-right cell_.","solution":"def max_coins(grid): Given a 2D grid filled with non-negative integers representing the number of coins in each cell, Bob seeks to collect the maximum number of coins when traveling from the top-left cell to the bottom-right cell, moving only rightward or downward at each step. :param grid: List[List[int]] - 2D list of integers :return: int - the maximum number of coins collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a dp array dp = [[0] * n for _ in range(m)] # Start from the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given `logs`, a list of construction log entries, each entry having a start and end time of a job. Each log entry is represented as a two-element list `[start, end]`, denoting the inclusive start and end times of a job. Write a function to determine the maximum number of simultaneously active jobs at any time. A job is considered active if the current time is between the start and end times (inclusive). Your function should return the maximum number of active jobs during the construction period. ```python def maxActiveJobs(logs: List[List[int]]) -> int: pass ``` Note: Your solution should aim for an efficient time complexity.","solution":"def maxActiveJobs(logs): Returns the maximum number of active jobs at any time. :param logs: A list of log entries where each entry is represented as [start, end] denoting the inclusive start and end times of a job. :type logs: List[List[int]] :return: The maximum number of active jobs at any time. :rtype: int # Create a list of all events (start and end) events = [] for log in logs: start, end = log events.append((start, \'start\')) events.append((end, \'end\')) # Sort events first by time; if times are the same, prioritize \'end\' over \'start\' events.sort(key=lambda x: (x[0], x[1] == \'start\')) max_active_jobs = 0 current_active_jobs = 0 # Traverse through events for time, event in events: if event == \'start\': current_active_jobs += 1 max_active_jobs = max(max_active_jobs, current_active_jobs) else: current_active_jobs -= 1 return max_active_jobs"},{"question":"Given a directed graph represented by an adjacency list, write an algorithm to detect if there is a cycle in the graph. If a cycle exists, return `true`, otherwise return `false`. The graph node values are integers, and you can assume all values are unique. The input graph is provided as a dictionary where the keys represent the nodes and the values are lists of all the nodes that the key node has edges pointing to.","solution":"def has_cycle(graph): Detect if a cycle exists in the directed graph. Parameters: graph (dict): The directed graph represented as an adjacency list. Returns: bool: True if a cycle exists, False otherwise. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbour in graph.get(node, []): if neighbour not in visited: if dfs(neighbour, visited, rec_stack): return True elif neighbour in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n - 1`. The graph is represented by a 2D integer array `edges`, where `edges[i] = [ui, vi]` indicates there is a directed edge from node `ui` to node `vi`. Each node has an associated **value**. You are given an array `values` of length `n`, where `values[i]` is the **value** of the `ith` node. The **connected component** of a node is a subset of nodes that can be reached starting from that node, following the directed edges. Your **goal** is to find the **connected component** with the maximum sum of node values. Return _the sum of the node values in the connected component with the highest sum_. If there are multiple connected components with the same sum, return the highest sum.","solution":"from collections import defaultdict, deque def max_connected_component_sum(n, edges, values): Returns the sum of the node values in the connected component with the highest sum. Parameters: n : int : number of nodes edges : List[List[int]] : list of directed edges values : List[int] : list of node values Returns: int : sum of the node values in the connected component with the highest sum def bfs(start_node, visited, adjacency_list): queue = deque([start_node]) component_sum = 0 while queue: node = queue.popleft() if not visited[node]: visited[node] = True component_sum += values[node] for neighbor in adjacency_list[node]: if not visited[neighbor]: queue.append(neighbor) return component_sum adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) visited = [False] * n max_sum = 0 for node in range(n): if not visited[node]: component_sum = bfs(node, visited, adjacency_list) max_sum = max(max_sum, component_sum) return max_sum"},{"question":"Implement a function that takes a string `s` and returns the length of the longest substring of `s` that contains only unique characters. If there are no unique characters in the string, the function should return 0. The solution must be efficient with a time complexity of O(n). * For example, given the string `abcabcbb`, the longest substring with all unique characters is `abc`, so your function should return 3.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring of \'s\' that contains only unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. char_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"You are given a **0-indexed** array of integers `arr` and an integer `k`. The array is called **k-increasing** if `arr[i] <= arr[i+k]` holds for every index `i` such that `i + k < n`, where `n` is the length of the array. Return the minimum number of operations required to make the array **k-increasing**. In one operation, you can replace any element of the array with any integer.","solution":"def min_operations_to_make_k_increasing(arr, k): def length_of_lis(seq): # This function calculates the length of the Longest Increasing Subsequence (LIS) in \'seq\' lis = [] for element in seq: if len(lis) == 0 or element >= lis[-1]: lis.append(element) else: left, right = 0, len(lis)-1 while left < right: mid = (left + right) // 2 if lis[mid] <= element: left = mid + 1 else: right = mid lis[left] = element return len(lis) n = len(arr) total_operations = 0 for start in range(k): subsequence = [] for i in range(start, n, k): subsequence.append(arr[i]) length_of_subsequence = len(subsequence) length_of_lis_subsequence = length_of_lis(subsequence) total_operations += (length_of_subsequence - length_of_lis_subsequence) return total_operations"},{"question":"You are given a list of `transactions` where each transaction is represented by a string `transactions[i] = \\"name,city,time,amount\\"`. Each string contains the name of the person, the city they made the transaction in, the time of the transaction in minutes from some arbitrary starting point, and the amount of the transaction. A transaction is considered invalid if: 1. The amount exceeds 1000, or 2. There are multiple transactions within 60 minutes from two different cities for the same person. Return a list of all invalid transactions in the order they appear in the original input list. Your answer should be a list of the original transaction strings that are considered invalid.","solution":"def invalid_transactions(transactions): Returns a list of invalid transactions. A transaction is considered invalid if: 1. The amount exceeds 1000, or 2. There are multiple transactions within 60 minutes from two different cities for the same person. invalid = set() transactions_info = [] for transaction in transactions: name, city, time, amount = transaction.split(\',\') time = int(time) amount = int(amount) transactions_info.append((name, city, time, amount, transaction)) for i, (name1, city1, time1, amount1, transaction1) in enumerate(transactions_info): if amount1 > 1000: invalid.add(transaction1) for j, (name2, city2, time2, amount2, transaction2) in enumerate(transactions_info): if i != j and name1 == name2 and city1 != city2 and abs(time1 - time2) <= 60: invalid.add(transaction1) invalid.add(transaction2) return list(invalid)"},{"question":"A company is implementing a content rating system for its platform. Each content is rated by users, receiving up to one rating from each user. Ratings are represented in a list of tuples where each tuple contains two integers: the `user_id` and the corresponding numeric `rating` given by that user. Define a class `RatingSystem` with the following methods: * `RatingSystem()` Initializes the object. * `void add_rating(int user_id, int rating)` Adds the rating given by the user to the system. If the user has already rated, update their rating with the new value. * `float get_average_rating()` Returns the average rating of the content. If no ratings are available, return `0.0`. Ensure your solution appropriately handles the addition of ratings and the calculation of the average rating, including edge cases such as no ratings and duplicate user ratings.","solution":"class RatingSystem: def __init__(self): # Initializes an empty dictionary to store user ratings. self.ratings = {} def add_rating(self, user_id, rating): Adds or updates the rating given by the user_id. If the user has already rated, update the rating with the new value. self.ratings[user_id] = rating def get_average_rating(self): Returns the average rating of the content. If no ratings are available, return 0.0. if not self.ratings: return 0.0 total_rating = sum(self.ratings.values()) num_ratings = len(self.ratings) return total_rating / num_ratings"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Your task is to determine the minimum sum of an `n x k` grid filled with the elements of `nums`, such that each row and each column of the grid has at least one non-zero element. You can rearrange the elements of the list any way you like, but every cell in the grid must be filled, and some rows and columns may contain zeros. Return the minimum possible sum of the grid.","solution":"def min_sum_grid(nums, k): Given a list of non-negative integers and an integer k, determine the minimum sum of an n x k grid filled with the elements of nums such that each row and each column of the grid has at least one non-zero element. Each cell in the grid must be filled. nums: List of non-negative integers k: number of columns in the grid Returns the minimum possible sum of the grid. # Sort the numbers in ascending order nums.sort() # Calculate the number of rows required n = len(nums) // k if len(nums) % k != 0: n += 1 # Create the grid filled with zeros grid = [[0] * k for _ in range(n)] # Fill the grid idx = 0 for i in range(n): for j in range(k): if idx < len(nums): grid[i][j] = nums[idx] idx += 1 # Calculate the sum of the grid min_sum = sum(sum(row) for row in grid) return min_sum"},{"question":"You are given a list of `n` items where each item has a value `value[i]` and a weight `weight[i]`. Your task is to pack a knapsack of capacity `W` in such a way that the total value is maximized. However, to make it more interesting, each item can be chosen at most once. Return the maximum total value that fits within the given knapsack capacity. You can assume: - `1 <= n <= 100` - `1 <= value[i], weight[i] <= 1000` - `1 <= W <= 1000`","solution":"def knapsack_max_value(values, weights, W): n = len(values) # Initialize a DP array where dp[i][w] represents the maximum value # achievable with the first i items and a maximum weight limit w dp = [[0] * (W + 1) for _ in range(n + 1)] # Build the DP array for i in range(1, n + 1): for w in range(W + 1): # If we don\'t take the item i-1 dp[i][w] = dp[i-1][w] # If we take the item i-1, provided its weight is not more than the current capacity if weights[i-1] <= w: dp[i][w] = max(dp[i][w], dp[i-1][w - weights[i-1]] + values[i-1]) # The maximum value that fits within the given knapsack capacity return dp[n][W]"},{"question":"You are given an array of integers `nums` and an integer `target`. You are tasked with checking if there exist three integers in the array whose sum is equal to `target`. Return `true` if there are such three integers in the array, otherwise return `false`. Note that each integer in the array can be used only once in each combination. The solution should have a time complexity better than `O(n^3)`.","solution":"def three_sum(nums, target): Returns True if there exist three integers in nums whose sum equals target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of integers `arr` that can contain both positive and negative numbers. Your task is to find the **maximum product** subarray in `arr` and return its product. A subarray is a contiguous part of the array. Implement the function `maxProductSubarray(arr)`, which takes one argument, a list of integers `arr`, and returns an integer representing the maximum product of any subarray within `arr`.","solution":"def maxProductSubarray(arr): Returns the maximum product of any subarray within `arr`. if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"Given an array of integer heights representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining. The amount of water trapped at a single index is determined by the height of the shortest bar on either side of it. Write a function `trap` that calculates and returns the total water trapped. The function should take an array of non-negative integers as input and output a single integer representing the total trapped water.","solution":"def trap(height): Given a list of non-negative integers representing the elevation map, calculates the total amount of water that can be trapped after raining. Parameters: height (List[int]): A list of non-negative integers representing heights. Returns: int: The total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a 2D grid representing a list of flight routes between several cities where `grid[i][j]` is `1` if there is a direct flight from city `i` to city `j`, and `0` otherwise. Each city is represented by an index ranging from `0` to `n-1` (`n` being the total number of cities). You are also given two cities: `src` and `dst` as indices. Return _the shortest path from `src` to `dst` in terms of the number of flights (edges)_. If there is no valid path, return `-1`. The path should be returned as a list of city indices. If there are multiple shortest paths, return any of them.","solution":"from collections import deque def find_shortest_path(grid, src, dst): n = len(grid) visited = [False] * n parent = [-1] * n queue = deque([src]) visited[src] = True while queue: city = queue.popleft() if city == dst: path = [] while city != -1: path.append(city) city = parent[city] return path[::-1] for next_city in range(n): if grid[city][next_city] == 1 and not visited[next_city]: queue.append(next_city) visited[next_city] = True parent[next_city] = city return -1"},{"question":"You are given a 2D matrix `mat` of integers with dimensions `m x n`. Each cell in the matrix contains either a 0 or a 1. A cell containing 1 represents an obstacle, and a cell containing 0 represents an open path. You start at the top-left cell (0, 0) and want to move to the bottom-right cell (m-1, n-1). You can only move right or down from a cell. Write a function to determine the number of unique paths from the top-left cell to the bottom-right cell, considering the obstacles. If there is no valid path, return 0.","solution":"def unique_paths_with_obstacles(mat): Returns the number of unique paths from top-left to bottom-right in a matrix with obstacles. if not mat or mat[0][0] == 1 or mat[-1][-1] == 1: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if mat[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a list of strings `words` and an integer `m`. A word is considered \\"m-desirable\\" if no two adjacent characters in the word are the same and the length of the word is at least `m`. Return the list of all \\"m-desirable\\" words from the input list. If no such word exists, return an empty list.","solution":"def is_m_desirable(word, m): Checks if a word is m-desirable. A word is m-desirable if no two adjacent characters in the word are the same and the length of the word is at least m. if len(word) < m: return False for i in range(len(word) - 1): if word[i] == word[i + 1]: return False return True def m_desirable_words(words, m): Returns a list of all m-desirable words from the input list. return [word for word in words if is_m_desirable(word, m)]"},{"question":"You are given a string `s` consisting only of letters \'a\' and \'b\'. You can delete any number of characters in `s` to construct a new string consisting of alternating characters \'a\' and \'b\'. Return _the minimum number of deletions needed_ to make the string alternating. Note that the resulting string should not contain two consecutive characters that are the same.","solution":"def min_deletions_to_alternate(s): Returns the minimum number of deletions needed to make the string alternating. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given an integer array `nums` representing the cost of house renovations. You are only allowed to renovate a house in such a way that you do not renovate two adjacent houses. Given these constraints, implement the function `maxRenovationCost` that will calculate the maximum amount of money you can spend on house renovations without violating the rule. For example, if `nums = [2, 7, 9, 3, 1]`, the function should return 12, because you can opt for the second (7) and fourth (3) renovations.","solution":"def maxRenovationCost(nums): Calculate the maximum renovation cost without renovating two adjacent houses. :param nums: List[int] - List of integers representing the renovation cost for each house. :return: int - Maximum renovation cost. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n # dp array to store the max cost up to each house dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"Given a string `str` consisting of lowercase English letters, return _the longest substring without repeating characters_. If there are multiple substrings with the same length, return _the substring that appears first_.","solution":"def longest_substring_without_repeating_characters(s): Returns the longest substring without repeating characters. If there are multiple substrings with the same length, the substring that appears first is returned. :param s: Input string consisting of lowercase English letters :type s: str :return: The longest substring without repeating characters :rtype: str char_index = {} start = 0 max_len = 0 max_substr = \\"\\" for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:end+1] return max_substr"},{"question":"# New Question Given a `m x n` matrix `mat` of integers, return _the **sum** of all matrix elements which are both located on an even row and even column_. Consider row and column indices to be 0-based. ```python def sumEvenRowEvenCol(mat: List[List[int]]) -> int: # Your implementation here pass ```","solution":"def sumEvenRowEvenCol(mat): Returns the sum of all matrix elements located on even rows and even columns. Parameters: mat (List[List[int]]): The 2D matrix of integers. Returns: int: The sum of elements on even rows and even columns. total_sum = 0 for i in range(0, len(mat), 2): for j in range(0, len(mat[i]), 2): total_sum += mat[i][j] return total_sum"},{"question":"You are given a 2D integer array `events` where `events[i] = [startDayi, endDayi, valuei]` represents an event that starts on `startDayi` and ends on `endDayi`, both days inclusive, and has a value of `valuei`. You can only attend one event per day. Return _the maximum sum of the values that you can collect by attending the events such that no two events you attend overlap_.","solution":"from bisect import bisect_right def max_value(events): Returns the maximum sum of the values that can be collected by attending the events such that no two events attended overlap. events.sort(key=lambda x: x[1]) # Sort based on end days dp = [] for start, end, value in events: # Current maximum value if this event was taken total_value = value idx = bisect_right(dp, (start - 1, float(\'inf\'))) - 1 if idx >= 0: total_value += dp[idx][1] if not dp or total_value > dp[-1][1]: dp.append((end, total_value)) return dp[-1][1] if dp else 0"},{"question":"Given a binary tree, find the value of the smallest node that has a minimum depth. The depth of a node is defined as the length of the path from the root to the node. The minimum depth is the shortest distance from the root to a leaf node (a node with no children). Return the value of the smallest node among all nodes that have the minimum depth.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_minimum_depth_smallest_value(root: TreeNode) -> int: if not root: return float(\'inf\') from collections import deque queue = deque([(root, 1)]) min_depth = float(\'inf\') min_value = float(\'inf\') while queue: node, depth = queue.popleft() if not node.left and not node.right: if depth < min_depth: min_depth = depth min_value = node.val elif depth == min_depth: min_value = min(min_value, node.val) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return min_value"},{"question":"You are given an array of integers `arr` and a target value `target`. Implement a class `TargetSubarray` with the following methods: * `TargetSubarray(int[] arr, int target)` Initializes the object with the provided `arr` and `target`. * `boolean findTargetSubarray()` Returns `true` if there exists a contiguous subarray within `arr` that sums up to the `target`, and `false` otherwise. This class should enable efficient checking of subarrays within the given constraints.","solution":"class TargetSubarray: def __init__(self, arr, target): self.arr = arr self.target = target def findTargetSubarray(self): current_sum = 0 prefix_sums = {0} for num in self.arr: current_sum += num if (current_sum - self.target) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to find the length of the shortest subarray with a sum greater than or equal to `target`. If there is no such subarray, return `0` instead. Implement a function: ```python def min_subarray_len(target: int, arr: List[int]) -> int: ``` # Example: ```python # Input: arr = [2,3,1,2,4,3] target = 7 # Output: 2 # Explanation: The subarray [4,3] has the minimal length 2 under the problem constraint. ``` # Constraints: 1. (1 leq arr.length leq 10^5) 2. (1 leq arr[i] leq 10^4) 3. (1 leq target leq 10^9)","solution":"from typing import List def min_subarray_len(target: int, arr: List[int]) -> int: n = len(arr) left = 0 total = 0 min_len = n + 1 for right in range(n): total += arr[right] while total >= target: min_len = min(min_len, right - left + 1) total -= arr[left] left += 1 return min_len if min_len != n + 1 else 0"},{"question":"You are given a string `s` and an integer `maxLetters`. A **valid substring** is a substring that contains at most `maxLetters` distinct characters. Find the length of the longest valid substring in `s`. Return the length of the longest valid substring that can be formed.","solution":"def longest_valid_substring(s, maxLetters): Returns the length of the longest valid substring that contains at most maxLetters distinct characters. from collections import defaultdict n = len(s) if n == 0 or maxLetters <= 0: return 0 max_length = 0 char_count = defaultdict(int) left = 0 for right in range(n): char_count[s[right]] += 1 while len(char_count) > maxLetters: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings `s1` and `s2` of equal length and a positive integer `k`. You can swap the characters of `s1` at any two positions at most `k` times. Your task is to determine whether it is possible to make `s1` equal to `s2` by performing at most `k` swaps. Return _`true` if it is possible, otherwise return `false`_.","solution":"def can_convert_with_k_swaps(s1, s2, k): Determine if s1 can be transformed into s2 with at most k swaps. Args: s1 (str): The first string. s2 (str): The second string. k (int): The maximum number of swaps allowed. Returns: bool: True if s1 can be transformed into s2 with at most k swaps, else False. if len(s1) != len(s2): return False # Count the number of differing positions differing_positions = 0 for a, b in zip(s1, s2): if a != b: differing_positions += 1 # If the number of differing positions is more than double the allowed swaps, it\'s impossible if differing_positions > 2 * k: return False return True"},{"question":"You are given an m x n integer matrix `heights` representing the height of each unit cell in a continent. The continent is surrounded by a body of water represented by cells with height `0`. From any cell, you can travel to another if and only if the destination cell has a height equal to or lower than the current cell. The goal is to find the path from the highest peak to the water body in the shortest number of moves. Return the minimum number of moves required to reach the water body starting from the highest peak. If there are multiple highest peaks, consider any path from the highest peak with the least number of moves.","solution":"from collections import deque def find_highest_peak(heights): Finds the highest peak and its coordinates in the matrix. max_height = float(\'-inf\') peak_coords = [] for i in range(len(heights)): for j in range(len(heights[0])): if heights[i][j] > max_height: max_height = heights[i][j] peak_coords = [(i, j)] elif heights[i][j] == max_height: peak_coords.append((i, j)) return peak_coords, max_height def bfs_to_water(heights, start_points, max_height): Breadth-First Search (BFS) to find shortest path from the highest peak to the water. m, n = len(heights), len(heights[0]) queue = deque([(x, y, 0) for x, y in start_points]) visited = set(start_points) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if heights[nx][ny] == 0: return moves + 1 if heights[nx][ny] <= heights[x][y] and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 # When there\'s no path to water def min_moves_to_water(heights): if not heights or not heights[0]: return -1 start_points, max_height = find_highest_peak(heights) return bfs_to_water(heights, start_points, max_height)"},{"question":"You are given a **0-indexed** array of integers `nums`, where each integer represents the position on an infinite number line. An integer `i` can jump from its current position to any other position with a cost equal to the absolute difference between the destination and the initial position values. However, each integer can only jump **at most once**. Each element in the array may only jump directly to another element in the array. Your task is to determine two things: * Calculate the **minimum total cost** to make all elements in the array equal by performing the allowed jumps. * Determine the resulting common position that minimizes the total cost. Return _a tuple_ `(min_total_cost, common_position)` _where_: * `min_total_cost` _is the minimum total cost to make all elements equal to the common position._ * `common_position` _is the resulting common position of all elements._ If there are multiple positions with the same minimum cost, return the smallest one.","solution":"def min_cost_to_equal(nums): Returns the minimum total cost to make all elements in the array equal and the resulting common position. nums.sort() n = len(nums) if n % 2 == 1: common_position = nums[n // 2] else: common_position = nums[(n // 2) - 1] min_total_cost = sum(abs(x - common_position) for x in nums) return min_total_cost, common_position"},{"question":"Given the `head` of a singly linked list, reverse the nodes of the list _k_ at a time. The nodes of the list should remain in the same relative order if the number of nodes is not a multiple of _k_. You may not alter the values in the list\'s nodes, only the nodes themselves can be changed. Return the modified list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) if head: head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given two arrays `clients` and `incomes` of the same length `n`, where `clients[i]` is the name of the `i-th` client and `incomes[i]` is a positive integer representing their income. Additionally, you are provided with an integer `threshold`. Write a function that returns the names of all clients whose income is greater than or equal to the `threshold`, sorted in **ascending** order by their names. If no clients meet the threshold, return an empty list.","solution":"def clients_above_threshold(clients, incomes, threshold): Returns the list of client names with income greater than or equal to threshold, sorted in ascending order. Parameters: clients (list of str): List of client names. incomes (list of int): List of incomes corresponding to the clients. threshold (int): Income threshold. Returns: list of str: Sorted list of client names with income above or equal to threshold. result = [clients[i] for i in range(len(clients)) if incomes[i] >= threshold] return sorted(result)"},{"question":"You are given a list of integers `arr` representing the heights of consecutive buildings in a row. A person can jump from one building to another if the next building is the same height or is exactly one unit taller than the current building. Write a function to determine the maximum number of buildings a person can visit starting from the first building in the row. Return _the maximum number of buildings that can be visited starting from the first building._","solution":"def maximum_buildings_visited(arr): Returns the maximum number of buildings that can be visited starting from the first building. A person can jump from one building to another if the next building is the same height or is exactly one unit taller. if not arr: return 0 max_visits = 1 current_visits = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1] or arr[i] == arr[i-1] + 1: current_visits += 1 else: break return current_visits"},{"question":"You are given a 2D grid of integers where each cell is either a 0 (empty) or a 1 (obstacle). You are located at the top-left corner of the grid (i.e., grid[0][0]) and need to find a path to the bottom-right corner (i.e., grid[m-1][n-1]), moving only down or right at any point in time. Write a function to determine if such a path exists. If a path exists, return the length of the shortest clear path (number of steps); otherwise, return -1.","solution":"from collections import deque def shortest_path_binary_matrix(grid): Determine the length of the shortest clear path from the top-left to the bottom-right corner of the grid. Return the length of the path if it exists, otherwise return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1)] # Only down and right movements queue = deque([(0, 0, 1)]) # (row, col, distance) grid[0][0] = 1 # mark as visited while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for drow, dcol in directions: new_row, new_col = row + drow, col + dcol if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) grid[new_row][new_col] = 1 # mark as visited return -1"},{"question":"Given a list of `n` integers where each integer represents a position on a number line, return the maximum distance between any two consecutive integers after sorting the list. The list is guaranteed to have at least two elements.","solution":"def max_distance_between_consecutive_integers(int_list): Returns the maximum distance between any two consecutive integers after sorting the list. Parameters: int_list (list): A list of integers. Returns: int: The maximum distance between any two consecutive integers. # Sort the list sorted_list = sorted(int_list) # Initialize the maximum distance max_distance = 0 # Calculate the maximum distance between consecutive integers for i in range(1, len(sorted_list)): distance = sorted_list[i] - sorted_list[i-1] if distance > max_distance: max_distance = distance return max_distance"},{"question":"You are given an array of pairs of integers where each pair represents a coordinate point `(x, y)` in a 2D plane. You need to determine the **minimum** number of straight lines required to cover all the points. A straight line can cover multiple points if they are all collinear. Return _the minimum number of straight lines needed to cover all the points_. Note: - The points are identified by their Cartesian coordinates and no two points will have the same coordinates. - You may find lines that are horizontal, vertical, or diagonal.","solution":"from collections import defaultdict from math import gcd def min_lines_to_cover_points(points): def slope_intercept(p1, p2): Utility function to get the slope and intercept of the line through points p1 and p2. dx = p2[0] - p1[0] dy = p2[1] - p1[1] # Use gcd to normalize the slope to avoid floating-point precision issues g = gcd(dy, dx) slope = (dy // g, dx // g) # slope as a reduced fraction (dy/dx) intercept = p1[1] * dx - p1[0] * dy # using cross multiplication to keep intercept as integer return slope, intercept if not points: return 0 n = len(points) if n == 1: return 1 lines = defaultdict(set) for i in range(n): for j in range(i + 1, n): slope, intercept = slope_intercept(points[i], points[j]) lines[(slope, intercept)].add(points[i]) lines[(slope, intercept)].add(points[j]) covered_points = set() num_lines = 0 while covered_points != set(points): max_line = max(lines, key=lambda k: len(lines[k] - covered_points)) covered_points.update(lines[max_line]) num_lines += 1 return num_lines"},{"question":"Given an integer array `nums` of length n. You need to determine if there exists a subset of elements that sum up to a given target `k`. Return `true` if such a subset exists, or `false` otherwise. Each element in the array may only be used once.","solution":"def subset_sum(nums, k): Determine if there exists a subset of elements in nums that sums up to k. Args: nums (list of int): The list of integers. k (int): The target sum. Returns: bool: True if such a subset exists, False otherwise. n = len(nums) dp = [[False] * (k + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]] return dp[n][k]"},{"question":"You have a list of `n` projects. Each project `i` has a certain value `value[i]` and a certain completion time `completion[i]`. You can select at most one project to work on. Each project can be started at any time, but it takes an exact amount of time specified by its completion time to complete. You earn the project’s value if you finish it before or exactly at the deadline time `d`. Given a list of such projects and the deadline `d`, write a function to return the maximum value you can achieve from the projects. ```python def maximumProjectValue(value: List[int], completion: List[int], d: int) -> int: # Your code here ```","solution":"def maximumProjectValue(value, completion, d): Returns the maximum value of the project which can be completed before or exactly at the deadline. :param value: List[int] - A list of values of the projects. :param completion: List[int] - A list of completion times of the projects. :param d: int - Deadline time to complete the project. :return: int - Maximum value of the project that can be completed before or exactly at the deadline. max_value = 0 for v, c in zip(value, completion): if c <= d: max_value = max(max_value, v) return max_value"},{"question":"You are given a list of integers `nums` representing the values of coins you have. You are also given two variables `target1` and `target2`. You need to determine the fewest number of total coins you need to make up the amounts `target1` and `target2` using the coins in `nums`. You can reuse the same coin multiple times. Return _the minimum number of coins needed to make up both amounts, or `-1` if it is not possible to achieve both targets with the given coins_. **Note** that: - You must use the exact value of each target separately from the coins list. - The coins used to form `target1` cannot be used again to form `target2`. ```python def min_coins(nums: List[int], target1: int, target2: int) -> int: # Your implementation here ```","solution":"from typing import List def min_coins(nums: List[int], target1: int, target2: int) -> int: def coin_change(coins, amount): dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1 # Find the minimum coins required for both targets separately min_coins_target1 = coin_change(nums, target1) min_coins_target2 = coin_change(nums, target2) if min_coins_target1 == -1 or min_coins_target2 == -1: return -1 return min_coins_target1 + min_coins_target2"},{"question":"Given a binary tree, return the **in-order traversal** of its nodes\' values as a list. An in-order traversal visits nodes in the following order for a binary tree: * First, visit all the nodes in the left subtree * Then, visit the root node * Finally, visit all the nodes in the right subtree The input will be the root of the binary tree, which is represented as a class with attributes `val`, `left`, and `right`. Return _a list of integers representing the in-order traversal of the binary tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the in-order traversal of a binary tree. result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"You are given a binary string `s` (a string consisting of only \'0\'s and \'1\'s). In one move, you can choose any character in the string and flip it (i.e., change \'0\' to \'1\' or \'1\' to \'0\'). Your goal is to make the string have alternating characters, that is, no two adjacent characters are the same. Return the minimum number of moves needed to transform the string into an alternating character string.","solution":"def min_moves_to_alternate(s: str) -> int: Returns the minimum number of moves needed to transform the binary string into an alternating character string. Args: s - binary string Returns: int - minimum number of moves n = len(s) # Generate alternate patterns based on the length of the string alt1 = \'\'.join([\'0\' if i % 2 == 0 else \'1\' for i in range(n)]) alt2 = \'\'.join([\'1\' if i % 2 == 0 else \'0\' for i in range(n)]) # Count the mismatches with both patterns moves_alt1 = sum(1 for i in range(n) if s[i] != alt1[i]) moves_alt2 = sum(1 for i in range(n) if s[i] != alt2[i]) # Minimum of the mismatches gives the minimum moves needed return min(moves_alt1, moves_alt2)"},{"question":"A binary tree is given, and you need to implement a function to determine if it is a univalued binary tree. A binary tree is considered univalued if every node in the tree has the same value. You are provided with the root node of the binary tree, `root`. Your function should return `true` if the binary tree is univalued, and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determine if the binary tree is a univalued binary tree. A binary tree is considered univalued if every node in the tree has the same value. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the binary tree is univalued, False otherwise. if root is None: return True def is_unival(node, value): if node is None: return True if node.val != value: return False return is_unival(node.left, value) and is_unival(node.right, value) return is_unival(root, root.val)"},{"question":"Given an encoded string, where k[encoded_string] is the basic pattern: The encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Additionally, the length of the input string will not exceed 100. Decode the string and return it. For example, s = \\"3[a]2[bc]\\", return \\"aaabcbc\\". s = \\"3[a2[c]]\\", return \\"accaccacc\\". s = \\"2[abc]3[cd]ef\\", return \\"abcabccdcdcdef\\".","solution":"def decode_string(s): stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': # Push the current number and current string to the stack stack.append((current_str, current_num)) # Reset the current string and current number current_str, current_num = \'\', 0 elif char == \']\': # Pop the last string and number from the stack last_str, num = stack.pop() # Update the current string current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"Given two non-empty binary trees `root1` and `root2`, imagine that when you overlay these trees, some nodes of `root1` overlap with nodes of `root2`. To create the merged tree, wherever two nodes overlap, add the values of the two nodes and have the sum as the new node value. If a node does not overlap, it should be included as is from the original tree. Return _the merged binary tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees into one. Args: root1 (TreeNode): The root of the first binary tree. root2 (TreeNode): The root of the second binary tree. Returns: TreeNode: The root of the merged binary tree. if not root1: return root2 if not root2: return root1 merged_root = TreeNode(root1.val + root2.val) merged_root.left = mergeTrees(root1.left, root2.left) merged_root.right = mergeTrees(root1.right, root2.right) return merged_root"},{"question":"Given a 2D integer array `matrix`, return `true` if the matrix is a Toeplitz matrix. Otherwise, return `false`. A matrix is a Toeplitz matrix if every diagonal from top-left to bottom-right has the same elements. Each of the following rules define a Toeplitz matrix: - The element at index `(i, j)` is equal to the element at index `(i + 1, j + 1)` for all `(i, j)` where both `i + 1` and `j + 1` are within the bounds of the matrix.","solution":"def is_toeplitz_matrix(matrix): Returns True if the given matrix is a Toeplitz matrix, otherwise False. rows = len(matrix) cols = len(matrix[0]) for i in range(rows - 1): for j in range(cols - 1): if matrix[i][j] != matrix[i + 1][j + 1]: return False return True"},{"question":"Given an integer `N`, return the number of unique ways to assign `+` and `-` signs to each number from `1` to `N` (both inclusive) such that their sum equals `0`. For instance, if `N` is 3, one of the ways to achieve sum `0` is `-1 + 2 - 3 = -2 + 3 - 1 = 0`, another way is `-1 - 2 + 3 = 0`. If no such assignment is possible for the given `N`, return `0`.","solution":"def ways_to_make_zero_sum(N): Given an integer N, returns the number of unique ways to assign `+` and `-` signs to each number from 1 to N (both inclusive) such that their sum equals 0. If no such assignment is possible for the given N, return 0. if N % 2 != 0: return 0 import math # Calculate the factorial return math.comb(N, N // 2)"},{"question":"You are given an `n x n` 2D matrix `matrix` representing an image, where each element of the matrix is a pixel of the image. You need to rotate the matrix 90 degrees clockwise in-place. Write a function to perform the rotation. You may assume that the given matrix always has equal number of rows and columns, and you must not return anything but modify the matrix in-place instead.","solution":"def rotate(matrix): Rotates a given n x n 2D matrix 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given an array of integers `arr` representing the heights of buildings adjacent to each other. The goal is to identify the maximum area of a rectangle formed by buildings, where each rectangle\'s width is determined by adjacent buildings with the heights defined by the shortest building within that rectangle. Return the **maximum area** of any possible rectangle formed by the sequence of buildings. **Note** that the heights are only considered if they form a contiguous subsequence of the array.","solution":"def largestRectangleArea(arr): This function takes an array of integers representing the heights of buildings and returns the area of the largest rectangle that can be formed by the buildings. stack = [] max_area = 0 index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a 2D grid containing only 0s and 1s where 1 represents land and 0 represents water. An island in the grid is formed by connecting adjacent lands horizontally or vertically. A single land piece that does not connect with any other lands is also considered an island. A **closed island** is an island that is surrounded by water on all four edges. Any land connected to the boundary of the grid (directly or indirectly) is not considered a closed island. Return _the number of closed islands_ in the given grid.","solution":"def closed_island(grid): Returns the number of closed islands in the given grid. def dfs(i, j): Perform DFS to mark the visited land (mutate the grid). if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1: return grid[i][j] = 1 dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 rows = len(grid) cols = len(grid[0]) # Mark all lands connected to boundary as water for i in range(rows): for j in [0, cols-1]: if grid[i][j] == 0: dfs(i, j) for j in range(cols): for i in [0, rows-1]: if grid[i][j] == 0: dfs(i, j) # Count closed islands by DFS closed_islands_count = 0 for i in range(1, rows-1): for j in range(1, cols-1): if grid[i][j] == 0: closed_islands_count += 1 dfs(i, j) return closed_islands_count"},{"question":"Given an array of integers `nums`, return an array of arrays where each sub-array represents a different combination of `nums` where the elements are uniquely paired up. Each pair should only appear once and the order of the pairs does not matter. For example, given `nums = [1, 2, 3, 4]`, one possible output could be `[[1, 2], [3, 4]]`, `[[1, 3], [2, 4]]`, and so on. If the number of elements in `nums` is odd, return an empty array `[]` since all elements cannot be paired up.","solution":"from itertools import combinations def pair_combinations(nums): Given an array of integers `nums`, return an array of arrays where each sub-array represents a different combination of `nums` where the elements are uniquely paired up. if len(nums) % 2 != 0: return [] pairs = [] all_combinations = list(combinations(nums, 2)) def backtrack(start, path): if len(path) == len(nums) // 2: pairs.append(path[:]) return for i in range(start, len(all_combinations)): a, b = all_combinations[i] if not any(a in pair or b in pair for pair in path): backtrack(i + 1, path + [(a, b)]) backtrack(0, []) if len(pairs) > 0: return pairs return [[]]"},{"question":"You are given an integer array `height` representing the heights of columns. Each column’s width is 1. Consider two columns at different indices `i` and `j`, with `i < j`. The area of water that can be contained between these two columns is calculated as `(j - i) * min(height[i], height[j])`. Return the maximum area of water a container can store by selecting two columns from the array. Note that you may not slant the container.","solution":"def max_area(height): Find the maximum water container area by selecting two heights from the given list. :param height: List of integers representing heights of columns :return: Maximum area of water container max_area = 0 left, right = 0, len(height) - 1 while left < right: width = right - left min_height = min(height[left], height[right]) current_area = width * min_height max_area = max(max_area, current_area) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given a non-negative integer `num`, you need to find the number of ways to split this number into exactly three parts such that: 1. Each part is a non-negative integer. 2. The sum of the three parts equals the original number. In other words, if you have an integer `num`, count the number of possible triplets `(a, b, c)` such that `a + b + c = num`, where `a`, `b`, and `c` are non-negative integers. Return the total number of such triplets.","solution":"def count_triplets(num): Given a non-negative integer num, finds the number of ways to split this number into exactly three parts such that each part is a non-negative integer and their sum equals the original number. Parameters: num (int): A non-negative integer Returns: int: Number of possible triplets (a, b, c) such that a + b + c = num count = 0 # Iterate through all possible values of a and b for a in range(num + 1): for b in range(num + 1 - a): # Calculate c based on the remaining sum c = num - a - b if c >= 0: count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase English letters only. You need to perform the following operations exactly `k` times: 1. Select a non-empty substring of `s`. 2. Sort the letters in the selected substring in non-decreasing order. 3. Concatenate the sorted substring back into its original position in `s`. Your task is to return the lexicographically smallest string possible after performing these operations. For example, given `s = \\"dcab\\"` and `k = 2`, one possible solution is to select the substring `s[1:3]`, sort it to get `\\"ca\\"`, making `s = \\"dcaab\\"`, and then in the second operation, select substring `s[2:5]`, sort it to get `\\"aab\\"`, resulting in the final lexicographically smallest string `\\"aacbb\\"`. Return the resulting smallest string.","solution":"def find_lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string possible after k operations. if k == 1: # Rotate the string to find the lexicographically smallest rotation n = len(s) smallest = s for i in range(1, n): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k >= 2, we can fully sort the string return \'\'.join(sorted(s))"},{"question":"You are given an integer array `nums` where the elements are sorted in ascending order, and all elements are unique. Write a function to return a list of all possible **unique subsets** of the array `nums`. The solution set must not contain duplicate subsets. Return the subsets in **ascending order**. The subsets can be returned in any order within this requirement.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible unique subsets of a list sorted in ascending order. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) nums.sort() backtrack(0, []) return result"},{"question":"You are given a list of strings `words` and a search query string `pattern`. Write a function to find and return all strings from `words` that match the pattern. A string matches the pattern if there is a bijective mapping between the characters of the pattern and the characters of the string. Bijective mapping means that each character in the pattern maps to one and only one character in the string, and vice versa. You need to implement the following function: ```python def find_and_replace_pattern(words: List[str], pattern: str) -> List[str] ``` where both `words` and `pattern` consist of lowercase English letters.","solution":"from typing import List def matches(word: str, pattern: str) -> bool: if len(word) != len(pattern): return False mapping_w2p = {} mapping_p2w = {} for w_char, p_char in zip(word, pattern): if w_char in mapping_w2p and mapping_w2p[w_char] != p_char: return False if p_char in mapping_p2w and mapping_p2w[p_char] != w_char: return False mapping_w2p[w_char] = p_char mapping_p2w[p_char] = w_char return True def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: return [word for word in words if matches(word, pattern)]"},{"question":"You are given an array of positive integers `costs` where `costs[i]` is the cost of the `i-th` item. You would like to purchase exactly two items such that the sum of their costs is less than or equal to a given integer `budget`. Return _the maximum sum of costs for the two items_ you can achieve. If there are no two items that satisfy the condition, return _-1_.","solution":"def max_sum_under_budget(costs, budget): Return the maximum sum of costs for two items that is less than or equal to the budget. :param costs: List[int] - A list of positive integers representing the cost of items. :param budget: int - The maximum allowed sum of the costs of two items. :return: int - The maximum sum of costs for two items within the given budget, or -1 if not possible. max_sum = -1 n = len(costs) # Iterate through all pairs of items for i in range(n): for j in range(i + 1, n): current_sum = costs[i] + costs[j] if current_sum <= budget: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an array of `n` integers `nums` representing a list of items. Each item `nums[i]` has a certain weight. Your task is to design a method to randomly select an index `i` from the array according to the weights provided. Specifically, the probability of selecting index `i` is `nums[i]` divided by the sum of all `weights`. Implement a function that initializes the selection process with the given list of weights and another function that uses this initialization to return a randomly selected index based on their weights.","solution":"import random class Solution: def __init__(self, nums): self.weights = nums self.prefix_sums = [] self.total_sum = 0 for weight in self.weights: self.total_sum += weight self.prefix_sums.append(self.total_sum) def pick_index(self): target = random.uniform(0, self.total_sum) # Binary search for the target low, high = 0, len(self.prefix_sums) - 1 while low < high: mid = (low + high) // 2 if target > self.prefix_sums[mid]: low = mid + 1 else: high = mid return low"},{"question":"You are given a list of integers `tasks` where `tasks[i]` represents the time required to complete the `i`-th task. Each task can only be completed on a specific day, determined by the index of the task in the list. Additionally, you are provided with an integer `n`, the maximum number of tasks that can be completed on any given day. Your goal is to schedule the tasks over several days such that the maximum number of days required to complete all tasks is minimized. Return the minimum number of days needed to complete all tasks if you can schedule up to `n` tasks per day.","solution":"import math def min_days_to_complete_tasks(tasks, n): Returns the minimum number of days required to complete all tasks if up to `n` tasks can be completed per day. :param tasks: List[int] - a list of integers representing task times. :param n: int - the maximum number of tasks that can be completed per day. :return: int - the minimum number of days required. # Calculate the total number of tasks total_tasks = len(tasks) # Calculate the minimum number of days required by dividing total tasks by maximum tasks per day min_days = math.ceil(total_tasks / n) return min_days"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values from left to right, level by level. Implement a function that takes the root of the tree as input and returns a list of lists of integers, where each list represents a level of the tree. If the tree is empty, return an empty list.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree\'s node values. if not root: return [] result, queue = [], deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given an array of integers `arr` and an integer `k`, where `arr` represents the heights of different towers. You can randomly pick one tower and either increase or decrease its height by `k`. You need to find the minimum possible difference between the height of the tallest tower and the shortest tower after performing the operation on each tower exactly once. Return the minimum possible difference between the height of the tallest and the shortest tower after the operations.","solution":"def min_difference(arr, k): Finds the minimum possible difference between the height of the tallest tower and the shortest tower after increasing or decreasing each tower height by k. Parameters: arr (list of int): List of tower heights. k (int): Value by which each tower height can be increased or decreased. Returns: int: The minimum possible difference between the highest and lowest tower. if not arr: return 0 arr.sort() n = len(arr) ans = arr[-1] - arr[0] for i in range(1, n): max_elem = max(arr[i-1] + k, arr[-1] - k) min_elem = min(arr[0] + k, arr[i] - k) ans = min(ans, max_elem - min_elem) return ans"},{"question":"Given a string `s` representing a sequence of characters, return the lexicographically smallest **substring** of length `k` that can be found within `s`. Ensure the substring maintains the sequence order as found in `s`, but you do not need to maintain adjacent continuity. If no such substring exists, return an empty string.","solution":"def smallest_k_substring(s, k): Returns the lexicographically smallest substring of length k. if len(s) < k: return \\"\\" from itertools import combinations substrings = [\'\'.join(comb) for comb in combinations(s, k)] return min(substrings) if substrings else \\"\\""},{"question":"Given a function `findAnagrams(s: String, p: String): List[Int]`, implement an efficient algorithm to find **all** the start indices of `p`\'s anagrams in `s`. The output should be a list of integers representing the start indices. The order in the output list does not matter. Note that the input strings consist only of lowercase English letters.","solution":"def findAnagrams(s, p): Returns a list of start indices of p\'s anagrams in s. from collections import Counter p_count = Counter(p) s_count = Counter() result = [] p_len = len(p) for i in range(len(s)): s_count[s[i]] += 1 if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"You are given a list of `appointments` where each appointment is represented as a tuple `(start, end)` indicating the start and end times of the appointment. Your task is to determine the maximum number of non-overlapping appointments that can be scheduled. An appointment `(start1, end1)` is considered non-overlapping with `(start2, end2)` if `end1 <= start2` or `end2 <= start1`. Return an integer representing the maximum number of non-overlapping appointments.","solution":"def max_non_overlapping_appointments(appointments): Returns the maximum number of non-overlapping appointments. # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_appointment_end = float(\'-inf\') for start, end in appointments: if start >= last_appointment_end: max_appointments += 1 last_appointment_end = end return max_appointments"},{"question":"You are given a list of integers `nums` and an integer `x`. Your task is to find the length of the shortest subarray from `nums` whose sum is greater than `x`. If no such subarray exists, return `-1`. For example, given `nums = [1, 1, 3, 2, 5]` and `x = 7`: * The subarray `[3, 2, 5]` has a sum of `10`, which is greater than `7`, and its length is `3`. * The subarray `[2, 5]` has a sum of `7`, which is not greater than `7`. Thus, the output would be `3`.","solution":"def shortest_subarray_with_sum_greater_than_x(nums, x): from collections import deque n = len(nums) current_sum = 0 min_length = n + 1 subarray_sum_queue = deque() for i in range(n): current_sum += nums[i] subarray_sum_queue.append(nums[i]) while current_sum > x: min_length = min(min_length, len(subarray_sum_queue)) current_sum -= subarray_sum_queue.popleft() return min_length if min_length != n + 1 else -1"},{"question":"You are given a grid representing a city map where each value represents a different distance from a certain landmark. Each cell in the grid has a non-negative integer value indicating the distance to the landmark. Your task is to find the smallest island consisting of only cells that have a distance value of `1`. An island is defined as a group of connected cells (connected horizontally or vertically). Return _the size of the smallest island_. If there are no cells with the value `1`, return `-1`.","solution":"def smallest_island(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(row, col): if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] != 1 or visited[row][col]: return 0 visited[row][col] = True size = 1 size += dfs(row + 1, col) size += dfs(row - 1, col) size += dfs(row, col + 1) size += dfs(row, col - 1) return size min_island_size = float(\'inf\') found = False for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: size = dfs(i, j) min_island_size = min(min_island_size, size) found = True return min_island_size if found else -1"},{"question":"You are given an array `nums` consisting of integers. You need to determine the length of the longest strict decreasing subsequence present in the array. A strict decreasing subsequence is a sequence derived from the array where every subsequent element is strictly less than the previous one. Return the length of the longest strict decreasing subsequence in the array.","solution":"def longest_decreasing_subsequence_length(nums): Returns the length of the longest strict decreasing subsequence present in the array. :param nums: List[int], the input array of integers. :return: int, the length of the longest strict decreasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n # Initialize dp array where dp[i] represents the length of the longest decreasing subsequence ending with nums[i] for i in range(1, n): for j in range(i): if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an array of positive integers `heights` representing the heights of blocks in a histogram. Each block has a width of 1. The histogram extends from left to right, and you need to determine the area of the largest rectangle that can be formed in the histogram. Return _the area of the largest rectangle_. For example, given the array `[2, 1, 5, 6, 2, 3]`, the area of the largest rectangle is 10 (formed by the heights `5` and `6`).","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an `n x n` 2D matrix, `matrix`, containing only the elements `\'0\'` and `\'1\'`. A submatrix is defined as a rectangular area of the matrix. The goal is to find the size of the largest square submatrix that contains only `\'1\'`. Determine the side length of this largest square submatrix. Return 0 if there is no such submatrix.","solution":"def largest_square(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j] == \'1\': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given an array `heights` where `heights[i]` represents the height of a building. The buildings are situated along a street in a straight line and you want to place a ladder that can cover exactly `k` buildings. You can move the ladder to start at any building but it must extend to the next `k` buildings, covering them all. Return the **maximum height** that the ladder can reach in addition to the buildings it covers.","solution":"def max_ladder_height(heights, k): Returns the maximum height that the ladder can reach in addition to the buildings it covers. Params: heights: list of int, heights of the buildings k: int, number of buildings the ladder can cover Returns: int, maximum height that the ladder can reach max_height = 0 # Iterate through the list, considering each segment of k buildings for i in range(len(heights) - k + 1): current_segment_max = max(heights[i:i + k]) if current_segment_max > max_height: max_height = current_segment_max return max_height"},{"question":"Given the root of a binary search tree (BST), return the node with the smallest value in the BST that has a value greater than a given target. If such a node does not exist, return `null`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_min_greater_than(root, target): Finds the node with the smallest value greater than the given target value. :param root: TreeNode, root of the BST :param target: int, the target value :return: TreeNode or None, the node with the smallest value greater than target successor = None while root: if root.val > target: successor = root root = root.left else: root = root.right return successor"},{"question":"Write a function that takes in a string `s` and an array of pairs of indices `pairs` where each pair ((a, b)) represents swapping the characters at index `a` and index `b`. The function should return the lexicographically smallest string that can be formed by performing the swaps any number of times. You can assume that the string `s` only contains lowercase English letters and the length of `s` is at most 100000. The pairs array can contain between 1 and 10^5 pairs. Implement the function: * `string smallestStringWithSwaps(string s, vector<vector<int>>& pairs)`","solution":"from collections import defaultdict from itertools import product def smallestStringWithSwaps(s, pairs): Returns the lexicographically smallest string that can be formed by performing the swaps any number of times described in pairs of indices. # Union-Find data structure to group connected indices parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Union all pairs for a, b in pairs: union(a, b) # Group all connected indices connected_components = defaultdict(list) for i in range(len(s)): root = find(i) connected_components[root].append(i) # Sort and rebuild the result string result = list(s) for indices in connected_components.values(): sorted_chars = sorted(result[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): result[i] = char return \'\'.join(result)"},{"question":"You are given a grid of size `n x n` consisting of non-negative integers. A robot is initially located at the top-left corner of the grid (position `(0, 0)`) and the robot moves right, down, or diagonally right-down through the grid to reach the bottom-right corner (position `(n-1, n-1)`). The robot collects the values of the cells it passes through. Write a function to return the maximum sum of values the robot can collect when it reaches the bottom-right corner.","solution":"def max_sum_path(grid): Returns the maximum sum of values the robot can collect when it reaches the bottom-right corner. :param grid: List[List[int]], a 2D list of non-negative integers. :return: int, the maximum sum of values collected. if not grid or not grid[0]: return 0 n = len(grid) # Create a DP table to store the maximum sums dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row and first column in the dp table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[n-1][n-1]"},{"question":"Given an array of integers `arr` and an integer `x`, you need to determine if there exists a pair of elements in the array whose sum is equal to `x`. If such a pair exists, return `true`; otherwise, return `false`. You must achieve this in O(n) time complexity. For example, given `arr = [10, 15, 3, 7]` and `x = 17`, you should return `true` because `10 + 7 = 17`.","solution":"def pair_with_sum(arr, x): Returns true if there exists a pair of elements in the array whose sum is equal to x. :param arr: List of integers :param x: Target sum :return: Boolean seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"You are given an array of integers `nums` and an integer `k`. A *subarray* is a contiguous part of the original array. A *balanced subarray* is one where the sum of the subarray\'s elements is divisible by `k`. Write a function to find the total number of balanced subarrays in the given array.","solution":"def count_balanced_subarrays(nums, k): Returns the total number of balanced subarrays where the sum of the subarray\'s elements is divisible by k. count = 0 prefix_sum = 0 prefix_mods = {0: 1} # Dictionary to store frequency of prefix sums modulo k for num in nums: prefix_sum += num mod = prefix_sum % k # Adjust mod to be positive if mod < 0: mod += k if mod in prefix_mods: count += prefix_mods[mod] prefix_mods[mod] += 1 else: prefix_mods[mod] = 1 return count"},{"question":"Given a string `s` consisting of lowercase letters and an integer array `indices` of the same length, rearrange the string according to the given indices and return the rearranged string. More formally, you need to construct a new string `result` where `result[i] = s[indices[i]]`.","solution":"def rearrange_string(s, indices): Returns the rearranged string according to the given indices. :param s: A string consisting of lowercase letters. :param indices: An integer array of the same length as s. :return: The rearranged string. n = len(s) result = [\'\'] * n for i, index in enumerate(indices): result[index] = s[i] return \'\'.join(result)"},{"question":"You are given a list of non-negative integers `arr` representing the amount of money of each house in a row of houses. Each house has a certain amount of money stashed, and all houses are arranged in a straight line. The constraint is that you cannot rob two adjacent houses. Return the maximum amount of money you can rob tonight without alerting the police. Implement the function: * `int rob(vector<int>& arr)` Example: ```python Input: arr = [2, 7, 9, 3, 1] Output: 12 Explanation: Rob house 1 (money = 2) and then rob house 3 (money = 9) and then rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ```","solution":"def rob(arr): Returns the maximum amount of money that can be robbed without robbing two adjacent houses. :param arr: List of non-negative integers representing the amount of money at each house. :return: Maximum amount of money that can be robbed. if not arr: return 0 if len(arr) == 1: return arr[0] # Initialize dp array dp = [0] * len(arr) dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, len(arr)): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"You are given a list of `n` positive integers representing the heights of columns in a histogram. Each column is of the same width `1`. Your task is to find the area of the largest rectangle that can be formed within the bounds of the histogram. The rectangle must be confined between some range of columns, but its sides must be aligned with the x and y axes. Implement a function `int largestRectangleArea(vector<int>& heights)` that returns the area of the largest rectangle that can be formed in the histogram.","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a `matrix` with `m` rows and `n` columns, filled with non-negative integers. A **move** consists of selecting any element of the matrix and increasing it by 1. Return _the minimum number of moves required to make all the matrix elements equal_. You can increase the value of multiple elements simultaneously but each selected element can only be incremented by 1 in a single move.","solution":"def minMoves(matrix): Return the minimum number of moves required to make all the matrix elements equal. # Flatten the matrix into a list of values flat_matrix = [item for row in matrix for item in row] # Find the minimum value in the matrix min_value = min(flat_matrix) # Calculate the total number of moves required moves = sum(item - min_value for item in flat_matrix) return moves"},{"question":"You are given a list of integers `nums` representing a sequence of numbers. Design an algorithm to determine the length of the longest arithmetic subsequence in `nums`. An arithmetic subsequence is a sequence of numbers where the difference between consecutive elements is constant. That is, for an arithmetic subsequence of the form `[a1, a2, ..., an]`, the difference `a2 - a1` is the same as `a3 - a2`, and so on. Return the length of the longest arithmetic subsequence in the given list. If there are multiple subsequences with the same length, return the length of any one of them.","solution":"def longest_arith_seq_length(nums): Returns the length of the longest arithmetic subsequence in nums. if not nums: return 0 # dp array to store the length of the arithmetic sequence dp = [{} for _ in range(len(nums))] max_length = 1 for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"You are given a `string` `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation any number of times: choose any substring of `s` and delete it. Your task is to determine the **minimum number of operations** needed to make the string empty. Return the _minimum number of operations_ required to remove all characters from the string.","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string empty. return len(s)"},{"question":"Given an integer array `heights` representing the height of buildings along a street, and an integer `distance`, return the maximum number of buildings you can see from any building when looking to the right. A building `i` can see building `j` if `i < j` and `heights[j]` is taller than any building between `i` and `j`, and the distance between buildings `i` and `j` does not exceed `distance`.","solution":"def max_visible_buildings(heights, distance): Given an array of building heights and a maximum distance, return the maximum number of buildings visible from any building when looking to the right, given that a building can only see taller buildings within the specified distance range. n = len(heights) max_visible = 0 # Iterate over each building as the starting point for i in range(n): visible_count = 0 max_height = heights[i] # Check buildings within the specified distance to the right for j in range(i + 1, min(i + distance + 1, n)): if heights[j] > max_height: visible_count += 1 max_height = heights[j] max_visible = max(max_visible, visible_count) return max_visible"},{"question":"You are given an integer array `nums` and an integer `target`. You want to find the number of unique pairs `(i, j)` with `0 <= i < j < nums.length` such that the sum of `nums[i]` and `nums[j]` equals `target`. Return the number of unique pairs that sum up to `target`.","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) such that 0 <= i < j < len(nums) and nums[i] + nums[j] == target. seen = {} unique_pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: for comp_idx in seen[complement]: if comp_idx < i: unique_pairs.add((comp_idx, i)) if num not in seen: seen[num] = [] seen[num].append(i) return len(unique_pairs)"},{"question":"You are given a string `s` and an integer `k`. Rearrange the characters of the string `s` such that each character appears at least once in every `k` length substring of the result. If it is not possible to rearrange the string in this way, return an empty string. If multiple valid rearrangements exist, return any of them.","solution":"from collections import Counter import heapq def rearrangeString(s, k): Rearrange the characters of the string `s` such that each character appears at least once in every `k` length substring of the result. If it is not possible, return an empty string. if k == 0: return s char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: curr_count, curr_char = heapq.heappop(max_heap) result.append(curr_char) queue.append((curr_char, curr_count + 1)) if len(queue) >= k: front_char, front_count = queue.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return \'\'.join(result) if len(result) == len(s) else \'\' # Test case example print(rearrangeString(\'aabbcc\', 3)) # Output: e.g., \'abcabc\' or any valid permutation print(rearrangeString(\'aaabc\', 3)) # Output: \'\' print(rearrangeString(\'aaadbbcc\', 2))# Output: e.g., \'abacabcd\' or any valid permutation"},{"question":"Given a two-dimensional grid of integers where each element in the grid represents the height of a terrain, determine the maximum area of water that could exist on a flat surface of the terrain, assuming water can only exist in valleys. The height of the terrain is given as a 2D integer array `heights` of size `m x n`. The water can only be contained by higher terrain, and you may assume all edges of the grid are mountains that prevent water from flowing out. Return the maximum volume of water that can be trapped in the grid.","solution":"import heapq def max_water_volume(heights): if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the border cells onto the heap and mark them visited for i in range(m): for j in [0, n-1]: heapq.heappush(heap, (heights[i][j], i, j)) visited[i][j] = True for j in range(n): for i in [0, m-1]: heapq.heappush(heap, (heights[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_volume = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_volume += max(0, height - heights[nx][ny]) heapq.heappush(heap, (max(height, heights[nx][ny]), nx, ny)) return water_volume"},{"question":"You are given `n` non-negative integers representing the histogram\'s bar height where the width of each bar is `1`. Return the area of the largest rectangle in the histogram.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram. :param heights: List of non-negative integers representing the histogram\'s bar heights. :return: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` that consists of letters, digits, and special characters. Write a function to return a new string where all the digits are grouped at the beginning, all the letters are grouped in the middle, and all the special characters are grouped at the end, maintaining their original relative order within each group. Return _the newly rearranged string_.","solution":"def rearrange_string(s): Rearranges the string such that all digits are at the beginning, followed by letters, and all special characters at the end, maintaining their relative order. Parameters: - s (str): The input string containing digits, letters, and special characters. Returns: - str: The rearranged string. digits = [] letters = [] special_chars = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) else: special_chars.append(char) return \'\'.join(digits) + \'\'.join(letters) + \'\'.join(special_chars)"},{"question":"Given a list of non-negative integers `nums`, subtract the smallest element in the list from each element in the list. Return the modified list after every element has been decremented by the smallest value in the original list, in the same order as they appeared in the original list.","solution":"def subtract_minimum(nums): Given a list of non-negative integers, subtract the smallest element from each element. Args: nums (List[int]): A list of non-negative integers. Returns: List[int]: A list after subtracting the smallest element from each element in the list. if not nums: return nums # if the list is empty, return it as it is min_val = min(nums) # find the minimum value in the list return [num - min_val for num in nums] # subtract min_val from each element and return the new list"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` represents a shuffled version of some original string, and the `indices` array indicates the indices of the characters in the original string. More specifically, if `indices[i] = j`, then the character `s[i]` belongs in position `j` in the original string. Reconstruct the original string and return it. Implement the `reconstructString` function: - `String reconstructString(String s, int[] indices)` **Example:** - Input: `s = \\"aiohn\\", indices = [3,1,4,2,0]` - Output: `\\"nihao\\"` **Note:** - `s` will contain only lowercase English letters. - `indices` is a permutation of the integers from 0 to `s.length() - 1`.","solution":"def reconstructString(s, indices): Reconstructs the original string from its shuffled version and the given indices. Parameters: s (str): The shuffled string. indices (List[int]): The indices array representing where each character should go. Returns: str: The original string. # Initialize an empty list with the same length as s reconstructed = [\'\'] * len(s) # Place each character in its original position for i, index in enumerate(indices): reconstructed[index] = s[i] # Join the list to form the reconstructed string return \'\'.join(reconstructed)"},{"question":"Given a `matrix` where each cell contains either a `0` (representing an empty cell) or a `1` (representing an obstacle), write a function to find the length of the shortest path from the top-left corner to the bottom-right corner. The path can only be formed by moving either down or right at any point in time. If there is no such path, return -1.","solution":"def shortest_path(matrix): from collections import deque def is_valid_move(x, y, rows, cols): return 0 <= x < rows and 0 <= y < cols and matrix[x][y] == 0 if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 rows, cols = len(matrix), len(matrix[0]) queue = deque([(0, 0, 1)]) directions = [(1, 0), (0, 1)] visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, rows, cols) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Consider a binary tree where each node contains an integer value. Implement the `BinaryTree` class with the following methods: * `BinaryTree(int[] nodes)` - Initializes the binary tree from the given array of integers using level order insertion. The value `null` in the array represents a missing node. * `int findLCA(int node1, int node2)` - Finds the Lowest Common Ancestor (LCA) of the two given nodes in the binary tree. The LCA is defined as the furthest node from the root that is an ancestor of both `node1` and `node2`. If either `node1` or `node2` is not present in the tree, return `-1`.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self, nodes): if not nodes: self.root = None else: self.root = TreeNode(nodes[0]) queue = [self.root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] is not None: current.left = TreeNode(nodes[i]) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] is not None: current.right = TreeNode(nodes[i]) queue.append(current.right) i += 1 def findLCA(self, node1, node2): def find_and_trace_ancestor(root, val): if root is None: return None if root.val == val: return [root] left_path = find_and_trace_ancestor(root.left, val) if left_path: return [root] + left_path right_path = find_and_trace_ancestor(root.right, val) if right_path: return [root] + right_path return None path1 = find_and_trace_ancestor(self.root, node1) path2 = find_and_trace_ancestor(self.root, node2) if not path1 or not path2: return -1 i = 0 while i < len(path1) and i < len(path2) and path1[i] == path2[i]: i += 1 return path1[i - 1].val if i > 0 else -1"},{"question":"Given a list of meeting time intervals consisting of start and end times `[[s1, e1], [s2, e2], ...]` (si < ei), determine if a person could attend all meetings. The list is not necessarily ordered. Return `true` if a person can attend all meetings without conflicts, otherwise return `false`.","solution":"def can_attend_meetings(intervals): Determine if a person can attend all meetings without conflicts. Args: intervals: List of intervals where each interval is a list of two integers [start, end] Returns: Boolean value indicating if a person can attend all meetings # Sort the intervals based on the start times intervals.sort(key=lambda x: x[0]) # Check for any overlapping intervals for i in range(1, len(intervals)): if intervals[i][0] < intervals[i - 1][1]: return False return True"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of trees, where `heights[i]` is the height of the `i-th` tree. You need to find out if there exists a pair of trees such that the absolute difference between their heights is exactly equal to a given integer `d`. Return `true` if such a pair exists, and `false` otherwise.","solution":"def find_pair_with_difference(heights, d): Given a list of integer heights and an integer d, this function checks if there exists a pair of trees with an absolute height difference equal to d. Parameters: heights (list of int): List of tree heights. d (int): Target difference to find. Returns: bool: True if such a pair exists, False otherwise. seen_heights = set() for height in heights: if (height + d) in seen_heights or (height - d) in seen_heights: return True seen_heights.add(height) return False"},{"question":"You are tasked with writing a function to simulate the behavior of a basic text editor with a limited set of operations. The text editor supports the following operations: - `append <string>`: Append the given string to the end of the current text. - `delete <k>`: Delete the last `k` characters from the current text. - `print <k>`: Print the `k`-th character of the current text (1-indexed). - `undo`: Undo the last performed operation (limited to `append` and `delete`). Implement the `TextEditor` class: - `TextEditor()`: Initializes the object with an empty text. - `void append(String str)`: Appends the given string to the current text. - `void delete(int k)`: Deletes the last `k` characters from the current text. - `char print(int k)`: Returns the `k`-th character of the current text (1-indexed). - `void undo()`: Undoes the last performed `append` or `delete` operation. Your implementation should efficiently handle multiple operations and maintain the history to allow for undo operations.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def delete(self, k): self.history.append(self.text) self.text = self.text[:-k] def print_char(self, k): if 1 <= k <= len(self.text): return self.text[k - 1] else: raise IndexError(\\"Index out of bounds\\") def undo(self): if self.history: self.text = self.history.pop()"},{"question":"In an alien language, surprisingly, there are only three distinct characters: \'a\', \'b\', and \'c\'. You are given a string `text` consisting solely of these characters. The string has a special property – it is balanced if, and only if, it does not contain \'abc\' as a substring (i.e., no \'a\' is immediately followed by \'b\', followed by \'c\'). Your task is to determine the maximum possible length of a balanced substring that can be obtained by deleting some characters (possibly zero) from `text`. Return the length of this balanced substring.","solution":"def max_balanced_substring_length(text): Returns the maximum length of a balanced substring that can be obtained from text. A substring is balanced if it does not contain \'abc\' as a substring. count_a = text.count(\'a\') count_b = text.count(\'b\') count_c = text.count(\'c\') # Return the total length of text minus the length of the longest \'abc\' pattern return count_a + count_b + count_c"},{"question":"Write a function that accepts a positive integer `n` and returns an array representing the first `n` rows of Pascal\'s Triangle. In Pascal\'s Triangle, each number is the sum of the two numbers directly above it.","solution":"def generate_pascals_triangle(n): Returns the first n rows of the Pascal\'s Triangle. Parameters: n (int): The number of rows to generate. Returns: List[List[int]]: A list of lists representing the first n rows of Pascal\'s Triangle. if n <= 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"Given an array `nums` containing `n` integers where each integer is in the range [1, n] inclusive, you need to detect all the integers that appear more than once in the array. Write a function that returns an array of all the duplicate integers in any order.","solution":"def find_duplicates(nums): Returns a list of integers that appear more than once in the array nums. Parameters: nums (list): A list of integers where each integer is in the range [1, n] where n is the length of the list. Returns: list: A list of duplicated integers. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(index + 1) else: nums[index] = -nums[index] return duplicates"},{"question":"Given a binary tree, write a function `findLCA` that finds the **Lowest Common Ancestor** (LCA) of two given nodes in the tree. The Lowest Common Ancestor is defined between two nodes p and q as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself). The tree is represented by a `TreeNode` class, where each `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` The function `findLCA` takes three arguments: the `root` of the tree, and the two nodes `p` and `q` whose LCA needs to be found. Return the LCA node. Example: ```python # Example 1: # Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = TreeNode(5), q = TreeNode(1) # Output: TreeNode(3) # Example 2: # Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = TreeNode(5), q = TreeNode(4) # Output: TreeNode(5) ``` **Note:** - All values are unique within the tree. - You may assume that both `p` and `q` are always present in the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, p, q): Finds the Lowest Common Ancestor (LCA) of two given nodes in the binary tree. Parameters: root (TreeNode): The root of the binary tree. p (TreeNode): The first node. q (TreeNode): The second node. Returns: TreeNode: The Lowest Common Ancestor of nodes p and q. # Base case if root is None or root == p or root == q: return root # Search in left and right subtrees left = findLCA(root.left, p, q) right = findLCA(root.right, p, q) # If both subtrees return non-null, root is the LCA if left and right: return root # If left is non-null, LCA is in the left subtree return left if left else right"},{"question":"You are given an array of integers `tasks` where `tasks[i]` represents the amount of time it takes to complete the i-th task. Each day you can complete two tasks as long as their combined time does not exceed a given integer `maxTime`. Return the minimum number of days required to complete all the tasks. If it is not possible to complete all tasks, return `-1`.","solution":"def min_days_to_complete_tasks(tasks, maxTime): Returns the minimum number of days required to complete all the tasks given that each day you can complete two tasks as long as their combined time does not exceed maxTime. If it is not possible to complete all tasks, return -1. tasks.sort() left = 0 right = len(tasks) - 1 days = 0 while left <= right: if left == right: # Only one task left days += 1 left += 1 elif tasks[left] + tasks[right] <= maxTime: days += 1 left += 1 right -= 1 else: days += 1 right -= 1 return days"},{"question":"Given two strings `a` and `b`, return the shortest string that has both `a` and `b` as subsequences. If there are multiple valid answers, return any of them. A string `x` is a subsequence of string `y` if deleting some (can be none) characters from `y` results in the string `x`.","solution":"def shortest_common_supersequence(a, b): Returns the shortest string that has both `a` and `b` as subsequences. m, n = len(a), len(b) # Create a DP table to find the length of the shortest supersequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif a[i - 1] == b[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the shortest common supersequence i, j = m, n superseq = [] while i > 0 and j > 0: if a[i - 1] == b[j - 1]: superseq.append(a[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] < dp[i][j - 1]: superseq.append(a[i - 1]) i -= 1 else: superseq.append(b[j - 1]) j -= 1 while i > 0: superseq.append(a[i - 1]) i -= 1 while j > 0: superseq.append(b[j - 1]) j -= 1 return \'\'.join(superseq[::-1])"},{"question":"Given a string `s` consisting of lowercase English letters and a pattern `p` consisting of lowercase English letters and the character `*`, implement a function to find the longest substring in `s` that matches the pattern `p`. The character `*` in the pattern can replace any sequence of characters (including the empty sequence). Return _the longest substring of_ `s` _that matches the pattern_ `p`. If multiple substrings match and have the same length, return the one that appears first. If no substrings match, return an empty string.","solution":"def longest_substring_match(s, p): def match(s, p): m, n = len(s), len(p) dp = [True] + [False] * n for i in range(1, n + 1): if p[i - 1] == \'*\': dp[i] = dp[i - 1] else: break for i in range(1, m + 1): prev_dp = dp[:] dp[0] = False for j in range(1, n + 1): if p[j - 1] == \'*\': dp[j] = dp[j - 1] or dp[j] else: dp[j] = prev_dp[j - 1] and p[j - 1] == s[i - 1] return dp[n] max_len = 0 longest_substring = \\"\\" for i in range(len(s)): for j in range(i+1, len(s)+1): substring = s[i:j] if match(substring, p) and len(substring) > max_len: max_len = len(substring) longest_substring = substring return longest_substring"},{"question":"Write a function to find the longest common prefix string amongst an array of strings `strs`. If there is no common prefix, return an empty string `\\"\\"`. A common prefix for a set of strings is the initial portion of each string that is the same for all strings in the set.","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Args: strs (List[str]): An array of strings. Returns: str: The longest common prefix, or an empty string if there is no common prefix. if not strs: return \\"\\" # Start with the first string in the array as the prefix prefix = strs[0] # Compare the prefix with each string in the array for string in strs[1:]: while string[:len(prefix)] != prefix: # Reduce the prefix by one character until it matches the start of string prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"You are given a rectangular cake represented as a `grid` of size `m x n`, where each cell of the grid has an integer value representing its sweetness. A chef needs to cut the cake into exactly `k` rectangular pieces such that each piece has the same total sweetness. A cut can be made either horizontally or vertically along the boundaries between cells. Return `true` if it is possible to cut the cake into `k` pieces with equal total sweetness, and `false` otherwise.","solution":"def can_cut_cake_equitably(grid, k): Determine if the cake can be cut into k pieces with equal total sweetness. :param grid: List[List[int]], 2D list representing the cake\'s sweetness values. :param k: int, the number of pieces to divide the cake into. :return: bool, True if possible to divide the cake into k equal-sweetness pieces, False otherwise. total_sweetness = sum(sum(row) for row in grid) # If the total sweetness cannot be divided equally into k pieces, return False if total_sweetness % k != 0: return False target_sweetness = total_sweetness // k # Helper function to check if a prefix sum is achievable def can_partition(prefix_sums, target): current_sum, count = 0, 0 for ps in prefix_sums: current_sum += ps if current_sum == target: count += 1 current_sum = 0 return count >= k # Check horizontal cuts row_sums = [sum(row) for row in grid] if can_partition(row_sums, target_sweetness): return True # Check vertical cuts col_sums = [sum(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0]))] if can_partition(col_sums, target_sweetness): return True return False"},{"question":"Given two non-negative integers, `num1` and `num2`, return _the sum of the two integers represented as a string_. You should not convert the integers to strings directly and only use string manipulation for constructing the final sum string.","solution":"def add_strings(num1, num2): Returns the sum of two non-negative integers represented as strings. The function does not directly convert the entire integers to strings but constructs the final sum string using string manipulation. i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] while i >= 0 or j >= 0 or carry: n1 = int(num1[i]) if i >= 0 else 0 n2 = int(num2[j]) if j >= 0 else 0 total = n1 + n2 + carry carry = total // 10 result.append(str(total % 10)) i -= 1 j -= 1 return \'\'.join(result[::-1])"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `x`. Your task is to check whether there exists a subarray of `nums` whose elements add up to `x`. A subarray is a contiguous portion of an array. Return _`true` if there exists such a subarray, otherwise return `false`_.","solution":"def does_subarray_sum_to_x(nums, x): Checks whether there exists a subarray of nums that adds up to x. current_sum = 0 prefix_sums = {0} for num in nums: current_sum += num if (current_sum - x) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"Given a `n x n` integer matrix `matrix`, rotate the matrix by 90 degrees (clockwise). You have to perform this rotation [in place](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input matrix directly. Do not allocate another 2D matrix and do the rotation.","solution":"def rotate_matrix(matrix): Rotates the input n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a robot with an infinite grid. The robot starts at position `(0,0)` and initially faces north. The robot can receive a sequence of instructions where each instruction is either: - `\'G\'` (go straight 1 unit), - `\'L\'` (turn 90 degrees to the left), - `\'R\'` (turn 90 degrees to the right). The robot performs the instructions repeatedly, i.e., once the sequence of instructions is over, the robot continues to repeat it from the beginning. Given an integer `n` representing the number of times the robot repeats the instruction sequence, determine if the robot returns to the starting point `(0, 0)` after executing the instructions `n` times. Write a function `bool isRobotAtOrigin(string instructions, int n)` that returns `true` if the robot returns to the starting point after `n` repetitions of the instruction sequence, and `false` otherwise.","solution":"def isRobotAtOrigin(instructions, n): Determines if the robot returns to the starting point after repeating the given instructions n times. :param instructions: str : A string of instructions \'G\', \'L\', \'R\'. :param n: int : Number of times the instruction sequence is repeated. :return: bool : True if the robot returns to the starting point (0,0), False otherwise. # Initial position and direction, where 0 = North, 1 = East, 2 = South, 3 = West x, y, dir = 0, 0, 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # North, East, South, West # Function to execute one iteration of instruction sequence def move(instructions): nonlocal x, y, dir for instruction in instructions: if instruction == \'G\': x += directions[dir][0] y += directions[dir][1] elif instruction == \'L\': dir = (dir - 1) % 4 elif instruction == \'R\': dir = (dir + 1) % 4 # Simulate the instructions n times for _ in range(n): move(instructions) return x == 0 and y == 0"},{"question":"Given a **0-indexed** integer array `nums` containing `n` distinct integers, you need to return an array `result` such that for each `nums[i]`, `result[i]` is the number of integers from the array that are smaller than `nums[i]`. The array `result` should be of the same size as `nums`. For example, if `nums = [8,1,2,2,3]`, then `result` should be `[4,0,1,1,3]` since: - `8` has `4` numbers smaller than it, - `1` has `0` numbers smaller than it, - each `2` has `1` number smaller than it, and - `3` has `3` numbers smaller than it.","solution":"def smallerNumbersThanCurrent(nums): Given a list of distinct integers, return a list where each element is the number of elements that are smaller than the current element in the original list. result = [] for i in range(len(nums)): count = sum(1 for num in nums if num < nums[i]) result.append(count) return result"},{"question":"Given an **n x n** 2D matrix `mat` representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in place, which means you have to modify the input 2D matrix directly. Do not allocate another 2D matrix and do the rotation. For example: - If `mat` is [[1,2,3], [4,5,6], [7,8,9]], the rotated matrix should be [[7,4,1], [8,5,2], [9,6,3]]. - If `mat` is [[5,1,9,11], [2,4,8,10], [13,3,6,7], [15,14,12,16]], the rotated matrix should be [[15,13,2,5], [14,3,4,1], [12,6,8,9], [16,7,10,11]]. Note: You should not return anything. Modify `mat` in-place.","solution":"def rotate(matrix): Rotate the given n x n 2D matrix by 90 degrees (clockwise) in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a **0-indexed** array `arr` of integers and a **0-indexed** array of integer **queries** of length `q`, where each query is either in the form `[1, index, val]` or `[2, left, right]`. The `ith` query can be one of two types: 1. `[1, index, val]` indicates that you should update the element at `index` in `arr` to `val`. 2. `[2, left, right]` requests the sum of the elements in `arr` from the `left` index to the `right` index (both inclusive). Return _an array_ `results` _of length equal to the number of type-2 queries, where_ `results[i]` _is the sum returned from the_ `ith` _type-2 query._","solution":"def process_queries(arr, queries): results = [] for query in queries: if query[0] == 1: # Update operation index, val = query[1], query[2] arr[index] = val elif query[0] == 2: # Sum operation left, right = query[1], query[2] result = sum(arr[left:right+1]) results.append(result) return results"},{"question":"Given an array of integers `arr`, sort the array in such a manner that the even numbers come first followed by the odd numbers, maintaining their relative order of appearance within their respective groups. Return _the modified array_.","solution":"def sort_even_odd(arr): Sort the array such that even numbers come first followed by odd numbers, maintaining their relative order of appearance within their respective groups. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"You are given an array of integers `arr` which represents the daily temperature record over some days. Write a function that returns an array `res` such that `res[i]` is the number of days you would have to wait after the `i-th` day to get a warmer temperature. If there is no future day for which this is possible, put `0` instead. # Constraints: - 1 <= `arr.length` <= 10000 - -100 <= `arr[i]` <= 100 # Example: Given the array `arr = [73, 74, 75, 71, 69, 72, 76, 73]`, the function should return `[1, 1, 4, 2, 1, 1, 0, 0]`. Given the array `arr = [50, 40, 30, 20, 10]`, the function should return `[0, 0, 0, 0, 0]`. Write the function `int[] dailyTemperatures(int[] arr)`.","solution":"def dailyTemperatures(arr): res = [0] * len(arr) stack = [] for i, temp in enumerate(arr): while stack and arr[stack[-1]] < temp: prev_day = stack.pop() res[prev_day] = i - prev_day stack.append(i) return res"},{"question":"You are given a **0-indexed** 2D integer array `edges`, where `edges[i] = [ai, bi]` denotes an undirected edge between nodes `ai` and `bi` in a connected graph. Design a function to determine the minimum number of edges that need to be removed to make the graph acyclic (i.e., to make it a tree). Return this minimum number of edges. **Note:** 1. The graph initially is guaranteed to be connected. 2. Self-loops and multiple edges between two nodes are allowed.","solution":"def min_edges_to_remove(edges): Returns the minimum number of edges that need to be removed to make the graph acyclic (i.e., to make it a tree). :param edges: List[List[int]] - a 2D integer array of undirected edges :return: integer - the minimum number of edges to remove if not edges: return 0 # Count vertices. We assume the highest numbered vertex determines the count. vertices = set() for u, v in edges: vertices.add(u) vertices.add(v) V = len(vertices) total_edges = len(edges) # Minimum edges to remove to make the graph a tree. return total_edges - (V - 1)"},{"question":"You are given a list of `n` integers representing the heights of the buildings aligned in a row. The width of each building is `1`. It starts raining, and water is trapped between the buildings. Compute how much water is trapped after raining. Return an integer representing the total units of water trapped.","solution":"def trapped_water(heights): Computes the total units of water trapped after raining given the heights of buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: Total units of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"You are given a list of `n` computers. Each computer has an associated CPU processing power denoted by the array `power`, where `power[i]` represents the processing power of the ith computer. You are also given a list of `pairs` where each `pairs[j] = [computer1j, computer2j]` indicates that there is a direct network connection between `computer1j` and `computer2j`. A computer can communicate with another computer either directly or indirectly through a series of network connections. You need to find the **maximum processing power** that can be achieved by combining the processing powers of a group of connected computers. Return this maximum processing power.","solution":"def find_max_processing_power(n, power, pairs): from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for u, v in pairs: graph[u].append(v) graph[v].append(u) # To track visited nodes visited = [False] * n def bfs(start): queue = deque([start]) visited[start] = True total_power = 0 while queue: node = queue.popleft() total_power += power[node] for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_power max_power = 0 # Perform BFS to find all connected components for i in range(n): if not visited[i]: max_power = max(max_power, bfs(i)) return max_power"},{"question":"Given a string `sequence` and a string `word`, return _the maximum number of times_ `word` _can be repeated as a substring in_ `sequence`. The substrings can overlap. For example, in the sequence `\\"abababab\\"` and the word `\\"ab\\"`, the word can be repeated `\\"4\\"` times.","solution":"def max_repeating(sequence, word): Returns the maximum number of times word can be repeated as a substring in sequence. count = 0 repeated_word = word # Increase the repeated_word by adding word until it is no longer a substring of sequence while repeated_word in sequence: count += 1 repeated_word += word return count"},{"question":"Given a string `s` that contains only digits, determine the number of ways to decode it. The mapping is [\'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\']. Assume that the input string is non-empty and contains only valid digits. Implement a function `numDecodings(s)` that takes a string `s` and returns the number of ways to decode it. Note that the input string may contain digits that correspond to multiple valid mappings (e.g., \'123\' could be decoded as \'ABC\', \'LC\', or \'AW\').","solution":"def numDecodings(s): Given a string s that contains only digits, determine the number of ways to decode it. The mapping is: \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'. if s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and s[i - 2] == \'1\' or (s[i - 2] == \'2\' and s[i - 1] <= \'6\'): dp[i] += dp[i - 2] return dp[n]"},{"question":"Given an integer array `heights` representing the heights of buildings and an integer `k`, return the minimum number of bricks you need to remove so that there are no more than `k` buildings of the same height standing in a row. For example, if the input is `heights = [3,3,3,3,4,4,4,1,1,1,1,1,3,3]` and `k = 2`, the output should be `6` because you need to remove four `3`s and two `1`s to ensure no more than two buildings of the same height are consecutive.","solution":"def minimum_bricks_to_remove(heights, k): Given an integer array `heights` representing the heights of buildings and an integer `k`, returns the minimum number of bricks needed to be removed so that there are no more than `k` buildings of the same height standing in a row. Parameters: heights (list of int): The heights of the buildings. k (int): The maximum allowable consecutive buildings of the same height. Returns: int: The minimum number of bricks to remove. if not heights: return 0 removes = 0 count = 1 # Start from the first building for i in range(1, len(heights)): if heights[i] == heights[i - 1]: # Consecutive same height count += 1 else: removes += max(0, count - k) count = 1 # Reset count for new height # Handle the last sequence removes += max(0, count - k) return removes"},{"question":"You are given a non-negative integer array `arr` and an integer `k`. You need to create a new array `result` such that each element in the `result` array is the sum of `k` consecutive elements from the `arr` array, starting from the first element. If there are fewer than `k` elements left at any point, just sum the remaining elements and include that sum in `result`. Return the `result` array.","solution":"def sum_of_k_consecutive_elements(arr, k): Returns a new array such that each element in the new array is the sum of k consecutive elements from the given array arr. If there are fewer than k elements left, sum the remaining elements. :param arr: List of non-negative integers :param k: Integer, number of consecutive elements to sum :return: List of integers representing the sum of k consecutive elements result = [] for i in range(0, len(arr), k): result.append(sum(arr[i:i+k])) return result"},{"question":"You are given a string `s` of length `n`. You can perform the following operation on `s` at most once: choose any index `i` (1 <= i <= n) and remove the character at that index. A string is considered to be beautiful if it contains no two adjacent characters that are the same. Return _the minimum length of the string_ `s` after the operation so that it becomes beautiful. If the string is already beautiful, return `n`.","solution":"def min_length_beautiful_string(s): Returns the minimum length of the string s after removing at most one character so that it becomes beautiful. A string is considered beautiful if it contains no two adjacent characters that are the same. n = len(s) for i in range(1, n): if s[i] == s[i-1]: # Check if removing s[i-1] or s[i] makes the string beautiful s1 = s[:i-1] + s[i:] s2 = s[:i] + s[i+1:] return min(len(s1), len(s2)) return n"},{"question":"You are given a string `s` consisting of only characters \'a\' and \'b\'. You can perform the following operations on the string an unlimited number of times: - Choose a non-empty substring consisting of only \'a\'s and replace it with a single \'b\'. - Choose a non-empty substring consisting of only \'b\'s and replace it with a single \'a\'. Return the minimum number of operations needed to make the entire string consist of only one type of character.","solution":"def min_operations_to_uniform(s): Returns the minimum number of operations needed to make the entire string consist of only one type of character. if not s: return 0 # Count the number of \'a\' groups and \'b\' groups count_a = 0 count_b = 0 # Initialize the previous character for comparison prev_char = s[0] if prev_char == \'a\': count_a += 1 else: count_b += 1 # Iterate through the string to count groups for char in s[1:]: if char != prev_char: if char == \'a\': count_a += 1 else: count_b += 1 prev_char = char return min(count_a, count_b)"},{"question":"You are given a grid of size `m x n` filled with non-negative numbers, representing the elevation of a region. Your goal is to calculate the maximum water that can be trapped in the region after raining, given that water can only be trapped in cells that are surrounded by higher elevation on all four sides. Write a function that takes the grid as input and returns the maximum amount of water trapped.","solution":"import heapq def trap_rain_water(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Initialize the priority queue with all the boundary cells for i in range(m): heapq.heappush(min_heap, (heightMap[i][0], i, 0)) heapq.heappush(min_heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = visited[i][n-1] = True for j in range(n): heapq.heappush(min_heap, (heightMap[0][j], 0, j)) heapq.heappush(min_heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = visited[m-1][j] = True result = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Process the cells in the priority queue while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy # If it\'s inside the grid and not visited if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True # Check if water can be trapped and add to the result result += max(0, height - heightMap[nx][ny]) # Push the cell into the priority queue with updated height heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return result"},{"question":"You are given the `root` of a binary tree where each node contains a single digit (0-9). Each root-to-leaf path in the binary tree represents a number. Find the total sum of all the numbers represented by the root-to-leaf paths in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): def helper(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return helper(node.left, current_number) + helper(node.right, current_number) return helper(root, 0)"},{"question":"Given an integer array `time` where `time[i]` represents the duration of the ith song, return the number of pairs of songs for which their total duration in seconds is divisible by 60.","solution":"def num_pairs_divisible_by_60(time): Returns the number of pairs of songs for which their total duration in seconds is divisible by 60. Parameters: time (List[int]): a list of integers representing the duration of each song in seconds. Returns: int: the number of valid pairs. remainder_count = [0] * 60 count = 0 for t in time: remainder = t % 60 complement = (60 - remainder) % 60 # To handle the case when remainder is 0 count += remainder_count[complement] remainder_count[remainder] += 1 return count"},{"question":"Implement a class `WordFilter` that supports two functions: `addWord(word)` and `findWordWithPrefixAndSuffix(prefix, suffix)`. The `addWord(word)` function will add a given word to the data structure. The `findWordWithPrefixAndSuffix(prefix, suffix)` function should return a word from the data structure that starts with the given `prefix` and ends with the given `suffix`. If multiple words match the criteria, return any one of them. If no words match, return an empty string. The words added to the data structure are guaranteed to be non-empty strings composed of lowercase English letters only.","solution":"class WordFilter: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def findWordWithPrefixAndSuffix(self, prefix, suffix): for word in self.words: if word.startswith(prefix) and word.endswith(suffix): return word return \'\'"},{"question":"A string `s` is said to be a good string if there are no two adjacent characters in `s` that are the same. You are given a string `start` consisting of lowercase English letters. Your task is to find the minimum number of deletions required to make `start` a good string. Delete characters one-by-one to obtain the shortest possible good string. Write a function `int minDeletionsToGoodString(String start)` that takes in the input string `start` and returns the minimum number of deletions needed. **Example:** ``` Input: start = \\"aaabbbcc\\" Output: 5 Explanation: Deleting the characters to make each pair of identical adjacent characters non-adjacent, you have to delete \'a\'s, \'b\'s, and \'c\'s leaving a sequence like \\"abc\\". ``` Ensure that your solution is efficient and runs in O(n) time complexity where n is the length of the string.","solution":"def minDeletionsToGoodString(start): Returns the minimum number of deletions required to make the input string a good string. A string is considered good if it doesn\'t have any two adjacent characters that are the same. if not start: return 0 deletions = 0 # Traverse the string for i in range(1, len(start)): # If the current character is the same as the previous one if start[i] == start[i - 1]: deletions += 1 return deletions"},{"question":"Given a string `s` consisting of lowercase letters, return _the first non-repeating character in `s`. If there is no such character, return a single space `\' \'`_. Note: You must solve this problem with O(n) time complexity.","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no such character, returns a single space \' \'. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \' \'"},{"question":"Given a circular linked list `head` and an integer `n`, determine if the circular linked list contains a sublist of length `n` where all elements are distinct. Return `true` if such a sublist exists, otherwise return `false`. A **circular linked list** is a list where the last element points back to the first element, creating a loop.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_distinct_sublist(head: ListNode, n: int) -> bool: if not head or n <= 0: return False # Use a set to track visited nodes\' values visited = set() current = head length = 0 # First, determine the length of the circular linked list while True: length += 1 current = current.next if current == head: break # If the list length is less than n, it\'s not possible to have such a sublist if length < n: return False # Start sliding window approach start = head for i in range(length): distinct_count = 0 visited.clear() current = start for j in range(n): if current.val in visited: break visited.add(current.val) current = current.next distinct_count += 1 if distinct_count == n: return True start = start.next return False"},{"question":"You are given a binary tree where each node has the values `0` or `1`. Each path from the root to a leaf node represents a binary number. Your task is to convert each binary number represented by the root-to-leaf paths into its decimal value and return _the **sum** of these decimal values_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: def helper(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val # If it\'s a leaf node if not node.left and not node.right: return current_number # Recur for left and right subtrees return helper(node.left, current_number) + helper(node.right, current_number) return helper(root, 0)"},{"question":"You have a collection of `n` computer files. You are given an array `sizes` where `sizes[i]` represents the size of the ith file in megabytes (MB). Additionally, there is an array `dates` where `dates[i]` is a string representing the date when the ith file was last modified, in the format `\\"YYYY-MM-DD\\"`. Write a function to find the largest file that was last modified within the last year (from today\'s date). If no files were modified within the past year, return -1. Assume today\'s date is given as a string `current_date` in the format `\\"YYYY-MM-DD\\"`.","solution":"from datetime import datetime, timedelta def largest_file_within_last_year(sizes, dates, current_date): curr_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") last_year_date = curr_date - timedelta(days=365) largest_size = -1 for size, date_str in zip(sizes, dates): file_date = datetime.strptime(date_str, \\"%Y-%m-%d\\") if file_date >= last_year_date: if size > largest_size: largest_size = size return largest_size"},{"question":"A company wants to reward its employees based on their performance ratings. You are given an integer array `ratings` of size `n` where each rating is between 1 and 100 inclusive. You need to distribute candies to employees such that: * Each employee gets at least one candy. * Employees with higher ratings get more candies than their neighbors. Return the **minimum** number of candies you need to distribute to satisfy the above conditions.","solution":"def min_candies(ratings): Returns the minimum number of candies required to distribute to employees based on their ratings. :param ratings: List[int] - List of integer ratings :return: int - Minimum number of candies n = len(ratings) if n == 0: return 0 # Each employee should get at least one candy candies = [1] * n # Left to right scan for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Right to left scan for j in range(n - 2, -1, -1): if ratings[j] > ratings[j + 1]: candies[j] = max(candies[j], candies[j + 1] + 1) return sum(candies)"},{"question":"Given a matrix `mat` where each element is either 0 or 1. You need to return an array of the same dimensions where each element in the output array is the minimum distance to a 0 in the `mat`. The distance between two adjacent cells is the Manhattan distance. Implement the following function: ```python def updateMatrix(mat: List[List[int]]) -> List[List[int]]: # implementation ``` Where: - `mat` is an `m x n` binary matrix (1s and 0s). Return the updated matrix where each element contains the distance to the nearest 0.","solution":"from typing import List from collections import deque def updateMatrix(mat: List[List[int]]) -> List[List[int]]: m, n = len(mat), len(mat[0]) dist = [[float(\'inf\')] * n for _ in range(m)] queue = deque() # Initialize queue with all \'0\' positions for i in range(m): for j in range(n): if mat[i][j] == 0: dist[i][j] = 0 queue.append((i, j)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS to update distances from \'0\'s while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if dist[nx][ny] > dist[x][y] + 1: dist[nx][ny] = dist[x][y] + 1 queue.append((nx, ny)) return dist"},{"question":"Given a string `s` consisting of lowercase English letters, find the length of the longest contiguous substring with exactly `k` distinct characters. If there is no such substring, return `-1`. For example, given the string `s = \\"eceba\\"` and `k = 2`, the longest contiguous substring with exactly 2 distinct characters is `\\"ece\\"` which has a length of 3.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest contiguous substring with exactly k distinct characters. If there is no such substring, returns -1. if k == 0: return -1 left = 0 max_length = -1 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if len(char_map) == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` and a string `t`. You want to form the shortest possible subsequence by removing characters from `s`, such that the resulting subsequence contains `t` as a substring at least once. Return the length of the shortest such subsequence. If it is not possible to form such a subsequence, return `-1`.","solution":"def shortest_subsequence_length(s, t): Returns the length of the shortest subsequence of s that contains t as a substring. If it is not possible to form such a subsequence, return -1. # Length of strings s and t len_s = len(s) len_t = len(t) # If t is longer than s, it\'s not possible to form t if len_t > len_s: return -1 # Two pointers to check if t is a subsequence of s i, j = 0, 0 while i < len_s and j < len_t: if s[i] == t[j]: j += 1 i += 1 # If we completed traversing t, return len_t (minimum length subsequence) if j == len_t: return len_t else: return -1"},{"question":"You are given a list of `n` unique integers `arr` and an integer `target`. Your task is to determine if there exists a pair of elements in the list that adds up to `target`. If such a pair exists, return `true`; otherwise, return `false`. Write a function `boolean hasPairWithSum(int[] arr, int target)` to achieve this. _Note:_ You may assume all inputs are valid and the list is unsorted.","solution":"def has_pair_with_sum(arr, target): Determines if there exists a pair of elements in the list that adds up to the target. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a `m x n` grid filled with non-negative numbers, representing points on a game board. The goal is to start from the top-left corner of the grid and reach the bottom-right corner with the **maximum** points accumulated. You can only move either down or right at any point in time. Write a function that returns the maximum points you can collect by the end of the trip.","solution":"def max_points(grid): Returns the maximum points collected starting from the top-left corner to the bottom-right corner of the grid. :param grid: List[List[int]], a m x n grid filled with non-negative numbers :return: int, maximum points Approach: Dynamic Programming if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only move right) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only move down) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"You are given a `m x n` 2D grid initialized with three possible values: - `-1` representing an obstacle, - `0` representing an empty cell, - `1` representing a starting point of a signal. The signal spreads to adjacent cells (up, down, left, right) each minute. An obstacle cell `-1` blocks the signal and it cannot pass through it. Given the grid, you need to determine the time taken for all empty cells to receive the signal from any of the starting points. If some empty cells cannot receive the signal, return `-1`. Otherwise, return the time taken in minutes for all empty cells to be covered by the signal.","solution":"from collections import deque def time_to_propagate_signal(grid): if not grid: return -1 rows, cols = len(grid), len(grid[0]) queue = deque() visited = set() empty_cells = 0 # Initialize the queue with all starting points and count empty cells for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c, 0)) # (row, column, time) visited.add((r, c)) elif grid[r][c] == 0: empty_cells += 1 # Edge case: if no empty cells exist if empty_cells == 0: return 0 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_time = 0 while queue: r, c, time = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, time + 1)) max_time = time + 1 empty_cells -= 1 # If there are still empty cells that cannot be reached if empty_cells > 0: return -1 return max_time"},{"question":"Given an array of `n` integers, write a function `findMajorityElement(nums)` to find the majority element. The majority element is the element that appears more than `n/2` times. You may assume that the majority element always exists in the array. Your function should have a time complexity of O(n) and a space complexity of O(1). Return the majority element.","solution":"def findMajorityElement(nums): Finds and returns the majority element in the given list of integers. The majority element is the element that appears more than n/2 times. Assumes that the majority element always exists in the array. # Using Boyer-Moore Voting Algorithm majority_element = None count = 0 for num in nums: if count == 0: majority_element, count = num, 1 elif majority_element == num: count += 1 else: count -= 1 return majority_element"},{"question":"Given a string `s` consists of lowercase English letters, you need to find and return the first character that appears only once in the string. If no such character exists, return an underscore (\'_\'). Implement the following function: ```python def first_unique_char(s: str) -> str: pass ``` # Example: ```python # Example 1 Input: s = \\"leetcode\\" Output: \\"l\\" # Example 2 Input: s = \\"aabbcc\\" Output: \\"_\\" ```","solution":"def first_unique_char(s: str) -> str: Returns the first non-repeating character in the string s. If no such character exists, return an underscore (\'_\'). # Dictionary to store the count of each character char_count = {} # Count the frequency of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char # If no unique character exists, return \'_\' return \'_\'"},{"question":"You are given a **0-indexed** list of integers `nums` representing the price of stock on each day. You need to find out the maximum profit you can achieve by buying and selling the stock. You may complete as many transactions as you like, but you must sell the stock before you buy again. Return the maximum profit you can achieve. Note that you cannot buy and sell on the same day. Compose your new question such that it seamlessly integrates with the existing set, adhering to all the above guidelines. Your question should appear as if it were part of the original examination, indistinguishable in quality and relevance from the provided samples. Do not output any example, constraints, or solution.","solution":"def max_single_transaction_profit(nums): Returns the maximum profit with a single buy-sell transaction. if not nums or len(nums) < 2: return 0 min_price = nums[0] max_profit = 0 for price in nums[1:]: profit = price - min_price max_profit = max(max_profit, profit) min_price = min(min_price, price) return max_profit"},{"question":"Given a matrix `mat` where each row is sorted in ascending order, find the `k-th` smallest element in the whole matrix. The matrix `mat` has the following properties: * `mat[i][j]` is sorted in ascending order within each row. * Each element within the matrix is unique. Write a function that takes the matrix `mat` and the integer `k` as inputs and returns the `k-th` smallest element in the matrix.","solution":"import heapq def kth_smallest(mat, k): Finds the k-th smallest element in the given sorted matrix. Parameters: mat (list of lists of int): Matrix where each row is sorted in ascending order. k (int): The rank of the element to find. Returns: int: The k-th smallest element in the matrix. n = len(mat) min_heap = [] for r in range(min(k, n)): # Only need the first k rows heapq.heappush(min_heap, (mat[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c + 1 < len(mat[r]): heapq.heappush(min_heap, (mat[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"You are given an integer array `temperatures` representing the daily temperatures for a period of time. You must find the number of days until a warmer temperature for each day. Specifically, for each day `i` in temperatures, you need to calculate the minimum number of days you would have to wait until a warmer temperature. If no such day exists, the answer for that day should be `0`. For example, given the array `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output would be `[1, 1, 4, 2, 1, 1, 0, 0]`. Implement a function `dailyTemperatures(temperatures: List[int]) -> List[int]` that returns the list of numbers of days until a warmer temperature for each day.","solution":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: For each day in temperatures, calculate the number of days until a warmer temperature. If no such day exists, the answer for that day is 0. answer = [0] * len(temperatures) stack = [] # This will store the indices of the temperatures array for i, current_temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < current_temp: previous_day = stack.pop() answer[previous_day] = i - previous_day stack.append(i) return answer"},{"question":"You are given an integer array `height` representing the height of each building in a city. The buildings are arranged in a line, and you are standing on the ground at the start of this line. You can only jump from one building to the next if the next building is shorter than or of the same height as the current building. Write a function that returns the maximum number of consecutive buildings you can jump to starting from the first building.","solution":"def max_consecutive_jumps(height): Returns the maximum number of consecutive buildings you can jump to starting from the first building where each building in the sequence is shorter than or equal to the previous one. if not height: return 0 max_jumps = 0 current_jumps = 0 for i in range(1, len(height)): if height[i] <= height[i-1]: current_jumps += 1 max_jumps = max(max_jumps, current_jumps) else: current_jumps = 0 # Add 1 to max_jumps to account for the first building itself return max_jumps + 1"},{"question":"You are given a string `s` which consists only of lowercase English letters. You can perform the following operation on any substring of `s`: choose any character in the substring and delete it. Your goal is to make all characters in the string unique using the minimum number of operations. Return the minimum number of operations required to achieve this goal. For example, given the input string \\"aab\\", the minimum number of operations required is 1 (delete one \'a\').","solution":"def min_operations_to_unique_chars(s): Returns the minimum number of operations required to make all characters in the string s unique. from collections import Counter char_count = Counter(s) operations = 0 for count in char_count.values(): if count > 1: operations += count - 1 return operations"},{"question":"Given a list of non-negative integers representing the amount of time it takes to complete each task, and a positive integer `n` which represents the cooldown period between the same tasks, design an algorithm to find the minimum time required to complete all tasks. You can execute the tasks in any order, but once a task is executed, it must wait for the duration of the cooldown period `n` before it can be executed again.","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum time required to complete all tasks with a cooldown period. Parameters: tasks (list): A list of non-negative integers representing task completion times. n (int): The cooldown period required between the same tasks. Returns: int: The minimum time required to complete all tasks. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for task in task_counts if task_counts[task] == max_count) intervals_needed = (max_count - 1) * (n + 1) + max_count_tasks return max(intervals_needed, len(tasks))"},{"question":"Implement a `WordDictionary` class that supports adding new words and searching for words. The `search` method supports searching with a dot `.` character, which can represent any letter. Your implementation should be efficient and handle large numbers of words and searches. * `WordDictionary()` Initializes the data structure. * `void addWord(String word)` Adds a word to the data structure. * `boolean search(String word)` Returns `true` if the word is in the data structure (accounting for the dot characters that represent any letter), and `false` otherwise. **Example:** ``` WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\\"bad\\"); wordDictionary.addWord(\\"dad\\"); wordDictionary.addWord(\\"mad\\"); wordDictionary.search(\\"pad\\"); // return False wordDictionary.search(\\"bad\\"); // return True wordDictionary.search(\\".ad\\"); // return True wordDictionary.search(\\"b..\\"); // return True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, letter in enumerate(word): if letter == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if letter not in node.children: return False node = node.children[letter] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"Given an integer array `nums`, return _the **smallest index** of the first peak element_. A **peak element** is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index of the first peak. You may assume that `nums[-1]` and `nums[n]` are sentinels with values `-∞` (negative infinity) and `n` is the length of the array.","solution":"def find_first_peak(nums): Returns the smallest index of the first peak element in the list. n = len(nums) for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): return i return -1"},{"question":"Given a string `s` and a dictionary of words `dict`, return _the number of words in_ `dict` _that are subsequences of_ `s`. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. For example, \\"abc\\", \\"abg\\" and \\"bg\\" are subsequences of \\"abcdefg\\", but \\"bfc\\" is not.","solution":"def is_subsequence(s, word): Checks if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def count_subsequences(s, dict_words): Returns the number of words in dict_words that are subsequences of s. return sum(1 for word in dict_words if is_subsequence(s, word))"},{"question":"You are given a 2D grid of characters `board` and a string `word`. Write a function that returns `true` if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. The board contains only uppercase English letters. Implement the function `bool exist(vector<vector<char>>& board, string word)` that returns `true` if the word exists in the grid, otherwise returns `false`.","solution":"def exist(board, word): Returns True if the word exists in the grid following the specified rules, otherwise returns False. def dfs(board, word, i, j, index): if index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]: return False temp = board[i][j] board[i][j] = \'#\' # Mark this cell as used found = (dfs(board, word, i+1, j, index+1) or dfs(board, word, i-1, j, index+1) or dfs(board, word, i, j+1, index+1) or dfs(board, word, i, j-1, index+1)) board[i][j] = temp # Unmark this cell return found for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0] and dfs(board, word, i, j, 0): return True return False"},{"question":"You are given an array `events` where `events[i]` represents the start and end day of an event `i`. You can attend at most `k` events, but you cannot attend two events on the same day. Each event `i` in `events` is represented as a tuple `(start_i, end_i)` where `1 <= start_i <= end_i <= 10^9`. Return _the maximum number of events you can attend_, considering you can only attend at most `k` events and no two events can overlap on a given day.","solution":"def max_num_of_events(events, k): events.sort(key=lambda x: (x[1], x[0])) attended_days = set() total_events_attended = 0 for start, end in events: for day in range(start, end + 1): if day not in attended_days: attended_days.add(day) total_events_attended += 1 if total_events_attended == k: return total_events_attended break return total_events_attended"},{"question":"We have an array of integers `heights` where each element represents the height of a pillar. You need to find out the maximum volume of water that can be trapped between any two pillars. The water trapped between the two pillars `i` and `j` (where `i < j`) will be bounded by the height of the shorter pillar and the width between the pillars. Implement a function `maxWaterVolume` that takes in a single array `heights` and returns the maximum volume of water that can be trapped. Function Signature: ```python def maxWaterVolume(heights: List[int]) -> int: ```","solution":"from typing import List def maxWaterVolume(heights: List[int]) -> int: Returns the maximum volume of water that can be trapped between any two pillars. max_volume = 0 left, right = 0, len(heights) - 1 while left < right: # Calculate the possible volume between the two pointers width = right - left height = min(heights[left], heights[right]) volume = width * height # Update the maximum volume if the current one is greater max_volume = max(max_volume, volume) # Move the shorter height towards the center if heights[left] < heights[right]: left += 1 else: right -= 1 return max_volume"},{"question":"You are given a list of integers `nums` and an integer `k`. A continuous subarray of `nums` is called a **good subarray** if the sum of the elements in it is exactly `k`. Return the number of **good subarrays** in `nums`. **Example:** Input: `nums = [1, 1, 1]`, `k = 2` Output: `2` Explanation: There are two good subarrays: [1, 1] (from index 0 to 1) and [1, 1] (from index 1 to 2). Input: `nums = [1, 2, 3]`, `k = 3` Output: `2` Explanation: There are two good subarrays: [1, 2] (from index 0 to 1) and [3] (from index 2 to 2). Note: The elements in the array can be positive, negative, or zero.","solution":"def count_good_subarrays(nums, k): Returns the number of continuous subarrays whose sum equals k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"You are given a list of `n` strings, where each string represents a word. You need to group these words into sets where anagrams are in the same set. Each word consists of lowercase English letters. Return the list of groups, where each group is a list of anagrams. For example, given the list `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, the output should be `[[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]`. Design an efficient algorithm to solve the problem.","solution":"from collections import defaultdict def group_anagrams(words): Groups the words into sets where anagrams are in the same set. Parameters: words (list): List of strings where each string represents a word. Returns: list: A list of lists containing groups of anagrams. anagrams = defaultdict(list) for word in words: key = tuple(sorted(word)) anagrams[key].append(word) return list(anagrams.values())"},{"question":"You are given an array of integers `nums` representing the cost of items in a store. There is a special offer that states if you buy any two items, you get a discount equivalent to the price of the cheaper item. Return _the minimum total cost you have to pay_ after applying the discount on any two items. Note that the discount can only be applied once and if there are fewer than two items in the list, no discount can be applied.","solution":"def minimum_total_cost(nums): Returns the minimum total cost after applying the special discount. If there are fewer than two items, no discount can be applied. if len(nums) < 2: return sum(nums) nums.sort() # After sorting, the cheapest two items are nums[0] and nums[1] total_cost = sum(nums) - nums[0] return total_cost"},{"question":"You\'re given an array `arr` of positive integers, where each integer represents the height of a bar in a histogram. Each bar has a width of `1`. Write an algorithm to calculate the **largest rectangle** that can be formed within the bounds of this histogram. The rectangle must be formed by consecutive bars. Return the area of the **largest rectangle**. You must write an efficient algorithm to solve this problem.","solution":"def largest_rectangle_area(heights): Calculates the largest rectangle area in a histogram represented by heights. Args: heights (List[int]): A list of positive integers representing the heights of the histogram\'s bars. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 for i, h in enumerate(heights): start = i while stack and stack[-1][1] > h: index, height = stack.pop() max_area = max(max_area, height * (i - index)) start = index stack.append((start, h)) for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of `queries` where each query is a list of two integers `[left, right]`. For each query, you need to find the number of distinct letters in the substring of `s` that starts at the index `left` and ends at the index `right`. Return a list of integers where each integer is the result of the corresponding query. You must write an algorithm with less than `O(n * q)` runtime complexity, where `n` is the length of the string `s` and `q` is the number of queries.","solution":"def distinct_letters_substrings(s, queries): Returns the number of distinct letters in the substring of s specified by each query. Parameters: s (str): The input string queries (list): A list of [left, right] intervals Returns: list: A list of integers, each representing the count of distinct letters for the corresponding query # Length of the string n = len(s) # Precompute distinct counts using a prefix approach precomputed = [{} for _ in range(n)] # Initialize the first character\'s set precomputed[0][s[0]] = 1 # Fill out the rest of the precomputed array for i in range(1, n): # Clone the previous state (to accumulate counts) precomputed[i] = precomputed[i - 1].copy() if s[i] in precomputed[i]: precomputed[i][s[i]] += 1 else: precomputed[i][s[i]] = 1 results = [] for left, right in queries: if left == 0: # In case of entire segment from start to `right`, just count distinct characters distinct_count = len(precomputed[right]) else: # Subtract the previous state from the current to get the distinct count in the range current_count = precomputed[right] previous_count = precomputed[left - 1] # Distinct count only considering the latest part distinct_count = 0 for char in current_count: if current_count.get(char, 0) - previous_count.get(char, 0) > 0: distinct_count += 1 results.append(distinct_count) return results"},{"question":"You are given an array of integers `arr` representing the amount of time taken to complete each task. Each task can be assigned to exactly one worker. However, each worker can only work on one task at a time. You have a limited number of workers, `k`, and you need to minimize the maximum time taken by any one worker to complete their tasks. In other words, distribute the tasks among the workers such that the worker who takes the longest time finishes their tasks in the shortest time possible. Return _the minimum possible value of the maximum time taken by any one worker_.","solution":"def can_assign_tasks_within_max_time(arr, k, max_time): assigned_workers = 1 current_time = 0 for task in arr: if current_time + task <= max_time: current_time += task else: assigned_workers += 1 current_time = task if assigned_workers > k: return False return True def minimize_max_time(arr, k): left = max(arr) # The minimum possible max_time is the time taken by the largest task. right = sum(arr) # The maximum possible max_time is the total time of all tasks. while left < right: mid = (left + right) // 2 if can_assign_tasks_within_max_time(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Given a string `sequence` containing only lowercase English letters, determine the length of the longest strictly increasing subsequence (not necessarily contiguous) that can be obtained from this string. Return _the integer length of this longest increasing subsequence_. A strictly increasing subsequence is defined as a sequence of characters in which each subsequent character has a higher lexicographical order than the previous one.","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given string. if not sequence: return 0 # Create an array to store the longest increasing subsequence lengths lis = [1] * len(sequence) # Compute optimized lis values in a bottom up manner for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis which represents the length of the longest increasing subsequence return max(lis)"},{"question":"Consider a directed graph represented as an adjacency list `graph`, where `graph[i]` is a list of all the nodes `j` such that there is a directed edge from node `i` to node `j`. Each node is a letter from `\'a\'` to `\'z\'`. Given the graph, implement a function that returns the length of the longest path in the graph where each node has a different letter. The path cannot revisit any node. If there is no valid path, return 0.","solution":"def longest_unique_path(graph): def dfs(node, visited): if node in visited: return 0 visited.add(node) max_length = 0 for neighbor in graph.get(node, []): max_length = max(max_length, dfs(neighbor, visited)) visited.remove(node) return 1 + max_length max_path_length = 0 for node in graph: max_path_length = max(max_path_length, dfs(node, set())) return max_path_length"},{"question":"Given a string `s` consisting of lowercase English alphabet letters, return _the index of the first non-repeating character_ in `s`. If there is no non-repeating character, return `-1`. A non-repeating character is defined as a character that appears exactly once in the string. For example, given the string `\\"leetcode\\"`, the function should return `0` because the first non-repeating character is `\\"l\\"`. For the string `\\"aabb\\"`, the function should return `-1` because there are no non-repeating characters.","solution":"def first_non_repeating_character_index(s): Returns the index of the first non-repeating character in the string s. If there is no non-repeating character, returns -1. # Create a dictionary to store count of each character char_count = {} # Populate the dictionary with counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the index of the first character with a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"Given a binary tree, implement a function to check if the tree is balanced. A binary tree is considered balanced if for every node in the tree, the height of the left subtree and the right subtree differ by no more than 1. The height of a node is the number of edges on the longest path from the node to a leaf. Implement the function `boolean isBalanced(TreeNode root)`, where `TreeNode` is a class that encapsulates a node in the binary tree. Example: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` For example, given the following binary tree: ``` 1 / 2 3 / 4 5 ``` The function should return `true` as the binary tree is balanced.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Checks if a binary tree is balanced. A binary tree is balanced if for every node in the tree, the height of the left and right subtrees differ by no more than 1. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is balanced, False otherwise def height_and_balanced(node): if not node: return 0, True left_height, left_balanced = height_and_balanced(node.left) right_height, right_balanced = height_and_balanced(node.right) current_height = max(left_height, right_height) + 1 current_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return current_height, current_balanced _, is_bal = height_and_balanced(root) return is_bal"},{"question":"You are given an integer array `nums`. We define a running sum of an array as `runningSum[i]` = `sum(nums[0]…nums[i])`. Return _the running sum of `nums`_. This means you need to construct a new array where each element at position `i` is the sum of all elements from the start of the array up to position `i` in the original array. The test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer.","solution":"def running_sum(nums): Returns the running sum of the array nums. runningSum[i] = sum(nums[0]...nums[i]) if not nums: return [] running_sum_arr = [nums[0]] for i in range(1, len(nums)): running_sum_arr.append(running_sum_arr[-1] + nums[i]) return running_sum_arr"},{"question":"You are given two integer arrays `preorder` and `inorder` each representing the preorder and inorder traversal of a binary tree. Write a function to construct the binary tree from these traversals and return its root.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def buildTree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]: if not preorder or not inorder: return None # The first element of preorder list is the root node root_val = preorder[0] root = TreeNode(root_val) # Find the index of the root in inorder list root_index_inorder = inorder.index(root_val) # Everything to the left of root_index_inorder in inorder list is the left subtree left_inorder = inorder[:root_index_inorder] # Everything to the right of root_index_inorder in inorder list is the right subtree right_inorder = inorder[root_index_inorder+1:] # The nodes of the left subtree in preorder list left_preorder = preorder[1:1+len(left_inorder)] # The nodes of the right subtree in preorder list right_preorder = preorder[1+len(left_inorder):] # Recursively build the left and right subtrees root.left = buildTree(left_preorder, left_inorder) root.right = buildTree(right_preorder, right_inorder) return root"},{"question":"Given a string `s` containing only three types of characters: \'(\', \')\', and \'*\', write a function to check whether the string is valid. The string is valid if: 1. Any left parenthesis \'(\' must have a corresponding right parenthesis \')\'. 2. Any right parenthesis \')\' must have a corresponding left parenthesis \'(\'. 3. Left parenthesis \'(\' must go before the corresponding right parenthesis \')\'. 4. \'*\' could be treated as a single right parenthesis \')\' or a single left parenthesis \'(\' or an empty string. Write an algorithm that runs in `O(n)` time and use only constant extra space.","solution":"def checkValidString(s: str) -> bool: Returns True if the string is valid, False otherwise. lo = hi = 0 for ch in s: if ch == \'(\': lo += 1 hi += 1 elif ch == \')\': if lo > 0: lo -= 1 hi -= 1 else: # ch == \'*\' if lo > 0: lo -= 1 hi += 1 if hi < 0: return False return lo == 0"},{"question":"Given a string `s` consisting of lowercase English letters, you need to partition `s` into as few substrings as possible so that each substring is a palindrome. Return the minimum number of cuts needed for a palindrome partitioning of `s`. A substring is a contiguous sequence of characters within a string. A palindrome is a sequence of characters that reads the same forward and backward.","solution":"def min_cut_palindrome_partition(s): Returns the minimum number of cuts needed for a palindrome partitioning of s. n = len(s) if n == 0: return 0 # is_palindrome[i][j] will be True if the string s[i:j+1] is a palindrome is_palindrome = [[False] * n for _ in range(n)] for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: if j - i <= 1: is_palindrome[i][j] = True else: is_palindrome[i][j] = is_palindrome[i + 1][j - 1] cuts = [float(\'inf\')] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 else: for j in range(i): if is_palindrome[j + 1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"You are given a list of non-negative integers `nums` representing the number of stones in each pile, and an integer `k` which is the maximum number of piles you can merge into one pile at a time. Your task is to determine the minimum cost to merge all the piles into one pile. The cost of merging two or more piles is the sum of the number of stones in the piles being merged. Return _the minimum cost to merge all the piles into one pile under the given constraints_.","solution":"import heapq def min_cost_to_merge_piles(nums, k): Returns the minimum cost to merge all piles into one pile given the constraints. Args: nums: list of non-negative integers representing the number of stones in each pile k: maximum number of piles you can merge into one pile at a time Returns: int: minimum cost to merge all piles into one pile if len(nums) == 1: return 0 if k == 2: # We can use a min heap to always merge the smallest piles heapq.heapify(nums) total_cost = 0 while len(nums) > 1: cost = heapq.heappop(nums) + heapq.heappop(nums) total_cost += cost heapq.heappush(nums, cost) return total_cost else: # For k > 2, the problem turns into more complex # This simplified solution assumes k = 2 raise NotImplementedError(\\"This function only supports k=2 currently\\") print(min_cost_to_merge_piles([4, 3, 6, 2], 2)) # Expected output: 29"},{"question":"You are given a string `expression` that represents a valid mathematical expression containing only non-negative integers, the operators `+`, `-`, `*`, and `/`, and parentheses `()`. The integers and operators in the expression are separated by spaces. Your task is to evaluate the expression and return the result as an integer. **Note**: - The operators have the standard precedence: `*` and `/` have higher precedence than `+` and `-`, and parentheses can be used to override the precedence. - You should assume the expression is always valid. - The division operator `/` should perform integer division.","solution":"def evaluate(expression): Evaluates a mathematical expression and returns the result as an integer. def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a // b def evaluate_expression(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate_expression(expression)"},{"question":"You are given a string `s` that consists of only digits (0-9) and two integers, `k1` and `k2`. Your task is to determine the lexicographically smallest substring of length `k1` and the lexicographically largest substring of length `k2` from the given string `s`. Return a list containing these two substrings in the order: `[smallest_substring, largest_substring]`. If there are multiple such substrings, return any of them. Both `k1` and `k2` are guaranteed to be less than or equal to the length of the string `s`.","solution":"def find_substrings(s, k1, k2): Finds the lexicographically smallest substring of length k1 and the lexicographically largest substring of length k2 from the given string s. smallest_substring = min(s[i:i+k1] for i in range(len(s) - k1 + 1)) largest_substring = max(s[i:i+k2] for i in range(len(s) - k2 + 1)) return [smallest_substring, largest_substring]"},{"question":"Given a matrix `mat` of size `m x n` and two integers `row` and `col`, implement a function that returns the matrix where all the elements in the specified `row` and `col` are set to zero. If a cell is already zero, it should remain zero. Your function should perform this operation in-place without using additional matrix space. Example: - Input: `mat = [[1,2,3],[4,5,6],[7,8,9]], row = 1, col = 2` - Output: `[[1,2,0],[0,0,0],[7,8,0]]`","solution":"def set_zeroes(mat, row, col): Sets all elements in the specified row and col to zero. Parameters: mat (list of lists): The matrix of size m x n. row (int): The row index to set to zero. col (int): The column index to set to zero. Returns: list of lists: The modified matrix with specified row and column elements set to zero. m = len(mat) n = len(mat[0]) # Set all elements in the specified row to zero for j in range(n): mat[row][j] = 0 # Set all elements in the specified column to zero for i in range(m): mat[i][col] = 0 return mat"},{"question":"You are given a circular array `nums` of integers and an integer `target`. A circular array means the end of the array connects to the beginning to form a circle. You may start any position in `nums` and move to either direction (left or right). Find the minimum number of steps required to reach an element equal to `target`. If the `target` does not exist in the array, return `-1`. Studying this problem will require understanding array traversal and implementing circular movement logic effectively.","solution":"def min_steps_to_target(nums, target): Returns the minimum number of steps required to reach an element equal to target in the circular array nums. If the target does not exist in the array, returns -1. n = len(nums) if target not in nums: return -1 min_steps = float(\'inf\') for i in range(n): if nums[i] == target: min_steps = min(min_steps, i, n - i) return min_steps"},{"question":"Given a list of strings `words`, find the word that will appear in the middle if all the words are sorted alphabetically. If there are an even number of words, return the one that comes earlier in the sorted order. Each word in the list consists of only lowercase English letters. Return the word that meets the criteria.","solution":"def middle_word(words): Returns the middle word in an alphabetically sorted list of words. If there are an even number of words, returns the one that comes earlier. words.sort() mid_index = (len(words) - 1) // 2 return words[mid_index]"},{"question":"You are given a binary tree where each node has a value of `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is `0 -> 1 -> 1`, the binary number is `011`, which is `3` in decimal. Return the sum of these binary numbers represented by the root-to-leaf paths. Since the answer may be very large, return it **modulo** `109 + 7`. **Note**: A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): MOD = 10**9 + 7 def dfs(node, current): if not node: return 0 current = (current << 1) | node.val if not node.left and not node.right: # If it\'s a leaf return current return (dfs(node.left, current) + dfs(node.right, current)) % MOD return dfs(root, 0) % MOD"},{"question":"You are given a 2D integer matrix `mat` of size `m x n` and an integer `target`. Your task is to return the element from the matrix such that the absolute difference between this element and the `target` is minimized. If there are multiple such elements, return the smallest one. For example, if `mat = [[1, 3, 5], [6, 7, 9]]` and `target = 4`, the element `3` has the smallest absolute difference from `4`, which is `1`. In case there are multiple elements with the same absolute difference, return the smallest element among them.","solution":"def find_min_abs_difference(mat, target): Returns the element from the matrix such that the absolute difference between this element and the target is minimized. If there are multiple such elements, returns the smallest one. :param mat: List[List[int]] - 2D list of integers :param target: int - the target integer :returns: int - the element with the minimum absolute difference to target closest_element = None min_diff = float(\'inf\') for row in mat: for element in row: current_diff = abs(element - target) if current_diff < min_diff or (current_diff == min_diff and element < closest_element): min_diff = current_diff closest_element = element return closest_element"},{"question":"Given a string `s` consisting of lowercase letters, you need to split `s` into the maximum number of unique non-empty substrings. Your task is to determine and return the number of to substrings such that no two substrings are identical.","solution":"def max_unique_substrings(s): Returns the maximum number of unique non-empty substrings from the string s. unique_substrings = set() start = 0 for end in range(len(s)): while s[start:end + 1] in unique_substrings: start += 1 unique_substrings.add(s[start:end + 1]) return len(unique_substrings)"},{"question":"You are given a list of integers `temperatures` representing the daily temperatures for a week. You are also provided a target integer `T`. Your task is to return a list of integers such that each element in the list represents the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, store `0` for that day.","solution":"def daily_temperatures(temperatures): Returns a list of integers representing the number of days to wait for a warmer temperature. If no warmer temperature is in the future, the value is 0. Parameters: temperatures (list[int]): A list of daily temperatures. Returns: list[int]: A list of integers where each element represents the number of days to wait for a warmer temperature. result = [0] * len(temperatures) stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: j = stack.pop() result[j] = i - j stack.append(i) return result"},{"question":"You are given an array of integers `nums` consisting of `n` unique elements. Each element in the array represents a distinct index in the range `[0, n-1]`. Your task is to **efficiently** reorder the elements of the array such that each element `nums[i]` is replaced by its corresponding position in the sorted version of the array. Return the reordered array. For instance, if the input array `nums` is `[4, 2, 0, 1, 3]`, its corresponding sorted version is `[0, 1, 2, 3, 4]`, and the reordered array should be `[4, 2, 0, 1, 3]` because the element `4` is at index `4`, element `2` is at index `2`, element `0` is at index `0`, element `1` is at index `1`, and element `3` is at index `3`.","solution":"def reorder_by_sorted_positions(nums): Reorders the elements of the array such that each element nums[i] is replaced by its corresponding position in the sorted version of the array. Args: nums (List[int]): Array of n unique integers where each element represents a distinct index in the range [0, n-1]. Returns: List[int]: The reordered array where each element is replaced by its position in the sorted version of the array. # Create a dictionary mapping each value to its index in the sorted array sorted_indices = {value: idx for idx, value in enumerate(sorted(nums))} # Replace each element with its sorted position return [sorted_indices[num] for num in nums]"},{"question":"You are given two dates as strings in the format \\"YYYY-MM-DD\\". Your task is to compute the number of days between the two dates. Return the absolute difference in days between the two dates. Assume the dates are valid and the first date is not necessarily earlier than the second date. The date range to consider is from January 1, 1900 to December 31, 2100.","solution":"from datetime import datetime def days_between_dates(date1, date2): Returns the absolute number of days between two dates. Parameters: date1 (str): The first date in the format \\"YYYY-MM-DD\\" date2 (str): The second date in the format \\"YYYY-MM-DD\\" Returns: int: The absolute difference in days between the two dates. format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, format) d2 = datetime.strptime(date2, format) return abs((d1 - d2).days)"},{"question":"You are given an array of integers representing the heights of a group of people standing in a queue. Each position in the array contains the height of the person at that position in the queue. Due to a sudden event, some people are forced to move to the front of the queue, but their relative heights must remain unchanged. You need to find the longest subsequence of people (not necessarily contiguous) such that every person\'s height in that subsequence is greater than or equal to the height of the person standing directly in front of them in the original queue. Return _the length of the longest possible subsequence of people_ following the described condition.","solution":"def longest_non_decreasing_subsequence(heights): Finds the length of the longest non-decreasing subsequence in heights. if not heights: return 0 n = len(heights) # Initialize the DP array dp = [1] * n # Compute the longest non-decreasing subsequence for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence return max(dp)"},{"question":"Given a list of `n` processes, where each process is represented by a tuple `(id, arrivalTime, burstTime)`, implement a scheduling algorithm such that the following tasks are performed: - The processes are scheduled using the Shortest Job First (SJF) scheduling algorithm. The SJF algorithm schedules the process with the shortest burst time next. - If two processes have the same burst time, the process with the earlier arrival time is scheduled first. - If two processes have the same burst time and arrival time, the process with the smaller `id` is scheduled first. Implement the function `scheduleProcesses(processes)` that returns a list of process `ids` in the order they are scheduled to run.","solution":"def scheduleProcesses(processes): Schedules processes using the Shortest Job First (SJF) scheduling algorithm. Args: processes (list of tuples): A list of tuples where each tuple represents a process with (id, arrivalTime, burstTime). Returns: list: A list of process ids in the order they are scheduled to run. # Sort processes based on the given rules # 1. by burstTime # 2. by arrivalTime if burstTime is the same # 3. by id if both burstTime and arrivalTime are the same sorted_processes = sorted(processes, key=lambda x: (x[2], x[1], x[0])) # Extract the ids in the order of their scheduling scheduled_order = [process[0] for process in sorted_processes] return scheduled_order"},{"question":"You are given an integer array `cards` where `cards[i]` represents the points you can earn from the `i-th` card. These points can be both positive and negative. You can pick cards from either the beginning or the end of the array, removing the card and earning the specific points until the array is empty. However, there is a constraint on the number of cards you can pick consecutively. Specifically, you are given an integer `k` that represents the maximum number of consecutive cards you are allowed to pick in one move. After each pick (even if it’s less than `k` cards), you must stop and make a new pick. Return _the maximum points you can earn by optimally picking and removing cards from the array._","solution":"def max_score(cards, k): Returns the maximum points you can earn by optimally picking and removing cards. You are allowed to pick at most k cards consecutively from either end. n = len(cards) if k >= n: return sum(cards) # Total points from picking the first k cards from front or back. max_points = sum(cards[:k]) current_points = max_points # Sliding window to calculate max points when considering picking cards from the end for i in range(1, k + 1): current_points += cards[-i] - cards[k - i] max_points = max(max_points, current_points) return max_points"},{"question":"You are given two integer arrays `arr1` and `arr2` both of length `n`. Each element in the arrays represents a node in a graph. An edge exists between nodes `i` and `arr1[i]` as well as nodes `i` and `arr2[i]`. Your task is to determine if the entire graph is connected. A graph is connected if there is a path between any two nodes. Return `true` if the graph is connected, otherwise return `false`.","solution":"def is_graph_connected(n, arr1, arr2): Determines if the graph formed by the connections is connected. from collections import defaultdict, deque # Create adjacency list from the two arrays graph = defaultdict(list) for i in range(n): graph[i].append(arr1[i]) graph[i].append(arr2[i]) graph[arr1[i]].append(i) graph[arr2[i]].append(i) # Perform BFS from the first node (node 0) visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) # Check if all nodes have been visited return len(visited) == n"},{"question":"Given a 2D grid of integers where each integer represents the height of a building, find the maximum area of a rectangle formed by four different buildings such that: * The four buildings form the corners of a rectangle with sides parallel to the x and y axes. * Each building must be at a different corner of the rectangle. Return the _maximum area of such a rectangle_, or `0` if no such rectangle can be formed.","solution":"def maxRectangleArea(grid): Finds the maximum area of a rectangle formed by four different buildings (with heights as integers) such that all sides of the rectangle are parallel to the x and y axes. Parameters: grid (List[List[int]]): A 2D grid representing the heights of buildings. Returns: int: The maximum area of the rectangle, or 0 if no such rectangle can be formed. max_area = 0 rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 # Dictionary to store pairs of buildings\' heights that have been checked already pair_map = {} for r1 in range(rows): for r2 in range(r1 + 1, rows): for c1 in range(cols): for c2 in range(c1 + 1, cols): if grid[r1][c1] == grid[r2][c1] and grid[r1][c2] == grid[r2][c2]: area = (r2 - r1) * (c2 - c1) max_area = max(max_area, area) return max_area"},{"question":"You are given a 2D grid consisting of black cells (\'#\') and white cells (\'.\'), where the character grid[i][j] represents the cell in row i and column j. A cluster is a group of connected black cells, where two cells are connected if they share a side (horizontal or vertical). Write a function to return the number of distinct clusters in the grid.","solution":"def num_clusters(grid): Returns the count of distinct clusters of black cells (\'#\') in the 2D grid. # Dimensions of the grid rows = len(grid) cols = len(grid[0]) def dfs(r, c): Helper function to perform Depth First Search to mark all \'#\' in the same cluster. if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != \'#\': return # Mark the cell as visited grid[r][c] = \'.\' # Visit all four adjacent cells dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) cluster_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'#\': # If a cluster is found, increment the cluster count cluster_count += 1 # Use DFS to mark all connected cells in this cluster dfs(r, c) return cluster_count"},{"question":"Given a list of integers `arr`, you need to perform certain operations to transform the list. Each operation consists of removing the largest element and appending it to a new list. However, if there are multiple elements with the same maximum value, remove only one occurrence of it. Continue this process until `arr` is empty. Finally, return the new list containing elements in the order they were removed. Note: Assume there is at least one number in the list.","solution":"def transform_list(arr): Transforms the list by repeatedly removing the largest element and appending it to a new list. Parameters: arr (list): List of integers to be transformed. Returns: list: New list containing elements in the order they were removed. result = [] while arr: max_value = max(arr) arr.remove(max_value) result.append(max_value) return result"},{"question":"You are given a binary search tree (BST) and a target integer value. Write a function that returns the value in the BST that is closest to the target. If there are two values in the BST that are equally close to the target, return the smaller value. A binary search tree is defined as follows: * The left subtree of a node contains only nodes with keys less than the node\'s key. * The right subtree of a node contains only nodes with keys greater than the node\'s key. * Both the left and right subtrees must also be binary search trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root, target): Returns the value in the BST that is closest to the target. If there are two values equally close, return the smaller value. closest = root.val current = root while current: if abs(current.val - target) < abs(closest - target): closest = current.val elif abs(current.val - target) == abs(closest - target) and current.val < closest: closest = current.val if target < current.val: current = current.left else: current = current.right return closest"},{"question":": You are given a string `expression` that represents a mathematical expression containing non-negative integers, operators +, -, *, and /. The expression also contains parentheses to indicate the order of operations. You need to evaluate the expression and return its result. The operator precedence is as follows: 1. Parentheses 2. Multiplication (*) and division (/) 3. Addition (+) and subtraction (-) You can assume that the given expression is always valid and does not contain any redundant parentheses. For example, given `expression = \\"3 + 2 * 2\\"`, the output should be `7`. Given `expression = “(1+(4+5+2)-3)+(6+8)”`, the output should be `23`. Write a function to evaluate the given mathematical expression and return the result.","solution":"def evaluate_expression(expression): def calc(op, second, first): if op == \'+\': return first + second if op == \'-\': return first - second if op == \'*\': return first * second if op == \'/\': return int(first / second) # Truncate towards 0 def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(calc(operator, right, left)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operation(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, values) return values[0]"},{"question":"Given an array of integers, find the maximum product of any three numbers in the array. Return the maximum product.","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three numbers in the list. # Sorting the array nums.sort() # Maximum product is either the product of the three largest numbers # or the product of the two smallest numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given a matrix `grid` of size `m x n` consisting of `\'0\'`s (land) and `\'1\'`s (water). An island is a maximal 4-directionally connected group of `\'0\'`s and a lake is a maximal 4-directionally connected group of `\'1\'`s. You can change an arbitrary number of `\'0\'`s into `\'1\'`s to form lakes. Return the maximum number of islands that can be converted into lakes by changing the minimum number of `\'0\'`s to `\'1\'`s. If no islands exist, return `0`.","solution":"def max_islands_to_lakes(grid): if not grid or not grid[0]: return 0 def dfs(row, col): if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != \'0\': return grid[row][col] = \'*\' dfs(row - 1, col) dfs(row + 1, col) dfs(row, col - 1) dfs(row, col + 1) count_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'0\': count_islands += 1 dfs(i, j) return count_islands"},{"question":"You are given a matrix `grid` with `n` rows and `m` columns, where each cell in the matrix contains an integer representing the height of that cell in a 3D landscape. You need to find the **water trapped** after it rains heavily. Water can only be trapped in a cell if it is surrounded by cells with heights greater than or equal to the height of the cell itself. The water trapped in each cell is the difference between the height of the surrounding cells and the height of the current cell. Return _the total amount of water trapped_ in the matrix.","solution":"import heapq def trapRainWater(heightMap): Calculate the amount of water trapped in a 3D landscape represented by a height map. Args: heightMap (List[List[int]]): 2D list representing the height of each cell in the grid. Returns: int: Total amount of water trapped. if not heightMap or not heightMap[0]: return 0 n, m = len(heightMap), len(heightMap[0]) visited = [[False] * m for _ in range(n)] heap = [] # Push all the cells on the border into the heap for i in range(n): for j in range(m): if i == 0 or i == n - 1 or j == 0 or j == m - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True # directions for moving in the 4 possible ways directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can delete any number of characters from the string. Return _the **length** of the longest subsequence of `s` that is a valid alphabetical sequence \'abc\'._ A subsequence is a sequence derived by deleting zero or more characters from the string without changing the order of the remaining characters.","solution":"def longest_abc_subsequence(s): Returns the length of the longest subsequence of \'s\' that is a valid alphabetical sequence \'abc\'. # Initialize counts for \'a\', \'b\', and \'c\' in the subsequence count_a = count_b = count_c = 0 for char in s: if char == \'a\': count_a += 1 elif char == \'b\': # \'b\' can only be part of the sequence if there are \'a\'s before it if count_a > count_b: count_b += 1 elif char == \'c\': # \'c\' can only be part of the sequence if there are \'b\'s before it if count_b > count_c: count_c += 1 # The longest valid subsequence ends with \'c\' and is limited by the count of \'c\' return count_c * 3"},{"question":"Given a 2D list of integers `grid` representing a rectangular grid where each cell contains an integer. You are initially located at the top-left corner of the grid (i.e., `grid[0][0]`) and your goal is to reach the bottom-right corner of the grid (i.e., `grid[m-1][n-1]`). You can only move either right or down at any point in time. Return the minimum path sum to reach from the top-left corner to the bottom-right corner by moving only right or down.","solution":"def min_path_sum(grid): Calculates the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid, where you can only move right or down at each step. Args: grid (list of list of int): The 2D grid of integers. Returns: int: The minimum path sum. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]"},{"question":"You are given a list of `n` words, `words`, where each word consists of lowercase English letters. Two words are considered connected if they differ by exactly one character. For example, \\"bat\\" and \\"cat\\" are connected, while \\"bat\\" and \\"cats\\" are not. Determine the _largest set of connected words_ in `words`. Return the size of this set.","solution":"def differ_by_one_char(word1, word2): Returns True if word1 and word2 differ by exactly one character, otherwise False. if len(word1) != len(word2): return False differences = sum(1 for a, b in zip(word1, word2) if a != b) return differences == 1 def build_graph(words): Builds an adjacency list for the words where an edge exists if the words differ by exactly one character. graph = {word: [] for word in words} for i in range(len(words)): for j in range(i + 1, len(words)): if differ_by_one_char(words[i], words[j]): graph[words[i]].append(words[j]) graph[words[j]].append(words[i]) return graph def dfs(word, graph, visited): Performs depth-first search to compute the size of the connected component. stack = [word] size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True size += 1 for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return size def largest_connected_set(words): Determines the size of the largest connected set of words. if not words: return 0 graph = build_graph(words) visited = {word: False for word in words} max_size = 0 for word in words: if not visited[word]: component_size = dfs(word, graph, visited) max_size = max(max_size, component_size) return max_size"},{"question":"You are given a string `s` that consists of lowercase English letters and a pattern `p` that also consists of lowercase English letters. You need to determine the smallest window in `s` that contains all the characters of `p` (including duplicates). If no such window exists, return an empty string. A window is defined as a contiguous sequence of characters within the string. For example, in the string `\\"abcde\\"`, the window between indices 1 and 3 is `\\"bcd\\"`. Return _the smallest window in `s` that contains all characters of `p`._ If there is a tie, return the window that occurs first in `s`. If no such window exists, return an empty string.","solution":"def minWindow(s, p): from collections import Counter if not s or not p: return \\"\\" # Dictionary which keeps a count of all the unique characters in p. p_count = Counter(p) # Number of unique characters in p that need to be present in the desired window. required = len(p_count) # Left and Right pointers in the sliding window. left, right = 0, 0 # Number of unique characters in the current window that matches the desired count in p_count. formed = 0 # Dictionary which keeps a count of all the unique characters in the current window. window_counts = {} # Result tuple (window length, left, right) ans = float(\\"inf\\"), None, None while right < len(s): # Add one character from the right to the window character = s[right] window_counts[character] = window_counts.get(character, 0) + 1 # If the frequency of the current character added equals to the desired count in p_count then increment the formed count if character in p_count and window_counts[character] == p_count[character]: formed += 1 # Try and contract the window till the point where it ceases to be \'desirable\'. while left <= right and formed == required: character = s[left] # Save the smallest window until now. if right - left + 1 < ans[0]: ans = (right - left + 1, left, right) # The character at the position pointed by the `left` pointer is no longer a part of the window. window_counts[character] -= 1 if character in p_count and window_counts[character] < p_count[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. left += 1 # Keep expanding the window once we are done contracting. right += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"Define a class `PalindromeChecker` that provides methods to check for a palindromic substring of a given length within a provided string `s`. The class should include the following functionalities: - `PalindromeChecker(string s)` - Initializes the object with a string `s`. - `hasPalindromeOfLength(int length)` - Returns `true` if there is at least one substring of the provided `length` that is a palindrome, and `false` otherwise. - `getPalindromesOfLength(int length)` - Returns a list of all unique palindromic substrings of the specified `length` found within `s`. For example: - Given `s = \\"ababa\\"`, `hasPalindromeOfLength(3)` would return `true`, and `getPalindromesOfLength(3)` would return `[\\"aba\\", \\"bab\\"]`. - Given `s = \\"abc\\"`, `hasPalindromeOfLength(2)` would return `false`, and `getPalindromesOfLength(2)` would return `[]`.","solution":"class PalindromeChecker: def __init__(self, s: str): self.s = s def hasPalindromeOfLength(self, length: int) -> bool: if length > len(self.s): return False for i in range(len(self.s) - length + 1): sub_str = self.s[i:i + length] if sub_str == sub_str[::-1]: return True return False def getPalindromesOfLength(self, length: int) -> list: palindromes = set() if length > len(self.s): return [] for i in range(len(self.s) - length + 1): sub_str = self.s[i:i + length] if sub_str == sub_str[::-1]: palindromes.add(sub_str) return list(palindromes)"},{"question":"You are creating an application where you need to keep track of user sessions. Each session has a start and an end time, which are integers representing the number of seconds since the start of the day. You need to implement a system that can efficiently record new sessions and query the total number of active sessions at any given point. Design a class `SessionTracker` with the following methods: * `SessionTracker()` Initializes the tracker object. * `void addSession(int start, int end)` Adds a new session with a given start and end time. * `int getActiveSessions(int timestamp)` Returns the number of active sessions at the given `timestamp`. An active session at `timestamp` is defined as a session where `start <= timestamp < end`.","solution":"class SessionTracker: def __init__(self): self.sessions = [] def addSession(self, start, end): Adds a new session with a given start and end time. self.sessions.append((start, end)) def getActiveSessions(self, timestamp): Returns the number of active sessions at the given timestamp. count = 0 for start, end in self.sessions: if start <= timestamp < end: count += 1 return count"},{"question":"You are given an m x n grid `rooms` initialized with these three possible values: - `-1` representing a wall or an obstacle. - `0` representing a gate. - `INF` representing an empty room. (INF is 2^31 - 1, which you can assume is an infinite distance.) Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain as INF. You can use the breadth-first search (BFS) algorithm to solve this problem. The distance is calculated as the number of steps from the gate to the empty room. Write a function `wallsAndGates(rooms: List[List[int]]) -> None` to update the grid in place.","solution":"from collections import deque from typing import List def wallsAndGates(rooms: List[List[int]]) -> None: if not rooms: return INF = 2**31 - 1 m, n = len(rooms), len(rooms[0]) queue = deque() for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, d = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = d + 1 queue.append((nx, ny, d + 1))"},{"question":"A company is organizing a coding contest in which `n` participants will compete. Each participant receives a unique participant ID from `1` to `n`. You are given an integer array `scores` of length `n` where `scores[i]` indicates the score of the participant with ID `i+1`. The company wants to reward the highest scorers but there is a limit `k` on the number of distinct scores that can be rewarded. Return the array of participant IDs who will receive rewards. If multiple participants have scores that allow them to be rewarded and their scores are tied, include their participant IDs in the order in which they appear in the input array.","solution":"def reward_participants(scores, k): Selects participants to reward based on their scores. Only the top k distinct scores are rewarded. Args: scores (list of int): List of scores for each participant. k (int): Number of distinct top scores to be rewarded. Returns: list: List of participant IDs who will receive rewards. # Get the unique scores and sort them in descending order unique_scores = sorted(set(scores), reverse=True) # Limit the number of scores to top k distinct scores top_scores = unique_scores[:k] # Collect participant IDs who have one of the top k distinct scores rewarded_ids = [] for i, score in enumerate(scores): if score in top_scores: rewarded_ids.append(i + 1) return rewarded_ids"},{"question":"You have a list of integers `nums` and an integer `target`. Your task is to determine if there exists a **subarray** of `nums` whose sum equals `target`. A **subarray** is a contiguous part of the array. Return _true_ if such a subarray exists, otherwise return _false_. For example, given `nums = [1, 2, 3, 7, 5]` and `target = 12`, this would return `true`, because the subarray `[2, 3, 7]` sums up to `12`.","solution":"def has_subarray_with_sum(nums, target): Determines if there exists a subarray of nums whose sum equals target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: bool: True if such a subarray exists, otherwise False. current_sum = 0 sum_dict = {0: -1} # Dictionary to store the sum up to all indices for i, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_dict: return True sum_dict[current_sum] = i return False"},{"question":"Given a list of integers `numbers`, return a new list containing the squares of each number in `numbers`, sorted in non-decreasing order. For example, given `numbers` = `[-4, -1, 0, 3, 10]`, the output should be `[0, 1, 9, 16, 100]`.","solution":"def sorted_squares(numbers): Returns a list of the squares of each number in `numbers`, sorted in non-decreasing order. Args: numbers (list of int): List of integers to be squared and sorted. Returns: list of int: A new list containing the squares of each number in `numbers`, sorted in non-decreasing order. # Calculate the square of each number squared = [num ** 2 for num in numbers] # Sort the squared numbers in non-decreasing order sorted_squared = sorted(squared) return sorted_squared"},{"question":"A company organizes a competition in which participants are awarded points for solving problems. The competition has `n` participants, and each participant is identified by a unique ID from `1` to `n`. The competition consists of several rounds, and each round participants can earn different scores. Given an array of `scores` where `scores[i]` is an array of `[id, points]`, representing the id of the participant and the points he/she earned in that round, calculate the total points for each participant. You need to return an array of integers, where the `i-th` element represents the total points accumulated by the participant with ID `i`. # Example: Input: `n = 4`, `scores = [[1, 10], [2, 5], [3, 7], [1, 3], [2, 5], [4, 8]]` Output: `[13, 10, 7, 8]` Explanation: - Participant 1 has scores 10 and 3, total = 13 - Participant 2 has scores 5 and 5, total = 10 - Participant 3 has scores 7, total = 7 - Participant 4 has scores 8, total = 8","solution":"def calculate_total_scores(n, scores): Calculate the total scores for each participant. Parameters: n (int): Number of participants. scores (list): List of lists where each inner list has two elements [id, points]. Returns: list: List of total scores for each participant with ID from 1 to n. total_scores = [0] * n for score in scores: id, points = score total_scores[id - 1] += points return total_scores"},{"question":"Given an array of integers `arr`, return _an array of the same length where each element `i` is the **product** of all elements in `arr` except `arr[i]`, without using division._ Implement this with a time complexity of O(n). For example, given `[1, 2, 3, 4]`, the returned array should be `[24, 12, 8, 6]`, as: - For 1: 24 (2 * 3 * 4) - For 2: 12 (1 * 3 * 4) - For 3: 8 (1 * 2 * 4) - For 4: 6 (1 * 2 * 3)","solution":"def product_except_self(arr): Returns an array where each element at index i is the product of all elements in arr except arr[i]. length = len(arr) result = [1] * length # Result array initialized to 1s # Calculate left products for each element left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate right products for each element right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"Given a directed graph with `n` nodes labeled from `0` to `n-1`, and an array of `edges` where `edges[i]` = [from[i], to[i]] represents a directed edge from node `from[i]` to node `to[i]`, find and return all the nodes that are eventually safe. A node is \\"safe\\" if every possible path starting from that node leads to a terminal node which is a node with no out-going edges. A node `u` is safe if every path starting from `u` does not reach any cycle in the graph. Return all the safe nodes in ascending order.","solution":"def eventualSafeNodes(n, edges): Finds all eventual safe nodes in a directed graph. :param n: Total number of nodes in the graph :param edges: List of directed edges of the graph :return: List of all eventual safe nodes in ascending order from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) # Create the graph and its reverse for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) out_degree = [0] * n for u in range(n): out_degree[u] = len(graph[u]) # Queue to process nodes whose out degree is 0 queue = deque([i for i in range(n) if out_degree[i] == 0]) safe_nodes = [] while queue: node = queue.popleft() safe_nodes.append(node) for prev in reverse_graph[node]: out_degree[prev] -= 1 if out_degree[prev] == 0: queue.append(prev) # Return the safe nodes in ascending order return sorted(safe_nodes)"},{"question":"Given a list of `words` and a string `s`, determine if `s` can be constructed by concatenating words from the list. Each word from the list can be used any number of times. Return `true` if `s` can be constructed from the given words, and `false` otherwise.","solution":"def can_construct(words, s): Determine if s can be constructed by concatenating words from the list. Each word from the list can be used any number of times. :param words: List of words :param s: String to be constructed :return: True if s can be constructed, False otherwise def can_construct_memo(s, memo={}): if s == \\"\\": return True if s in memo: return memo[s] for word in words: if s.startswith(word): suffix = s[len(word):] if can_construct_memo(suffix, memo): memo[s] = True return True memo[s] = False return False return can_construct_memo(s)"},{"question":"Design and implement a class `TextEditor` that simulates a simple text editor with an undo and redo functionality. The editor operates on a single string of text and supports the following operations: - **insert**(String text): Inserts the given text at the end of the current text. - **delete**(int k): Deletes the last `k` characters from the current text. If `k` is greater than the length of the current text, delete all characters. - **undo**(): Reverts the last operation (`insert` or `delete`), allowing for undoing multiple steps consecutively. - **redo**(): Reapplies the last undone operation, if any, allowing for redoing multiple steps consecutively. Implement the `TextEditor` class with the following methods: - `TextEditor()`: Initializes the text editor with an empty string. - `void insert(String text)`: Appends the given text to the end of the current text. - `void delete(int k)`: Deletes the last `k` characters from the current text. - `void undo()`: Reverts the last operation (`insert` or `delete`), if possible. - `void redo()`: Reapplies the last undone operation, if possible. - `String currentText()`: Returns the current state of the text after all operations.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.undo_stack = [] def insert(self, text): self.history.append(self.text) self.text += text self.undo_stack = [] # Clear redo stack when new operation is performed def delete(self, k): self.history.append(self.text) if k >= len(self.text): self.text = \\"\\" else: self.text = self.text[:-k] self.undo_stack = [] # Clear redo stack when new operation is performed def undo(self): if self.history: last_state = self.history.pop() self.undo_stack.append(self.text) self.text = last_state def redo(self): if self.undo_stack: last_undone_state = self.undo_stack.pop() self.history.append(self.text) self.text = last_undone_state def currentText(self): return self.text"},{"question":"Given an array of integers `arr`, partition the array into two subsets such that the difference between their sums is minimized. Return the minimum difference. You may assume that each integer in the array is non-negative. This question requires you to find an optimal way to partition the array, leveraging dynamic programming techniques to explore all possible subset combinations efficiently.","solution":"def min_partition_difference(arr): Returns the minimum difference between the sums of two subsets partitioned from the given array `arr`. total_sum = sum(arr) n = len(arr) # Create a DP table where dp[i][j] will be True if there exists a subset of first `i` elements with sum `j` dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # There is always a subset with sum 0 for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the largest j such that dp[n][j] is True where j is at most total_sum // 2 for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset1_sum - subset2_sum)"},{"question":"You are given a list of integers `heights` representing the height of each mountain in a range. The mountains are arranged in ascending order of their positions. You need to find the number of **distinct water basins** that can be formed between the mountains. A water basin is defined as a set of contiguous mountains such that each mountain in the basin is followed by a higher mountain, and surrounded by higher mountains on both ends. Return _the number of distinct water basins_.","solution":"def count_water_basins(heights): Determines the number of distinct water basins. Args: heights (list): A list of integers representing the heights of mountains. Returns: int: The number of distinct water basins. if not heights or len(heights) < 3: return 0 basins_count = 0 i = 1 while i < len(heights) - 1: if heights[i - 1] > heights[i] < heights[i + 1]: basins_count += 1 # Move i to the next potential basin start while i < len(heights) - 1 and heights[i] <= heights[i + 1]: i += 1 i += 1 return basins_count"},{"question":"You are given an array of integers `arr` representing the heights of consecutive buildings. The heights are given from left to right, and every building is separated by a unit distance. You need to determine the maximum number of buildings that can be jumped over starting from any building. A jump from building `i` to building `j` is possible if `arr[j]` is greater than `arr[i]`. A building can be jumped over multiple times if it continues to meet the condition with subsequent buildings. Return an integer representing the maximum number of jumps possible.","solution":"def max_jumps(arr): Returns the maximum number of jumps possible starting from any building. n = len(arr) dp = [0] * n for i in range(n): for j in range(i + 1, n): if arr[j] > arr[i]: dp[j] = max(dp[j], dp[i] + 1) return max(dp)"},{"question":"You are given an array of integers `arr` and an integer `x`. Split the array into two non-empty contiguous subarrays such that the sum of one subarray is exactly `x` less than the sum of the other subarray, if possible. Return a list of two lists representing the two subarrays in any order. If there are multiple solutions, any valid pair can be returned. If no such way exists, return an empty list.","solution":"def split_array(arr, x): Splits the array into two non-empty contiguous subarrays such that the sum of one subarray is exactly x less than the sum of the other subarray. Parameters: arr (list): The list of integers to be split. x (int): The difference desired between the two subarrays\' sums. Returns: list: A list of two lists representing the two subarrays if possible, else an empty list. n = len(arr) if n < 2: return [] total_sum = sum(arr) # Trying to find the split point left_sum = 0 for i in range(n-1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum + x or right_sum == left_sum + x: return [arr[:i+1], arr[i+1:]] return []"},{"question":"Given a string `text` consisting of lowercase English letters and an integer `k`, you can choose any character from the string and move it to the end of the string. Return _the lexicographically smallest string_ you can get after performing **at most k** such moves. For example, if the input string is `\\"cba\\"` and `k = 1`, the output should be `\\"acb\\"` since you can move `\\"a\\"` to the end of the string to make it smallest in lexicographical order.","solution":"def lexicographically_smallest_string(text, k): Returns the lexicographically smallest string possible after performing at most k moves where any character can be moved to the end of the string. if k == 0: return text elif k == 1: smallest = text for i in range(len(text)): rotated = text[i:] + text[:i] if rotated < smallest: smallest = rotated return smallest else: return \'\'.join(sorted(text))"},{"question":"A forest is represented by a 2D grid `forest` where each cell is either \'0\' representing an empty space, \'1\' representing a tree, or \'2\' representing a fire. Each cell is connected to its four direct neighbors (vertically and horizontally). Each minute, any tree that is adjacent to a fire will catch fire. Return _the minimum number of minutes it will take for the entire forest to be burnt down._ If it is impossible for the entire forest to be burnt down, return -1.","solution":"from collections import deque def min_minutes_to_burn_forest(forest): rows, cols = len(forest), len(forest[0]) queue = deque() tree_count = 0 # Initialize queue with all fire positions and count trees for r in range(rows): for c in range(cols): if forest[r][c] == \'2\': queue.append((r, c, 0)) # (row, col, minutes) elif forest[r][c] == \'1\': tree_count += 1 def neighbors(r, c): for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)): if 0 <= nr < rows and 0 <= nc < cols: yield (nr, nc) minutes = 0 while queue: r, c, minutes = queue.popleft() for nr, nc in neighbors(r, c): if forest[nr][nc] == \'1\': # If it\'s a tree forest[nr][nc] = \'2\' tree_count -= 1 queue.append((nr, nc, minutes + 1)) return minutes if tree_count == 0 else -1"},{"question":"You are given two strings, `s1` and `s2`. The goal is to determine if you can transform `s1` into `s2` using the following operation any number of times: choose any character from `s1` and move it to the end of the string. Return _true_ if you can transform `s1` into `s2` this way, and _false_ otherwise.","solution":"def can_transform(s1, s2): Determine if string s1 can be transformed into string s2 by moving any character to the end of the string any number of times. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `m`. You need to partition the array into **exactly** `m` non-empty continuous subarrays. Each subarray has a sum. The largest sum among these subarrays is called the \\"subarray sum\\" of the partition. Return _the smallest possible value of the largest subarray sum_.","solution":"def splitArray(nums, m): def canSplit(mid): subarray_count = 1 curr_sum = 0 for num in nums: curr_sum += num if curr_sum > mid: subarray_count += 1 curr_sum = num if subarray_count > m: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a string `s` containing characters from the alphabet `a-z`, you are to perform the following operations: find out the leftmost non-repeating character in the string and return its index. If there is no non-repeating character, return `-1`. The input string can be assumed to contain only lowercase English letters. For example, given the string `\\"leetcode\\"`, the leftmost non-repeating character is `\'l\'` and the function should return its index `0`.","solution":"def leftmost_non_repeating_character(s): Finds the leftmost non-repeating character in the string and returns its index. If there is no non-repeating character, returns -1. character_count = {} # Count occurrences of each character for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 # Find the leftmost non-repeating character for index, char in enumerate(s): if character_count[char] == 1: return index return -1"},{"question":"You are given an array of `n` distinct integers and an integer `k`. Your task is to find the `k-th` largest element in the array. Implement a function that returns the `k-th` largest element. You are expected to solve this problem in `O(n)` time complexity on average.","solution":"import random def kth_largest(nums, k): Returns the k-th largest element in the list nums. def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def select(left, right, k_smallest): if left == right: return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(nums) - 1, len(nums) - k)"},{"question":"You are given a string `s` consisting only of characters `a`, `b`, and `c`. A valid string is defined as a string in which there are no consecutive characters that are the same. For instance, \\"abc\\", \\"acbac\\" are valid strings, but \\"aabbcc\\" and \\"abccba\\" are not. Your task is to remove the minimum number of characters from `s` to make it a valid string. Return _the minimum number of characters_ that need to be removed to achieve this.","solution":"def min_removals_to_make_valid(s): Returns the minimum number of characters that need to be removed to make the string s a valid string with no consecutive characters being the same. if not s: return 0 # Initialize count of removals removals = 0 # Iterate the string and check consecutive characters for i in range(1, len(s)): if s[i] == s[i-1]: removals += 1 return removals"},{"question":"Given an integer array `arr`, a target integer `target`, and an integer `k`, return _the **k closest integers** to `target` in array `arr`_. The result should be sorted in ascending order. The **distance** between two integers `a` and `b` is the absolute difference between `a` and `b`.","solution":"def k_closest_integers(arr, target, k): Returns k closest integers to target in array arr in ascending order. # Sort the array based on the distance to the target arr.sort(key=lambda x: (abs(x - target), x)) # Get the first k elements after sorting by distance and then by value result = arr[:k] # Return the result sorted in ascending order return sorted(result)"},{"question":"You are given a string `s` consisting of lowercase English letters and the character `\'?\'`. You can replace the `\'?\'` characters with any lowercase English letter such that no two adjacent characters are the same. Return the modified string after all replacements have been made. If it is not possible to achieve such a configuration, return an empty string \\"\\".","solution":"def modifyString(s): Modifies the input string by replacing all \'?\' with any lowercase letter such that no two adjacent characters are the same. s = list(s) for i in range(len(s)): if s[i] == \'?\': for ch in \'abc\': if (i == 0 or s[i - 1] != ch) and (i == len(s) - 1 or s[i + 1] != ch): s[i] = ch break return \'\'.join(s)"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You have to delete the minimum number of characters from `s` so that it becomes a valid string. A string is considered valid if it does not contain any of the substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". Return the minimum number of characters you need to delete to make the string valid.","solution":"def min_deletions_to_make_valid(s): This function returns the minimum number of deletions required to make the string \'s\' valid. A string is considered valid if it does not contain any of the substrings \\"aaa\\", \\"bbb\\", or \\"ccc\\". deletions = 0 i = 0 while i < len(s) - 2: if s[i] == s[i + 1] == s[i + 2]: deletions += 1 i += 2 # Skip the next character to avoid extra deletions else: i += 1 return deletions"},{"question":"You are given the root of a **binary tree** where each node contains an integer value. Your task is to find and return a list of **all path sums** from the root to the leaves. A **path sum** is defined as the sum of the node values along a path from the root node to any leaf node. A **leaf node** is a node with no children. Example: Given the following binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` The path sums would be: - Root 5 to leaf 7: 5 + 4 + 11 + 7 = 27 - Root 5 to leaf 2: 5 + 4 + 11 + 2 = 22 - Root 5 to leaf 13: 5 + 8 + 13 = 26 - Root 5 to leaf 1: 5 + 8 + 4 + 1 = 18 The function should return a list of these sums: `[27, 22, 26, 18]`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sums(root): def dfs(node, current_sum, sums): if node is None: return current_sum += node.val # if it\'s a leaf, append the sum to the list if node.left is None and node.right is None: sums.append(current_sum) return dfs(node.left, current_sum, sums) dfs(node.right, current_sum, sums) result = [] dfs(root, 0, result) return result"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. You need to find the starting and ending positions (inclusive) of the smallest subarray that, when sorted, results in the entire array being sorted in ascending order. If the array is already sorted, return a tuple (-1, -1). * For example, given `nums = [2, 6, 4, 8, 10, 9, 15]`, the smallest subarray that needs to be sorted is from index `1` to `5`, so the output should be `(1, 5)`. * If the array is `nums = [1, 2, 3, 4, 5]`, the array is already sorted, so the output should be `(-1, -1)`. Return _a tuple of integers_ representing the starting and ending positions of the smallest subarray that needs to be sorted.","solution":"def find_unsorted_subarray(nums): Returns the starting and ending positions of the smallest subarray that needs to be sorted so that the entire array becomes sorted, or (-1, -1) if the entire array is already sorted. n = len(nums) sorted_nums = sorted(nums) start = 0 while start < n and nums[start] == sorted_nums[start]: start += 1 if start == n: return (-1, -1) end = n - 1 while end > start and nums[end] == sorted_nums[end]: end -= 1 return (start, end)"},{"question":"Given a string `s`, find the length of the longest substring `t` that contains no more than `k` distinct characters. The string `s` consists of lowercase English letters only. You need to return the length of the longest substring that satisfies this condition. Masriulk Theuend_validation_FIELD_ENCODED Validity of the algorithm mustretched geometrically to account for potential non-ascii characters while maintaining linearithmic time complexity properties\'","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains no more than k distinct characters. if k == 0: return 0 left, right = 0, 0 max_length = 0 char_count = {} while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given a 2D grid of size `m x n` representing a maze, you need to find the minimum number of steps required for a player to move from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. The player can move up, down, left, or right, but cannot move through walls. The maze is represented by a matrix where `0` indicates an open path and `1` indicates a wall. If the path to the bottom-right corner does not exist, return `-1`. The player cannot move out of the maze boundaries. Return the minimum number of steps required to reach the bottom-right corner, or `-1` if it is not possible.","solution":"from collections import deque def minStepsMaze(maze): Given a 2D grid representing a maze, return the minimum number of steps required for a player to move from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). The player can move up, down, left, or right but cannot move through walls. :param maze: List[List[int]], a 2D grid representing the maze :return: int, minimum number of steps required to reach the bottom-right corner, -1 if not possible if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return -1 m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (m-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and maze[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a list of strings `timestamps` representing timestamps of some events in the format `YYYY-MM-DD hh:mm:ss` and a query. Each query is of the form `[unit, startTimestamp, endTimestamp]`, where `unit` is one of the `[\\"Year\\", \\"Month\\", \\"Day\\", \\"Hour\\", \\"Minute\\", \\"Second\\"]`, and `startTimestamp` and `endTimestamp` are timestamps of the same format as above. For each query, you need to return the number of events that occurred within the time range specified by `startTimestamp` and `endTimestamp`, inclusive, considering the precision specified by the `unit`. For example, if the unit is `\\"Year\\"`, compare only the years of the timestamps. If the unit is `\\"Hour\\"`, compare up to the hour, and so on. Implement the function `def countEvents(timestamps, queries)` which returns a list of integers, each representing the result of the corresponding query.","solution":"from datetime import datetime def countEvents(timestamps, queries): def parse_timestamp(ts, unit): if unit == \\"Year\\": return ts[:4] elif unit == \\"Month\\": return ts[:7] elif unit == \\"Day\\": return ts[:10] elif unit == \\"Hour\\": return ts[:13] elif unit == \\"Minute\\": return ts[:16] elif unit == \\"Second\\": return ts[:19] results = [] for unit, startTimestamp, endTimestamp in queries: startParsed = parse_timestamp(startTimestamp, unit) endParsed = parse_timestamp(endTimestamp, unit) count = sum(startParsed <= parse_timestamp(ts, unit) <= endParsed for ts in timestamps) results.append(count) return results"},{"question":"Given an integer string `s`, you are to decode it to a sentence following the steps below: 1. Separate the string into substrings such that each substring represents a unique digit. 2. Map each digit to its respective letter where \'1\' maps to \'A\', \'2\' maps to \'B\', ..., and \'9\' maps to \'I\'. 3. Concatenate these letters to form the resulting sentence. Return the decoded sentence in uppercase. For example: * If the input is `\\"123\\"`, the output should be `\\"ABC\\"`. * If the input is `\\"456\\"`, the output should be `\\"DEF\\"`.","solution":"def decode_integer_string(s): Decodes the given integer string to a sentence following the mapping: \'1\' -> \'A\', \'2\' -> \'B\', ..., \'9\' -> \'I\'. Args: s (str): The integer string to decode. Returns: str: The decoded sentence in uppercase. # Initialize a dictionary for mapping integers to letters mapping = { \'1\': \'A\', \'2\': \'B\', \'3\': \'C\', \'4\': \'D\', \'5\': \'E\', \'6\': \'F\', \'7\': \'G\', \'8\': \'H\', \'9\': \'I\' } # Decode the integer string using the dictionary decoded_sentence = \'\'.join(mapping[char] for char in s) return decoded_sentence"},{"question":"You are given an integer array `nums` representing the number of votes each candidate received in an election. The candidate with the highest number of votes is declared the winner unless more than one candidate has the highest number of votes. In that case, return the list of indices of the candidates who are tied for the most votes, in ascending order. If there is a single winner, return their index in a list. If no one has votes, return an empty list. Implement a function to determine the winner or the ties.","solution":"def election_winner(nums): Determines the winner or the ties in an election. :param nums: List[int] - the number of votes each candidate received. :return: List[int] - list of indices of the winner(s). if not nums: return [] max_votes = max(nums) winners = [i for i, votes in enumerate(nums) if votes == max_votes] return winners"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a street. A sunny view is defined as the view from the building where no other building taller or equal in height is directly to its west (left). Return the length of the longest subarray where every building in that subarray has a sunny view.","solution":"def longest_sunny_view_subarray(heights): Returns the length of the longest subarray where every building has a sunny view. max_length = 0 current_length = 0 max_height = -1 for height in heights: if height > max_height: current_length += 1 max_height = height else: current_length = 1 max_height = height max_length = max(max_length, current_length) return max_length"},{"question":"Given a string `expression` that consists of non-negative integers and the operators `+`, `-`, `*`, and `/`, return the result of the expression. The integer division should truncate toward zero. You may assume that the given expression is always valid and there are no leading or trailing spaces. Each number and operator is separated by exactly one space.","solution":"def evaluate_expression(expression): Evaluates a given expression string consisting of non-negative integers and the operators +, -, *, and /. The integer division should truncate toward zero. # Split the expression into tokens tokens = expression.split() # Stack for numbers stack = [] # Variable to keep track of the current operator, default is \'+\' current_op = \'+\' for token in tokens: if token.isdigit(): num = int(token) # Perform the operation based on the current operator if current_op == \'+\': stack.append(num) elif current_op == \'-\': stack.append(-num) elif current_op == \'*\': stack.append(stack.pop() * num) elif current_op == \'/\': # Integer division should truncate toward zero stack.append(int(stack.pop() / num)) else: # Update the current operator current_op = token # Return the sum of the stack return sum(stack)"},{"question":"You are given a string `s` containing lowercase English letters and an integer `k`. You need to determine if you can construct a palindrome using exactly `k` characters from the string `s`. Each character in the string can be used at most once. Return `true` if it is possible to construct such a palindrome and `false` otherwise. A palindrome is a word that reads the same forward and backward.","solution":"from collections import Counter def canConstructPalindrome(s, k): Determines if it is possible to construct a palindrome of exactly k characters from the string s. if k > len(s): return False char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most 1 character with an odd count (center character) # For k length palindrome: # - We need at most 1 odd_count (if k is odd) # - We need no odd_count if k is even return odd_count <= k and odd_count == k % 2"},{"question":"Create a function that generates all possible valid IP addresses from a given string `s` containing only digits. You can return the IP addresses in any order. An IP address is a sequence of four numbers (each between 0 and 255) separated by dots. The string `s` cannot contain leading zeros unless the number itself is 0. Function Signature: ```python def restoreIpAddresses(s: str) -> List[str]: ```","solution":"from typing import List def restoreIpAddresses(s: str) -> List[str]: def is_valid(segment: str) -> bool: Check if the segment is a valid IP address segment: - Must be a number between 0 and 255. - Must not have leading zeros unless it\'s \'0\'. return int(segment) <= 255 if segment == \\"0\\" else segment[0] != \\"0\\" and int(segment) <= 255 def backtrack(start: int = 0, parts: List[str] = []): # If reached the end of string and we have 4 parts (valid segments) if start == len(s) and len(parts) == 4: result.append(\\".\\".join(parts)) return # If we have 4 parts but haven\'t reached the end of the string, return if len(parts) == 4: return # Try to create segments length from 1 to 3 for length in range(1, 4): if start + length <= len(s): segment = s[start:start + length] if is_valid(segment): backtrack(start + length, parts + [segment]) result = [] backtrack() return result"},{"question":"Given an array of integers `arr`, return _an array of length 2 containing_ `[firstUnique, lastUnique]` _where_ `firstUnique` _is the value of the **first unique** element in the array ordering from the left, and_ `lastUnique` _is the value of the **last unique** element in the array ordering from the right. If there are no unique elements in the array, return_ `[-1, -1]`.","solution":"def first_last_unique(arr): Returns an array of length 2 containing [firstUnique, lastUnique] where firstUnique is the value of the first unique element in the array ordering from the left, and lastUnique is the value of the last unique element in the array ordering from the right. If there are no unique elements in the array, returns [-1, -1]. from collections import Counter # Count the occurrences of each element in the array counts = Counter(arr) # Find the first unique element first_unique = next((item for item in arr if counts[item] == 1), -1) # Find the last unique element reversed_arr = arr[::-1] last_unique = next((item for item in reversed_arr if counts[item] == 1), -1) return [first_unique, last_unique]"},{"question":"You are given a 2D grid of integers `grid` representing a maze where: - `0` represents an empty cell, - `1` represents a wall, - `2` represents the starting point, and - `3` represents the ending point. The task is to find the shortest path from the starting point to the ending point without passing through any walls. You can move up, down, left, or right to an empty cell. If there\'s no possible path, return `-1`. Implement the `MazeSolver` class: - `MazeSolver(int[][] grid)` Initializes the `MazeSolver` object with the maze grid. - `int shortestPath()` Returns the length of the shortest path from the starting point to the ending point. If there is no possible path, return `-1`.","solution":"from collections import deque class MazeSolver: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) self.start = None self.end = None # Locate starting and ending points for r in range(self.rows): for c in range(self.cols): if grid[r][c] == 2: self.start = (r, c) elif grid[r][c] == 3: self.end = (r, c) def shortestPath(self): if not self.start or not self.end: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize BFS queue = deque([(self.start[0], self.start[1], 0)]) # (row, col, distance) visited = set() visited.add(self.start) while queue: row, col, dist = queue.popleft() # If we have reached the end if (row, col) == self.end: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < self.rows and 0 <= new_col < self.cols and self.grid[new_row][new_col] != 1 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If there\'s no possible path return -1"},{"question":"You are given a string `s` containing only characters \'a\' and \'b\'. You want to remove the minimum number of characters from the string such that there are no two consecutive \'a\'s and no two consecutive \'b\'s. Return the length of the resulting string after the removals.","solution":"def min_removals(s): Returns the length of the string after removing the minimum number of characters such that there are no two consecutive \'a\'s and no two consecutive \'b\'s. if not s: return 0 result_length = 1 # Include the first character for i in range(1, len(s)): if s[i] != s[i - 1]: result_length += 1 return result_length"},{"question":"Given a list of words and two words `word1` and `word2`, return _the shortest distance between these two words in the list_. The distance between two words in the list is the number of index positions between them. You may assume that `word1` does not equal `word2`, and both words exist in the list.","solution":"def shortest_distance(words, word1, word2): Returns the shortest distance between word1 and word2 in the list of words. index1 = index2 = -1 min_distance = float(\'inf\') for i, word in enumerate(words): if word == word1: index1 = i elif word == word2: index2 = i if index1 != -1 and index2 != -1: distance = abs(index1 - index2) if distance < min_distance: min_distance = distance return min_distance"},{"question":"You are given a list of integers `nums`. Each integer in the list represents the number of coins in a particular pile. In one move, you can remove any amount of coins (including none) from a single pile. In each move, the goal is to make the maximum number of coins in any pile decrease. Return _the minimum number of moves required_ to make all piles contain the same number of coins.","solution":"def min_moves_to_equal_piles(nums): Returns the minimum number of moves required to make all piles contain the same number of coins. Each move consists of removing any number of coins from a single pile. The goal is to minimize the number of moves required to make all piles contain the same number of coins. # Calculate the number of moves by summing the differences between each pile and the minimum pile min_coins = min(nums) return sum(num - min_coins for num in nums)"},{"question":"An **m x n grid** represents a maze where `0` represents open paths and `1` represents walls. A person starts at the top-left corner `(0, 0)` and needs to find their way to the bottom-right corner `(m-1, n-1)`. You are allowed to move in four directions: up, down, left, and right. Return _the minimum number of steps needed to reach the bottom-right corner_, or `-1` if there is no possible path. The person cannot move through walls and cannot move outside the boundaries of the maze.","solution":"from collections import deque def min_steps_maze(maze): Returns the minimum number of steps needed to reach the bottom-right corner of a maze, or -1 if there is no possible path. :param maze: List[List[int]] representing the maze :return: Minimum number of steps or -1 if no path exists if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return -1 m, n = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, step_count) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == m-1 and c == n-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"You are given a 2D integer matrix `matrix` with only ones (1) and zeroes (0), where each row is sorted in a non-decreasing order. Your task is to find the leftmost column index with at least a one in it. If no such column exists, return -1. Implement the function `int leftMostColumnWithOne(int[][] matrix)` that achieves this. The function signature is: ``` int leftMostColumnWithOne(int[][] matrix) ``` Your algorithm should have a time complexity better than O(m*n), where m is the number of rows and n is the number of columns in the matrix.","solution":"def leftMostColumnWithOne(matrix): Finds the leftmost column index with at least a one in it. If no such column exists, return -1. if not matrix or not matrix[0]: return -1 m, n = len(matrix), len(matrix[0]) current_row = 0 current_col = n - 1 leftmost_col = -1 while current_row < m and current_col >= 0: if matrix[current_row][current_col] == 1: leftmost_col = current_col current_col -= 1 else: current_row += 1 return leftmost_col"},{"question":"You are given a string `s` consisting of only characters `a`, `b`, and `c`. You can delete any number of characters from the string `s` to form a new string. Your task is to determine the length of the longest possible substring consisting of exactly two types of characters. Each of these two characters must appear at least once in the substring. Return the length of such a substring. If no such substring exists, return 0.","solution":"def longest_two_char_substr(s): if not s: return 0 max_len = 0 n = len(s) # Trying all possible pairs of characters for char1 in \'abc\': for char2 in \'abc\': if char1 != char2: count1, count2 = 0, 0 length = 0 for char in s: if char == char1: count1 += 1 length += 1 elif char == char2: count2 += 1 length += 1 else: if count1 > 0 and count2 > 0: max_len = max(max_len, length) count1, count2, length = 0, 0, 0 if count1 > 0 and count2 > 0: max_len = max(max_len, length) return max_len"},{"question":"You are given the heads of two singly linked lists `headA` and `headB`. Imagine that they are potentially intersecting at some node, which means the ending nodes through the intersection onward are the same for both lists. Write an algorithm to find the node at which the intersection begins. Return `null` if there is no intersection. * `ListNode getIntersectionNode(ListNode headA, ListNode headB)`: Returns the node at which the intersection of two singly linked lists begins, or `null` if there is no intersection. Notes: * Please assume the list nodes number cannot exceed more than `10^5`. * Do not change the structures of the nodes.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Returns the intersection node of two singly linked lists, if any. Otherwise returns None. if not headA or not headB: return None # Create two pointers ptrA, ptrB = headA, headB # Traverse both lists while ptrA != ptrB: # When ptrA reaches the end, switch it to the head of B ptrA = ptrA.next if ptrA else headB # When ptrB reaches the end, switch it to the head of A ptrB = ptrB.next if ptrB else headA # Either they meet at the intersection or both become None return ptrA"},{"question":"You are given an array of integers `heights` representing the heights of students standing in a single file line. Each student is compared with the student standing directly in front of them, except for the first student. A student is considered to be \\"not in order\\" if they are shorter than the student directly in front of them. Your task is to determine the minimum number of students that need to change positions (swap) to ensure that all students are standing in non-decreasing order of height from front to back. Return the minimum number of swaps required.","solution":"def min_swaps_to_sort(heights): Returns the minimum number of swaps required to sort the students in non-decreasing order of heights. n = len(heights) indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indexed_heights[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_heights[x][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in ascending order and of length `m` and `n` respectively. Merge `nums2` into `nums1` as one sorted array. Assume that `nums1` has enough space (size `m + n`) to hold additional elements from `nums2`. You must do this by modifying `nums1` in-place without using any additional space. Return the modified `nums1`.","solution":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into nums1. Args: nums1: List[int] - The first sorted array with enough space to accommodate elements from nums2. m: int - The number of valid elements in nums1. nums2: List[int] - The second sorted array. n: int - The number of elements in nums2. Returns: List[int] - The merged sorted array contained in nums1. # Index of the last element in nums1\'s allocated space. last = m + n - 1 # Index of the last element in nums1. i = m - 1 # Index of the last element in nums2. j = n - 1 # Merge nums2 into nums1 from the end. while i >= 0 and j >= 0: if nums1[i] > nums2[j]: nums1[last] = nums1[i] i -= 1 else: nums1[last] = nums2[j] j -= 1 last -= 1 # Fill nums1 with remaining elements from nums2. while j >= 0: nums1[last] = nums2[j] j -= 1 last -= 1 return nums1"},{"question":"Given a string `s`, return the length of the longest substring of `s` that consists of the same character. For example, for the input `\\"aaabbbaaac\\"`, the longest substring of the same character is `\\"aaa\\"`, and its length is `3`. The input will consist of only lowercase English letters, and its length will be between `1` and `10^4`.","solution":"def longest_substring_same_char(s): Returns the length of the longest substring of the same character in the given string s. if not s: return 0 max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 max_len = max(max_len, current_len) else: current_char = s[i] current_len = 1 return max_len"},{"question":"You are given a string `formula` representing a chemical formula. Return a string representing the count of each atom in the simplest form. The count should be in alphabetical order. The formula consists of lowercase and uppercase letters, digits, and parentheses. The breakdown of the formula follows these rules: 1. If an atom appears sequentially, the count of atoms is added together. 2. If an atom appears within parentheses, the entire content within the parentheses is treated as a group, and the count outside the parentheses is applied to the entire group. 3. The counts of atoms are added based on the above rules to form the simplest count. For example: - Input: \\"H2O\\" - Output: \\"H2O\\" - Input: \\"Mg(OH)2\\" - Output: \\"H2MgO2\\" - Input: \\"K4(ON(SO3)2)2\\" - Output: \\"K4N2O14S4\\"","solution":"def parse_formula(formula): from collections import defaultdict import re def parse(s, i=0): n = len(s) atom_counts = defaultdict(int) while i < n: if s[i] == \'(\': sub_count, i = parse(s, i + 1) i += 1 start, end = i, i while end < n and s[end].isdigit(): end += 1 multiplier = int(s[start:end]) if end > start else 1 for k, v in sub_count.items(): atom_counts[k] += v * multiplier i = end elif s[i] == \')\': return atom_counts, i else: start = i if s[i].isupper(): i += 1 while i < n and s[i].islower(): i += 1 atom = s[start:i] start, end = i, i while end < n and s[end].isdigit(): end += 1 count = int(s[start:end]) if end > start else 1 atom_counts[atom] += count i = end return atom_counts, i counts, _ = parse(formula) return \'\'.join(f\\"{atom}{counts[atom] if counts[atom] > 1 else \'\'}\\" for atom in sorted(counts)) # Tests assert parse_formula(\\"H2O\\") == \\"H2O\\" assert parse_formula(\\"Mg(OH)2\\") == \\"H2MgO2\\" assert parse_formula(\\"K4(ON(SO3)2)2\\") == \\"K4N2O14S4\\""},{"question":"Given an integer array `nums`, you need to determine whether the array can be divided into consecutive subsequences of length `k`. A **consecutive subsequence** is a sequence of `k` numbers where the difference between any two consecutive numbers is `1`. If it is possible to divide the array into such consecutive subsequences, return `true`, otherwise return `false`. Note that each number in the array must be part of exactly one subsequence.","solution":"from collections import Counter def isPossibleDivide(nums, k): Determines if the array can be divided into consecutive subsequences of length k. Parameters: nums (List[int]): The array of integers. k (int): The length of each consecutive subsequence. Returns: bool: True if the array can be divided into consecutive subsequences of length k, otherwise False. if len(nums) % k != 0: return False num_count = Counter(nums) nums.sort() for num in nums: if num_count[num] > 0: for i in range(num, num + k): if num_count[i] > 0: num_count[i] -= 1 else: return False return True"},{"question":"You are given a **0-indexed** array of integers `nums`. The task is to transform the array such that: * All odd elements appear before all even elements. The relative order of the odd and even elements should be maintained from the original array. Return _the array after reorganizing it by placing all odd elements first followed by all even elements maintaining their original order_.","solution":"def separate_odd_even(nums): Rearranges the array such that all odd elements appear before all even elements. The relative order of odd and even elements is maintained. :param nums: List[int] :return: List[int] odds = [num for num in nums if num % 2 != 0] evens = [num for num in nums if num % 2 == 0] return odds + evens"},{"question":"You are tasked with managing a library inventory system. Each book in the library is characterized by a unique `id`, a `title`, an `author`, and a `publication year`. The system should support the following functionalities: * **Add Book**: Add a new book to the library inventory. * **Remove Book**: Remove a book from the inventory using its unique `id`. * **Search by Title**: Search for books using a keyword present in the title and return the matching results sorted first by `publication year` in ascending order, and then by `id` in ascending order if there is a tie. * **Search by Author**: Search for books by a particular author and return the matching books sorted first by `publication year` in ascending order, and then by `id` in ascending order if there is a tie. Implement the `LibraryInventory` class: * `LibraryInventory()` Initializes the library inventory system. * `void addBook(int id, String title, String author, int year)` Adds a new book to the inventory with the given `id`, `title`, `author`, and `publication year`. * `void removeBook(int id)` Removes the book with the given `id` from the inventory. * `List<Book> searchByTitle(String keyword)` Searches for books whose title contains the given `keyword` and returns a list of matching books sorted as described above. * `List<Book> searchByAuthor(String author)` Searches for books by the given `author` and returns a list of matching books sorted as described above. Each `Book` object in the resulting lists should have the properties `id`, `title`, `author`, and `year`.","solution":"class Book: def __init__(self, id, title, author, year): self.id = id self.title = title self.author = author self.year = year class LibraryInventory: def __init__(self): self.books = [] def addBook(self, id, title, author, year): new_book = Book(id, title, author, year) self.books.append(new_book) def removeBook(self, id): self.books = [book for book in self.books if book.id != id] def searchByTitle(self, keyword): result = [book for book in self.books if keyword.lower() in book.title.lower()] result.sort(key=lambda x: (x.year, x.id)) return result def searchByAuthor(self, author): result = [book for book in self.books if book.author.lower() == author.lower()] result.sort(key=lambda x: (x.year, x.id)) return result"},{"question":"You are given two integer arrays `deposits` and `withdrawals` representing the amount of money deposited and withdrawn from a bank account during a series of transactions. Each `deposits[i]` or `withdrawals[i]` value can be positive or negative, indicating a deposit (positive) or a withdrawal (negative) respectively. Calculate the maximum account balance that has been reached at any point during these transactions. The account starts with a balance of 0. Return _the maximum balance that has been achieved during the transactions._","solution":"def max_balance(deposits, withdrawals): Calculate the maximum account balance reached during the series of deposits and withdrawals. Args: deposits (list): List of deposit amounts. withdrawals (list): List of withdrawal amounts. Returns: int: The maximum balance achieved. current_balance = 0 max_balance = 0 transactions = [*deposits, *withdrawals] for transaction in transactions: current_balance += transaction if current_balance > max_balance: max_balance = current_balance return max_balance"},{"question":"You are given a **0-indexed** integer array `flowers`, where `flowers[i]` represents the number of flowers blooming on the `i-th` day. You are also given an integer `k`, which represents the number of contiguous days you can select to pick flowers. You must maximize the total number of flowers you pick over these `k` days. Return _the maximum number of flowers you can pick within `k` contiguous days_.","solution":"def max_flowers_picked(flowers, k): Returns the maximum number of flowers picked within k contiguous days. :param flowers: A list of integers where flowers[i] represents the number of flowers blooming on the i-th day. :param k: An integer representing the number of contiguous days to pick flowers. :return: The maximum number of flowers picked within k contiguous days. # Edge case if k is larger than the list size if k > len(flowers): return sum(flowers) # Calculate the initial window sum of the first \'k\' days window_sum = sum(flowers[:k]) max_flowers = window_sum # Slide the window across the flowers list for i in range(k, len(flowers)): window_sum = window_sum + flowers[i] - flowers[i - k] max_flowers = max(max_flowers, window_sum) return max_flowers"},{"question":"You are given an `m x n` 2D grid initialized with all `0`s. You need to perform several operations on this grid where each operation is represented by a triple `(r, c, d)` meaning that all cells in row `r` and column `c` should have their values increased by `d`. After all operations are performed, return the maximum value present in the grid.","solution":"def max_value_in_grid(m, n, operations): grid = [[0]*n for _ in range(m)] for r, c, d in operations: for i in range(n): grid[r][i] += d for i in range(m): grid[i][c] += d # since grid[r][c] will be incremented twice, we need to decrement it once grid[r][c] -= d # Find the maximum value in the grid max_value = max(max(row) for row in grid) return max_value"},{"question":"You are given a string `s` consisting of lowercase English letters and the `*` character, which acts as a wildcard that can be replaced by any single lowercase English letter. Consider all possible strings that can be produced by replacing each `*` character with any single lowercase English letter. Return _the **lexicographically smallest** string among all possible strings that can be formed_ from `s` after replacing all the `*` characters.","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string by replacing \'*\' with \'a\'. return s.replace(\'*\', \'a\')"},{"question":"You are given two strings `s1` and `s2` containing only lowercase English letters. Your task is to determine if you can convert `s1` to `s2` by deleting some (possibly zero) characters from `s1` without reordering the remaining characters. Return **true** if it is possible to convert `s1` to `s2` by this method, or **false** otherwise.","solution":"def can_convert(s1, s2): Determine if s2 can be obtained by deleting some characters from s1 without reordering. :param s1: The original string :param s2: The target string that needs to be obtained :return: Boolean value indicating if s2 can be obtained from s1 by deleting chars if not s2: return True s2_index = 0 for char in s1: if char == s2[s2_index]: s2_index += 1 if s2_index == len(s2): return True return s2_index == len(s2)"},{"question":"Given an array of integers `arr`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. **Example:** ```python Input: arr = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. ```","solution":"def max_subarray_sum(arr): Finds the largest sum of a contiguous subarray within a given array of integers. :param arr: List of integers :return: Integer representing the maximum subarray sum if not arr: # If the array is empty return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. Your task is to determine if there exists a way to partition the string `s` into exactly three non-empty parts `s1`, `s2`, `s3` such that each part contains the same set of characters. Each letter in the alphabet must have the same frequency in all three parts. Return `true` if such a partition exists, otherwise return `false`.","solution":"from collections import Counter def can_partition_into_three_equal_parts(s): Determines if the given string can be partitioned into exactly three non-empty parts such that each part contains the same set of characters with the same frequency. :param s: The input string (0-indexed) consisting of lowercase English letters :return: True if the string can be partitioned as described, False otherwise # The total length of the string must be divisible by 3 if len(s) % 3 != 0: return False # Each character in the string should appear a multiple of 3 times total_count = Counter(s) for count in total_count.values(): if count % 3 != 0: return False return True"},{"question":"Given a list of strings `operations` that contains operations performed on an initially empty stack, implement a function that returns the final content of the stack after all operations have been executed. The operations can be “PUSH x” (which pushes an integer x onto the stack), “POP” (which pops the top element from the stack), and “TOP” (which retrieves the top element but does not remove it). Assume the stack is never empty when a \\"POP\\" or \\"TOP\\" operation is performed. Return the final stack as a list of integers, where the bottom-most element of the stack is the first element in the list.","solution":"def stack_operations(operations): Executes a list of stack operations and returns the final content of the stack. Args: operations (list of str): List of operations (\\"PUSH x\\", \\"POP\\", \\"TOP\\"). Returns: list of int: Final content of the stack. stack = [] for op in operations: if op.startswith(\\"PUSH\\"): _, val = op.split() stack.append(int(val)) elif op == \\"POP\\": stack.pop() elif op == \\"TOP\\": top = stack[-1] return stack"},{"question":"You are given a 2D integer array `matrix` representing an `m x n` grid. Each cell in the grid can either be `0` (empty) or `1` (occupied). A path from the top left to the bottom right is considered **valid** if it only travels through empty cells (cells with value `0`) and moves in the directions of right, left, up, or down (but not diagonally). Write a function `bool hasValidPath(int[][] matrix)` that returns `true` if there is a valid path from the top-left to the bottom-right cell, otherwise returns `false`. **Definition of hasValidPath:** Parameters: - `int[][] matrix`: The 2D integer grid. Returns: - `boolean`: A boolean indicating if there is a valid path. **Note:** - The top-left cell and the bottom-right cell are guaranteed to be empty (i.e., they contain a `0`). - Dimensions of the grid are `m x n` with `1 <= m, n <= 100`.","solution":"def hasValidPath(matrix): Returns True if there is a valid path from the top-left to the bottom-right cell in the given matrix moving only through cells with value 0, otherwise returns False. if not matrix: return False m, n = len(matrix), len(matrix[0]) if matrix[0][0] != 0 or matrix[m-1][n-1] != 0: return False from collections import deque def is_valid(x, y): return 0 <= x < m and 0 <= y < n and matrix[x][y] == 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) matrix[0][0] = -1 # mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): queue.append((nx, ny)) matrix[nx][ny] = -1 # mark as visited return False"},{"question":"You are given an array of positive integers `arr` representing the heights of a stack of blocks, and an integer `m`. A block can be added to any stack in the array, but it must always maintain the form of a pyramid of height `m`. This means you cannot add a block to a stack if it would create a new stack height that breaks the pyramid property, where the maximum height of blocks decreases by 1 as you move away from the peak of the pyramid. For example, given `m = 3` and an existing stack `[1, 2, 3, 2, 1]` you can add a block at the peak or any other position following the pyramid property, but cannot add a block that makes the height greater or less cohesive with the pyramid structure. Calculate the maximum height of any of the stacks after any number of legal block additions. Return the maximum height of the blocks. **Note:** The pyramid property applies locally to where the blocks are added and ensures no dips or exceptions within the formed structure.","solution":"def max_pyramid_height(arr, m): Given an array of positive integers `arr` representing the heights of a stack of blocks, and an integer `m` representing the pyramid height, this function returns the maximum height a stack can reach after any number of legal block additions while maintaining the pyramid property for height `m`. if m <= 0: return 0 max_stack_height = 0 for height in arr: max_height = height + m - 1 max_stack_height = max(max_stack_height, max_height) return max_stack_height"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subsequence** is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements. Return the length of the longest **increasing subsequence** of `arr` such that the difference between the maximum and minimum element of the subsequence is less than or equal to `k`. If there is no such subsequence, return `0`.","solution":"def longest_increasing_subsequence_with_constraint(arr, k): Returns the length of the longest increasing subsequence such that the difference between the maximum and minimum element of the subsequence is less than or equal to k. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(n): for j in range(i): if arr[j] < arr[i] and (arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s`, find the length of the longest substring that consists of the same character repeated consecutively. For example, in the string `\\"aaabbcc\\"`, the longest substring with repeating characters is `\\"aaa\\"` with a length of 3. Return the length of this longest substring.","solution":"def longest_repeating_substring(s): Return the length of the longest substring that consists of the same character repeated consecutively. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # reset the counter for the new character # Check the last sequence max_length = max(max_length, current_length) return max_length"},{"question":"You are given a sorted integer array `arr` and a positive integer `k`. Your task is to find the `k`th missing positive integer from this array, which is the `k`th positive integer that is not present in `arr`. For example, consider the array `arr = [2, 3, 4, 7, 11]` and `k = 5`. The first five missing positive integers are `[1, 5, 6, 8, 9]`, so the 5th missing positive integer is `9`. Return the `k`th missing positive integer.","solution":"def findKthMissing(arr, k): Finds the k-th missing positive integer from the sorted array. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(arr) and arr[index] == current: index += 1 else: missing_count += 1 if missing_count < k: current += 1 return current"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer array `distance` of length 26. The distance array is indexed from 0 to 25, where `distance[i]` represents the minimum required distance between two occurrences of the ith character of the alphabet in the string. Determine if the string `s` satisfies the distance requirement for all characters. Return `true` if the string meets the requirement, and `false` otherwise.","solution":"def check_distances(s, distance): Returns true if the string s satisfies the distance requirement for all characters. Parameters: s (str): a string consisting of lowercase alphabets. distance (List[int]): an integer array of length 26 where distance[i] represents the minimum required distance between two occurrences of the ith character of the alphabet. Returns: bool: true if the string meets the distance requirement, false otherwise. last_occurrence = {} for i, char in enumerate(s): char_index = ord(char) - ord(\'a\') # find index in the distance array for the character if char in last_occurrence: if i - last_occurrence[char] - 1 != distance[char_index]: return False last_occurrence[char] = i return True"},{"question":"You are given a string `s` of length `n` consisting only of lowercase English letters. You need to determine if it is possible to partition the string `s` into exactly `k` contiguous non-empty substrings such that each substring is a palindrome. Return _`true` if it is possible to partition the string in such a manner, otherwise return `false`._","solution":"def can_partition_palindromes(s, k): Determine if the string s can be split into exactly k palindromic substrings. Args: s (str): The input string. k (int): The number of palindromic substrings required. Returns: bool: True if possible, else False. n = len(s) # Helper function to check if a string is a palindrome def is_palindrome(str): return str == str[::-1] # If k is greater than the length of the string, it is impossible if k > n: return False # If k is 1, the whole string must be a palindrome if k == 1: return is_palindrome(s) # If k is equal to the length of the string, every character must be a palindrome if k == n: return True # In general case, we need to check if we can form k palindomes # This can be simplified by realizing that a string can have at most as many palindromic blocks as half its length because a single palindrome block with odd length takes more than our required cuts # Hence, we need to check if the minimum required cuts to make k palindromes is achievable # To make k palindromes from a string \\"s\\" we need at least k cuts # This means we can only cut between two characters exactly n-1 times. # Therefore, k must be less than or equal to n # Example: \\"ababa\\" -> to form 3 palindromes k=3: \\"a\\", \\"bab\\", \\"a\\" # We use dynamic programming to check the minimum required cuts to make k palindromes dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True # every single character is a palindrome for length in range(2, n+1): # length of the substring for i in range(n-length+1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1] cuts = [float(\'inf\')] * n # cuts required to make all substrings palindromes for i in range(n): if dp[0][i]: cuts[i] = 0 else: for j in range(i): if dp[j+1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1] + 1 <= k"},{"question":"Given a string `s` consisting of only lowercase English letters, construct a new string by rearranging the letters of `s` such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. If there are multiple valid solutions, return any of them. Write a function that returns _the newly arranged string or an empty string if no valid arrangement exists_.","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange the given string \'s\' such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, \'\' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_str = \'\'.join(result) return rearranged_str if len(rearranged_str) == len(s) else \\"\\""},{"question":"Given a list of `n` words, return the **shortest** word that contains all the characters of the English alphabet at least once. If there is no such word, return an empty string. Each word in the list consists of only lowercase English letters. In case of multiple shortest words, return the lexicographically smallest one.","solution":"def get_shortest_word_with_english_alphabet(words): Returns the shortest word that contains all the characters of the English alphabet at least once. If there is no such word, returns an empty string. In case of multiple shortest words, returns the lexicographically smallest one. import string # Create a set of all the characters in the English alphabet for comparison alphabet_set = set(string.ascii_lowercase) # Initialize the shortest word as None shortest_word = None for word in words: if set(word) >= alphabet_set: if shortest_word is None or (len(word) < len(shortest_word)) or (len(word) == len(shortest_word) and word < shortest_word): shortest_word = word return shortest_word if shortest_word is not None else \'\'"},{"question":"Implement a contact management system that allows storing, searching, and deleting contacts. Each contact is represented by a name and a phone number. Implement the `ContactManager` class: * `ContactManager()` Initializes the empty `ContactManager` object. * `void addContact(String name, String phoneNumber)` Adds a contact with the given name and phone number to the system. * `void deleteContact(String name)` Deletes the contact with the given name from the system. * `String getPhoneNumber(String name)` Returns the phone number of the contact with the given name. If the contact does not exist, return an empty string. * `List<String> searchByNamePrefix(String prefix)` Returns a list of contact names that start with the given prefix. The results should be sorted in lexicographical order. If no contacts match the prefix, return an empty list. You may assume that the contact names are case-insensitive.","solution":"class ContactManager: def __init__(self): self.contacts = {} def addContact(self, name, phoneNumber): self.contacts[name.lower()] = phoneNumber def deleteContact(self, name): name = name.lower() if name in self.contacts: del self.contacts[name] def getPhoneNumber(self, name): return self.contacts.get(name.lower(), \\"\\") def searchByNamePrefix(self, prefix): prefix = prefix.lower() matched_names = [name for name in self.contacts if name.startswith(prefix)] return sorted(matched_names)"},{"question":"You are given a list of integers `nums` where each element represents the number of chocolates in a box. You are also given an integer `k` which represents the number of friends you want to distribute the chocolates to. You need to distribute the chocolates such that: - Each friend receives exactly one box of chocolates. - The difference between the number of chocolates in the box received by the friend who gets the most chocolates and the friend who gets the least chocolates is minimized. Return _the minimum possible difference between the chocolates in the box received by the friend who gets the most chocolates and the friend who gets the least chocolates_.","solution":"def minimumDifference(nums, k): Returns the minimum possible difference between the chocolates in the box received by the friend who gets the most chocolates and the friend who gets the least chocolates. Parameters: nums (list of int): List of integers representing number of chocolates in each box. k (int): Number of friends. Returns: int: The minimum difference. if k == 0 or k > len(nums): return 0 nums.sort() min_diff = float(\'inf\') for i in range(len(nums) - k + 1): diff = nums[i + k - 1] - nums[i] min_diff = min(min_diff, diff) return min_diff"},{"question":"Given a string `s` consisting of words separated by spaces, determine the length of the shortest word in the string. If there are multiple words with the same shortest length, return the length of any one of them. Write a function that accepts the string `s` as an argument and returns an integer representing the length of the shortest word. Note that words are separated by single spaces and there are no leading or trailing spaces in the input.","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the given string `s`. # Split the string into a list of words words = s.split() # Find and return the length of the shortest word return min(len(word) for word in words)"},{"question":"You are given a set of points in a 2D plane represented by an array `points` where `points[i] = [xi, yi]`. These points form a polygon when connected sequentially with a line segment between each pair of consecutive points and the last point connected to the first point. Determine if the polygon is **convex** or **concave**. A polygon is **convex** if all its interior angles are less than 180 degrees; otherwise, it is **concave**. Return `true` if the polygon is **convex**, and `false` if it is **concave**.","solution":"def is_convex(points): Determines if a polygon formed by the given points is convex or concave. Args: points (List[List[int]]): List of points representing the vertices of the polygon. Returns: bool: True if the polygon is convex, False if concave. def cross_product(o, a, b): Returns the cross product of vectors OA and OB. A positive cross product indicates a counter-clockwise turn, a negative one indicates a clockwise turn, and zero indicates a collinear alignment. return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) is_positive = None n = len(points) for i in range(n): o, a, b = points[i], points[(i + 1) % n], points[(i + 2) % n] cross_prod = cross_product(o, a, b) if cross_prod != 0: if is_positive is None: is_positive = cross_prod > 0 else: if is_positive != (cross_prod > 0): return False return True"},{"question":"Given an integer array `arr` and an integer `m`, return the maximum sum of any subarray of size `m`, where a subarray is a contiguous part of the array. If `m` is greater than the length of the array, return -1.","solution":"def max_sum_subarray(arr, m): Returns the maximum sum of any subarray of size m. Parameters: arr (list): The list of integers. m (int): The size of the subarray. Returns: int: The maximum sum of any subarray of size m, or -1 if m is greater than the length of the array. n = len(arr) # If m is greater than the length of the array, return -1 if m > n: return -1 # Initialize the sum of the first window of size m max_sum = current_sum = sum(arr[:m]) # Slide the window over the array for i in range(m, n): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase letters, an integer `k`, and an integer array `cost` of the same length as `s` where `cost[i]` represents the cost of deleting the character `s[i]`. You want to delete some characters from `s` such that the resulting string does not contain any k consecutive equal characters. Minimize the total cost of deletions required to achieve this. Return the minimum cost to delete characters from `s` so that no two adjacent characters are equal.","solution":"def minCost(s, k, cost): n = len(s) total_cost = 0 i = 0 while i < n: j = i current_cost = 0 max_cost = 0 count = 0 # Find a group of identical chars and calculate the total and max cost within the group while j < n and s[j] == s[i]: current_cost += cost[j] if max_cost < cost[j]: max_cost = cost[j] count += 1 j += 1 # Check for k consecutive characters if count >= k: # Exclude the max cost within the group as we keep it total_cost += (current_cost - max_cost) i = j return total_cost"},{"question":"You are given an array of integers `heights` representing the height of buildings lining a street, from left to right. The `heights[i]` value is the height of the `i-th` building. A building can only see the sunset if it is taller than all the buildings to its right. Write a function that returns the indices of the buildings that can see the sunset, in order from left to right. Implement the `SunsetView` class with the following methods: - `SunsetView(int[] heights)` Initializes the object with the buildings\' heights. - `List<Integer> getBuildingsWithSunsetView()` Returns the indices of the buildings that can see the sunset. For example, given the heights array `[3, 7, 8, 3, 6, 1]`, buildings with indices `[2, 4, 5]` can see the sunset since they are taller than all the buildings to their right.","solution":"class SunsetView: def __init__(self, heights): self.heights = heights def getBuildingsWithSunsetView(self): indices = [] max_height = float(\'-inf\') for i in reversed(range(len(self.heights))): if self.heights[i] > max_height: indices.append(i) max_height = self.heights[i] return indices[::-1]"},{"question":"You are given a 2D `grid` of size `m x n` where each cell represents a \'0\' (empty) or \'1\' (obstacle). Write a function that finds the number of unique paths from the top-left corner to the bottom-right corner, given that you can only move right or down. **However**, you can pass through the obstacles but can\'t end or start on them. Implement this using Dynamic Programming. Return the number of unique paths from the top-left to the bottom-right corner. It’s guaranteed that the start and end cells are not obstacles.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles, where you can pass through the obstacles but can\'t end or start on them. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"Given a list of non-negative integers representing the heights of buildings where the width of each building is 1 unit, return the area of the largest rectangle that can be formed by any number of consecutive buildings (rectangle boundaries align with building walls).","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram made up of the given heights. # Add a zero height to handle remaining heights in stack heights.append(0) max_area = 0 stack = [] for i in range(len(heights)): # Ensure stack is in increasing order of height\'s position while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] if stack: width = i - stack[-1] - 1 else: width = i max_area = max(max_area, h * width) stack.append(i) # Remove the 0 height added above for consistency heights.pop() return max_area"},{"question":"You are given a 2D array `grid` of size `m x n` representing a map where: - \'0\' represents water, - \'1\' represents land. An island is formed by connecting adjacent lands horizontally or vertically (but not diagonally) and is surrounded by water. You may assume all four edges of the grid are surrounded by water. Write a function to return the number of distinct islands. Two islands are considered distinct if and only if one island is not the same as another island (shape can differentiate them). __Note:__ - If your solution requires storing island shapes for comparison, ensure that it accounts for positioning and does not treat the same shape shifted/rotated as different.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the given grid. :param grid: List[List[str]] (2D array) where \'0\' represents water and \'1\' represents land :return: int, number of distinct islands def dfs(r, c, base_r, base_c, visited): stack = [(r, c)] shape = [] while stack: curr_r, curr_c = stack.pop() if 0 <= curr_r < len(grid) and 0 <= curr_c < len(grid[0]) and not visited[curr_r][curr_c] and grid[curr_r][curr_c] == \'1\': visited[curr_r][curr_c] = True rel_r, rel_c = curr_r - base_r, curr_c - base_c shape.append((rel_r, rel_c)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): stack.append((curr_r + dr, curr_c + dc)) return shape def get_canonical_shape(shape): def normalize(shape): shape.sort() min_r, min_c = shape[0] return [(r - min_r, c - min_c) for r, c in shape] canonical_shapes = [] for _ in range(4): shape = [(c, -r) for r, c in shape] # Rotate 90 degree canonical_shapes.append(normalize(shape)) shape = [(-r, c) for r, c in shape] # Reflect canonical_shapes.append(normalize(shape)) return min(canonical_shapes) if not grid or not grid[0]: return 0 visited = [[False] * len(grid[0]) for _ in range(len(grid))] distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == \'1\' and not visited[r][c]: shape = dfs(r, c, r, c, visited) canonical_shape = get_canonical_shape(shape) distinct_islands.add(tuple(canonical_shape)) return len(distinct_islands)"},{"question":"You are given a singly linked list `head` consisting of `n` nodes. Each node contains an integer value. Implement a function to **reorder** the list as follows: 1. Split the list into two halves. If the length of the list is odd, the extra node should be part of the first half. 2. Reverse the second half. 3. Merge the two halves by alternating nodes from each half. Modify the list in-place and return the reordered list. **Example:** Input: head = [1, 2, 3, 4, 5] Output: [1, 5, 2, 4, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return head # Function to find the middle of the list def find_middle(node): slow, fast = node, node while fast and fast.next: slow = slow.next fast = fast.next.next return slow # Function to reverse a linked list def reverse(node): prev, curr = None, node while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev # Find the middle of the list mid = find_middle(head) # Split the list into two halves second_half = mid.next mid.next = None # Reverse the second half second_half = reverse(second_half) # Merge the two halves by alternating nodes first_half = head while second_half: temp1, temp2 = first_half.next, second_half.next first_half.next = second_half second_half.next = temp1 first_half, second_half = temp1, temp2 return head # Helper function to convert list to ListNode def list_to_linkedlist(lst): dummy = ListNode() current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next # Helper function to convert ListNode to list def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"Given an integer array `arr`, find and return all the unique subsets of the array. Each element in the array may appear more than once, and the solution set must not contain duplicate subsets. The subsets may be returned in any order. Implement the function `List<List<Integer>> findUniqueSubsets(int[] arr)`.","solution":"from typing import List def findUniqueSubsets(arr: List[int]) -> List[List[int]]: Finds all unique subsets of the given array. def backtrack(start, path): res.append(path) for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue backtrack(i + 1, path + [arr[i]]) arr.sort() res = [] backtrack(0, []) return res"},{"question":"Given a list of `n` integers where each integer represents the height of a building on a flat 2D plane, find the **maximum area** of a rectangle that can be formed between two buildings where the rectangle\'s width is the distance between the two buildings, and the height is the minimum of the two buildings. Return the maximum area that can be achieved. The height of the rectangle is determined by the shorter of the two buildings that form its ends.","solution":"def max_area_of_rectangle(building_heights): Find the maximum area of a rectangle that can be formed between two buildings where the rectangle\'s width is the distance between the two buildings, and the height is the minimum of the two buildings. :param building_heights: List[int], a list of integers representing heights of buildings. :return: int, the maximum area of the rectangle. max_area = 0 i, j = 0, len(building_heights) - 1 while i < j: height = min(building_heights[i], building_heights[j]) width = j - i current_area = height * width max_area = max(max_area, current_area) # Move the pointer which points to the shorter building if building_heights[i] < building_heights[j]: i += 1 else: j -= 1 return max_area"},{"question":"Given a binary tree, return _the **flattened** version of the tree as a **linked list** such that the linked list should use the same node classes as the tree but should be structured in a way that each node\'s right child points to the next node of a pre-order traversal and the left child is always `null`_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree into a linked list using the same Node classes. The linked list should follow the pre-order traversal of the binary tree. if not root: return # We\'ll use a stack to simulate the pre-order traversal stack = [root] prev = None while stack: current = stack.pop() if prev: prev.right = current prev.left = None if current.right: stack.append(current.right) if current.left: stack.append(current.left) prev = current"},{"question":"Given an array of integers `nums` and an integer `k`, modify the array in-place such that all elements greater than `k` are moved to the end of the array, while the order of the other elements are preserved. Return the modified array. Note: The relative order of elements greater than `k` does not need to be preserved. You must solve the problem in `O(1)` extra space complexity and `O(n)` time complexity.","solution":"def move_elements(nums, k): Move elements greater than k to the end of the list in-place. Parameters: nums (List[int]): The list of integers to be modified. k (int): The threshold value. Returns: List[int]: The modified list with elements greater than k moved to the end. n = len(nums) i = 0 # Traverse through the array while i < n: if nums[i] > k: # Move the element to the end and pop it from the current position nums.append(nums.pop(i)) # As we have moved an element we reduce the size to consider our while loop n -= 1 else: # Move to the next element if condition not met i += 1 return nums"},{"question":"Given a `2D` grid of size `m x n` where one cell is marked as the starting point \'S\', one cell is marked as the destination \'D\', and \'#\' denotes a blocked cell that cannot be passed through. All other cells are empty \'.\' which can be walked through. You need to implement a function to find the shortest path from \'S\' to \'D\' that does not pass through any blocked cells. Return the length of the path. If there is no such path, return `-1`. You can move up, down, left, or right (but not diagonally) between the empty cells.","solution":"from collections import deque def shortest_path(grid): if not grid: return -1 m, n = len(grid), len(grid[0]) directions = [(-1,0), (1,0), (0,-1), (0,1)] start, end = None, None for i in range(m): for j in range(n): if grid[i][j] == \'S\': start = (i, j) elif grid[i][j] == \'D\': end = (i, j) if not start or not end: return -1 queue = deque([(start[0], start[1], 0)]) visited = set(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != \'#\': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a list of `n` integers representing coins, where `coins[i]` is the value of the `i-th` coin. You need to split these coins into two sets `A` and `B` such that the absolute difference between the sum of coins in set `A` and the sum of coins in set `B` is minimized. Return _the minimum possible absolute difference._","solution":"def min_difference_in_coins(coins): Returns the minimum possible absolute difference between sums of two sets A and B. total = sum(coins) n = len(coins) dp = [[False] * (total // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total // 2 + 1): dp[i][j] = dp[i - 1][j] if coins[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - coins[i - 1]] for j in range(total // 2, -1, -1): if dp[n][j]: return total - 2 * j"},{"question":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for the array `arr = [1,2,3]`, the following are all the permutations: `[1,2,3]`, `[1,3,2]`, `[2,1,3]`, `[2,3,1]`, `[3,1,2]`, and `[3,2,1]`. Given two integers `n` and `k`, return _the `k`-th permutation sequence of an array consisting of the integers from `1` to `n`_. The permutation sequence is considered to be indexed starting from `1`.","solution":"import math def get_permutation(n, k): Returns the k-th permutation sequence of an array consisting of the integers from 1 to n. :param n: The array will consist of numbers from 1 to n. :param k: The index (1-based) of the permutation sequence to return. :return: The k-th permutation as a string. numbers = list(range(1, n + 1)) k -= 1 # Convert k to 0-based index permutation = [] for i in range(n, 0, -1): factorial = math.factorial(i - 1) index = k // factorial k %= factorial permutation.append(numbers.pop(index)) return \'\'.join(map(str, permutation))"},{"question":"You are given two strings, `s1` and `s2`, and you need to determine if `s2` is a substring of any permutation of `s1`. In other words, you have to check if there is a permutation of `s1` which contains `s2` as a substring. Return _`true` if s2 is a substring of any permutation of s1, and `false` otherwise._","solution":"from collections import Counter def is_permutation_substring(s1, s2): Returns true if s2 is a substring of any permutation of s1. if len(s2) > len(s1): return False s2_count = Counter(s2) window_count = Counter(s1[:len(s2)]) if s2_count == window_count: return True for i in range(len(s2), len(s1)): window_count[s1[i]] += 1 window_count[s1[i - len(s2)]] -= 1 if window_count[s1[i - len(s2)]] == 0: del window_count[s1[i - len(s2)]] if window_count == s2_count: return True return False"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` where each element `nums[i]` represents the number of chocolates in the `i-th` box. You are also given an integer `k`, representing the number of boxes you have to choose. Your task is to find the **maximum** number of chocolates you can collect by choosing exactly `k` consecutive boxes from the array `nums`. Return _the maximum number of chocolates you can collect_.","solution":"def max_chocolates(nums, k): Finds the maximum number of chocolates you can collect by choosing exactly k consecutive boxes from the array \'nums\'. :param nums: List[int] - List of integers representing chocolates in each box. :param k: int - Number of consecutive boxes to choose. :return: int - Maximum chocolates collected. if not nums or k <= 0 or k > len(nums): return 0 # Calculate the sum of the first \'k\' boxes max_chocolates = current_sum = sum(nums[:k]) # Slide the window of size \'k\' and find the maximum sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_chocolates = max(max_chocolates, current_sum) return max_chocolates"},{"question":"Given an array of integers `nums` and an integer `target`, return all pairs of indices `(i, j)` such that `nums[i] + nums[j] == target` with `i < j`. Ensure to return the pairs in lexicographical order. If there are no such pairs, return an empty list. The solution should be efficient and avoid checking every possible pair.","solution":"def pair_indices(nums, target): Returns all pairs of indices (i, j) such that nums[i] + nums[j] == target with i < j. The pairs are returned in lexicographical order. pairs = [] seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: for j in seen[complement]: pairs.append((j, i)) if num in seen: seen[num].append(i) else: seen[num] = [i] pairs.sort() return pairs"},{"question":"You are given a string `expression` that represents a mathematical expression consisting of non-negative integers and the arithmetic operators `+`, `-`, `*`, and `/`. The expression string is fully parenthesized, meaning that every operation is enclosed in parentheses and each operand is either a single digit or another fully parenthesized expression. Your task is to evaluate the expression and return the result as an integer. Implement the function in such a way that it can handle both addition, subtraction, multiplication, and division. For example, given the expression `((2+3)*(4-2))`, the function should return `10` since `(2+3)` evaluates to `5` and `(4-2)` evaluates to `2`, and `5 * 2` equals `10`. Write a function that processes the input string and computes the correct final value based on the provided arithmetic operations and parentheses structure.","solution":"def evaluate_expression(expression): Evaluates a fully parenthesized mathematical expression consisting of non-negative integers and the operators +, -, *, and /. def helper(exp, index): if exp[index].isdigit(): start = index while index < len(exp) and exp[index].isdigit(): index += 1 return int(exp[start:index]), index if exp[index] == \'(\': index += 1 # skip \'(\' left_value, index = helper(exp, index) op = exp[index] index += 1 # skip operator right_value, index = helper(exp, index) if exp[index] == \')\': index += 1 # skip \')\' if op == \'+\': return left_value + right_value, index elif op == \'-\': return left_value - right_value, index elif op == \'*\': return left_value * right_value, index elif op == \'/\': return left_value // right_value, index else: raise ValueError(\\"Invalid Operator\\") result, _ = helper(expression, 0) return result"},{"question":"You are given a string `s` and an array of integers `pos` of the same length. The string `s` and the array `pos` represent a series of character insertions on a blank string where the character `s[i]` is inserted at position `pos[i]`. Given that all insertions are valid (i.e., no conflicts of positions exist), return the final string after all insertions. Note: The characters should be inserted in the order given in the array `pos`.","solution":"def insert_characters(s, pos): Inserts characters of the string `s` at the positions specified in the array `pos` into a blank string. Parameters: s (str): The string whose characters are to be inserted. pos (list of int): The positions at which characters are to be inserted. Returns: str: The final string after all insertions. # Initialize an array of characters with the same length as `s` result = [\'\'] * len(s) # Insert characters into their respective positions for char, index in zip(s, pos): result[index] = char # Join the list of characters into a final string return \'\'.join(result)"},{"question":"You are given an array of positive integers `heights` representing the heights of buildings on a street. You need to determine the maximum number of buildings that can receive sunlight in the morning. A building receives sunlight if there are no taller buildings to its left. Return _the maximum number of buildings that can receive sunlight_.","solution":"def max_sunlit_buildings(heights): Returns the maximum number of buildings that can receive sunlight in the morning. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The maximum number of buildings that can receive sunlight. if not heights: return 0 count = 1 # The first building always receives sunlight max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"Given a list of non-negative integers representing the amount of time each task takes, and an integer `d` representing the maximum number of days you can work, return _the minimum possible maximum working time for any day_ if you want to schedule the tasks over `d` days to minimize the maximum amount of time spent on any single day. Each task must be performed without splitting it over several days. For example, if the list of tasks is `[7, 2, 5, 10, 8]` and you have `d = 2` days, the minimum possible maximum working time for any day is `18`, where you can schedule the tasks as `[7, 2, 5]` and `[10, 8]`.","solution":"def can_split(tasks, d, max_work): current_sum = 0 required_days = 1 for task in tasks: if current_sum + task > max_work: required_days += 1 current_sum = task if required_days > d: return False else: current_sum += task return True def minimize_max_work_time(tasks, d): Return the minimum possible maximum working time for any day given the list of tasks and the maximum number of days. left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_split(tasks, d, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` containing lowercase alphabetic characters. A **substring** is any contiguous sequence of characters within the string. You need to find the length of the longest substring with all distinct characters. For example, if the input string is \\"abcabcbb\\", the answer is `3`, as the longest substring with all distinct characters is \\"abc\\". If the input string is \\"bbbbb\\", the answer is `1`, as the longest substring with all distinct characters is \\"b\\". If the input string is \\"pwwkew\\", the answer is `3`, as the longest substring with all distinct characters is \\"wke\\".","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` consisting of lowercase letters only. You need to find the first non-repeating character in it and return its index. If it doesn\'t exist, return -1. Implement the function `firstUniqChar(s: str) -> int`.","solution":"def firstUniqChar(s: str) -> int: Finds the index of the first non-repeating character in a string. If none exists, returns -1. from collections import Counter # Using Counter to count the occurrences of each character count = Counter(s) # Finding the first character with count 1 for idx, char in enumerate(s): if count[char] == 1: return idx # If no unique character found return -1"},{"question":"You are given an array of integers `arr` representing the heights of stacked boxes. The width of each box is the same. We need to determine the maximum number of boxes that can be stacked on top of each other, following these rules: 1. A box can only be placed on top of another box if its height is less than or equal to the height of the box below it. 2. You can only move boxes from top of the stack to another stack, i.e., the order of boxes cannot be changed. Return _the maximum height of the stack that can be formed_.","solution":"def max_stack_height(arr): Given an array of integers representing the heights of stacked boxes, determines the maximum number of boxes that can be stacked on top of each other following the rule that each box can only be placed on top of another box if its height is less than or equal to the height of the box below it. if not arr: return 0 max_height = 1 # Minimum one box can form a stack current_height = 1 # Initialize with the first box for i in range(1, len(arr)): if arr[i] <= arr[i-1]: current_height += 1 max_height = max(max_height, current_height) else: current_height = 1 # Reset the current height return max_height"},{"question":"Given a **0-indexed** string `s` of lowercase English letters and an integer `k`, determine whether it is possible to rearrange the characters of `s` such that there are exactly `k` pairs of adjacent characters that are the same. Return `true` if it is possible, otherwise return `false`.","solution":"from collections import Counter def can_rearrange_with_k_pairs(s, k): Determine if it is possible to rearrange the characters of the string s so that there are exactly k pairs of adjacent characters that are the same. Args: s (str): the input string k (int): the number of adjacent pairs required Returns: bool: True if it\'s possible to rearrange to get exactly k pairs, otherwise False freq = Counter(s) max_pairs = sum((count - 1) for count in freq.values()) return k <= max_pairs"},{"question":"A string `s` is called a **happy prefix** if a non-empty prefix of `s` is also a suffix of `s`, but the prefix and suffix must not overlap. In other words, if we denote the prefix and suffix by `prefix` and `suffix`, respectively, then the following conditions must hold true: * The `prefix` must be a non-empty string that appears at the beginning of `s`. * The `suffix` must be a non-empty string that appears at the end of `s`. * The length of `prefix` and `suffix` must be the same. * `prefix` and `suffix` must not overlap within `s`. Given the string `s`, return the longest **happy prefix** of `s`. If there is no such prefix, return an empty string.","solution":"def longest_happy_prefix(s): Returns the longest happy prefix of the string s. length = len(s) for i in range(length - 1, 0, -1): if s[:i] == s[-i:]: return s[:i] return \\"\\""},{"question":"Write a function that takes in a non-negative integer `n` and returns the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.","solution":"def number_of_steps(n): Returns the number of steps to reduce the number n to zero. If the current number is even, it is divided by 2. If it is odd, 1 is subtracted from it. steps = 0 while n > 0: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"You are given an array `arr` of integers representing the positions of `n` cars on a very long highway. Each car moves at the same speed, which is 1 unit per second. The goal is to find out the position of the cars after `k` seconds if all cars move in such a way that they do not overtake one another and their relative positions remain the same. Return the modified array representing the positions of the cars after `k` seconds.","solution":"def car_positions_after_seconds(arr, k): Returns the positions of the cars after k seconds. Each car moves at the same speed of 1 unit per second. The relative positions of the cars remain the same. :param arr: List[int], the initial positions of the cars :param k: int, the number of seconds :return: List[int], the positions of the cars after k seconds return [position + k for position in arr]"},{"question":"You are given a list of `tasks` in the form of a string array where each task represents a workflow to be executed. Each workflow is denoted by a sequence of process IDs separated by arrows (e.g., `\\"2->5->3\\"`). Each workflow must be executed in the order specified. Additionally, some workflows may depend on the completion of others. Dependencies are provided as a list of pairs `dependencies`, where `dependencies[i] = [task1, task2]` indicates that `task1` must be completed before `task2` can start. Implement an algorithm to return the order in which all the tasks should be completed or determine if it\'s impossible to complete all tasks (i.e., there is a circular dependency). Classes and Methods to Implement: * `class TaskScheduler`: * `TaskScheduler(String[] tasks, String[][] dependencies)` - Initializes the object with the list of tasks and their dependencies. * `List<String> getOrder()` - Returns a list of tasks in the order they should be executed. If it is impossible to complete all tasks, return an empty list.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self, tasks, dependencies): self.tasks = tasks self.dependencies = dependencies self.adj_list = defaultdict(list) self.in_degree = defaultdict(int) self.prepare_graph() def prepare_graph(self): # Initialize in-degree dictionary for all tasks for task in self.tasks: self.in_degree[task] = 0 # Build the graph and record in-degrees of nodes for dependency in self.dependencies: prev_task, next_task = dependency self.adj_list[prev_task].append(next_task) self.in_degree[next_task] += 1 def getOrder(self): # Perform topological sort zero_in_degree_queue = deque([task for task in self.tasks if self.in_degree[task] == 0]) topological_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topological_order.append(vertex) # Reduce the in-degree of each neighbor by 1 for neighbor in self.adj_list[vertex]: self.in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if self.in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological sort includes all tasks, return the order, else return empty list if len(topological_order) == len(self.tasks): return topological_order else: return [] # Example usage: # tasks = [\\"1->2->3\\", \\"4->5\\", \\"6\\"] # dependencies = [[\\"1->2->3\\", \\"4->5\\"], [\\"4->5\\", \\"6\\"]] # scheduler = TaskScheduler(tasks, dependencies) # result = scheduler.getOrder() # Output might be [\\"1->2->3\\", \\"4->5\\", \\"6\\"] or any valid topological sort order"},{"question":"You are given two **non-empty** binary trees `root1` and `root2`, where each tree node contains an integer value. Merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the non-null node will be used as the node of the new tree. Return _the merged tree_. # Example: ```plaintext Input: root1: [1,3,2,5], root2: [2,1,3,null,4,7] Output: [3,4,5,5,4,null,7] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees. If both nodes overlap, sum their values. If a node is missing in one tree, use the node from the other tree. if not root1 and not root2: return None elif not root1: return root2 elif not root2: return root1 root1.val += root2.val root1.left = mergeTrees(root1.left, root2.left) root1.right = mergeTrees(root1.right, root2.right) return root1"},{"question":"You are given an integer array `heights` representing the heights of buildings arranged in a line. You have a **water reservoir** that can be placed on these buildings. The water reservoir will trap water in the empty spaces between buildings, but the water trapped in each space is limited by the height of the shorter building on either side. Your task is to calculate the **total amount of trapped water**. Write a function `trap` that takes an integer array `heights` and returns the total trapped water. Example: ```python heights = [0,1,0,2,1,0,1,3,2,1,2,1] # The function should return the total amount of trapped water which is 6. ```","solution":"def trap(heights): Calculates the total amount of trapped water given an array of building heights. Parameters: heights (list of int): An integer array representing the heights of buildings. Returns: int: The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"You are given a **2D grid** of size `m x n` consisting of only the characters `\'0\'` and `\'1\'`. A **region** of the grid is defined as a connected component of `\'1\'`s (cells connected horizontally or vertically). Return _the number of **distinct regions** of `\'1\'`s in the grid.","solution":"def num_distinct_regions(grid): Returns the number of distinct regions of \'1\'s in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): # Stack for Depth-First Search (DFS) stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == \'1\': visited[nx][ny] = True stack.append((nx, ny)) region_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: region_count += 1 visited[i][j] = True dfs(i, j) return region_count"},{"question":"Given an integer `n`, return all possible time representations of the `n` minutes on a binary watch. The binary watch displays time in a format where: - The hour is represented by the first 4 bits (0-11). - The minutes are represented by the last 6 bits (0-59). For example, - 34 minutes would be represented as `00100010` in binary, which corresponds to `2:34` on a binary watch. - 19 minutes would be represented as `00010011` in binary, which corresponds to `0:19` on a binary watch. Return the list of all possible time representations in a format \\"h:mm\\" or \\"hh:mm\\" sorted lexicographically by default. Example: **Input:** `n = 1` **Output:** `[\\"0:01\\", \\"0:02\\", \\"0:04\\", \\"0:08\\", \\"0:16\\", \\"0:32\\", \\"1:00\\", \\"2:00\\", \\"4:00\\", \\"8:00\\"]` **Note:** - The order of times in the output list mirrors the sorting based on their actual time value. - The leading zero in the hour portion must be omitted, and minutes should always have two digits.","solution":"def read_binary_watch(n): def count_bits(x): Counts the number of 1s in binary representation of x. count = 0 while x: x &= (x - 1) count += 1 return count result = [] for h in range(12): for m in range(60): if count_bits(h) + count_bits(m) == n: result.append(f\\"{h}:{m:02d}\\") return sorted(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to return the first non-repeating character in `s`. If all characters are repeating, return \'_\'. Write an efficient algorithm to solve this problem with the lowest time complexity possible.","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, returns \'_\'. # Dictionary to store the frequency of each character char_count = {} # List to maintain the order of characters char_order = [] # Count the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 char_order.append(char) # Find the first non-repeating character by order for char in char_order: if char_count[char] == 1: return char return \'_\'"},{"question":"You are given a binary tree in which each node contains a value. The value of each node is an integer. Implement a method that returns the sum of the values of all nodes that are at the deepest level of the tree. The deepest level of a tree is defined as the level that is farthest from the root node. If there are multiple nodes at the deepest level, sum all their values. For example, given the binary tree: ``` 1 / 2 3 / / 4 5 6 7 / 8 ``` The deepest level is 4 (considering the levels start at 1), which contains only one node with value 8. The result should be 8. Another example, given the binary tree: ``` 1 / 2 3 / 4 5 6 / 7 8 ``` The deepest level is 4, which contains nodes with values 7 and 8. The sum of these values is 15.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_level_sum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"A gardener is planning to design a square garden with a water sprinkler system installed at the center of the garden. The garden will be represented by an `n x n` grid and the sprinkler at the center can water its surrounding cells. Given an integer `n` representing the size of the garden grid (where `n` is always odd, so there is a distinct center cell) and another integer `r` representing the radius of the sprinkler\'s reach (including the center cell), determine the number of cells that would be watered by the sprinkler. The sprinkler can water all cells within a Manhattan distance of `r` from the center cell. Write a function: ```python def watered_cells(n: int, r: int) -> int: ``` that returns the number of cells that would be watered by the sprinkler.","solution":"def watered_cells(n: int, r: int) -> int: Returns the number of cells that would be watered by the sprinkler. Parameters: - n: an odd integer representing the size of the garden grid (n x n). - r: an integer representing the radius of the sprinkler\'s reach. Returns: - The number of cells watered by the sprinkler. center = n // 2 watered = 0 for i in range(n): for j in range(n): if abs(center - i) + abs(center - j) <= r: watered += 1 return watered"},{"question":"You are given a string `s` consisting solely of characters \'a\', \'b\', and \'c\'. You need to reorder the string such that no two adjacent characters are the same. If it is possible to reorder the string in this way, return the rearranged string. If it is not possible, return an empty string.","solution":"import heapq from collections import Counter def rearrange_string(s): # Count the frequencies of each character freq = Counter(s) # Create a max heap from the frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Placeholder for the previous character and its count prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If previous character still remains, push it back into the heap if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and decrement the count prev_char = char prev_count = count + 1 # decrement the count since we\'ve used one instance # Check if the result\'s length matches the input string length if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"Given a grid of size `m x n` consisting of `0`s (land) and `1`s (water), an island is a group of `0`s connected `4-directionally` (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Find the largest island and return _its area_.","solution":"def largest_island(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return 0 grid[x][y] = -1 # mark as visited area = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: area += dfs(x + dx, y + dy) return area m, n = len(grid), len(grid[0]) max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 0: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"Given an array `nums` of `n` integers, return _the length of the longest subarray that contains no more than `k` distinct integers._ You may assume that the input `nums` contains at least one element and `k` is a positive integer less than or equal to `n`. For example, for `nums = [1, 2, 1, 2, 3]` and `k = 2`, the result should be `4` because the longest subarray with at most `2` distinct integers is `[1, 2, 1, 2]`.","solution":"def longest_subarray_with_k_distinct(nums, k): from collections import defaultdict left, right = 0, 0 n = len(nums) freq_map = defaultdict(int) max_length = 0 while right < n: freq_map[nums[right]] += 1 right += 1 while len(freq_map) > k: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"You are given an array of `n` integers `arr` where `arr[i]` represents the height of the `i-th` plant in a garden. A garden is considered beautiful if for any two plants with indices `i` and `j` (where `i < j`), the absolute difference in height between these plants is no more than `k`. Write a function that returns the maximum number of plants that can be included in a beautiful garden.","solution":"def max_beautiful_garden(arr, k): Returns the maximum number of plants that can be included in a beautiful garden. :param arr: List[int] - a list of integers where arr[i] represents the height of the i-th plant. :param k: int - maximum allowed difference in height between any two plants. :return: int - the maximum number of plants in a beautiful garden. if not arr: return 0 arr.sort() left = 0 max_count = 0 for right in range(len(arr)): while arr[right] - arr[left] > k: left += 1 max_count = max(max_count, right - left + 1) return max_count"},{"question":"Given an array `directions` where `directions[i] = \'L\'`, `\'R\'`, `\'U\'`, or `\'D\'`, representing movements left, right, up, and down respectively, determine if the series of movements returns you to the original starting point `(0, 0)`. Return `true` if you return to the origin after performing all the movements, otherwise return `false`.","solution":"def is_back_to_origin(directions): Determine if the series of movements returns to the origin (0, 0). Parameters: directions (list of str): The list of movements (\'L\', \'R\', \'U\', \'D\'). Returns: bool: True if the series of movements returns to the origin, False otherwise. x, y = 0, 0 for direction in directions: if direction == \'L\': x -= 1 elif direction == \'R\': x += 1 elif direction == \'U\': y += 1 elif direction == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Given a 2D matrix `grid` of dimensions `m x n`, where each cell is either a land (represented by 1) or water (represented by 0), find the size of the largest island in the grid. An island is a group of connected lands, connected either horizontally or vertically (not diagonally). You may assume that there is exactly one island in the grid. Write a function `int largestIsland(int[][] grid)` that returns the size of the largest island.","solution":"def largestIsland(grid): Returns the size of the largest island in the grid. :param grid: List[List[int]], a 2D matrix representing the grid :return: int, size of the largest island def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark this cell as visited by setting it to water size = 1 # Count the current cell # Explore all four directions (up, down, left, right) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given an **m x n** binary matrix `grid`. An island is a group of `1`s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. You need to find the largest island and determine the number of cells it comprises. Return _the maximum number of cells in an island_.","solution":"def max_area_of_island(grid): def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited area = 1 # counting itself # explore the 4 directions area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # found an island part max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a list of integers `nums` that contains `n` unique elements. You are also given two integers `start` and `end` representing the range of indices. Reverse the subset of list `nums` between indices `start` and `end` (inclusive) and then return the entire modified list.","solution":"def reverse_sublist(nums, start, end): Reverses the subset of the list nums between indices start and end (inclusive). Args: nums (list of int): The original list of unique integers. start (int): The starting index of the subset to reverse. end (int): The ending index of the subset to reverse. Returns: list of int: The modified list with the specified subset reversed. if start < 0 or end >= len(nums) or start > end: raise ValueError(\\"Invalid start or end indices\\") nums[start:end+1] = nums[start:end+1][::-1] return nums"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You can at most perform `k` operations on this string, where each operation consists of deleting any single character from it. Your goal is to determine the length of the longest substring that contains no more than `1` distinct character. Return _the length of the longest substring after performing at most_ `k` _operations_. The test cases are generated such that it is always possible to find a solution under the given constraints.","solution":"def longest_substring(s, k): Returns the length of the longest substring that contains no more than 1 distinct character after performing at most k deletions. from collections import Counter left = 0 max_len = 0 char_count = Counter() for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > 1: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return min(len(s), max_len + k)"},{"question":"You are given an array of integers where both the maximum value and its frequency are unknown. Write a function to find the value that appears most frequently alongside its frequency. If there are multiple values with the same highest frequency, return the smallest one. **Function Signature:** ```python def most_frequent_element(arr: List[int]) -> Tuple[int, int]: # Your code here ```","solution":"from typing import List, Tuple from collections import Counter def most_frequent_element(arr: List[int]) -> Tuple[int, int]: Returns the value that appears most frequently in the array and its frequency. If multiple values have the same highest frequency, the smallest value is returned. if not arr: return (None, 0) freq_counter = Counter(arr) max_frequency = max(freq_counter.values()) most_frequent_values = [num for num, freq in freq_counter.items() if freq == max_frequency] smallest_value = min(most_frequent_values) return (smallest_value, max_frequency)"},{"question":"You are given two arrays, `a` and `b`, both containing `n` unique integers. The arrays represent the initial and target arrangement of marbles on a table. You can perform the following operation any number of times: * Choose any marble from array `a` and relocate it to any valid position in array `b`, provided that the relative order of the remaining marbles in array `a` remains unchanged. Determine the minimum number of operations required to transform array `a` into array `b`. Return this minimum number of operations.","solution":"def min_operations_to_transform(a, b): Determines the minimum number of operations required to transform array a into array b. n = len(a) position_in_b = {value: idx for idx, value in enumerate(b)} lis = [] for value in a: if value in position_in_b: index_b = position_in_b[value] pos = find_position_to_replace(lis, index_b) if pos < len(lis): lis[pos] = index_b else: lis.append(index_b) return n - len(lis) def find_position_to_replace(sequence, value): Helper function to perform binary search to find the position to replace in the sequence. low, high = 0, len(sequence) while low < high: mid = (low + high) // 2 if sequence[mid] < value: low = mid + 1 else: high = mid return low"},{"question":"You are given an integer `n` representing the number of cities and an integer `m` representing the number of paths between those cities. The cities are numbered from `1` to `n`. Each of the `m` paths can be traveled by bike or car, and is represented by a triplet `[u, v, type]` where `u` and `v` denote the endpoints of the path, and `type` is `1` if it\'s a bike path and `2` if it\'s a car path. You are also given two integers `start` and `end` representing the starting city and the destination city, respectively. Your task is to determine the **minimum number of paths** one needs to travel to go from the `start` city to the `end` city. You can travel by either bike or car, but you must adhere to the provided path types. Return the minimum number of paths required to reach from the start to the end city. If there is no such route, return `-1`.","solution":"from collections import deque, defaultdict def min_paths(n, m, paths, start, end): Finds the minimum number of paths to travel from start city to end city. :param n: int - number of cities :param m: int - number of paths :param paths: list of tuples - each tuple is (u, v, type) where u and v are cities, and type is 1 (bike) or 2 (car) :param start: int - starting city :param end: int - destination city :return: int - minimum number of paths required, or -1 if no route exists if start == end: return 0 graph = defaultdict(list) for u, v, type_ in paths: graph[u].append((v, type_)) graph[v].append((u, type_)) # BFS initialization queue = deque([(start, 0)]) # (current_city, path_count) visited = set() visited.add(start) while queue: current_city, path_count = queue.popleft() for neighbor, path_type in graph[current_city]: if neighbor == end: return path_count + 1 if (neighbor, path_type) not in visited: visited.add((neighbor, path_type)) queue.append((neighbor, path_count + 1)) return -1"},{"question":"Given an array of integers, write a function to find the longest subsequence that is strictly increasing. The subsequence does not have to be contiguous but cannot change the order of elements from the original array. Implement the `LongestIncreasingSubsequence` class that includes: * `LongestIncreasingSubsequence(int[] nums)` Initializes the instance with the array `nums`. * `int findLIS()` Returns the length of the longest increasing subsequence.","solution":"class LongestIncreasingSubsequence: def __init__(self, nums): self.nums = nums def findLIS(self): if not self.nums: return 0 n = len(self.nums) lis = [1] * n for i in range(1, n): for j in range(0, i): if self.nums[i] > self.nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"In a decaying city, there is a network of roads forming a grid of size m x n. Each cell in the grid represents an elevation map where the elevation heights are represented by an integer array heights of size m x n. The current cell position is designated as (0, 0), and the exit point is at (m-1, n-1). From the current cell, you can move to any adjacent cell, i.e., to the cell on the right, left, up, or down. However, you want to find a route to the exit such that the maximum difference in elevation between adjacent cells along the path is minimized. You need to return the minimum effort required to travel from the start point (0, 0) to the destination (m-1, n-1). Note that the difference in elevation between two adjacent cells `(i,j)` and `(x,y)` is given by `|heights[i][j] - heights[x][y]|`, where `|·|` represents the absolute value. Return an integer representing the minimum effort required.","solution":"from heapq import heappop, heappush from itertools import product def minimumEffortPath(heights): Returns the minimum effort required to travel from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) in the grid. rows, cols = len(heights), len(heights[0]) effort_to = [[float(\'inf\')] * cols for _ in range(rows)] effort_to[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return effort for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: new_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if effort_to[nx][ny] > new_effort: effort_to[nx][ny] = new_effort heappush(min_heap, (new_effort, nx, ny)) return -1 # Execution should never reach here as there\'s always a path."},{"question":"Given a list of integers, you need to determine the maximum sum of a contiguous subarray, where the length of the subarray is exactly `k`. If there are multiple subarrays with the maximum sum, return the one which appears first. Implement the function: ```python def max_subarray_sum_k(arr: List[int], k: int) -> List[int]: # Your code here ``` The function should return the subarray itself, not the sum. You can assume that the array contains at least `k` elements.","solution":"from typing import List def max_subarray_sum_k(arr: List[int], k: int) -> List[int]: Returns the subarray of length k with the maximum sum. max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = current_sum max_index = 0 for i in range(1, len(arr) - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_index = i return arr[max_index:max_index + k]"},{"question":"You are given a list of `n` integers, where each integer represents the height of a building on a street. You have an unlimited number of horizontal lines that you can use to draw across these buildings. A line will be considered to intercept buildings if it lies at the exact top height of any building or any height in between. Your task is to determine the **minimum** number of horizontal lines needed to **at least touch or intersect** every building. Return the minimum number of lines required to touch all buildings.","solution":"def min_lines_to_touch_buildings(buildings): Returns the minimum number of horizontal lines needed to at least touch or intersect every building. Args: buildings (list of int): A list of integers representing the heights of buildings. Returns: int: The minimum number of horizontal lines required. if not buildings: return 0 # The minimum number of lines needed will be equal to the number of unique heights. unique_heights = set(buildings) return len(unique_heights)"},{"question":"You are given a list of `transactions` where `transactions[i] = [sender, receiver, amount]` represents a transaction from user `sender` to user `receiver` of `amount` units. Implement a function that returns a list of users who have a net balance of zero after all transactions are processed. A user\'s net balance is obtained by summing the amounts they received and subtracting the amounts they sent. The result should be sorted in ascending order of user identifiers.","solution":"def net_zero_users(transactions): Returns a list of users with a net zero balance after processing the transactions. The resulting list is sorted in ascending order of user identifiers. from collections import defaultdict balance = defaultdict(int) for sender, receiver, amount in transactions: balance[sender] -= amount balance[receiver] += amount zero_balance_users = [user for user, bal in balance.items() if bal == 0] return sorted(zero_balance_users)"},{"question":"You are given a linked list of integers `head` and an integer `n`. Your task is to reverse the nodes of the linked list in groups of `n`, and return the modified list. If the number of nodes is not a multiple of `n`, then the remaining nodes at the end should be left as is. A group\'s reversal should maintain the original order of nodes within the group. For example, if we have a linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` and `n = 3`, the list will be transformed to `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): def reverse_linked_list(head, k): prev, curr = None, head while k > 0: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev count = 0 ptr = head while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverse_k_group(ptr, k) return reversed_head return head"},{"question":"You are working on a project that involves managing a queue of tasks. Each task has an associated priority, and tasks should be processed in priority order. Implement the `TaskManager` class to support the following operations: * `TaskManager()` Initializes the `TaskManager` with an empty queue. * `void addTask(int taskId, int priority)` Adds a new task with the given `taskId` and `priority` to the queue. If the task already exists, update its priority. * `int getNextTask()` Retrieves and removes the task with the highest priority from the queue. If multiple tasks have the same priority, retrieve the one that was added first. If no tasks are available, return -1. * `void removeTask(int taskId)` Removes the task with the given `taskId` from the queue. If the task does not exist, nothing happens. * `int peekNextTask()` Retrieves but does not remove the task with the highest priority from the queue. If multiple tasks have the same priority, retrieve the one that was added first. If no tasks are available, return -1. Note: Priority is represented as an integer, and a higher number indicates a higher priority. Assume that the `taskId` is unique.","solution":"import heapq class TaskManager: def __init__(self): self.task_map = {} # Maps taskId to (priority, index), to facilitate updates and removals self.task_list = [] # List to maintain the heap property based on priority and index self.index = 0 # This will serve as a timestamp to maintain the order of insertion def addTask(self, taskId, priority): if taskId in self.task_map: self.removeTask(taskId) entry = [-priority, self.index, taskId] # Use a negative priority for max-heap behavior heapq.heappush(self.task_list, entry) self.task_map[taskId] = entry self.index += 1 def getNextTask(self): while self.task_list: priority, index, taskId = heapq.heappop(self.task_list) if taskId in self.task_map: del self.task_map[taskId] return taskId return -1 def removeTask(self, taskId): entry = self.task_map.pop(taskId, None) if entry: entry[-1] = None # Set the taskId to None to mark the entry as removed def peekNextTask(self): while self.task_list: priority, index, taskId = self.task_list[0] if taskId is not None: return taskId heapq.heappop(self.task_list) # Remove the invalidated entry return -1"},{"question":"Given a list of integers `arr` representing a binary tree in level-order traversal, return _the **maximum** width of the binary tree_. The **width** of a binary tree is the maximum width among all levels. The width of one level is defined as the number of nodes between the leftmost and rightmost non-null nodes on that level (inclusive). The tree is represented in level-order, where a `null` value indicates the absence of a node. For example, given the list `arr = [1, 3, 2, 5, 3, null, 9]`, the binary tree has a level-order traversal as: ``` 1 / 3 2 / 5 3 9 ``` The width of the tree is `4`, as the maximum width is observed on the second level [5, 3, null, 9].","solution":"def width_of_binary_tree(arr): Returns the maximum width of the binary tree represented by a list `arr` in level-order traversal. if not arr: return 0 # List to keep the current level width calculations level_widths = [] # Init queue with the root node and its index queue = [(0, 1)] # (index in arr, position in tree) while queue: level_length = len(queue) start_position = queue[0][1] end_position = queue[-1][1] level_widths.append(end_position - start_position + 1) # Queue for the next level new_queue = [] for i in range(level_length): index, pos = queue[i] # Calculate the children\'s positions left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(arr) and arr[left_child_index] is not None: new_queue.append((left_child_index, 2 * pos)) if right_child_index < len(arr) and arr[right_child_index] is not None: new_queue.append((right_child_index, 2 * pos + 1)) queue = new_queue return max(level_widths)"},{"question":"You are given a list of strings words and a string prefix. Your task is to write a function `countWordsWithPrefix(words: List[str], prefix: str) -> int` that returns the number of strings in the list that have the given prefix. For example, given the list `words = [\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"]` and the prefix `prefix = \\"app\\"`, the function should return `3` because \\"apple\\", \\"app\\", and \\"application\\" all start with \\"app\\". --- Note: Ensure you assess the function\'s efficiency to handle larger lists of words and prefixes accurately.","solution":"from typing import List def countWordsWithPrefix(words: List[str], prefix: str) -> int: Returns the number of strings in the list that start with the given prefix. count = 0 for word in words: if word.startswith(prefix): count += 1 return count"},{"question":"Given a string `s` and an array of integers `indices` of the same length, `s` represents a scrambled string and `indices` defines the order of characters in `s` after sorting. Write a function that returns the original (unscrambled) string before the scramble occurred. For example, if `s = \\"edcba\\"` and `indices = [4, 3, 2, 1, 0]`, the original string was `\\"abcde\\"` because placing each character `s[i]` at `indices[i]` positions results in the alphabetically sorted string.","solution":"def restore_string(s, indices): Restore the original string by placing each character s[i] at the position indices[i]. Args: s (str): The scrambled string. indices (list): The list of positions for each character in the original string. Returns: str: The original unscrambled string. original_string = [\'\'] * len(s) for i, index in enumerate(indices): original_string[index] = s[i] return \'\'.join(original_string)"},{"question":"You are given a string `pattern` and another string `text`. In one operation, you can remove any one character from the `text` string. Your task is to find the **minimum** number of operations needed to make `pattern` a **subsequence** of `text`. A **subsequence** of a string is a new string generated from the original string by deleting some characters (possibly none) without changing the remaining characters\' relative order.","solution":"def min_operations_to_subsequence(pattern, text): Returns the minimum number of operations to make `pattern` a subsequence of `text`. m, n = len(text), len(pattern) i, j = 0, 0 while i < m and j < n: if text[i] == pattern[j]: j += 1 i += 1 return n - j"},{"question":"You are given a string `s` and an integer `k`. Return the number of substrings of `s` of length `k` that are palindrome. A string is palindrome if it reads the same forward and backward. Substrings are consecutive segments of the string, so different starting positions of the same palindromic sequence are considered distinct substrings.","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def count_palindromic_substrings(s, k): Returns the number of palindromic substrings of length k in the string s. n = len(s) count = 0 # Iterate through the string to get all possible substrings of length k for i in range(n - k + 1): substring = s[i:i+k] if is_palindrome(substring): count += 1 return count"},{"question":"You are given a **0-indexed** integer array `costs` where `costs[i]` represents the cost of ith item. You are also given an integer `money` representing the amount of money you have. You want to maximize the number of items you can buy with the money you have. Implement the `ShoppingOptimizer` class: * `ShoppingOptimizer(int[] costs, int money)` - Initializes the object with `costs` array and `money`. * `int maximizeItems()` - Returns the maximum number of items you can buy with the given money. If no items can be bought, return `0`. * `int spend(int itemIndex)` - If the item with index `itemIndex` can be bought with the remaining money, reduce the money accordingly and return the cost of the item. Otherwise, return `-1`. Ensure that the methods properly handle the scenario where the `itemIndex` is invalid (i.e., `itemIndex` is out of bounds of the `costs` array).","solution":"class ShoppingOptimizer: def __init__(self, costs, money): Initializes the object with costs array and money. self.costs = costs self.money = money def maximizeItems(self): Returns the maximum number of items you can buy with the given money. sorted_costs = sorted(self.costs) total_items = 0 for cost in sorted_costs: if self.money >= cost: self.money -= cost total_items += 1 else: break return total_items def spend(self, itemIndex): If the item with index itemIndex can be bought with the remaining money, reduce the money accordingly and return the cost of the item. Otherwise, return -1. if 0 <= itemIndex < len(self.costs): if self.money >= self.costs[itemIndex]: self.money -= self.costs[itemIndex] return self.costs[itemIndex] else: return -1 else: return -1"},{"question":"Given a string `s` which represents a numeric expression that includes non-negative integers and the \'+\', \'-\', \'*\', and \'/\' operators (addition, subtraction, multiplication, and division respectively), return the result of the expression. The division here is integer division, meaning the result should be the integer part of the quotient. The input expression is guaranteed to be a valid expression. Implement the function so that it can handle operator precedence and parentheses properly.","solution":"def evaluate_expression(s): Evaluate the given numeric expression string and return the result. The expression can include non-negative integers and the \'+\', \'-\', \'*\', and \'/\' operators. Division is integer division, and the function handles operator precedence and parentheses. def helper(tokens): stack = [] num = 0 sign = \'+\' while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = helper(tokens) if (not token.isdigit() and token != \' \') or len(tokens) == 0: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) sign = token num = 0 if token == \')\': break return sum(stack) tokens = list(s.replace(\' \', \'\')) return helper(tokens)"},{"question":"You have an array of integers `nums` representing a binary tree in level-order traversal, where `nums[0]` is the root. Write a function to determine _the maximum depth_ of the binary tree. The _maximum depth_ is the number of nodes along the longest path from the root node down to the farthest leaf node. Assume that all values in `nums` are valid integers and `-1` represents a missing node. The binary tree may be incomplete, meaning that some nodes may be missing children. Return the _maximum depth_ of the tree. For example, given `nums = [3, 9, 20, -1, -1, 15, 7]`, the binary tree looks like this: ``` 3 / 9 20 / 15 7 ``` And its maximum depth is `3`.","solution":"from collections import deque def max_depth(nums): if not nums: return 0 index = 0 depth = 0 queue = deque([index]) while queue: depth += 1 level_length = len(queue) for _ in range(level_length): current_index = queue.popleft() left_child_index = 2 * current_index + 1 right_child_index = 2 * current_index + 2 if left_child_index < len(nums) and nums[left_child_index] != -1: queue.append(left_child_index) if right_child_index < len(nums) and nums[right_child_index] != -1: queue.append(right_child_index) return depth"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to perform `k` operations on the array. In each operation, you can choose any two elements of the array and increase both elements by `1`. Return _the maximum element in the array after performing_ `k` _operations_.","solution":"def max_element_after_operations(arr, k): Returns the maximum element in the array after performing k operations. Each operation allows you to choose any two elements and increase both by 1. if not arr: return 0 # Calculate the result based on the initial max element and the number of operations max_element = max(arr) + k return max_element"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. Your task is to find the **maximum product** of any subarray of `arr`. A subarray is a contiguous part of an array, and the product of a subarray is the product of all its elements. Return the maximum product that can be obtained from any subarray of `arr`. If the input array is empty, return 0.","solution":"def max_product_subarray(arr): if not arr: # If the input array is empty return 0 max_product = min_product = global_max = arr[0] for num in arr[1:]: if num < 0: # Swap max and min if the current number is negative max_product, min_product = min_product, max_product max_product = max(num, num * max_product) min_product = min(num, num * min_product) global_max = max(global_max, max_product) return global_max"},{"question":"You are given an assignment to schedule several teams to work on different projects over a certain period. Each team has a specific availability period during which they can work on projects, and each project requires a specific continuous time duration to be completed. You need to assign each project to exactly one team such that no team\'s availability period overlaps and every project is completed within the availability period of a team. You are given a 2D list `teams` where `teams[i]` contains two integers `[start_i, end_i]` representing the start and end times of the `i-th` team\'s availability period. You are also given a list `projects` where `projects[j]` contains a single integer `duration_j` that represents the required time duration to complete the `j-th` project. Return _the maximum number of projects that can be completed given the availability periods of the teams_.","solution":"def max_projects(teams, projects): Returns the maximum number of projects that can be completed given the availability periods of the teams. Parameters: teams (list of lists): Each sublist [start, end] represents availability of a team. projects (list of ints): Each element represents the duration of a project. Returns: int: The maximum number of projects that can be completed. # Sort teams by their availability\'s end time teams.sort(key=lambda x: x[1]) # Sort projects by their duration projects.sort() available_teams = 0 project_index = 0 n_teams = len(teams) n_projects = len(projects) while available_teams < n_teams and project_index < n_projects: team_availability = teams[available_teams] project_duration = projects[project_index] # Check if the project can be completed within the team\'s availability period if team_availability[1] - team_availability[0] >= project_duration: # Move to the next project project_index += 1 # Move to the next team available_teams += 1 return project_index"},{"question":"Given an array of non-negative integers representing the heights of buildings where the width of each building is `1`, compute how much water it can trap after raining. Each building\'s width is `1`. The input is an array `height` where `height[i]` represents the height of the `i-th` building. The task is to determine the total amount of rainwater trapped.","solution":"def trap(height): This function computes the total amount of rainwater trapped given the heights of a series of buildings. :param height: List[int] - A list of non-negative integers representing the heights of the buildings. :return: int - The total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total amount of rainwater trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are developing a software for a bank that assists in managing customer accounts. Implement the `Bank` class which supports the following operations: * `Bank(vector<long long>& balance)` Initializes the `Bank` object with the vector `balance` representing the initial amount of money in each account. The length of the vector is the number of accounts. * `bool transfer(int account1, int account2, long long money)` Transfers `money` units from the account `account1` to the account `account2`. Return `true` if the transfer was successful, otherwise return `false`. * `bool deposit(int account, long long money)` Deposits `money` units to `account`. Return `true` if the deposit was successful. * `bool withdraw(int account, long long money)` Withdraws `money` units from `account`. Return `true` if the withdrawal was successful. # Constraints - There are a total of `n` accounts in the bank. - 1 ≤ `account`, `account1`, `account2` ≤ n - 0 ≤ `money` ≤ 10^12 - The initial balance of each account is between 0 and 10^12 inclusive.","solution":"class Bank: def __init__(self, balance): Initializes the Bank object with the vector balance representing the initial amount of money in each account. balance: List of long long integers. self.balance = balance def transfer(self, account1, account2, money): Transfers money units from account1 to account2. account1: integer (1-indexed) account2: integer (1-indexed) money: long long integer Returns True if the transfer was successful, otherwise returns False. if not (1 <= account1 <= len(self.balance) and 1 <= account2 <= len(self.balance)): return False # Account numbers are out of bounds. if self.balance[account1 - 1] < money: return False # Not enough balance to transfer. self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account, money): Deposits money units to account. account: integer (1-indexed) money: long long integer Returns True if the deposit was successful. if not (1 <= account <= len(self.balance)): return False # Account number is out of bounds. self.balance[account - 1] += money return True def withdraw(self, account, money): Withdraws money units from account. account: integer (1-indexed) money: long long integer Returns True if the withdrawal was successful, otherwise returns False. if not (1 <= account <= len(self.balance)): return False # Account number is out of bounds. if self.balance[account - 1] < money: return False # Not enough balance to withdraw. self.balance[account - 1] -= money return True"},{"question":"You are given a 2D integer array `grid` representing a grid of 1s (land) and 0s (water). An island is a group of 1s connected vertically or horizontally (not diagonally). The perimeter of an island is the total length of the island\'s boundary formed by water or the edge of the grid. Write a function that returns the perimeter of the island in the grid. Note: There is exactly one island in the grid.","solution":"def island_perimeter(grid): Returns the perimeter of the island represented in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"You are given a **0-indexed** array of integers `heights` representing the heights of buildings in a row. A building is considered to have a \\"better view\\" if it is taller than all the buildings to its right. Return _an array of integers representing the indices of the buildings with a \\"better view\\" in the same order they appear in the original array_.","solution":"def better_view_buildings(heights): Returns indices of buildings with a \\"better view\\". A building is said to have a better view if it is taller than all the buildings to its right. n = len(heights) max_height = float(\'-inf\') result = [] for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"You are given a list of strings `words` and a string `target`. Find and return _the minimum number of strings from `words` required to form the string `target` such that each character in `target` is used exactly once_. If it is not possible to form the string `target` using the given `words`, return `-1`. Each string in `words` can be used any number of times.","solution":"from collections import Counter from typing import List def min_words_to_form_target(words: List[str], target: str) -> int: target_count = Counter(target) words_counts = [Counter(word) for word in words] words_used = 0 used_idx = set() while target_count: best_word = None best_idx = None max_match = 0 for i, word_count in enumerate(words_counts): if i in used_idx: continue match = sum(min(word_count[c], target_count[c]) for c in word_count) if match > max_match: max_match = match best_word = word_count best_idx = i if max_match == 0: return -1 for c in best_word: if c in target_count: used = min(best_word[c], target_count[c]) target_count[c] -= used if target_count[c] == 0: del target_count[c] words_used += 1 used_idx.add(best_idx) return words_used"},{"question":"Write a function that takes a string `s` and an array of strings `words`, and returns the number of times each word in `words` appears as a subsequence in `s`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Implement the function `numMatchingSubseq(String s, String[] words)`.","solution":"def numMatchingSubseq(s, words): def is_subseq(word, string): it = iter(string) return all(char in it for char in word) result = {} for word in words: result[word] = is_subseq(word, s) return result"},{"question":"You are given a string `dominoes` representing a row of dominoes, where each domino is either \'L\' (falls to the left), \'R\' (falls to the right), or \'.\' (remains upright). Each time a domino falls to the left or right, it will push the closest upright domino in the same direction until it either encounters another falling domino or reaches the end. Return the final state of the dominoes after all falling movements have been resolved.","solution":"def push_dominoes(dominoes): Given a string representing a row of dominoes, return the final state after all the dominoes have fallen. symbols = list(dominoes) length = len(symbols) forces = [0] * length # Left to right pass force = 0 for i in range(length): if symbols[i] == \'R\': force = length elif symbols[i] == \'L\': force = 0 else: force = max(force - 1, 0) forces[i] += force # Right to left pass force = 0 for i in range(length - 1, -1, -1): if symbols[i] == \'L\': force = length elif symbols[i] == \'R\': force = 0 else: force = max(force - 1, 0) forces[i] -= force # Calculate final state result = [] for f in forces: if f == 0: result.append(\'.\') elif f > 0: result.append(\'R\') else: result.append(\'L\') return \\"\\".join(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. A certain rule dictates that consecutive duplicates are removed from the string recursively until no consecutive duplicates are left. For instance, given the string `\\"abbaca\\"`, the process would be as follows: - Remove consecutive duplicates: `\\"abbaca\\"` → `\\"aaca\\"` - Remove consecutive duplicates: `\\"aaca\\"` → `\\"ca\\"` Return the resultant string after all consecutive duplicate removals have been completed.","solution":"def remove_consecutive_duplicates(s): Recursively removes consecutive duplicates from the string s until no consecutive duplicates are left. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"Given an integer array `nums`, return true if there exists a **duplicate** within `k` indices of each other, otherwise return false. A duplicate within `k` indices means `nums[i] == nums[j]` and `abs(i - j) <= k` for some indices `i` and `j`.","solution":"def contains_nearby_duplicate(nums, k): Returns true if there exists a duplicate within k indices of each other. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"Given a list of `n` strings, write a function that groups the strings into anagrams. Each group should be a list of anagrams. Return the list of groups, such that each group itself is a list of strings that are anagrams of each other. The order of the groups and the order within each group does not matter. An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.","solution":"from collections import defaultdict def group_anagrams(strs): Groups the input list of strings into anagrams. Args: strs (list of str): List of strings to be grouped into anagrams. Returns: List of lists, where each sublist contains strings that are anagrams of each other. anagram_map = defaultdict(list) for s in strs: # Sort the string to use as a key for the anagram group sorted_str = \'\'.join(sorted(s)) anagram_map[sorted_str].append(s) return list(anagram_map.values())"},{"question":"You are given an array of integers `arr`, where each element occurs three times except for one unique element which occurs exactly once. Find the element that occurs only once in linear time complexity and without using extra memory.","solution":"def single_number(arr): Find the element that occurs exactly once in an array where all other elements occur three times. :param arr: List[int] - List of integers where every element appears three times except one that appears once. :return: int - The element that appears exactly once. ones, twos = 0, 0 for num in arr: # Update ones and twos accordingly ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given an integer array `cards` where each `cards[i]` represents the value of a card. You need to pick exactly three cards from this array such that the sum of their values is **maximum**, but their values should be **pairwise distinct** (no two cards can have the same value). If it is not possible to pick three distinct cards, return -1. Return the maximum sum of values of the chosen cards if possible, otherwise return -1.","solution":"def max_sum_distinct_triplet(cards): Returns the maximum sum of three distinct cards values, or -1 if not possible. unique_cards = list(set(cards)) # Remove duplicates if len(unique_cards) < 3: return -1 unique_cards.sort(reverse=True) return unique_cards[0] + unique_cards[1] + unique_cards[2]"},{"question":"You are given a list of meetings represented by arrays where each array contains the start and end times of a meeting. [[start1, end1], [start2, end2], ...]. Write a function to determine if a person could attend all meetings. Return _True_ if the person can attend all meetings, otherwise return _False_.","solution":"def can_attend_all_meetings(meetings): Returns True if a person can attend all given meetings, otherwise False. :param meetings: List of meetings represented by lists of start and end times. :type meetings: List[List[int]] :return: Boolean value indicating if a person can attend all meetings :rtype: bool # Sort meetings by start time sorted_meetings = sorted(meetings, key=lambda x: x[0]) for i in range(1, len(sorted_meetings)): # If the current meeting starts before the previous one ends, return False if sorted_meetings[i][0] < sorted_meetings[i-1][1]: return False return True"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to perform a series of operations on the string until its length is less than or equal to `k`. In one operation, you can delete any character from the string. Your task is to find the minimum number of operations required to reduce the length of the string to `k` or less. Return the minimum number of operations needed.","solution":"def min_operations_to_reduce_length(s, k): Returns the minimum number of operations to reduce the length of string s to k or less. Parameters: s (str): The original string. k (int): The target maximum length of the string. Returns: int: The minimum number of operations required. current_length = len(s) if current_length <= k: return 0 return current_length - k"},{"question":"Imagine you have a function `watch(duration, timeSlots)` where `duration` is an integer representing the total duration you want to fill by choosing some, none, or all of the integers in the `timeSlots` list. The function should return a boolean value indicating whether it is possible to precisely sum up to `duration` using some, none, or all values from `timeSlots`.","solution":"def watch(duration, timeSlots): Determines if it is possible to sum up exactly to the given duration using any combination of the timeSlots values. n = len(timeSlots) # Create a DP array with False values dp = [False] * (duration + 1) dp[0] = True # Base case: sum of 0 is always possible # For each slot, update the DP table for time in timeSlots: for j in range(duration, time - 1, -1): if dp[j - time]: dp[j] = True return dp[duration]"},{"question":"You are given an array of integers `heights` representing the heights of a set of boxes. The width of each box is `1`. You need to arrange these boxes to form a container that holds the maximum volume of water. The container cannot be tilted, and water is confined between the boxes, forming the container with the shortest box on either side. Return _the maximum amount of water that can be stored between any two boxes in the array_.","solution":"def max_water_capacity(heights): Returns the maximum volume of water that can be stored between any two boxes represented by their heights. max_volume = 0 left = 0 right = len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_volume = height * width max_volume = max(max_volume, current_volume) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_volume"},{"question":"Given an array of integers `arr`, a subarray of `arr` is called a **mountain** if the subarray has at least three elements and there exists some index `i` with `0 < i < arr.length - 1` such that: * `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` * `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` Return the _length_ of the longest mountain subarray. If there is no mountain subarray, return `0`. Your algorithm should run in `O(n)` time and use only constant extra space.","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray. n = len(arr) if n < 3: return 0 max_length = 0 i = 1 while i < n - 1: if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left] > arr[left - 1]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 max_length = max(max_length, right - left + 1) i = right else: i += 1 return max_length"},{"question":"A company has a list of `n` employees, each with a unique ID. Every employee has a list of subordinates\' IDs representing the employees that directly report to them. Additionally, each employee has an importance value, which is a positive integer. Given the company structure and an employee ID, write a function to recursively calculate the total importance value for that employee and all of their subordinates. The input will be a list of employees\' data represented by the class `Employee` and an integer `id` representing the employee ID for which you need to calculate the total importance. Each `Employee` class will have the following fields: * `id`: The unique ID of the employee. * `importance`: The importance value of the employee. * `subordinates`: A list of IDs that directly report to this employee.","solution":"class Employee: def __init__(self, id: int, importance: int, subordinates: list): self.id = id self.importance = importance self.subordinates = subordinates def get_importance(employees, id): emp_map = {emp.id: emp for emp in employees} def dfs(emp_id): emp = emp_map[emp_id] total_importance = emp.importance for sub_id in emp.subordinates: total_importance += dfs(sub_id) return total_importance return dfs(id)"},{"question":"You are given a list of `logs` where each log is a string formatted as `\\"user_id:action_type:timestamp\\"`. Each `user_id` is a unique identifier, `action_type` can be either \\"login\\" or \\"logout\\", and `timestamp` is an integer representing the time of the action in seconds. Your task is to identify all users who were logged in at the exact same time as their most recent `login` action and did not log out afterwards. Return a list of `user_id` for these users in increasing order.","solution":"def find_logged_in_users(logs): Identifies all users who were logged in at the exact same time as their most recent `login` action and did not log out afterwards. Args: logs: A list of strings where each string is formatted as \\"user_id:action_type:timestamp\\" Returns: A list of user_ids of users who were logged in at the same time as their most recent login and did not log out afterwards, sorted in increasing order. from collections import defaultdict last_action = defaultdict(lambda: {\\"timestamp\\": None, \\"action\\": None}) for log in logs: user_id, action_type, timestamp = log.split(\\":\\") timestamp = int(timestamp) last_action[user_id] = {\\"timestamp\\": timestamp, \\"action\\": action_type} result = [] for user_id, action in last_action.items(): if action[\\"action\\"] == \\"login\\": result.append(user_id) return sorted(result)"},{"question":"Given an array of integers `arr`, you need to calculate the minimum number of moves required to make all elements in `arr` equal, where a move is incrementing `n - 1` elements by 1. Return the minimum number of moves required.","solution":"def min_moves(arr): Calculate the minimum number of moves required to make all elements in arr equal, where a move is incrementing n - 1 elements by 1. :param arr: List[int] - List of integers :return: int - Minimum number of moves required min_element = min(arr) total_moves = sum(arr) - len(arr) * min_element return total_moves"},{"question":"Given a matrix `grid` with `m` rows and `n` columns where each cell contains an integer, write a function to return the count of all distinct paths from the top-left cell to the bottom-right cell of the matrix. You can only move either down or right at any point in time. Note that all the paths must be unique and no cell can be revisited on any path.","solution":"def count_paths(grid): Returns the count of all distinct paths from the top-left cell to the bottom-right cell of the matrix. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if i == 0 and j == 0: dp[i][j] = 1 else: from_top = dp[i-1][j] if i > 0 else 0 from_left = dp[i][j-1] if j > 0 else 0 dp[i][j] = from_top + from_left return dp[m-1][n-1]"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. An element `nums[i]` is considered a **local minimum** if it is smaller than its neighbors, meaning `nums[i] < nums[i - 1]` and `nums[i] < nums[i + 1]` for `1 <= i < n - 1`. The first element is considered a local minimum if it’s smaller than the second element, and the last element is considered a local minimum if it’s smaller than the second last element. Return _the indices of all local minimums in the array_.","solution":"def find_local_minima(nums): Returns the indices of all local minimums in the array. :param nums: List of integers :return: List of indices of local minimums if not nums: return [] n = len(nums) local_minima_indices = [] # Edge case for the first element if n == 1 or nums[0] < nums[1]: local_minima_indices.append(0) # Check for local minima in the middle of the array for i in range(1, n - 1): if nums[i] < nums[i - 1] and nums[i] < nums[i + 1]: local_minima_indices.append(i) # Edge case for the last element if n > 1 and nums[-1] < nums[-2]: local_minima_indices.append(n - 1) return local_minima_indices"},{"question":"You are given a list of non-negative integers `weights` representing the weight of items, and an integer `capacity` representing the maximum weight that a container can hold. You need to select a subset of the items such that the total weight is as close as possible to the `capacity` without exceeding it. Return the total weight of the selected subset.","solution":"def knapsack(weights, capacity): Returns the maximum total weight that is as close as possible to the capacity without exceeding it. Args: weights (list of int): List of non-negative integers representing the weights of items. capacity (int): Maximum weight that the container can hold. Returns: int: Maximum total weight of the selected subset of items. n = len(weights) dp = [0] * (capacity + 1) for w in weights: for c in range(capacity, w - 1, -1): dp[c] = max(dp[c], dp[c - w] + w) return dp[capacity]"},{"question":"Given a rectangular `matrix` of integers, you must find a submatrix that has the largest sum among all possible submatrices. A **submatrix** is a contiguous block of cells within the matrix. Return _the sum of the elements in this largest submatrix_.","solution":"def max_sum_submatrix(matrix): This function finds the sum of the submatrix that has the largest sum within the given matrix. if not matrix or not matrix[0]: return 0 rows = len(matrix) columns = len(matrix[0]) max_sum = float(\'-inf\') # We use Kadane\'s algorithm in 2D for left in range(columns): temp = [0] * rows for right in range(left, columns): for i in range(rows): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane_algorithm(temp)) return max_sum def kadane_algorithm(arr): Helper function to implement Kadane\'s algorithm to find the largest sum of a contiguous subarray. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"Given an array of integers `arr`. A subarray is defined as a non-empty contiguous sequence of elements in the array. Return _the length of the longest subarray_ where the difference between the maximum and minimum elements is less than or equal to one.","solution":"def longest_subarray_with_diff_one(arr): This function returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to one. max_length = 1 current_start = 0 while current_start < len(arr): current_max = current_min = arr[current_start] for j in range(current_start, len(arr)): current_max = max(current_max, arr[j]) current_min = min(current_min, arr[j]) if current_max - current_min <= 1: max_length = max(max_length, j - current_start + 1) else: break current_start += 1 return max_length"},{"question":"Given an `m x n` integer matrix `grid`, return the length of the shortest path from the top-left cell to the bottom-right cell such that: 1. You can move up, down, left, or right from a cell. 2. You can only move to a cell if it contains a `1`. If there is no such path, return `-1`. Note: The cells in the grid may contain either a `0` or a `1`, where `1` represents that the cell is traversable and `0` represents that the cell is blocked.","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell in the given m x n integer matrix grid, where you can move in four directions and only through cells containing \'1\'. If there is no such path, returns -1. if not grid or not grid[0] or grid[0][0] != 1 or grid[-1][-1] != 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) distance = 1 # Starting from the top-left cell while queue: for _ in range(len(queue)): r, c = queue.popleft() if r == rows - 1 and c == cols - 1: return distance for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: queue.append((nr, nc)) grid[nr][nc] = -1 # Mark as visited distance += 1 return -1"},{"question":"You are given a string `s` and two integers `leftShifts` and `rightShifts`. The string `s` will be shifted to the left `leftShifts` times and to the right `rightShifts` times. Note that if a character is shifted past the start (or end) of the string, it wraps around to the end (or start) of the string. Implement a function that returns the final string after all the shifts have been performed.","solution":"def shift_string(s, leftShifts, rightShifts): This function takes a string `s` and two integers `leftShifts` and `rightShifts`. It returns the string after performing `leftShifts` left shifts and `rightShifts` right shifts. net_shifts = (rightShifts - leftShifts) % len(s) return s[-net_shifts:] + s[:-net_shifts]"},{"question":"You are given a positive integer `n` representing the number of nodes of an **undirected connected graph**. The nodes are numbered from `0` to `n - 1` (**inclusive**). You are also given a 2D integer array `edges`, where `edges[i] = [u, v]` denotes that there is an **undirected** edge between nodes `u` and `v` in the graph. Write a function that returns a boolean indicating whether the given graph is a **tree**.","solution":"def is_tree(n, edges): Determines if an undirected graph is a tree. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of edges in the graph represented as pairs of nodes [u, v]. Returns: bool: True if the graph is a tree, False otherwise. if len(edges) != n - 1: # For a graph to be a tree, it must have exactly n-1 edges return False from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() # BFS to check if the graph is connected queue = deque([0]) visited.add(0) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # After BFS, if all nodes are visited, it means the graph is connected return len(visited) == n"},{"question":"Given an initial list of integers, `nums`, and a list `updates` where each element is a tuple `(index, value)`, apply each update to the `nums` list such that for each tuple `(index, value)`, `nums[index]` is incremented by `value`. Return the modified list after all updates have been applied.","solution":"def apply_updates(nums, updates): Applies a series of updates to the nums list. Each update is a tuple (index, value), indicating that nums[index] should be incremented by value. :param nums: List[int] - The initial list of integers :param updates: List[Tuple[int, int]] - The list of updates to apply :return: List[int] - The modified list after applying all updates for index, value in updates: nums[index] += value return nums"},{"question":"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character. This problem can be approached using the concept of **dynamic programming** to find the **edit distance** between the two words.","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. Operations permitted: insert a character, delete a character, replace a character. m, n = len(word1), len(word2) # Create a DP table to store the minimum edit distance dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the minimum edit distance for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped at each elevation map\'s bar. Each bar\'s width is 1 unit. Compute how much water can be trapped after raining. You need to write a function that takes an array of integers representing the elevation map and returns an integer representing the total amount of trapped rainwater.","solution":"def trap_rain_water(height): Calculate the total amount of trapped rainwater. Parameters: height (list): A list of non-negative integers representing the elevation map. Returns: int: Total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total trapped rainwater trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a string `s` and an array of words `words`, return _the length of the longest word in_ `words` _that can be constructed from the characters in_ `s`. Each character in `s` can only be used once per word. If no word can be constructed, return 0.","solution":"def can_construct_from_chars(word, char_count): Helper function to check if a word can be constructed from the given characters. word_count = {} for char in word: if char not in word_count: word_count[char] = 0 word_count[char] += 1 for char, count in word_count.items(): if char_count.get(char, 0) < count: return False return True def longest_word_length(s, words): Returns the length of the longest word in `words` that can be constructed from characters in `s`. char_count = {} for char in s: if char not in char_count: char_count[char] = 0 char_count[char] += 1 max_length = 0 for word in words: if can_construct_from_chars(word, char_count): max_length = max(max_length, len(word)) return max_length"},{"question":"You are given an array of integers `arr` where the elements are sorted in ascending order but have been rotated at some pivot point unknown to you. (e.g., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`). Find the index of a given target value. If the target is not found in the array, return `-1`. You must write an algorithm with O(log n) runtime complexity.","solution":"def search_rotated_array(arr, target): Searches the given rotated sorted array for the target value and returns its index. If the target is not found, it returns -1. The runtime complexity of the algorithm is O(log n). if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine if the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. Your task is to determine the minimum number of operations required to convert `s` into `t` where each operation is either inserting a character, deleting a character, or replacing a character in `s`. This problem is also known as computing the edit distance. Return _the minimum number of operations required to transform `s` into `t`._","solution":"def min_edit_distance(s, t): Returns the minimum number of operations required to convert string s into string t. m = len(s) n = len(t) # Create a (m+1) x (n+1) matrix dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute edit distance for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Replacement return dp[m][n]"},{"question":"Given an array of integers `nums`, you are tasked with implementing a data structure that supports the following operations: 1. Update the value of an element in `nums` at a specific index. 2. Retrieve the sum of elements between two given indices in `nums` (inclusive). Implement the `NumArray` class: * `NumArray(int[] nums)` Initializes the object with the integer array `nums`. * `void update(int index, int val)` Updates the value of `nums[index]` to `val`. * `int sumRange(int left, int right)` Returns the sum of elements between indices `left` and `right` (inclusive) in the array `nums`.","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = self.nums[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, val): # Set value at position p pos = index + self.n self.tree[pos] = val # Move upward and update parents while pos > 1: left = pos right = pos if pos % 2 == 0: right = pos + 1 else: left = pos - 1 # Parent is updated after child is updated self.tree[pos // 2] = self.tree[left] + self.tree[right] pos //= 2 def sumRange(self, left, right): # Get the sum of elements from left to right l, r = left + self.n, right + self.n sum = 0 while l <= r: if l % 2 == 1: sum += self.tree[l] l += 1 if r % 2 == 0: sum += self.tree[r] r -= 1 l //= 2 r //= 2 return sum"},{"question":"You have a collection of water bottles, each with a different capacity. You are given an integer array `bottles` where each element represents the capacity of a water bottle, and an integer `target_volume` representing the amount of water you want to collect. Return `true` if you can select a subset of these bottles such that their total capacity equals `target_volume`, otherwise return `false`. Note that each bottle may only be used once.","solution":"def can_collect_target_volume(bottles, target_volume): Determines if a subset of bottles can sum up to the target volume. Parameters: bottles (list of int): The capacities of the water bottles. target_volume (int): The target volume of water to collect. Returns: bool: True if a subset of bottles can sum to the target volume, else False. n = len(bottles) dp = [[False] * (target_volume + 1) for _ in range(n + 1)] # There is always a subset with sum 0, the empty subset dp[0][0] = True for i in range(1, n + 1): for j in range(target_volume + 1): if j < bottles[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - bottles[i - 1]] return dp[n][target_volume]"},{"question":"Write a function `nextGreaterElement(nums1, nums2)` where `nums1` and `nums2` are arrays without duplicates, and `nums1` is a subset of `nums2`. The function finds all the next greater numbers for `nums1`\'s elements in the corresponding places of `nums2`. The next greater number of an element x in `nums1` is the first greater number to its right in `nums2`. If it does not exist, output -1 for this element. The function should return an array of integers representing the results for each element in `nums1`. Example Input: ``` nums1 = [4,1,2] nums2 = [1,3,4,2] ``` Example Output: ``` [-1,3,-1] ```","solution":"def nextGreaterElement(nums1, nums2): Finds the next greater element for each element of nums1 in nums2. next_greater_map = {} stack = [] for num in nums2: while stack and stack[-1] < num: next_greater_map[stack.pop()] = num stack.append(num) return [next_greater_map.get(num, -1) for num in nums1]"},{"question":"You are given a string `str` containing only the characters `(` and `)` representing a sequence of parentheses. Implement a function to determine if the given string is balanced. A string is balanced if: * Every opening parenthesis `(` has a corresponding closing parenthesis `)`. * Every closing parenthesis `)` has a corresponding opening parenthesis `(`. * The parentheses in the string must be in the correct order, meaning that no closing parenthesis appears before its matching opening parenthesis. Return `true` if the string is balanced, and `false` otherwise.","solution":"def is_balanced(s: str) -> bool: Returns True if the given string of parentheses is balanced, otherwise False. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"Given an integer array `arr`, return the length of the shortest, non-empty, contiguous subarray of `arr`, such that the greatest common divisor (GCD) of every element in the subarray is greater than `1`. If no such subarray exists, return `-1`.","solution":"import math def find_shortest_subarray_with_gcd_greater_than_one(arr): Returns the length of the shortest non-empty contiguous subarray such that the GCD of every element in the subarray is greater than 1. If no such subarray exists, returns -1. def gcd(a, b): Returns the GCD of two numbers. while b: a, b = b, a % b return a n = len(arr) shortest_length = float(\'inf\') found = False for i in range(n): current_gcd = arr[i] if current_gcd == 1: continue for j in range(i, n): current_gcd = gcd(current_gcd, arr[j]) if current_gcd == 1: break if current_gcd > 1: found = True shortest_length = min(shortest_length, j - i + 1) return shortest_length if found else -1"},{"question":"You are given a **0-indexed** array `heights` containing integers, representing the heights of buildings in a row. You need to find the largest rectangle that can be formed by stacking these buildings next to each other. Return the area of the largest rectangle that can be formed by these buildings. The width of each building is 1. --- This new question maintains the format, style, and complexity of the provided sample questions, covering common algorithm and data structure concepts such as array manipulation and calculating the maximum area using stack-based approaches.","solution":"def largest_rectangle_area(heights): Calculate the largest rectangle area in histogram. Args: heights (List[int]): List of heights of the buildings. Returns: int: The area of the largest rectangle that can be formed. max_area = 0 stack = [] for i in range(len(heights) + 1): while stack and (i == len(heights) or heights[i] < heights[stack[-1]]): h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"Given an array of `n` integers `nums`, find and return an array answer of length `n`, where `answer[i]` is the **product of all the elements of `nums` except `nums[i]`**. The solution should be designed to work in **O(n)** time and without using division.","solution":"def product_except_self(nums): Given an array of `n` integers `nums`, returns an array `answer` where `answer[i]` is the product of all the elements of `nums` except `nums[i]`. n = len(nums) answer = [1] * n # Calculate products of elements to the left of each element left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Calculate products of elements to the right of each element and combine with left products right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"You are given a network of `n` computers represented by a 2D integer array `edges`, where `edges[i] = [u, v]` represents a connection between computers `u` and `v`. There is also an integer `k`, representing the number of computers that can fail without disrupting the network. A network is considered disrupted if there is no path between any two computers. Your task is to determine if the network is k-fault tolerant. A network is k-fault tolerant if it remains connected when any `k` computers fail. Write a function `boolean isKFaultTolerant(int n, int[][] edges, int k)` that returns `true` if the network is k-fault tolerant, and `false` otherwise.","solution":"def is_k_fault_tolerant(n, edges, k): from itertools import combinations from collections import defaultdict def is_connected(graph, num_vertices, skip_nodes=set()): visited = set() def dfs(node): if node in visited: return visited.add(node) for neighbor in graph[node]: if neighbor not in skip_nodes: dfs(neighbor) # Start DFS traversal from any node that is not among skip_nodes for start_node in range(num_vertices): if start_node not in skip_nodes: dfs(start_node) break # Check if all nodes are visited, excluding skip_nodes for node in range(num_vertices): if node not in skip_nodes and node not in visited: return False return True # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Check all combinations of k nodes for nodes_to_fail in combinations(range(n), k): if not is_connected(graph, n, set(nodes_to_fail)): return False return True"},{"question":"You are given a list of `n` integers, `nums`. Your task is to check whether you can rearrange the elements of `nums` such that `nums` forms an **arithmetic progression**. An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. Return `true` if it is possible to rearrange `nums` into an arithmetic progression, otherwise return `false`.","solution":"def can_make_arithmetic_progression(nums): Checks if the given list can be rearranged to form an arithmetic progression. :param nums: List of integers :return: Boolean value indicating if the list can form an arithmetic progression if len(nums) < 2: return True nums.sort() diff = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != diff: return False return True"},{"question":"There is an inventory management system for a warehouse. The warehouse keeps track of items using a list of `n` products, each product being identified by a unique integer ID from `0` to `n-1`. Each product has a priority value that determines its importance. You need to restock the inventory and you have to select the products based on their priority values. However, due to space constraints, you can only select a contiguous subarray of products for restocking. Given a **0-indexed** integer array `priority` where `priority[i]` denotes the priority of the `i-th` product, return _the sum of priorities of the **best** contiguous subarray that you can select, where the **best** subarray has the highest sum of priorities._ If there are multiple subarrays with the same highest sum, return any one of them.","solution":"def max_subarray_sum(priority): Returns the sum of the best contiguous subarray with the highest sum of priorities. max_current = max_global = priority[0] for i in range(1, len(priority)): max_current = max(priority[i], max_current + priority[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an array of integers representing the heights of students in a class. Each student can swap places with any other student. Determine the minimum number of swaps required so that the students are arranged in non-decreasing order of height. Write the function `int minSwapsToSort(int[] heights)`.","solution":"def minSwapsToSort(heights): Returns the minimum number of swaps required to sort the heights array in non-decreasing order. # Enumerate the height array with positions enumerated_heights = list(enumerate(heights)) # Sort the enumerated heights based on the values of heights enumerated_heights.sort(key=lambda x: x[1]) # Create a visited list to keep track of visited elements visited = [False] * len(heights) swaps = 0 for i in range(len(heights)): # if the element is already visited or already in the correct place if visited[i] or enumerated_heights[i][0] == i: continue # Visit all elements in the cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = enumerated_heights[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"A string is called a permutation of a palindrome if it can be rearranged to form a palindrome. Given a string `s`, return `true` if the string is a permutation of a palindrome, and `false` otherwise. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The input string will only consist of lowercase letters.","solution":"def is_permutation_of_palindrome(s): Returns True if the string s is a permutation of a palindrome, and False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # There can be at most one character with an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 == 1) return odd_count <= 1"},{"question":"You are given a list of words and a string `pattern`. Find all words in the list that match the given pattern. A word matches the pattern if there exists a permutation of letters such that the word can be transformed into the pattern after replacing each letter with another letter. Return the list of words that match the pattern. The words and the pattern consist of lowercase English letters. Example: Input: words = [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], pattern = \\"abb\\" Output: [\\"mee\\",\\"aqq\\"] Explanation: \\"mee\\" matches the pattern because \\"mee\\" can be transformed to \\"abb\\" by replacing \'m\' with \'a\' and \'e\' with \'b\'. Similarly, \\"aqq\\" matches the pattern because \\"aqq\\" can be transformed to \\"abb\\" by replacing \'a\' with \'a\' and \'q\' with \'b\'. \\"abc\\" does not match the pattern because different letters cannot be replaced with the same letter.","solution":"def word_pattern_match(words, pattern): def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in used_chars: return False char_map[p_char] = w_char used_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"Given a list of `n` integers `nums` representing a binary tree\'s inorder traversal, transform this list back into its corresponding binary search tree (BST). Return the root of this BST. The inorder traversal of a BST is a sorted array, so ensure the array `nums` is sorted. Each element in `nums` is distinct.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Transforms a sorted list of integers nums into a height-balanced binary search tree. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"A company is planning to offer an online food ordering service. You have been asked to implement a system that tracks orders and determines the total cost for customers based on their orders. Each customer can order multiple items, and each item has a different price. You are given a 2D list `orders`, where `orders[i] = [customer_id, item_id, price]` represents an order placed by the customer with id `customer_id` for the item with id `item_id` at a price of `price`. Implement a function `total_cost(orders)` that returns a dictionary where the keys are `customer_id` and the values are the total cost of orders for that customer. Example: ``` orders = [ [1, 101, 5], [2, 102, 7], [1, 103, 8], [2, 104, 2] ] Output: { 1: 13, 2: 9 } ```","solution":"def total_cost(orders): Returns a dictionary with customer_id as keys and the total cost of orders as values. Parameters: orders (list): A 2D list where each element is [customer_id, item_id, price]. Returns: dict: Dictionary with customer_id as keys and total cost as values. cost_dict = {} for order in orders: customer_id, item_id, price = order if customer_id in cost_dict: cost_dict[customer_id] += price else: cost_dict[customer_id] = price return cost_dict"},{"question":"You are given a list of non-negative integers `nums` representing the amounts of money of `n` houses lined up in a row. Each house can be robbed, but robbing two adjacent houses will trigger the security system. Your goal is to maximize the amount of money you can rob tonight without alerting the police. Write a function that returns the maximum amount of money you can rob. You may assume all houses form a straight line.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering the security system. The input is a list of non-negative integers representing the amounts of money of houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n # dp[i] represents the maximum amount of money you can rob up to house i dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[n-1]"},{"question":"Implement a system to manage a library\'s book collection and user book rentals. Create a `Library` class with the following methods: * `Library()` Initializes the library system. * `void addBook(int bookId, String title)` Adds a book with the specified `bookId` and `title` to the library\'s collection. * `void removeBook(int bookId)` Removes the book with the specified `bookId` from the library\'s collection. * `void registerUser(int userId, String userName)` Registers a new user with the specified `userId` and `userName`. * `void rentBook(int userId, int bookId)` Allows a user with the specified `userId` to rent the book with the specified `bookId`. A user cannot rent a book that is not in the library\'s collection or if the book is already rented. * `void returnBook(int userId, int bookId)` Allows a user to return a rented book. The user must have rented the specified book. * `List<String> getUserRentedBooks(int userId)` Retrieves a list of titles of books currently rented by the user with the specified `userId`. Ensure that book titles are unique within the library\'s collection and handle cases where operations refer to non-existent users or books gracefully.","solution":"class Library: def __init__(self): self.books = {} # bookId: title self.users = {} # userId: userName self.rented_books = {} # userId: set(bookId) self.book_rent_status = {} # bookId: rented (True/False) def addBook(self, bookId, title): if bookId not in self.books: self.books[bookId] = title self.book_rent_status[bookId] = False def removeBook(self, bookId): if bookId in self.books: if not self.book_rent_status[bookId]: # Ensure that book is not rented before removing. del self.books[bookId] del self.book_rent_status[bookId] def registerUser(self, userId, userName): if userId not in self.users: self.users[userId] = userName self.rented_books[userId] = set() def rentBook(self, userId, bookId): if userId in self.users and bookId in self.books: if not self.book_rent_status[bookId]: self.rented_books[userId].add(bookId) self.book_rent_status[bookId] = True def returnBook(self, userId, bookId): if userId in self.users and bookId in self.books: if bookId in self.rented_books[userId]: self.rented_books[userId].remove(bookId) self.book_rent_status[bookId] = False def getUserRentedBooks(self, userId): if userId in self.users: return [self.books[bookId] for bookId in self.rented_books[userId]] return [] # Example usage: # library = Library() # library.addBook(1, \\"1984\\") # library.addBook(2, \\"To Kill a Mockingbird\\") # library.registerUser(101, \\"Alice\\") # library.rentBook(101, 1) # print(library.getUserRentedBooks(101)) # Output: [\\"1984\\"]"},{"question":"You are given a string `s` consisting of lowercase letters that is repeated infinitely many times. You are also given an integer `x` representing a number of positions. Return the number of occurrences of the character \'a\' in the first `x` positions of the infinitely repeated string.","solution":"def repeated_string_count(s, x): Returns the number of occurrences of the character \'a\' in the first x positions of the infinitely repeated string s. # Calculate the number of complete repetitions of the string in first x characters full_repetitions = x // len(s) # Calculate the number of characters in the partial repetition at the end remainder = x % len(s) # Count \'a\'s in the full string full_count = s.count(\'a\') * full_repetitions # Count \'a\'s in the partial repetition partial_count = s[:remainder].count(\'a\') return full_count + partial_count"},{"question":"You are given a list of non-negative integers representing the amount of money of each house. Robbing two adjacent houses will trigger an alarm system. Return the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given an integer array `tasks` representing the number of tasks to complete and an integer `k` representing the maximum number of tasks that can be assigned to each worker, return the minimum number of workers required to complete all tasks. The tasks must be completed in sequential order, and each worker can take on tasks assigned to them one at a time until they reach the maximum limit `k`.","solution":"def min_workers_required(tasks, k): Returns the minimum number of workers required to complete all tasks given each worker can handle up to k tasks. :param tasks: List[int] - List of integers representing the number of tasks :param k: int - Maximum number of tasks each worker can handle :return: int - Minimum number of workers required total_tasks = sum(tasks) return (total_tasks + k - 1) // k"},{"question":"You are given a list of integers `nums`, where each element in the list represents a point in a 2D coordinate system projected on the x-axis. You are required to pair these points such that the distance between each pair of points is minimized. Return the minimum distance possible after pairing all the points optimally. Note that each point in `nums` can be paired with exactly one other point, and the given list contains an even number of elements.","solution":"def min_pair_distance(nums): Pairs points such that the distance between each pair is minimized. Returns the minimum possible sum of distances between each pair of points. :param nums: List of integers :return: Minimum distance possible after pairing all points optimally # Sort the list to pair consecutive elements nums.sort() # Initialize minimum distance to 0 min_distance = 0 # Pair consecutive elements for i in range(0, len(nums) - 1, 2): min_distance += abs(nums[i] - nums[i + 1]) return min_distance"},{"question":"Given an integer array `nums`, find _the **length** of the longest contiguous subarray such that all its elements are **distinct**._","solution":"def length_of_longest_subarray(nums): Returns the length of the longest contiguous subarray with all distinct elements. if not nums: return 0 n = len(nums) left = 0 max_len = 0 seen = {} for right in range(n): if nums[right] in seen and seen[nums[right]] >= left: left = seen[nums[right]] + 1 seen[nums[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given an array of integers `arr`, you are allowed to pick any single pivot element such that all elements to the left of the pivot are less than or equal to the pivot and all elements to the right of the pivot are greater than or equal to the pivot. Return the number of possible pivot positions in the array where this condition is satisfied.","solution":"def count_possible_pivots(arr): Given an array of integers arr, return the number of possible pivot positions such that all elements to the left of the pivot are less than or equal to the pivot and all elements to the right of the pivot are greater than or equal to the pivot. n = len(arr) if n == 0: return 0 left_max = [float(\'-inf\')] * n right_min = [float(\'inf\')] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_min[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_min[i] = min(right_min[i + 1], arr[i]) count = 0 for i in range(1, n): if left_max[i - 1] <= right_min[i]: count += 1 return count"},{"question":"You are given a non-empty string `s` consisting only of digits. Every digit in `s` corresponds to a place on an old-fashioned rotary dial telephone. Mapping the digits to the characters as follows: 1 maps to `.` (dot), 2 to `a` and `b` and `c`, 3 to `d` and `e` and `f`, 4 to `g` and `h` and `i`, 5 to `j` and `k` and `l`, 6 to `m` and `n` and `o`, 7 to `p` and `q` and `r` and `s`, 8 to `t` and `u` and `v`, and 9 to `w` and `x` and `y` and `z`. Spaces in the input should be mapped to spaces in the output. Write a function to convert each digit in `s` to their corresponding characters, considering 1 corresponds to a dot `.`. Return the resulting string.","solution":"def rotary_dial_conversion(s): Converts a string consisting of digits based on the rotary dial correspondence. dial_dict = { \'1\': \'.\', \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\', \'0\': \' \' } result = [] for char in s: if char in dial_dict: result.append(dial_dict[char]) else: return \\"\\" # Invalid input character return \'\'.join(result)"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of the `i-th` building in a row of buildings. You want to select a contiguous segment of buildings such that the difference between the maximum height and the minimum height in that segment is minimized to a value less than or equal to a given integer `h`. Return _the length of the longest contiguous segment_ that satisfies this condition.","solution":"def longest_contiguous_segment(heights, h): Returns the length of the longest contiguous segment of buildings where the difference between the maximum and minimum height is less than or equal to h. :param heights: List[int] - A list of building heights. :param h: int - The allowed height difference. :return: int - The length of the longest contiguous segment. if not heights: return 0 start = 0 max_length = 0 current_min, current_max = float(\'inf\'), float(\'-inf\') for end in range(len(heights)): current_min = min(current_min, heights[end]) current_max = max(current_max, heights[end]) while current_max - current_min > h: start += 1 current_min = min(heights[start:end+1]) current_max = max(heights[start:end+1]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array `arr` of integers, return the length of the longest arithmetic subarray in `arr`. An arithmetic subarray is a subarray that contains at least two integers and the difference between any two consecutive elements is the same across the subarray.","solution":"def longest_arith_seq_length(arr): Returns the length of the longest arithmetic subarray in arr. if len(arr) < 2: return 0 max_len = 2 curr_len = 2 diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] == diff: curr_len += 1 else: diff = arr[i] - arr[i-1] curr_len = 2 max_len = max(max_len, curr_len) return max_len"},{"question":"You are given an integer array `nums` where each element is **unique**. A valid partition of `nums` is a way to partition the array into two non-empty subsets such that the sum of the elements in each subset is equal. Return `true` if you can partition `nums` into two subsets with equal sum, and `false` otherwise.","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. :param nums: List[int] - an array of unique integers :return: bool - True if it can be partitioned, False otherwise total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) possible_sums = {0} for num in nums: new_sums = set() for s in possible_sums: new_sum = s + num if new_sum == target: return True new_sums.add(new_sum) possible_sums.update(new_sums) return target in possible_sums"},{"question":"Given a string `s` and a list of strings `dictionary`, find the longest string in the `dictionary` that can be formed by deleting some characters of the given string `s` without reordering the remaining characters. If there are multiple answers, return the longest string with the smallest lexicographical order. If there is no possible result, return an empty string. Implement the function `String findLongestWord(String s, List<String> dictionary)`.","solution":"def findLongestWord(s, dictionary): def is_subsequence(x): it = iter(s) return all(c in it for c in x) longest = \\"\\" for word in sorted(dictionary, key=lambda x: (-len(x), x)): if is_subsequence(word): longest = word break return longest"},{"question":"Given an integer array `arr` where each element is within a specific range, you need to find the **length of the longest contiguous subarray** such that all elements within this subarray are **unique**—i.e., no repeated elements within the subarray. Return the length of the longest subarray having all unique elements.","solution":"def longest_unique_subarray_length(arr): Returns the length of the longest contiguous subarray with all unique elements. if not arr: return 0 max_len = 0 start = 0 seen = {} for end in range(len(arr)): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. The function should return _true_ if the trees are the same and _false_ otherwise. Use a recursive approach to solve this problem.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(p, q): Checks if two binary trees are the same. if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"You are given a string `s` and `n` moves. In one move, you can insert any character at any position in the string `s`. After all `n` moves, you should check if the resulting string is a palindrome. Return `true` if it is possible to add exactly `n` characters to `s` to make it a palindrome, and `false` otherwise. Note that inserting exactly `n` characters means you cannot insert more or fewer than `n` characters. Implement a function `canBePalindrome(s: str, n: int) -> bool` that returns whether it is possible to make the string `s` a palindrome with exactly `n` character insertions.","solution":"def canBePalindrome(s: str, n: int) -> bool: Returns whether it is possible to make the string `s` a palindrome with exactly `n` character insertions. # Finding the minimum deletions required to make the string palindrome def min_deletions_to_make_palindrome(s: str) -> int: l = len(s) # Create a table to store results of subproblems dp = [[0 for x in range(l)] for y in range(l)] # Fill the table for cl in range(2, l+1): for i in range(l - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 0 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1 # The minimum number of deletions required to make string palindrome return dp[0][l - 1] required_insertions = min_deletions_to_make_palindrome(s) return required_insertions == n"},{"question":"There is a tree (i.e., a connected, undirected graph with no cycles) with `n` nodes numbered from `0` to `n - 1` and `n - 1` edges. Each node has a value associated with it given in the integer array `values`. Implement a function to compute the sum of node values for every subtree in the tree. To represent the tree structure, you are given a 2D array `edges`, where `edges[i] = [u, v]` indicates that there is an edge between node `u` and node `v` in the tree. Write a function `subtreeSums(int n, int[] values, List<int[]> edges)` which returns an integer array where the `i-th` element is the sum of the values of all nodes in the subtree rooted at node `i`.","solution":"def subtreeSums(n, values, edges): from collections import defaultdict, deque # Create an adjacency list to represent the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Result array to store the subtree sums result = [0] * n # Function to perform DFS and calculate subtree sums def dfs(node, parent): total_sum = values[node] for neighbor in tree[node]: if neighbor != parent: total_sum += dfs(neighbor, node) result[node] = total_sum return total_sum # Calling DFS from node 0 assuming it is the root dfs(0, -1) return result"},{"question":"A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point in time. The robot tries to reach the bottom-right corner of the grid. However, there are obstacles on the grid, which are marked as `1`, and empty spaces are marked as `0`. The robot can only move through empty spaces. Given the `m x n` grid of obstacles, return the number of unique paths that the robot can take to reach the bottom-right corner from the top-left corner. The answer may be large, so return it **modulo** `10^9 + 7`.","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from the top-left to the bottom-right of an m x n grid considering obstacles. MOD = 10**9 + 7 if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD return dp[-1][-1]"},{"question":"You are given an integer array `nums` and an integer `target`. Find the number of all unique quadruplets `(nums[a], nums[b], nums[c], nums[d])` such that `a`, `b`, `c`, and `d` are distinct indices and the sum of the four integers is equal to `target`. Return the number of such unique quadruplets. Note that the same numbers in different positions can form different quadruplets and should be counted accordingly.","solution":"from itertools import combinations def four_sum_count(nums, target): Returns the number of unique quadruplets (nums[a], nums[b], nums[c], nums[d]) such that the sum of the four integers is equal to target. count = 0 nums_len = len(nums) if nums_len < 4: return 0 # Generate all possible quadruplets for quadruplet in combinations(nums, 4): if sum(quadruplet) == target: count += 1 return count"},{"question":"You are given a string `s` representing a code in which letters and digits are randomly mixed. Your task is to reformat the string so that no two identical types of characters are adjacent, i.e., no two letters and no two digits are adjacent. If it is impossible to reformat the string in such a way, return an empty string. Otherwise, return the reformatted string. If there are multiple valid solutions, you may return any of them.","solution":"def reformat_string(s): Reformats the string such that no two identical types of characters are adjacent. Returns an empty string if it\'s not possible to do so. letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" reformatted_list = [] if len(letters) > len(digits): reformatted_list = [None] * (len(letters) + len(digits)) reformatted_list[::2] = letters reformatted_list[1::2] = digits else: reformatted_list = [None] * (len(digits) + len(letters)) reformatted_list[::2] = digits reformatted_list[1::2] = letters return \\"\\".join(reformatted_list)"},{"question":"You are given two strings `word1` and `word2`. Your task is to find the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: - Insert a character - Delete a character - Replace a character Each operation counts as one step. Use dynamic programming to solve the problem and return the minimum number of operations required to convert `word1` to `word2`.","solution":"def min_distance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i # If word2 is empty, delete all characters from word1 for j in range(n + 1): dp[0][j] = j # If word1 is empty, insert all characters of word2 # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: insert = dp[i][j - 1] + 1 delete = dp[i - 1][j] + 1 replace = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert, delete, replace) return dp[m][n]"},{"question":"You are given an `m x n` grid filled with non-negative integers representing the height of each cell. The \\"water volume\\" in a cell is the difference between the highest neighboring cell and the cell itself if the neighboring cell is higher. Write a function that calculates the total amount of trapped water across the entire grid if water can only flow to neighboring cells (horizontally and vertically). Given the height grid as an input, return the total trapped water volume.","solution":"def trap_rain_water(height): import heapq if not height: return 0 m, n = len(height), len(height[0]) if m <= 2 or n <= 2: return 0 visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): for j in range(n): if i in [0, m-1] or j in [0, n-1]: heapq.heappush(heap, (height[i][j], i, j)) visited[i][j] = True total_water = 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while heap: h, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: total_water += max(0, h - height[nx][ny]) heapq.heappush(heap, (max(h, height[nx][ny]), nx, ny)) visited[nx][ny] = True return total_water"},{"question":"A **string s** is said to be **periodic** with period **k** if ```s[i] == s[i + k]``` for all valid ```i```. For example, the string `s = \\"ababab\\"` is periodic with period `k = 2`. Similarly, the string `\\"abcabcabc\\"` is periodic with period `k = 3`. Note that a string may have multiple periods (e.g., `\\"abcabc\\"` has periods `3` and `6`). You are given a string `s` and a list of queries, where each query is represented as an array of two integers `[i, j]`. For each query, return the smallest period `k` of the substring `s[i...j]`. Return an array `ans` where `ans[i]` is the answer to the `i-th` query. If the substring has no periodicity, return the length of the substring.","solution":"def smallest_period(s, queries): Returns the smallest period of the substring for the given range in each query. def find_period(sub): Helper function to find the smallest period of the given substring. n = len(sub) for k in range(1, n + 1): if n % k == 0: if sub[:k] * (n // k) == sub: return k return n result = [] for query in queries: i, j = query substring = s[i:j+1] result.append(find_period(substring)) return result"},{"question":"You are given a string `s` that represents a compressed version of a string where each group of repeated characters is written as the character followed by the count of repetitions. For example, the string \\"aaabbcc\\" would be compressed as \\"a3b2c2\\". Additionally, the counts of repetitions are always single-digit numbers (1-9). Write a function to decompress this string back to its original form. Return the decompressed string.","solution":"def decompress_string(s): Decompress the given compressed string. Args: s (str): A compressed string where characters are followed by their counts. Returns: str: The decompressed string. decompressed = [] i = 0 while i < len(s): char = s[i] count = int(s[i + 1]) decompressed.append(char * count) i += 2 return \'\'.join(decompressed)"},{"question":"You are given the head of a singly linked list where elements are sorted in ascending order, and an integer `k`. Remove the `k-th` node from the end of the list and return its head. Consider using a single pass for achieving this.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns its head. Achieves this in a single pass using the two-pointer technique. dummy = ListNode(0, head) first = dummy second = dummy # Move first pointer to the k+1\'th node from the beginning for _ in range(k + 1): first = first.next # Move both pointers until the first pointer reaches the end while first: first = first.next second = second.next # Second pointer will be pointing to the (k+1)\'th last node, # so we skip the k-th last node second.next = second.next.next return dummy.next"},{"question":"You are given a list of integers `nums` representing the amount of time each user has spent on a website, and an integer `k` representing a specific time threshold. Your task is to return the number of continuous subarrays of `nums` where the sum of the elements in the subarray is exactly `k`. A subarray is defined as a contiguous part of the array.","solution":"def subarray_sum(nums, k): Returns the number of continuous subarrays where the sum of the elements is exactly k. Params: nums: List[int] - List of integers representing the amount of time each user has spent on a website. k: int - The specific time threshold. Returns: int - The number of continuous subarrays with sum exactly k. count = 0 current_sum = 0 sums_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sums_dict: count += sums_dict[current_sum - k] if current_sum in sums_dict: sums_dict[current_sum] += 1 else: sums_dict[current_sum] = 1 return count"},{"question":"Given a binary tree, return a list of the average value of the nodes on each level. The binary tree is represented by a list of integers, where `null` represents a missing node. Each level of the binary tree should be traversed in left-to-right order, and for each level, calculate the average value of the nodes. The average should be represented as a floating-point number. If a level of the tree has no nodes, it should not be included in the output.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def average_of_levels(root: Optional[TreeNode]) -> List[float]: if not root: return [] results = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) average = level_sum / level_length results.append(average) return results"},{"question":"You are given an m x n binary matrix `grid` representing a map of \'1\'s (land) and \'0\'s (water). An island is a group of \'1\'s (land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the smallest (non-zero) number of 1\'s that form an island in the given binary matrix. Return _the size of the smallest island._","solution":"def min_island_size(grid): Returns the size of the smallest island in the given binary matrix grid. :param grid: List[List[int]] - 2D binary matrix representing the map :return: int - size of the smallest island if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark as visited size = 1 size += dfs(i-1, j) size += dfs(i+1, j) size += dfs(i, j-1) size += dfs(i, j+1) return size min_size = float(\'inf\') found_island = False for i in range(m): for j in range(n): if grid[i][j] == 1: found_island = True island_size = dfs(i, j) if island_size > 0: min_size = min(min_size, island_size) return min_size if found_island else 0"},{"question":"You are given a string `s` which contains only lower case letters and an integer `k`. You need to perform a series of operations to determine the lexicographically largest string that can be formed by rotating the string `k` times to the right. On each rotation, you can optionally swap the character in the first position with any other character in the string. You need to find and return the lexicographically largest string possible after performing `k` rotations.","solution":"def lexicographically_largest_string(s, k): Returns the lexicographically largest string that can be formed by rotating and optionally swapping the first character of the string `s` `k` times. :param s: str: A string consisting of only lower case letters. :param k: int: The number of rotations. :return: str: The lexicographically largest string possible after `k` rotations. if k == 1: # For k=1, we need to try all single rotations and return the maximum one max_string = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated > max_string: max_string = rotated return max_string else: # For k>1, we can just sort the string in reverse to get the lexicographically largest string return \'\'.join(sorted(s, reverse=True))"},{"question":"You are given an integer array `nums` and a pivot index `k`. You need to rotate the array to the right by `k` steps, where `k` is non-negative. Write a function that returns the rotated array. For example, given the array `nums = [1,2,3,4,5,6,7]` and `k = 3`, the output should be `[5,6,7,1,2,3,4]`.","solution":"def rotate(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int] - The list of integers to rotate. :param k: int - The number of steps to rotate the list to the right. :return: List[int] - The rotated list. n = len(nums) k = k % n # In case k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Your task is to find the number of unique pairs of integers in the list whose sum is equal to `target`. A pair `(a, b)` is considered unique if `nums[a] + nums[b] == target` and `a != b`. Pairs `(a, b)` and `(b, a)` are considered the same and should only be counted once. Return the number of unique pairs that meet these criteria. Note: The order of the integers in the pairs does not matter.","solution":"def unique_pairs(nums, target): Returns the number of unique pairs of integers in the list whose sum equals to target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: # Create a sorted tuple to avoid duplicate pairs pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"You are given a nested list of integers `matrix` representing a 2D matrix. A row and column in the matrix are sorted in non-decreasing order (i.e., each row is sorted from left to right, and each column is sorted from top to bottom). Given an integer `target`, write a function to determine if `target` is in the matrix. Return `true` if `target` exists in the matrix, and `false` otherwise.","solution":"def search_matrix(matrix, target): Determines if target exists in the matrix. :param matrix: List of List of integers representing a 2D matrix. :param target: Integer to search for in the matrix. :return: True if target exists in the matrix, otherwise False. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a string `s` representing a list of words, each separated by a single space. Find the length of the longest substring that contains unique characters within this string. If there are multiple substrings with the same maximum length, return the one that appears first. Return the length of this substring. Note: The substring should be a part of a single word and not span across multiple words. If there are no possible substrings with unique characters, return 0.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring containing unique characters within the given string `s`. max_length = 0 words = s.split() for word in words: seen = {} start = 0 for end, char in enumerate(word): if char in seen: start = max(start, seen[char] + 1) seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Implement a function to find the longest substring of a given string `s` that contains at most two distinct characters. The function should return this longest substring. If there is a tie, return any of the longest substrings. The input string `s` will have a length in the range `[1, 10^4]`. **Example:** ```python Input: s = \\"eceba\\" Output: \\"ece\\" Input: s = \\"ccaabbb\\" Output: \\"aabbb\\" ```","solution":"def longest_substring_with_two_distinct_chars(s): Returns the longest substring of s that contains at most two distinct characters. if len(s) <= 2: return s start = 0 max_length = 0 max_substring = \\"\\" char_count = {} for end in range(len(s)): char = s[end] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > 2: start_char = s[start] char_count[start_char] -= 1 if char_count[start_char] == 0: del char_count[start_char] start += 1 if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"Given an integer array `arr`, move all the zeros to the end of the array while maintaining the relative order of the non-zero elements. You should modify the array in-place and aim for a solution with linear time complexity. Return the modified array.","solution":"def move_zeros_to_end(arr): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Modifies the array in place. Args: arr (list): The input list of integers. Returns: list: The modified list with all zeros moved to the end. non_zero_index = 0 # Move all non-zero elements to the front for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Fill remaining positions with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"Given an integer array `arr` of length `n` and an integer `target`, return `true` if there exist three distinct indices `i`, `j`, and `k` such that `arr[i] + arr[j] + arr[k] == target`. Otherwise, return `false`.","solution":"def three_sum_target(arr, target): Returns true if there exists three distinct indices i, j, and k in the array such that arr[i] + arr[j] + arr[k] == target, else false. n = len(arr) # Sort the array to use two-pointer technique arr.sort() for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a linked list where each node contains an integer value. Implement a method to reorder the linked list in such a way that the node values alternate between the smallest and largest remaining values. Specifically, after reordering, the first node should be the smallest value, the second node should be the largest value, the third node should be the second smallest value, the fourth node should be the second largest value, and so on. For example, given the linked list `1 -> 5 -> 2 -> 4 -> 3`, the reordered linked list should be `1 -> 5 -> 2 -> 4 -> 3`. Implement the following function: ```python def reorderList(head: ListNode) -> None: # your code here ``` Where `ListNode` is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: if not head: return None # Extract values from the linked list into a list values = [] current = head while current: values.append(current.val) current = current.next # Sort the list of values values.sort() # Interleave the smallest and largest values n = len(values) reorder_values = [] for i in range((n + 1) // 2): reorder_values.append(values[i]) if i != n - i - 1: # Avoid adding the middle element twice in an odd-numbered list reorder_values.append(values[n - i - 1]) # Modify the linked list to have the new ordered values current = head for val in reorder_values: current.val = val current = current.next"},{"question":"Given a matrix `mat` of size `m x n` where each element is a non-negative integer, return _the **total sum** of all elements that are part of any of the diagonals in the matrix_. A diagonal is defined as a sequence of elements that are connected by increasing both the row and column indices by the same amount, starting from any element of the matrix. This includes the main diagonal and all possible shifted diagonals. Your solution should have a time complexity that does not exceed `O(m * n)`.","solution":"def diagonal_sum(mat): Returns the total sum of all elements that are part of any of the diagonals in the matrix. # Use the dimensions of the matrix. m = len(mat) n = len(mat[0]) if m > 0 else 0 total_sum = 0 # Sum elements from diagonals starting from each element in the first row. for col in range(n): row, current_col = 0, col while row < m and current_col < n: total_sum += mat[row][current_col] row += 1 current_col += 1 # Sum elements from diagonals starting from each element in the first column, excluding the first element. for row in range(1, m): current_row, col = row, 0 while current_row < m and col < n: total_sum += mat[current_row][col] current_row += 1 col += 1 return total_sum"},{"question":"You are given a 2D integer grid `grid` where `grid[r][c]` represents the number of coins at the cell located at row `r` and column `c`. You can move only right or down from the top-left corner of the grid to the bottom-right corner. Return the maximum number of coins you can collect by the time you reach the bottom-right corner.","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected moving only right or down from the top-left corner to the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a DP table to store the maximum coins collected at each cell dp = [[0] * cols for _ in range(rows)] # Initialize the DP table with the value at the starting position dp[0][0] = grid[0][0] # Fill the first row (can only move from left to right) for c in range(1, cols): dp[0][c] = dp[0][c-1] + grid[0][c] # Fill the first column (can only move from top to bottom) for r in range(1, rows): dp[r][0] = dp[r-1][0] + grid[r][0] # Fill the rest of the DP table for r in range(1, rows): for c in range(1, cols): dp[r][c] = max(dp[r-1][c], dp[r][c-1]) + grid[r][c] # The bottom-right corner will have the maximum coins collected return dp[rows-1][cols-1]"},{"question":"You are given a list of `n` integers, where each integer represents the number of points scored by a team in a single match. Your task is to return the length of the **longest increasing subsequence** (LIS) of the given list. An increasing subsequence is a sequence of numbers in which each number is greater than the previous one in the sequence. For example, given the list `[10, 9, 2, 5, 3, 7, 101, 18]`, the longest increasing subsequence is `[2, 3, 7, 101]`, and the length is `4`. Implement the function: ```python def length_of_lis(points: List[int]) -> int: ``` This function takes a list of integers, `points`, and returns an integer representing the length of the longest increasing subsequence.","solution":"from typing import List def length_of_lis(points: List[int]) -> int: if not points: return 0 lis = [1] * len(points) for i in range(1, len(points)): for j in range(i): if points[i] > points[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"Given an unsorted array of integers `nums`, find the **length** of the longest sequence of consecutive elements. A sequence of consecutive elements is defined as a group of elements where each element in the group differs from its neighbors by exactly `1`. Return _the length of the longest sequence of consecutive elements._ For example, given the array `nums = [100, 4, 200, 1, 3, 2]`, the longest sequence of consecutive elements is `[1, 2, 3, 4]` and the return value should be `4`.","solution":"def longest_consecutive(nums): if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # start of a new sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a string `s`, return the **length of the longest substring** that contains an equal number of \'0\'s and \'1\'s. If there are multiple such substrings, return the length of the longest one. A substring is a contiguous sequence of characters within the string.","solution":"def longest_equal_zero_one_substring(s): Returns the length of the longest substring with equal number of \'0\'s and \'1\'s. max_len = 0 count = 0 count_map = {0: -1} for i, char in enumerate(s): if char == \'0\': count -= 1 else: count += 1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. A **duo** in the list is a pair of words that share a common prefix of at least length `k`. Return _the number of unique duos in the list given the prefix length `k`_. If no such duo exists, return `0`.","solution":"def count_duos(words, k): Returns the number of unique duos in the list of words that share a common prefix of at least length k. Parameters: words (List[str]): A list of strings where each word consists of lowercase English letters. k (int): The minimum length of the common prefix. Returns: int: The number of unique duos in the list with the required common prefix length. from collections import defaultdict prefix_map = defaultdict(list) # Group words by their prefix of length k for word in words: if len(word) >= k: prefix = word[:k] prefix_map[prefix].append(word) unique_duo_count = 0 # Count pairs in each prefix group for prefix, words_with_prefix in prefix_map.items(): n = len(words_with_prefix) if n > 1: unique_duo_count += n * (n - 1) // 2 return unique_duo_count"},{"question":"Given a string `s` consisting only of characters \'a\', \'b\', and \'c\', return the length of the longest substring in which the number of \'a\'s, \'b\'s, and \'c\'s are the same. If no such substring exists, return `0`.","solution":"def longest_balanced_substring(s): Returns the length of the longest substring where the number of \'a\'s, \'b\'s, and \'c\'s are the same. Args: s (str): Input string consisting of characters \'a\', \'b\', and \'c\'. Returns: int: Length of the longest balanced substring. from collections import defaultdict count = defaultdict(int) max_length = 0 prefix_counts = {} prefix_counts[(0, 0)] = -1 for i, char in enumerate(s): if char == \'a\': count[\'a\'] += 1 elif char == \'b\': count[\'b\'] += 1 elif char == \'c\': count[\'c\'] += 1 key = (count[\'a\'] - count[\'b\'], count[\'a\'] - count[\'c\']) if key in prefix_counts: max_length = max(max_length, i - prefix_counts[key]) else: prefix_counts[key] = i return max_length"},{"question":"Given a string `str` consisting of parentheses `(` and `)`, your task is to determine the minimum number of parentheses to remove to make the string valid. A string is considered valid if it is empty or if there are matching open and close parentheses for every pair. Return the modified string that is valid after the minimum number of removals. * Example: * For `str = \\"))((\\"`, removing the first and last parentheses will result in `\\"()\\"`.","solution":"def min_remove_to_make_valid(s: str) -> str: Returns a modified string that is valid after the minimum number of removals. A string is valid if it is empty or if there are matching open and close parentheses for every pair. stack = [] to_remove = set() # First pass: determine positions of parentheses to remove for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: to_remove.add(i) # Add the unmatched open parentheses to the to_remove set to_remove = to_remove.union(set(stack)) # Second pass: build the resulting string result = \'\'.join(char for i, char in enumerate(s) if i not in to_remove) return result"},{"question":"Given an integer array `arr`, your task is to find the length of the longest contiguous subarray with an equal number of `0`s and `1`s. You need to ensure the solution has a time complexity of O(n) and uses O(n) space. Return _the length of the longest contiguous subarray with an equal number of `0`s and `1`s_.","solution":"def findMaxLength(nums): This function finds the length of the longest contiguous subarray with an equal number of 0s and 1s in the given array. count_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"Given an array of integers `arr` where the ith element represents the amount of time needed to process a job, and an integer `k` representing the number of available processors, distribute the jobs to the processors such that the maximum processing time of the jobs assigned to any processor is minimized. Return the minimized maximum processing time. To distribute the jobs: * Each processor can be assigned one or more jobs. * Jobs assigned to a processor must be contiguous in the array to maintain order. Write a function to compute and return the minimum possible value of the maximum processing time needed by any processor.","solution":"def canDistribute(arr, k, maxTime): current_sum = 0 required_processors = 1 for time in arr: if current_sum + time <= maxTime: current_sum += time else: required_processors += 1 current_sum = time if required_processors > k: return False return True def minProcessingTime(arr, k): left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if canDistribute(arr, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a list of `n` integers representing the heights of buildings in a straight line. A building `i` can see another building `j` if and only if all the buildings between `i` and `j` (exclusive) are shorter than both building `i` and building `j`. Two buildings `i` and `j` can see each other if and only if `i < j`. Return the total number of pairs of buildings that can see each other. Since the answer may be very large, return it **modulo** `109 + 7`.","solution":"def canSeeEachOther(heights): Returns the number of pairs of buildings that can see each other. heights: List of integers representing the heights of buildings. MOD = 10**9 + 7 n = len(heights) total_pairs = 0 for i in range(n): max_val = heights[i] for j in range(i + 1, n): if heights[j] > max_val: total_pairs += 1 total_pairs %= MOD max_val = heights[j] return total_pairs"},{"question":"Given a binary tree where each node has a value, find the maximum value you can obtain by traversing the tree. However, you may only traverse the tree by visiting each node\'s left or right child, starting from the root. The value obtained from a node is added to your total only once, even if you visit that node multiple times. You are allowed to traverse each node\'s left and right child, but cannot revisit the same path. Return the maximum total value that can be obtained.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_value_traversal(root): def helper(node): if not node: return 0 left_max = helper(node.left) right_max = helper(node.right) return node.value + max(left_max, right_max) return helper(root)"},{"question":"Write a function that takes a list of integers as input and returns a list of integers representing the product of all elements of the input list except the element at the current position. The function should not use division and should run in O(n) time. You may assume that the input list has a length of at least 2.","solution":"def product_except_self(nums): Returns an array of products of all elements except the element at the current position. Args: nums (List[int]): List of integers. Returns: List[int]: List of products. length = len(nums) result = [1] * length # Calculate left products left = 1 for i in range(length): result[i] = left left *= nums[i] # Calculate right products and combine with left products right = 1 for i in range(length - 1, -1, -1): result[i] *= right right *= nums[i] return result"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and you are to find the intersection of these two arrays. Each element in the result must appear as many times as it shows in both arrays, and the result can be in any order. Implement a function that returns the intersection of these arrays. The final result should be free of any duplicate entries. Example: If the input arrays are: `nums1 = [1, 2, 2, 3]` `nums2 = [2, 2, 3, 4]` Then the expected output would be: `[2, 3]`","solution":"def intersect(nums1, nums2): Returns the intersection of two sorted arrays without duplicates. Each element in the result must appear as many times as it shows in both arrays. from collections import Counter # Count occurrences of each element in the arrays count1 = Counter(nums1) count2 = Counter(nums2) # Find intersection of the two counters intersection = count1 & count2 # Convert to list with the elements appearing as many times as they appear in both arrays result = list(intersection.elements()) # Remove duplicates result = list(set(result)) return result"},{"question":"Suppose you are given a string `s` consisting of lowercase English letters. Your task is to find the length of the **longest substring** without repeating characters. Write a function `longest_unique_substring(s)` that returns this length. Ensure that your solution has a time complexity of O(n), where `n` is the length of the string.","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start_index = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start_index + 1) return max_length"},{"question":"Write a function that checks if a given integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. For example, `121` is a palindrome while `123` is not. You must solve this problem without converting the integer to a string.","solution":"def is_palindrome(x): Check if the integer x is a palindrome. if x < 0: return False original = x reversed_num = 0 while x != 0: remainder = x % 10 reversed_num = reversed_num * 10 + remainder x //= 10 return original == reversed_num"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform operations on this string by replacing any substring of length at least two with a single character that occurs the most frequently within that substring. For example, given the substring \\"abacd\\": * The letter \'a\' appears twice, which is more frequent than \'b\', \'c\', or \'d\', so you can replace \\"abacd\\" by \'a\'. The goal is to minimize the length of the string `s` using the described operations. Return the minimum length of the string `s` after performing any number of such operations.","solution":"def minimal_length(s: str) -> int: This function returns the minimum possible length of the string `s` after performing any number of replacement operations using the described method. # The idea is to count frequencies of each character and create the minimal string from collections import Counter # Find the frequency of characters in the string freq = Counter(s) # The minimal possible length we\'ll get will be equal to the total count of distinct characters. distinct_count = len(freq) return distinct_count"},{"question":"Given a string `str` consisting of alphanumeric characters and a positive integer `k`, you need to reformat the string such that every group of `k` characters (starting from the left) is separated by a hyphen (\'-\'). If there are fewer than `k` characters at the last group, it remains unchanged. Additionally, the alphanumeric characters must be converted to uppercase. Implement the function `String reformatString(String str, int k)` that returns the reformatted string according to the described rules.","solution":"def reformatString(s, k): Reformat the string such that every group of k characters (starting from the left) is separated by a hyphen (\'-\'). The alphanumeric characters must be converted to uppercase. Parameters: - s: str, input string consisting of alphanumeric characters. - k: int, positive integer defining the group length. Returns: - str, the reformatted string. # Remove all non-alphanumeric characters. alphanumeric_str = \'\'.join(c.upper() for c in s if c.isalnum()) # Determine the length of the string. n = len(alphanumeric_str) # Create the resulting reformatted string. reformatted = [] for i in range(0, n, k): reformatted.append(alphanumeric_str[i:i+k]) return \'-\'.join(reformatted)"},{"question":"You are given a `grid` representing a city, where each cell can either be an empty land (represented as `0`), a building (represented as `1`), or an obstacle (represented as `2`). You can move in four possible directions (up, down, left, or right) from an empty land to another empty land. Your goal is to find an empty land such that the sum of the distances from this land to all the buildings is minimized. Distance is measured in terms of the number of steps taken to reach each building. If it is not possible to collect all building distances from any land, return `-1`. Return the minimum distance sum from an empty land to all buildings.","solution":"from collections import deque def minDistance(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) buildings = sum(val == 1 for row in grid for val in row) hit = [[0] * cols for _ in range(rows)] dist_sum = [[0] * cols for _ in range(rows)] def bfs(start_row, start_col): visited = [[False] * cols for _ in range(rows)] queue = deque([(start_row, start_col, 0)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: row, col, dist = queue.popleft() for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and not visited[r][c] and grid[r][c] == 0: visited[r][c] = True hit[r][c] += 1 dist_sum[r][c] += dist + 1 queue.append((r, c, dist + 1)) for row in range(rows): for col in range(cols): if grid[row][col] == 1: bfs(row, col) result = float(\'inf\') for row in range(rows): for col in range(cols): if grid[row][col] == 0 and hit[row][col] == buildings: result = min(result, dist_sum[row][col]) return result if result != float(\'inf\') else -1"},{"question":"You are given a string `s` representing an encoded file path, using the following encoding rules: - Each digit in the string represents how many levels down in the hierarchy the next character is located. - The hierarchical structure is such that a character following `1` is a direct child of the root or the previous character, a character following `2` is a child of the character that\'s one level deep, and so on. For example, the string `1a2b1c` translates to a hierarchy where: - `a` is directly under the root. - `b` is under `a`. - `c` is directly under the root, not `a`. Write a function `decodeFilePath` that takes in the encoded string `s` and returns a nested dictionary representation of the hierarchical structure. The dictionary should use each character as a key, and its value being either another dictionary (representing its children) or an empty dictionary if it has no children.","solution":"def decodeFilePath(s): Decodes an encoded file path string and returns a nested dictionary representation of the hierarchy. if not s: return {} root = {} current_level = root stack = [root] i = 0 while i < len(s): if s[i].isdigit(): level = int(s[i]) i += 1 while len(stack) > level: stack.pop() current_level = stack[-1] if i < len(s): char = s[i] if char not in current_level: current_level[char] = {} stack.append(current_level[char]) i += 1 return root"},{"question":"Implement a `BinarySearchTree` class with the following methods: * `BinarySearchTree()` initializes the BST with an empty root. * `void insert(int val)` inserts a value into the BST. If the value already exists, it does not insert it again. * `boolean search(int val)` returns `true` if the value exists in the BST, otherwise `false`. * `void delete(int val)` removes the value from the BST if it exists. * `List<Integer> inorderTraversal()` returns a list of all values in the BST in in-order traversal order. Design the `BinarySearchTree` class such that it maintains the properties of a binary search tree where: * The left subtree of a node contains only nodes with keys less than the node’s key. * The right subtree of a node contains only nodes with keys greater than the node’s key. * Both the left and right subtrees must also be binary search trees. Note: When removing a node, you must properly handle the three cases: 1. The node to be deleted is a leaf node. 2. The node to be deleted has one child. 3. The node to be deleted has two children.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.key: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.key: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.key == val: return True elif val < node.key: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.key: node.left = self._delete(node.left, val) elif val > node.key: node.right = self._delete(node.right, val) else: if node.left is None: return node.right if node.right is None: return node.left temp = self._find_min(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def _find_min(self, node): current = node while current.left is not None: current = current.left return current def inorderTraversal(self): result = [] self._inorderTraversal(self.root, result) return result def _inorderTraversal(self, node, result): if node is not None: self._inorderTraversal(node.left, result) result.append(node.key) self._inorderTraversal(node.right, result)"},{"question":"Given a string `s` consisting of lowercase English letters, you need to perform a series of operations. In one operation, you can choose any character in the string and remove it if it appears more than once in the remaining part of the string. Return the length of the shortest possible string after performing such operations any number of times. If the string is already in its shortest possible form, return its length.","solution":"def shortest_unique_string_length(s): Returns the length of the shortest possible string after removing characters that appear more than once in the remaining part of the string. from collections import Counter counter = Counter(s) # Remove any characters that appear more than once unique_chars = [char for char, count in counter.items() if count == 1] return len(unique_chars)"},{"question":"Write a function `findAllAnagrams` that takes two inputs: a string `s` and a string `p`. This function should return an array of all the start indices of `p`\'s anagrams in `s`. You may return the answer in any order. An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. * `findAllAnagrams(String s, String p)` - returns `List<Integer>` containing start indices of each anagram of `p` in `s`. For example, if `s = \\"cbaebabacd\\"` and `p = \\"abc\\"`, the function should return `[0, 6]` because the substring \\"cba\\" (starting at index 0) and the substring \\"bac\\" (starting at index 6) are anagrams of \\"abc\\".","solution":"def findAllAnagrams(s, p): from collections import Counter p_len = len(p) p_counter = Counter(p) s_counter = Counter(s[:p_len-1]) result = [] for i in range(p_len-1, len(s)): s_counter[s[i]] += 1 if s_counter == p_counter: result.append(i-p_len+1) s_counter[s[i-p_len+1]] -= 1 if s_counter[s[i-p_len+1]] == 0: del s_counter[s[i-p_len+1]] return result"},{"question":"Given an integer array `nums`, a **good subsequence** is a subsequence that is non-empty and all of its elements are unique. The **length** of a good subsequence is the count of its elements. Determine the **maximum length** of any good subsequence you can form from the elements of `nums`. Return the maximum length of any good subsequence.","solution":"def max_length_good_subsequence(nums): Determines the maximum length of any good subsequence (non-empty and unique elements) from the elements of nums. return len(set(nums))"},{"question":"You are given a non-negative integer `num`. Your task is to repeatedly add all its digits until the result has only one digit. This process is known as \\"digital root.\\" Return the digital root of `num`. For example, if you start with `num = 38`, then the sequence would be: - `3 + 8 = 11` - `1 + 1 = 2` So the digital root of `38` is `2`.","solution":"def digital_root(num): Returns the digital root of a non-negative integer num. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"You are given an array of integers `nums`. A \\"good\\" array is defined as an array where the greatest common divisor (GCD) of all its elements is 1. Return `true` if the given array is a good array, and `false` otherwise. For example, the array `[12, 5, 7, 23]` is a good array because the GCD of all the elements is 1, while the array `[4, 6, 8]` is not a good array because the GCD of all the elements is greater than 1.","solution":"from math import gcd from functools import reduce def is_good_array(nums): Determines if the given array is a \\"good\\" array, where a good array has a greatest common divisor (GCD) of 1 for all its elements. Args: nums (List[int]): List of integers. Returns: bool: True if the array is good, False otherwise. return reduce(gcd, nums) == 1"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `x`. You are allowed to perform a specific move on the string `s` at most `x` times. In one move, you can choose any character and remove it from the string. Your goal is to make the final string lexicographically smallest. Return the lexicographically smallest string you can obtain after at most `x` moves.","solution":"def lexicographically_smallest_string(s, x): Returns the lexicographically smallest string after removing at most x characters from s. stack = [] to_remove = x for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # If there are still removals left and the string is not empty, remove from end final_string = \'\'.join(stack) if to_remove > 0: final_string = final_string[:-to_remove] return final_string"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to find the longest path in the tree where each consecutive node along the path has values differing by exactly 1. This path may or may not pass through the root. A path can be started and ended at any node in the tree. Return the length of the longest such path. If there are no consecutive nodes differing by exactly 1, return 1 since each node individually can be considered as a path of length 1. Example: - Input: `root = [1, 2, 3, None, 3, None, 4, 4, 5]` - Output: 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): if not root: return 0 def helper(node, parent_value, current_length): if not node: return current_length if parent_value + 1 == node.value: current_length += 1 else: current_length = 1 left_length = helper(node.left, node.value, current_length) right_length = helper(node.right, node.value, current_length) return max(current_length, left_length, right_length) return helper(root, root.value - 1, 0)"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to find the maximum number of substrings you can create from `s` such that each substring has exactly `k` distinct characters and all characters of each substring are the same. Return the maximum number of such substrings you can create. If it is not possible to create any valid substring, return `0`.","solution":"def max_substrings_with_k_distinct_char(s, k): Returns the maximum number of substrings with exactly k distinct characters where all characters in each substring are the same. Parameters: s (str): The input string. k (int): The number of distinct characters required in each substring. Returns: int: The maximum number of valid substrings. from collections import Counter # Corner case: if k is less than or equal to 0 or greater than the length of the string if k <= 0 or k > len(s): return 0 # Count the frequency of each character in the string char_count = Counter(s) # Iterate over the frequency dictionary max_substrings = 0 for char, count in char_count.items(): if count >= k: max_substrings += count // k return max_substrings"},{"question":"Given a 2D grid of integers where each integer represents the height of a terrain at that cell, and an integer value representing the volume of water you can pour onto this grid, write a function to determine how much water can be trapped in all the low points of the terrain after pouring the water. The grid boundaries are impermeable, meaning water cannot flow out of the edges. Implement the function `int calculateTrappedWater(int[][] heightMap, int volume)`. Note that if the volume of water poured exceeds the capacity that can be trapped by the terrain, the excess will spill over and not be counted.","solution":"import heapq def calculateTrappedWater(heightMap, volume): if not heightMap or not heightMap[0]: return 0 n, m = len(heightMap), len(heightMap[0]) visited = [[False]*m for _ in range(n)] heap = [] # Initialize the heap with boundary cells for i in range(n): for j in range(m): if i == 0 or j == 0 or i == n-1 or j == m-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True trapped_water = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap and volume > 0: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True trapped_height = max(0, height - heightMap[nx][ny]) if volume > trapped_height: trapped_water += trapped_height volume -= trapped_height else: trapped_water += volume volume = 0 break heapq.heappush(heap, (max(heightMap[nx][ny], height), nx, ny)) return min(trapped_water, volume + trapped_water) # Account for spill over volume"},{"question":"Given a string `s`, return the longest palindrome that can be made by rearranging the characters of `s`. If there are multiple longest palindromes, return any of them. The input string will consist of lowercase English letters only.","solution":"from collections import Counter def longest_palindrome(s): Given a string s, returns the longest palindrome that can be made by rearranging its characters. count = Counter(s) left_half = [] middle = \'\' for char, freq in count.items(): if freq % 2 == 1: middle = char left_half.append(char * (freq // 2)) left_half.sort() left_half_str = \'\'.join(left_half) result = left_half_str + middle + left_half_str[::-1] return result"},{"question":"You are given a **non-empty** string `s` consisting of lowercase alphabets and an integer array `indices` of the same length. Both `s` and `indices` are of the same length `n`. The string `s` represents a scrambled version of another string, and `indices` represents how the characters in the original string should be rearranged so that they appear in the order of the scrambled string `s`. Specifically, the character at index `i` in the scrambled string `s` should be moved to `indices[i]` in the original string. Return _the original string after reordering the characters according to the given `indices` array_.","solution":"def restore_string(s, indices): Rearranges the string s based on the indices list. Parameters: s (str): The scrambled string. indices (list): The list of indices indicating the new positions of the characters. Returns: str: The original string after reordering. n = len(s) result = [\'\'] * n for i, char in enumerate(s): result[indices[i]] = char return \'\'.join(result)"},{"question":"A **cyclic shift** of an array `arr` is obtained by moving the elements a certain number of positions to the right with elements from the end of the array wrapping around to the start. Given an array of integers `arr` and a positive integer `k`, perform `k` cyclic shifts on `arr` and return the resulting array. For example, if `arr = [1, 2, 3, 4, 5]` and `k = 2`, the resulting array after 2 cyclic shifts would be `[4, 5, 1, 2, 3]`. Ensure the algorithm runs efficiently even for large arrays and values of `k`.","solution":"def cyclic_shift(arr, k): Perform k cyclic shifts on the array arr. if not arr or k <= 0: return arr n = len(arr) k = k % n # To handle cases where k is larger than the length of the array return arr[-k:] + arr[:-k]"},{"question":"Given an `m x n` 2D grid `grid` which represents a map of \'1\'s (land) and \'0\'s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. To align with the existing questions: - The question is framed clearly and concisely explaining the context. - Complexity involves understanding grid traversal algorithms, such as DFS or BFS. - Topic aligns with problem-solving skills in handling data structures like 2D arrays and implementing depth-first search (DFS) or breadth-first search (BFS).","solution":"def num_islands(grid): Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands (horizontally or vertically). if not grid: return 0 rows, cols = len(grid), len(grid[0]) count = 0 def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == \'0\': return grid[r][c] = \'0\' # mark the land as visited # explore all 4 possible directions dfs(r + 1, c) # down dfs(r - 1, c) # up dfs(r, c + 1) # right dfs(r, c - 1) # left for r in range(rows): for c in range(cols): if grid[r][c] == \'1\': count += 1 dfs(r, c) return count"},{"question":"You are given a list of integers `weights` where each element represents the weight of a person. You need to find the minimum number of boats required to rescue everyone. Each boat can carry a maximum weight of `limit` and can hold at most two people at the same time. Return the minimum number of boats required to rescue all the people, assuming each person can be placed in exactly one boat.","solution":"def numRescueBoats(weights, limit): Returns the minimum number of boats required to rescue all the people. Args: weights (List[int]): List of weights of the people. limit (int): Maximum weight capacity of each boat. Returns: int: Minimum number of boats required. weights.sort() i, j = 0, len(weights) - 1 boats = 0 while i <= j: if weights[i] + weights[j] <= limit: i += 1 j -= 1 boats += 1 return boats"},{"question":"You are given a 2D grid `matrix` of characters where each character can be one of `\'0\'`, `\'1\'`, or `\'E\'`. The grid represents a field where `\'0\'` is an empty cell, `\'1\'` is an obstacle, and `\'E\'` is an exit. You start at the top-left corner of the grid (position `(0, 0)`). You can move up, down, left, or right from the current cell to an adjacent empty cell. Your goal is to find the shortest path to any exit cell `\'E\'`. If there is no path to an exit, return `-1`. The path length is measured by the number of cells traversed from the start to the exit, including both start and exit cells.","solution":"from collections import deque def shortest_path_to_exit(matrix): Returns the length of the shortest path from the top-left corner (0, 0) to any exit cell (\'E\') in the given 2D grid `matrix`. If no path exists, return -1. if not matrix or not matrix[0] or matrix[0][0] == \'1\': return -1 rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if matrix[r][c] == \'E\': return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] != \'1\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an **n x n** binary matrix `grid` where each cell represents a portal that is either **active** (`1`) or **inactive** (`0`). Your task is to return the total number of **connected components** of active portals. A **connected component** consists of a set of active portals that are connected by moving horizontally or vertically. Two cells are considered connected if they share a common side. Return the total number of such connected components in the matrix.","solution":"def count_connected_components(grid): def dfs(i, j): # If out of bounds or not a portal, return if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return # Mark the portal as visited grid[i][j] = 0 # Traverse in all 4 possible directions (up, down, left, right) dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 n = len(grid) connected_components = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: dfs(i, j) connected_components += 1 return connected_components"},{"question":"A delivery company wants to optimize its delivery routes in a city, which is represented as a grid of `m x n` blocks. Each block has a certain delivery cost represented in a 2D array `costs` where `costs[i][j]` is the delivery cost of the block located at row `i` and column `j`. The company\'s delivery starts from the top-left corner of the grid and ends at the bottom-right corner. The drivers can only move right or down at any point in time. Write a function to return the minimum delivery cost to reach the bottom-right corner from the top-left corner. Make sure your function is efficient to handle grids with large dimensions.","solution":"def min_delivery_cost(costs): Returns the minimum delivery cost to reach the bottom-right corner from the top-left corner. Drivers can only move right or down at any point in time. :param costs: 2D list with delivery costs for each block [i][j]. :return: Minimum delivery cost. if not costs or not costs[0]: return 0 m, n = len(costs), len(costs[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = costs[0][0] # Initialize the top row for j in range(1, n): dp[0][j] = dp[0][j-1] + costs[0][j] # Initialize the left column for i in range(1, m): dp[i][0] = dp[i-1][0] + costs[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costs[i][j] return dp[m-1][n-1]"},{"question":"Given an array of integers `arr`, create a function that returns the product of every integer in the array except the integer at the current index, without using division and in O(n) time complexity. For example, given the array `[1, 2, 3, 4]`, the function should return `[24, 12, 8, 6]`.","solution":"def product_except_self(arr): Returns an array such that each element at index i is the product of all other elements in the array except arr[i], without using division and in O(n) time. :param arr: List of integers :return: List of products except self at each index n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n output = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate output array for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"Given a string `s` and an array of intervals `[start, end]`, where each interval represents a pair of start and end indices (inclusive) within the string, return a new string with only the characters that are within the given intervals. If intervals overlap, they should be merged into a single interval. For example, if the input string is `\\"abcdef\\"` and intervals are `[(1, 3), (2, 4)]`, the merged interval would be `(1, 4)`, and the resulting string would be `\\"bcde\\"`. If no intervals are provided, return an empty string.","solution":"def merge_intervals(intervals): if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for start, end in intervals[1:]: last_end = merged[-1][1] if start <= last_end + 1: merged[-1][1] = max(last_end, end) else: merged.append([start, end]) return merged def extract_string_using_intervals(s, intervals): merged_intervals = merge_intervals(intervals) result = [] for start, end in merged_intervals: result.append(s[start:end+1]) return \'\'.join(result)"},{"question":"You are given a 2D matrix of integers `matrix` where each row is sorted in ascending order, and each column is sorted in ascending order. Write a function that takes this matrix and an integer `target` as input and returns a boolean indicating whether `target` is found in the matrix. Implement an efficient algorithm that minimizes the number of comparisons.","solution":"def search_matrix(matrix, target): Returns True if target is found in the matrix, otherwise False. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = rows - 1 col = 0 while row >= 0 and col < cols: if matrix[row][col] == target: return True elif matrix[row][col] > target: row -= 1 else: col += 1 return False"},{"question":"You are given a string `s` which consists of lowercase letters and an integer `k`. You need to transform the string into a new string `t` by performing the following operation exactly `k` times: Select any character from the string `s` and append it to the end of `t`. Return the length of the longest substring with all characters the same in the string `t` after all operations are performed.","solution":"def longest_uniform_substring_after_k_operations(s, k): Applies the operation of appending a character from s to t k times and returns the length of the longest substring with all characters the same in t. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the character with the maximum frequency max_freq_char = max(char_count, key=char_count.get) # Longest possible uniform substring would be the frequency of the most frequent character plus k max_length_after_operations = char_count[max_freq_char] + k return max_length_after_operations"},{"question":"Given an array of integers `arr` and an integer `target`, find two distinct indices i and j in the array such that `arr[i] + arr[j] == target`. If such indices exist, return them as a tuple. If no such indices exist, return an empty tuple. You may assume that each input would have exactly one solution and you may not use the same element twice.","solution":"def two_sum(arr, target): Returns a tuple of two distinct indices i and j such that arr[i] + arr[j] == target. If no such indices exist, returns an empty tuple. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"You are given a list of non-negative integers representing the amount of money of each house, arranged in a circle. A robber cannot rob two adjacent houses, and also cannot rob the first and the last house together because they are adjacent (in a circular manner). Determine the maximum amount of money the robber can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money a robber can rob without alerting the police, given the houses are arranged in a circle. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] if n == 2: return max(nums) def rob_linear(houses): Helper function to rob houses in a linear street (not circular) prev, curr = 0, 0 for amount in houses: prev, curr = curr, max(curr, prev + amount) return curr return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"Write a function that takes a list of integers `nums` and returns a list of lists, where each sublist contains all the elements of `nums` that have the same frequency of occurrence, ordered from highest frequency to lowest frequency. If two numbers have the same frequency, the numbers should be arranged in ascending order within their sublist. For example, given the input list `[3,3,1,2,2,2,4,4,4,4]`, the function should return `[[4], [2], [3], [1]]`.","solution":"from collections import Counter def group_by_frequency(nums): Groups integers in the list nums by their frequency of occurrence. The sublists are ordered from highest frequency to lowest frequency, and within each sublist, the integers are sorted in ascending order. Args: nums (list): List of integers. Returns: list: A list of lists, each containing integers with the same frequency. # Count the frequency of each number frequency_counter = Counter(nums) # Create a dictionary where key is the frequency and value is a list of numbers with that frequency frequency_map = {} for num, freq in frequency_counter.items(): if freq not in frequency_map: frequency_map[freq] = [] frequency_map[freq].append(num) # Sort each frequency group and the frequency map by frequency in descending order result = [] for freq in sorted(frequency_map.keys(), reverse=True): result.append(sorted(frequency_map[freq])) return result"},{"question":"You are given an array of integers `heights` representing the height of buildings situated along a straight line. The array `heights` is sorted in non-decreasing order. You want to build a water tank on one of the buildings such that the tank can collect the maximum rainwater. The amount of rainwater collected above a building is determined by the heights of that building and the next taller building to its right. If there is no taller building to the right, the rainwater collected is zero. Write an algorithm to find and return the maximum amount of rainwater that can be collected. For example, given the array `heights = [1, 3, 5, 7, 7, 9]`, the total amount of rainwater that can be collected above the building with height `3` is `5 - 3 = 2`, above the building with height `5` is `7 - 5 = 2`, and so on. Write a function to identify the maximum amount of rainwater that can be collected. The algorithm should be efficient with a time complexity of `O(n)`.","solution":"def max_rainwater_collected(heights): Returns the maximum amount of rainwater that can be collected above a building. Arguments: heights -- List[int]: sorted list of building heights in non-decreasing order Returns: int -- maximum amount of rainwater that can be collected above a building n = len(heights) if n < 2: return 0 # No rainwater can be collected if there are less than 2 buildings max_water = 0 for i in range(n - 1): water_collected = heights[i + 1] - heights[i] if water_collected > max_water: max_water = water_collected return max_water"},{"question":"Given an array of integers `arr` and an integer `x`, find the length of the smallest contiguous subarray of which the sum is greater than or equal to `x`. If there is no such subarray, return `-1`. For example, given `arr = [2, 3, 1, 2, 4, 3]` and `x = 7`, the smallest contiguous subarray with a sum greater than or equal to `7` is `[4, 3]`, so the function should return `2`. Review the array and integer for different possibilities, and ensure the smallest subarray length is returned.","solution":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray of which the sum is greater than or equal to x. If there is no such subarray, returns -1. n = len(arr) min_length = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an integer array `arr`. An operation on the array consists of picking any two elements and replacing them with their sum. Determine the number of operations needed to reduce the array to a single element with minimal sum. Return the minimal sum at the end of all operations.","solution":"from heapq import heapify, heappop, heappush def minimal_sum_operations(arr): Returns the minimal sum and number of operations needed to reduce the array to a single element. # Edge cases: if not arr: return 0, 0 if len(arr) == 1: return arr[0], 0 # Create a min-heap from the array heapify(arr) total_operations = 0 while len(arr) > 1: # Pop two smallest elements first = heappop(arr) second = heappop(arr) # Replace them with their sum new_element = first + second heappush(arr, new_element) total_operations += 1 # The last remaining element in the heap is the result final_sum = heappop(arr) return final_sum, total_operations"},{"question":"You are given an array `arr` of integers and an integer `target`. Your task is to determine if there exist two distinct indices `i` and `j` in the array such that `arr[i] + arr[j] = target`. Implement a function `has_pair_with_sum(arr, target)` that returns a boolean value: `True` if such indices exist, and `False` otherwise. Make sure the solution operates with optimal time complexity.","solution":"def has_pair_with_sum(arr, target): This function takes an array of integers `arr` and an integer `target`. It returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals target. Otherwise, it returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"Implement the `MajorityElement` class which provides the functionality to find the majority element in an array of size `n`. The majority element is the element that appears more than `n/2` times. The class should support the following methods: - **`MajorityElement(int[] nums)`**: Initializes the object with the given array `nums`. - **`int findMajority()`**: Returns the majority element in the array. If no majority element exists, return `-1`. Note that the array will not be sorted, and the algorithm should operate in linear time and constant space.","solution":"class MajorityElement: def __init__(self, nums): Initializes the object with the given array nums. self.nums = nums def findMajority(self): Returns the majority element in the array. If no majority element exists, return -1. candidate = None count = 0 # Boyer-Moore Voting Algorithm to find the candidate for num in self.nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is indeed the majority if self.nums.count(candidate) > len(self.nums) // 2: return candidate else: return -1"},{"question":"You are given a string `s` that represents a license key which is a sequence of alphanumeric characters grouped by dashes. The string is reformatted to be divided into groups of size `k` (where `k` is a positive integer) separated by dashes. The first group may be shorter than `k` but still must contain at least one character. Write a function that converts this license key to uppercase and reformats it according to the above conditions. If the given license key `s` is “2-5g-3-J” and `k` is 2, the output should be “2-5G-3J”. If `s` is “2-4A0r7-4k” and `k` is 4, the output should be “24A0-R74K”.","solution":"def reformat_license_key(s: str, k: int) -> str: Reformats a license key string to be divided into groups of size `k`, separated by dashes, and converts all characters to uppercase. Parameters: s (str): The license key string to be reformatted. k (int): The size of each group of characters. Returns: str: The reformatted license key string. # Remove all dashes and convert the string to uppercase s = s.replace(\\"-\\", \\"\\").upper() # Initialize the result list result = [] # Process the string in reverse order, adding dashes every k characters for i in range(len(s)): if i > 0 and i % k == 0: result.append(\\"-\\") result.append(s[-(i + 1)]) # The result list is in reverse order, so reverse it back to the correct order return \\"\\".join(result[::-1])"},{"question":"Given a 2D grid of integers representing a map where each cell contains either a `1` (land) or a `0` (water), return _the size of the largest `1`-connected cluster_ on the map. A `1`-connected cluster is defined as a group of `1`s that are connected vertically or horizontally, not diagonally. You may assume that the grid has at least one cell.","solution":"def largest_island(grid): Returns the size of the largest 1-connected cluster (island) in the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 grid[r][c] = 0 # Mark this cell as visited size = 1 # Check all four directions size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size max_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: max_size = max(max_size, dfs(r, c)) return max_size"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` indicates the position of a point on a 2D plane. A number of lasers are positioned on the x-axis, and each laser can sweep vertically to eliminate all points that lie on its path. You need to place the **minimum number** of lasers such that all the points are eliminated. Return _the minimum number of lasers needed_.","solution":"def findMinLasers(points): Finds the minimum number of lasers needed to eliminate all points. Args: points: List[List[int]] - A list of [x, y] coordinates. Returns: int - The minimum number of lasers. # Sort points by their x-coordinate points.sort(key=lambda p: p[0]) # Initialize count of lasers and end coordinate of current laser lasers = 0 current_laser_end = -float(\'inf\') for point in points: x, y = point if x > current_laser_end: # New laser is needed lasers += 1 current_laser_end = x return lasers"},{"question":"Given an array of integers `nums`, find the number of contiguous subarrays that sum up to a given integer `k`. Two subarrays are considered distinct if they start or end at different indices. [Question 5]:","solution":"def subarray_sum(nums, k): Finds the number of contiguous subarrays that sum up to a given integer k. Args: nums: List[int] - List of integers representing the array. k: int - The target sum for subarrays. Returns: int - Number of contiguous subarrays that sum to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"You are given a string `word` consisting of lowercase and uppercase English letters. You need to detect if `word` follows these rules: - All letters in `word` are in uppercase, or - All letters in `word` are in lowercase, or - Only the first letter in `word` is in uppercase and all other letters are in lowercase. Return `true` if `word` follows the above rules, and `false` otherwise. For example: - \\"USA\\" returns `true` - \\"leetcode\\" returns `true` - \\"Google\\" returns `true` - \\"fLAG\\" returns `false`","solution":"def detectCapitalUse(word): Detect if the word uses capital letters correctly per the provided rules. Arguments: word -- string consisting of lowercase and uppercase English letters Returns: True if word follows the capitalization rules, False otherwise. if word.isupper(): return True if word.islower(): return True if word[0].isupper() and word[1:].islower(): return True return False"},{"question":"You are given a string `s` consisting of only lowercase alphabets. You can shuffle the string in any order you want. Return the length of the longest substring with all unique characters that can be created from any possible shuffled version of `s`.","solution":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters that can be created from any possible shuffled version of the input string. The length of the longest unique substring is the same as the number of unique characters in the string `s` because we can rearrange `s` in such a way that all its unique characters will form a contiguous substring. return len(set(s))"},{"question":"You are given the head of a singly linked list. Removing a node in this list can be done in linear time O(n). Write a function `removeNodes(head, m)` that removes the node at the `m`-th position from the end of the list and returns the head of the modified list. If `m` is greater than the length of the list, return the unmodified list. Note that the position `m` is 1-based, meaning that `m = 1` corresponds to the last node in the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNodes(head, m): # Create a dummy node that points to the head of the list dummy = ListNode(0) dummy.next = head # Initialize two pointers - fast and slow fast = dummy slow = dummy # Move the fast pointer m+1 steps ahead (to be 1-based compliant) for _ in range(m + 1): if fast is None: return head # m is greater than the length of the list fast = fast.next # Move both pointers until the fast one reaches the end while fast is not None: fast = fast.next slow = slow.next # Skip the m-th node from the end slow.next = slow.next.next # Return the head of the modified list return dummy.next"},{"question":"Given an array of integers `nums` sorted in ascending order, convert it into a height-balanced binary search tree (BST). A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Write a function that generates the BST from the given sorted array `nums`. **Example:** Input: `nums = [-10, -3, 0, 5, 9]` Output: [0, -3, 9, -10, null, 5] Explanation: - The root node is 0. - The left child of 0 is -3. - The right child of 0 is 9. - The left child of -3 is -10. - The right child of 9 is 5. Note: The output represents the preorder traversal of the constructed BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Converts a sorted array to a height-balanced binary search tree. :param nums: List[int], a list of integers sorted in ascending order :return: TreeNode, the root of the height-balanced BST if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sortedArrayToBST(nums[:mid]) root.right = sortedArrayToBST(nums[mid+1:]) return root def preorderTraversal(root): Generate the preorder traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], the preorder traversal of the tree as list of values if not root: return [] return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)"},{"question":"You are given an array of integers `nums`, where each integer represents a position on a number line. Your task is to find all the unique triplets in the array which together sum to zero. Note that the solution set must not contain duplicate triplets. _For example, given array `nums = [-1, 0, 1, 2, -1, -4]`, a solution set is:_ ``` [ [-1, 0, 1], [-1, -1, 2] ] ``` **Note:** Each pair of integers in the solution set should be such that the sum of the three integers is zero. Ensure the solution is without repeated triplets, meaning `[a,b,c]` is the same as `[b,a,c]` or any other permutation.","solution":"def three_sum(nums): Finds all unique triplets in the array which sum to zero. Parameters: nums (List[int]): An array of integers. Returns: List[List[int]]: A list of unique triplets that sum to zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"You are given a rectangular grid of size `m x n` with empty cells (represented by `0`) and cells with obstacles (represented by `1`). You are also given a starting position `(startX, startY)` and an ending position `(endX, endY)` in the grid. You need to find the **shortest path** from the starting position to the ending position, moving only through empty cells and avoiding obstacles. You can move in four possible directions: up, down, left, and right. If no such path exists, return `-1`. Write a function `shortestPath(grid, startX, startY, endX, endY)` that returns the length of the shortest path from the start to the end positions.","solution":"from collections import deque def shortestPath(grid, startX, startY, endX, endY): Finds the shortest path in a grid from the (startX, startY) to (endX, endY), avoiding obstacles. Parameters: grid (list of list of int): m x n grid where 0 represents an empty cell and 1 represents an obstacle. startX (int): Starting position X coordinate. startY (int): Starting position Y coordinate. endX (int): Ending position X coordinate. endY (int): Ending position Y coordinate. Returns: int: Length of the shortest path, or -1 if no such path exists. if grid[startX][startY] == 1 or grid[endX][endY] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startX, startY, 0)]) # (currentX, currentY, distance) visited = set((startX, startY)) while queue: x, y, dist = queue.popleft() if x == endX and y == endY: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a list of integers `nums` representing a sequence of operations where each element is an integer signifying a change to a base value, starting at 0. For example, an element of 4 means adding 4 to the base value. An element of -3 means subtracting 3 from the base value. Your task is to determine the maximum value obtainable from any subsequence of these operations. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the maximum value obtainable.","solution":"def max_subsequence_sum(nums): Returns the maximum value obtainable from any subsequence of the given list of integers. max_sum = 0 current_sum = 0 for num in nums: current_sum += num if current_sum < 0: current_sum = 0 if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given an integer array `arr` of `n` elements, each element being either `1` or `-1`, and an integer `target`, your task is to determine whether there exists a **non-empty** subarray whose sum is exactly equal to `target`. A subarray is a contiguous part of the array. If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def subarray_sum_equals_target(arr, target): Determines whether there exists a non-empty subarray whose sum is exactly equal to target. :param arr: List[int] - List of integers (1 or -1) :param target: int - Target sum :return: bool - True if such a subarray exists, False otherwise current_sum = 0 prefix_sums = {0: -1} # To handle the case when subarray starts from index 0 for i in range(len(arr)): current_sum += arr[i] # If current_sum - target exists in prefix_sums, we found a subarray with sum = target if current_sum - target in prefix_sums: # To ensure the subarray is non-empty if i - prefix_sums[current_sum - target] > 0: return True # Store the prefix sum with the current index if current_sum not in prefix_sums: prefix_sums[current_sum] = i return False"},{"question":"Write a function `mostFrequentEven` that takes in a list of integers `nums` and returns the most frequent even element in the list. If there is a tie, return the smallest even element among the tied elements. If there are no even elements in the list, return -1. For example: - Given the list `[3, 4, 1, 2, 3, 4, 4, 6]`, the function should return `4` since `4` appears most frequently among the even numbers. - Given the list `[1, 7, 5, 3]`, the function should return `-1` as there are no even numbers. - Given the list `[3, 2, 2, 4, 4, 6, 6]`, the function should return `2` as `2` is the smallest even element among the tied elements appearing most frequently.","solution":"from collections import Counter def mostFrequentEven(nums): Returns the most frequent even element in the list. If there is a tie, it returns the smallest even element among the tied elements. If there are no even elements, it returns -1. even_nums = [num for num in nums if num % 2 == 0] if not even_nums: return -1 freq = Counter(even_nums) most_common = freq.most_common() max_freq = most_common[0][1] candidate_nums = [num for num, count in most_common if count == max_freq] return min(candidate_nums)"},{"question":"Given an array of integers `height` representing the heights of buildings. Your task is to count how many buildings have an ocean view. The buildings are in a line and each building can see the ocean if all the buildings to its right are shorter. Write a function that returns the number of buildings with an ocean view. For example, given the array `height = [4, 2, 3, 1]`, the buildings with indices 0, 2, and 3 have ocean views.","solution":"def count_ocean_view_buildings(height): Returns the number of buildings that have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: height (list of int): A list representing the heights of the buildings. Returns: int: The number of buildings with an ocean view. ocean_view_count = 0 max_height_from_right = float(\'-inf\') for h in reversed(height): if h > max_height_from_right: ocean_view_count += 1 max_height_from_right = h return ocean_view_count"},{"question":"Given a string `s`, remove the minimum number of characters from `s` so that it becomes a valid palindrome. A string is a valid palindrome if it reads the same forward and backward. Return _the result string after the minimum number of deletions_. If there are multiple possible results, return any of them.","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp def build_palindrome(s, dp): n = len(s) i, j = 0, n - 1 res = [] while i <= j: if s[i] == s[j]: res.append(s[i]) i += 1 j -= 1 elif dp[i][j - 1] > dp[i + 1][j]: j -= 1 else: i += 1 palindrome = res + res[::-1] if i == j + 1 else res + res[::-1][1:] return \'\'.join(palindrome) def make_palindrome(s): dp = longest_palindromic_subsequence(s) return build_palindrome(s, dp)"},{"question":"You are given an array of unique integers `arr` and an integer `target`. You need to determine if there exist three integers in the array whose sum is equal to the `target`. Return a boolean indicating whether such a triplet exists. Note that the integers in the array can be used only once in each triplet.","solution":"def three_sum(arr, target): This function returns True if there are three integers in the array whose sum is equal to the target, otherwise, it returns False. arr.sort() n = len(arr) for i in range(n-2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given an integer array `nums` and an integer `target`. You need to build an expression out of `nums` by adding a `+` or `-` sign between each pair of adjacent elements. The goal is to determine whether there is a way to insert the operators such that the resulting expression evaluates to the given `target`. Return `true` if it is possible to obtain `target` by inserting the operators, otherwise return `false`. **Note**: - You must insert exactly one operator between each pair of adjacent elements in `nums`. - If `nums` consists of only one number, simply check if it is equal to `target`.","solution":"def can_obtain_target(nums, target): Determines if it is possible to insert \'+\' or \'-\' between adjacent elements in nums to achieve the target. def backtrack(index, current_total): # Base case: If we\'ve considered all numbers if index == len(nums): return current_total == target # Recursive case: Add or subtract current number add_result = backtrack(index + 1, current_total + nums[index]) subtract_result = backtrack(index + 1, current_total - nums[index]) return add_result or subtract_result # Initial call starts with first number return backtrack(1, nums[0])"},{"question":"You are given an **0-indexed** 2D integer array `matrix` with dimensions `m x n`, where each element represents a positive integer. You are also given an integer `k`. Your task is to find the sum of the elements of the submatrix with the largest sum among all submatrices that have an area of `k` (i.e., contain exactly `k` elements). If there are multiple submatrices with the same largest sum, return any of their sums. If no such submatrix exists, return `0`.","solution":"def max_sum_submatrix(matrix, k): Finds the sum of the elements of the submatrix with the largest sum among all submatrices that have an area of k. Parameters: matrix (list of list of int): 2D array where each element is a positive integer. k (int): Number of elements in the submatrix. Returns: int: The sum of the submatrix with the largest sum or 0 if no such submatrix exists. m, n = len(matrix), len(matrix[0]) if k > m * n: return 0 max_sum = float(\'-inf\') for row_start in range(m): for col_start in range(n): for row_size in range(1, m - row_start + 1): for col_size in range(1, n - col_start + 1): if row_size * col_size == k: current_sum = 0 for i in range(row_start, row_start + row_size): for j in range(col_start, col_start + col_size): current_sum += matrix[i][j] max_sum = max(max_sum, current_sum) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"Given a non-empty string `s`, you may delete at most one character. Judge whether you can make it a palindrome by doing so. A palindrome is a word that reads the same backward as forward. Implement the function `bool validPalindrome(string s)` that returns `true` if the string can be a palindrome after deleting at most one character, otherwise return `false`.","solution":"def validPalindrome(s): Returns True if the string can be a palindrome after deleting at most one character, otherwise returns False. def is_palindrome_range(s, i, j): Check if the substring s[i:j] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try to skip either the left character or the right character and check for palindrome return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"You are tasked with organizing a series of meetings in multiple conference rooms. Each room can be booked for non-overlapping intervals. You are given an array of meeting time intervals, where `intervals[i] = [start, end]` represents the start and end times of the i-th meeting. Write a function that determines the minimum number of conference rooms required to host all the meetings. The intervals are considered inclusive of start and end times, meaning a meeting ending at time t does not overlap with a meeting starting at time t. Implement the function `int minMeetingRooms(int[][] intervals)` that returns the minimum number of conference rooms required.","solution":"def minMeetingRooms(intervals): Determines the minimum number of conference rooms required to host all meetings. Args: intervals (List[List[int]]): A list of meetings, each defined by a start and end time. Returns: int: The minimum number of conference rooms required. if not intervals: return 0 # Separate out the start and end times in separate lists starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) s_ptr, e_ptr = 0, 0 used_rooms = 0 while s_ptr < len(intervals): # A meeting starts if starts[s_ptr] < ends[e_ptr]: used_rooms += 1 s_ptr += 1 else: # A meeting ends e_ptr += 1 s_ptr += 1 return used_rooms"},{"question":"A company needs to manage the team\'s project priorities. Given a list where each element represents a project with a unique positive integer identifier and priority levels from 1 (highest) to 5 (lowest), the task is to reorder the projects such that higher priority projects come before lower priority projects. If two projects have the same priority, they should be ordered by their identifier in ascending order. Return _a list of project identifiers sorted by the described criteria_.","solution":"def prioritize_projects(projects): Reorders projects so that higher priority projects come before lower priority projects. If two projects have the same priority, they are ordered by their identifier in ascending order. Arguments: projects -- a list of tuples where each tuple (id, priority) represents a project\'s identifier and priority level. Returns: A list of project identifiers sorted by the described criteria. return [id for id, priority in sorted(projects, key=lambda x: (x[1], x[0]))]"},{"question":"Given an integer array `nums` of length `n`, find the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to `limit`. Return _the maximum length of such subarray_. # Example ``` Input: nums = [8, 2, 4, 7], limit = 4 Output: 2 Explanation: There are two subarrays with the maximum length (2): [8, 2] and [4, 7]. The absolute difference between any two elements in these subarrays is less than or equal to 4. ```","solution":"from collections import deque def longest_subarray(nums, limit): Find the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to limit. min_deque = deque() max_deque = deque() start = 0 max_length = 0 for end, value in enumerate(nums): while min_deque and nums[min_deque[-1]] >= value: min_deque.pop() while max_deque and nums[max_deque[-1]] <= value: max_deque.pop() min_deque.append(end) max_deque.append(end) while nums[max_deque[0]] - nums[min_deque[0]] > limit: start += 1 if min_deque[0] < start: min_deque.popleft() if max_deque[0] < start: max_deque.popleft() max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given two strings `s1` and `s2` of the same length consisting of lowercase letters. You are allowed to rearrange the order of the characters in `s2`. Write a function that determines if `s2` can be rearranged to be a **substring** of `s1`. Return `true` if it is possible, otherwise return `false`. A **substring** is a contiguous non-empty sequence of characters within a string.","solution":"def can_rearrange_to_substring(s1, s2): Determines if s2 can be rearranged to be a substring of s1. from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 < len_s2: return False s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if window_counter == s2_counter: return True for i in range(len_s2, len_s1): window_counter[s1[i]] += 1 window_counter[s1[i - len_s2]] -= 1 if window_counter[s1[i - len_s2]] == 0: del window_counter[s1[i - len_s2]] if window_counter == s2_counter: return True return False"},{"question":"Given a list of `n` integers, determine if it is possible to rearrange the integers such that every adjacent pair of integers has a greatest common divisor (GCD) of 1. If such an arrangement is possible, return any valid arrangement. If it is not possible, return an empty list.","solution":"import math from collections import deque def is_possible_arrange_gcd_1(arr): Determine if it is possible to rearrange the list such that every adjacent pair has a GCD of 1. :param arr: List of integers :return: A rearranged list with every adjacent pair having a GCD of 1, or an empty list if impossible. def is_coprime_pairwise(arr): for i in range(len(arr) - 1): if math.gcd(arr[i], arr[i + 1]) != 1: return False return True n = len(arr) if n == 1: return arr deq = deque(sorted(arr, reverse=True)) result = [] while deq: result.append(deq.popleft()) if deq and math.gcd(result[-1], deq[0]) != 1: deq.append(deq.popleft()) if is_coprime_pairwise(result): return result else: return []"},{"question":"You are given two sorted integer arrays `nums1` and `nums2`, each of size `n`. The task is to find all the pairs `(i, j)` such that `nums1[i] + nums2[j]` is equal to a given target value `target`. Return the list of all such pairs as an array of tuples. If there are no such pairs, return an empty list. Each pair should be represented as `(i, j)`, where `i` is the index in `nums1` and `j` is the index in `nums2`.","solution":"def find_pairs(nums1, nums2, target): Finds all pairs (i, j) such that nums1[i] + nums2[j] equals the target. Parameters: nums1 (list of int): First sorted list of integers. nums2 (list of int): Second sorted list of integers. target (int): Target sum for the pairs. Returns: list of tuples: List of pairs (i, j) where nums1[i] + nums2[j] == target. pairs = [] for i in range(len(nums1)): for j in range(len(nums2)): if nums1[i] + nums2[j] == target: pairs.append((i, j)) return pairs"},{"question":"You are given a list of integers representing a collection of diamonds, where each integer corresponds to the weight of a particular diamond. Your goal is to pair up the diamonds into pairs such that each pair contains exactly two diamonds and the absolute difference between their weights does not exceed a given threshold `k`. Each diamond can be used in at most one pair. Return the maximum number of pairs you can form under these conditions. For example, given the list of diamonds `[1, 3, 5, 9, 11]` and a threshold `k = 2`, the valid pairs are `(1, 3)`, `(5, 3)`, and `(9, 11)`, which maximizes the number of pairs formed.","solution":"def max_pairs(diamonds, k): Given a list of integers representing diamond weights and a threshold k, returns the maximum number of pairs formed such that the absolute difference between their weights does not exceed k. diamonds.sort() paired = [False] * len(diamonds) pairs = 0 for i in range(len(diamonds)): if paired[i]: continue for j in range(i + 1, len(diamonds)): if not paired[j] and abs(diamonds[i] - diamonds[j]) <= k: paired[i] = paired[j] = True pairs += 1 break return pairs"},{"question":"You are given a list of tasks, where each task is represented as a tuple (start, end), indicating the start and end times of the task. Your goal is to determine if a person can attend all tasks without any overlap. Implement the `canAttendAllTasks` function: * `canAttendAllTasks(List<Tuple<Integer, Integer>> tasks)` returns `true` if a person can attend all the given tasks without any overlap, otherwise returns `false`. For example: - Input: tasks = `[(1, 3), (2, 4), (3, 5)]` - Output: `false` - Input: tasks = `[(1, 2), (2, 3), (3, 4)]` - Output: `true` **Note:** Assume that a task ending at time `t` and another task starting at time `t` do not overlap.","solution":"def canAttendAllTasks(tasks): Determines if a person can attend all tasks without any overlap. :param tasks: List of tuples where each tuple represents (start, end) of a task. :return: True if a person can attend all given tasks without any overlap, False otherwise. # First, sort the tasks by their start times tasks.sort(key=lambda x: x[0]) # Traverse through sorted tasks and check for overlaps for i in range(1, len(tasks)): # End time of the previous task prev_end = tasks[i-1][1] # Start time of the current task curr_start = tasks[i][0] # If the end of a task is greater than the start of the next, they overlap if prev_end > curr_start: return False return True"},{"question":"Given a 2D grid of integers where each cell contains either a 0 or a 1, write an algorithm to determine the number of distinct islands in the grid. An island is a group of 1\'s connected 4-directionally (horizontal or vertical) and is surrounded by water (0s). Two islands are considered distinct if one island\'s shape cannot be translated (shifted) or rotated to match the other island\'s shape. Return the total number of distinct islands.","solution":"def numDistinctIslands(grid): Function to determine the number of distinct islands in a given 2D grid. :param grid: List of List of integers (2D grid) :return: Integer (number of distinct islands) def dfs(x, y, base_x, base_y, current_shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark the cell as visited current_shape.append((x - base_x, y - base_y)) # Explore all 4 directions dfs(x + 1, y, base_x, base_y, current_shape) dfs(x - 1, y, base_x, base_y, current_shape) dfs(x, y + 1, base_x, base_y, current_shape) dfs(x, y - 1, base_x, base_y, current_shape) distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: current_shape = [] dfs(i, j, i, j, current_shape) distinct_islands.add(tuple(current_shape)) return len(distinct_islands)"},{"question":"You are given a string `s` consisting of only letters \'a\' and \'b\'. You can perform the following operation on the string: For every occurrence of the substring \\"ab\\", you can either replace all occurrences of \\"ab\\" with \\"ba\\" or remove all occurrences of \\"ab\\" from the string. Return the _minimum number of operations needed to make the string consist of only one type of letter_.","solution":"def min_operations(s): Returns the minimum number of operations needed to make the string consist of only one type of letter. :param s: A string consisting of only \'a\' and \'b\' :return: The minimum number of operations a_count = s.count(\'a\') b_count = s.count(\'b\') # No operation is needed if the string already consists of only one type of letter if a_count == 0 or b_count == 0: return 0 # We need one operation to replace or remove each remaining \'a\' or \'b\' to make the string uniform. return min(a_count, b_count)"},{"question":"A game consists of `n` levels, each with an associated difficulty level represented by the array `difficulties`. To move from one level to the next, a player must solve a puzzle. The time taken to solve the puzzle at level `i` is given by `solveTime[i]`. The player has `t` units of time to complete the game. Implement a function that determines the maximum number of levels the player can complete within the given time `t`. If it is not possible to complete any level, return 0.","solution":"def max_levels(difficulties, solveTime, t): Returns the maximum number of levels a player can complete within the given time t. # Combine difficulties and solveTime into a list of tuples levels = list(zip(difficulties, solveTime)) # Sort levels by solveTime (ascending order) levels.sort(key=lambda x: x[1]) time_spent = 0 levels_completed = 0 for level in levels: if time_spent + level[1] <= t: time_spent += level[1] levels_completed += 1 else: break return levels_completed"},{"question":"Given an undirected graph with `n` nodes labeled from `0` to `n - 1` represented by a list of edges. Each edge is a pair of nodes represented by an array `[u, v]`. Return _the number of connected components in the graph_. A **connected component** is a subset of nodes such that there is a path between any two nodes in this subset.","solution":"def count_components(n, edges): Returns the number of connected components in an undirected graph. :param n: Number of nodes :param edges: List of edges where each edge is represented by a list [u, v] :return: Number of connected components def dfs(node, visited, adj_list): stack = [node] while stack: currentNode = stack.pop() for neighbor in adj_list[currentNode]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * n count = 0 for i in range(n): if not visited[i]: visited[i] = True count += 1 dfs(i, visited, adj_list) return count"},{"question":"You are given two strings `s` and `t`. Write a function that determines if `s` can be transformed into `t` using the following operation any number of times: choose any character from `s` and change it to any other character. Return `true` if `s` can be transformed into `t` and `false` otherwise.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t using the operation of changing any character from s to any other character any number of times. Args: s (str): source string t (str): target string Returns: bool: True if s can be transformed into t, False otherwise if len(s) != len(t): return False return sorted(s) == sorted(t)"},{"question":"A robotic vacuum cleaner is tasked with cleaning an obstacle-filled room. The room is represented as a two-dimensional grid of size `m x n`, where each cell can either be empty (0) or contain an obstacle (1). The vacuum cleaner initially starts at the top-left corner of the room (i.e., cell (0, 0)) and it is only able to move right or down one cell at a time. Determine if the vacuum cleaner can successfully reach the bottom-right corner of the room (i.e., cell (m-1, n-1)). If it is possible, return `true`. Otherwise, return `false`.","solution":"def can_reach_end(grid): This function determines if the vacuum can reach the bottom-right corner of the room. Args: grid (list): a two-dimensional list representing the room. Returns: bool: True if the vacuum can reach the bottom-right corner, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # right, down def dfs(x, y): if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: # Mark the cell as visited grid[nx][ny] = -1 if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"You are provided with a list of strings `operations` where each string represents a specific mathematical operation to be performed on a counter that starts at 0. The operations can be as follows: - `\\"+\\"` : Increment the counter by 1. - `\\"-\\"` : Decrement the counter by 1. - `\\"++\\"` : Increment the counter by 2. - `\\"--\\"` : Decrement the counter by 2. Return the final value of the counter after performing all the operations in the list.","solution":"def final_counter_value(operations): Computes the final value of a counter starting at 0 after performing the given operations. Parameters: operations (list of str): List of operations to perform, where each operation is one of \\"+\\", \\"-\\", \\"++\\", \\"--\\". Returns: int: The final value of the counter. counter = 0 for operation in operations: if operation == \\"+\\": counter += 1 elif operation == \\"-\\": counter -= 1 elif operation == \\"++\\": counter += 2 elif operation == \\"--\\": counter -= 2 return counter"},{"question":"Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array. The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. You may assume that `nums1` has a size equal to `m + n` such that it has enough space to hold additional elements from `nums2`. Provide a function that does the in-place merge and returns the sorted `nums1` array.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 into one sorted array in-place. :param nums1: List[int], first sorted array with m initialized elements followed by n empty spaces. :param m: int, number of initialized elements in nums1. :param nums2: List[int], second sorted array with n initialized elements. :param n: int, number of initialized elements in nums2. # Last index of the final sorted array last = m + n - 1 # Compare elements from the end and merge while m > 0 and n > 0: if nums1[m-1] > nums2[n-1]: nums1[last] = nums1[m-1] m -= 1 else: nums1[last] = nums2[n-1] n -= 1 last -= 1 # Fill nums1 with remaining elements of nums2, if any while n > 0: nums1[last] = nums2[n-1] n -= 1 last -= 1 return nums1"},{"question":"You are given a string `s` consisting only of lowercase letters. Your task is to determine the **longest palindromic subsequence** in `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A palindrome is a sequence that reads the same backwards as forwards. Implement a function `int longestPalindromeSubseq(String s)` that returns the length of the longest palindromic subsequence in `s`.","solution":"def longestPalindromeSubseq(s): Returns the length of the longest palindromic subsequence in s. n = len(s) dp = [[0] * n for _ in range(n)] # A single character palindrome length is 1 for i in range(n): dp[i][i] = 1 # Compute the longest palindromic subsequence length for length in range(2, n + 1): # Subsequence lengths from 2 to n for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"You are given a string `s` consisting of lowercase Latin letters. A \\"good\\" substring is defined as a substring that contains no repeated characters. Your task is to find the length of the longest \\"good\\" substring in `s`. A substring is defined as a contiguous sequence of characters within the string.","solution":"def length_of_longest_good_substring(s): Returns the length of the longest good substring in s. n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given two strings, `s` and `t`. You can perform operations to transform `s` into `t` by deleting any number of characters and inserting any number of characters at any position in `s`. Return the minimum number of operations required to transform `s` into `t`. An optimal solution involves calculating the minimum number of insertions and deletions required.","solution":"def min_operations(s, t): Returns the minimum number of operations required to transform s into t. Operations include insertions and deletions. # Calculate the length of the longest common subsequence (LCS) def lcs(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_length = lcs(s, t) deletions = len(s) - lcs_length insertions = len(t) - lcs_length return deletions + insertions"},{"question":"A delivery company has `n` delivery hubs and `m` delivery routes. Each delivery route `i` connects delivery hubs `u` and `v` and takes `time[i]` minutes to travel. Your task is to write a function that returns the **minimum time** it would take for a delivery truck to travel from a given starting hub to every other hub, using the provided routes. If a hub is unreachable from the starting hub, return `-1` for that hub. *Note*: The input consists of `(n, m, start, routes)` where `n` is the number of hubs, `m` is the number of routes, `start` is the starting hub, and `routes` is a list of tuples (u, v, time). Each tuple represents a bidirectional route.","solution":"import heapq def delivery_minimum_time(n, m, start, routes): Returns the minimum time it would take for a delivery truck to travel from a given starting hub to every other hub. If a hub is unreachable from the starting hub, return -1 for that hub. :param n: Number of delivery hubs :param m: Number of delivery routes :param start: Starting hub :param routes: List of tuples (u, v, time) representing bidirectional routes :return: List of minimum travel times from start hub to each hub # Create the adjacency list for the graph graph = {i: [] for i in range(n)} for u, v, time in routes: graph[u].append((v, time)) graph[v].append((u, time)) # Initialize the minimum time to reach each node as infinity min_time = [float(\'inf\')] * n min_time[start] = 0 # Priority queue to store the (travel time, hub) pairs pq = [(0, start)] heapq.heapify(pq) while pq: current_time, u = heapq.heappop(pq) if current_time > min_time[u]: continue for v, time in graph[u]: new_time = current_time + time if new_time < min_time[v]: min_time[v] = new_time heapq.heappush(pq, (new_time, v)) # Convert unreachable nodes to -1 return [time if time != float(\'inf\') else -1 for time in min_time]"},{"question":"A group of friends is going on a road trip and they plan to visit `n` different cities. They want to start the trip in one of the cities and visit each city exactly once before returning to the starting city. Given a 2D integer array `distances` where `distances[i][j]` represents the distance between city `i` and city `j`, return _the minimum distance they need to travel to complete the trip_. **Note:** You can assume that the sum of the distances for all possible routes will fit within the bounds of an integer.","solution":"from itertools import permutations def min_travel_distance(distances): Returns the minimum distance required to travel to all cities starting and ending in the same city, visiting each city exactly once. distances: 2D integer array representing distances between cities n = len(distances) cities = range(n) min_distance = float(\'inf\') for perm in permutations(cities): current_distance = 0 for i in range(n): current_distance += distances[perm[i]][perm[(i + 1) % n]] min_distance = min(min_distance, current_distance) return min_distance"},{"question":"You are given a list of `people` represented as an array of dictionaries. Each dictionary contains two keys: \\"name\\" (a string) and \\"height\\" (an integer). An example dictionary is `{\\"name\\": \\"John\\", \\"height\\": 180}`. Write a function that returns the list of dictionaries sorted in descending order by height. If two people have the same height, maintain their original order in the list.","solution":"def sort_people_by_height(people): Sorts a list of people dictionaries by height in descending order. If two people have the same height, maintains their original order. Args: people (list): List of dictionaries each having two keys: \'name\' and \'height\'. Returns: list: Sorted list of dictionaries by height in descending order. return sorted(people, key=lambda x: x[\'height\'], reverse=True)"},{"question":"Given an integer array `arr` and an integer `k`, implement a function `rotateRight` to rotate the array to the right by `k` steps, where `k` is non-negative. A right rotation means that each element of the array is shifted to the right by one position, and the last element is moved to the first position. Return the modified array after performing the rotation. ```python def rotateRight(arr: List[int], k: int) -> List[int]: # Your code here ```","solution":"from typing import List def rotateRight(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"You are given a **0-indexed** array `plans` of length `n` where `plans[i]` indicates the number of steps required to finish the i-th project. Every project has a different start and end time, but you can work on them simultaneously. Your task is to determine the total number of steps you will be able to complete if you must strictly work on exactly one project at a time. Return _the maximum number of steps you can complete from different projects in the given period_. If it is not possible to complete any project, return `-1`.","solution":"def max_steps(plans): Determines the maximum number of steps that can be completed from different projects. :param plans: List[int] - list where plans[i] indicates the number of steps required for the i-th project :return: int - maximum number of steps that can be completed from different projects within the given period if not plans: return -1 completed_steps = 0 for steps in plans: if steps > 0: completed_steps += steps return completed_steps if completed_steps > 0 else -1"},{"question":"You are given a 2D grid representing a garden, each cell of which contains an integer. The integers represent the height of the plants in the garden. You need to determine the largest possible perimeter of a rectangular region where all the heights of the plants in that region are the same. Return the perimeter of that region.","solution":"def largest_perimeter(grid): Determines the largest possible perimeter of a rectangular region where all the heights of the plants in that region are the same. rows = len(grid) cols = len(grid[0]) def calculate_perimeter(r1, c1, r2, c2): Calculates the perimeter of a rectangle defined by its top-left and bottom-right corners. height = grid[r1][c1] for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): if grid[i][j] != height: return 0 return 2 * ((r2 - r1 + 1) + (c2 - c1 + 1)) max_perimeter = 0 for r1 in range(rows): for c1 in range(cols): for r2 in range(r1, rows): for c2 in range(c1, cols): max_perimeter = max(max_perimeter, calculate_perimeter(r1, c1, r2, c2)) return max_perimeter"},{"question":"You have a string `s` consisting of lowercase alphabetic characters. You can perform the following operation as many times as you want: Choose any two adjacent characters in the string that are different, and swap them. Determine the **smallest lexicographical order** that can be achieved by performing this operation any number of times. Return the resulting smallest lexicographical string.","solution":"def smallest_lexicographical_order(s): Returns the smallest lexicographical order of the string `s` by swapping any two adjacent characters that are different, any number of times. return \'\'.join(sorted(s))"},{"question":"You are given a list of non-negative integers `arr` and a number `k`. You need to partition the list into `k` subsets such that the sum of elements in each subset are all the same. Return _true_ if such a partitioning is possible, otherwise return _false_.","solution":"def canPartitionKSubsets(arr, k): Determine if array arr can be partitioned into k subsets with equal sum. total_sum = sum(arr) if total_sum % k != 0: return False target = total_sum // k arr.sort(reverse=True) subsets = [0] * k def backtrack(index): if index == len(arr): return all(s == target for s in subsets) for i in range(k): if subsets[i] + arr[index] <= target: subsets[i] += arr[index] if backtrack(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return backtrack(0)"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a land `1` or water `0`. An island is a group of `1`s (land) connected **4-directionally** (horizontal or vertical). Multiple islands may exist, and we determine island \'A\' to be connected to island \'B\' if one of \'A\'s cells is adjacent to one of \'B\'s cells. You need to count the number of distinct islands. Return _the number of distinct islands_ you can form, considering islands with the same shape but different locations as distinct. The islands\' shapes are determined by their size and the relative positions of their land cells.","solution":"def countDistinctIslands(grid): def dfs(x, y, baseX, baseY): # Mark the current cell as visited grid[x][y] = 0 # Initialize the shape with the relative position to the base shape = [(x - baseX, y - baseY)] # Check all 4 directions (up, down, left, right) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: newX, newY = x + dx, y + dy if 0 <= newX < m and 0 <= newY < n and grid[newX][newY] == 1: shape.extend(dfs(newX, newY, baseX, baseY)) return shape def getIslandShape(x, y): # This will store the relative shape of the island shape = dfs(x, y, x, y) # Sort the shape to have a consistent representation return tuple(sorted(shape)) m, n = len(grid), len(grid[0]) visited_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: # Retrieve the consistent shape of the island found shape = getIslandShape(i, j) visited_islands.add(shape) return len(visited_islands)"},{"question":"You are given a list of integers `heights` representing the heights of the students in a class, arranged in a line from left to right. You are also given an integer `k`, which represents the number of steps you can make. In one step, you can pick any student from the line and move them to any position within the same line, rearranging the order of the heights. Your task is to determine the lexicographically smallest sequence of heights possible after performing exactly `k` steps. Return the lexicographically smallest list of heights after `k` steps.","solution":"def smallest_sequence_after_k_steps(heights, k): Returns the lexicographically smallest sequence of heights possible after k steps. n = len(heights) for i in range(n): if k == 0: break smallest_idx = i # Find the smallest value we can move to position i within the next k moves for j in range(i + 1, min(n, i + k + 1)): if heights[j] < heights[smallest_idx]: smallest_idx = j if smallest_idx != i: # Move the smallest found element to position i while smallest_idx > i: heights[smallest_idx], heights[smallest_idx - 1] = heights[smallest_idx - 1], heights[smallest_idx] smallest_idx -= 1 k -= 1 return heights"},{"question":"You are given an integer array `arr` and a sequence of operations `operations`, where each operation is represented as a tuple `(op, x, y)`. Depending on the value of `op`, perform the following actions: - If `op` equals `1`, replace all occurrences of the value `x` in `arr` with `y`. - If `op` equals `2`, insert the value `y` after every occurrence of the value `x` in `arr`. After performing all the operations in sequence, return the modified array.","solution":"def modify_array(arr, operations): for op, x, y in operations: if op == 1: arr = [y if value == x else value for value in arr] elif op == 2: new_arr = [] for value in arr: new_arr.append(value) if value == x: new_arr.append(y) arr = new_arr return arr"},{"question":"Given an integer array `heights` where `heights[i]` represents the height of a person, return the _minimum number of people that must be moved such that all the heights are no longer strictly increasing or strictly decreasing._ In other words, make the sequence non-monotonic with the fewest number of changes.","solution":"def min_people_to_move(heights): Returns the minimum number of people that must be moved such that the heights are no longer strictly increasing or strictly decreasing. n = len(heights) if n < 3: return 0 # Sequence with fewer than 3 elements cannot be strictly increasing or decreasing. increasing = 0 decreasing = 0 for i in range(1, n): if heights[i] > heights[i - 1]: increasing += 1 elif heights[i] < heights[i - 1]: decreasing += 1 if increasing == n - 1 or decreasing == n - 1: return 1 # If entire array is strictly increasing or decreasing. else: return 0 # If array is already non-monotonic."},{"question":"You are given a singly linked list where each node contains an integer value. Implement a function to rearrange the nodes in such a way that all nodes with values less than a given integer `x` come before nodes with values greater than or equal to `x`. The relative order of the nodes in each of the two partitions should be preserved. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): Rearranges nodes in the given singly linked list such that all nodes with values less than x come before nodes with values greater than or equal to x. if not head: return None less_head = ListNode(0) greater_head = ListNode(0) less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # Combine the two lists greater.next = None # End the list properly less.next = greater_head.next # Combine less and greater lists return less_head.next"},{"question":"Given an `n x n` 2D matrix **matrix**, return _the **rotated** matrix by 90 degrees (clockwise)_. You have to rotate the matrix **in-place**, which means you have to modify the input matrix directly. **Do not** allocate another 2D matrix and do the rotation.","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List of List of ints :return: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` integers. Define a segment as a contiguous subarray of `nums`. The *weight* of a segment is defined as the sum of its elements divided by the length of the segment. Return the **maximum weight** of any segment of `nums`. If there are multiple segments with the same maximum weight, return the one that appears first.","solution":"def max_weight_segment(nums): Returns the segment with the maximum weight and its weight. n = len(nums) max_weight = float(\'-inf\') best_segment = [] for i in range(n): for j in range(i, n): segment = nums[i:j+1] weight = sum(segment) / len(segment) if weight > max_weight: max_weight = weight best_segment = segment return best_segment, max_weight"},{"question":"You are given a string `s` representing a list of words separated by spaces. Each word consists of lowercase and uppercase letters. We want to perform case normalization on the words such that the first letter of each word is capitalized and the rest are in lowercase. Write a function called `normalize_sentence` that takes in the string `s`, and returns the sentence with normalized words. Example: - Input: \\"hello WORLD this IS a tEsT\\" - Output: \\"Hello World This Is A Test\\"","solution":"def normalize_sentence(s): Normalizes the sentence such that the first letter of each word is capitalized and the rest are in lowercase. Parameters: s (str): The input string Returns: str: The normalized string return \' \'.join(word.capitalize() for word in s.split())"},{"question":"Given a binary tree, convert it to a **doubly linked list** in-place. The left and right pointers in nodes are to be used as previous and next pointers respectively in the doubly linked list. The order of nodes in the doubly linked list should be the same as the **in-order traversal** of the binary tree. Write a function `TreeNode *convertToDLL(TreeNode *root)` to achieve this. **Example:** ``` Input: 10 / 12 15 / / 25 30 36 40 Output: 25 <-> 12 <-> 30 <-> 10 <-> 36 <-> 15 <-> 40 ``` Note: the function should return the head of the doubly linked list. A TreeNode is assumed to have the following structure: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def convertToDLL(root): Convert a binary tree to a doubly linked list in-place and return the head of the list. if not root: return None # Helper function for in-order traversal def inorder(node): if not node: return inorder(node.left) # Process the current node if inorder.prev is None: inorder.head = node else: node.left = inorder.prev inorder.prev.right = node inorder.prev = node inorder(node.right) inorder.head = None inorder.prev = None inorder(root) return inorder.head"},{"question":"Suppose you are given a binary tree where each node contains a value `0` or `1`. Each root-to-leaf path represents a binary number starting from the most significant bit. Write a function to return the total sum of all root-to-leaf binary numbers. In doing so, consider the binary numbers represented by each path as integers and sum them up.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_path): if not node: return 0 current_path = (current_path << 1) | node.val if not node.left and not node.right: return current_path return dfs(node.left, current_path) + dfs(node.right, current_path) return dfs(root, 0)"},{"question":"Given an integer array `nums`, return the **maximum product** of three distinct elements in the array. Create a function that determines this product by considering various combinations of elements. For instance, given `nums = [1, 2, 3, 4]`, the maximum product would be `24` (2 * 3 * 4). Ensure to handle both positive and negative numbers to get the highest product.","solution":"def maximum_product_of_three(nums): Returns the maximum product of three distinct elements in the array nums. nums.sort() # The maximum product can be either: # 1. Product of the three largest numbers # 2. Product of the two smallest (possibly negative) numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given an `n x n` 2D matrix representing an image, where each element is an integer from 0 to 255 representing the grayscale value of a pixel. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. Do not allocate another 2D matrix to do the rotation. Implement the following function: ```python def rotate(matrix: List[List[int]]) -> None: Rotate the image by 90 degrees (clockwise) in-place. ```","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotate the image by 90 degrees (clockwise) in-place. n = len(matrix) # Transpose the matrix (Convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a string `expression` that includes digits and the operators \'+\', \'-\', \'*\', and \'/\'. This expression contains no parentheses and is a well-formed arithmetic operation. Implement a function to evaluate this expression as a calculator would. The division should truncate towards zero (i.e., integer division). The function should handle the operator precedence and follow the left-to-right sequence for operators of the same precedence. For example, given the expression `\\"3+2*2\\"`, the function should return `7`, since the multiplication must be evaluated before the addition. Given the expression `\\"14-3/2\\"`, the function should return `13` since integer division of `3/2` is `1`, and `14-1` is `13`. Write a function: ```python def evaluate_expression(expression: str) -> int: ``` that computes the result of the given arithmetic expression.","solution":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression without parentheses containing +, -, *, and /. Division should truncate towards zero (integer division). stack = [] current_number = 0 operator = \'+\' for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in \'+-*/\' or i == len(expression) - 1: if operator == \'+\': stack.append(current_number) elif operator == \'-\': stack.append(-current_number) elif operator == \'*\': stack.append(stack.pop() * current_number) elif operator == \'/\': stack.append(int(stack.pop() / current_number)) # Truncate towards zero operator = char current_number = 0 return sum(stack)"},{"question":"You are given an array of integers `nums` where `nums[i]` represents the position of the `i-th` house along a street. There are `n` houses. You need to paint all the houses such that no two adjacent houses have the same color. There are three colors available: red, blue, and green. The cost of painting each house with a certain color is represented by a `cost` array where `cost[i][0]`, `cost[i][1]`, and `cost[i][2]` are the costs of painting house `i` with red, blue, and green respectively. Your task is to calculate the minimum cost to paint all houses. Implement the function `minCost` which takes in the `cost` array and returns the minimum cost to paint all houses.","solution":"def minCost(cost): Returns the minimum cost to paint all houses such that no two adjacent houses have the same color. :param cost: List[List[int]] where cost[i][0], cost[i][1], and cost[i][2] are the costs of painting house i with red, blue, and green respectively. :return: the minimum cost to paint all the houses if not cost: return 0 n = len(cost) previous_cost = cost[0] for i in range(1, n): current_cost = [0] * 3 current_cost[0] = cost[i][0] + min(previous_cost[1], previous_cost[2]) current_cost[1] = cost[i][1] + min(previous_cost[0], previous_cost[2]) current_cost[2] = cost[i][2] + min(previous_cost[0], previous_cost[1]) previous_cost = current_cost return min(previous_cost)"},{"question":"You are given an integer array `heights` representing the heights of students in a class. The array is arranged in any random order. Your task is to sort the students such that everyone\'s height is in non-decreasing order. Return the sorted array of heights. Note that the same age may appear more than once, and you should preserve the relative order of students with the same height.","solution":"def sort_heights(heights): Sorts the given array of heights in non-decreasing order. Parameters: heights (list of int): List containing the heights of students. Returns: list of int: Sorted list of heights in non-decreasing order. return sorted(heights)"},{"question":"Given a set of non-overlapping intervals `intervals` where each interval is represented as a pair of integers `[start, end]` (both inclusive), determine if a new interval `newInterval` can be inserted into `intervals` without overlapping any of the existing intervals. Return `true` if the new interval can be inserted, and `false` otherwise. The intervals in `intervals` are sorted by their start time.","solution":"def can_insert_interval(intervals, new_interval): Determines if a new interval can be inserted into the intervals list without overlapping. Args: intervals: List of non-overlapping intervals sorted by their start time. new_interval: The new interval to be inserted. Returns: Boolean value indicating if the new interval can be inserted without overlapping. for interval in intervals: if not (new_interval[1] < interval[0] or new_interval[0] > interval[1]): return False return True"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n - 1`, where each node represents a city. The graph is represented by a 2D integer array `edges` where `edges[i] = [fromi, toi]` indicates that there is a one-way road from city `fromi` to city `toi`. A **shipment** can travel from city `a` to city `b` if there is a path of one or more roads connecting `a` to `b`. Return _the number of cities from which it is possible to reach all other cities_.","solution":"def num_cities_reaching_all(n, edges): def dfs(graph, visited, node): stack = [node] while stack: cur_node = stack.pop() visited.add(cur_node) for neighbor in graph[cur_node]: if neighbor not in visited: stack.append(neighbor) # Convert edges list to adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) count = 0 for i in range(n): visited = set() dfs(graph, visited, i) if len(visited) == n: count += 1 return count"},{"question":"You are given a string `s` and an integer `x`. Your task is to modify `s` by changing exactly `x` of its characters to any lowercase English letter such that the resulting string is a palindrome. A **palindrome** is a string that reads the same forward and backward. Return _the **minimum** possible number of character positions in `s` that need to be changed to make it a palindrome_.","solution":"def min_changes_to_make_palindrome(s, x): Returns the minimum number of character changes required to make the input string `s` a palindrome. Only up to `x` changes are allowed. n = len(s) changes_needed = 0 # count the number of changes needed to make the string a palindrome for i in range(n // 2): if s[i] != s[n - i - 1]: changes_needed += 1 return min(changes_needed, x)"},{"question":"Given an `n x n` matrix representing a Sudoku board, write a function to determine if the board is valid. The Sudoku board could be partially filled, where empty cells are represented by the character `\'.\'`. A valid Sudoku board (partially filled) is not necessarily solvable, but it must satisfy the following rules: 1. Each row must contain the digits `1-9` without repetition. 2. Each column must contain the digits `1-9` without repetition. 3. Each of the nine `3x3` sub-boxes of the grid must contain the digits `1-9` without repetition. The Sudoku board is represented as a 2D array of characters.","solution":"def is_valid_sudoku(board): Returns True if a given board represents a valid Sudoku board, otherwise False. # Initialize data structures to keep track of digits rows = [set() for _ in range(9)] columns = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num == \'.\': continue # Check row if num in rows[i]: return False rows[i].add(num) # Check column if num in columns[j]: return False columns[j].add(num) # Check box box_index = (i // 3) * 3 + (j // 3) if num in boxes[box_index]: return False boxes[box_index].add(num) return True"},{"question":"Given an array of integers `nums`, each representing a stick length, return the maximum perimeter of a triangle that can be formed with three of these stick lengths. If no valid triangle can be formed, return 0. To form a valid triangle, the sum of any two sides must be greater than the third side.","solution":"def max_perimeter_triangle(nums): Returns the maximum perimeter of a triangle that can be formed with three of these stick lengths. If no valid triangle can be formed, returns 0. nums.sort(reverse=True) for i in range(len(nums) - 2): if nums[i] < nums[i + 1] + nums[i + 2]: return nums[i] + nums[i + 1] + nums[i + 2] return 0"},{"question":"Given a singly linked list `head`, return the list after reversing the nodes in k-group. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes at the end should remain as it is.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head # Check if there are at least k nodes left in the linked list. count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given a string `s` containing only characters `\'0\'` and `\'1\'`. A substring is called a **binary substring** if all the characters are **the same**. The **segments** in the string are the contiguous substrings of `\'0\'`s and `\'1\'`s. For example, the string \\"00110011\\" has the following segments: \\"00\\", \\"11\\", \\"00\\", \\"11\\". Return the **minimum** number of segments that need to be removed to make `s` a **binary substring**. In other words, find the minimal number of segments that can be removed such that the remaining string is composed of only one type of character.","solution":"def min_segments_to_remove(s: str) -> int: Returns the minimum number of segments that need to be removed to make `s` a binary substring. if not s: return 0 current_char = s[0] segment_count = 1 for char in s[1:]: if char != current_char: segment_count += 1 current_char = char return segment_count - 1"},{"question":"Given a string `s` which consists of letters from `\'a\'` to `\'z\'` and an integer `n`, determine if it is possible to make the string `s` into a palindrome by removing at most `n` characters. Return `true` if it is possible, otherwise return `false`. A palindrome is a string that reads the same backward as forward.","solution":"def can_make_palindrome(s, n): Determines if a string can be made into a palindrome by removing at most n characters. Args: s (str): The input string consisting of letters from \'a\' to \'z\'. n (int): The maximum number of characters that can be removed. Returns: bool: True if it is possible to make the string s into a palindrome by removing at most n characters, otherwise False. def is_palindrome(s): return s == s[::-1] if is_palindrome(s): return True # Initialize a 2D dp array dp = [[0] * len(s) for _ in range(len(s))] # Fill the dp table for length in range(2, len(s) + 1): # length of the substring for i in range(len(s) - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][len(s) - 1] <= n"},{"question":"You are given a list of integers `nums` representing an elevation map where the width of each bar is 1. The elevation map will be in the form of an array where each number represents the height of the bar at that index. Your task is to compute how much water it can trap after raining. Return _the total amount of trapped water_ in cubic units.","solution":"def trap(height): Calculate the total trapped water in cubic units given an elevation map. :param height: List[int] : A list of non-negative integers representing the elevation map. :return: int : The total trapped water in cubic units. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given an integer array `A`, rotate the array to the right by `k` steps, where `k` is non-negative. Return the modified array after rotation.","solution":"def rotate_array(A, k): Rotates the array A to the right by k steps. if not A or k <= 0: return A n = len(A) k = k % n # In case k is greater than the array length return A[-k:] + A[:-k]"},{"question":"You are given a string expression containing numbers and the operators \'+\', \'-\', \'*\', and \'/\'. Evaluate the expression and return the result as an integer. The given expression is in infix notation, and every operation is guaranteed to be a valid integer arithmetic operation according to standard precedence rules, i.e., multiplication and division have higher precedence over addition and subtraction and are evaluated left to right, and the same goes for addition and subtraction. Note that the given expression does not have any parentheses to alter the precedence rules.","solution":"def evaluate_expression(expression: str) -> int: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return int(a / b) # to ensure the result is an integer def compute_values(values, operators): b = values.pop() a = values.pop() op = operators.pop() values.append(apply_op(a, b, op)) values = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): compute_values(values, operators) operators.append(expression[i]) i += 1 while operators: compute_values(values, operators) return values[0]"},{"question":"You are given a string `s` and an array `queries` where each query is a pair of integers `[left, right]`. For each query, determine the number of distinct characters in the substring of `s` that starts at index `left` and ends at index `right` (both inclusive). Return a list of integers where each integer is the answer to the corresponding query.","solution":"def distinct_chars_in_substrings(s, queries): Returns a list of integers where each integer is the number of distinct characters in the substring of s defined by the corresponding query. Parameters: s (str): the input string queries (List[Tuple[int, int]]): list of queries where each query is a tuple (left, right) Returns: List[int]: List of integers representing the number of distinct characters for each query result = [] for left, right in queries: substring = s[left:right+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"Implement a function to identify all the starting indices of substrings in a given string `s` that are anagrams of a given string `p`. Both strings consist of lowercase English letters. The output should be a list of all starting indices in `s` where the substring is an anagram of `p`. The order of output does not matter. _Tip: An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once._","solution":"def find_anagrams(s, p): Returns a list of starting indices of substrings in `s` that are anagrams of `p`. from collections import Counter p_count = Counter(p) s_count = Counter(s[:len(p)-1]) result = [] p_length = len(p) for i in range(len(p)-1, len(s)): s_count[s[i]] += 1 # include a new char in the window if s_count == p_count: # Check if current window is an anagram of p result.append(i - p_length + 1) s_count[s[i - p_length + 1]] -= 1 # remove the first char of the window if s_count[s[i - p_length + 1]] == 0: del s_count[s[i - p_length + 1]] # clean up our counter return result"},{"question":"Given a **0-indexed** integer array `scores` representing the scores of players in a game. Each player can form a team with another player. A team is considered valid if the **absolute difference** between the scores of the two players in the team is **at most** a given integer `k`. Return _the **maximum** number of valid teams that can be formed._ Each player can be part of at most one team.","solution":"def max_teams(scores, k): Returns the maximum number of valid teams that can be formed given the scores and the maximum allowed difference k. scores.sort() n = len(scores) i = 0 result = 0 while i < n - 1: if abs(scores[i] - scores[i + 1]) <= k: result += 1 i += 2 # skip the next player as both are in a team now else: i += 1 # move to the next player return result"},{"question":"Given a string `str` that consists of only the characters `\'1\'` and `\'0\'`, find the maximum length of a contiguous substring which contains an equal number of `\'1\'s` and `\'0\'s`. If no such substring exists, return `0`.","solution":"def find_max_equal_substring_length(s): Returns the maximum length of a contiguous substring which contains an equal number of \'1\'s and \'0\'s. count_map = {0: -1} max_length = 0 count = 0 for idx, char in enumerate(s): if char == \'1\': count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, idx - count_map[count]) else: count_map[count] = idx return max_length"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of columns in a histogram where the width of each column is `1`. The histogram spans from `left` to `right` in order. A rectangle in the histogram is defined by choosing some `left` column and a `right` column, such that all columns between `left` and `right` inclusive should have a height of at least the height of the shortest column in the chosen range. Return _the **area** of the largest rectangle in the histogram_. For example, given `heights = [2,1,5,6,2,3]`, the largest rectangle has an area of `10` units.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram. if not heights: return 0 max_area = 0 stack = [] for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"You are given a string `s` consisting of only lowercase English letters. You can rearrange the characters of the string in any order and determine the **longest substring** that would occur at least twice in the rearranged string. Return _the length of that longest substring_ that appears **at least twice**. If no such substring exists, return `0`. The length of string `s` will not exceed `10^4`.","solution":"def longest_repeated_substring_length(s): Returns the length of the longest substring that appears at least twice in any rearranged version of the input string. # Check if the length of s is less than 2 (no repeated substrings possible) if len(s) < 2: return 0 # Initialize a dictionary to count the frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Calculate the maximum possible length of the repeated substring max_length = 0 for char in char_count: # Only consider characters that appear at least twice if char_count[char] > 1: max_length += char_count[char] // 2 return max_length if max_length > 0 else 0"},{"question":"Given an integer array `nums` of length `n` where all the elements are distinct, you need to find the **next permutation** of `nums` in **lexicographical order**. The next permutation of an array of integers is the next lexicographically greater permutation of its integer elements. If no such permutation exists, it rearranges `nums` as the lowest possible order (i.e., sorted in ascending order). You must implement an algorithm that runs in `O(n)` time complexity. Return _the transformed array_ in place.","solution":"def next_permutation(nums): Modifies nums in-place to the next lexicographical permutation. If no such permutation exists, rearranges nums to the smallest possible order. n = len(nums) # Step 1: Find the largest index \'i\' such that nums[i] < nums[i + 1]. # If no such index exists, the permutation is the last permutation. i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # If the entire array is not in non-increasing order # Step 2: Find the largest index \'j\' greater than \'i\' such that nums[i] < nums[j] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap nums[i] with nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the sub-array from nums[i + 1] to the end to get the next smallest lexicographic order nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"In a social networking service, people are represented by integers from 0 to n-1. There is a directed friendship relation from person `a` to person `b` if `friendships[a][b]` is true. Two people, `a` and `b`, are considered as mutual friends if there is a path from `a` to `b` and a path from `b` to `a`. Given the `n x n` matrix `friendships` where `friendships[i][j]` indicates if person `i` is friends with person `j`, return the total number of mutual friendships in the network. Note that the relation is not necessarily symmetric, i.e., `friendships[a][b]` does not imply `friendships[b][a]`.","solution":"def count_mutual_friendships(friendships): Returns the total number of mutual friendships in the network. Parameters: friendships (list of list of bool): The adjacency matrix indicating friendships. Returns: int: The number of mutual friendships. n = len(friendships) mutual_friendships = 0 for a in range(n): for b in range(n): if friendships[a][b] and friendships[b][a]: mutual_friendships += 1 # Since each mutual friendship is counted twice, divide the result by 2 return mutual_friendships // 2"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from `1` to `n`. The task is to flip the binary tree to create a mirror image of the original tree. After flipping, return the root node of the flipped tree. A binary tree flip means converting the left subtree into the right subtree and the right subtree into the left subtree, recursively, for all the nodes in the tree. Write a function `flipBinaryTree(TreeNode* root)` that performs this operation. Note: 1. The binary tree is represented using a `TreeNode` class where `TreeNode.val` represents the value of the node, `TreeNode.left` is the left child, and `TreeNode.right` is the right child. 2. You may assume that the nodes are structured properly according to the definition of binary trees. 3. You should write the function to flip the binary tree in-place without using additional space, except for the recursive stack.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flipBinaryTree(root): Flip the binary tree to create a mirror image of the original tree. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the flipped binary tree. if root is None: return None # Recursively swap left and right subtrees left_flipped = flipBinaryTree(root.right) right_flipped = flipBinaryTree(root.left) root.left = left_flipped root.right = right_flipped return root"},{"question":"Given a string `s` that consists of only the characters `\'a\'`, `\'b\'`, and `\'c\'`, determine the length of the **longest substring** that can be formed such that all characters in the substring are unique. Note that the substring may not contain repeated characters. Return the length of the longest possible substring with unique characters.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with unique characters in the given string s. The string s consists of only characters \'a\', \'b\', and \'c\'. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an array of integers and an integer `k`. Your task is to modify the array such that it contains exactly `k` different integers. In order to achieve this, you are allowed to delete elements from the array. Find the minimum number of deletions required to achieve the goal. If it is not possible to achieve exactly `k` different integers, return `-1`. ```python def min_deletions(nums, k): # Your code here ```","solution":"def min_deletions(nums, k): from collections import Counter if k > len(nums): return -1 freq_map = Counter(nums) unique_elements = len(freq_map) if unique_elements < k: return -1 if unique_elements == k: return 0 freq_list = sorted(freq_map.values()) deletions = 0 while unique_elements > k: deletions += freq_list.pop(0) unique_elements -= 1 return deletions"},{"question":"You are given an integer array `nums`. Write a function to determine whether removing a single element from the array can make the resulting array strictly increasing. The resulting array should have no elements equal to or decreasing relative to the previous element. Return `true` if it is possible to achieve this by removing exactly one element, otherwise return `false`.","solution":"def can_be_strictly_increasing(nums): Determines whether removing one element can make the array strictly increasing. Args: nums (List[int]): An array of integers. Returns: bool: True if possible to make array strictly increasing by removing one element, otherwise False. def is_strictly_increasing(arr): for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: return False return True for i in range(len(nums)): if is_strictly_increasing(nums[:i] + nums[i+1:]): return True return False"},{"question":"You are given two strings `s` and `t`, you need to transform string `s` into string `t` by performing exactly one operation: choose a non-empty substring in `s` and rearrange the characters within that substring in any order. Return _true_ if it is possible to transform `s` into `t` by performing exactly one operation, and _false_ otherwise.","solution":"def can_transform(s, t): Determine whether you can transform string s into string t by rearranging one of the substrings in s. Args: s (str): The original string. t (str): The target string after one rearrangement. Returns: bool: True if s can be transformed into t by rearranging exactly one substring, False otherwise. # Early exit if lengths are not equal if len(s) != len(t): return False # Count character frequencies count_s = {} count_t = {} for char in s: if char in count_s: count_s[char] += 1 else: count_s[char] = 1 for char in t: if char in count_t: count_t[char] += 1 else: count_t[char] = 1 # The strings must have the same character counts return count_s == count_t"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to partition the array into exactly `k` non-empty contiguous subarrays such that the sum of the averages of each subarray is maximized. Return _the maximum sum of the averages, rounded to five decimal places_. A contiguous subarray must contain at least one element, and the sum of the averages is calculated as follows: [ text{sum_of_averages} = frac{text{sum(subarray1)}}{text{size(subarray1)}} + frac{text{sum(subarray2)}}{text{size(subarray2)}} + ldots + frac{text{sum(subarrayk)}}{text{size(subarrayk)}} ] The partition should aim to provide the largest possible value for the sum of these averages.","solution":"def largest_sum_of_averages(nums, k): Returns the maximum sum of the averages when partitioning the array nums into k non-empty contiguous subarrays. # Initialize sums array to store cumulative sums n = len(nums) sums = [0] * (n + 1) for i in range(n): sums[i + 1] = sums[i] + nums[i] # Initialize dp array where dp[i][k] represents the maximum sum of averages we can get by partitioning # the first i elements into k parts dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][1] = sums[i] / i for j in range(2, k + 1): for i in range(j, n + 1): for x in range(j - 1, i): dp[i][j] = max(dp[i][j], dp[x][j - 1] + (sums[i] - sums[x]) / (i - x)) return round(dp[n][k], 5)"},{"question":"Given a string `s` of length `n`, consisting of lowercase English letters, return the length of the longest subarray that contains at most `k` distinct characters. For example, if `s = \\"eceba\\"` and `k = 2`, the longest subarray is `\\"ece\\"` with a length of 3. You need to implement a function `int longestSubarrayWithKDistinct(String s, int k)` that achieves this in O(n) time complexity.","solution":"def longestSubarrayWithKDistinct(s, k): from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_map = defaultdict(int) while right < n: char_map[s[right]] += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given an integer array `stations` where `stations[i]` represent the amount of fuel available at the `ith` fuel station, and an integer `distance` representing the total distance to travel from a starting point to a destination. You are also given an integer `initialFuel` representing the initial amount of fuel in your vehicle. You start at the beginning of the array and can move forward one station at a time. At each station, you can refuel your vehicle with the fuel available at that station. You can only move forward if you have enough fuel to do so. Find _the minimum number of fuel stops needed to reach your destination or return -1 if it is not possible to reach the destination with the given conditions_.","solution":"import heapq def minFuelStops(stations, distance, initialFuel): Calculate the minimum number of fuel stops needed to reach the destination. Parameters: stations (List[int]): The list of fuel available at each station. distance (int): The total distance to the destination. initialFuel (int): The initial amount of fuel in the vehicle. Returns: int: The minimum number of fuel stops needed to reach the destination, or -1 if not possible. max_heap = [] fuel = initialFuel stops = 0 idx = 0 n = len(stations) while fuel < distance: # Add all reachable stations to the heap while idx < n and idx + 1 <= fuel: heapq.heappush(max_heap, -stations[idx]) idx += 1 # If no more fuel stations are reachable and destination is not reached if not max_heap: return -1 # Refuel with the most fuel available from the reachable stations fuel += -heapq.heappop(max_heap) stops += 1 return stops"},{"question":"Given a string `s` representing a positive integer, you need to remove k digits from this number such that the new number is the smallest possible. Return the smallest number you can obtain as a string. Note that the returned number should not have any leading zeros unless it is zero itself. For example, given `s = \\"1432219\\"` and `k = 3`, the smallest number would be `\\"1219\\"`.","solution":"def remove_k_digits(s, k): Removes k digits from the string s representing a positive integer such that the new number is the smallest possible. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # Remove any remaining digits if k is not zero while k > 0: stack.pop() k -= 1 # Convert back to string and strip leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \'0\'"},{"question":"You are given a list of `n` strings. Each string in the list consists of lowercase English letters. Determine if multiple strings in the list are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies. Return `true` if there exist at least two strings that are anagrams, otherwise return `false`.","solution":"from collections import defaultdict def has_anagrams(strings): Determines if there are multiple strings in the list that are anagrams of each other. :param strings: List of strings :returns: Boolean indicating if multiple strings are anagrams of each other anagrams = defaultdict(int) for s in strings: # Create a sorted tuple of characters as a key key = tuple(sorted(s)) anagrams[key] += 1 # Check if any anagram group has more than one string for count in anagrams.values(): if count > 1: return True return False"},{"question":"Given an integer array `heights` representing the heights of buildings, return _the number of buildings whose view of the sunset is not obstructed_. A building has an unobstructed view of the sunset if all the buildings to its right are shorter. The buildings in the array are represented from left to right, i.e., from index `0` to index `n-1`.","solution":"def count_unobstructed_views(heights): Returns the number of buildings with an unobstructed view of the sunset. n = len(heights) if n == 0: return 0 max_height = heights[-1] count = 1 for i in range(n-2, -1, -1): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"You have an array of positive integers `arr` representing the sizes of different files. You are tasked with minimizing the time required to merge all the files into a single file. The merging process follows these rules: 1. Each merge operation takes time equal to the sum of the sizes of the files being merged. 2. You can merge any two files into one new file, and the size of the new file is the sum of the sizes of the two files merged. Return the minimum time required to merge all the files into a single file.","solution":"import heapq def min_merge_time(arr): Calculate the minimum time required to merge all files into a single file. Args: arr: List of integers representing the sizes of different files. Returns: int: The minimum time required to merge all files into a single file. if not arr: return 0 heapq.heapify(arr) total_time = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) merge_time = first + second total_time += merge_time heapq.heappush(arr, merge_time) return total_time"},{"question":"You are given a string `s` and a dictionary of strings `wordDict`. Return _the length of the longest substring of `s` that can be constructed by concatenating elements of `wordDict`, allowing each word in `wordDict` to be used multiple times_. The substring must be contiguous and the concatenation order must match the appearance order in the string `s`. Note that you don\'t need to use all the words from `wordDict` and any word can be used any number of times.","solution":"def longest_concat_substring_length(s, wordDict): word_set = set(wordDict) n = len(s) max_len = 0 # Create a DP array to store the longest length dp = [0] * (n+1) for i in range(1, n+1): for j in range(i): if s[j:i] in word_set: dp[i] = max(dp[i], dp[j] + (i - j)) return max(dp)"},{"question":"You are given a `n`-ary tree, which is a tree in which a node can have at most `n` children. Each node is represented as a triple `(val, children, parent)` where `val` is the node\'s value, `children` is a list of child nodes, and `parent` is the node\'s parent node. Implement a function to find the lowest common ancestor (LCA) of two given nodes in the n-ary tree. The LCA of two nodes p and q in a tree is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself).","solution":"class Node: def __init__(self, val, children=None, parent=None): self.val = val self.children = children if children is not None else [] self.parent = parent def lowest_common_ancestor(p, q): Finds the lowest common ancestor (LCA) of two given nodes p and q in an n-ary tree. The LCA of two nodes p and q in a tree is the lowest node that has both p and qas descendants (where we allow a node to be a descendant of itself). path_to_root_p = get_path_to_root(p) path_to_root_q = get_path_to_root(q) # Reverse paths because we traced back to root path_to_root_p.reverse() path_to_root_q.reverse() # Find the LCA lca = None for anc_p, anc_q in zip(path_to_root_p, path_to_root_q): if anc_p == anc_q: lca = anc_p else: break return lca def get_path_to_root(node): path = [] while node: path.append(node) node = node.parent return path"},{"question":"Given a list of `words`, find all pairs of distinct words that, when concatenated, form a palindrome. A palindrome is a word that reads the same backward as forward. Return a list of pairs `(i, j)`, such that the concatenation of `words[i]` and `words[j]` forms a palindrome. Each pair should be listed only once, with the order of pairs not mattering. Example: ``` Input: words = [\\"bat\\", \\"tab\\", \\"cat\\"] Output: [(0, 1), (1, 0)] Explanation: \\"battab\\" and \\"tabbat\\" are palindromes. ```","solution":"def is_palindrome(word): return word == word[::-1] def palindrome_pairs(words): pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): pairs.append((i, j)) return pairs"},{"question":"You are given a string `expression` that consists of digits and operators (`+`, `-`, `*`, `/`). Your task is to evaluate the mathematical expression and return its result as an integer. The expression must be evaluated according to the typical order of operations: 1. Multiplication and division have higher precedence than addition and subtraction. 2. Operators of the same precedence are evaluated from left to right. 3. Assume that the division operator (`/`) always performs integer division. **Note:** You are guaranteed that the given string `expression` is a valid arithmetic expression.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of digits and operators (+, -, *, /). Returns the result as an integer. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] in \'0123456789\': num = 0 while i < len(expression) and expression[i] in \'0123456789\': num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] in \'+-*/\': while (operators and operators[-1] in \'*/\' and expression[i] in \'*/\') or (operators and operators[-1] in \'*/\' and expression[i] in \'+-\') or (operators and operators[-1] in \'+-\' and expression[i] in \'+-\'): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from 1 to `n`. The tree is represented as an array `parents` where `parents[i]` is the parent of the `i-th` node. The root node has `parents[root] = -1`. For each node `u` in the tree, determine the distance to its farthest leaf node, i.e., the **maximum** number of edges in the path from `u` to any leaf node in its sub-tree. Return an array `distances` where `distances[i]` is the distance for the `i-th` node.","solution":"from collections import defaultdict def distance_to_farthest_leaf(n, parents): # Create a tree from the parent array tree = defaultdict(list) root = None for i, p in enumerate(parents): if p == -1: root = i else: tree[p].append(i) # Function to find the height of the tree rooted at a node def height(node): if not tree[node]: # If the node is a leaf return 0 return max(height(child) for child in tree[node]) + 1 distances = [0] * n for i in range(n): distances[i] = height(i) return distances"},{"question":"Given an integer array `nums`, your task is to return the length of the longest zigzag subsequence in the array. A zigzag subsequence is defined as a sequence of numbers where the differences between successive numbers strictly alternate between positive and negative. This means for a subsequence `a1, a2, ..., an`, the difference `(a2 - a1), (a3 - a2), ...` alternates between positive and negative. An empty subsequence is considered a valid zigzag subsequence.","solution":"def longest_zigzag(nums): Function to find the length of the longest zigzag subsequence in an array. if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: up[i] = max(up[i], down[j] + 1) elif nums[i] < nums[j]: down[i] = max(down[i], up[j] + 1) return max(up[n-1], down[n-1])"},{"question":"Suppose you are given a binary tree in which each node contains a value representing a character from \'a\' to \'z\'. Define the path sum of a path in the tree as the concatenation of the characters from the root to a leaf node. Your task is to find the smallest lexicographical string that represents a path sum from the root to a leaf. Given the `root` of such a binary tree, return _a string corresponding to the smallest lexicographical path sum from the root to a leaf node_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def smallest_lexicographical_path_sum(root): Returns the smallest lexicographical path sum from the root to a leaf node in a binary tree. root: TreeNode Root of the binary tree return: str Smallest lexicographical path sum from root to a leaf if not root: return \\"\\" result = [] def dfs(node, path): if node: path += chr(ord(\'a\') + node.value) if not node.left and not node.right: result.append(path) else: dfs(node.left, path) dfs(node.right, path) dfs(root, \\"\\") return min(result) if result else \\"\\""},{"question":"You are given two strings `str1` and `str2` of the same length `n`. You can swap any two characters in `str1` any number of times. Your task is to determine if it is possible to transform `str1` into `str2` using these swaps. Return `true` if it is possible to transform `str1` into `str2`, otherwise return `false`.","solution":"def can_transform(str1, str2): Determines if str1 can be transformed into str2 by any number of swaps. Parameters: - str1: The first string. - str2: The second string. Returns: - A boolean indicating whether str1 can be transformed into str2. # If the two strings have different lengths, transformation is not possible if len(str1) != len(str2): return False # By sorting both strings, we can check if they are permutations of each other return sorted(str1) == sorted(str2)"},{"question":"You are given a list of integers `allergens` representing the instances of different allergens found in a population. Each integer represents a specific type of allergen. A research institute is conducting a study and needs to identify pairs of allergies that are found together in at least one instance. Return _a list of unique pairs_ `[a, b]` _where `allergens[a]` and `allergens[b]` always appear together in the list `allergens`_. The pairs should be returned in **lexicographical order** based on the allergen type. Identify the pairs based on the index positions of the allergens in the given list. **Note:** - The elements in each pair should be distinct. - The pairs should be free of duplication, meaning if the pair `[a, b]` is considered, the pair `[b, a]` should not be included even if it meets the condition.","solution":"from collections import defaultdict def find_allergen_pairs(allergens): # Create a dictionary to store instances where each allergen appears allergen_indices = defaultdict(list) for idx, allergen in enumerate(allergens): allergen_indices[allergen].append(idx) # List to store the unique pairs pairs = set() for indices in allergen_indices.values(): for i in range(len(indices)): for j in range(i + 1, len(indices)): pairs.add((indices[i], indices[j])) # Convert set to sorted list and sort lexicographically by allergen type indices sorted_pairs = sorted(pairs) return sorted_pairs"},{"question":"You are given a rectangular grid of cells, where each cell either contains a `0` (an empty cell) or a `1` (an obstacle). You are also given a starting position `start` and a target position `end` within this grid. You can move up, down, left, or right, but you cannot move through obstacles. Write a function to determine if there is a path from the `start` position to the `end` position. If there is a path, return the shortest path distance (number of moves); if there is no such path, return `-1`. The grid, `start`, and `end` will be provided as inputs to the function.","solution":"from collections import deque def shortest_path(grid, start, end): Determines the shortest path in a grid from start to end position avoiding obstacles. Parameters: grid (List[List[int]]): 2D list representing the grid where 0 is an empty cell and 1 is an obstacle start (Tuple[int, int]): Starting position in the grid as (row, column) end (Tuple[int, int]): Target position in the grid as (row, column) Returns: int: Shortest path distance from start to end position, or -1 if no path exists def is_valid(x, y): Check if the position is within grid bounds and not an obstacle return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 # directions for moving in the grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() # If we\'ve reached the end, return the distance if (x, y) == end: return dist # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If queue is exhausted and end is not reached, return -1 return -1"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return _all possible sentences_ that can be formed by breaking `s` into one or more words present in `wordDict`. Each word in the dictionary can be used multiple times in the segmentation. The input string `s` is in lowercase, and the dictionary words are also in lowercase. You may return the answer in **any order**. Be aware that the same word in the dictionary can be reused multiple times during the segmentation.","solution":"def word_break(s, wordDict): Returns all possible sentences that can be formed by breaking s into one or more words present in wordDict. def backtrack(index): if index == len(s): return [\\"\\"] if index in memo: return memo[index] sentences = [] for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: for sub_sentence in backtrack(end): if sub_sentence: sentences.append(word + \\" \\" + sub_sentence) else: sentences.append(word) memo[index] = sentences return sentences memo = {} return backtrack(0)"},{"question":"You are given a list of `n` people standing in a queue. Each person is described by a pair of integers `(height, k)`, where `height` is the height of the person, and `k` is the number of people in front of this person who have a height greater than or equal to `height`. Write an algorithm to reconstruct the queue such that each person\'s `k` value is accurate based on their position in the queue. Return the queue represented as a list of integer pairs. The order in the original list should be maintained if two people have the same height and `k` value.","solution":"def reconstructQueue(people): Reconstruct the queue represented by a list of people where each person is described by a pair of integers (height, k), where height is the height of the person, and k is the number of people in front of this person who have a height greater than or equal to height. Parameters: people (List[Tuple[int, int]]): List of people described by (height, k). Returns: List[Tuple[int, int]]: Reconstructed queue. # Sort people to position tallest people first, and among them, sort by the k value people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person into the queue based on the k value for person in people: queue.insert(person[1], person) return queue"},{"question":"You are given a string `s` of length `n` comprising only the characters \'a\' and \'b\'. You can choose any substring of `s` and perform the following operation: reverse the substring and replace each \'a\' within it with \'b\' and each \'b\' with \'a\'. After performing the operation any number of times, what is the lexicographically smallest string you can achieve? Return the lexicographically smallest string.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string achievable after performing the operation any number of times on the given string s. # The optimal strategy is to convert the entire string to all \'a\'s or all \'b\'s. # Among those, we choose the lexicographically smaller one. all_a = \'a\' * len(s) all_b = \'b\' * len(s) smallest_string = min(all_a, all_b) return smallest_string"},{"question":"Given an integer `num`, convert it to a string representing its hexadecimal representation. For negative integers, two’s complement method is used. Note that: - All the letters in the hexadecimal representation should be in lowercase. - No leading zeros should be present in the output except for the zero case. Return the hexadecimal representation of `num` as a string.","solution":"def to_hex(num): Converts an integer to a hexadecimal string representation. For negative integers, two’s complement method is used. if num == 0: return \\"0\\" if num < 0: num += 2 ** 32 hex_digits = \\"0123456789abcdef\\" hex_str = \\"\\" while num > 0: hex_str = hex_digits[num % 16] + hex_str num //= 16 return hex_str"},{"question":"Given a matrix of integers of size `m x n`, rotate the matrix 90 degrees clockwise in place. You need to modify the matrix directly without using extra space. Return the modified matrix.","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise in place. :param matrix: List[List[int]] - A 2D list representing the matrix :return: The rotated matrix if not matrix or not matrix[0]: return matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given an array of integers `arr` where each element represents the height of a building. Assume that each building has a width of 1. The goal is to determine the maximum area of a rectangle that can be formed within a contiguous subsequence of buildings. The height of the rectangle is determined by the shortest building in the subsequence, and its width is equal to the number of buildings in the subsequence. Write a function that finds and returns the maximum area of such a rectangle. **Note**: The array may contain up to (10^5) elements.","solution":"def largestRectangleArea(heights): Finds the maximum area of a rectangle that can be formed within a contiguous subsequence of buildings. The height of the rectangle is determined by the shortest building in the subsequence, and its width is equal to the number of buildings in the subsequence. stack = [] max_area = 0 heights.append(0) # Sentinel value to ensure stack is emptied at the end for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"You are given a **0-indexed** array `nums` of `n` integers, each representing a point on the number line. Find and return the minimum number of jumps required to move from the first point to the last point in the array. A jump can be defined as moving from a point at index `i` to any other point within a distance of `nums[i]` on the number line. If it is not possible to reach the last point, return `-1`.","solution":"def minimum_jumps(nums): Returns the minimum number of jumps required to move from the first point to the last point in the array. If it is not possible to reach the last point, return -1. n = len(nums) if n == 0: return -1 jumps = [float(\'inf\')] * n jumps[0] = 0 for i in range(1, n): for j in range(i): if i <= j + nums[j] and jumps[j] != float(\'inf\'): jumps[i] = min(jumps[i], jumps[j] + 1) return jumps[-1] if jumps[-1] != float(\'inf\') else -1"},{"question":"Write a function that takes an integer array `nums` and an integer `k`, and returns the maximum average value of any contiguous subarray of length `k` in `nums`. The function should return the result as a floating-point number.","solution":"def findMaxAverage(nums, k): Returns the maximum average value of any contiguous subarray of length k. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: float - maximum average value n = len(nums) if n < k: return 0.0 # Initialize the sum of the first k elements. max_sum = cur_sum = sum(nums[:k]) # Traverse the array from the k-th element to the end. for i in range(k, n): cur_sum += nums[i] - nums[i - k] if cur_sum > max_sum: max_sum = cur_sum return max_sum / k"},{"question":"You are given a linked list `head`. Each node contains an integer value and a pointer to the next node in the list. Write a function that returns the value of the node where the cycle begins. If there is no cycle, return `null`. A cycle in the linked list means that some node in the list, next pointer points back to a previous node, forming a loop. You must solve the problem using constant extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Returns the node where the cycle begins. If there is no cycle, return None. slow = fast = head # Step 1: Determine if there is a cycle while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break else: # No cycle return None # Step 2: Find the entry to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Given a string `s` containing only lowercase English letters, you need to determine such that the characters of the string must be rearranged to form a **palindrome**. Return `true` _if it is possible to rearrange the string to form a palindrome, otherwise return_ `false`.","solution":"from collections import Counter def can_form_palindrome(s): Given a string s consisting of lowercase English letters, determines if it is possible to rearrange the string to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged into a palindrome, otherwise False. # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if and only if # there is at most one character with an odd number of occurrences. return odd_count <= 1"},{"question":"Imagine you are developing a video game in which you control a character that can walk on a grid. The character starts at the top-left corner of the grid, i.e., `(0, 0)`, and the grid has `m` rows and `n` columns. Some of the cells are blocked and cannot be walked on. You are given a 2D grid `obstacleGrid` where `0` represents a walkable cell and `1` represents a blocked cell. Your task is to return the total number of unique paths from the top-left corner to the bottom-right corner of the grid, i.e., `(m-1, n-1)`, with the restriction that the character can only move either down or right at any point in time.","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. :param obstacleGrid: List[List[int]] :return: int if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given an array of integers `arr` and an integer `n`, determine if there exist two indices `i` and `j` (0 <= i, j < arr.length) such that `i != j` and the absolute difference between `arr[i]` and `arr[j]` is exactly `n`. Return `true` if such indices exist, otherwise return `false`.","solution":"def has_pair_with_difference(arr, n): Returns True if there exist two indices i and j such that i != j and the absolute difference between arr[i] and arr[j] is exactly n. elements = set(arr) for number in arr: if (number + n) in elements or (number - n) in elements: return True return False"},{"question":"Given an integer array `nums` where each integer can appear multiple times but always appears an even number of times, except for one integer which appears an odd number of times. Write a function that finds and returns this single integer that appears an odd number of times. Example: ``` Input: nums = [4, 3, 3, 4, 4] Output: 4 ``` Explanation: - The integer 4 appears three times in the list, which is an odd number of times.","solution":"def find_odd_occurrence(nums): Given a list of integers where each integer appears an even number of times except for one integer which appears an odd number of times, this function returns the integer that appears an odd number of times. Args: nums (list): List of integers Returns: int: The integer that appears an odd number of times result = 0 for num in nums: result ^= num return result"},{"question":"Given an integer array `arr` and an integer `X`, you can perform the following operation any number of times (including zero): * Select any subarray (consecutive elements) of `arr` and increment each element of that subarray by 1. The **cost** of this operation is defined as the length of the subarray. Return the minimum cost to make all elements of `arr` greater than or equal to `X`. If it is impossible, return -1.","solution":"def min_cost_to_reach_x(arr, X): Returns the minimum cost to make all elements of arr greater than or equal to X. If it is impossible, return -1. max_diff = 0 for value in arr: if value >= X: continue max_diff = max(max_diff, X - value) return max_diff if max_diff > 0 else -1"},{"question":"Given a string `s` consisting of lowercase letters and integers, convert every digit in the string into \'0\' if it is even or \'1\' if it is odd. Return the resulting string. Note that the digits may be interspersed with non-digit characters. For example, given the string `s = \\"a1b2c3d4\\"`, the result should be `\\"a1b0c1d0\\"`.","solution":"def convert_digits(s): Converts every digit in the string into \'0\' if it is even or \'1\' if it is odd. Non-digit characters remain unchanged. :param s: A string containing lowercase letters and integers :return: Modified string with converted digits result = [] for char in s: if char.isdigit(): if int(char) % 2 == 0: result.append(\'0\') else: result.append(\'1\') else: result.append(char) return \'\'.join(result)"},{"question":"You are given an array of integers `arr` and an integer `target`. Your goal is to partition `arr` into two non-empty subarrays `left` and `right` such that the absolute difference between the sums of the elements in `left` and `right` is as close to `target` as possible. Return the minimum possible absolute difference between the sum of elements in `left` and the sum of elements in `right` compared to `target`. If there are multiple ways to partition the array, return the smallest result.","solution":"def min_diff_between_partitions(arr, target): This function partitions the array into two non-empty subarrays such that the absolute difference between the sums of the elements in left and right is as close to the target as possible. :param arr: List[int] - the input array of integers :param target: int - the target value for the absolute difference :return: int - the minimum possible absolute difference between the sum of elements in left and right compared to target n = len(arr) total_sum = sum(arr) left_sum = 0 min_diff = float(\'inf\') for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum current_diff = abs(left_sum - right_sum) min_diff = min(min_diff, abs(current_diff - target)) return min_diff"},{"question":"You are given a **0-indexed** integer array `arr` and a **0-indexed** array of queries `queries` where `queries[i] = [Li, Ri]` represents a query asking for the **most frequent** element in the subarray `arr[Li...Ri]`. Return _an array_ `result` _where_ `result[i]` _is the **most frequent** element in the subarray specified by the_ `i-th` _query_. If there is a tie for the most frequent element, return the **smallest** one.","solution":"from collections import Counter def most_frequent_element(arr, queries): Returns an array where each element is the most frequent element in the subarray specified by the corresponding query. If there is a tie, returns the smallest element. result = [] for query in queries: Li, Ri = query subarray = arr[Li:Ri+1] frequency = Counter(subarray) # Find the element with the highest frequency and smallest value in case of ties. most_frequent = min(frequency.items(), key=lambda x: (-x[1], x[0])) result.append(most_frequent[0]) return result"},{"question":"You are given a 0-indexed integer array `nums` and an integer `k`. Find the maximum sum of a **subarray** of length `k`. If the length of the initial array is less than `k`, return `-1`. A subarray is defined as a contiguous sequence of elements within the array. The solution must achieve this in linear time `O(n)`.","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k. If the length of nums is less than k, returns -1. n = len(nums) if n < k: return -1 # Compute the initial window sum max_sum = sum(nums[:k]) window_sum = max_sum # Slide the window over the array for i in range(k, n): window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"You are given a string `s` and an integer `k`. Your goal is to remove exactly `k` characters from the string in such a way that the remaining characters are in non-decreasing order. If it is not possible to make such a modification, return an empty string. If there are multiple ways to achieve this, return the lexicographically smallest one.","solution":"def remove_characters_to_sort(s, k): n = len(s) if k >= n: return \\"\\" stack = [] for i, char in enumerate(s): # Keep removing characters from the stack as long as we can still remove and # the current character is not ordered. while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end while k > 0: stack.pop() k -= 1 return \'\'.join(stack)"},{"question":"You are given `n` cities and `m` roads connecting pairs of the cities. Each road has an associated distance. Your task is to find the minimum distance required to travel from city `A` to city `B` using any combination of roads. However, there are certain conditions for travel: 1. You can only travel on a road if the sum of its distance and the distances of all previous roads taken from city `A` does not exceed a given limit `d`. 2. If it\'s not possible to reach city `B` under these conditions, return `-1`. You need to implement a function `minDistance(int n, int m, int d, List<List<Integer>> roads, int A, int B)` which takes the following parameters: - `n`: The number of cities. - `m`: The number of roads. - `d`: The distance limit. - `roads`: A list of lists, where each list contains three integers `[u, v, w]` representing a road between cities `u` and `v` with a distance of `w`. - `A`: The starting city. - `B`: The destination city. Return the minimum distance required to travel from city `A` to city `B` if possible, otherwise return `-1`.","solution":"import heapq def minDistance(n, m, d, roads, A, B): from collections import defaultdict, deque, namedtuple Road = namedtuple(\'Road\', [\'city\', \'distance\']) graph = defaultdict(list) for u, v, w in roads: graph[u].append(Road(city=v, distance=w)) graph[v].append(Road(city=u, distance=w)) def dijkstra(source, target): heap = [(0, source)] distances = {city: float(\'inf\') for city in range(1, n + 1)} distances[source] = 0 while heap: current_distance, current_city = heapq.heappop(heap) if current_city == target: return current_distance if current_distance > distances[current_city]: continue for road in graph[current_city]: distance = road.distance new_distance = current_distance + distance if new_distance <= d and new_distance < distances[road.city]: distances[road.city] = new_distance heapq.heappush(heap, (new_distance, road.city)) return -1 return dijkstra(A, B)"},{"question":"You are given a 2D matrix `matrix` of integers, where each row is sorted in non-decreasing order from left to right and each column is sorted in non-decreasing order from top to bottom. Given an integer `target`, write a function to search the matrix for this target. If `target` is found, return `true`; otherwise, return `false`. The function should try to find an efficient way to reduce the search space, considering the properties of the sorted matrix. For example, given `matrix = [[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]` and `target = 5`, the function should return `true` because the target exists in the matrix. If `target = 20`, the function should return `false` because the target does not exist in the matrix.","solution":"def search_matrix(matrix, target): Searches for a target value in a 2D matrix where each row and each column is sorted in non-decreasing order. Args: matrix (List[List[int]]): 2D matrix of integers target (int): The target integer to search for Returns: bool: True if the target is found, False otherwise if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 # Move down else: col -= 1 # Move left return False"},{"question":"You are given a linked list where the value of each node is a digit from `0` to `9`. The linked list represents a very large integer. Write a function to add one to this integer and return the updated linked list. You are not allowed to modify the original linked list in any way other than the necessary changes to represent the incremented value.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_one(head): This function adds one to the integer represented by the linked list. :param head: ListNode, the head of the linked list representing the integer :return: ListNode, the head of the updated linked list # A helper function to reverse the linked list def reverse_linked_list(node): prev = None current = node while current: next_node = current.next current.next = prev prev = current current = next_node return prev # Step 1: Reverse the linked list to process from least significant digit head = reverse_linked_list(head) # Step 2: Traverse the reversed list and add one current = head carry = 1 while current and carry: current.val += carry carry = current.val // 10 current.val %= 10 if carry and not current.next: current.next = ListNode(0) current = current.next # Step 3: Reverse the list back to the original order head = reverse_linked_list(head) return head # Helper function to construct linked list from a list of values def construct_linked_list(values): head = current = ListNode(values[0]) for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to a list of values def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values"},{"question":"Given a 2D grid of size `m x n` where each cell represents a plot of land that can either be farmed as crop land represented by `\'C\'`, barren land represented by `\'B\'`, or water represented by `\'W\'`, determine the number of distinct islands of crop land. An island is defined as a group of horizontally or vertically connected crop land (`\'C\'`) plots and is surrounded by either barren land (`\'B\'`) or water (`\'W\'`). Two places are considered connected if they are adjacent horizontally or vertically (but not diagonally). Return _the total number of distinct islands of crop land_ in the grid.","solution":"def num_distinct_islands(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != \'C\' or visited[i][j]: return visited[i][j] = True # Explore the neighbors (up, down, left, right) dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'C\' and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"You are given a list of strings `words` and an integer `n`. Each string in the list represents a word composed of lowercase English letters. You need to return a list of all the words that can be formed by concatenating at least `n` instances of any single character from the list of `words`. For example, if the character \'a\' appears in three different words, it counts as three instances. The solution should be a list of words that are sorted in lexicographical order. If no such word exists, return an empty list.","solution":"def words_with_repeated_chars(words, n): Returns a list of all the words that can be formed by concatenating at least `n` instances of any single character from the list of words. Args: words (list): list of strings where each string is a word composed of lowercase English letters n (int): the minimum instances of any single character Returns: list: a list of words sorted in lexicographical order from collections import Counter # Count total occurrences of each character in all words char_count = Counter() for word in words: char_count.update(word) # Find eligible characters with at least `n` instances eligible_chars = set(char for char in char_count if char_count[char] >= n) # Filter words that can be formed by these eligible characters result = [word for word in words if any(word.count(char) >= n for char in eligible_chars)] result.sort() return result"},{"question":"You are given an array of `n` integers, `nums`, where each element represents the height of a building in a city skyline. The skyline is viewed from the left side, and you want to calculate the amount of \\"water\\" that can be trapped after a rainstorm. The water will be trapped between the buildings in the valleys formed by the height differences. Return the total volume of water trapped.","solution":"def trap_water(height): Calculate the amount of water that can be trapped between the buildings after a rainstorm. :param height: List[int], array of integers representing the heights of buildings :return: int, the total volume of trapped water if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"You are given a list of non-negative integers `nums` representing a binary tree in a level order traversal format, where the `i-th` integer in the list is the value of the `i-th` node in the tree. Your task is to determine if the given binary tree is a complete binary tree. A binary tree is considered complete if all levels are fully filled except possibly the last, which is filled from left to right with no gaps. Return `true` if the binary tree is complete, otherwise return `false`.","solution":"from typing import List def is_complete_binary_tree(nums: List[int]) -> bool: Determines if the given binary tree, represented as a list in level order traversal, is a complete binary tree. n = len(nums) if n == 0: return True # An empty tree is considered complete for i in range(n): if 2 * i + 1 < n and not nums[2 * i + 1]: return False if 2 * i + 2 < n and not nums[2 * i + 2]: return False return True"},{"question":"You are given two strings `s` and `t`, each consisting of lowercase English letters. You want to transform string `s` into string `t` by performing the following operations exactly in the given order: 1. **Reverse** any substring of `s`. 2. **Replace** any single character of `s` with another lowercase English letter. Return _the minimum number of operations needed to transform `s` into `t`_. If it is impossible to transform `s` into `t`, return `-1`.","solution":"def min_operations(s, t): Returns the minimum number of operations needed to transform s into t. If it is impossible to transform s into t, returns -1. if len(s) != len(t): return -1 mismatches = [] for i in range(len(s)): if s[i] != t[i]: mismatches.append((s[i], t[i])) if len(mismatches) == 0: return 0 elif len(mismatches) == 1: return 1 elif len(mismatches) == 2 and mismatches[0] == (mismatches[1][1], mismatches[1][0]): return 1 return len(mismatches)"},{"question":"Given an array of integers, find all unique triplets in the array which gives the sum of zero. The solution set must not contain duplicate triplets. Return a list of all unique triplets, where each triplet is a list of integers [a, b, c] such that they satisfy the condition a + b + c = 0.","solution":"def three_sum(nums): Finds all unique triplets in the list which gives the sum of zero. :param nums: List of integers :return: List of unique triplets [a, b, c] such that a + b + c = 0 nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate values left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicate values while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicate values left += 1 right -= 1 return triplets"},{"question":"Given a binary tree, find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). In case of a tie, return all the values with the highest frequency in any order.","solution":"from collections import defaultdict from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_frequent_tree_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] def dfs(node): if not node: return 0 left_sum = dfs(node.left) right_sum = dfs(node.right) subtree_sum = node.val + left_sum + right_sum count[subtree_sum] += 1 return subtree_sum count = defaultdict(int) dfs(root) max_freq = max(count.values()) return [s for s, freq in count.items() if freq == max_freq]"},{"question":"You are given an array of integers `arr` and an integer `k`. Find the `k` most frequent elements in the array. Return _the elements in decreasing order of their frequency_. If two elements have the same frequency, the one with the larger numerical value should come first.","solution":"from collections import Counter import heapq def top_k_frequent_elements(arr, k): Returns the k most frequent elements in the array in decreasing order of their frequency. If two elements have the same frequency, the one with the larger numerical value comes first. if not arr or k <= 0: return [] frequency = Counter(arr) heap = [(-freq, num) for num, freq in frequency.items()] heapq.heapify(heap) result = [] for _ in range(k): freq, num = heapq.heappop(heap) result.append(num) return result"},{"question":"You are given an array of integers `arr` and an integer `target`. Return _the number of **subarrays** of `arr` whose elements sum up to_ `target`. A **subarray** is a contiguous non-empty sequence of elements within an array.","solution":"def subarray_sum(arr, target): Returns the number of subarrays whose sum equals to the target. from collections import defaultdict count = 0 curr_sum = 0 sum_dict = defaultdict(int) sum_dict[0] = 1 for num in arr: curr_sum += num if (curr_sum - target) in sum_dict: count += sum_dict[curr_sum - target] sum_dict[curr_sum] += 1 return count"},{"question":"You are given an integer array `nums` and an integer `k`. You need to find the **maximum** number of unique elements in any subarray of size `k`. A subarray is defined as a contiguous segment of the array. Return _an integer representing the maximum number of unique elements among all possible subarrays of size_ `k`.","solution":"def max_unique_elements(nums, k): Returns the maximum number of unique elements in any subarray of size k. if k > len(nums): return len(set(nums)) max_unique = 0 current_unique = {} # Initial window for i in range(k): current_unique[nums[i]] = current_unique.get(nums[i], 0) + 1 max_unique = len(current_unique) # Sliding window for i in range(k, len(nums)): # Remove the element that is sliding out of the window if current_unique[nums[i - k]] == 1: del current_unique[nums[i - k]] else: current_unique[nums[i - k]] -= 1 # Add the new element that is sliding into the window current_unique[nums[i]] = current_unique.get(nums[i], 0) + 1 # Update max unique count if needed max_unique = max(max_unique, len(current_unique)) return max_unique"},{"question":"Given a binary tree, imagine yourself walking down from the root to the tree\'s leaves. At each step, visually append the node values to a string while walking from left to right. Write a function that returns the string representation of the tree as seen from this visual traversal. If the tree is empty, return an empty string.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def tree_to_string(root): Given a binary tree, return a string representation of the tree as seen from a visual traversal from the root to the leaves, moving left to right. if not root: return \\"\\" result = [] queue = [root] while queue: node = queue.pop(0) result.append(str(node.val)) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return \' \'.join(result)"},{"question":"Given an integer array `arr` and an integer `d`, return the _length of the longest increasing subsequence in which the absolute difference between any two consecutive elements is less than or equal to `d`_. An increasing subsequence is a sequence of elements derived from the array in the same order, without necessarily being contiguous, that strictly increases in value.","solution":"def longest_increasing_subsequence(arr, d): Returns the length of the longest increasing subsequence where the absolute difference between any two consecutive elements is less than or equal to d. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will hold the length of the longest increasing subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and abs(arr[i] - arr[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an integer array `arr` and an integer `m`, return the maximum average of any subarray of length `m` in `arr`. The subarray must be contiguous and consist of exactly `m` elements.","solution":"def max_average_subarray(arr, m): Returns the maximum average of any subarray of length m. Parameters: arr (list of ints): The input array of integers m (int): The length of the subarray Returns: float: The maximum average of any subarray of length m if len(arr) < m: raise ValueError(\\"The length of the subarray cannot exceed the length of the array\\") max_sum = curr_sum = sum(arr[:m]) for i in range(m, len(arr)): curr_sum += arr[i] - arr[i - m] max_sum = max(max_sum, curr_sum) return max_sum / m"},{"question":"Given a string `expression` representing a valid mathematical expression containing integers and the operators `+`, `-`, `*`, and `/` (without any spaces), evaluate and return the result of the expression. The integer division should truncate toward zero. Example: Input: `expression = \\"3+2*2\\"` Output: `7` Note: - The input string is guaranteed to be non-empty and contains valid characters. - The integer division should truncate toward zero. - Implement a function to evaluate the expression without using the `eval` function.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers and operators +, -, *, /. Integer division should truncate toward zero. if not expression: return 0 stack = [] num = 0 sign = \'+\' for i, ch in enumerate(expression): if ch.isdigit(): num = num * 10 + int(ch) if ch in \'+-*/\' or i == len(expression) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) # truncate towards zero sign = ch num = 0 return sum(stack)"},{"question":"Implement a function that takes a matrix `mat` of size `m x n` and an integer `k`, and returns a matrix of the same size where each element in the returning matrix is the sum of all elements within a `k`-radius square of that element in the original matrix. The `k`-radius square of an element is the square that extends `k` units in all directions from the element itself. If a `k`-radius extends beyond the matrix boundaries, consider only the available elements.","solution":"def matrixBlockSum(mat, k): Returns a matrix of the same size where each element is the sum of all elements within a k-radius square of that element in the original matrix. mat: List[List[int]] - the original matrix m x n k: int - the radius for the square return: List[List[int]] - the resulting matrix m, n = len(mat), len(mat[0]) # Initialize prefix sum matrix with extra row and column for easier calculations prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] # Build the prefix sum matrix for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = (mat[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j]) # Initialize the result matrix result = [[0] * n for _ in range(m)] # Calculate the block sum for each element in the matrix for i in range(m): for j in range(n): # Determine the boundaries of the k-radius square r1, c1 = max(0, i - k), max(0, j - k) r2, c2 = min(m - 1, i + k), min(n - 1, j + k) # Convert to prefix sum matrix\'s coordinate r1, c1, r2, c2 = r1 + 1, c1 + 1, r2 + 1, c2 + 1 # Calculate the sum using prefix sum result[i][j] = (prefix_sum[r2][c2] - prefix_sum[r1 - 1][c2] - prefix_sum[r2][c1 - 1] + prefix_sum[r1 - 1][c1 - 1]) return result"},{"question":"You are given a **square grid** of size `n x n` filled with integers. Each cell represents a certain amount of strength. You have to start from the cell `(0, 0)` and reach the cell `(n-1, n-1)` moving only **right** or **down** at each step. You are required to collect the strength values in each cell you visit along the way. However, there is a hidden trap in some cells which will drain all your collected strength, and you must avoid these traps. An additional integer `trapValue` is provided which signifies the trap strength value; a cell with this value should be avoided. You need to find _the maximum strength you can collect from the start to the end avoiding the traps, or return_ `-1` _if no path is possible_.","solution":"def max_strength(grid, trapValue): n = len(grid) dp = [[-1] * n for _ in range(n)] if grid[0][0] == trapValue: return -1 dp[0][0] = grid[0][0] for i in range(n): for j in range(n): if i == 0 and j == 0: continue if grid[i][j] == trapValue: dp[i][j] = -1 continue up = dp[i-1][j] if i > 0 and dp[i-1][j] != -1 else -1 left = dp[i][j-1] if j > 0 and dp[i][j-1] != -1 else -1 dp[i][j] = max(up, left) + grid[i][j] if max(up, left) != -1 else -1 return dp[n-1][n-1]"},{"question":"You are given a `0-indexed` integer array `nums` of length `n`. Your task is to determine if you can partition the array into exactly `two` subarrays such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray. Return `true` if such a partition is possible, otherwise return `false`. Note that each element must belong to exactly one of the two subarrays.","solution":"def can_partition(nums): Determines if an array can be partitioned into two subarrays with equal sum. :param nums: List[int] :return: bool total_sum = sum(nums) # If the total sum is odd, it\'s not possible to partition into two equal sum subarrays if total_sum % 2 != 0: return False target = total_sum // 2 current_sum = 0 seen = set() for num in nums: current_sum += num if current_sum - target in seen or current_sum == target: return True seen.add(current_sum) return False"},{"question":"Given an integer array `nums`, return the number of consecutive increasing subsequences of length `k` present in the array. A **consecutive increasing subsequence** is defined as a subarray of length `k` where each element is strictly greater than the previous one. For example, if `nums = [1, 2, 3, 4, 2, 3, 4, 5]` and `k = 3`, the function should return `4`, since the subsequences `[1, 2, 3]`, `[2, 3, 4]`, `[3, 4, 5]`, and `[2, 3, 4]` meet the criteria.","solution":"def count_consecutive_increasing_subsequences(nums, k): Returns the number of consecutive increasing subsequences of length k in the array nums. Parameters: nums (list): A list of integers. k (int): The length of the desired subsequences. Returns: int: The number of consecutive increasing subsequences of length k. if k <= 1: raise ValueError(\\"k should be greater than 1\\") count = 0 for i in range(len(nums) - k + 1): if all(nums[j] < nums[j + 1] for j in range(i, i + k - 1)): count += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to build a binary search tree (BST) from `arr` and determine the sum of all elements within the BST that are **k distance** away from the root. Here, the distance is defined as the number of edges between the root and the node. For example, if the distance is 0, we refer to the root node itself, if the distance is 1, we refer to the immediate children of the root, and so on. Return _the sum of the nodes that are exactly `k` distance away from the root_. If there are no nodes at that distance, return `0`. Note: - You may assume the tree has no duplicate nodes. - The array does not have to be sorted.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(arr): if not arr: return None root = TreeNode(arr[0]) for value in arr[1:]: insert_into_bst(root, value) return root def sum_at_k_distance(root, k): if root is None: return 0 if k == 0: return root.value left_sum = sum_at_k_distance(root.left, k - 1) right_sum = sum_at_k_distance(root.right, k - 1) return left_sum + right_sum def sum_of_k_distance_from_root(arr, k): bst_root = build_bst(arr) return sum_at_k_distance(bst_root, k)"},{"question":"You are given a list of `n` flights, where each flight is represented as a triplet `[ui, vi, wi]` that denotes a flight from city `ui` to city `vi` with a travel cost `wi`. You are also given two integers `src` and `dst` representing the starting city and the destination city, respectively. Your task is to find the minimum travel cost to get from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) min_heap = [(0, src, k + 1)] while min_heap: cost, u, stops = heapq.heappop(min_heap) if u == dst: return cost if stops > 0: for v, w in graph[u]: heapq.heappush(min_heap, (cost + w, v, stops - 1)) return -1"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to rearrange the elements of the array such that the difference between any two consecutive elements is at most `k`. If it is impossible to rearrange the array to satisfy this condition, return an empty array. Otherwise, return any valid rearrangement of the array.","solution":"def rearrange_with_max_difference(arr, k): Rearranges the elements of the array such that the difference between any two consecutive elements is at most k. If it\'s not possible, returns an empty array. if not arr or k < 0: return [] sorted_arr = sorted(arr) n = len(sorted_arr) # Check the condition for rearrangement. for i in range(n - 1): if abs(sorted_arr[i] - sorted_arr[i + 1]) > k: return [] return sorted_arr"},{"question":"You are given a 2D list of integers `grid` representing a grid of size `m x n`, where each cell contains either a `0` (representing an empty cell) or a `1` (representing a wall). You need to find the maximum area of a rectangle that can be formed by empty cells. Return _an integer representing the maximum area of the rectangle filled with empty cells_.","solution":"def maximal_rectangle(grid): Returns the maximum area of a rectangle filled with empty cells in a grid. :param grid: List[List[int]] - 2D grid where 0 represents an empty cell and 1 represents a wall. :return: int - Maximum area of a rectangle filled with empty cells. if not grid: return 0 m, n = len(grid), len(grid[0]) max_area = 0 heights = [0] * n for i in range(m): for j in range(n): heights[j] = heights[j] + 1 if grid[i][j] == 0 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): Helper function to calculate the largest rectangle area in a histogram. :param heights: List[int] - Histogram heights. :return: int - Maximum rectangle area. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"Implement a data structure that supports the following operations: * `void insert(int key, int value)`: Insert a key-value pair into the data structure. * `int get(int key)`: Retrieve the value associated with the given key. If the key does not exist, return -1. * `void delete(int key)`: Remove the key-value pair associated with the given key. * `int[] get_all_keys()`: Return all currently stored keys in ascending order. The `key` values are integers and the `value` associated with each key is also an integer. Make sure your implementation provides efficient time complexity for each operation.","solution":"class DataStructure: def __init__(self): self.data = {} def insert(self, key, value): self.data[key] = value def get(self, key): return self.data.get(key, -1) def delete(self, key): if key in self.data: del self.data[key] def get_all_keys(self): return sorted(self.data.keys())"},{"question":"You are given an integer array `profits` representing the profit you observe each day from a particular stock. Given an integer `k`, find the maximum profit you can achieve by making at most `k` transactions. A transaction is defined as buying and then selling one share of the stock. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). If no transactions can be made, return 0.","solution":"def maxProfit(k, prices): n = len(prices) if n == 0: return 0 if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][-1]"},{"question":"You are given a list of non-negative integers `nums` representing the number of stones in each pile. You can remove up to two piles of stones at a time. In each turn, choose two distinct piles and remove exactly one stone from each. If a pile is empty, it cannot be chosen. Return _the maximum number of turns you can take until no more moves are possible_. [Question] 5:","solution":"def max_turns(nums): Returns the maximum number of turns that can be taken from the list of piles of stones. Each turn consists of choosing two distinct, non-empty piles and removing one stone from each. # Sort the list in descending order to prioritize the piles with the most stones nums.sort(reverse=True) turns = 0 while len(nums) > 1 and nums[1] > 0: # Decrement the top two piles nums[0] -= 1 nums[1] -= 1 turns += 1 # Re-sort the list to ensure the next maximum piles are at the beginning nums.sort(reverse=True) return turns"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform at most one move where you can choose exactly one character from `s` and insert it at any position in the string. Return _the length of the longest palindromic substring that can be obtained after at most one move_.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring that can be obtained after at most one move. def is_palindrome(s): return s == s[::-1] n = len(s) if is_palindrome(s): return n for i in range(n): if is_palindrome(s[:i] + s[i+1:]): return n return n - 1"},{"question":"Given a string `s` which represents an encoded number where each letter maps to its position in the alphabet (i.e., \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26), return _the number of ways to decode it_. For example, given the string \\"12\\", there are two valid decodings: \\"AB\\" (1 2) and \\"L\\" (12). Implement the function `numDecodings(s)` that takes a string `s` and returns an integer representing the number of ways to decode the string.","solution":"def numDecodings(s): if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 0 if s[0] == \'0\' else 1 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a 2D integer array `buildings` where each `buildings[i] = [lefti, righti, heighti]` represents a building with a width extending from `lefti` to `righti - 1` and a height of `heighti` units. Buildings may overlap with each other. Determine the skyline formed by these buildings. The skyline is described as a list of \\"key points\\" sorted by the left coordinate. A key point is the left endpoint of a horizontal line segment where the height changes. A building\'s key points include where its height starts and where it potentially changes due to an overlap with another building. Return the skyline as a list of key points `[x, y]`, where `x` is the x-coordinate of the key point and `y` is the height of the skyline at that point.","solution":"import heapq def get_skyline(buildings): Computes the skyline formed by a list of buildings. Each building is represented as a list [left, right, height]. The skyline is a list of key points [x, y] where x is the x-coordinate and y is the height. Args: buildings (List[List[int]]): List of buildings each represented as [left, right, height] Returns: List[List[int]]: The skyline represented as a list of key points [x, y] events = [] for left, right, height in buildings: events.append((left, -height, right)) events.append((right, 0, 0)) # Sort events first by x-coordinate. events.sort() result = [[0, 0]] live_buildings = [(0, float(\'inf\'))] for x, neg_height, right in events: while live_buildings[0][1] <= x: heapq.heappop(live_buildings) if neg_height: heapq.heappush(live_buildings, (neg_height, right)) max_height = -live_buildings[0][0] if result[-1][1] != max_height: result.append([x, max_height]) return result[1:]"},{"question":"You are given a list of `projects` where each project is represented as a tuple `(start_day, end_day, profit)`. `start_day` and `end_day` are integers representing the start and end days of the project, and `profit` is an integer representing the profit from completing this project. You can only work on one project at a time. Your task is to determine the maximum profit that you can earn by selecting projects to work on. Write a function to find the maximum profit.","solution":"from typing import List, Tuple def max_profit(projects: List[Tuple[int, int, int]]) -> int: projects.sort(key=lambda x: x[1]) # Sort projects by end_day n = len(projects) dp = [0] * n # dp[i] will store the maximum profit till the end of i-th project dp[0] = projects[0][2] def find_latest_non_conflict(i): # Binary search to find the latest project that doesn\'t conflict with projects[i] low, high = 0, i-1 while low <= high: mid = (low + high) // 2 if projects[mid][1] < projects[i][0]: if projects[mid + 1][1] < projects[i][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 for i in range(1, n): profit_if_taken = projects[i][2] l = find_latest_non_conflict(i) if l != -1: profit_if_taken += dp[l] dp[i] = max(dp[i-1], profit_if_taken) return dp[-1]"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, find and return _the maximum sum of non-adjacent elements_ in the array. If the array is empty or all elements are negative, return `0`.","solution":"def max_non_adjacent_sum(nums): if not nums or all(n < 0 for n in nums): return 0 incl = 0 excl = 0 for num in nums: new_excl = max(incl, excl) incl = excl + max(0, num) excl = new_excl return max(incl, excl)"},{"question":"You have a `2D` grid representing a park where each cell is either land represented by `1` or water represented by `0`. You want to build a bridge between two pieces of land in order to connect them. The bridge can only be built in a straight horizontal or vertical line over water cells. It is not possible to build a bridge diagonally or over other land cells. Given the 2D grid of integers, return _the **minimum number of water cells** required to be crossed to build the bridge_. Example: ``` Input: grid = [ [1,0,0,0,1], [0,0,0,0,0], [0,0,1,0,0], [0,1,0,0,0], [1,0,0,0,1] ] Output: 1 ```","solution":"from collections import deque def min_water_cells_to_cross(grid): def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny def bfs(queue): visited = set(queue) while queue: x, y, d = queue.popleft() for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1 and (nx, ny) not in visited: return d if grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, d + 1)) return float(\'inf\') def find_components(): components = [] visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: queue = deque([(i, j)]) component = [] while queue: x, y = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) component.append((x, y)) for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1 and (nx, ny) not in visited: queue.append((nx, ny)) components.append(component) return components components = find_components() if len(components) < 2: return 0 min_distance = float(\'inf\') for component in components: queue = deque([(x, y, 0) for x, y in component]) min_distance = min(min_distance, bfs(queue)) return min_distance"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find if there exists a non-empty sequence of the elements in `nums` that sums exactly to `target` but does not change the relative order of the elements. A sequence does not need to be contiguous. Return `True` if such a sequence exists and `False` otherwise.","solution":"def can_sum_to_target(nums, target): Returns True if a non-empty sequence of the elements in `nums` sums exactly to `target`, maintaining the relative order of the elements. Returns False otherwise. n = len(nums) # Create a 2D DP array where dp[i][j] means whether a subset of nums[:i] can sum up to j dp = [[False] * (target + 1) for _ in range(n + 1)] # There is always a way to sum to 0 by taking an empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: # Include nums[i-1] or not dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: # Can\'t include nums[i-1] dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"You are given two integer arrays `nums1` and `nums2` of length `n`. A valid pair is defined as an index `i` such that `nums1[i] <= nums2[i]`. The **distance** of a valid pair `(i, j)` is defined as `j - i` (where `j >= i`). Return the **maximum distance** of any valid pair. If there are no valid pairs, return `0`.","solution":"def max_distance(nums1, nums2): Returns the maximum distance of any valid pair (i, j) such that nums1[i] <= nums2[j] and j >= i. If there are no valid pairs, returns 0. max_dist = 0 n = len(nums1) for i in range(n): for j in range(i, n): if nums1[i] <= nums2[j]: max_dist = max(max_dist, j - i) return max_dist"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values as a 2D list. (i.e., from left to right, level by level).","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns the level order traversal of a binary tree\'s nodes\' values. Args: root: TreeNode, the root of the binary tree. Returns: List[List[int]]: 2D list representing level order traversal of the nodes\' values. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"Given a list of non-negative integers representing the heights of columns, where the width of each column is 1, compute the maximum amount of water that can be trapped between the columns after it rains.","solution":"def trap(height): Computes the maximum amount of water that can be trapped between columns after it rains. :param height: List of non-negative integers representing the heights of columns. :return: Maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] water_trapped = 0 while left < right: if max_left <= max_right: left += 1 max_left = max(max_left, height[left]) water_trapped += max(0, max_left - height[left]) else: right -= 1 max_right = max(max_right, height[right]) water_trapped += max(0, max_right - height[right]) return water_trapped"},{"question":"You are given a **0-indexed** array of integers `nums` representing the elevations of terrain at various points along a road. The goal is to calculate the **total volume** of water that can be trapped between the elevations after a heavy rain. The water trapped at each point depends on the heights of the terrain bars on both sides of it. Return _the **total volume** of water that can be trapped by the terrain described by the array `nums`_.","solution":"def trap_rain_water(nums): Calculate the total volume of water that can be trapped between the elevations after a heavy rain. Args: nums (List[int]): A list of integers representing the elevations. Returns: int: The total volume of trapped water. if not nums or len(nums) < 3: return 0 left, right = 0, len(nums) - 1 left_max, right_max = nums[left], nums[right] total_water = 0 while left < right: if nums[left] < nums[right]: if nums[left] >= left_max: left_max = nums[left] else: total_water += left_max - nums[left] left += 1 else: if nums[right] >= right_max: right_max = nums[right] else: total_water += right_max - nums[right] right -= 1 return total_water"},{"question":"Given an array of integers `nums` of length `n`, where all elements are initially distinct. You are allowed to perform at most one swap between any two elements of the array. Write a function to return the maximum number of unique elements that can be retained in the resulting array after at most one swap. Note that the array is sorted in ascending order after the swap is performed (if any). If swapping two elements leads to the same element appearing more than once, only one of those elements is considered for the count of unique elements.","solution":"def max_unique_elements(nums): Returns the maximum number of unique elements that can be retained in the resulting array after at most one swap. n = len(nums) # If the array has no elements or only one element, return its length if n <= 1: return n # Create a set to track unique elements unique_elements = set(nums) max_unique_count = len(unique_elements) # Try swapping each pair of elements and count unique elements for i in range(n): for j in range(i + 1, n): # Swap i and j nums[i], nums[j] = nums[j], nums[i] # Count unique elements in the modified array unique_elements = set(nums) max_unique_count = max(max_unique_count, len(unique_elements)) # Swap back nums[i], nums[j] = nums[j], nums[i] # If we have found the maximum unique count possible, return it directly if max_unique_count == n: return max_unique_count return max_unique_count"},{"question":"A company wants to optimize its product delivery routes in a city. They have a matrix representing the city\'s layout where each cell indicates the travel cost to move through it. Given a `grid` where `grid[i][j]` represents the travel cost at position `(i, j)`, return _the minimum cost to travel from the top left corner of the grid to the bottom right corner_. You may move only down or right at any point in time.","solution":"def min_cost(grid): Returns the minimum cost to travel from the top left corner to the bottom right corner of the grid. :param grid: List[List[int]] - A 2D list where grid[i][j] represents the travel cost at position (i, j) :return: int - The minimum cost to travel from the top left to the bottom right corner rows, cols = len(grid), len(grid[0]) cost_grid = [[0] * cols for _ in range(rows)] cost_grid[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): cost_grid[0][j] = cost_grid[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, rows): cost_grid[i][0] = cost_grid[i - 1][0] + grid[i][0] # Fill the rest of the cost grid for i in range(1, rows): for j in range(1, cols): cost_grid[i][j] = min(cost_grid[i - 1][j], cost_grid[i][j - 1]) + grid[i][j] return cost_grid[rows - 1][cols - 1]"},{"question":"Given an unsorted array of integers `nums`, find the smallest positive integer that is missing from the array. Return _the smallest missing positive integer_.","solution":"def first_missing_positive(nums): Return the smallest positive integer that is missing from the array. n = len(nums) # First pass: Place each number in its correct location if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Second pass: Identify the first number not correctly placed for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are correct, the missing one is n + 1 return n + 1"},{"question":"You are given a string `s` of lowercase English letters. You can perform the following operation on the string any number of times: Choose any character in the string and delete the nearest occurrence of that character to its right (if it exists). Your task is to determine the minimum number of operations required to transform the string into a string with all distinct characters. Return the minimum number of operations needed.","solution":"def min_operations_to_distinct(s): Returns the minimum number of operations needed to transform the string into a string with all distinct characters. from collections import Counter # Count the frequency of each character freq = Counter(s) # Sum the extra occurrences of each character operations = sum(count - 1 for count in freq.values()) return operations"},{"question":"Given a list of strings, group the anagrams together. Two strings are anagrams if and only if their sorted characters are equal. Return a list of lists, where each sublist contains strings that are anagrams of each other. The order of the strings in the output does not matter. Each string in the input list consists of lowercase alphabets only.","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together. Two strings are anagrams if their sorted characters are equal. Args: strs (List[str]): A list of strings to be grouped by anagrams. Returns: List[List[str]]: A list of lists, where each sublist contains strings that are anagrams of each other. anagram_map = defaultdict(list) for s in strs: sorted_chars = \'\'.join(sorted(s)) anagram_map[sorted_chars].append(s) return list(anagram_map.values())"},{"question":"You are given an integer array `arr`. A **valid subarray** is a continuous subarray that has a sum equal to a given target value `target`. Return _the length of the longest valid subarray_. If there is no such subarray, return `0`.","solution":"def longest_valid_subarray(arr, target): Returns the length of the longest valid subarray with sum equal to target. Parameters: arr (list): A list of integers. target (int): The target sum for the subarray. Returns: int: The length of the longest valid subarray, or 0 if no valid subarray exists. longest_length = 0 # We use a dictionary to store the cumulative sum up to each index cumulative_sum = 0 cumulative_dict = {0: -1} # This is used to handle cases where subarray starts from index 0 for i, num in enumerate(arr): cumulative_sum += num if cumulative_sum - target in cumulative_dict: longest_length = max(longest_length, i - cumulative_dict[cumulative_sum - target]) if cumulative_sum not in cumulative_dict: cumulative_dict[cumulative_sum] = i return longest_length"},{"question":"You are given an array of integers `arr`, where each integer represents the number of apples on a tree in a row of apple trees. You want to collect the maximum number of apples, but you can only collect from two adjacent trees each time, and you cannot collect from any tree more than once. Write a function to determine the maximum number of apples you can collect. Given the array `arr`, return the maximum number of apples that can be collected following the above rules.","solution":"def max_apples(arr): Given an array of integers arr, where each integer represents the number of apples on a tree in a row of apple trees, this function calculates the maximum number of apples that can be collected by only collecting from two adjacent trees each time, without collecting from any tree more than once. if not arr or len(arr) < 2: return 0 max_apples_collected = 0 for i in range(len(arr) - 1): max_apples_collected = max(max_apples_collected, arr[i] + arr[i + 1]) return max_apples_collected"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of items in a container. Each container can hold a maximum of `capacity` items. Your goal is to determine the **minimum number of containers** required to hold all the items from the `nums` array without exceeding the capacity of any container. Return _the **minimum number of containers** needed to hold all the items._","solution":"def min_containers(nums, capacity): Returns the minimum number of containers required to hold all items in the nums array without exceeding the given capacity of any container. if capacity <= 0: raise ValueError(\\"Capacity must be greater than zero.\\") total_items = sum(nums) return (total_items + capacity - 1) // capacity"},{"question":"You are given a list of integers representing the energy levels of different entities in a game. Each entity can perform an action that consumes a certain amount of energy. Given a list of actions and their respective energy costs, return _the maximum number of entities that can perform at least one action without their energy falling below zero_. You cannot reuse the same action for different entities, and each entity can perform only one action. The list of entities\' energy levels and the list of actions\' energy costs are given in two separate lists.","solution":"def max_entities_with_action(energy_levels, action_costs): Returns the maximum number of entities that can perform at least one action without their energy falling below zero. :param energy_levels: List of integers representing the energy levels of entities. :param action_costs: List of integers representing the energy costs of actions. energy_levels.sort() action_costs.sort() entity_index = 0 action_index = 0 count = 0 while entity_index < len(energy_levels) and action_index < len(action_costs): if energy_levels[entity_index] >= action_costs[action_index]: count += 1 entity_index += 1 action_index += 1 else: entity_index += 1 return count"},{"question":"Given a binary search tree (BST), write a function to find the lowest common ancestor of two given nodes in the BST. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in the BST that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). You may assume that both values exist in the BST.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Determines the lowest common ancestor of two nodes in a BST. :param TreeNode root: The root of the binary search tree. :param TreeNode p: The first node. :param TreeNode q: The second node. :return: The lowest common ancestor node. while root: if root.val > p.val and root.val > q.val: root = root.left elif root.val < p.val and root.val < q.val: root = root.right else: return root"},{"question":"You are given a list of non-negative integers `tokens` representing the values of tokens and an integer `power`. Initially, you start with `power` points. You can perform one of the following actions any number of times: 1. If your current points are at least the value of a token, you can take the token and gain 1 score, losing the token\'s value in points. 2. If you have at least one score, you can lose 1 score and gain points equal to the value of any token in your possession. Return _the highest score you can achieve after performing any number of the above actions_.","solution":"def max_score_from_tokens(tokens, power): Returns the highest score achievable given the tokens and initial power. tokens.sort() score = 0 max_score = 0 left, right = 0, len(tokens) - 1 while left <= right: if power >= tokens[left]: power -= tokens[left] score += 1 left += 1 max_score = max(max_score, score) elif score > 0: power += tokens[right] score -= 1 right -= 1 else: break return max_score"},{"question":"You are given a **0-indexed** integer array `arr` of length `m` and a positive integer `k`. You need to find the number of contiguous subarrays of length exactly `k` that have a sum greater than or equal to `x`. Return the count of such subarrays.","solution":"def count_subarrays_with_sum_at_least_x(arr, k, x): Returns the count of contiguous subarrays of length exactly k that have a sum greater than or equal to x. n = len(arr) count = 0 # Initial sum of the first window of size k window_sum = sum(arr[:k]) if window_sum >= x: count += 1 # Slide the window over the array while maintaining the sum of the window for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] if window_sum >= x: count += 1 return count"},{"question":"You are given an array of positive integers `arr`, where `arr[i]` represents the number of coins of the `i-th` color. Calculate the maximum number of different colors you can pick so that you do not pick more than `k` coins in total. Each color must be selected completely if chosen, meaning you cannot split the coins of a single color. Write a function to return the maximum number of different colors possible.","solution":"def max_colors(arr, k): Returns the maximum number of different colors that can be picked without exceeding the total number of coins k. Parameters: arr (list): A list of positive integers where arr[i] represents the number of coins of the i-th color. k (int): The maximum number of coins that can be picked in total. Returns: int: The maximum number of different colors. # Sort the array in ascending order to try and pick the smallest sets first arr.sort() total_colors = 0 current_sum = 0 for coins in arr: if current_sum + coins <= k: current_sum += coins total_colors += 1 else: break return total_colors"},{"question":"Given a list of non-negative integers representing the amount of money of each house, you are to determine the maximum amount of money you can rob tonight without alerting the police. The constraint is that you cannot rob two adjacent houses as it will trigger the alarm. More formally, return the maximum sum of non-adjacent elements from the given list. If the list is empty, return 0.","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the police. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize variables to store the maximum amount robbed up to the previous two houses prev1 = 0 prev2 = 0 for num in nums: # Calculate the maximum amount robbed up to the current house current = max(prev1, prev2 + num) # Update the previous two variables for the next iteration prev2 = prev1 prev1 = current return prev1"},{"question":"# Task: Design a function that takes an array of integers and a target integer. The function should find all unique quadruplets in the array that sum up to the target integer. Return these quadruplets as a list of lists. The solution should avoid duplicates and ensure each quadruplet is sorted in ascending order. You can assume that the array may contain both positive and negative integers and that the array length is at least 4.","solution":"def four_sum(nums, target): nums.sort() quad_list = [] length = len(nums) for i in range(length - 3): # To avoid duplicates if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): # To avoid duplicates if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: quad_sum = nums[i] + nums[j] + nums[left] + nums[right] if quad_sum == target: quad_list.append([nums[i], nums[j], nums[left], nums[right]]) # Avoiding duplicates while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif quad_sum < target: left += 1 else: right -= 1 return quad_list"},{"question":"Given a positive integer `n`, determine if it can be expressed as the sum of two or more consecutive positive integers. If `n` can be expressed this way, return _one sequence_ of those consecutive integers. If there are multiple valid sequences, return any one of them. If `n` cannot be expressed as the sum of consecutive positive integers, return _an empty list_.","solution":"def find_consecutive_sequence(n): Determines if n can be expressed as the sum of two or more consecutive positive integers. If possible, returns one such sequence as a list. Otherwise, returns an empty list. for start in range(1, n): total = 0 numbers = [] for current in range(start, n): total += current numbers.append(current) if total == n: return numbers elif total > n: break return [] # Example Usage: # print(find_consecutive_sequence(15)) # Output can be [1, 2, 3, 4, 5] or [4, 5, 6] or [7, 8] # print(find_consecutive_sequence(8)) # Output []"},{"question":"Given an array of integers `arr` and an integer `k`, find the `k`th largest element in the array. Implement a solution with a linear runtime complexity.","solution":"def find_kth_largest(arr, k): Returns the kth largest element in the array. import heapq return heapq.nlargest(k, arr)[-1]"},{"question":"Given an array of integers `arr`, return *the smallest positive integer* that is not present in the array. The array may contain duplicates and can include negative numbers. Your solution should have a linear runtime complexity and use constant extra space.","solution":"def first_missing_positive(arr): Returns the smallest positive integer that is not present in the array. n = len(arr) # Mark elements out of range, negative and zero values by assigning n+1 for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Use the array index as a hash map to record the presence of elements for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # The first positive index which is not marked indicates the missing number for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"Given an integer array `nums`, write a function that finds the longest subsequence such that each element in the subsequence is divisible by the previous one. Return the length of this subsequence. Efficiency is key, so consider optimizing your solution to handle large input sizes effectively.","solution":"def find_longest_divisible_subsequence(nums): Finds the length of the longest subsequence such that each element in the subsequence is divisible by the previous one. :param nums: List of integers :return: Length of the longest divisible subsequence if not nums: return 0 # Sort the array nums.sort() n = len(nums) # dp array to hold the longest subsequence length ending at each element dp = [1] * n # Iterate through the array to build up the dp array for i in range(1, n): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a string `s` consisting of lowercase and uppercase alphabetic characters and a positive integer `k`. You need to perform the following operation exactly `k` times: choose any two adjacent characters in the string and swap them. After performing all `k` swaps, return the lexicographically smallest string possible. If multiple answers exist, return any one of them.","solution":"def smallest_lexicographical_string(s, k): Returns the lexicographically smallest string by performing exactly k swaps of any two adjacent characters. s = list(s) n = len(s) for i in range(n): for j in range(1, n): if k > 0 and s[j - 1] > s[j]: s[j - 1], s[j] = s[j], s[j - 1] k -= 1 return \'\'.join(s)"},{"question":"You are given an array of integers `nums` and an integer `k`. A subarray is called **nice** if there are exactly `k` odd numbers in it. Return _the number of **nice** subarrays_. For example, given `nums = [1,1,2,1,1]` and `k = 3`, the subarrays with exactly `3` odd numbers are `[1,1,2,1]` and `[1,2,1,1]`. Thus, the function should return `2`.","solution":"def numberOfSubarrays(nums, k): Returns the number of nice subarrays (arrays with exactly k odd numbers). def atMostK(nums, k): count = 0 left = 0 odd_count = 0 for right in range(len(nums)): if nums[right] % 2 == 1: k -= 1 odd_count += 1 while k < 0: if nums[left] % 2 == 1: k += 1 left += 1 count += right - left + 1 return count # The number of subarrays with exactly k odd numbers is the number of subarrays # with at most k odd numbers minus the number of subarrays with at most (k-1) odd numbers. return atMostK(nums, k) - atMostK(nums, k - 1)"},{"question":"You are given a string `s` containing only the characters `\'0\'` and `\'1\'`. A **valid binary substring** is a substring that contains an equal number of consecutive `\'0\'`s and `\'1\'`s and all the `\'0\'`s and all the `\'1\'`s in these substrings are grouped consecutively. For example, `\\"0011\\"` and `\\"1100\\"` are valid binary substrings but `\\"0101\\"` is not. Return the number of valid binary substrings in `s`.","solution":"def countBinarySubstrings(s): Counts the number of valid binary substrings in the given string `s`. A valid binary substring has an equal number of consecutive \'0\'s and \'1\'s. :param s: A string containing characters \'0\' and \'1\' :return: The number of valid binary substrings groups = [1] for i in range(1, len(s)): if s[i] != s[i-1]: groups.append(1) else: groups[-1] += 1 count = 0 for i in range(1, len(groups)): count += min(groups[i-1], groups[i]) return count"},{"question":"You are given a list of `n` tasks labeled with unique integers from 0 to `n-1` and a list of `dependencies` where each dependency is a pair `(a, b)` indicating that task `a` must be completed before task `b` can be started. Write a function that returns the order in which the tasks should be completed, such that all dependencies are respected. If there are multiple valid orders, return any one of them. If it is impossible to complete all the tasks due to a circular dependency, return an empty list.","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Returns the order in which tasks should be completed based on the dependencies. If a circular dependency is detected, returns an empty list. Parameters: n (int): Number of tasks labeled from 0 to n-1. dependencies (List[Tuple[int, int]]): List of task dependencies (a, b) indicating task a must be completed before task b. Returns: List[int]: Order of task completion or empty list if circular dependency detected. # Build the graph and compute in-degrees of each node graph = defaultdict(list) in_degree = [0] * n for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Queue for nodes with no incoming edges queue = deque([i for i in range(n) if in_degree[i] == 0]) task_order = [] while queue: node = queue.popleft() task_order.append(node) # Decrease the in-degrees of neighboring nodes for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If task_order contains all tasks, return it, otherwise return an empty list return task_order if len(task_order) == n else []"},{"question":"You are given a binary tree with `n` nodes represented by `root`. Each node has a unique value from `1` to `n`. You are also given an array `queries` of length `q`, where each query is a positive integer `k` representing a level in the binary tree. Return an array of integers where the `i-th` integer is the sum of all node values at level `queries[i]`. If a query asks for a level that does not exist in the tree, it should be treated as `0`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_sum(root, queries): from collections import deque, defaultdict if root is None: return [0] * len(queries) # BFS to find level sums queue = deque([(root, 1)]) level_sums = defaultdict(int) while queue: node, level = queue.popleft() level_sums[level] += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) result = [] for k in queries: result.append(level_sums.get(k, 0)) return result"},{"question":"Given two strings, `str1` and `str2`, write a function to determine the length of the longest contiguous subsequence that appears in both strings. The function should return an integer representing the length of this subsequence.","solution":"def longest_contiguous_subsequence(str1, str2): Returns the length of the longest contiguous subsequence that appears in both str1 and str2. if not str1 or not str2: return 0 m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] longest = 0 for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) return longest"},{"question":"You are given a list of `num` **projects**, each with an integer **starting time** `start[i]` and **ending time** `end[i]`, which indicates that the project starts at `start[i]` and ends at `end[i]`. For any two projects to be chosen such that one project can be completed before the other starts, the ending time of one project must be less than the starting time of the other project. Return the maximum number of non-overlapping projects that can be completed.","solution":"def max_non_overlapping_projects(start, end): Returns the maximum number of non-overlapping projects that can be completed. Parameters: start (list): A list of integers representing the start times of projects. end (list): A list of integers representing the end times of projects. Returns: int: The maximum number of non-overlapping projects. projects = sorted(zip(end, start)) count = 0 last_end_time = float(\'-inf\') for project_end, project_start in projects: if project_start >= last_end_time: count += 1 last_end_time = project_end return count"},{"question":"You are given a binary tree where each node contains an integer value. Write a function `sumOfLongestPath(root)` that returns the sum of the values along the longest path from the root of the tree to a leaf. If there are multiple paths of the same length, return the sum of the path with the maximum sum. For example, for the given binary tree: ``` 1 / 2 3 / / 4 5 6 / 7 ``` The longest paths are `1 -> 2 -> 4` and `1 -> 3 -> 6 -> 7`, both having a length of 3. The sum of the values along these paths are 7 and 17 respectively. Since 17 is greater, your function should return 17.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sumOfLongestPath(root): Returns the sum of the values along the longest path from the root of the tree to a leaf. If there are multiple paths of the same length, return the sum of the path with the maximum sum. def dfs(node): if not node: return (0, 0) # (sum, length) leftSum, leftLength = dfs(node.left) rightSum, rightLength = dfs(node.right) if leftLength > rightLength: return (leftSum + node.value, leftLength + 1) elif rightLength > leftLength: return (rightSum + node.value, rightLength + 1) else: return (max(leftSum, rightSum) + node.value, leftLength + 1) totalSum, _ = dfs(root) return totalSum"},{"question":"You are given an integer array `nums` representing the number of flowers in each garden along a straight path. Every night, the fairy visits and the flowers in each garden either grow or shrink according to pre-defined rules. Specifically, for each garden at position `i`, the number of flowers can either stay the same or change to be equal to the number of flowers in the adjacent garden. Given an integer `d` representing the number of nights the fairy will visit, return the minimum number of flowers that could be present in the garden with the fewest flowers after `d` nights.","solution":"def min_flowers_after_nights(nums, d): Return the minimum number of flowers that could be present in any garden after d nights. n = len(nums) for _ in range(d): new_nums = nums.copy() for i in range(1, n-1): new_nums[i] = min(new_nums[i], nums[i-1], nums[i+1]) if n > 1: new_nums[0] = min(new_nums[0], nums[1]) new_nums[-1] = min(new_nums[-1], nums[n-2]) nums = new_nums return min(nums)"},{"question":"Given a string `s`, return a new string with each character in `s` doubled. For example, given \\"abc\\", return \\"aabbcc\\". The input string will contain only lowercase English letters.","solution":"def double_char(s): Returns a new string with each character in the input string doubled. Parameters: s (str): The input string containing only lowercase English letters. Returns: str: A new string with each character doubled. return \'\'.join([char * 2 for char in s])"},{"question":"You are given two **0-indexed** integer arrays `nums1` and `nums2` of length `n` each. Both arrays contain integers in any order. You need to find the minimum possible absolute sum difference between the corresponding elements of `nums1` and `nums2`. To achieve this, you are allowed to **replace** at most one element of `nums1` with any element from `nums1` itself. The absolute sum difference is defined as the sum of `|nums1[i] - nums2[i]|` for all `0 <= i < n`. Return the minimum possible absolute sum difference after at most one replacement in `nums1`. Note: The value of `|x|` denotes the absolute value of `x`.","solution":"def minAbsoluteSumDiff(nums1, nums2): n = len(nums1) sorted_nums1 = sorted(nums1) initial_sum = sum(abs(nums1[i] - nums2[i]) for i in range(n)) min_sum = initial_sum for i in range(n): original_diff = abs(nums1[i] - nums2[i]) low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if sorted_nums1[mid] < nums2[i]: low = mid + 1 else: high = mid - 1 if low < n: min_sum = min(min_sum, initial_sum - original_diff + abs(sorted_nums1[low] - nums2[i])) if high >= 0: min_sum = min(min_sum, initial_sum - original_diff + abs(sorted_nums1[high] - nums2[i])) return min_sum"},{"question":"You are given a **0-indexed** string `s` consisting of only lowercase English letters and an integer `k`. An operation is defined as selecting any character in the string and changing it to any other character. You are allowed to perform at most `k` operations. Return `true` if you can make `s` a palindrome after performing at most `k` operations, or return `false` otherwise.","solution":"def can_be_palindrome(s, k): Returns true if the string `s` can be made a palindrome using at most `k` operations. n = len(s) # Calculate the number of changes needed to make s a palindrome changes_needed = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: changes_needed += 1 # If the changes needed is less than or equal to allowed operations k return changes_needed <= k"},{"question":"You are given a list of integers `arr` and an integer `target`. Your task is to determine if there are **two distinct indices i and j** in the array such that the elements at these indices sum up to `target`. Return _the pair of indices (i, j) if such a pair exists, with i < j. If there are multiple solutions, return any_. If no such pair exists, return `[-1, -1]`.","solution":"def find_pair_with_sum(arr, target): Find two distinct indices i and j in the array such that arr[i] + arr[j] == target. Return the pair of indices as a tuple (i, j) if such a pair exists, otherwise return [-1, -1]. seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return [-1, -1]"},{"question":"You are given a **0-indexed** 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents an interval starting at `starti` and ending at `endi`. You are also given an integer `point`. An interval `[starti, endi]` is said to **cover** the point if `starti <= point <= endi`. Return _the number of intervals that cover the point_.","solution":"def count_intervals_covering_point(intervals, point): Returns the number of intervals that cover the given point. Parameters: intervals (list of list of int): A list of intervals, where each interval is represented as a list of two integers [start, end]. point (int): The point to check the coverage for. Returns: int: The number of intervals that cover the point. count = 0 for interval in intervals: if interval[0] <= point <= interval[1]: count += 1 return count"},{"question":"Given a **2D grid** of size `m x n` where each cell represents a piece of land (`1`) or water (`0`), find and return the largest island formed only by `1`s. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may not add any `1`s, or remove any `0`s. The grid is not necessarily connected, and there may be multiple islands. If no island exists, return `0`.","solution":"def largest_island(grid): Returns the size of the largest island in the given 2D grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]] - 2D grid representation of land (1) and water (0) :return: int - size of the largest island if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find whether there exist three numbers in `nums` such that their sum is exactly equal to `target`. Return `True` if there are such three numbers, otherwise return `False`. You may assume that each input would have exactly one solution, and you may not use the same element more than once.","solution":"def three_sum(nums, target): Determines if there are three numbers in `nums` that add up to `target`. :param nums: List of integers. :param target: Integer target sum. :return: True if there are three numbers that add up to target, False otherwise. nums.sort() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a string `s`, determine if it can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character occurs an odd number of times, while all other characters occur an even number of times. Return `true` if the string can be rearranged to form a palindrome, and `false` otherwise.","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"Given a list of integers representing a histogram\'s bar heights where each bar\'s width is 1, find the area of the largest rectangle that can be formed by any group of consecutive bars. The height of the rectangle is determined by the shortest bar in the group. Return the area of this rectangle. For example, given heights = [2, 1, 5, 6, 2, 3], the largest rectangle has an area of 10 (formed by bars 5 and 6).","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram represented by heights. :param heights: List[int] representing heights of histogram bars :return: Integer representing the maximum area of a rectangle found stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array `nums` consisting of positive integers. You can perform the following operation on the array any number of times: select a non-negative integer `k` and remove all elements equal to `k` and `k + 1` from the array. Return _the minimum number of operations required to make the array empty_.","solution":"def min_operations_to_empty(nums): from collections import Counter num_counts = Counter(nums) operations = 0 while num_counts: k = min(num_counts) operations += 1 if k in num_counts: del num_counts[k] if k + 1 in num_counts: del num_counts[k + 1] return operations"},{"question":"You are given an integer array `nums`. Two numbers form a pair if the absolute difference between them is `k`. Your task is to count the number of unique pairs in the array where the absolute difference between the pairs is equal to `k`. Return _the number of unique pairs_. **Note:** A pair `(a, b)` is considered the same as `(b, a)`, and pairs should be counted only once.","solution":"def count_pairs_with_difference_k(nums, k): Returns the number of unique pairs in the array where the absolute difference between the pairs is equal to k. pairs = set() nums_set = set(nums) for num in nums: if num + k in nums_set: pairs.add((min(num, num + k), max(num, num + k))) if num - k in nums_set: pairs.add((min(num, num - k), max(num, num - k))) return len(pairs)"},{"question":"You are given an unsorted array of integers `nums`. Write a function that partitions the array into contiguous subarrays, where each subarray contains exactly the same integer. Return the lengths of these subarrays as an array. For example, given the array `nums`, you should return an array of the lengths of the contiguous subarrays with identical integers. Your function should return _an array of the lengths of these contiguous subarrays_.","solution":"def partition_lengths(nums): Partitions the array into contiguous subarrays with identical integers and returns the lengths of these subarrays. Args: nums: List[int] - The input array of integers. Returns: List[int] - The lengths of the contiguous subarrays. if not nums: return [] lengths = [] current_count = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_count += 1 else: lengths.append(current_count) current_count = 1 lengths.append(current_count) return lengths"},{"question":"You are given an array of integers `nums` where `nums[i]` represents the amount of money of the ith house. Robber logic allows robbing houses such that no two adjacent houses are robbed. Calculate the maximum amount of money you can rob tonight without alerting the police. Implement a function `int rob(vector<int>& nums)` that returns the maximum amount of money you can rob.","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police, given that no two adjacent houses can be robbed. if not nums: return 0 elif len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] if len(nums) > 1: dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a 2D grid of size `m x n` representing a maze, where `0` represents an open space and `1` represents a wall. You are placed at the top-left corner of the maze, and your objective is to reach the bottom-right corner. You can only move up, down, left, or right, and you cannot move through walls. Implement a function `boolean canReachEnd(int[][] maze)`, that returns `true` if there is a path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), and `false` otherwise. Ensure your function is efficient in both time and space. **Notes:** - Your function should return `true` if the top-left or bottom-right corners themselves are walls. - The maze is connected, meaning that every open space is reachable from every other open space. - You should avoid any cycles in your path to ensure efficiency.","solution":"def canReachEnd(maze): def isValid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 def dfs(x, y): if x == len(maze) - 1 and y == len(maze[0]) - 1: return True maze[x][y] = -1 # mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # move up, down, left, right nx, ny = x + dx, y + dy if isValid(nx, ny) and dfs(nx, ny): return True return False if maze[0][0] == 1 or maze[-1][-1] == 1: return False return dfs(0, 0)"},{"question":"You are given a string `s` that consists of only lowercase letters. You need to implement a function that returns the length of the longest substring of `s` where the frequency of each character in this substring is at least `k`. For example, if `s = \\"aaabb\\"` and `k = 3`, the longest substring where each character appears at least 3 times is `\\"aaa\\"`, so the function should return `3`. If no such substring exists, return `0`. The input string `s` will have a length of at most `10^4`.","solution":"def longest_substring_with_k_repeats(s, k): def helper(start, end, k): if end - start < k: return 0 count = [0] * 26 for i in range(start, end): count[ord(s[i]) - ord(\'a\')] += 1 for mid in range(start, end): if count[ord(s[mid]) - ord(\'a\')] >= k: continue mid_next = mid + 1 while mid_next < end and count[ord(s[mid_next]) - ord(\'a\')] < k: mid_next += 1 return max(helper(start, mid, k), helper(mid_next, end, k)) return end - start return helper(0, len(s), k)"},{"question":"You are given an array of integers `heights` representing the heights of some buildings. The task is to find the maximum area of water trapped between the buildings. The width between each building is `1`. The water can only be trapped if there is a higher building on the left and right sides of a lower building. Return the maximum area of water that can be trapped. [BONUS]: Can you solve it in O(n) time?","solution":"def max_water_area(heights): Return the maximum area of water that can be trapped between the buildings represented by heights. The width between each building is 1. if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: current_height = min(heights[left], heights[right]) current_width = right - left current_area = current_height * current_width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Implement a function that merges two sorted linked lists into a single sorted linked list. Each linked list is sorted in ascending order. The function should take two arguments, which are the heads of the two linked lists, and return the head of the merged list. The function should be efficient with respect to time and space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merges two sorted linked lists and returns the head of the merged list. Args: l1: ListNode | None - Head of the first sorted linked list. l2: ListNode | None - Head of the second sorted linked list. Returns: ListNode | None - Head of the merged sorted linked list. dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"You are given a graph represented by an adjacency list, where each node has a unique ID from `0` to `n-1`, and the graph is a DAG (Directed Acyclic Graph). Implement a system that allows you to perform queries to determine if there exists a directed path between two given nodes `u` and `v`. Your system should efficiently support the following operations: * `initialize(int n, List<List<Integer>> adjacencyList)` initializes the system with `n` nodes and the provided adjacency list. * `isPath(int u, int v)` returns `true` if there is a path from node `u` to node `v`, and `false` otherwise. Design and implement the `PathQueries` class with the methods described. Performance should be optimized considering multiple queries on the same graph.","solution":"class PathQueries: def __init__(self, n, adjacency_list): Initializes the PathQueries with n nodes and the provided adjacency list. self.n = n self.adjacency_list = adjacency_list self.reachable = [[False] * n for _ in range(n)] for u in range(n): self._dfs(u, u) def _dfs(self, start, node): Uses Depth First Search to mark reachable nodes for each start node. self.reachable[start][node] = True for neighbor in self.adjacency_list[node]: if not self.reachable[start][neighbor]: self._dfs(start, neighbor) def is_path(self, u, v): Returns True if there is a path from node u to node v, False otherwise. return self.reachable[u][v]"},{"question":"You are given a **0-indexed** string `s` that consists of lowercase English letters. In one step, you can replace any character in the string with any other lowercase English letter. The goal is to transform `s` into a string that does not contain any two adjacent characters that are the same. Return _the minimum number of steps required_ to achieve this.","solution":"def min_steps_to_alternate(s): Returns the minimum number of steps required to transform the string so that no two adjacent characters are the same. steps = 0 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: steps += 1 # Increment steps count and skip the next character since it has been changed if i < n - 1: s = s[:i] + (\'a\' if s[i] != \'a\' else \'b\') + s[i + 1:] else: # If it\'s the last character, we don\'t need to change the subsequent one s = s[:i] + (\'a\' if s[i] != \'a\' else \'b\') return steps"},{"question":"Given an integer `n`, return the length of the longest substring of `1’s` in its binary representation without consecutive `0’s`. For instance, for the integer `n = 29` (`11101` in binary), the longest substring of `1’s` without consecutive `0’s` is `3` (`111`). Implement a function `maxSubstringLength(n: int) -> int` that computes this. The binary representation should be considered as-is, i.e., do not alter the actual sequence of bits. **Example:** ```python maxSubstringLength(29) # Returns 3 maxSubstringLength(15) # Returns 4 ```","solution":"def maxSubstringLength(n: int) -> int: Returns the length of the longest substring of `1’s` in the binary representation of the given integer `n` without consecutive `0’s`. binary_rep = bin(n)[2:] # Convert to binary string without \'0b\' prefix max_len = 0 current_len = 0 for char in binary_rep: if char == \'1\': current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"You are given an integer `n` representing the number of houses in a row, labeled from `0` to `n-1`, and an integer array `costs` where `costs[i]` is the cost to paint the `i`-th house. You are also given an integer array `colors` where `colors[i]` is the color of the `i`-th house. We define the \\"neighborhoods\\" as a contiguous block of houses sharing the same color. You are also given an integer `target` representing the desired number of neighborhoods. Implement a function `minCost` that returns the minimum total cost to paint all houses such that there are exactly `target` neighborhoods. If it\'s not possible to achieve exactly `target` neighborhoods, return `-1`. **Details to consider**: - If a house has `colors[i] = 0`, it means the house is currently unpainted, and you need to paint it with a color from `1` to `m`, where `m` is the number of different colors available. - If a house is already painted (`colors[i] != 0`), you cannot change its color. - The order of houses matters, and you should aim to minimize the total cost while achieving exactly `target` neighborhoods. Return the minimum cost or `-1` if it\'s not possible.","solution":"import functools def minCost(n, costs, colors, m, target): @functools.lru_cache(None) def dp(i, k, last_color): if k < 0 or k > target: return float(\'inf\') if i == n: return 0 if k == 0 else float(\'inf\') if colors[i] != 0: return dp(i + 1, k - (colors[i] != last_color), colors[i]) return min(costs[i][c-1] + dp(i+1, k - (c != last_color), c) for c in range(1, m + 1)) result = dp(0, target, 0) return -1 if result == float(\'inf\') else result"},{"question":"Given a binary tree, imagine yourself standing on the *right* side of it, return an array of the values of the nodes you can see ordered from top to bottom. Each node has a distinct value, and the tree can have an arbitrary number of levels. Create a function `right_side_view` which takes the root of the binary tree as input and returns the list of visible node values.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the list of node values that are visible from the right side view. if not root: return [] view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # if it\'s the rightmost element of this level if i == level_length - 1: view.append(node.val) # enqueue child nodes if node.left: queue.append(node.left) if node.right: queue.append(node.right) return view"},{"question":"Given a `2D` integer array `points` where each `points[i] = [xi, yi]` represents a point on the coordinate plane, find the **minimum distance** between any two distinct points `(xi, yi)` and `(xj, yj)`. The distance between two points is defined as `sqrt((xi - xj)^2 + (yi - yj)^2)`. Return _the **minimum distance** between any two points._ If the array contains fewer than two points, return `-1`.","solution":"import math def min_distance(points): Returns the minimum distance between any two distinct points in the points array. If the array contains fewer than two points, returns -1. if len(points) < 2: return -1 min_dist = float(\'inf\') for i in range(len(points)): for j in range(i + 1, len(points)): dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) if dist < min_dist: min_dist = dist return min_dist"},{"question":"**[Question 4]:** Given a list of non-negative integers `nums`, return the length of the longest subsequence of `nums` such that every element in the subsequence is an exact multiple of the previous element. A subsequence is derived by deleting some or no elements from the array without changing the order of the remaining elements. * For example, if `nums = [3, 6, 12, 24, 48]`, then `[3, 6, 12, 24, 48]` is a valid subsequence where each subsequent number is a multiple of the previous. * If `nums = [2, 3, 5, 10]`, then `[5, 10]` is a valid subsequence but `[2, 3, 5, 10]` is not because `5` is not a multiple of `3`. Return the length of this longest subsequence.","solution":"def longest_multiple_subsequence(nums): if not nums: return 0 nums.sort() dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of `n` non-negative integers representing the amount of rainwater trapped between each bar in a bar graph. Each integer corresponds to the height of a bar. Compute the maximum amount of water that can be trapped between the bars. Return _the total amount of trapped rainwater_.","solution":"def trap(height): Calculate the amount of trapped rain water given a list of bar heights. :param height: List[int], a list of non-negative integers representing bar heights :return: int, the total amount of trapped rainwater n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a string `s` that consists of digits only and an integer `k`. You can remove `k` digits from the string so that the resulting string is the smallest possible. Return the resulting string as the smallest possible number. # Example: - Input: `s = \\"1432219\\"`, `k = 3` - Output: `\\"1219\\"` # Constraints: - `1 <= k <= s.length <= 10^5` - `s` consists of digits (`0-9`) only.","solution":"def removeKdigits(s, k): Removes k digits from the string s to create the smallest possible number. stack = [] for digit in s: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still removals left to be made, remove from the end stack = stack[:-k] if k else stack # Strip leading zeros and return the result return \'\'.join(stack).lstrip(\'0\') or \\"0\\""},{"question":"Implement a class `VirtualFileSystem` that mimics a simple virtual file system with the following methods: - `VirtualFileSystem()`: Initializes an empty file system. - `void createFile(string filePath, int size)`: Creates a new file at the specified `filePath` with the given `size`. If a file already exists at that path, overwrite it with the new size. - `void deleteFile(string filePath)`: Deletes the file at the specified `filePath`. - `int getFileSize(string filePath)`: Returns the size of the file at the specified `filePath`. If the file does not exist, return `-1`. The file path is represented as a string with directory levels separated by a `/`. For example, `\\"/dir1/dir2/file.txt\\"` represents a path where `file.txt` is inside `dir2` which is inside `dir1`. You can assume that directories do not need to be explicitly created or managed - they are implicit from the file paths. Example: ``` VirtualFileSystem vfs = new VirtualFileSystem(); vfs.createFile(\\"/a/b/c.txt\\", 10); vfs.createFile(\\"/a/b/d.txt\\", 20); vfs.getFileSize(\\"/a/b/c.txt\\"); // returns 10 vfs.deleteFile(\\"/a/b/c.txt\\"); vfs.getFileSize(\\"/a/b/c.txt\\"); // returns -1 ```","solution":"class VirtualFileSystem: def __init__(self): self.files = {} def createFile(self, filePath, size): self.files[filePath] = size def deleteFile(self, filePath): if filePath in self.files: del self.files[filePath] def getFileSize(self, filePath): return self.files.get(filePath, -1)"},{"question":"Given an integer array `nums`, partition it into two subarrays (the left subarray and the right subarray) such that: - Every element in the left subarray is less than or equal to every element in the right subarray. - The left subarray is non-empty. Return the length of the left subarray. If multiple ways to partition the array satisfy the above conditions, return the smallest possible length of the left subarray.","solution":"def partition_disjoint(nums): Returns the length of the left subarray where every element in the left subarray is less than or equal to every element in the right subarray. n = len(nums) # Create a list to store max of left subarray up to each index left_max = [0]*n left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i-1], nums[i]) # Create a list to store min of right subarray from each index right_min = [0]*n right_min[-1] = nums[-1] for i in range(n-2, -1, -1): right_min[i] = min(right_min[i+1], nums[i]) # Find the partition point for i in range(1, n): if left_max[i-1] <= right_min[i]: return i return n # In case no partition found, the whole array is the left subarray."},{"question":"A binary tree is considered **\\"complete\\"** if every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. Given `root`, a reference to the root of a **complete binary tree**, determine if it is indeed a **complete binary tree**. Return `true` if the tree is complete, `false` otherwise. **Custom testing:** 1. The input data will be provided as a serialized form of the binary tree. 2. The driver code will construct the binary tree from the serialized input data. 3. The driver code will pass the tree `root` to your function to validate completeness.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteTree(root): Determines if a binary tree is complete. if not root: return True queue = [root] end = False while queue: node = queue.pop(0) if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"You are given an integer array `nums` where each element represents the position of a house along a street. You are also given an integer `k` representing the number of mailboxes to be installed. Your task is to determine the minimum total distance between each house and its nearest mailbox. Return _the minimum total distance required_.","solution":"def min_distance_to_mailboxes(nums, k): Returns the minimum total distance between each house and its nearest mailbox. The nums list is sorted and dynamic programming is used to find the best locations to place k mailboxes. # Utility function to calculate distance for a segment def distance(start, end): median_index = (start + end) // 2 median = nums[median_index] return sum(abs(nums[i] - median) for i in range(start, end + 1)) n = len(nums) nums.sort() # dp[i][j]: the minimum distance to place j+1 mailboxes among the first i+1 houses dp = [[float(\'inf\')] * k for _ in range(n)] for i in range(n): dp[i][0] = distance(0, i) for j in range(1, k): for i in range(n): for m in range(i): dp[i][j] = min(dp[i][j], dp[m][j-1] + distance(m + 1, i)) return dp[-1][-1]"},{"question":"You are given an array `rooms` where `rooms[i]` represents a list of keys in room `i`. Each room is numbered sequentially from `0` to `n-1`. Initially, you are in room `0` and must figure out if you can visit all the rooms. You start with a set of keys that contains only the key to room `0`. Each subsequent key you acquire allows you to enter a corresponding room. Return _true_ if you can visit all the rooms, otherwise return _false_. **Function Signature:** ``` def canVisitAllRooms(rooms: List[List[int]]) -> bool: ```","solution":"def canVisitAllRooms(rooms): Returns True if all rooms can be visited, otherwise False. visited = set() stack = [0] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(rooms[current]) return len(visited) == len(rooms)"},{"question":"An array `productIDs` contains unique integer identifiers for different products available in a warehouse. Each product belongs to a category given in the array `categories`, where `categories[i]` is the category for the product with ID `productIDs[i]`. You are asked to map each category to the list of product IDs in that category and return a dictionary where the keys are the categories, and the values are lists of product IDs in ascending order. Ensure the lists of product IDs are sorted in ascending order within each category.","solution":"def map_categories_to_products(productIDs, categories): Maps each category to the list of product IDs in that category and returns a dictionary where the keys are the categories, and the values are lists of product IDs in ascending order. Parameters: productIDs (list of int): List of unique product identifiers. categories (list of int): List of categories corresponding to each product ID. Returns: dict: Dictionary where keys are categories and values are lists of product IDs. category_map = {} for pid, cat in zip(productIDs, categories): if cat not in category_map: category_map[cat] = [] category_map[cat].append(pid) for cat in category_map: category_map[cat].sort() return category_map"},{"question":"Given a list of `tickets` where each ticket is represented as a tuple `(from, to)`, write a function that reconstructs the itinerary in order. All of the tickets belong to a man who departs from `JFK`. Hence, the itinerary must begin with `JFK`. If there are multiple valid itineraries, you should return the itinerary which has the smallest lexical order when read as a single string. You may assume all tickets form at least one valid itinerary. For example, if your tickets are `[(JFK, SFO), (JFK, ATL), (SFO, ATL), (ATL, JFK), (ATL, SFO)]`, the output should be `[\'JFK\', \'ATL\', \'JFK\', \'SFO\', \'ATL\', \'SFO\']`. Implement the function: ```python def findItinerary(tickets: List[Tuple[str, str]]) -> List[str]: ```","solution":"from typing import List, Tuple import collections def findItinerary(tickets: List[Tuple[str, str]]) -> List[str]: # Create graph using a dictionary of lists graph = collections.defaultdict(list) for src, dest in sorted(tickets): graph[src].append(dest) itinerary = [] def dfs(airport): while graph[airport]: next_airport = graph[airport].pop(0) dfs(next_airport) itinerary.append(airport) dfs(\\"JFK\\") return itinerary[::-1]"},{"question":"You are given a string `expression` representing a mathematical expression that can contain integers, the binary operators `+`, `-`, `*`, `/`, and parentheses `()`. The operators have their usual precedence: `*` and `/` higher than `+` and `-`. Parentheses can be used to override the precedence. Evaluate the expression and return its result as an integer. Assume the division operator `/` represents integer division.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing integers, +, -, *, / operators, and parentheses () with proper precedence and return the result as an integer. def calc(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # integer division def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operations(values_stack, ops_stack): op = ops_stack.pop() second = values_stack.pop() first = values_stack.pop() values_stack.append(calc(op, second, first)) def evaluate(expression): values_stack = [] ops_stack = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': ops_stack.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values_stack.append(val) i -= 1 elif expression[i] == \')\': while ops_stack and ops_stack[-1] != \'(\': apply_operations(values_stack, ops_stack) ops_stack.pop() # remove \'(\' from stack else: while ops_stack and precedence(ops_stack[-1]) >= precedence(expression[i]): apply_operations(values_stack, ops_stack) ops_stack.append(expression[i]) i += 1 while ops_stack: apply_operations(values_stack, ops_stack) return values_stack[0] return evaluate(expression)"},{"question":"Given a list of non-negative integers `nums`, your task is to determine if it is possible to split the entire list into three contiguous subarrays such that the sum of the integers in each subarray is equal. If possible, return _True_ else return _False_. * For example, for the array `[0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]`, it is possible to split it into three subarrays: `[0, 2, 1]`, `[-6, 6, -7, 9]`, and `[1, 2, 0, 1]`, all of which sum to `3`. Hence, the function should return `True`.","solution":"def split_array_into_three_equal_parts(nums): Determines if it\'s possible to split the array into three contiguous subarrays with equal sums. total_sum = sum(nums) if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum, parts_found = 0, 0 for num in nums: current_sum += num if current_sum == target_sum: parts_found += 1 current_sum = 0 if parts_found == 2: return True # If we found two parts, the third part must also have the target sum. return False"},{"question":"You are given a `Maze` represented by a grid of integers where `0` represents open paths and `1` represents walls. You can move up, down, left, or right but cannot pass through walls (grid cells with `1`). Write a function `canReach` that takes the grid and two pairs of coordinates, `start` and `end`, and determines whether there\'s a path from the `start` to the `end` in the maze. The function should return `true` if a path exists and `false` otherwise. You may assume the start and end positions are always valid and not walls.","solution":"def canReach(grid, start, end): Determines if there\'s a path from start to end in the given maze grid. :param grid: List[List[int]] - The grid representing the maze (0 = open path, 1 = wall) :param start: Tuple[int, int] - Starting coordinates (row, col) :param end: Tuple[int, int] - Ending coordinates (row, col) :return: bool - True if a path exists from start to end, False otherwise rows = len(grid) cols = len(grid[0]) def is_in_bounds(r, c): return 0 <= r < rows and 0 <= c < cols def bfs(start, end): from collections import deque queue = deque([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] seen = set() seen.add(start) while queue: current = queue.popleft() if current == end: return True for dr, dc in directions: nr, nc = current[0] + dr, current[1] + dc if is_in_bounds(nr, nc) and (nr, nc) not in seen and grid[nr][nc] == 0: queue.append((nr, nc)) seen.add((nr, nc)) return False return bfs(start, end)"},{"question":"You are given a list of projects represented by a list of integers `projects` where each integer represents the amount of reward for completing a project. Additionally, you have a limitation, you can only work on at most `k` projects at a time. Implement a function `maximizeReward(projects: List[int], k: int) -> int` that returns the maximum reward you can achieve by selecting at most `k` projects such that their total reward is maximized. Your solution should take into consideration that the order of project rewards may not initially favor the maximum reward selection, so you might need to sort or apply a strategy to optimize the selection process.","solution":"from typing import List def maximizeReward(projects: List[int], k: int) -> int: Returns the maximum reward achievable by selecting at most k projects. Parameters: projects (List[int]): List of rewards for each project. k (int): Maximum number of projects that can be selected. Returns: int: Maximum reward # Sort projects in descending order to maximize reward projects.sort(reverse=True) # Select up to k projects from the sorted list return sum(projects[:k])"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` positive integers and a positive integer `x`. Your task is to find the length of the longest contiguous subarray where the sum of its elements is divisible by `x`. If no such subarray exists, return `-1`.","solution":"def longest_subarray_divisible_by_x(nums, x): Finds the length of the longest contiguous subarray where the sum of its elements is divisible by x. prefix_sum_index = {0: -1} prefix_sum = 0 max_length = -1 for i, num in enumerate(nums): prefix_sum += num remainder = prefix_sum % x if remainder in prefix_sum_index: max_length = max(max_length, i - prefix_sum_index[remainder]) else: prefix_sum_index[remainder] = i return max_length"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. Your task is to find the maximum average of any subarray of length `k` in the `nums` array. Return the maximum average value as a floating-point number. If there are multiple subarrays with the same maximum average, return the first one encountered. Each subarray should consist of exactly `k` consecutive elements from the original array. The result should be rounded to 5 decimal places for precision.","solution":"def findMaxAverage(nums, k): Finds the maximum average subarray of length k in the nums array. n = len(nums) max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return round(max_sum / k, 5)"},{"question":"You are given a 2D integer grid `grid` representing a maze where `1` represents a wall and `0` represents an open path. You are also given two pairs of integers, `start` and `end`, where `start = [startRow, startCol]` represents your starting position in the maze and `end = [endRow, endCol]` represents your destination. You can move up, down, left, or right, but can\'t move through walls. Return _the length of the shortest path from start to end in the maze_. If there is no path, return `-1`.","solution":"from collections import deque def shortest_path_in_maze(grid, start, end): Returns the length of the shortest path from start to end in the maze. If there is no path, returns -1. :param grid: List[List[int]] - 2D integer grid representing the maze :param start: List[int] - Starting position [startRow, startCol] :param end: List[int] - Ending position [endRow, endCol] :return: int - Length of the shortest path or -1 if no path exists if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 ROWS, COLS = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set((start[0], start[1])) while queue: row, col, steps = queue.popleft() if [row, col] == end: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < ROWS and 0 <= new_col < COLS and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1"},{"question":"You are given a list `transactions` where each transaction is represented as a tuple `(sender, receiver, amount)`. Your task is to determine for each person the net balance at the end of the transactions. Assume all people have an initial balance of `0`. A person\'s net balance is calculated as the sum of amounts they received minus the sum of amounts they sent. Return a dictionary where the keys are the names of the persons and the values are their net balances. The list of transactions and persons can be large, so your solution should be efficient in terms of both time and space complexity.","solution":"def calculate_net_balances(transactions): Calculate net balance for each person given a list of transactions. :param transactions: list of tuples (sender, receiver, amount) :return: dictionary with person names as keys and net balances as values balances = {} for sender, receiver, amount in transactions: if sender not in balances: balances[sender] = 0 if receiver not in balances: balances[receiver] = 0 balances[sender] -= amount balances[receiver] += amount return balances"},{"question":"[Question] 4: Given a 2D grid of characters and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Return _`true`_ if the word exists in the grid and _`false`_ otherwise.","solution":"def exist(board, word): if not board: return False rows, cols = len(board), len(board[0]) def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[word_index]: return False temp = board[x][y] board[x][y] = \'#\' found = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) board[x][y] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"You are provided with an undirected graph with `n` nodes, labeled from `1` to `n`. You are also given a list of edges `edges` where each edge is formed by a pair of nodes `[ui, vi]` denoting an undirected edge between node `ui` and node `vi`, and a positive integer array `values` of length `n`, where `values[i]` represents the value associated with the node `i`. A **connected component** of the graph is a set of nodes such that there is a path between any two nodes in this set. The **value** of a connected component is the sum of values of nodes in this component. Return _the **maximum value** among all connected components in the graph_.","solution":"def maximum_connected_component_value(n, edges, values): from collections import defaultdict, deque def bfs(node, visited, graph, values): queue = deque([node]) visited[node] = True component_value = 0 while queue: current = queue.popleft() component_value += values[current - 1] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_value # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize visited array visited = [False] * (n+1) max_value = 0 # Perform BFS for each node for node in range(1, n+1): if not visited[node]: component_value = bfs(node, visited, graph, values) max_value = max(max_value, component_value) return max_value"},{"question":"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Implement the `mergeKLists` function that accepts a list of `k` linked-lists and returns a single sorted linked-list. - Class `ListNode`: - `int val` - `ListNode next` - Function signature: ```python def mergeKLists(self, lists: List[ListNode]) -> ListNode: ```","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next class Solution: def mergeKLists(self, lists: List[ListNode]) -> Optional[ListNode]: # Create a min-heap heap = [] for i in range(len(lists)): if lists[i]: heapq.heappush(heap, (lists[i].val, i, lists[i])) # Dummy head and current pointer dummy = ListNode() current = dummy # While there are elements in the heap while heap: val, i, node = heapq.heappop(heap) current.next = node current = current.next if node.next: heapq.heappush(heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"Implement the `StreamChecker` class to solve the following problem. You are given a list of words, and you need to process streams of characters to determine if any word in the list of words ends with the current stream. The `StreamChecker` class should contain the following methods: * `StreamChecker(String[] words)` Initializes the `StreamChecker` object with the given list of words. * `boolean query(char letter)` Adds the character `letter` to the current stream and returns `true` if any word in the list of words ends with the current stream. Otherwise, it returns `false`. Note: The queries will be in the order they appear in the stream. The length of any word in `words` will be at most 50, and the number of queries will not exceed 10^4.","solution":"class StreamChecker: def __init__(self, words): self.trie = {} self.stream = [] self.max_length = 0 for word in words: node = self.trie for char in reversed(word): if char not in node: node[char] = {} node = node[char] node[\'\'] = True self.max_length = max(self.max_length, len(word)) def query(self, letter): self.stream.append(letter) if len(self.stream) > self.max_length: self.stream.pop(0) node = self.trie for char in reversed(self.stream): if char in node: node = node[char] if \'\' in node: return True else: break return False"},{"question":"Given a matrix `grid` of size `n x n` consisting of only 0\'s and 1\'s, return the size of the largest square containing only 1\'s. A square is defined as a collection of cells forming a square of `1 x 1`, `2 x 2`, `3 x 3`, etc. The size of the square is determined by the length of its side. Implement the following method: `int largestSquare(int[][] grid)` The method should return an integer representing the side length of the largest square that can be formed in the given matrix.","solution":"def largestSquare(grid): if not grid or not grid[0]: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given an `m x n` 2D grid `grid` of integers where each integer represents the height of a building located at that cell. The rain water can flow to neighboring cells either left, right, up, or down only if the neighboring cell\'s height is less than or equal to the current cell\'s height. Water can flow from an edge cell to the ocean, and cells at the edges are considered connected to the ocean. Determine the cells where water can flow to both the Pacific and Atlantic oceans. Return _a list of grid coordinates where water can flow to both oceans_.","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) def bfs(starts): visited = set(starts) queue = list(starts) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: r, c = queue.pop(0) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] >= grid[r][c]: queue.append((nr, nc)) visited.add((nr, nc)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_starts = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) return list(pacific_reachable & atlantic_reachable)"},{"question":"[Question] 4: A robot is located at the top-left corner of a `m x n` grid (marked \'Start\' in the diagram below). The robot can move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below). How many possible unique paths are there? The grid is represented as follows: ``` Start . . . . . . . . . . . . . Finish ``` Write a function that takes two integers `m` and `n`, representing the number of rows and columns of the grid respectively, and returns the number of unique paths the robot can take from the top-left corner to the bottom-right corner. Your solution should consider the constraints typically associated with dynamic programming.","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. # Create a 2D list (table) to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column to 1 because there\'s only one way to # get to any cell in the first row (only move right) or first column (only move down) for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table using the relationship: # The number of ways to get to a cell is the sum of ways to get to the cell above it and # the cell to the left of it. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths to reach it return dp[-1][-1]"},{"question":"You are given two integers `x` and `y`, representing the coordinates of a point on a 2D graph. Write a function that determines the number of unique paths from the origin `(0, 0)` to the point `(x, y)` if you can only move either right or up at each step. Each path consists of exactly `x` moves to the right and `y` moves up. Return _the number of unique paths_.","solution":"from math import comb def unique_paths(x, y): Returns the number of unique paths from (0, 0) to (x, y) moving only right or up. # Using combinatorics, the number of unique paths is given by the binomial coefficient (x + y) choose x return comb(x + y, x)"},{"question":"You are given an integer array `numbers` of length `n` and an integer `X`. Your task is to find the **length** of the **smallest subarray** of `numbers` such that the **sum** of its elements is **greater than or equal to** `X`. If no such subarray exists, return `-1`. For example: * If `numbers = [2, 3, 1, 2, 4, 3]` and `X = 7`, the result is `2` because the smallest subarray with sum greater than or equal to `7` is `[4, 3]`. * If `numbers = [1, 4, 4]` and `X = 4`, the result is `1` because the smallest subarray with sum greater than or equal to `4` is `[4]`. The tests are generated such that there is always a possible solution if `X` is less than or equal to the sum of all elements in `numbers`.","solution":"def smallest_subarray_with_sum(numbers, X): Returns the length of the smallest subarray with sum greater than or equal to X. Returns -1 if no such subarray exists. n = len(numbers) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += numbers[end] while current_sum >= X: min_length = min(min_length, end - start + 1) current_sum -= numbers[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a string `s` and a list of indices `indices` where each index represents the start position of an asterisk (\'*\' ) that needs to be added, return the string after inserting the asterisks at the specified positions. The returned string should place asterisks exactly at the given positions and maintain the original order of characters not modified by the insertions.","solution":"def insert_asterisks(s, indices): Inserts asterisks (\'*\') into the string `s` at positions specified in `indices`. Args: s (str): The original string. indices (list): A list of integer positions where asterisks should be inserted. Returns: str: The modified string with asterisks inserted. indices.sort() # Ensure indices are sorted result = [] last_index = 0 for index in indices: result.append(s[last_index:index]) result.append(\'*\') last_index = index result.append(s[last_index:]) return \'\'.join(result)"},{"question":"Given a list of `n` strings where each string represents a unique user email address, determine whether any two email addresses are considered equivalent. Email addresses are equivalent if they are identical when both the local name and domain name are disregarded. The local name is the part before the \'@\' and the domain name is the part after the \'@\'. A local name can contain any of the following characters: - Lowercase and uppercase letters. - Numbers. - Special characters, except \'+\', which can be used to filter out local name content after it including the \'+\'. - The character \'.\' can be used to separate the local name segments and should be ignored in the comparison. Return a list of tuples where each tuple contains two email addresses that are considered equivalent, or an empty list if there are none.","solution":"def standardize_email(email): Standardizes the email address based on the rules: 1. The local part is considered the part before the \'@\' symbol. 2. Ignore any portion of the local part from \'+\' onwards. 3. Ignore all \'.\' characters in the local part. local, domain = email.split(\'@\') if \'+\' in local: local = local.split(\'+\')[0] local = local.replace(\'.\', \'\') return f\\"{local}@{domain}\\" def find_equivalent_emails(emails): Given a list of email addresses, return a list of tuples where each tuple contains two email addresses that are considered equivalent based on the provided rules. :param emails: List of email strings :return: List of tuples of equivalent email pairs standardized_emails = {} equivalents = [] for email in emails: standardized = standardize_email(email) if standardized in standardized_emails: equivalents.append((standardized_emails[standardized], email)) else: standardized_emails[standardized] = email return equivalents"},{"question":"Given a string `s` and an integer `k`, you need to return the length of the longest substring that contains at most `k` distinct characters. If `k` is zero, the longest substring will have a length of zero. For example, for the input `s = \\"eceba\\"` and `k = 2`, the output would be `3` as the longest substring is `\\"ece\\"`.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. :param s: Input string :param k: Integer representing maximum number of distinct characters allowed :return: Length of longest substring with at most k distinct characters if k == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a 2D grid containing digits from \'0\' to \'9\'. Each digit represents the cost of stepping onto that cell. You need to find the path from the top-left corner to the bottom-right corner that minimizes the total cost. You can only move either down or right at any point in time. Return the minimum cost of reaching the bottom-right corner from the top-left corner.","solution":"def minPathSum(grid): Returns the minimum path cost from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a cost matrix with the same dimensions as the grid cost = [[0 for _ in range(cols)] for _ in range(rows)] cost[0][0] = int(grid[0][0]) # Initialize first column for i in range(1, rows): cost[i][0] = cost[i-1][0] + int(grid[i][0]) # Initialize first row for j in range(1, cols): cost[0][j] = cost[0][j-1] + int(grid[0][j]) # Populate the cost matrix for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + int(grid[i][j]) return cost[rows-1][cols-1]"},{"question":"Given the head of a singly linked list, return the list after reversing it. You must solve this by modifying the pointers of the nodes in-place without creating any new nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list given its head. :param head: ListNode, the head of the singly linked list. :return: ListNode, the new head of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a list of `n` integers `nums` and an integer `k`. You need to find the length of the longest continuous subarray that contains at most `k` distinct integers. For example, given `nums = [1,2,1,2,3]` and `k = 2`, the longest subarray satisfying the condition is `[1,2,1,2]` which has length `4`. Return _the **length of the longest continuous subarray** with at most_ `k` _distinct integers._","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest continuous subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n * k == 0: return 0 start, end = 0, 0 count = defaultdict(int) max_len = 1 while end < n: count[nums[end]] += 1 while len(count) > k: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_len = max(max_len, end - start + 1) end += 1 return max_len"},{"question":"You are given an integer array `nums`. Identify the largest contiguous subarray within `nums` that has the maximum possible sum and return that sum. If the array contains all negative numbers, return the largest single element. The subarray must contain at least one element.","solution":"def max_subarray_sum(nums): Returns the largest sum of a contiguous subarray. If nums contains all negative numbers, returns the largest single element. The subarray must contain at least one element. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a `m x n` matrix `grid` filled with non-negative numbers, representing the number of points in each cell. A robot, starting in the top-left corner of the grid (`grid[0][0]`), wants to move to the bottom-right corner (`grid[m-1][n-1]`). The robot can only move either **right** or **down** at any point in time. Your task is to find the **maximum** number of points the robot can collect by the time it reaches the bottom-right corner. Implement a function `maxPointsCollection(grid: List[List[int]]) -> int` to solve the problem. **Example:** ``` Input: grid = [[5, 3, 2, 1], [1, 7, 1, 2], [4, 2, 8, 3], [0, 6, 4, 5]] Output: 28 Explanation: The path that collects the most points is 5→3→7→2→8→4→5, which adds up to 34. ``` **Note:** - `m == grid.length` - `n == grid[i].length` - `1 <= m, n <= 100` - `0 <= grid[i][j] <= 100`","solution":"from typing import List def maxPointsCollection(grid: List[List[int]]) -> int: Returns the maximum number of points the robot can collect by the time it reaches the bottom-right corner. m, n = len(grid), len(grid[0]) # Create a dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] # Initialize the dp array with the points at the starting position (0,0) dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from the top) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the result return dp[m-1][n-1]"},{"question":"You are given a dictionary of words and a string `sentence` that contains only spaces and lowercase letters. Implement an algorithm to replace all the substrings of `sentence` that are also in the dictionary with an asterisk (`\'*\'`). The replacement must be done in a way that preserves the original order and spacing. The length of the dictionary and the sentence should be minimized. Implement the `replaceWords` function: ```python def replaceWords(dictionary: List[str], sentence: str) -> str: # Implement the function here ```","solution":"from typing import List def replaceWords(dictionary: List[str], sentence: str) -> str: Replaces all the substrings of `sentence` that are present in the `dictionary` with an asterisk (\'*\'). # Split the sentence into words words = sentence.split() # Iterate over each word in the sentence for i, word in enumerate(words): # Check if the word is in the dictionary if word in dictionary: # Replace the word with an asterisk words[i] = \'*\' # Join the words back into a sentence return \' \'.join(words)"},{"question":"Implement a function `int romanToInt(string s)` that converts a Roman numeral to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Each symbol has a corresponding integer value: - I : 1 - V : 5 - X : 10 - L : 50 - C : 100 - D : 500 - M : 1000 There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. Given a Roman numeral, transform it into an integer. Ensure the input Roman numeral is valid and within the range from 1 to 3999. **Example:** ```python assert romanToInt(\\"III\\") == 3 assert romanToInt(\\"IV\\") == 4 assert romanToInt(\\"IX\\") == 9 assert romanToInt(\\"LVIII\\") == 58 assert romanToInt(\\"MCMXCIV\\") == 1994 ``` Return the integer representation of the Roman numeral.","solution":"def romanToInt(s): Converts a Roman numeral to an integer. Parameters: s (str): Roman numeral as a string. Returns: int: The integer representation of the Roman numeral. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return `true` if `s` can be segmented into a sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Implement the function `bool wordBreak(String s, List<String> wordDict)` where: - `s` is a string consisting of lowercase English letters. - `wordDict` is a list of non-empty words. Your code will be tested as follows: ```python result = wordBreak(s, wordDict) ``` Return `true` if `s` can be segmented as described, otherwise return `false`.","solution":"def wordBreak(s, wordDict): Returns True if \'s\' can be segmented into a sequence of one or more words from \'wordDict\', otherwise returns False. word_set = set(wordDict) # Convert list to set for faster lookups dp = [False] * (len(s) + 1) # DP array to store results of subproblems dp[0] = True # Base case - empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house, arranged in a circular neighborhood. Each house is placed adjacently such that the first house is beside the last house. Robbing two adjacent houses will automatically trigger the alarm and the money cannot be robbed from those houses. Return the maximum amount of money you can rob tonight without triggering the alarm.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering alarm from circular arrangement of houses. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums) def rob_linear(houses): prev, curr = 0, 0 for amount in houses: prev, curr = curr, max(prev + amount, curr) return curr return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"A sequence of numbers is called a **mountain array** if it consists of an initial **strictly increasing** sequence followed by a **strictly decreasing** sequence. The length of the increasing sequence and the decreasing sequence must both be greater than or equal to 1. Given an array of integers `arr`, return _true_ if it is a mountain array. Otherwise, return _false_.","solution":"def is_mountain_array(arr): Determines if the given array is a mountain array. A mountain array is a sequence of numbers that consists of an initial strictly increasing sequence followed by a strictly decreasing sequence. The length of the increasing sequence and the decreasing sequence must both be greater than or equal to 1. Args: arr (list): List of integers to be checked. Returns: bool: True if the array is a mountain array, False otherwise. if len(arr) < 3: return False i = 1 # Increasing sequence while i < len(arr) and arr[i] > arr[i - 1]: i += 1 # The peak cannot be the first or the last element if i == 1 or i == len(arr): return False # Decreasing sequence while i < len(arr) and arr[i] < arr[i - 1]: i += 1 return i == len(arr)"},{"question":"You are given a string `s` and an integer `n`. Your task is to create a new string by rotating `s` to the right by `n` characters. If `n` is negative, rotate the string to the left by the absolute value of `n` characters. For example, given the string `\\"abcdefg\\"` and `n = 2`, the result should be `\\"fgabcde\\"`. If `n = -2`, the result should be `\\"cdefgab\\"`. Ensure to handle cases where `n` is larger than the length of the string. Return _the resulting string after the rotation_.","solution":"def rotate_string(s, n): Rotate the string s by n characters. If n is positive, rotate to the right; if n is negative, rotate to the left. :param s: The string to rotate :param n: The number of characters to rotate by :return: The rotated string # Ensure n is within the bounds of the string\'s length n = n % len(s) if s else 0 # Perform the rotation return s[-n:] + s[:-n]"},{"question":"Given a string `s` containing only lowercase alphabetical characters and an integer `k`, determine if you can rearrange the characters in `s` such that there are no two adjacent characters that are the same, with at most `k` occurrences of any character. Return `true` if it is possible to rearrange `s` under these constraints, and `false` otherwise. For example, given `s = \\"aaabbc\\"` and `k = 2`, you can rearrange `s` as `\\"ababac\\"` which meets the conditions.","solution":"from collections import Counter from heapq import heappush, heappop def can_rearrange(s, k): Determine if the string `s` can be rearranged such that there are no two adjacent characters that are the same with at most `k` occurrences of any character. if not s: return True n = len(s) char_count = Counter(s) if any(count > (n + 1) // 2 for count in char_count.values()): return False max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) result = [] while max_heap: temp = [] for _ in range(min(k, len(s))): if not max_heap: break count, char = heappop(max_heap) result.append(char) if count < -1: temp.append((count + 1, char)) if temp and not max_heap and len(result) < n: return False for item in temp: heappush(max_heap, item) return True"},{"question":"You are given a string `s` which represents a spreadsheet column title as it appears in an Excel sheet. For example: - \\"A\\" -> 1 - \\"B\\" -> 2 - \\"Z\\" -> 26 - \\"AA\\" -> 27 - \\"AB\\" -> 28 - \\"ZY\\" -> 701 - \\"ZZ\\" -> 702 Write a function that converts the given column title `s` to its corresponding column number. Return the integer that corresponds to the column number of the title.","solution":"def titleToNumber(s): Convert a spreadsheet column title to its corresponding column number. Args: s (str): A string representing the Excel column title. Returns: int: The column number corresponding to the title. result = 0 for char in s: result = result * 26 + (ord(char) - ord(\'A\') + 1) return result"},{"question":"You are given a list of non-negative integers representing the amount of money of each house along a street. Each house is either early or late, and you are a professional robber planning to rob houses tonight. Each house has a 50% chance of being watched by the police. You cannot rob two adjacent houses because they may be watching your actions. Write a function `rob_houses` that determines the maximum amount of money you can rob tonight without alerting the police, given that every other house (starting from the first house) is more likely to be under surveillance. The function should take a list `houses` as its parameter and return the maximum amount of money you can rob. Implement the `rob_houses` function to find the optimal solution.","solution":"def rob_houses(houses): Returns the maximum amount of money that can be robbed tonight without alerting the police. n = len(houses) if n == 0: return 0 if n == 1: return houses[0] # Array to store the maximum robbed amount at each house rob_amount = [0] * n # Base cases rob_amount[0] = houses[0] rob_amount[1] = max(houses[0], houses[1]) for i in range(2, n): rob_amount[i] = max(rob_amount[i - 1], rob_amount[i - 2] + houses[i]) return rob_amount[-1]"},{"question":"You are given an integer array `nums` of size `n` and an integer `k`. Return _the number of non-empty subarrays that have a sum divisible by_ `k`. A subarray is a contiguous part of an array. For example, given the array `nums = [4, 5, 0, -2, -3, 1]` and `k = 5`, the output should be `7` because there are 7 subarrays with a sum divisible by 5.","solution":"def subarrays_div_by_k(nums, k): Returns the number of non-empty subarrays with a sum divisible by k. from collections import defaultdict count = 0 prefix_sum = 0 mod_count = defaultdict(int) mod_count[0] = 1 for num in nums: prefix_sum += num mod = prefix_sum % k if mod in mod_count: count += mod_count[mod] mod_count[mod] += 1 return count"},{"question":"You are given a **0-indexed** list of non-negative integers `nums`, representing the amount of rainwater that each element of the list can trap if it forms a unit-width vertical bar. You are to determine how much rainwater can be trapped between the bars after a rain. Specifically, with the heights given, calculate how many units of water remain trapped in each position between the bars. You must find the total amount of trapped water. For example, given `nums = [0,1,0,2,1,0,1,3,2,1,2,1]`, the elevation map will look like this: ``` x x x x x x x x x x x x x x x 0123456789 ``` Here, you can trap 6 units of water in the indices that form valleys. Return _the **total amount** of trapped water_.","solution":"def trap(height): Calculate the total amount of trapped water given the heights of bars. :param height: List[int] - a list of non-negative integers representing the height of each bar :return: int - total units of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the accumulated water total_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) total_water += max(0, water_level - height[i]) return total_water"},{"question":"Given a list of integers `nums` representing the heights of buildings standing in a row, write a function to determine if there exists a sequence of buildings such that the heights strictly increase. In other words, you need to check if there exists a subsequence of `nums` where every height is less than the height that comes after it. Return `true` if such a sequence exists, and `false` otherwise.","solution":"def exists_increasing_sequence(nums): Checks if there exists a strictly increasing subsequence in the list of building heights. Args: nums: List[int] - A list of integers representing building heights. Returns: bool - True if there exists an increasing subsequence, False otherwise. if len(nums) < 2: return False # A single scan to check for at least two increasing elements can suffice for i in range(1, len(nums)): if nums[i] > nums[i - 1]: return True return False"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). The binary tree is represented by a string of comma-separated values, and nodes are given in a level-order format where \'null\' represents an empty node. Write a function that constructs the binary tree from this string and then performs the level order traversal. Example driving code: ```python tree_str = \\"3,9,20,null,null,15,7\\" print(level_order_traversal(tree_str)) # Output: [[3], [9, 20], [15, 7]] ``` Note: You can assume that the input string represents a valid binary tree and has at least one node.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_str(tree_str): if not tree_str: return None nodes = tree_str.split(\',\') root = TreeNode(int(nodes[0])) queue = deque([root]) index = 1 while queue and index < len(nodes): node = queue.popleft() if nodes[index] != \'null\': node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if index < len(nodes) and nodes[index] != \'null\': node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root def level_order_traversal(tree_str): root = build_tree_from_str(tree_str) if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given an array of positive integers `heights` where each element represents the height of a building in a row. Write a function to compute the amount of water that can be trapped after it rains. Implement your solution with a time complexity of `O(n)` and a space complexity of `O(1)`.","solution":"def trap_rain_water(heights): Computes the amount of water that can be trapped after it rains given a list of building heights. :param heights: List[int] - A list of positive integers representing the height of buildings. :return: int - The amount of water that can be trapped. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"You are given an array of integers `nums` representing a sequence of numbers. Your task is to determine whether the sequence can be split into two non-empty subsequences such that the sum of the elements in each subsequence is the same. Return `true` if such a split is possible, and `false` otherwise.","solution":"def can_split_equal_sum(nums): Determines if the given list of integers can be split into two non-empty subsequences with equal sum. Args: nums (list) : list of integers Returns: bool : True if the list can be split into two non-empty subsequences with equal sum, False otherwise. total_sum = sum(nums) # If the total sum is odd, it can\'t be split into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Using a set to keep track of possible sums of subsets possible_sums = set([0]) for num in nums: new_sums = set() for s in possible_sums: new_sum = s + num if new_sum == target: return True new_sums.add(new_sum) possible_sums.update(new_sums) return False"},{"question":"Write a function `nextGreaterElement` that takes an array of integers `nums` and returns an array of integers `result` where `result[i]` is the next greater element of `nums[i]` in the array. If there is no greater element, `result[i]` should be `-1`. The \\"next greater element\\" for a given element in the array is the first element to the right of it that is greater than it. Example: ``` Input: nums = [4, 5, 2, 10, 8] Output: result = [5, 10, 10, -1, -1] ``` Return the `result` array containing the next greater elements for the input array `nums`.","solution":"def nextGreaterElement(nums): Returns an array where result[i] is the next greater element of nums[i] in the array. If there is no greater element, result[i] is -1. result = [-1] * len(nums) stack = [] for i in range(len(nums) - 1, -1, -1): while stack and stack[-1] <= nums[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(nums[i]) return result"},{"question":"Given an integer array `nums`, find out the maximum gap between any two elements in the sorted version of the array. Your algorithm should run in linear time (`O(n)`).","solution":"def maximum_gap(nums): Returns the maximum difference between any two successive elements in the sorted version of the array. if len(nums) < 2: return 0 min_val, max_val = min(nums), max(nums) bucket_size = max(1, (max_val - min_val) // (len(nums) - 1)) bucket_count = (max_val - min_val) // bucket_size + 1 buckets = [{\'min\': float(\'inf\'), \'max\': float(\'-inf\')} for _ in range(bucket_count)] for num in nums: idx = (num - min_val) // bucket_size buckets[idx][\'min\'] = min(num, buckets[idx][\'min\']) buckets[idx][\'max\'] = max(num, buckets[idx][\'max\']) max_gap, prev_max = 0, min_val for bucket in buckets: if bucket[\'min\'] == float(\'inf\'): continue max_gap = max(max_gap, bucket[\'min\'] - prev_max) prev_max = bucket[\'max\'] return max_gap"},{"question":"You are given two arrays of integers `nums1` and `nums2` sorted in non-decreasing order and two integers `k1` and `k2`. You are allowed to perform at most one operation on each of the arrays, either inserting a new element at any position or deleting an existing one. Your goal is to make both arrays have the same length. Return _the minimum absolute difference_ between the sums of the two arrays after performing the allowed operations.","solution":"def min_absolute_difference(nums1, nums2, k1, k2): def adjust_length(arr, k): if k > 0: arr.append(0) elif k < 0 and len(arr) > 0: arr.pop() len_diff = len(nums1) - len(nums2) if len_diff > 0: adjust_length(nums2, len_diff) k2 -= len_diff elif len_diff < 0: adjust_length(nums1, -len_diff) k1 += len_diff sum1 = sum(nums1) sum2 = sum(nums2) return abs(sum1 - sum2)"},{"question":"An art school is organizing a painting competition where every student is assigned a unique integer ID. The school wishes to form teams such that the sum of the IDs in each team is even. Given an integer array `student_ids` representing the IDs of the students, return the total number of different valid teams that can be formed. Two teams are different if and only if the chosen students\' IDs are different. The output should be the number of different valid teams **modulo** `10^9 + 7`. Note that a team can consist of any number of students, including just one student.","solution":"MOD = 10**9 + 7 def count_even_sum_teams(student_ids): even_count = sum(1 for x in student_ids if x % 2 == 0) odd_count = len(student_ids) - even_count # Total subsets = 2^len(student_ids), but we need to exclude the empty subset total_subsets = (1 << len(student_ids)) - 1 if odd_count == 0: # All IDs are even, so we only care about non-empty subsets of even IDs return total_subsets % MOD # Calculate the number of valid teams directly result = 1 # start with the empty subset for x in student_ids: result = (result * 2) % MOD # Exclude the empty subset result = (result - 1 + MOD) % MOD # We want the number of non-empty valid teams (modulo 10**9 + 7) return result"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to determine if there exists **two distinct** indices `i` and `j` in the array such that `arr[i] + arr[j] = target`. Return `true` if such indices exist and `false` otherwise. The solution should have a time complexity of O(n).","solution":"def two_sum(arr, target): Determines if there exist two distinct indices in the array such that their values add up to the target. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if such indices exist num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return True num_to_index[num] = i return False"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `k`. A modified greatest common divisor (GCD) is defined as the largest integer `g` such that for every subarray of length `k` in `nums`, there exists at least one integer in the subarray that is a multiple of `g`. Return the modified GCD of the array.","solution":"from math import gcd from functools import reduce def modified_gcd(nums, k): def gcd_of_list(lst): return reduce(gcd, lst) n = len(nums) if n < k: return None # Not possible to have subarrays of length k if array length is less than k overall_gcd = 0 for i in range(n - k + 1): subarray = nums[i:i+k] sub_gcd = gcd_of_list(subarray) overall_gcd = gcd(overall_gcd, sub_gcd) return overall_gcd"},{"question":"You are given an array of integers `arr` and an integer `K`. A contiguous subarray\'s \\"product\\" is computed by multiplying its elements together. Determine the number of contiguous subarrays whose product is less than `K`. Return the total count of such subarrays.","solution":"def count_subarrays_with_product_less_than_k(arr, k): Returns the number of contiguous subarrays whose product is less than k. if k <= 1: return 0 product = 1 count = 0 start = 0 for end in range(len(arr)): product *= arr[end] while product >= k and start <= end: product //= arr[start] start += 1 count += end - start + 1 return count"},{"question":"Given an array of integers, find all unique triplets in the array that sum up to zero. The solution set must not contain duplicate triplets. Return the list of triplets in any order.","solution":"def three_sum(nums): Given an array of integers, find all unique triplets in the array that sum up to zero. The solution set must not contain duplicate triplets. :param nums: List[int] :return: List[List[int]] nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"You are given a string `s` consisting of only the characters \'a\', \'b\', and \'c\'. You can delete any number of characters in the string to create a string in which no two adjacent characters are the same. Return the minimum number of deletions required to achieve this.","solution":"def min_deletions_to_avoid_adjacent_duplicates(s): Returns the minimum number of deletions required to make no two adjacent characters the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given a string `s` consisting of lowercase English letters, and you are to perform operations on `s` to convert it to a new string. You can perform the following operations any number of times in any order: * **Insert** a character at any position `i`. * **Delete** a character at any position `i`. * **Replace** a character at any position `i` with any other character. You are also given a list of words `words`, where each word is also composed of lowercase English letters. The goal is to transform `s` into one of the words from the list with the minimum number of operations. Return the minimum number of operations required to achieve this transformation.","solution":"def min_operations_to_transform(s, words): def edit_distance(word1, word2): len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len1][len2] min_operations = float(\'inf\') for word in words: min_operations = min(min_operations, edit_distance(s, word)) return min_operations"},{"question":"You are given a list of integers `tasks` where `tasks[i]` represents the time needed to complete the `i-th` task and an integer `n` representing the number of processors available. Distribute the tasks among the processors to minimize the maximum time taken by any processor. Return the minimum possible maximum time taken by any processor after distributing all the tasks.","solution":"def minimize_max_task_time(tasks, n): Distributes the tasks among the processors to minimize the maximum time taken by any processor. Parameters: tasks (List[int]): A list of integers where tasks[i] represents the time needed to complete the i-th task. n (int): The number of processors available. Returns: int: The minimum possible maximum time taken by any processor after distributing all the tasks. def is_feasible(time_limit): processors = 1 current_load = 0 for task in tasks: if current_load + task > time_limit: processors += 1 current_load = 0 if processors > n: return False current_load += task return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a string `s` consisting of lowercase alphabetic characters only, you are to transform `s` into a **beautiful string**. A beautiful string is defined as a string where no two adjacent characters are the same, `_and_` the count of each unique character is such that the maximum count of any character does not exceed half the length of the string (rounded up). If it is not possible to transform the string into a beautiful string, return `\\"NOT POSSIBLE\\"`. Otherwise, return the beautiful string with the lexicographically smallest order (the smallest possible beautiful string in alphabetical order). For example, given the string `\\"aab\\"`, the output should be `\\"aba\\"`. Given the string `\\"aaab\\"`, the output should be `\\"NOT POSSIBLE\\"`.","solution":"from collections import Counter from heapq import heappop, heappush def create_beautiful_string(s): n = len(s) # Count frequency of each character frequency = Counter(s) # Check if any character exceeds the allowed maximum frequency max_freq_allowed = (n + 1) // 2 if any(freq > max_freq_allowed for freq in frequency.values()): return \\"NOT POSSIBLE\\" # Create a max heap based on frequencies (negated for max heap behavior) max_heap = [] for char, freq in frequency.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, \'\' while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # Decrement frequency return \'\'.join(result)"},{"question":"An art gallery has `n` floors and each floor `i` has `a[i]` art pieces _arranged in a row_. A new display method requires splitting each row of art pieces into exactly `m` subsections, where each subsection must contain at least one art piece. You need to ensure that the maximum number of art pieces in the largest subsection is minimized. Return the **minimum possible maximum size of the largest subsection**. You are given the array `a` of length `n` where `a[i]` is the number of art pieces on the `i-th` floor, and an integer `m` which is the number of required subsections for each floor.","solution":"def minimize_max_size(a, m): def can_split(mid): count = 0 current_sum = 0 for pieces in a: if pieces > mid: return False if current_sum + pieces > mid: count += 1 current_sum = pieces else: current_sum += pieces count += 1 return count <= m left, right = max(a), sum(a) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a list of integers `cards` where each integer represents the points on a card and a positive integer `k`. You need to select exactly `k` cards from the beginning or the end of the list and remove them. Your goal is to maximize the sum of the points on the selected cards. Return _the **maximum sum** of points you can achieve by selecting exactly_ `k` _cards from the beginning or the end of the list_.","solution":"def maxScore(cards, k): Returns the maximum sum of points from selecting exactly k cards from the beginning or the end of the list. :param cards: List of integers representing points on each card :param k: Integer representing the number of cards to select :return: Maximum sum of points total_points = sum(cards[-k:]) # start with the sum of the last k cards max_points = total_points for i in range(k): total_points += cards[i] - cards[-k + i] max_points = max(max_points, total_points) return max_points"},{"question":"You are given a matrix of integers `mat` with `m` rows and `n` columns. A **row sum** is the sum of the elements in a single row, and a **column sum** is the sum of the elements in a single column. Return _the maximum value_ of the sum of any row sum and any column sum. To clarify, you must find and return the highest possible value you can achieve by adding any row sum to any column sum.","solution":"def max_row_col_sum(mat): Returns the maximum value of the sum of any row sum and any column sum. if not mat: return 0 m = len(mat) n = len(mat[0]) row_sums = [sum(row) for row in mat] col_sums = [sum(mat[i][j] for i in range(m)) for j in range(n)] max_row_sum = max(row_sums) max_col_sum = max(col_sums) return max_row_sum + max_col_sum"},{"question":"Given a binary tree, root of the tree is given to you along with an integer x. You need to find the maximum depth of the binary tree. Then consider all nodes at that maximum depth and return the value of the node which is the farthest from node with value x. If there are multiple nodes which are the same distance from x, return the smallest value among them. The distance between two nodes is defined as the number of edges in the shortest path between them.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def find_all_nodes_at_depth(root, depth): if not root: return [] if depth == 1: return [root] return find_all_nodes_at_depth(root.left, depth - 1) + find_all_nodes_at_depth(root.right, depth - 1) def distance_between_nodes(root, node1, node2): def lca(root, p, q): if not root or root == p or root == q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left and right: return root return left if left else right def depth_from_node(root, node, depth): if not root: return -1 if root == node: return depth left_depth = depth_from_node(root.left, node, depth + 1) if left_depth != -1: return left_depth return depth_from_node(root.right, node, depth + 1) lca_node = lca(root, node1, node2) return depth_from_node(lca_node, node1, 0) + depth_from_node(lca_node, node2, 0) def farthest_node(root, x): depth = max_depth(root) nodes_at_max_depth = find_all_nodes_at_depth(root, depth) x_node = None def find_node(root, x): if not root: return None if root.val == x: return root return find_node(root.left, x) or find_node(root.right, x) x_node = find_node(root, x) farthest_distance = -1 farthest_node_value = float(\'inf\') for node in nodes_at_max_depth: dist = distance_between_nodes(root, x_node, node) if dist > farthest_distance or (dist == farthest_distance and node.val < farthest_node_value): farthest_distance = dist farthest_node_value = node.val return farthest_node_value"},{"question":"Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: 1. The left subtree of a node contains only nodes with keys less than the node\'s key. 2. The right subtree of a node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. Each node in the tree has a `val` attribute representing its value, a `left` attribute pointing to its left child, and a `right` attribute pointing to its right child. Return _True_ if the binary tree is a valid BST, otherwise return _False_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determine if the binary tree rooted at \'root\' is a valid Binary Search Tree (BST). Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if node.val <= low or node.val >= high: return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"Given a binary tree, return the vertical order traversal of its nodes\' values. (i.e., from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. The input of the binary tree will be provided as a TreeNode class. For example, given the following tree: ``` 3 / 9 20 / 15 7 ``` The output should be: ``` [ [9], [3, 15], [20], [7] ] ``` Return _a list of lists where each sublist contains the values at each vertical order_.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrder(root): if not root: return [] node_queue = deque([(root, 0)]) column_map = defaultdict(list) while node_queue: node, col = node_queue.popleft() column_map[col].append(node.val) if node.left: node_queue.append((node.left, col - 1)) if node.right: node_queue.append((node.right, col + 1)) sorted_columns = sorted(column_map.keys()) return [column_map[col] for col in sorted_columns]"},{"question":"You are given a string `s`, representing a stream of characters. You must implement the `FirstUnique` class: - `FirstUnique(string s)` Initializes the object with the string `s`. - `char showFirstUnique()` Returns the first unique character in the stream. If there is no such character, return ` \' \' ` (a space). - `void add(char ch)` Adds the character `ch` to the stream. You should optimize the `showFirstUnique` method to work efficiently amid a sequence of `add` operations. **Example:** ``` FirstUnique firstUnique = new FirstUnique(\\"aabbccde\\"); firstUnique.showFirstUnique(); // returns \'d\' firstUnique.add(\'f\'); firstUnique.showFirstUnique(); // returns \'d\' firstUnique.add(\'d\'); firstUnique.showFirstUnique(); // returns \'e\' ``` Note: - You may assume that `showFirstUnique` and `add` methods are called frequently. Optimize for their runtime complexity.","solution":"from collections import OrderedDict class FirstUnique: def __init__(self, s: str): self.stream = s self.char_count = OrderedDict() for char in s: if char in self.char_count: self.char_count[char] += 1 else: self.char_count[char] = 1 def showFirstUnique(self) -> str: for char, count in self.char_count.items(): if count == 1: return char return \' \' def add(self, ch: str) -> None: if ch in self.char_count: self.char_count[ch] += 1 else: self.char_count[ch] = 1"},{"question":"You are given a list of integers representing the amount of gold in each mine and an integer `T` representing the maximum total minutes available to mine the gold. Each mine takes a unique number of minutes to be mined completely and yields its corresponding amount of gold. Return the maximum amount of gold you can mine within the given total minutes `T`. Note: You can only mine a whole mine or skip it; you can\'t mine a fraction of it.","solution":"def max_gold(mines, times, T): Returns the maximum amount of gold that can be mined within the given total minutes. :param mines: List of integers representing the amount of gold in each mine :param times: List of integers representing the time to completely mine each corresponding mine :param T: Integer representing the total minutes available :return: Integer representing the maximum amount of gold that can be mined n = len(mines) dp = [[0] * (T + 1) for _ in range(n + 1)] for i in range(1, n + 1): for t in range(T + 1): if times[i - 1] <= t: dp[i][t] = max(dp[i - 1][t], dp[i - 1][t - times[i - 1]] + mines[i - 1]) else: dp[i][t] = dp[i - 1][t] return dp[n][T]"},{"question":"You are given two binary trees. Write a function to check if they are identical or not. Two binary trees are considered identical if they are structurally identical and the nodes have the same value. Function signature: `bool isIdentical(TreeNode *p, TreeNode *q)` ```cpp struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isIdentical(p, q): Returns True if binary trees rooted at p and q are identical. # If both are None, they are identical if not p and not q: return True # If one is None and the other is not, they are not identical if not p or not q: return False # Compare current node values and recursively check left and right subtrees return (p.val == q.val) and isIdentical(p.left, q.left) and isIdentical(p.right, q.right)"},{"question":"Given a string `s` containing only the characters \'a\', \'b\', and \'c\', you can perform the following operation any number of times: choose any two adjacent characters in `s` and replace them with a single character that is different from both characters. For example, if `s[i]` = \'a\' and `s[i+1]` = \'b\', you can replace them with \'c\'. Return the length of the smallest string possible that can be obtained after performing the above operation any number of times.","solution":"def smallest_string_length(s): Returns the length of the smallest string possible that can be obtained after performing the operation any number of times. # If the string is empty or has one character, return its length if len(s) <= 1: return len(s) # Check if all characters in the string are the same if len(set(s)) == 1: return len(s) # If the string length is odd, the smallest string length will be 1 if len(s) % 2 == 1: return 1 # If the string length is even, the smallest string length will be 2 return 2"},{"question":"Given a list of `n` integers that represents the heights of buildings, find the maximum area of a rectangle formed by any contiguous buildings that can be contained within an array. You are given `heights` representing the heights of each building in the array, where `heights[i]` is the height of the `i-th` building. Implement the `MaxRectangle` class: - `MaxRectangle(int[] heights)` Initializes the object with the array of building heights. - `int maxArea()` Returns the maximum possible area of the rectangle contained within the array of building heights. Your solution should have a time complexity of `O(n)`.","solution":"class MaxRectangle: def __init__(self, heights): Initializes the object with the array of building heights. self.heights = heights def maxArea(self): Returns the maximum possible area of the rectangle contained within the array of building heights. stack = [] max_area = 0 index = 0 while index < len(self.heights): if not stack or self.heights[stack[-1]] <= self.heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (self.heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (self.heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a singly linked list where each node contains an integer value. The list is guaranteed to have at least one node. Your task is to determine if the linked list is a palindrome. A linked list is considered a palindrome if it reads the same forward and backward. The node structure of the linked list is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Return `True` if the linked list is a palindrome, otherwise return `False`. **Note:** You are expected to solve this with a time complexity of O(n) and a space complexity of O(1), where n is the number of nodes in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head): Determines if the linked list is a palindrome. # Function to reverse the linked list def reverse_list(head): prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev # Find the end of the first half and reverse the second half def end_of_first_half(head): slow = head fast = head while fast.next is not None and fast.next.next is not None: slow = slow.next fast = fast.next.next return slow if head is None or head.next is None: return True # Find the end of the first half and reverse the second half first_half_end = end_of_first_half(head) second_half_start = reverse_list(first_half_end.next) # Check whether or not there is a palindrome result = True first_position = head second_position = second_half_start while result and second_position is not None: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Restore the list and return the result first_half_end.next = reverse_list(second_half_start) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to modify the string by inserting the letter \'a\' at exactly `k` positions within the string. The objective is to obtain the lexicographically smallest string possible by this process. You are required to return the lexicographically smallest string that can be obtained after exactly `k` insertions.","solution":"def insert_a_for_lexicographically_smallest_string(s, k): Inserts \'a\' into the string s at exactly k positions to obtain the lexicographically smallest string possible. Parameters: s (str): The original string. k (int): The number of \'a\'s to insert. Returns: str: The lexicographically smallest string after insertions. # Insert all \'a\'s at the start to get the smallest string return \'a\' * k + s"},{"question":"A popular online retailer uses a rating system to evaluate customer satisfaction with its products. Each rating is an integer between 1 and 5, inclusive. You are required to analyze the ratings and provide a summary based on the number of ratings for each product. Specifically, you are given a list of strings `ratings`, where `ratings[i]` is in the format \\"product_id:rating\\". The `product_id` is a string identifier for the product, and `rating` is an integer between 1 and 5, representing the customer\'s rating for that product. Your task is to return a dictionary where each key is a product_id and its corresponding value is another dictionary. This inner dictionary should have keys for each rating from 1 to 5 and their corresponding count of ratings as the values. For example, given `ratings = [\\"p1:4\\", \\"p2:2\\", \\"p1:3\\", \\"p1:4\\", \\"p3:5\\", \\"p2:1\\", \\"p3:5\\"]`, the output should be: ``` { \\"p1\\": {1: 0, 2: 0, 3: 1, 4: 2, 5: 0}, \\"p2\\": {1: 1, 2: 1, 3: 0, 4: 0, 5: 0}, \\"p3\\": {1: 0, 2: 0, 3: 0, 4: 0, 5: 2} } ```","solution":"def analyze_ratings(ratings): Analyzes the ratings for each product and returns a summary dictionary. Args: ratings (list of str): A list of rating strings in the format \\"product_id:rating\\". Returns: dict: A dictionary where each key is a product_id and its value is another dictionary with keys for each rating from 1 to 5 and their counts as the values. summary = {} for rating in ratings: product_id, rating_value = rating.split(\\":\\") rating_value = int(rating_value) if product_id not in summary: summary[product_id] = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0} summary[product_id][rating_value] += 1 return summary"},{"question":"You are given a **0-indexed** array `cost` of `n` positive integers, where `cost[i]` represents the cost of jumping to index `i`. You start at index `0` and want to reach the last index of the array. You can either jump to the next index `(i + 1)` or skip an index `(i + 2)`. Your task is to find the minimum cost required to reach the end of the array. Return _the minimum total cost to reach the last index_ of the array.","solution":"def minCostClimbingStairs(cost): Returns the minimum total cost to reach the last index of the array. n = len(cost) # Initialize the first two steps dp = [0] * n # Cost to reach the first and second step is the respective cost value dp[0] = cost[0] if n > 1: dp[1] = cost[1] # Fill the dp array with minimum cost to reach each step for i in range(2, n): dp[i] = min(dp[i-1], dp[i-2]) + cost[i] # Minimum cost to reach the last or the second last step return min(dp[n-1], dp[n-2])"},{"question":"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. For example, given `1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`, you should return `1 -> 2 -> 5`. If the list is `1 -> 1 -> 1 -> 2 -> 3`, you should return `2 -> 3`. Implement the function `deleteDuplicates` which takes as input the head of a singly linked list and returns the head of the modified list. - `class ListNode`: * `int val` * `ListNode next` You may assume the linked list is sorted in ascending order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deleteDuplicates(head): Remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. :param head: ListNode - Head of the sorted linked list :return: ListNode - Head of the modified linked list dummy = ListNode(0) # Dummy node to handle edge cases dummy.next = head prev = dummy # Previous node, starting with dummy current = head # Current node while current: # Skip all nodes that have the same value as the current node while current.next and current.val == current.next.val: current = current.next # If prev.next is current, it means there was no duplicate for current.val if prev.next == current: prev = prev.next # Move prev to the next node else: # If we detected duplicates, skip all nodes with the current value prev.next = current.next current = current.next # Move to the next node return dummy.next"},{"question":"You are given four lists of integers: `A`, `B`, `C`, and `D`. Write a function to compute how many tuples (i, j, k, l) there are such that `A[i] + B[j] + C[k] + D[l] == 0`. To ensure the solution is efficient, aim to achieve a time complexity better than O(N^4) where N is the length of the lists. Return the number of tuples that satisfy this condition.","solution":"def four_sum_count(A, B, C, D): This function counts the number of tuples (i, j, k, l) such that A[i] + B[j] + C[k] + D[l] == 0. Args: A, B, C, D: Lists of integers Returns: Integer representing the number of tuples. from collections import defaultdict sum_ab = defaultdict(int) # Calculate all pair sums from A and B and count their occurrences for a in A: for b in B: sum_ab[a + b] += 1 count = 0 # For each pair sum from C and D, check if the negation of that sum is in sum_ab for c in C: for d in D: count += sum_ab[-(c + d)] return count"},{"question":"You are given a sorted integer array `arr` and a target integer `target`. Determine if there exists a pair of elements in the array such that their sum is equal to the target value. Return `true` if such a pair exists, and `false` otherwise. The function should have a linear runtime complexity and use constant extra space.","solution":"def has_pair_with_sum(arr, target): Determine if there exists a pair of elements in the sorted array \'arr\' such that their sum is equal to \'target\'. Parameters: arr (list of int): The sorted integer array. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Write a function to flatten a nested dictionary. Given a dictionary where keys can be strings and values can be either strings or nested dictionaries, flatten the dictionary such that all nested dictionaries are flattened into a single level with their keys represented in a path format. For example, given the input `{\\"a\\": {\\"b\\": {\\"c\\": \\"d\\"}, \\"e\\": \\"f\\"}}`, the output should be `{\\"a.b.c\\": \\"d\\", \\"a.e\\": \\"f\\"}`.","solution":"def flatten_dict(d, parent_key=\'\', sep=\'.\'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key string to use during flattening. sep (str): The separator between keys. Defaults to \'.\'. Returns: dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"Given a list of integers `arr`, find the **start** and **end** indices of the subarray that must be sorted in-place (from smallest to largest) to make the entire array sorted in non-decreasing order. If the array is already sorted, return `[-1, -1]`. To illustrate, if the list `arr` is `[2, 6, 4, 8, 10, 9, 15]`, sorting the subarray from index `1` to `5` (`arr[1:6]` which is `[6, 4, 8, 10, 9]`) will make the entire array sorted. Thus, for this example, your function should return `[1, 5]`.","solution":"def find_unsorted_subarray(arr): This function returns the start and end indices of the smallest subarray that must be sorted in place to make the entire array sorted in non-decreasing order. If the array is already sorted, it returns [-1, -1]. n = len(arr) start, end = -1, -1 # Find the first element which is out of order from the left for i in range(1, n): if arr[i] < arr[i - 1]: start = i - 1 break # If start is not found, the array is already sorted if start == -1: return [-1, -1] # Find the first element which is out of order from the right for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: end = i + 1 break # Find the minimum and maximum of the subarray arr[start:end+1] subarray_min = min(arr[start:end+1]) subarray_max = max(arr[start:end+1]) # Extend the start back as far as needed while start > 0 and arr[start-1] > subarray_min: start -= 1 # Extend the end forward as far as needed while end < n and arr[end] < subarray_max: end += 1 return [start, end-1]"},{"question":"Implement a class `ScoreTracker` that tracks scores for multiple players in a game. The class should support the following methods: * `void addScore(playerId, score)`: Adds the given `score` to the specified player\'s total score. * `int getTopPlayer()`: Returns the `playerId` of the player with the highest score. If multiple players have the highest score, return the one with the smallest `playerId`. * `void reset(playerId)`: Resets the score for the specified player to zero. Ensure that your implementation efficiently supports the operations as the number of players and scoring events can be very large.","solution":"class ScoreTracker: def __init__(self): self.scores = {} def addScore(self, playerId, score): if playerId not in self.scores: self.scores[playerId] = 0 self.scores[playerId] += score def getTopPlayer(self): top_player = min( (player for player in self.scores.items() if player[1] == max(self.scores.values())), key=lambda x: x[0] ) return top_player[0] def reset(self, playerId): if playerId in self.scores: self.scores[playerId] = 0"},{"question":"Given an array of integers `nums`, your task is to partition the array into one or more contiguous subarrays such that the sum of elements in each subarray is odd. Return the minimum number of subarrays required. If it is not possible to partition the array in such a way, return -1. Note that a single element subarray is also considered a contiguous subarray.","solution":"def min_odd_subarrays(nums): This function takes an array of integers and returns the minimum number of subarrays such that the sum of elements in each subarray is odd. If it\'s not possible to partition, it returns -1. count_odd = 0 for num in nums: if num % 2 != 0: count_odd += 1 # If there are no odd numbers, it\'s impossible to have an odd-sum subarray. if count_odd == 0: return -1 # If the number of odd numbers is odd, we can have subarrays summing to odd. # If the number of odd numbers is even, the problem is more complex, but # there will always be at least one subarray with an odd number sum if there\'s an odd number. return count_odd"},{"question":"Given an unsorted integer array `nums` and an integer `k`, you need to find the `k` most frequent elements in `nums`. Implement the function `List<Integer> topKFrequent(int[] nums, int k)` that returns a list of the `k` most frequent elements in the array. The answer can be returned in any order. For example, given `nums = [1,1,1,2,2,3]` and `k = 2`, the output should be `[1,2]` because `1` appears three times and `2` appears twice. Ensure that your solution is efficient for large arrays.","solution":"from collections import Counter import heapq def topKFrequent(nums, k): Find the k most frequent elements in the array nums. Args: nums: List of integers. k: Integer specifying the number of top elements to return. Returns: List of k most frequent elements in nums. # Step 1: Count the frequency of each element in nums count = Counter(nums) # Step 2: Use a max heap to extract the k most frequent elements return [item for item, freq in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"You are given a string `s` that consists of lowercase letters and an integer `k`. You are allowed to select any substring of the string and remove it, but performing this operation decreases `k` by 1 for each removal. The goal is to determine the lexicographically smallest string that can be obtained by applying the removal operation at most `k` times. If it is not possible to make any modifications (i.e., `k` is `0`), return the original string. Return _the lexicographically smallest string possible after at most `k` removals_.","solution":"def remove_k_digits(s: str, k: int) -> str: if k == 0: return s stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If k still > 0, remove the last k elements while k > 0: stack.pop() k -= 1 return \'\'.join(stack)"},{"question":"Given a binary tree, implement a `Codec` class to serialize and deserialize the tree so that serialization and deserialization are valid inverses of each other. The `Codec` class methods should be: * `String serialize(TreeNode root)` Encodes a tree to a single string. * `TreeNode deserialize(String data)` Decodes the encoded data to reconstruct the original tree. Serialize and deserialize the binary tree such that even if there are duplicate values in the nodes, the structure of the tree is preserved, and there is a single unique representation of the serialized string. You may assume that each node contains an integer value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def rserialize(node): if not node: return \'None,\' return str(node.val) + \',\' + rserialize(node.left) + rserialize(node.right) return rserialize(root) def deserialize(self, data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def rdeserialize(data_iter): val = next(data_iter) if val == \'None\': return None node = TreeNode(int(val)) node.left = rdeserialize(data_iter) node.right = rdeserialize(data_iter) return node data_list = data.split(\',\') data_iter = iter(data_list) return rdeserialize(data_iter)"},{"question":"Given an array of integers `heights` representing the heights of columns of a histogram, find the largest rectangular area that can be formed in the histogram. For simplicity, assume that all columns have a width of 1. Note: You must write an efficient algorithm where the complexity is less than O(n^2).","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a binary search tree (BST) with `n` nodes where each node contains a positive integer value. Your task is to find the lowest common ancestor (LCA) of two given nodes in the BST. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in the BST that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). The BST is structured such that the left child of a node contains a value less than the node\'s value, and the right child contains a value greater than the node\'s value. Given the root of the BST and the values of the two nodes `p` and `q`, return the value of their lowest common ancestor. ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Finds the lowest common ancestor (LCA) of two nodes in a BST. :param root: TreeNode, the root of the BST :param p: int, value of the first node :param q: int, value of the second node :return: int, value of the LCA node while root: # if both p and q are greater than root, LCA lies in right if p > root.val and q > root.val: root = root.right # if both p and q are smaller than root, LCA lies in left elif p < root.val and q < root.val: root = root.left else: # We have found the split point, i.e. the LCA node. return root.val"},{"question":"There are `n` cities connected by `m` roads. Each road has a travel time associated with it. You are given a 2D array `roads` where `roads[i] = [city1, city2, travel_time]`, indicating that there is a road between `city1` and `city2` with a travel time of `travel_time`. You need to return the minimum travel time required to visit all cities starting from city `0`. It is guaranteed that all cities can be reached from city `0`. If there are multiple ways to visit all cities with the same minimum travel time, return any one of them. The return value should be an array representing the order of cities visited, starting and ending at city `0`. **Notes:** - The cities are numbered from `0` to `n-1`. - Each pair of roads is bidirectional, which means that road `[city1, city2, travel_time]` is the same as `[city2, city1, travel_time]`.","solution":"import heapq def find_min_time_path(n, roads): Returns the minimum travel time required to visit all cities starting from city `0`. # Create adjacency list adj = {i: [] for i in range(n)} for city1, city2, travel_time in roads: adj[city1].append((travel_time, city2)) adj[city2].append((travel_time, city1)) # Prim\'s Algorithm to find minimum spanning tree (MST) def prim(start): total_cost = 0 min_heap = [(0, start, [])] # (cost, node, path) visited = set() while min_heap: cost, u, path = heapq.heappop(min_heap) if u in visited: continue visited.add(u) total_cost += cost path.append(u) for nei_cost, v in adj[u]: if v not in visited: heapq.heappush(min_heap, (nei_cost, v, path.copy())) return total_cost, path total_time, path = prim(0) # Complete the path by returning to start city path.append(0) return path"},{"question":"You are given a string `s` and an array of strings `words`, where each element of `words` is a unique word. Your task is to determine the minimum number of unique words from `words` that need to be concatenated (without rearranging the order of characters within each word) to form the string `s`. If it is not possible to form `s` using words from `words`, return -1. Each word from `words` can be used at most once in the concatenation. For example, given `s = \\"leetcode\\"` and `words = [\\"leet\\", \\"code\\", \\"le\\", \\"et\\", \\"cod\\"]`, the minimum number of unique words needed to form `s` is `2` (\\"leet\\" + \\"code\\"). If it is not possible to form `s` using words from `words`, return `-1`.","solution":"def min_concatenation(s, words): words_set = set(words) dp = [float(\'inf\')] * (len(s) + 1) dp[0] = 0 for i in range(1, len(s) + 1): for word in words_set: if s[:i].endswith(word): dp[i] = min(dp[i], dp[i - len(word)] + 1) return dp[-1] if dp[-1] != float(\'inf\') else -1"},{"question":"You are given a **2D grid** of size `m x n` representing a binary matrix, where `1` represents land and `0` represents water. An **island** is a maximal 4-directionally connected group of `1`s. The grid is considered to be connected to the boundaries and the islands can span multiple rows and columns. You need to find the size of the largest island in the grid. Write a function that takes the grid as input and returns the size of the largest island.","solution":"def largest_island(grid): if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the land as visited size = 1 size += dfs(grid, i + 1, j) size += dfs(grid, i - 1, j) size += dfs(grid, i, j + 1) size += dfs(grid, i, j - 1) return size max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(grid, i, j)) return max_island_size"},{"question":"Given a list of integers `nums`, return the **longest consecutive sequence** in the array. A consecutive sequence is a sequence of numbers where the difference between any two consecutive numbers is `1`. The sequence can appear in any order in the array. Return the length of this longest consecutive sequence.","solution":"def longest_consecutive(nums): Given a list of integers, returns the length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Only start a new sequence if `num-1` is not in the set if (num - 1) not in num_set: current_num = num current_streak = 1 # Check the next consecutive numbers while (current_num + 1) in num_set: current_num += 1 current_streak += 1 # Update longest streak if current streak is longer longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given an array of integers representing the population of different cities and an integer `k` representing the number of cities to be merged. To optimize the population distribution, you need to merge exactly `k` adjacent cities into one city such that the total difference in population size between the remaining cities is minimized. Return the minimum possible difference in the population sizes of the remaining cities after merging. The difference is calculated as the maximum population size among the remaining cities minus the minimum population size among the remaining cities.","solution":"def min_population_difference(populations, k): n = len(populations) if n == k: return 0 # If all cities are merged into one, there\'s no difference min_diff = float(\'inf\') for i in range(n - k + 1): merged_pop = sum(populations[i:i + k]) remaining_populations = populations[:i] + populations[i + k:] min_remaining = min(remaining_populations) max_remaining = max(remaining_populations) max_diff = max_remaining - min_remaining min_diff = min(min_diff, max_diff) return min_diff"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Return _an array of the squares of each number_ sorted in non-decreasing order. For example, given `nums = [-4, -1, 0, 3, 10]`, your function should return `[0, 1, 9, 16, 100]`.","solution":"def sorted_squares(nums): Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. return sorted(x * x for x in nums)"},{"question":"Given a 2D grid of size `m x n` representing a map where `0` represents water and `1` represents land, identify the largest island that can be formed by connecting adjacent lands horizontally or vertically (diagonals are not included). You are allowed to change at most one water cell (`0`) to a land cell (`1`) in order to maximize the size of the island. Return the size of the largest island. **Note:** - You may assume all four edges of the grid are surrounded by water. - A single cell of land counts as an island of size `1`.","solution":"def largestIsland(grid): Returns the size of the largest island that can be formed by converting at most one 0 to a 1. def dfs(x, y, index): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 1: return 0 grid[x][y] = index return 1 + dfs(x+1, y, index) + dfs(x-1, y, index) + dfs(x, y+1, index) + dfs(x, y-1, index) m, n = len(grid), len(grid[0]) index = 2 sizes = {0: 0} # Step 1: Identify all islands and their sizes for i in range(m): for j in range(n): if grid[i][j] == 1: size = dfs(i, j, index) sizes[index] = size index += 1 # Step 2: Try converting each 0 to 1 and calculate the potential island size max_island = max(sizes.values()) for i in range(m): for j in range(n): if grid[i][j] == 0: seen = set() for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if 0 <= x < m and 0 <= y < n and grid[x][y] > 1: seen.add(grid[x][y]) potential_size = 1 + sum(sizes[index] for index in seen) max_island = max(max_island, potential_size) return max_island"},{"question":"You are given a `k x k` grid representing a city layout where some cells might be blocked by buildings. The player controls a robot located at the top-left corner `(0,0)` and the goal is to move the robot to the bottom-right corner `(k-1,k-1)` under the following conditions: - The robot can move up, down, left, or right. - The character `\'0\'` represents a blocking building (impassable cell), and the character `\'1\'` represents a drivable road (free cell). - The robot cannot drive through buildings. Determine the length of the shortest path for the robot to reach from the top-left corner `(0,0)` to the bottom-right corner `(k-1,k-1)`. If there is no possible path, return `-1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid. Args: grid: List[List[str]], a `k x k` grid where \'0\' represents a blocking building and \'1\' represents a drivable road. Returns: int: the length of the shortest path, or -1 if no path exists. k = len(grid) if k == 0 or len(grid[0]) == 0 or grid[0][0] == \'0\' or grid[k-1][k-1] == \'0\': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # down, up, right, left queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, path_length = queue.popleft() if (row, col) == (k-1, k-1): return path_length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < k and 0 <= new_col < k and grid[new_row][new_col] == \'1\' and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, path_length + 1)) return -1"},{"question":"You are given a string `s` which consists of lowercase English letters and a list of `queries`, where each query is a list containing two integers `[start, end]`. For each query, find the count of distinct characters in the substring of `s` starting from index `start` to index `end` (inclusive). Return an array of results for each query in the input order.","solution":"def count_distinct_chars(s, queries): Returns the count of distinct characters in the substrings specified by the queries. :param s: A string consisting of lowercase English letters. :param queries: A list of queries where each query is a list of two integers [start, end]. :return: A list of integers, where each integer is the count of distinct characters in the substring specified by the corresponding query. results = [] for start, end in queries: substring = s[start:end + 1] distinct_characters = set(substring) results.append(len(distinct_characters)) return results"},{"question":"Given a string `s` consisting of lowercase letters and an integer array `cost` of the same length, you can perform the following operation any number of times: Choose two adjacent characters in the string and delete one, incurring the cost associated with the deleted character (the cost for each character is provided in the `cost` array). The goal is to remove characters to create a string with no consecutive equal letters and minimize the total cost incurred by these deletions. Return the minimum cost required to achieve this.","solution":"def minCost(s, cost): Given a string `s` and an array of costs `cost`, this function calculates the minimum cost required to remove adjacent, identical characters from the string to ensure no two adjacent characters are the same. Args: s (str): input string consisting of lowercase letters cost (List[int]): list of integer costs associated with each character in `s` Returns: int: minimum cost to remove characters so that there are no adjacent identical characters total_cost = 0 n = len(s) if n == 0: return 0 for i in range(1, n): if s[i] == s[i - 1]: if cost[i] < cost[i - 1]: total_cost += cost[i] cost[i] = cost[i - 1] else: total_cost += cost[i - 1] return total_cost"},{"question":"You are given an integer array `arr` representing heights of buildings. A building with height `arr[i]` can trap water to its left and right, depending on the heights of the buildings around it. Specifically, you need to compute the maximum amount of water that can be trapped in between buildings after it rains. Return the total water trapped.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining. :param height: List[int] - a list of integers representing the height of buildings. :return: int - the total amount of trapped water. if not height: return 0 n = len(height) left = [0] * n right = [0] * n water = 0 # Compute max height to the left of each building left[0] = height[0] for i in range(1, n): left[i] = max(left[i - 1], height[i]) # Compute max height to the right of each building right[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], height[i]) # Calculate the trapped water for i in range(n): water += min(left[i], right[i]) - height[i] return water"},{"question":"Given a sorted array of unique integers `nums` and a target integer `target`, write a function to find the insertion position of `target` in `nums` such that the array would still be sorted after the insertion. The function should return the index where the target can be inserted to maintain the array\'s sorted order. If the target is already present in the array, return the index where it is located.","solution":"def search_insert(nums, target): Given a sorted array of unique integers `nums` and a target integer `target`, returns the index where the target should be inserted to maintain sorted order. If the target is already present, returns the index where it is located. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"You are given a 2D integer array `intervals` where `intervals[i] = [starti, endi]` represents an interval. The intervals can overlap, and they might not be sorted in any order. Your task is to merge all overlapping intervals and return an array of the merged intervals in **any order**. For example, given the input `intervals = [[1,3],[2,6],[8,10],[15,18]]`, the result should be `[[1,6],[8,10],[15,18]]` because intervals `[1,3]` and `[2,6]` overlap and are merged into `[1,6]`.","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the merged intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is represented as a list [start, end]. Returns: List[List[int]]: A list of merged intervals. if not intervals: return [] # Sort intervals by their start values intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged"},{"question":"You are given a string `s` consisting only of lowercase English letters. A **palindromic substring** is a substring which reads the same backward as forward. Return the start and end indices of the longest palindromic substring in `s`. If there are multiple solutions, return any of them. If the string is empty, return `[-1, -1]`.","solution":"def longest_palindromic_substring(s): Returns the start and end indices of the longest palindromic substring in s. If there are multiple solutions, return any of them. If the string is empty, return [-1, -1]. if not s: return [-1, -1] n = len(s) start, end = 0, 0 def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Odd length palindromes l1, r1 = expand_around_center(i, i) # Even length palindromes l2, r2 = expand_around_center(i, i + 1) if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return [start, end]"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to choose any two characters in the string and replace all occurrences of the first character with the second character and vice versa (i.e., you can swap any two distinct characters). Your goal is to perform at most one such operation to maximize the lexicographical order of the resulting string. Return the lexicographically largest string possible after performing the swap operation. If no such swap can improve the string, return the original string.","solution":"def swap_lexicographically_largest(s): Perform at most one swap operation to maximize the lexicographical order of the string s. Swap any two distinct characters in the string. if not s: return \\"\\" n = len(s) last_pos = {char: i for i, char in enumerate(s)} for i in range(n): for c in sorted(last_pos.keys(), reverse=True): if c > s[i] and last_pos[c] > i: lst = list(s) lst[i], lst[last_pos[c]] = lst[last_pos[c]], lst[i] return \\"\\".join(lst) return s"},{"question":"Given a list of `n` words, where each word is a string consisting of lowercase English letters, determine the **minimum number** of characters required to type all the words using an on-screen keyboard with only the first `m` characters of the alphabet available. Each word in the list appears at least once. Assume the on-screen keyboard only displays characters in alphabetical order starting from \'a\' and ending at the m-th character (e.g., \'a\', \'b\', ..., to the m-th character). If it is impossible to type all the words with available characters, return -1.","solution":"def min_characters_to_type_words(words, m): Determine the minimum number of characters to type all words using an on-screen keyboard with only the first m characters of the alphabet available. :param words: List of words (each word is a string with lowercase English letters). :param m: Number of characters available on the on-screen keyboard. :return: The minimum number of characters required to type all the words or -1 if impossible. # Set of allowed characters allowed_characters = set(chr(97 + i) for i in range(m)) # Check each word to see if it can be typed with allowed characters for word in words: for char in word: if char not in allowed_characters: return -1 # If we can type all words, return the number of characters available return m"},{"question":"Given a list of `intervals` where each interval is a tuple of two integers representing the start and end times `[start, end]`, merge all overlapping intervals and return the list of merged intervals such that no intervals overlap and they cover all the intervals in the input.","solution":"def merge_intervals(intervals): Merges a list of overlapping intervals. Args: intervals (list of tuple): A list where each element is a tuple of two integers representing the start and end times. Returns: list of tuple: A list of merged intervals. if not intervals: return [] # Sort intervals by start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # Overlapping intervals, merge them merged[-1] = (previous[0], max(previous[1], current[1])) else: # No overlap, add to result merged.append(current) return merged"},{"question":"You are given a positive integer `n`. Your task is to return the number of unique BSTs (Binary Search Trees) that can be constructed with `n` distinct nodes, where the values of the nodes are `1` to `n`. Since the answer can be large, return it modulo `109 + 7`.","solution":"def num_trees(n): Returns the number of unique BSTs that can be constructed with n distinct nodes, where the values of the nodes are 1 to n. The result is given modulo 10^9 + 7. MOD = 10**9 + 7 if n == 0 or n == 1: return 1 # Initialize the dp array where dp[i] will be storing the number of unique BST with i nodes. dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array using the formula: dp[i] = sum(dp[j-1] * dp[i-j]) for every i and j for i in range(2, n + 1): for j in range(1, i + 1): dp[i] = (dp[i] + dp[j-1] * dp[i-j]) % MOD return dp[n]"},{"question":"Given an array of integers `arr`, return all possible unique permutations of this array in lexicographical order. You must implement a solution that can handle arrays with duplicate elements. For example, given the array `[1, 1, 2]`, the unique permutations are `[[1, 1, 2], [1, 2, 1], [2, 1, 1]]`. Make sure to return the results in sorted order where `1, 1, 2` comes before `1, 2, 1`, and so on.","solution":"from itertools import permutations def unique_permutations(arr): Returns all unique permutations of the list `arr` in lexicographical order. # Generate all permutations all_permutations = permutations(arr) # Use a set to avoid duplicate permutations unique_permutations_set = set(all_permutations) # Convert set to list and sort lexicographically unique_permutations_list = sorted(list(unique_permutations_set)) # Convert each tuple to a list return [list(p) for p in unique_permutations_list]"},{"question":"Given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane, a **rectangle** is defined as a set of four points that form the vertices of the rectangle with sides parallel to the X and Y axes. Return the area of the **smallest** axis-aligned rectangle that can be formed by any four points from the given array, or return `0` if no such rectangle exists. The area of a rectangle is given by the product of the differences in X coordinates and Y coordinates of the opposite corners.","solution":"def minRectangleArea(points): point_set = set(map(tuple, points)) min_area = float(\'inf\') found = False for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: area = abs(x2 - x1) * abs(y2 - y1) min_area = min(min_area, area) found = True return min_area if found else 0"},{"question":"A company has `n` employees and each employee has a unique id in the range from `0` to `n - 1`. The company\'s communication network is represented as a 2D list `adjList` where `adjList[i]` contains all the ids of employees whom employee `i` can directly communicate with. Define an employee as a \\"team leader\\" if every other employee can eventually communicate with them either directly or through intermediate employees. Given the adjacency list `adjList`, return _the id of the team leader if one exists, or_ `-1` _if no such team leader is present_.","solution":"def find_team_leader(n, adjList): Finds the team leader in the network or returns -1 if none exists. A team leader is an employee who can be communicated with by every other employee directly or indirectly. def dfs(node, visited): visited.add(node) for neighbor in adjList[node]: if neighbor not in visited: dfs(neighbor, visited) for i in range(n): visited = set() dfs(i, visited) if len(visited) == n: return i return -1"},{"question":"You are given a list of integers `nums` and an integer `target`. Find two distinct integers in the list such that their sum is equal to `target` and return their indices in a tuple `(i, j)` where `i < j`. If no such pair exists, return `(-1, -1)`. The indices must be in the order they appear in `nums`.","solution":"def two_sum(nums, target): Returns the indices of the two distinct integers in the list `nums` that sum to `target`. The returned tuple is of the form (i, j) where i < j. If no such pair exists, returns (-1, -1). num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1)"},{"question":"You are given a string `s` and an integer `n`. You need to perform `n` shifting operations on this string. In each shift operation, you can select any character from the string and move it to any position in the string. After performing all `n` shifts, return the lexicographically smallest string that you can obtain.","solution":"def shift_lexicographically(s, n): Perform n shifting operations on a string s and return the lexicographically smallest string. if n > 1: # Any sequence can be sorted lexicographically in n > 1 moves return \'\'.join(sorted(s)) else: # For n == 1, we need to consider all rotations and find the smallest one smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest"},{"question":"You are given an array of integers `arr` and an integer `d`. In one move, you can jump from index `i` to `i + j` or `i - j` (with `0 < j <= d`), provided `arr[i] > arr[i + j]` or `arr[i] > arr[i - j]`. You can visit the same index multiple times. The jumps affect the value of `i` within the bounds (from `0` to `n-1`, where `n` is the length of `arr`). Return _the maximum number of indices you can visit in the array_.","solution":"def max_jumps(arr, d): n = len(arr) dp = [1] * n # Pair each index with its value, then sort by value sorted_indices = sorted(range(n), key=lambda x: arr[x]) for i in sorted_indices: for direction in [-1, 1]: for j in range(1, d + 1): ni = i + direction * j if 0 <= ni < n and arr[i] > arr[ni]: dp[i] = max(dp[i], dp[ni] + 1) else: break return max(dp)"},{"question":"Given an array of integers `arr` and an integer `k`, return _the minimum number of moves required to make all array elements equal, where in each move you can increment or decrement any array element by `k`._","solution":"def min_moves_to_make_elements_equal(arr, k): Returns the minimum number of moves required to make all array elements equal. Each move allows incrementing or decrementing any array element by k. n = len(arr) # Sort the array arr.sort() # The target median element to minimize total distance median = arr[n // 2] # Calculate total moves total_moves = 0 for num in arr: total_moves += abs(num - median) // k return total_moves"},{"question":"You are given two strings, `s1` and `s2`, both consisting of lowercase English letters. Your task is to determine if `s1` can be transformed into `s2` by moving at most one character from `s1` to any position within `s1`. The order of characters in `s1` can be changed, but you are only allowed to perform at most one move operation. Return **true** if `s1` can be transformed into `s2` under these conditions, and **false** otherwise.","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by moving at most one character. if s1 == s2: return True if len(s1) != len(s2): return False # Scan through characters and collect different positions differences = [] for i in range(len(s1)): if s1[i] != s2[i]: differences.append((s1[i], s2[i])) # If exactly two characters are different, check if a single swap suffices if len(differences) == 2: if differences[0] == differences[1][::-1]: return True # If more or less than two characters are different, it\'s impossible with one move return False"},{"question":"You are given an integer array `heights` representing the height of trees in a forest. A tree can only grow in height if the height of at least one of its immediate neighbors (left or right) is taller than it. You can iterate through the array multiple times. On each iteration, if a tree can grow, it gains a height of `1`. Return _the final height of the trees in the array after they can no longer grow_.","solution":"def final_tree_heights(heights): Returns the final height of the trees in the array after they can no longer grow. Parameters: heights (list of int): the heights of the trees in the forest. Returns: list of int: the final heights of the trees. if not heights: return [] n = len(heights) growing = True while growing: growing = False new_heights = heights[:] for i in range(n): if i > 0 and heights[i] < heights[i - 1]: new_heights[i] += 1 growing = True if i < n - 1 and heights[i] < heights[i + 1]: new_heights[i] += 1 growing = True heights = new_heights return heights"},{"question":"Given an array of integers `arr`, find a subsequence of array `arr` such that the difference between adjacent elements of the subsequence is exactly `k`. The subsequence should be as long as possible and among all possible such subsequences, return the one that appears first in the original array. Return the starting index and the elements of this subsequence. If there are multiple solutions, return any one of them.","solution":"def longest_subsequence_with_diff(arr, k): Finds the longest subsequence where the difference between adjacent elements is exactly k. Args: arr : list of int The input array of integers. k : int The difference between adjacent elements of the subsequence. Returns: tuple A tuple containing the starting index of the subsequence and the subsequence itself. n = len(arr) max_len = 0 start_idx = -1 best_subsequence = [] for i in range(n): current_subsequence = [arr[i]] for j in range(i + 1, n): if arr[j] - current_subsequence[-1] == k: current_subsequence.append(arr[j]) if len(current_subsequence) > max_len: max_len = len(current_subsequence) start_idx = i best_subsequence = current_subsequence return start_idx, best_subsequence"},{"question":"You are given an array of integers `arr` and an integer `k`. Return an array of all the unique pairs `(x, y)` from the array such that `x + y = k`. Each pair should be in the form `[x, y]` where `x <= y`, and the array of pairs should be sorted in ascending order first by `x` and then by `y`. If there are no such pairs, return an empty array.","solution":"def find_pairs_with_sum(arr, k): Returns an array of all the unique pairs (x, y) from the array such that x + y = k. Each pair is formatted as [x, y] where x <= y, and the array of pairs is sorted in ascending order first by x and then by y. seen = set() pairs = set() for num in arr: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) # Convert set of pairs to sorted list of lists sorted_pairs = sorted([list(pair) for pair in pairs]) return sorted_pairs"},{"question":"You are given a list of `n` pairs of integers `intervals` where `intervals[i] = [start_i, end_i]` represents the start and end times of the `ith` meeting. Implement a method to determine the minimum number of meeting rooms required to accommodate all the meetings. Meetings overlap if `start_i < end_j` and `end_i > start_j`. For example, given the input `intervals = [[0, 30], [5, 10], [15, 20]]`, the output should be `2`, since at least two meeting rooms are needed to hold the meetings at times [0, 30] and [5, 10] simultaneously. If the input was `intervals = [[7, 10], [2, 4]]`, the output should be `1`, as none of the meetings overlap.","solution":"def minMeetingRooms(intervals): Determine the minimum number of meeting rooms required to accommodate all meetings. :param intervals: List of pairs [start, end] representing meeting times. :return: Minimum number of meeting rooms required. if not intervals: return 0 # Separate the start and end times start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_pointer = end_pointer = 0 rooms_needed = 0 max_rooms = 0 while start_pointer < len(intervals): # If there\'s a meeting that starts before the earliest ending one ends, we need a new room if start_times[start_pointer] < end_times[end_pointer]: rooms_needed += 1 start_pointer += 1 else: # Otherwise, we can free up a room and move the end pointer rooms_needed -= 1 end_pointer += 1 # Track the maximum number of rooms needed max_rooms = max(max_rooms, rooms_needed) return max_rooms"},{"question":"You are given a string `s` consisting of only letters (both uppercase and lowercase) and digits. You need to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, return an empty string `\\"\\"`. Otherwise, return any possible rearrangement of the string that meets the given condition.","solution":"from collections import Counter import heapq def reorganize_string(s): Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, returns an empty string \\"\\". count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) previous_char = None previous_count = 0 result = [] while max_heap or previous_count: if previous_count: if not max_heap: return \\"\\" count, char = heapq.heappop(max_heap) else: count, char = heapq.heappop(max_heap) result.append(char) count += 1 if previous_count: heapq.heappush(max_heap, (previous_count, previous_char)) previous_char = char previous_count = count return \\"\\".join(result)"},{"question":"You are given a list of `n` strings, where each string is a word. You need to find and return a list of lists with all anagram groups from the given words. An anagram group is a group of words that, when sorted alphabetically character by character, result in the same string. Each group should contain all of its anagrams (including duplicates), and the groups should be ordered by the first appearance of any member of the group in the original list. Words within the groups should also be sorted by their original order in the input list. For example, given the input list `[\\"tea\\", \\"ate\\", \\"eat\\", \\"bat\\", \\"tab\\"]`, the output should be `[[\'tea\', \'ate\', \'eat\'], [\'bat\', \'tab\']]`.","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams from a list of words. Args: words: list of str Returns: list of lists of str: Anagrams grouped together. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"Given an array of strings `transactions` where each transaction is represented as a string in the format `\\"SenderName ReceiverName Amount Timestamp\\"`, return the list of all users who are involved in at least two fraudulent transactions. A transaction is considered fraudulent if it occurs within 10 minutes of a previous transaction involving the same sender or receiver, regardless of the order of sender and receiver. The output should be a list of user names sorted lexicographically.","solution":"from collections import defaultdict from datetime import datetime, timedelta def find_fraudulent_users(transactions): user_transactions = defaultdict(list) fraudulent_users = set() # Parse transactions and convert to more manageable format parsed_transactions = [] for trans in transactions: sender, receiver, amount, timestamp = trans.split() timestamp = datetime.strptime(timestamp, \'%Y-%m-%dT%H:%M:%S\') parsed_transactions.append((sender, receiver, int(amount), timestamp)) # Sort transactions by timestamp parsed_transactions.sort(key=lambda x: x[3]) def record_transaction(user, timestamp): for old_timestamp in user_transactions[user]: if timestamp - old_timestamp <= timedelta(minutes=10): fraudulent_users.add(user) return user_transactions[user].append(timestamp) # Check for fraudulent transactions for sender, receiver, amount, timestamp in parsed_transactions: record_transaction(sender, timestamp) record_transaction(receiver, timestamp) return sorted(fraudulent_users)"},{"question":"Given a binary tree, implement the method `lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)` that finds the lowest common ancestor (LCA) of two given nodes `p` and `q` in the tree. The LCA is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). Each node will have a unique value, and you can assume that both `p` and `q` are present in the tree. The method should optimize for the overall runtime.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def lowestCommonAncestor(root, p, q): Returns the lowest common ancestor of nodes p and q in the binary tree rooted at root. if not root or root == p or root == q: return root left_lca = lowestCommonAncestor(root.left, p, q) right_lca = lowestCommonAncestor(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"You are given an `m x n` matrix `grid` consisting of non-negative integers. Your task is to find the largest rectangular sub-matrix whose sum is less than or equal to a given target value `k`. If there is no such sub-matrix, return 0. Return the sum of the largest sub-matrix if one exists. The sub-matrix can be as small as a single element or as large as the entire matrix.","solution":"def maxSumSubmatrix(grid, k): Find the largest rectangular sub-matrix sum which is no more than k :param grid: List[List[int]], the input matrix :param k: int, the target value for sub-matrix sum :return: int, the sum of the largest sub-matrix no more than k from itertools import accumulate import bisect def max_sum_subarray_less_than_k(arr): max_sum = float(\'-inf\') current_sum = 0 prefix_sums = [0] for num in arr: current_sum += num # Find the smallest prefix sum larger than (current_sum - k) idx = bisect.bisect_left(prefix_sums, current_sum - k) if idx < len(prefix_sums): max_sum = max(max_sum, current_sum - prefix_sums[idx]) # Insert the current sum in the sorted prefix sum list bisect.insort(prefix_sums, current_sum) return max_sum if not grid or not grid[0]: return 0 row, col = len(grid), len(grid[0]) max_sum = float(\'-inf\') for left in range(col): row_sum = [0] * row for right in range(left, col): for r in range(row): row_sum[r] += grid[r][right] max_sum = max(max_sum, max_sum_subarray_less_than_k(row_sum)) if max_sum == k: return max_sum return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"You are given a **non-negative** integer array `arr` of length `n`. You are also given an integer `k` such that `1 <= k < n`. * For example, if `arr = [4, 1, 7, 3, 2]`, and `k = 2`. You can slide a window of size `k` over the array `arr` from the left to the right. * The window can be moved by one element at a time (from `left` to `right`). For each movement of the window, find the **maximum** element within the window. * For example, for the given array and `k = 2`: * The window starts at the first position and captures `[4, 1]`, the maximum value is `4`. * Move the window to the right by 1 position and captures `[1, 7]`, the maximum value is `7`. * Continue in this fashion until the end of the array. Return _an array of **all** maximum values obtained from each window movement from the left to the right_.","solution":"def sliding_window_maximum(arr, k): Returns an array of the maximum elements within each sliding window of size k. Parameters: arr (list of int): The input array. k (int): The window size. Returns: list of int: The maximum elements in each window. from collections import deque if not arr or k <= 0: return [] deq = deque() result = [] for i, num in enumerate(arr): # Remove elements not within the window if deq and deq[0] < i - k + 1: deq.popleft() # Maintain decreasing order in the deque while deq and arr[deq[-1]] < num: deq.pop() deq.append(i) # Append the maximum element of the current window to the result if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"You are given a `rows x cols` binary matrix `grid` representing a maze where `1` represents a wall and `0` represents an open path. You are also given the starting position `start` and the destination position `end`, both of which are positions in the maze. Your task is to determine whether there is a path from `start` to `end` in the maze. You can only move in four possible directions: up, down, left, and right. You cannot move through walls, as you can only travel through open paths. Return `true` if there is a path from `start` to `end`, otherwise return `false`.","solution":"def has_path(grid, start, end): Determines if there is a path from start to end in the given maze. :param grid: List[List[int]] - The binary matrix representing the maze :param start: Tuple[int, int] - The starting position in (row, col) format :param end: Tuple[int, int] - The destination position in (row, col) format :return: bool - True if there is a path from start to end, else False rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 def dfs(x, y): if (x, y) == end: return True grid[x][y] = 1 # Mark the cell as visited for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(start[0], start[1])"},{"question":"Given a string `s`, return the longest palindromic substring in `s`. A palindromic string is a string that reads the same forward and backward. You need to implement the function: - `public String longestPalindrome(String s)` This function should take a single argument `s`, which is a string consisting of lowercase and/or uppercase alphanumeric characters, and return a single string representing the longest palindromic substring of `s`. If there are multiple palindromic substrings with the same maximum length, return the first one you encounter.","solution":"def longest_palindrome(s): Finds the longest palindromic substring in the input string. :param s: A string consisting of lowercase and/or uppercase alphanumeric characters :return: The longest palindromic substring in the input string if not s: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"Given a string `s`, you want to revise it such that any character can be replaced with any other character in the alphabet. Perform a revision that minimizes the number of distinct characters in the string while ensuring the resulting string still forms a palindrome. Return the minimum number of distinct characters required to form such a palindrome. A palindrome is a string that reads the same backward as forward. For example, `\\"abba\\"` and `\\"racecar\\"` are palindromes, but `\\"abcdef\\"` is not. Example: ``` Input: s = \\"babad\\" Output: 1 Explanation: Replace all characters with \'a\' to get the palindrome \\"aaaaa\\". Only one distinct character is required. ``` Note: The input \\"s\\" will only contain lowercase English letters and will have a length between 1 and 1000, inclusive.","solution":"def min_distinct_chars_to_palindrome(s): Given a string s, perform a revision that minimizes the number of distinct characters in the string while ensuring the resulting string still forms a palindrome. Return the minimum number of distinct characters required to form such a palindrome. from collections import Counter counter = Counter(s) # Even length or odd length palindrome rules odd_count = sum(1 for count in counter.values() if count % 2 != 0) # For a palindrome, we can only have at most one character with an odd count # so the minimum number of distinct characters would be 1 (change all characters to 1 distinct char) # or as many even-count characters and one odd (if more than one odd exists, those can be converted) # Hence, the minimal distinct characters in a palindromic structure would be 1. return 1"},{"question":"You are given an integer array `arr` and two integers `m` and `k`. Write a function to find the number of subarrays of size `m` that contain the integer `k` exactly once. A subarray is a contiguous part of an array. Your function should return the number of such subarrays. __Example:__ Given `arr = [1, 2, 3, 2, 1]`, `m = 3`, and `k = 2`, the function should return `2` because there are two subarrays of size `m` that contain the integer `k` exactly once: `[1, 2, 3]` and `[3, 2, 1]`.","solution":"def count_subarrays_with_k(arr, m, k): Returns the number of subarrays of size m that contain the integer k exactly once. count = 0 for i in range(len(arr) - m + 1): subarray = arr[i:i + m] if subarray.count(k) == 1: count += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `k`. Divide the array into `k` non-empty subsets such that the sum of each subset is equal. Return `true` if you can achieve this partition, and `false` otherwise.","solution":"def can_partition_k_subsets(arr, k): Function to determine if an array can be partitioned into k subsets with equal sum. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) if arr[0] > target_sum: return False subsets = [0] * k def can_partition(index): if index == len(arr): return all(subset == target_sum for subset in subsets) for i in range(k): if subsets[i] + arr[index] <= target_sum: subsets[i] += arr[index] if can_partition(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return can_partition(0)"},{"question":"You are given an integer array `nums` which contains `n` unique elements, and an integer `k` such that `1 <= k <= n`. You need to find the length of the shortest subarray of `nums` that contains all the numbers from `1` to `k`. If no such subarray exists, return `-1`. The array `nums` is not necessarily sorted. Return the length of the shortest subarray that contains all elements from `1` to `k`.","solution":"def shortest_subarray_with_all_elements(nums, k): Returns the length of the shortest subarray in `nums` that contains all elements from 1 to `k`. If no such subarray exists, returns -1. from collections import defaultdict required_elements = set(range(1, k+1)) n = len(nums) if not required_elements.issubset(set(nums)): return -1 left = 0 min_length = float(\'inf\') element_count = defaultdict(int) unique_count = 0 for right in range(n): if nums[right] in required_elements: if element_count[nums[right]] == 0: unique_count += 1 element_count[nums[right]] += 1 while unique_count == k: min_length = min(min_length, right - left + 1) if nums[left] in required_elements: element_count[nums[left]] -= 1 if element_count[nums[left]] == 0: unique_count -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an array of `intervals` where `intervals[i] = [start_i, end_i]` represent the start and end times of the `i`-th meeting. Return the minimum number of meeting rooms required to accommodate all the meetings. Implement this in the function `minMeetingRooms`. **Example format (Python function signature):** ```python def minMeetingRooms(intervals: List[Tuple[int, int]]) -> int: # implementation here ``` **Example:** ```python intervals = [(0, 30), (5, 10), (15, 20)] print(minMeetingRooms(intervals)) # Output should be 2 ``` In the given example, we need at least two meeting rooms to accommodate all the meetings.","solution":"from typing import List, Tuple import heapq def minMeetingRooms(intervals: List[Tuple[int, int]]) -> int: if not intervals: return 0 # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Initialize a heap to keep track of the end times of meetings heap = [] # Add the first meeting\'s end time to the heap heapq.heappush(heap, intervals[0][1]) # Iterate over the remaining intervals for i in range(1, len(intervals)): # If the meeting can start after the earliest ended meeting if intervals[i][0] >= heap[0]: heapq.heappop(heap) # Add the current meeting\'s end time to the heap heapq.heappush(heap, intervals[i][1]) # The size of the heap is the number of meeting rooms required return len(heap)"},{"question":"Given a list of integers `heights` representing the heights of buildings, find the two buildings that together can contain the most amount of water. The amount of water contained between any two buildings is the width of the gap between the two buildings times the height of the shorter building of the two. You need to return the maximum amount of water that can be contained. Ensure that your solution is efficient with a time complexity better than O(n^2).","solution":"def max_area(heights): Returns the maximum amount of water that can be contained between two buildings. if not heights or len(heights) < 2: return 0 max_water = 0 left = 0 right = len(heights) - 1 while left < right: # Calculate the area height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update the maximum water max_water = max(max_water, current_water) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given a matrix `mat` of size `n x m` consisting of non-negative integers, you are tasked with finding the row which has the maximum sum of its elements and returning the index of that row. If there are multiple rows with the same maximum sum, return the index of the first such row. The matrix `mat` is guaranteed to have at least one row and one column. Return _the index of the row with the maximum sum of elements_.","solution":"def row_with_max_sum(mat): Returns the index of the row with the maximum sum of elements in the given matrix mat. If there are multiple rows with the same maximum sum, returns the index of the first such row. Parameters: mat (List[List[int]]): A list of lists where each sublist represents a row in the matrix. Returns: int: The index of the row with the maximum sum of elements. max_sum = float(\'-inf\') max_index = -1 for i, row in enumerate(mat): current_sum = sum(row) if current_sum > max_sum: max_sum = current_sum max_index = i return max_index"},{"question":"Write a function that takes a list of integers `nums` and returns the length of the longest increasing subsequence in the array. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The test cases are generated so that the answer fits on a 32-bit signed integer.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"There is a city with `n` buildings aligned in a row and each building has a certain height. You are given a **0-indexed** integer array `heights` containing `n` positive integers where `heights[i]` represents the height of the `i`-th building. A building is considered to have a \\"view\\" if there are no taller buildings to its right. Return a list containing the indices of all the buildings that have a \\"view\\". The buildings in the resulting list should be sorted in ascending order of their indices.","solution":"def find_buildings_with_view(heights): Returns the indices of buildings that have a view. A building has a view if there are no taller buildings to its right. Parameters: heights (List[int]): A list of integers representing the heights of the buildings. Returns: List[int]: A list of indices of buildings with a view. n = len(heights) result = [] max_height_so_far = 0 for i in range(n - 1, -1, -1): if heights[i] > max_height_so_far: result.append(i) max_height_so_far = heights[i] return sorted(result)"},{"question":"You are given a list of integers `arr` where each integer represents an event with a start time and a duration. Each integer in `arr` has the following format: `HHMM` where `HH` represents the hour in 24-hour format and `MM` represents the minutes. You also have an integer `duration` which represents a fixed duration in minutes required to complete a task. You need to determine the number of non-overlapping intervals in `arr` that can accommodate the given task duration. An interval can be considered valid if there is enough room for the entire task without overlapping with other intervals. Implement the `Schedule` class: * `Schedule(int[] arr, int duration)` Initializes the schedule with the given list of events and the task duration. * `int maxNonOverlappingIntervals()` Returns the maximum number of non-overlapping intervals that can fit the task duration.","solution":"import datetime class Schedule: def __init__(self, arr, duration): self.arr = arr self.duration = duration def maxNonOverlappingIntervals(self): intervals = [] for time in self.arr: hour = time // 100 minute = time % 100 start_time = datetime.datetime(year=1970, month=1, day=1, hour=hour, minute=minute) end_time = start_time + datetime.timedelta(minutes=self.duration) intervals.append((start_time, end_time)) # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) max_intervals = 0 last_end_time = datetime.datetime(year=1970, month=1, day=1, hour=0, minute=0) for interval in intervals: if interval[0] >= last_end_time: max_intervals += 1 last_end_time = interval[1] return max_intervals"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city landscape, where the width of each building is 1 unit. The skyline is represented by the outline formed when looking at the buildings from a distance. Compute the area of the largest rectangle that can be formed within the boundaries of the outline. Return _the area of this largest rectangle_.","solution":"def largestRectangleArea(heights): Given a list of building heights, computes the area of the largest rectangle. stack = [] max_area = 0 heights.append(0) # Append a zero to handle end cases for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"Given an array of integers `arr`, your task is to find a **contiguous subarray** with the **maximum sum** and return that sum. A subarray is a slice of the array that maintains the order of the elements. If all numbers are negative, the maximum sum is the smallest negative number. The solution should have a time complexity of O(n), where `n` is the length of the array.","solution":"def max_subarray_sum(arr): Returns the sum of the contiguous subarray with the maximum sum in the given array. Uses Kadane\'s Algorithm to achieve O(n) time complexity. if not arr: return 0 max_sum = cur_sum = arr[0] for num in arr[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum"},{"question":"You are given an integer array `arr` of distinct integers sorted in ascending order, and an array of integers `queries` representing different target values. Implement a function that returns an array of integers where each element corresponds to the number of elements in `arr` that are less than or equal to the target value from `queries`. For instance, if `arr = [1, 2, 5, 6, 8]` and `queries = [0, 3, 6]`, the function should return `[0, 2, 4]`.","solution":"def count_less_equal(arr, queries): Returns an array of integers where each element corresponds to the number of elements in `arr` that are less than or equal to the value from `queries`. Assumes `arr` is sorted in ascending order. def count_le(arr, target): Helper function that returns count of elements less than or equal to target in sorted array arr left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid return left return [count_le(arr, query) for query in queries]"},{"question":"An image is represented by an `m x n` binary matrix `image` where `0` represents a pixel of value `0` and `1` represents a pixel of value `1`. You need to find the **smallest rectangle** that encloses all the pixels that have a value of `1` in the image. The edges of the rectangle should be aligned along the row and column axes of the matrix. Given the binary matrix `image`, return _the area of the smallest rectangle that encloses all the `1` pixels_.","solution":"def min_area(image): Finds the area of the smallest rectangle enclosing all 1 pixels in a binary image. :param image: List of Lists containing binary values (0 or 1) :return: The area of the smallest rectangle enclosing all 1 pixels. if not image or not image[0]: return 0 rows = len(image) cols = len(image[0]) top, bottom, left, right = rows, 0, cols, 0 for i in range(rows): for j in range(cols): if image[i][j] == 1: if i < top: top = i if i > bottom: bottom = i if j < left: left = j if j > right: right = j if top == rows and bottom == 0 and left == cols and right == 0: return 0 return (bottom - top + 1) * (right - left + 1)"},{"question":"You are given two strings `s1` and `s2`, both of the same length and containing only lowercase letters. Write a function that returns _the longest substring_ that appears in both `s1` and `s2`. If there are multiple longest common substrings with the same length, return any of them. If no common substring exists, return an empty string.","solution":"def longest_common_substring(s1, s2): Returns the longest substring that appears in both s1 and s2. If there are multiple longest common substrings with the same length, return any of them. If no common substring exists, return an empty string. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common suffixes of substrings. # dp[i][j] will hold the length of the longest common substring ending in s1[i-1] and s2[j-1]. dp = [[0] * (n + 1) for _ in range(m + 1)] # Length of the longest common substring longest = 0 # Ending index of longest common substring in s1 ending_index = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest: longest = dp[i][j] ending_index = i else: dp[i][j] = 0 if longest == 0: return \\"\\" return s1[ending_index - longest: ending_index]"},{"question":"You are given an `m x n` binary matrix `grid` where 0 represents water and 1 represents land. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s. An island is considered to be surrounded by water if all the 1s that make up the island are connected by 0s (including any 1s that are connected diagonally to the island). Write a function to return the number of islands that are fully surrounded by water. Note that the edges of the grid are also considered to be surrounded by water.","solution":"def num_islands_surrounded(grid): Returns the number of islands that are fully surrounded by water. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return True if grid[x][y] == -1: return True grid[x][y] = -1 # Mark as visited if (x == 0 or x == m-1 or y == 0 or y == n-1): return False top = dfs(x-1, y) bottom = dfs(x+1, y) left = dfs(x, y-1) right = dfs(x, y+1) return top and bottom and left and right count = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 1: if dfs(i, j): count += 1 return count"},{"question":"You are given a `2D` integer array `intervals` where each `intervals[i]` is a `pair` of integers `[start_i, end_i]` representing an interval. Return the length of the union of all the intervals. The union of the intervals is the total length covered by all the intervals, considering overlapping intervals only once.","solution":"def union_of_intervals(intervals): Returns the total length covered by the union of the intervals. if not intervals: return 0 # Sort intervals based on the starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [] for interval in intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1]) total_length = sum(end - start for start, end in merged_intervals) return total_length"},{"question":"You are given an integer array `nums` and an integer `k`. A **continuous subarray** is a subarray that appears in the same sequential order as the original array without skipping any elements. Your task is to find out whether there is a continuous subarray of length at least 2 that sums up to a multiple of `k` (i.e., the sum is equal to `k`, `2k`, `3k`, and so on). If such subarray exists, return `true`; otherwise, return `false`. **Note**: The length of the input array `nums` will not exceed `10^5`, and (10^{-5} leq k leq 10^5).","solution":"def check_subarray_sum(nums, k): Check if there exists a continuous subarray of length at least 2 that sums to a multiple of k. if not nums or len(nums) < 2: return False cum_sum = 0 mod_dict = {0: -1} # To handle edge case where the sum is exactly a multiple of k at index > 0 for index, num in enumerate(nums): cum_sum += num if k != 0: cum_sum %= k if cum_sum in mod_dict: if index - mod_dict[cum_sum] > 1: # Ensure subarray length is at least 2 return True else: mod_dict[cum_sum] = index return False"},{"question":"Given a **0-indexed** string `text` and an array of words `words` where each word is a non-empty string, return _the total count of subsequences of `text` that are equal to any word in `words`_. A subsequence means deleting some or no characters from `text` without changing the order of the remaining characters.","solution":"from collections import defaultdict def num_matching_subseq(text, words): Return the total count of subsequences of `text` that are equal to any word in `words`. def is_subsequence(s, t): it = iter(t) return all(c in it for c in s) word_count = defaultdict(int) for word in words: word_count[word] += 1 total_count = 0 for word, count in word_count.items(): if is_subsequence(word, text): total_count += count return total_count"},{"question":"Given a binary tree, imagine each node has an additional pointer called `next` that connects it to the next node in the same level. Initially, all the `next` pointers are set to `null`. Write a function to connect each node to its next node in the same level. The tree is represented by the root node of the binary tree and could be either a perfect binary tree or a complete binary tree. Your function should modify the tree in-place.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None, next: \'TreeNode\' = None): self.val = val self.left = left self.right = right self.next = next def connect(root: \'TreeNode\') -> \'TreeNode\': if not root: return None current = root while current.left: next_level_start = current.left while current: current.left.next = current.right if current.next: current.right.next = current.next.left current = current.next current = next_level_start return root"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to find the `k`th largest element in the array. Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element. Can you implement an algorithm to solve this in `O(n log n)` time complexity using `O(1)` extra space?","solution":"def find_kth_largest(nums, k): Find the kth largest element in an array. Parameters: nums (list): List of integers. k (int): The kth position. Returns: int: The kth largest element in the array. nums.sort(reverse=True) return nums[k-1]"},{"question":"You are given two strings, `s` and `t`. You want to merge the two strings in such a way that the resulting string is lexographically smallest and contains all characters from both `s` and `t`. The merge operation should follow these rules: - Pick the smallest non-empty prefix from `s` or `t`. - Append this prefix to the result and delete it from the corresponding string. Return _the merged string_ consisting of all characters from `s` and `t`. **Note:** The lexographically smallest string is defined as the string that would appear earliest in a dictionary if `s` and `t` are compared.","solution":"def merge_strings(s, t): Merges two strings s and t to form the lexicographically smallest string. Parameters: s (str): The first input string. t (str): The second input string. Returns: str: The lexicographically smallest merged string. result = [] while s and t: if s < t: result.append(s[0]) s = s[1:] else: result.append(t[0]) t = t[1:] # One of the strings could still have remaining characters result.append(s) result.append(t) return \'\'.join(result)"},{"question":"You are given an array of integers `nums` representing the number of apples on each apple tree in a row. You can choose any two adjacent trees and pick one or all of the apples from both trees during each move. Return _the **minimum number of moves** required to pick all the apples from all the trees._","solution":"def min_moves(nums): Returns the minimum number of moves required to pick all apples from the trees. Args: nums : List[int] - A list of integers representing the number of apples on each tree. Returns: int - Minimum number of moves required to pick all apples. if not nums: return 0 if len(nums) == 1: return nums[0] total_apples = sum(nums) return (total_apples + 1) // 2"},{"question":"You are given an array of integers `arr` and a target sum `k`. Write a function that returns all unique quadruplets `[a, b, c, d]` in the array such that `a + b + c + d = k`. Each quadruplet should be returned as a list of four integers, and the resulting list of quadruplets should not contain duplicate quadruplets. The numbers in the quadruplet can be in any order. Return the list of quadruplets or an empty list if no such quadruplets exist.","solution":"def four_sum(arr, k): arr.sort() quadruplets = [] length = len(arr) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: # Skip duplicate elements continue for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: # Skip duplicate elements continue left, right = j + 1, length - 1 while left < right: quad_sum = arr[i] + arr[j] + arr[left] + arr[right] if quad_sum == k: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: # Skip duplicate elements left += 1 while left < right and arr[right] == arr[right - 1]: # Skip duplicate elements right -= 1 left += 1 right -= 1 elif quad_sum < k: left += 1 else: right -= 1 return quadruplets"},{"question":"Given a string `s` consisting of lowercase alphabets, find out how many times you have to remove characters from the string to make it a palindrome. In one operation, you can remove any character from any position in the string. Return the minimum number of operations required to convert the string into a palindrome. **Example:** - Input: `s = \\"abacaba\\"` - Output: `0` - Explanation: The string is already a palindrome. - Input: `s = \\"abc\\"` - Output: `2` - Explanation: You can remove \'b\' and \'c\' to make \\"a\\" which is a palindrome. **Note:** - A palindrome is a string that reads the same forwards and backwards. - The input string `s` will contain at most `1000` characters.","solution":"def min_removals_to_make_palindrome(s): Returns the minimum number of operations required to convert the string into a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0]*n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] lps = longest_palindromic_subsequence(s) return len(s) - lps"},{"question":"There are `n` bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it\'s off or turning off if it\'s on). For the `i-th` round, you toggle every `i-th` bulb. For the `n-th` round, you only toggle the last bulb. Find the number of bulbs that are on after `n` rounds. Return the number of bulbs that are on.","solution":"def count_bulbs_on(n): Returns the number of bulbs that are on after n rounds. Initially, all bulbs are off. The nth round represents the number of bulbs that have been toggled exactly a perfect square number of times. import math return int(math.sqrt(n))"},{"question":"You are given a `rows x columns` binary matrix `grid`. Each cell contains either a `0` or a `1`. You can perform at most one move: choose any cell and toggle its value (i.e., change a `0` to `1` or vice-versa). Return _the **maximum** number of `1`s you can obtain by performing at most one move_. If no move is needed, return the current number of `1`s in the matrix.","solution":"def max_ones_after_flip(grid): Calculate the maximum number of 1\'s obtainable by flipping at most one cell. Args: grid (List[List[int]]): A 2D list representing the grid. Returns: int: Maximum number of 1\'s after at most one flip. total_ones = sum(sum(row) for row in grid) max_ones_with_flip = total_ones for row in grid: for cell in row: if cell == 0: max_ones_with_flip = max(max_ones_with_flip, total_ones + 1) return max_ones_with_flip"},{"question":"Design a data structure that supports the following operations: `insert`, `delete`, `getRandom`, and `getUniqueRandom`. * `insert(val)`: Inserts an element `val` into the data structure. If the element already exists, return `false`. Otherwise, insert the element and return `true`. * `delete(val)`: Removes an element `val` from the data structure. If the element does not exist, return `false`. Otherwise, remove the element and return `true`. * `getRandom()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. * `getUniqueRandom()`: Returns a random element from the data structure that hasn\'t been returned by `getUniqueRandom` since the previous reset. Once all elements have been returned, reset and start over. Implement the `RandomizedDataStructure` class: ```python class RandomizedDataStructure: def __init__(self): # Initialize your data structure here. def insert(self, val: int) -> bool: # Add the element `val`. Returns `true` if the element was added. def delete(self, val: int) -> bool: # Remove the element `val`. Returns `true` if the element was deleted. def getRandom(self) -> int: # Returns a random element. def getUniqueRandom(self) -> int: # Returns a unique random element, as per the rules described. ```","solution":"import random class RandomizedDataStructure: def __init__(self): self.data = set() self.unique_random_pool = set() self.fetched_unique_randoms = set() def insert(self, val: int) -> bool: if val in self.data: return False self.data.add(val) self.unique_random_pool.add(val) return True def delete(self, val: int) -> bool: if val not in self.data: return False self.data.remove(val) if val in self.unique_random_pool: self.unique_random_pool.discard(val) return True def getRandom(self) -> int: if not self.data: raise ValueError(\\"No elements in data structure\\") return random.choice(tuple(self.data)) def getUniqueRandom(self) -> int: if not self.unique_random_pool: self.unique_random_pool = self.data.copy() self.fetched_unique_randoms.clear() if not self.unique_random_pool: raise ValueError(\\"No elements in data structure\\") unique_random = random.choice(tuple(self.unique_random_pool)) self.unique_random_pool.remove(unique_random) self.fetched_unique_randoms.add(unique_random) return unique_random"},{"question":"Given a binary tree, imagine you are standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The binary tree is represented with the `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Implement the `Solution` class with the following method:** - `List[int] rightSideView(TreeNode root)` - Returns a list of integers representing the values of the nodes visible from the right side of the binary tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right class Solution: def rightSideView(self, root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given two arrays `height` and `width` where `height[i]` and `width[i]` represent the height and width of the `i-th` rectangle, respectively. A rectangle can be placed inside another rectangle if and only if both the height and width of one rectangle are strictly greater than the height and width of the other rectangle. You need to find the maximum number of rectangles that can be nested inside each other. Return the maximum number of rectangles that can be nested.","solution":"def max_nested_rectangles(height, width): Given the heights and widths arrays of rectangles, return the maximum number of rectangles that can be nested inside each other. # Combine the heights and widths into a list of tuples and sort them based on one dimension first # and if they are equal, sort by the other dimension in descending order. rectangles = sorted(zip(height, width), key=lambda x: (x[0], -x[1])) # Initialize an array to keep track of the longest increasing subsequence based on the second dimension. dp = [] for _, w in rectangles: lo, hi = 0, len(dp) # Binary search for the correct position of the current width. while lo < hi: mid = (lo + hi) // 2 if dp[mid] < w: lo = mid + 1 else: hi = mid # Replace or add the current width to the dp array. if lo < len(dp): dp[lo] = w else: dp.append(w) return len(dp)"},{"question":"You are given a list of network connections represented as a list of tuples, where each tuple contains two integers representing two connected computers. The list may have redundant connections and may represent one or more disjointed networks. Your task is to determine the number of distinct networks (connected components) represented by the connections. For example, if the input is `[(1, 2), (2, 3), (4, 5)]`, there are 2 distinct networks: one connecting computers `1, 2, 3`, and another connecting computers `4, 5`. If the input is `[(1, 2), (2, 3), (3, 1)]`, there is only 1 network connecting all three computers. Write a function that takes the list of connections and returns the number of distinct networks.","solution":"def count_networks(connections): Count the number of distinct networks (connected components) in the given list of connections. from collections import defaultdict def dfs(node, visited, graph): stack = [node] while stack: n = stack.pop() for neighbor in graph[n]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) graph = defaultdict(list) visited = set() for u, v in connections: graph[u].append(v) graph[v].append(u) networks = 0 for node in graph.keys(): if node not in visited: visited.add(node) dfs(node, visited, graph) networks += 1 return networks"},{"question":"You are given a robot on an infinite grid. The robot starts at `(0, 0)` and can move in one of four directions: `\'U\'` (up), `\'D\'` (down), `\'L\'` (left), or `\'R\'` (right). The robot can be given a sequence of these movements. The grid also contains a set of forbidden points that the robot cannot enter. Given the movement commands as a string and the forbidden points as a list of tuples, determine if the robot will avoid all forbidden points and return to the origin after following all the given commands. Return `True` if the robot returns to the origin while avoiding forbidden points, otherwise return `False`. Implement the function `def will_robot_return(commands: str, forbidden_points: List[Tuple[int, int]]) -> bool`: - `commands` is a string consisting of characters `\'U\'`, `\'D\'`, `\'L\'`, and `\'R\'`. - `forbidden_points` is a list containing tuples of integers representing the points that are forbidden. Output `True` if the robot returns to the origin while avoiding all forbidden points, otherwise `False`.","solution":"from typing import List, Tuple def will_robot_return(commands: str, forbidden_points: List[Tuple[int, int]]) -> bool: Returns True if the robot returns to the origin while avoiding forbidden points, else False. x, y = 0, 0 forbidden = set(forbidden_points) for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 if (x, y) in forbidden: return False return (x, y) == (0, 0)"},{"question":"You are given an array of integers `nums` representing the number of stones in each pile and an integer `k`. You need to determine if it is possible to divide these piles into exactly `k` groups such that the total number of stones in each group is the same. If it is possible, return `true`. Otherwise, return `false`.","solution":"def can_divide_into_k_groups(nums, k): Determine if it\'s possible to divide the piles into exactly k groups such that the total number of stones in each group is the same. total_stones = sum(nums) n = len(nums) # Check if total_stones can be divided into k groups if total_stones % k != 0: return False target = total_stones // k # Check if it\'s possible to partition the array into subsets with given sum def can_partition(current_idx, current_sum, groups_formed, used): if groups_formed == k - 1: return True # If we\'ve successfully formed k-1 groups, the last group is automatically valid if current_sum == target: return can_partition(0, 0, groups_formed + 1, used) # Move to form the next group for i in range(current_idx, n): if not used[i] and current_sum + nums[i] <= target: used[i] = True if can_partition(i + 1, current_sum + nums[i], groups_formed, used): return True used[i] = False return False used = [False] * n return can_partition(0, 0, 0, used)"},{"question":"You are given an integer array `arr` of length `n` and an integer `d`. You need to determine if there exists any two elements in the array such that the absolute difference between them is exactly equal to `d`. Return `true` _if such a pair exists, otherwise return_ `false`.","solution":"def has_pair_with_difference(arr, d): Determines if there are two elements in the array such that their absolute difference is d. Args: arr : List[int] - The array of integers. d : int - The target difference. Returns: bool - True if such a pair exists, otherwise False. elements = set(arr) for num in arr: if (num + d) in elements or (num - d) in elements: return True return False"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find a **non-empty** subarray whose sum is maximum and does not exceed `target`. Return _the **sum** of this subarray_.","solution":"def max_subarray_sum(nums, target): Returns the sum of the maximum subarray whose sum is less than or equal to target. max_sum = float(\'-inf\') current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 if current_sum <= target: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"You are given a string `s` representing a sentence and an integer `k`. The string `s` consists of words separated by single spaces. Each word consists of lowercase letters. Trim the sentence to have only the first `k` words. Return the trimmed sentence as a new string. [Question] 5:","solution":"def trim_sentence(s, k): Trims the given sentence `s` to have only the first `k` words. Parameters: s (str): The sentence to be trimmed. k (int): The number of words to include in the trimmed sentence. Returns: str: The trimmed sentence containing only the first `k` words. words = s.split() trimmed_words = words[:k] return \' \'.join(trimmed_words)"},{"question":"You are given an integer `n` representing the total number of people in a circle, numbered from `1` to `n`. Starting from person `1`, you remove the `k-th` person in the circle moving clockwise, and the removal process continues from the next person immediately after the removed person until only one person remains. Write a function `findTheWinner(int n, int k)` to determine the winner of this elimination game. The function should return the number of the last remaining person. Use an algorithm that is efficient for larger values of `n` and `k`.","solution":"def findTheWinner(n, k): def josephus(n, k): if n == 1: return 0 else: return (josephus(n - 1, k) + k) % n return josephus(n, k) + 1"},{"question":"You are given a **0-indexed** integer array `nums`. A subarray (a contiguous non-empty sequence of elements within an array) is called **balanced** if it contains an equal number of even and odd numbers. Return _the longest length of a **balanced** subarray in_ `nums`. If no such subarray exists, return `0`.","solution":"def find_max_length_balanced_subarray(nums): # This will store the first occurrence of the even-odd difference prefix_map = {0: -1} max_length = 0 even_minus_odd = 0 for i, num in enumerate(nums): if num % 2 == 0: even_minus_odd += 1 else: even_minus_odd -= 1 if even_minus_odd in prefix_map: max_length = max(max_length, i - prefix_map[even_minus_odd]) else: prefix_map[even_minus_odd] = i return max_length"},{"question":"Given an integer array `nums` and an integer `k`, return the _kth smallest element_ in the sorted order within `nums` using an efficient algorithm. Note that `nums` could contain duplicates, but the value we\'re looking for is based on sorted order, so identical values are considered for sorting purposes.","solution":"import heapq def kth_smallest(nums, k): Returns the kth smallest element in the sorted order within nums. Args: nums (List[int]): A list of integers. k (int): An integer representing the position. Returns: int: The kth smallest element in sorted order. if k < 1 or k > len(nums): raise ValueError(\\"k is out of the range of the list length\\") # Using a min-heap to find the kth smallest element # Convert nums to a min-heap heapq.heapify(nums) # Extract min k times to get the kth smallest for _ in range(k - 1): heapq.heappop(nums) return heapq.heappop(nums)"},{"question":"Given an array of integers `arr` containing **unique** elements and an integer `target`, return `true` _if there are three distinct elements in `arr` that sum up to `target`, or_ `false` _otherwise_. The function should attempt to find such a triplet in`O(n^2)`_ time complexity or better.*","solution":"def three_sum(arr, target): Returns True if there are three distinct elements in arr that sum up to target, False otherwise. arr.sort() n = len(arr) for i in range(n): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given an array of strings `words` and a string `target`. Write a function to determine if `target` can be formed by concatenating characters of any string in `words` in the same order. Each word can be used more than once, but all characters of a word must be used in order. Return `true` if it\'s possible to form `target`, otherwise return `false`.","solution":"def can_form_target(words, target): if not target: return True for word in words: if target.startswith(word): if can_form_target(words, target[len(word):]): return True return False"},{"question":"You are given a **0-indexed** integer array `scores` of length `n`, where `scores[i]` represents the score of the `i-th` student. You are also given an integer `k`, representing the number of students to select. The selected students should have the highest total score possible, but no two selected students can be adjacent in the list `scores`. Return the **maximum** total score that can be achieved by selecting exactly `k` students under these constraints.","solution":"def max_score(scores, k): n = len(scores) # Edge cases if k == 0: return 0 if k == 1: return max(scores) # dp[i] will store the maximum score we can get by selecting i students such that the students are not adjacent dp = [0] * (n + 1) # max_vals[i][j] will store the maximum of scores[i] score we can get by selecting j students starting from the ith student max_vals = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): for i in range(n - 1, -1, -1): if j == 1: max_vals[i][j] = scores[i] else: max_vals[i][j] = scores[i] + (max_vals[i + 2][j - 1] if i + 2 < n else 0) max_vals[i][j] = max(max_vals[i][j], max_vals[i + 1][j] if i + 1 < n else 0) return max_vals[0][k]"},{"question":"You are given a list of integers representing the brightness levels of various stars, and an integer `k` representing the number of stars needed to form a cluster. Your task is to find the minimum difference in brightness between the brightest and the dimmest star in any valid cluster of exactly `k` stars. A valid cluster is any subset of `k` stars from the list. Return the minimum possible value of this difference.","solution":"def min_brightness_difference(brightness_levels, k): Returns the minimum difference in brightness between the brightest and the dimmest star in any valid cluster of exactly k stars. Parameters: brightness_levels (list of int): A list of integers representing the brightness levels of various stars. k (int): An integer representing the number of stars needed to form a cluster. Returns: int: The minimum difference in brightness between the brightest and dimmest star in any valid cluster of exactly k stars. if len(brightness_levels) < k: raise ValueError(\\"The list should have at least k elements\\") # Sort the brightness levels brightness_levels.sort() # Initialize the minimum difference with a large value min_diff = float(\'inf\') # Traverse through the sorted list to find the minimum difference for i in range(len(brightness_levels) - k + 1): current_diff = brightness_levels[i + k - 1] - brightness_levels[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"Given an array of integers `arr` where each element represents the height of a vertical line on a 2D plane, determine the maximum amount of water that can be trapped between the lines after a heavy rain. The water trapped should be computed by considering the minimum of the heights of the lines and the spacing between them. Return the maximum volume of water that can be stored in the 2D plane. The input array `arr` will have at least 2 elements, and you are to return a single integer indicating the maximum amount of water that can be trapped.","solution":"def max_trapped_water(arr): Determines the maximum amount of water that can be trapped between the lines. Parameters: arr (list of int): List of integers representing the heights of vertical lines. Returns: int: The maximum amount of water that can be trapped. if not arr or len(arr) < 2: return 0 left = 0 right = len(arr) - 1 max_water = 0 while left < right: height = min(arr[left], arr[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"Alice is organizing a tournament with `n` participants, each identified by a unique player ID from `1` to `n`. Each player will compete exactly once in every round, and each round results in a set of matches where one player wins and the other loses. The matches are represented as a list of tuples `(winner, loser)`. A player can advance to the next round if they have won at least one match in the current round. Given the list of results for each round, you need to determine the set of players who will advance to the next round. Return this set as an array of player IDs sorted in ascending order. For example, if the matches are `[(2, 1), (3, 4), (2, 3), (5, 6)]`, both players `2` and `3` win at least one match each, so the output should be `[2, 3]`. **Note** that each player participates in exactly one match in every round and all player IDs are unique.","solution":"def advancing_players(matches): Given a list of match results where each match is a tuple of (winner, loser), returns a sorted list of player IDs who won at least one match. winners_set = set() for winner, _ in matches: winners_set.add(winner) return sorted(list(winners_set))"},{"question":"Given a list of integers, write a function to find the length of the longest consecutive subsequence of integers in the list. The subsequence can be in any order but it should consist of consecutive numbers. For example, in the list [100, 4, 200, 1, 3, 2], the longest consecutive subsequence is [1, 2, 3, 4], which has a length of 4. Return the length of this subsequence.","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive subsequence of integers in the list. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Check if it is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: # Count consecutive numbers current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a list of words, create a function that groups the words that are anagrams of each other. Return the list of groups, with each group containing words that are anagrams. The groups can be returned in any order.","solution":"from collections import defaultdict def group_anagrams(words): Groups the words that are anagrams of each other. Args: words (list): A list of words. Returns: list: A list of groups, with each group containing words that are anagrams. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"You are given a binary tree where each node contains an integer value. The task is to determine the maximum sum of values obtained by traveling from any node to any other node (including traveling from a node to itself). You may travel through parent nodes and child nodes, but you cannot travel through the same node more than once in this journey. Write a function to find and return this maximum sum. Note: A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum sum of values obtained by traveling from any node to any other node in a binary tree. def helper(node): nonlocal max_sum if not node: return 0 left_sum = max(helper(node.left), 0) right_sum = max(helper(node.right), 0) current_sum = node.val + left_sum + right_sum max_sum = max(max_sum, current_sum) return node.val + max(left_sum, right_sum) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"A sequence of numbers is called **Zigzag** if the differences between successive numbers strictly alternate between positive and negative. Given a sequence of integers, determine the length of the longest subsequence that is a Zigzag. Note that the differences between successive elements in this subsequence must strictly alternate in sign, i.e., if the difference between the first two elements is positive, the difference between the next pair should be negative, and so on, and vice versa.","solution":"def longest_zigzag_sequence(arr): Given an array of integers, find the length of the longest subsequence that is a Zigzag sequence. if len(arr) < 2: return len(arr) up = [1] * len(arr) down = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"You are given an array of integers `nums` and an integer `x`. Your task is to find the number of pairs `(i, j)` such that `i < j` and `nums[i] + nums[j] == x`. Write a function that determines the number of such pairs. Return _the **total count** of the valid pairs._","solution":"def count_pairs(nums, x): Returns the count of pairs (i, j) such that i < j and nums[i] + nums[j] == x. :param nums: List of integers. :param x: Target sum for pairs. :return: Number of valid pairs. count = 0 seen = {} for num in nums: complement = x - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"There are n bulbs, numbered from 1 to n, arranged in a row. Initially, all the bulbs are turned off. You are given an array `operations` where `operations[i] = [left, right]` means that you toggle the state of all bulbs from index `left` to index `right` (inclusive). Toggling the state means that if the bulb is off, it will be turned on, and if it is on, it will be turned off. Write a function to find out the final state of all the bulbs after performing all operations. Return the final state of the bulbs as an array of 0s and 1s, where 0 represents a bulb that is off and 1 represents a bulb that is on.","solution":"def toggleBulbs(n, operations): Returns the final state of the bulbs after performing all operations. Parameters: - n: the number of bulbs. - operations: List of [left, right] pairs representing the operations to be performed. Returns: - List of integers representing the state of each bulb (0 for off, 1 for on). bulbs = [0] * n for left, right in operations: for i in range(left - 1, right): bulbs[i] = 1 - bulbs[i] return bulbs"},{"question":"You are given a list of integers `nums` and a target integer `target`. Write a function that returns the indices of the **two numbers** from the list such that they add up to the target. Each input will have **exactly one solution**, and you cannot use the same element twice. Return the answer in any order. If no such indices exist, return `[-1, -1]`.","solution":"def two_sum(nums, target): Finds two indices such that the numbers at those indices in the list add up to the target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: list of int: A list containing two indices. If no solution exists, returns [-1, -1]. num_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_index: return [num_index[complement], index] num_index[num] = index return [-1, -1]"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to perform a **zigzag level order traversal** of its nodes\' values. (i.e., from left to right, then right to left for the next level, and alternate between). Your function should return a list of lists, where each inner list represents a level in the tree. Function signature: ```python def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: # your code here ```","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] nodes_queue = deque([root]) left_to_right = True while nodes_queue: level_size = nodes_queue.__len__() level_values = deque() for _ in range(level_size): node = nodes_queue.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: nodes_queue.append(node.left) if node.right: nodes_queue.append(node.right) result.append(list(level_values)) left_to_right = not left_to_right return result"},{"question":"You are tasked with creating a task management application for a project team. Each task is represented by a unique task ID and has a specific priority level. The application should support adding tasks, updating task priorities, and retrieving the highest priority task. Implement the `TaskManager` class: * `TaskManager()` Initializes the object. * `void addTask(int taskId, int priority)` Adds a new task with a given `taskId` and `priority` level. If a task with the same `taskId` already exists, update its priority to the new value. * `void removeTask(int taskId)` Removes the task with the given `taskId`. If the task does not exist, do nothing. * `int getHighestPriorityTask()` Returns the `taskId` of the task with the highest priority. If multiple tasks have the same highest priority, return the one that was added most recently. If there are no tasks remaining, return `-1`. Your implementation should efficiently support the operations above.","solution":"class TaskManager: def __init__(self): self.tasks = {} self.priority_list = [] def addTask(self, taskId, priority): if taskId in self.tasks: # remove the old task from the priority list self.priority_list.remove((self.tasks[taskId], taskId)) self.tasks[taskId] = priority # add the new task to the priority list self.priority_list.append((priority, taskId)) # Sort priority list by (priority descending, taskId descending) self.priority_list.sort(key=lambda x: (-x[0], -x[1])) def removeTask(self, taskId): if taskId in self.tasks: self.priority_list.remove((self.tasks[taskId], taskId)) del self.tasks[taskId] def getHighestPriorityTask(self): if not self.priority_list: return -1 return self.priority_list[0][1]"},{"question":"Given an array `tasks` where `tasks[i]` represents the integer duration of the `i-th` task, and an integer `cooldown` representing the required cooldown period between two tasks of the same type, return the least number of units of times that the CPU will take to finish all the given tasks. Each task can be of any integer type, and you may assume that there are infinite slots for task scheduling, but you must respect the cooldown period.","solution":"from collections import Counter def least_interval(tasks, cooldown): Given an array tasks and a cooldown period, return the least number of units of times that the CPU will take to finish all the given tasks. :param tasks: List[int], the array of task durations. :param cooldown: int, the required cooldown period between two tasks of the same type. :return: int, the minimum time units required to complete all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_count = max(task_counts.values()) # Calculate the most number of idle slots required idle_slots = (max_count - 1) * cooldown for count in task_counts.values(): idle_slots -= min(max_count - 1, count) needed_slots = max(0, idle_slots) return len(tasks) + needed_slots"},{"question":"You are given a `0-indexed` array of integers `nums` and an integer `p`. Split the array into one or more subarrays such that each subarray has exactly one even integer and the sum of all subarrays is less than or equal to `p`. Return the maximum number of subarrays you can obtain. If it is not possible to split the array with these constraints, return `-1`.","solution":"def max_subarrays_with_one_even(nums, p): Split the array into maximum number of subarrays such that each subarray has exactly one even integer and the sum of all subarrays is less than or equal to p. n = len(nums) subarrays_count = 0 current_sum = 0 current_even_count = 0 for num in nums: current_sum += num if num % 2 == 0: current_even_count += 1 if current_even_count == 1: # First even number for this potential subarray if current_sum > p: return -1 subarrays_count += 1 current_sum = 0 current_even_count = 0 else: if current_sum > p: return -1 if current_even_count > 0: return -1 return subarrays_count"},{"question":"You are given a binary tree and you want to traverse it in zigzag level order (also known as spiral order). Zigzag level order traversal of a binary tree is defined as follows: - The nodes are visited level by level from left to right. - However, reverse the order of nodes at every other level, i.e., the second level, the fourth level, and so on. Write a function that takes as input the root of a binary tree and returns the zigzag level order traversal of its nodes\' values as a list of lists. Example: Given binary tree [3, 9, 20, null, null, 15, 7], ``` 3 / 9 20 / 15 7 ``` Return its zigzag level order traversal as: ``` [ [3], [20, 9], [15, 7] ] ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_values = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_values)) left_to_right = not left_to_right return result"},{"question":"You are given an `m x n` binary matrix `grid` where `0` represents a sea cell and `1` represents a land cell. Consider a move to be switching any `1` to `0` or any `0` to `1`. You need to find the minimum number of moves required to make all the islands in the grid of equal size. An island is defined as a group of `\'1\'`s (land cells) connected horizontally or vertically. Return the minimum number of moves. Example: If the grid is: ``` [ [1, 0, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0] ] ``` The minimum number of moves needed to make all islands equal size is 1.","solution":"def num_islands(grid): This function calculates the number of islands in a given grid using DFS. if not grid: return 0 def dfs(grid, r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 dfs(grid, r-1, c) dfs(grid, r+1, c) dfs(grid, r, c-1) dfs(grid, r, c+1) count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: dfs(grid, r, c) count += 1 return count def min_moves_to_equalize_islands(grid): This function calculates the minimum number of moves needed to make all islands in the grid of equal size. islands = [] m, n = len(grid), len(grid[0]) def dfs(grid, r, c): if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] != 1: return 0 grid[r][c] = -1 # Mark the cell as visited size = 1 size += dfs(grid, r - 1, c) size += dfs(grid, r + 1, c) size += dfs(grid, r, c - 1) size += dfs(grid, r, c + 1) return size for r in range(m): for c in range(n): if grid[r][c] == 1: islands.append(dfs(grid, r, c)) if len(islands) == 0: return 0 target_size = round(sum(islands) / len(islands)) moves = 0 for size in islands: moves += abs(size - target_size) return moves // 2 # Since each move changes the size by 2"},{"question":"You are given a binary matrix `mat` of size `m x n`, where each cell contains either `0` or `1`. A cell is called \\"special\\" if it contains a `1` and all the cells in the same row and column contain `0`s except for that cell. Return _the number of special cells_ in the matrix `mat`. Example: Input: `mat` = [[1,0,0],[0,0,1],[1,0,0]] Output: 1 Explanation: The cell `mat[1][2]` is the only special cell, as it\'s the only `1` in its row and column.","solution":"def numSpecial(mat): m = len(mat) n = len(mat[0]) rows = [sum(row) for row in mat] cols = [sum(col) for col in zip(*mat)] special_count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1: special_count += 1 return special_count"},{"question":"A company is planning to develop a new software system to manage their employees\' vacation requests. The vacation periods are represented as intervals `[start, end]` where `start` and `end` are inclusive dates given as integers. You are given a list of `n` vacation intervals for the employees. Return _the **minimum number of additional vacation periods** the company must allow such that **no two intervals overlap** and every employee gets their requested vacation period._ If an interval overlaps with another, the company must offer additional separate periods to accommodate the original intervals without overlap.","solution":"def min_additional_vacation_periods(intervals): Returns the minimum number of additional vacation periods required to allow all intervals without overlap. if not intervals: return 0 intervals.sort(key=lambda x: x[0]) end_times = [intervals[0][1]] for interval in intervals[1:]: # Assign the earliest possible non-overlapping period placed = False for i in range(len(end_times)): if interval[0] > end_times[i]: end_times[i] = interval[1] placed = True break if not placed: # Need a new additional period end_times.append(interval[1]) return len(end_times) - 1"},{"question":"You are given two strings `s1` and `s2` consisting of lowercase English letters. You can use the characters of each string to form a new string by concatenating them. However, you can only use a character from each string at most once. You aim to form the longest common subsequence (LCS) from the newly formed strings out of the characters of `s1` and `s2`. Two subsequences are considered common if they can both be derived from the new strings by deleting some characters without changing the order of the remaining characters. Return _the length of the longest common subsequence that can be formed from the characters of `s1` and `s2`_. If it is not possible to form any common subsequence, return `0`.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence that can be formed from the characters of s1 and s2. m, n = len(s1), len(s2) # Initialize a (m+1) by (n+1) DP table filled with zeroes. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table using a bottom-up dynamic programming approach. for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings arranged in a straight line. Each building `i` has a different height `heights[i]`. A builder wants to cover as many buildings as possible using the least number of rectangular platforms. Each platform can cover buildings from `i` to `j` (inclusive) if and only if all buildings have the exact same height. Return the minimum number of platforms required to cover all buildings.","solution":"def min_platforms(heights): Returns the minimum number of platforms required to cover all buildings where each platform can cover buildings with the same heights. Arguments: heights -- list of integers representing the heights of the buildings. Returns: int -- minimum number of platforms required. if not heights: return 0 platforms = 1 current_height = heights[0] for height in heights: if height != current_height: platforms += 1 current_height = height return platforms"},{"question":"You are given an integer array `nums` sorted in **non-decreasing order**, and an integer `target`. You need to find the starting and ending position of a given `target` value. If `target` is not found in the array, return `[-1, -1]`. Write a function that takes the array `nums` and the integer `target` as inputs and returns an array of length 2 representing the start and end positions.","solution":"def search_range(nums, target): This function returns the starting and ending positions of a given target value in a sorted array. If the target is not found, the function returns [-1, -1]. :param nums: List[int] - Sorted list of integers :param target: int - Target value to find :return: List[int] - Starting and ending positions of the target value def find_position(left=True): low, high = 0, len(nums) - 1 position = -1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: position = mid if left: high = mid - 1 else: low = mid + 1 elif nums[mid] < target: low = mid + 1 else: high = mid - 1 return position start = find_position(left=True) if start == -1: return [-1, -1] # Target not found end = find_position(left=False) return [start, end]"},{"question":"You are given a **0-indexed** `m x n` integer matrix `grid` where each cell contains an integer representing the elevation at that point. You aim to move from the top-left corner `(0, 0)` to the bottom-right corner `(m - 1, n - 1)` by moving only **down** or **right**. During your path, the elevation difference between any two consecutive cells should not exceed a given integer `E`. Return _the number of such valid paths from `(0, 0)` to `(m - 1, n - 1)`_. Since the answer may be very large, return it **modulo** `109 + 7`.","solution":"def count_valid_paths(grid, E): m, n = len(grid), len(grid[0]) MOD = 10**9 + 7 # Initialize a dp table. dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the dp table for i in range(m): for j in range(n): if i > 0 and abs(grid[i][j] - grid[i-1][j]) <= E: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0 and abs(grid[i][j] - grid[i][j-1]) <= E: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[-1][-1]"},{"question":"You are given an integer array `headers` where each element represents the number of pages a printer can print in one minute, and an integer `pages` which represents the total number of pages needed to be printed across multiple printers working simultaneously. Assuming all printers start printing at the same time, determine _the minimum number of minutes required to print exactly_ `pages` _pages._","solution":"def min_time_to_print(headers, pages): Determine the minimum number of minutes required to print exactly `pages` pages given the capabilities of multiple printers working simultaneously. :param headers: List of integers where each integer represents the number of pages a printer can print in one minute. :param pages: Integer representing the total number of pages to be printed. :return: Minimum number of minutes required to print `pages` pages. def can_print_in_time(time): Helper function to calculate whether the printers can print the required number of pages in the given time. total_pages = sum(time * rate for rate in headers) return total_pages >= pages low, high = 1, max(headers) * ((pages + min(headers) - 1) // min(headers)) while low < high: mid = (low + high) // 2 if can_print_in_time(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an integer array `nums` and an integer `target`. Design an algorithm to find the number of continuous subarrays in `nums` that sum up to the `target`. Return the number of such subarrays. A continuous subarray is a slice of the array where elements are contiguous, and the order of elements in the slice must be maintained as in the original array.","solution":"def subarray_sum(nums, target): Returns the number of continuous subarrays which sum up to the target. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if (current_sum - target) in prefix_sums: count += prefix_sums[current_sum - target] prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"Given a string `s` and an integer `k`, you need to perform the following operation exactly `k` times: Choose any character `c` in `s` and all occurrences of `c` in the string will be removed. Your goal is to maximize the length of the remaining string after `k` operations. Return _the length of the string after the operations_.","solution":"from collections import Counter def max_length_after_k_operations(s, k): Returns the length of the string after removing all occurrences of `k` characters. Args: - s: the input string - k: the number of characters to remove Returns: - An integer representing the length of the remaining string if not s or k == 0: return len(s) # Generate the frequency count of each character in the string char_count = Counter(s) # Get the k most frequent characters most_common_chars = char_count.most_common(k) # Calculate the number of characters to remove chars_to_remove = sum(count for _, count in most_common_chars) # Return the remaining length after removing k most frequent characters return len(s) - chars_to_remove"},{"question":"You are given an array `arr` consisting of `n` integers. A **subarray** of `arr` is a contiguous block of elements within `arr`. Define the **beauty** of a subarray as the difference between the maximum and minimum elements in the subarray. Your task is to return the sum of the beauty of all possible subarrays of length exactly `k`. For example, given `arr = [4, 2, 1, 3]` and `k = 2`, the possible subarrays of length `k` are: `[4, 2], [2, 1], [1, 3]`. The sum of the beauties of these subarrays is `(4-2) + (2-1) + (3-1) = 2 + 1 + 2 = 5`.","solution":"def sum_of_beauties(arr, k): Returns the sum of the beauty of all possible subarrays of length exactly k. n = len(arr) sum_beauty = 0 for i in range(n - k + 1): subarray = arr[i:i + k] max_element = max(subarray) min_element = min(subarray) beauty = max_element - min_element sum_beauty += beauty return sum_beauty"},{"question":"You are given two strings, `s` and `t`, and an integer `maxCost`. Each string consists of lowercase letters and has the same length. You want to convert string `s` into string `t` by changing each character from `s` to the corresponding character in `t`. The **cost** of converting the `i`-th character of `s` into the `i`-th character of `t` is `abs(s[i] - t[i])`, where `abs` denotes the absolute value of the difference between the ASCII values of the characters. Return the maximum length of a substring of `s` that can be converted to a corresponding substring of `t` with the total **cost** not exceeding `maxCost`.","solution":"def equalSubstring(s, t, maxCost): max_len = 0 current_cost = 0 start = 0 for end in range(len(s)): current_cost += abs(ord(s[end]) - ord(t[end])) while current_cost > maxCost: current_cost -= abs(ord(s[start]) - ord(t[start])) start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given an **m x n** binary matrix `grid` representing a map where `1` represents land and `0` represents water. An **island** is a maximal group of connected `1`s, where a cell is connected to another if they are adjacent horizontally or vertically. The **distance** between two islands is defined as the shortest path between any two land cells, each from different islands, including transformation steps from land to water. Return the length of the shortest bridge needed to connect any two islands. For example, if `grid = [[0, 1], [1, 0]]`, the shortest bridge has length `1`.","solution":"from collections import deque def shortest_bridge(grid): def dfs(x, y, visited, island): stack = [(x, y)] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) island.append((cx, cy)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # explore neighbors nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: stack.append((nx, ny)) def get_islands(): visited = set() islands = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: island = [] dfs(i, j, visited, island) islands.append(island) return islands islands = get_islands() def bfs(queue, visited): steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: if grid[nx][ny] == 1: return steps visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1 if len(islands) < 2: return -1 island1 = islands[0] island2 = islands[1] island1_queue = deque(island1) visited_from_island1 = set(island1) return bfs(island1_queue, visited_from_island1)"},{"question":"You are given an integer matrix `grid` of size `m x n` and an integer `threshold`. An element in the matrix is considered a **neighbor** if it is directly up, down, left, or right from the current element. Find the **largest region** in the grid that contains only elements less than or equal to the `threshold`. A region is defined as a group of connected elements (via neighbors) that all satisfy the condition of being less than or equal to `threshold`. Return the _size of the largest region_ found. Run-time complexity should be taken into account while designing the solution.","solution":"def largest_region(grid, threshold): Find the largest region in the grid with elements <= threshold. Parameters: grid (List[List[int]]): 2D list representing the grid. threshold (int): The threshold value. Returns: int: Size of the largest region. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] > threshold: return 0 visited[x][y] = True size = 1 # current cell for delta_x, delta_y in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + delta_x, y + delta_y) return size largest = 0 for i in range(m): for j in range(n): if grid[i][j] <= threshold and not visited[i][j]: largest = max(largest, dfs(i, j)) return largest"},{"question":"You are given a 2D integer array `tasks`, where `tasks[i] = [duration, deadline]` represents a task that takes `duration` amount of time to complete and has a deadline specified by `deadline`. You need to complete all the tasks in a way that maximizes the number of tasks completed before their respective deadlines. You have unlimited resources and can complete multiple tasks at the same time as long as their total duration does not exceed the deadline they are supposed to meet. Implement a function `int maxTasksWithinDeadline(int[][] tasks)` that returns the maximum number of tasks that can be completed before their deadlines. Each task must be executed within its own duration time and completed by its deadline.","solution":"def maxTasksWithinDeadline(tasks): Returns the maximum number of tasks that can be completed before their respective deadlines. :param tasks: List of tasks where each task is represented by [duration, deadline] :type tasks: List[List[int]] :return: Maximum number of tasks that can be completed before their deadlines :rtype: int # Sort the tasks by their deadlines (critical step) tasks.sort(key=lambda x: x[1]) # Initialize current time and tasks completed count current_time = 0 tasks_completed = 0 # Iterate through the sorted tasks for duration, deadline in tasks: if current_time + duration <= deadline: # If the task can be completed within its deadline current_time += duration tasks_completed += 1 return tasks_completed"},{"question":"You are given a **0-indexed** integer array `arr` which represents a binary tree in level order traversal where `arr[i]` is the value of the ith node in the level order traversal. If the ith position is empty, then `arr[i]` will be -1. Your task is to return the **sum of the values** of the nodes that make up the longest path from the root to a leaf. If there are multiple paths of the same length, return the path with the maximum sum. In other words, the function should return the maximum possible sum of values among the longest root-to-leaf paths.","solution":"def max_sum_of_longest_path(arr): if not arr or arr[0] == -1: return 0 def dfs(index): if index >= len(arr) or arr[index] == -1: return (0, 0) # (sum, depth) left_index = 2 * index + 1 right_index = 2 * index + 2 left_sum, left_depth = dfs(left_index) right_sum, right_depth = dfs(right_index) if left_depth > right_depth: return (left_sum + arr[index], left_depth + 1) elif right_depth > left_depth: return (right_sum + arr[index], right_depth + 1) else: return (max(left_sum, right_sum) + arr[index], left_depth + 1) max_sum, _ = dfs(0) return max_sum"},{"question":"Given an array of positive integers `arr`, you can perform the following operation any number of times: choose any two distinct indices `i` and `j` and remove the element at `j`, then replace the element at `i` with their sum. The goal is to minimize the number of remaining elements in the array. Write a function that returns the minimum possible number of elements that can remain in the array after performing the operation any number of times.","solution":"def minimize_array(arr): Given an array of positive integers, returns the minimum possible number of elements that can remain in the array after performing the specified operation any number of times. The operation is: choose any two distinct indices i and j, remove the element at j, then replace the element at i with their sum. # The minimum number of elements that can remain in a non-empty array is 1. return 1 if arr else 0"},{"question":"Given a list of `n` integers, find the length of the longest increasing subsequence. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return _the **length** of the longest increasing subsequence_.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not nums: return 0 # DP array to store the length of the longest increasing subsequence up to each element dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp)"},{"question":"You are given a `0-indexed` integer array `nums` of length `n` where all elements are distinct. The integer array `nums` represents a permutation of the numbers in the range `[0, n - 1]`. You are allowed to swap any two elements of `nums`. Return _the minimum number of swaps required to sort the array in ascending order_.","solution":"def minSwaps(nums): Returns the minimum number of swaps required to sort the array `nums` in ascending order. n = len(nums) arrPos = [(num, idx) for idx, num in enumerate(nums)] arrPos.sort() visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arrPos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrPos[j][1] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"You are given a list of strings `words` and another string `characters`. Write a function that returns the sum of lengths of all `words[i]` that can be formed by characters from `characters`. You can only use each character from `characters` once. Ensure that each word in `words` must be fully formed using the available characters from `characters`. Return _the total length of all words that can be formed._","solution":"from collections import Counter def count_characters(words, characters): Returns the sum of the lengths of all words that can be formed by characters from the given set of characters. Each character can only be used once. total_length = 0 char_count = Counter(characters) for word in words: word_count = Counter(word) can_form_word = True for char in word: if word_count[char] > char_count[char]: can_form_word = False break if can_form_word: total_length += len(word) return total_length"},{"question":"You are given a list of integers `arr` and an integer `k`. You can perform the following operation exactly `k` times: **Remove any element from the list and add it back at any position**. Your task is to determine the maximum possible sum of the list after performing exactly `k` operations. For example, if `arr = [1, 3, 5, 2, 4]` and `k = 2`, then the maximum sum you can obtain is `15` by removing `5` and `3`, and adding them back at the end of the list making it `[1, 2, 4, 5, 3]`. Return the maximum possible sum of the list after `k` operations.","solution":"def max_possible_sum(arr, k): Returns the maximum possible sum of the list `arr` after performing exactly `k` operations. In each operation, any element can be removed and added back to any position. :param arr: List of integers :param k: Number of operations allowed :return: Maximum possible sum after k operations arr.sort() return sum(arr)"},{"question":"Given a list of points in the 2D plane, where each point is represented by a tuple (x, y), return the total area covered by these points on the Cartesian plane. Each point should be considered as a 1x1 square centered at the given coordinates. Overlapping areas should be counted only once. The result should be an integer representing the total covered area.","solution":"def calculate_area(points): Given a list of points in the 2D plane, where each point is represented by a tuple (x, y), return the total area covered by these points on the Cartesian plane. Each point should be considered as a 1x1 square centered at the given coordinates. Overlapping areas should be counted only once. unique_points = set() for x, y in points: unique_points.add((x, y)) return len(unique_points)"},{"question":"You are given an integer array `courses` where `courses[i]` represents the duration of the `i-th` course. You are also given an integer `days` that represents the total number of days you can dedicate to taking these courses. Each course can only be taken on consecutive days. You need to determine if it is possible to take all the given courses within the provided number of days. If it is possible, return `true`, otherwise return `false`.","solution":"def can_take_all_courses(courses, days): Determines if it is possible to take all the courses within the given number of days. :param courses: List[int], a list of course durations :param days: int, the total number of days available :return: bool, True if it is possible to take all courses within the given days, False otherwise total_course_days = sum(courses) return total_course_days <= days"},{"question":"You are given two strings, `word1` and `word2`. A string `word3` is said to be a valid shuffle of `word1` and `word2` if it can be formed by interleaving the characters of `word1` and `word2` maintaining the order of characters in both strings. Determine if `word3` is a valid shuffle of `word1` and `word2`. Return `true` if `word3` is a valid shuffle, otherwise return `false`.","solution":"def is_valid_shuffle(word1, word2, word3): Returns true if word3 is a valid shuffle of word1 and word2, otherwise false. # Check if the total length matches if len(word3) != len(word1) + len(word2): return False # Use two pointers to track position in word1 and word2 i, j = 0, 0 for char in word3: if i < len(word1) and char == word1[i]: i += 1 elif j < len(word2) and char == word2[j]: j += 1 else: return False return True"},{"question":"You are given a list of `n` integers representing the water levels at various points along a canal. Each integer represents the height of the water at that point. You need to find the amount of water that can be trapped after a rain. More formally, given `n` non-negative integers representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining. Return _the total amount of water trapped_.","solution":"def trap_water(height): Given n non-negative integers representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a maximal group of connected `1`s, where two `1`s are considered connected if they are adjacent horizontally or vertically. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island does not have \\"lakes\\" (water inside that is not connected to the water around the island). Each cell is square, and distance is being measured in manhattan distance, where distance between two cells (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. You are given the grid `grid`, return _the length of the shortest bridge_ that you can build to connect the island to itself. A bridge is a series of `0`s that connects two 1\'s while minimizing the distance between them. You can change any number of `0`s to `1`s to form the bridge.","solution":"from collections import deque def shortestBridge(grid): Returns the length of the shortest bridge to connect the island to itself. def bfs(queue): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: r, c, distance = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and (nr, nc) not in visited: if grid[nr][nc] == 1: return distance queue.append((nr, nc, distance + 1)) visited.add((nr, nc)) return -1 def mark_island(r, c): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(r, c)]) island_points.append((r, c, 0)) grid[r][c] = -1 while queue: cr, cc = queue.popleft() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 1: grid[nr][nc] = -1 queue.append((nr, nc)) island_points.append((nr, nc, 0)) m, n = len(grid), len(grid[0]) island_points = [] found = False for i in range(m): for j in range(n): if grid[i][j] == 1: mark_island(i, j) found = True break if found: break visited = set((r, c) for r, c, _ in island_points) queue = deque(island_points) return bfs(queue)"},{"question":"You are given a **circular linked list** where each node contains a positive integer value and a pointer to the next node. A circular linked list means that the last node points back to the first node. The circular linked list has the following definition: struct Node { int val; Node *next; } Write a function to insert a new node with a given value `insertVal` into the circular linked list such that the list remains sorted in ascending order. If there are multiple suitable places to insert the new node, insert it after the largest node which is smaller or equal to `insertVal`. If the list is empty, create a new single node circular list and return it.","solution":"class Node: def __init__(self, val, next=None): self.val = val self.next = next def insert_into_sorted_circular_list(head, insertVal): Inserts a new node with given value insertVal into the sorted circular linked list. new_node = Node(insertVal) if head is None: new_node.next = new_node return new_node curr = head while True: # Case 1: Insert in the middle of the list if curr.val <= insertVal <= curr.next.val: break # Case 2: Insert at the boundary between largest and smallest if curr.val > curr.next.val and (insertVal >= curr.val or insertVal <= curr.next.val): break curr = curr.next # Case 3: Came back to head, means all are same values if curr == head: break new_node.next = curr.next curr.next = new_node return head"},{"question":"You are given a list of integers `heights` representing the height of buildings and an integer `bricks` and `ladders` representing the number of bricks and ladders you have respectively. You can either use bricks or ladders to move from one building to another building if the next building is taller. You need `height difference` number of bricks to move to the taller building if you choose to use bricks or one ladder to skip any height difference. Your goal is to reach the furthest building index starting from the 0th building. Return _the **maximum** building index (0-based) you can reach if you optimally use the given bricks and ladders_.","solution":"import heapq def furthest_building(heights, bricks, ladders): min_heap = [] for i in range(len(heights) - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) > ladders: bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(heights) - 1"},{"question":"Write a function `maxSubArrayProduct(nums)` that takes a list of integers `nums` as input and returns the maximum product of a contiguous subarray within the list. A **contiguous subarray** is a subarray that appears sequentially in the original array. Note that the input list may contain both positive and negative numbers, as well as zero. Ensure your solution efficiently handles the possibility of negative results and zero values by leveraging the properties of products.","solution":"def maxSubArrayProduct(nums): Returns the maximum product of a contiguous subarray within the nums list. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"You are given an array `transactions` where `transactions[i] = [accountId, balance]`, representing the account ID and the remaining balance of each active account. Implement functions to perform the following operations: * `void deposit(int accountId, int amount)`: deposit a specified amount into the account with the given ID. * `boolean withdraw(int accountId, int amount)`: withdraw a specified amount from the account with the given ID if the account has sufficient balance; return `true` if the withdrawal is successful and `false` otherwise. * `int getBalance(int accountId)`: return the current balance of the account with the given ID. Make sure to handle cases where an operation is attempted on a non-existent account gracefully.","solution":"class Bank: def __init__(self, transactions): Initializes the bank with the given transactions. :param transactions: List[List[int, int]] - List of [accountId, balance] self.accounts = {accountId: balance for accountId, balance in transactions} def deposit(self, accountId, amount): Deposits the specified amount into the account with the given ID. :param accountId: int - The ID of the account :param amount: int - The amount to deposit if accountId in self.accounts: self.accounts[accountId] += amount else: self.accounts[accountId] = amount def withdraw(self, accountId, amount): Withdraws the specified amount from the account with the given ID if there is sufficient balance. :param accountId: int - The ID of the account :param amount: int - The amount to withdraw :return: boolean - True if the withdrawal is successful, False otherwise if accountId in self.accounts and self.accounts[accountId] >= amount: self.accounts[accountId] -= amount return True return False def getBalance(self, accountId): Returns the current balance of the account with the given ID. :param accountId: int - The ID of the account :return: int - The current balance of the account, or 0 if the account does not exist return self.accounts.get(accountId, 0)"},{"question":"Given an array of positive integers `arr`, return the length of the longest contiguous subarray such that after removing one element, the remaining subarray contains all unique elements. If all elements in the original array are unique, return the length of the array minus one.","solution":"def longest_subarray_after_removal(arr): def unique_subarray_length(sub): seen = set() for num in sub: if num in seen: return len(seen) seen.add(num) return len(seen) max_length = 0 for i in range(len(arr)): sub = arr[:i] + arr[i+1:] max_length = max(max_length, unique_subarray_length(sub)) return max_length"},{"question":"Given a grid of size `m x n` filled with non-negative integers, you can move from any cell to any adjacent cell (horizontally or vertically) as long as the adjacent cell has a higher value than the current cell. Your task is to find the length of the longest path where the path\'s numbers are strictly increasing. You need to implement the `longestIncreasingPath` method, which takes in a 2D integer array `grid`. The method should return the length of the longest path in the given grid. Example: Consider the following grid: ``` [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] ``` The longest increasing path is `[1, 2, 6, 9]`, which has a length of `4`. Definition: ```python class Solution: def longestIncreasingPath(self, grid: List[List[int]]) -> int: # your code here ```","solution":"from typing import List class Solution: def longestIncreasingPath(self, grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[-1 for _ in range(n)] for _ in range(m)] # -1 indicates unvisited def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return dp[x][y] result = 0 for i in range(m): for j in range(n): result = max(result, dfs(i, j)) return result"},{"question":"Given a list of strings `words` and a string `pattern`, find all strings in the list that match the pattern. A string matches the pattern if there is a bijection between a letter in the pattern and a letter in the word. More clearly, there must be a one-to-one mapping between each letter in the pattern and each letter in the word. For example, if `pattern` is \\"abb\\" then: - \\"deq\\" matches the pattern because \\"d\\" -> \\"a\\", \\"e\\" -> \\"b\\", \\"q\\" -> \\"b\\". - \\"mee\\" matches the pattern because \\"m\\" -> \\"a\\", \\"e\\" -> \\"b\\", \\"e\\" -> \\"b\\". - \\"aqq\\" does not match the pattern because \\"a\\" -> \\"a\\", \\"q\\" -> \\"b\\", and \\"q\\" -> \\"b\\" which is contradictory. Return a list of all words that match the given pattern. The length of `pattern` and the words in `words` are guaranteed to be the same.","solution":"def find_and_replace_pattern(words, pattern): def matches(word): mapping = {} reverse_mapping = {} for w_char, p_char in zip(word, pattern): if w_char not in mapping: if p_char in reverse_mapping: return False mapping[w_char] = p_char reverse_mapping[p_char] = w_char elif mapping[w_char] != p_char: return False return True return [word for word in words if matches(word)]"},{"question":"You are given a **sorted** array `arr` of distinct integers which can be positive, negative, or zero. Your task is to find the smallest missing positive integer in the array. A positive integer is missing if it does not appear in the array and is larger than 0. Return _the smallest missing positive integer._ If no positive integer is missing, return _the next positive integer that would follow the largest element in the array_. For example, if `arr = [-3, -1, 1, 2, 4, 5]` then the smallest missing positive integer would be `3`, and for `arr = [1, 2, 3, 4, 5]` the result would be `6`.","solution":"def smallest_missing_positive(arr): Finds the smallest missing positive integer in a sorted array of distinct integers. Parameters: - arr: list of distinct integers (sorted). Returns: - The smallest missing positive integer. # Initialize the smallest missing positive integer missing = 1 # Iterate over the array for num in arr: if num == missing: # Increment the smallest missing positive integer missing += 1 elif num > missing: # If we\'ve found a gap, break out of the loop break return missing"},{"question":"Given two strings `s` and `p`, where `s` is a string of lowercase English letters and `p` is a pattern string which can contain lowercase English letters, \'?\' (which matches any single character), and \'*\' (which matches any sequence of characters including the empty sequence), implement a function to determine if `p` matches `s`. Return `true` if `p` matches `s`, otherwise return `false`.","solution":"def is_match(s, p): Determines if the pattern p matches the string s, where \'?\' matches any single character, and \'*\' matches any sequence of characters (including the empty sequence). m, n = len(s), len(p) # dp[i][j] will be True if the first i characters in s match the first j characters in p dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Empty pattern matches empty string # Fill the first row for patterns with \'*\' at the beginning for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] else: break # Fill the rest of the dp table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"Given an array of integers `nums` and an integer `k`, your task is to divide the array into `k` non-overlapping subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum among the `k` subarrays. You may assume that it is always possible to divide the array into the required number of subarrays. Ensure that the solution designed efficiently handles the problem constraints.","solution":"def minimize_max_sum(nums, k): Divide nums into k non-overlapping subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum among the k subarrays. def can_split(nums, k, max_sum): Helper function to check if it\'s possible to split the array into k parts with each part\'s sum <= max_sum. current_sum = 0 parts = 1 for num in nums: if current_sum + num > max_sum: current_sum = num parts += 1 if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `nums` and an integer target `k`. Your task is to return the number of unique pairs of integers in the array whose sum is equal to the target `k`. A pair `(a, b)` is considered unique if there are no other pairs with the same elements, regardless of the order. For example, (1, 2) and (2, 1) are considered the same pair and hence should not be counted twice. Note that the pairs should consist of distinct elements in the array. Return the number of unique pairs that add up to the target sum `k`.","solution":"def count_unique_pairs(nums, k): Returns the number of unique pairs of integers in nums that sum up to k. A pair (a, b) is considered unique if there are no other pairs with the same elements, regardless of the order. if not nums: return 0 seen = set() pairs = set() for num in nums: complement = k - num if complement in seen and (min(num, complement), max(num, complement)) not in pairs: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"Given the `root` node of a binary tree, implement a function that returns a list of all the leaves. A leaf is a node with no children. The function should traverse the tree in any order and gather the values of all leaf nodes. Make sure to account for edge cases such as an empty tree or a tree with only one node. Your solution should handle trees with varying structures and sizes effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def get_leaves(root): Returns a list of values of all leaf nodes in the binary tree. def collect_leaves(node, leaves): if node: if not node.left and not node.right: leaves.append(node.val) collect_leaves(node.left, leaves) collect_leaves(node.right, leaves) leaves = [] collect_leaves(root, leaves) return leaves"},{"question":"You are given a list of integers `nums` representing the number of points each player scored in a series of games. A player who scores more than the previous one is considered to have a \\"winning streak\\". Return the **length** of the longest winning streak in the series. If there is no winning streak, return 0.","solution":"def longest_winning_streak(nums): Returns the length of the longest winning streak in the series. A winning streak is when each score is greater than the preceding score. if not nums: return 0 max_streak = 0 current_streak = 0 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return 0 if max_streak == 0 else max_streak + 1"},{"question":"You are given a grid representing a city where `1` represents an obstacle and `0` represents an open space. You are also given the coordinates of a starting point `(sx, sy)` and a target point `(tx, ty)`, both of which are guaranteed to be open spaces. Determine if there is a path from the starting point to the target point such that the path does not pass through any obstacles. You can move up, down, left, or right at each step. Return `true` if such a path exists, otherwise return `false`.","solution":"from collections import deque def is_path(grid, sx, sy, tx, ty): Determines if there is a path from (sx, sy) to (tx, ty) in the given grid. A 1 represents an obstacle and a 0 represents an open space. :param grid: List[List[int]], the grid representing the city. :param sx: int, starting x-coordinate :param sy: int, starting y-coordinate :param tx: int, target x-coordinate :param ty: int, target y-coordinate :return: bool, True if a path exists, otherwise False rows, cols = len(grid), len(grid[0]) visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy)]) while queue: x, y = queue.popleft() if (x, y) == (tx, ty): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"You are given a **0-indexed** integer array `points` where `points[i]` represents the **score** of the `i-th` assignment. You are also provided an integer `m` which denotes the maximum number of consecutive assignments you can choose. Your task is to select assignments such that: * You pick a non-empty sequence of consecutive assignments with length less than or equal to `m`. * You maximize the total score obtained by the selected sequence of assignments. Return _the **maximum** total score obtained by any valid sequence of assignments._","solution":"def max_score(points, m): Returns the maximum total score obtained by any valid sequence of assignments. :param points: List[int] - The list of scores. :param m: int - The maximum number of consecutive assignments that can be chosen. :return: int - The maximum total score. n = len(points) max_sum = float(\'-inf\') for i in range(n): current_sum = 0 for j in range(i, min(i + m, n)): current_sum += points[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an integer array `nums`, segregate all 0s to the beginning and all 1s to the end while maintaining the relative order of other elements. Return the modified array. For example, given `nums = [0, 1, 0, 3, 12]`, the function should return `[0, 0, 3, 12, 1]`. Write an efficient algorithm to achieve this in linear time with a constant amount of extra space.","solution":"def segregate_zeros_and_ones(nums): Segregates all 0s to the beginning and all 1s to the end while maintaining the relative order of other elements. :param nums: List of integers :return: Modified list with 0s at the beginning and 1s at the end if not nums: return nums n = len(nums) result = [] count_zeros = 0 count_ones = 0 # First pass: Count 0s and 1s and collect non-0 and non-1 elements for num in nums: if num == 0: count_zeros += 1 elif num == 1: count_ones += 1 else: result.append(num) # Construct the final array with zeros at the beginning, followed by the non-0/non-1 elements, and ones at the end return [0] * count_zeros + result + [1] * count_ones"},{"question":"You are given a `n x n` grid that represents a maze, where each cell can either be empty (represented by `0`) or blocked (represented by `1`). You start at the top-left corner of the maze and want to reach the bottom-right corner. You can only move up, down, left, or right, and you cannot move through blocked cells. Determine if there is a path from the top-left corner to the bottom-right corner of the maze. Return `true` if there is a path and `false` otherwise.","solution":"def has_path(maze): Determines if there is a path from the top-left corner to the bottom-right corner of the maze. n = len(maze) if maze[0][0] == 1 or maze[n-1][n-1] == 1: return False def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or maze[x][y] == 1: return False if x == n-1 and y == n-1: return True maze[x][y] = 1 # Mark as visited if dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1): return True maze[x][y] = 0 # Unmark as visited for other paths return False return dfs(0, 0)"},{"question":"You are given a grid representing a city where each cell can either be a building or an empty lot. Your goal is to place a building in an empty lot such that the distance to the nearest building is minimized. The grid is a 2D integer array `grid` where `grid[i][j]` can be either `0` (an empty lot) or `1` (a building). The distance used in this problem is the Manhattan Distance, which is calculated as `|i1 - i2| + |j1 - j2|`. Return the minimum distance to the nearest building after placing a building in any of the empty lots. If it is not possible to place a building, return `-1`.","solution":"from collections import deque def min_distance_to_nearest_building(grid): rows = len(grid) cols = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start_i, start_j): visited = [[False]*cols for _ in range(rows)] queue = deque([(start_i, start_j, 0)]) visited[start_i][start_j] = True max_distance = 0 while queue: i, j, dist = queue.popleft() for direction in directions: ni, nj = i + direction[0], j + direction[1] if 0 <= ni < rows and 0 <= nj < cols and not visited[ni][nj]: visited[ni][nj] = True if grid[ni][nj] == 1: return dist + 1 queue.append((ni, nj, dist + 1)) return float(\'inf\') empty_lots = [(i, j) for i in range(rows) for j in range(cols) if grid[i][j] == 0] if not empty_lots: return -1 min_distance = float(\'inf\') for i, j in empty_lots: distance = bfs(i, j) if distance < min_distance: min_distance = distance return min_distance if min_distance != float(\'inf\') else -1"},{"question":"You are given a binary tree where each node contains an integer value. Return the **sum of the values** of each node in the tree\'s left subtree. The left subtree of a node is defined as the subtree rooted at that node\'s left child. If a node does not have a left child, its left subtree sum is considered to be 0. Here\'s the structure for the binary tree node: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function: ``` def sumOfLeftSubtree(root: Optional[TreeNode]) -> int: ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeftSubtree(root: TreeNode) -> int: Returns the sum of the values of each node in the tree\'s left subtree. if not root or not root.left: return 0 def subtreeSum(node: TreeNode) -> int: if not node: return 0 return node.val + subtreeSum(node.left) + subtreeSum(node.right) return subtreeSum(root.left)"},{"question":"You are given an integer array `packages` representing the weights of packages, and an integer `truckCapacity` which represents the maximum weight the truck can carry. Each package can either be loaded onto the truck or left behind. You need to determine the **maximum number** of packages that can be loaded onto the truck without exceeding the `truckCapacity`. Return _the maximum number of packages the truck can carry_.","solution":"def max_packages(packages, truckCapacity): Returns the maximum number of packages that can be loaded onto the truck without exceeding the truck\'s capacity. :param packages: List[int] - List of package weights :param truckCapacity: int - Maximum weight the truck can carry :return: int - Maximum number of packages that can be loaded onto the truck # Sort the packages in ascending order to maximize the number of packages loaded packages.sort() current_weight = 0 num_packages = 0 # Load packages until adding another would exceed the truck\'s capacity for weight in packages: if current_weight + weight > truckCapacity: break current_weight += weight num_packages += 1 return num_packages"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is defined as unique if it does not contain any repeating characters. Write a function that returns the length of the longest unique substring in `s`. If the string is empty, return 0. Use a sliding window approach with a hashmap to achieve an optimal solution.","solution":"def length_of_longest_unique_substring(s): Return the length of the longest substring without repeating characters. :param s: String consisting of lowercase English letters :return: Length of the longest unique substring char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: # Update the start position if the current character was seen after the start start = max(start, char_map[s[end]] + 1) # Current character\'s most recent index char_map[s[end]] = end # Calculate the length of the current window max_length = max(max_length, end - start + 1) return max_length"},{"question":"Write a function that takes an integer array `heights` representing the heights of a lineup of people, and an integer `k` representing the number of people that need to be selected. Your task is to select `k` people such that the difference between the maximum height and the minimum height of the selected people is minimized. Return the minimum possible difference.","solution":"def min_difference_in_heights(heights, k): Returns the minimum possible difference between the maximum height and the minimum height of the selected k people. Parameters: heights (list[int]): List of integers representing the heights of people. k (int): Number of people to be selected. Returns: int: Minimum possible difference. if k <= 1: return 0 heights.sort() min_diff = float(\'inf\') for i in range(len(heights) - k + 1): current_diff = heights[i + k - 1] - heights[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"You are given a string `s` and an array of strings `words`. You are tasked with finding all the starting indices of `words`\' concatenation in `s`. The concatenation must consist of each word in `words` exactly once and without any intervening characters. The order of words in the concatenation does not matter. Return all the starting indices sorted in ascending order.","solution":"def find_substring_indices(s, words): from collections import Counter if not s or not words: return [] word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count word_counter = Counter(words) result = [] for i in range(len(s) - total_length + 1): seen = {} for j in range(word_count): word = s[i + j * word_length: i + (j + 1) * word_length] if word in word_counter: seen[word] = seen.get(word, 0) + 1 if seen[word] > word_counter[word]: break else: break else: result.append(i) return sorted(result)"},{"question":"Suppose you have a string `s` containing only characters `\'a\'`, `\'b\'`, and `\'c\'`. The string is considered valid if all the following conditions are met: * The number of characters `\'a\'` in `s` is at most 2. * The number of characters `\'b\'` in `s` is at least 1. * The number of characters `\'c\'` in `s` is exactly 2. Write a function that returns `true` if the string `s` is valid according to the conditions described, otherwise return `false`.","solution":"def is_valid_string(s): Returns true if the string `s` is valid according to the given conditions. The conditions are: - The number of characters \'a\' in `s` is at most 2. - The number of characters \'b\' in `s` is at least 1. - The number of characters \'c\' in `s` is exactly 2. return s.count(\'a\') <= 2 and s.count(\'b\') >= 1 and s.count(\'c\') == 2"},{"question":"Write a function that takes an array of integers `nums` representing a circular track, where each index represents a position and `nums[i]` represents the distance to the next position. A car starts at position `0` and has a limited amount of fuel. Return the **maximum** number of distinct positions that can be visited starting from position `0` using the available fuel. Note that the car can choose to go either clockwise or counterclockwise and can revisit positions, but they should only be counted once.","solution":"def max_distinct_positions(nums, fuel): Returns the maximum number of distinct positions that can be visited starting from position 0 using the available fuel. n = len(nums) def visit_count(start, end, remaining_fuel, visited): pos = start while remaining_fuel >= nums[pos]: remaining_fuel -= nums[pos] pos = (pos + end + n) % n visited.add(pos) if pos == start: break return visited visited_from_start = visit_count(0, 1, fuel, {0}) visited_from_end = visit_count(0, -1, fuel, {0}) return max(len(visited_from_start), len(visited_from_end))"},{"question":"You are given a **0-indexed** array of positive integers `nums` where `nums[i]` represents the number of apples in the `ith` basket. You want to eat exactly `k` apples, and you can choose to either eat all the apples from a basket or skip it entirely. Return the **minimum number** of baskets you need to eat from to get exactly `k` apples.","solution":"def min_baskets(nums, k): Returns the minimum number of baskets needed to eat exactly k apples. Parameters: nums (list): List of integers representing the number of apples in each basket. k (int): The number of apples to eat. Returns: int: Minimum number of baskets needed to eat exactly k apples. basket_count = 0 nums.sort(reverse=True) for apples in nums: if k <= 0: break if apples <= k: k -= apples basket_count += 1 return basket_count if k == 0 else -1"},{"question":"You are given an integer array `arr` that represents the heights of buildings along a street, where `arr[i]` is the height of the `i-th` building. Each building receives sunlight from the left (i.e., from the horizon). A building receives sunlight if and only if it is taller than all the buildings to its left. Return _the number of buildings that receive sunlight_.","solution":"def count_buildings_receiving_sunlight(arr): Returns the number of buildings that receive sunlight. A building receives sunlight if and only if it is taller than all the buildings to its left. Parameters: arr (list of int): List of building heights. Returns: int: Number of buildings that receive sunlight. if not arr: return 0 count = 1 # The first building always receives sunlight max_height = arr[0] for height in arr[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to determine whether the binary tree is a complete binary tree. A binary tree is a complete binary tree if every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Return `true` if the binary tree is complete, otherwise return `false`.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_complete_binary_tree(root): Determines whether a binary tree is a complete binary tree. if not root: return True queue = deque([root]) end = False while queue: current = queue.popleft() if current: if end: return False queue.append(current.left) queue.append(current.right) else: end = True return True"},{"question":"Write a function to determine if a string `t1` is an anagram of another string `t2` after removing exactly one character from `t2`. An **anagram** is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. * For example, if `t1 = \\"listen\\"` and `t2 = \\"silentb\\"`, you can remove the character `\'b\'` from `t2` to get an anagram of `t1`. * If `t1 = \\"listen\\"` and `t2 = \\"litsen\\"`, then no character removal from `t2` will yield an anagram of `t1`. Return `true` if `t1` can be formed from `t2` by removing exactly one character from `t2`, and `false` otherwise.","solution":"def is_one_char_removed_anagram(t1, t2): Determines if t1 is an anagram of t2 after removing exactly one character from t2. if len(t1) + 1 != len(t2): return False for i in range(len(t2)): modified_t2 = t2[:i] + t2[i+1:] if sorted(modified_t2) == sorted(t1): return True return False"},{"question":"You are given a string `s` representing a sequence of moves of a robot in a 2D grid. This grid is initially centered at the origin (0, 0). The robot can move up, down, left, or right represented by the characters \'U\', \'D\', \'L\', and \'R\' respectively. Your task is to determine if there exists a circle in the sequence of moves such that the robot returns to the origin at the end of the sequence. Return `True` if it does, and `False` otherwise.","solution":"def judge_circle(s): Determine if the robot returns to the origin after a sequence of moves in a 2D grid. Parameters: s (str): A string representing the sequence of moves (\'U\', \'D\', \'L\', \'R\'). Returns: bool: True if the sequence of moves returns the robot to the origin, False otherwise. x, y = 0, 0 for move in s: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"You are given a `2D grid` of size `m x n` which represents a map of only `land` and `water` cells. Cells are represented as `1` (land) or `0` (water). A **lake** is a maximal 4-directionally (horizontal or vertical) connected group of `water` cells. Return _the size of the largest lake in the grid_.","solution":"def largest_lake(grid): Returns the size of the largest lake (group of connected water cells) in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return 0 grid[x][y] = -1 # Mark as visited size = 1 size += dfs(x + 1, y) # down size += dfs(x - 1, y) # up size += dfs(x, y + 1) # right size += dfs(x, y - 1) # left return size largest = 0 for i in range(m): for j in range(n): if grid[i][j] == 0: largest = max(largest, dfs(i, j)) return largest"},{"question":"You are given a matrix `mat` of size `m x n` with initial values set to 0. You are also provided an array of operations `ops`, where each operation is represented as a tuple of two integers `(a, b)`. This operation increments every element in the submatrix that ranges from the top-left corner `(0, 0)` to `(a-1, b-1)` by 1. Return the number of maximum integers in the matrix after performing all the operations.","solution":"def maxCount(m, n, ops): Return the number of maximum integers in the matrix after performing all the operations. :param int m: number of rows in the matrix :param int n: number of columns in the matrix :param List[Tuple[int, int]] ops: list of operations :return int: number of maximum integers in the matrix if not ops: return m * n min_a = min(op[0] for op in ops) min_b = min(op[1] for op in ops) return min_a * min_b"},{"question":"You are given a list of integers `nums`. You are allowed to perform the following operation on the list any number of times: * **Operation**: Pick any two adjacent elements in the list and swap them if the left element is greater than the right. Return _the **minimum** number of operations required to sort the list in **non-decreasing** order_. For example, given the list `[3, 2, 1]`, the minimum number of operations required to sort it is `3`.","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations required to sort the list in non-decreasing order. Operation: Pick any two adjacent elements in the list and swap them if the left element is greater than the right. n = len(nums) result = 0 # Bubble Sort Algorithm, counting swaps for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] result += 1 return result"},{"question":"Given a **0-indexed** 2D integer array `matrix` of size `m x n` and an **integer** `target`, find whether `target` exists in `matrix`. This matrix has the following properties: * Integers in each row are sorted in ascending order from left to right. * Integers in each column are sorted in ascending order from top to bottom. Return `true` if `target` is found in the matrix and `false` otherwise.","solution":"def search_matrix(matrix, target): Searches for the target in the matrix. The matrix has properties: each row is sorted in ascending order, each column is sorted in ascending order. :param matrix: 2D list of integers :param target: integer :return: boolean indicating if target is found in matrix if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an array of integers `height` representing the height of students in a line. Each element `height[i]` represents the height of the `i-th` student in the line. Due to a new school policy, the students need to be rearranged such that the highest is at the front and the shortest is at the back. Your task is to return the minimum number of swaps required to achieve this arrangement. A swap operation consists of swapping the positions of any two students. For example, given the array `[5, 3, 1, 2, 4]`, the minimum number of swaps required to rearrange the students such that `[1, 2, 3, 4, 5]` is `4`.","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to rearrange the students such that they are in increasing order of height. n = len(arr) arrpos = [*enumerate(arr)] # Sort the array by array element values to get the right position for each element arrpos.sort(key=lambda it: it[1]) # To keep track of visited elements visited = [False] * n result = 0 for i in range(n): # already visited or already in the correct position if visited[i] or arrpos[i][0] == i: continue # Number of nodes in this cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][0] cycle_size += 1 # Update result by adding the number of swaps needed for this cycle if cycle_size > 0: result += (cycle_size - 1) return result"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n-1` and a list of edges where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. A node is considered a **critical node** if removing it along with its associated edges \\"disconnects\\" the graph (i.e., the graph is no longer fully connected). Your task is to determine the set of **critical nodes** in the graph. Return _an array_ of all such nodes in **ascending order**. The input graph may not be initially connected, and nodes without any edges should not be included in the output.","solution":"def find_critical_nodes(n, edges): from collections import defaultdict # Helper function to perform DFS def dfs(node, discovery, low, parent, time, graph, visited, articulation_points): visited[node] = True discovery[node] = low[node] = time[0] time[0] += 1 child_count = 0 is_articulation = False for neighbor in graph[node]: if not visited[neighbor]: parent[neighbor] = node child_count += 1 dfs(neighbor, discovery, low, parent, time, graph, visited, articulation_points) low[node] = min(low[node], low[neighbor]) if parent[node] is None and child_count > 1: is_articulation = True if parent[node] is not None and low[neighbor] >= discovery[node]: is_articulation = True elif neighbor != parent[node]: low[node] = min(low[node], discovery[neighbor]) if is_articulation: articulation_points.add(node) graph = defaultdict(list) for edge in edges: graph[edge[0]].append(edge[1]) graph[edge[1]].append(edge[0]) discovery = [-1] * n low = [-1] * n parent = [None] * n time = [0] visited = [False] * n articulation_points = set() for i in range(n): if not visited[i] and graph[i]: dfs(i, discovery, low, parent, time, graph, visited, articulation_points) return sorted(articulation_points)"},{"question":"You are given a **0-indexed** integer array `nums` of size `n`, where each element represents the number of candies in a jar. You need to transfer candies between jars to make sure each jar has an **even** number of candies. For every transfer, you can choose any two jars and move one candy from one jar to the other. Determine the _minimum number of transfers_ needed to achieve your goal. If it\'s not possible, return `-1`.","solution":"def min_transfers_to_even_candies(nums): Returns the minimum number of transfers needed to make each element in `nums` even. If it\'s not possible, returns -1. odd_count = sum(1 for num in nums if num % 2 != 0) # If the number of odd elements is odd, it\'s impossible to make all elements even if odd_count % 2 != 0: return -1 # Each pair of odd numbers requires one transfer to make both even return odd_count // 2"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a straight line. An ocean is to the right of these buildings, and your task is to determine which buildings can see the ocean. A building can see the ocean if all the buildings to its right are shorter than it. Return _a list of indices of the buildings that can see the ocean, sorted in increasing order._ **Example:** - **Input:** `heights = [4, 2, 3, 1, 1]` - **Output:** `[0, 2, 4]` - **Explanation:** Buildings at indices 0, 2, and 4 can see the ocean because there are no taller buildings to their right. **Notes:** - The list of buildings is guaranteed to have at least one building.","solution":"def buildings_with_ocean_view(heights): Returns indices of buildings that can see the ocean. n = len(heights) max_height = 0 result = [] for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"Given a 2D integer matrix, write a function `void rotate(int[][] matrix)` to rotate the matrix 90 degrees clockwise in place. The rotation should be done in place, meaning you have to modify the input 2D matrix directly. **Do not** allocate another 2D matrix and do the rotation. For example, if the matrix is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The rotated matrix should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate(matrix): Rotates the given 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Given a binary tree, return the sum of values of its deepest leaves. The binary tree is defined using the `TreeNode` structure, where each node has an integer value, a left child, and a right child. You need to traverse the tree and compute the sum of all nodes located at the deepest level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given a string `s`, return the length of the largest substring that can be rearranged to form a palindrome. A palindrome is a string that reads the same forward and backward. For example, for the string \\"aabbcc\\", the largest substring that can be rearranged to form a palindrome is \\"aabbcc\\" of length 6, while for the string \\"abc\\", the largest substring that can be rearranged to form a palindrome is \\"a\\", \\"b\\", or \\"c\\" of length 1. The string may contain both uppercase and lowercase letters and has at least one character.","solution":"def longest_palindrome_substring_length(s): Returns the length of the largest substring that can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"Design a class that simulates a simple text editor which supports the following operations: - `addText(String text)` - adds `text` to the end of the document. - `deleteText(int k)` - deletes the last `k` characters of the document. - `countWords()` - counts the total number of words in the document. Words are separated by space, and it is guaranteed that there are no leading or trailing spaces and no multiple spaces between words. Implement the `SimpleTextEditor` class: - `SimpleTextEditor()` Initializes the `SimpleTextEditor` object. - `void addText(String text)` adds `text` to the document. - `void deleteText(int k)` deletes the last `k` characters from the document. - `int countWords()` returns the total number of words in the current document.","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" def addText(self, text): self.text += text def deleteText(self, k): self.text = self.text[:-k] def countWords(self): if not self.text: return 0 return len(self.text.split())"},{"question":"You are given an integer `n` representing the total number of nodes in an undirected graph, numbered from `0` to `n-1`. An array `edges` is also given, where each `edges[i] = [a, b]` represents an undirected edge between nodes `a` and `b`. Design an algorithm to determine whether the graph is a valid tree. A valid tree meets the following conditions: * The graph is fully connected, meaning there is a path between any pair of nodes. * The graph contains no cycles. Return `true` if the graph is a valid tree, otherwise return `false`.","solution":"def valid_tree(n, edges): Determines if the given graph is a valid tree. :param n: int, the number of nodes :param edges: List of List of int, the edges of the graph :return: bool, True if the graph is a valid tree, False otherwise # A tree must have exactly n-1 edges if len(edges) != n - 1: return False from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # BFS or DFS to ensure the graph is fully connected and acyclic visited = set() def bfs(start): q = deque([start]) while q: node = q.popleft() for neighbor in adj_list[node]: if neighbor in visited: continue visited.add(neighbor) q.append(neighbor) visited.add(0) bfs(0) # Graph is fully connected if we visited all nodes return len(visited) == n"},{"question":"You are given a string `s` representing an arithmetic expression containing integers and the operators `+`, `-`, `*`, `/`. The expression has no parentheses and is guaranteed to be valid. Calculate the result of the expression following the standard order of operations (PEMDAS/BODMAS rules: multiplication and division have higher precedence than addition and subtraction). Assume integer division truncates toward zero. Write a function that takes the string `s` and returns the result of the expression. (Note: You may assume that the input string contains no extra spaces, and the integers are non-negative.)","solution":"def calculate(s): Evaluates the arithmetic expression represented by the string `s` following the standard order of operations and returns the result as an integer. def helper(it): num = 0 stack = [] sign = \'+\' while it < len(s): if s[it].isdigit(): num = num * 10 + int(s[it]) if s[it] in \'+-*/\' or it == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack[-1] = stack[-1] * num elif sign == \'/\': # Integer division in Python 3 stack[-1] = int(stack[-1] / num) sign = s[it] num = 0 it += 1 return sum(stack) return helper(0)"},{"question":"You are given a 2D grid `grid`, where `grid[i][j]` represents the elevation of a cell. Water can flow from a cell to another one if and only if the elevation of the latter cell is equal to or lower than the former one. The grid is surrounded by an ocean on all four sides, and the elevation outside the grid is considered to be 0. You need to determine the number of cells from which water can flow to at least one of the border cells. Return _the number of such cells_.","solution":"def numCellsWaterFlowToBorder(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def bfs(starts): queue = starts[:] reachable = set(starts) while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in reachable and grid[nx][ny] <= grid[x][y]: queue.append((nx, ny)) reachable.add((nx, ny)) return reachable border_cells = [(i, 0) for i in range(rows)] + [(i, cols - 1) for i in range(rows)] + [(0, j) for j in range(cols)] + [(rows - 1, j) for j in range(cols)] reachable_from_border = bfs(border_cells) return len(reachable_from_border) # Example run grid = [[1, 2, 2, 3], [3, 2, 3, 4], [2, 4, 5, 5], [6, 7, 1, 4]] numCellsWaterFlowToBorder(grid) # Expected: 15 out of 16 cells should be reachable"},{"question":"You are given an array of integers `arr` where each integer uniquely identifies some object. You are also provided with a 2D list `swaps` where each `swaps[i] = [a, b]` represents a direct bi-directional swap allowed between objects `a` and `b`. Return `true` if it is possible to sort the array `arr` in non-decreasing order by performing a series of swaps from the given list. Otherwise, return `false`. Each object can be swapped any number of times as long as the swap is allowed in the `swaps` list.","solution":"def can_sort_by_swaps(arr, swaps): Determine if it\'s possible to sort the array in non-decreasing order by performing allowed swaps. n = len(arr) # Create a graph from swaps graph = {i: set() for i in range(n)} for a, b in swaps: graph[a].add(b) graph[b].add(a) # Find all connected components visited = [False] * n def dfs(node, component): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True component.append(current) for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) connected_components = [] for i in range(n): if not visited[i]: component = [] dfs(i, component) connected_components.append(component) # Check if we can sort each connected component sorted_arr = sorted(arr) for component in connected_components: indices = sorted(component) values = sorted([arr[i] for i in component]) for idx, val in zip(indices, values): if sorted_arr[idx] != val: return False return True"},{"question":"Given a list of non-negative integers `nums`, you are tasked with arranging the numbers such that they form the largest possible number. The result should be returned as a string. To form the largest number, you will need to implement a custom sorting mechanism. Return the final largest number in string format.","solution":"from functools import cmp_to_key def largestNumber(nums): Arranges the numbers in the list to form the largest possible number. Args: nums (list of int): List of non-negative integers. Returns: str: The largest possible number as a string. def compare(x, y): # Custom comparator to decide the order if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert each number to string nums_str = list(map(str, nums)) # Sort the string numbers based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate the sorted numbers to form the largest number largest_num = \'\'.join(nums_str) # Edge case: if the largest number is the string of zeros, return \'0\' if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are tasked with building a data structure that can efficiently represent and query intervals. Implement the `IntervalSet` class: * `void addInterval(int start, int end)`: Adds an interval `[start, end]` to the data structure. It is guaranteed that `0 <= start <= end <= 10^9`. If the interval overlaps with any existing intervals, they should be merged. * `bool queryInterval(int start, int end)`: Returns `true` if every point in the interval `[start, end]` is covered by at least one interval in the data structure, otherwise returns `false`. The intervals are inclusive, meaning that the endpoints are part of the interval.","solution":"class IntervalSet: def __init__(self): self.intervals = [] def addInterval(self, start, end): Adds an interval [start, end] to the data structure. If the interval overlaps with any existing intervals, they should be merged. new_interval = [start, end] merged_intervals = [] i = 0 # Add all intervals before the new interval while i < len(self.intervals) and self.intervals[i][1] < start: merged_intervals.append(self.intervals[i]) i += 1 # Merge overlapping intervals while i < len(self.intervals) and self.intervals[i][0] <= end: new_interval[0] = min(new_interval[0], self.intervals[i][0]) new_interval[1] = max(new_interval[1], self.intervals[i][1]) i += 1 merged_intervals.append(new_interval) # Add all intervals after the new interval while i < len(self.intervals): merged_intervals.append(self.intervals[i]) i += 1 self.intervals = merged_intervals def queryInterval(self, start, end): Returns True if every point in the interval [start, end] is covered by at least one interval in the data structure, otherwise returns False. for interval in self.intervals: if interval[0] <= start and end <= interval[1]: return True return False"},{"question":"You are given a **0-indexed** binary string `s` that consists of `\'0\'` and `\'1\'` characters only. Your task is to make the string alternately consist of the characters `\'0\'` and `\'1\'`. In other words, the string should look like `\\"010101...\\"` or `\\"101010...\\"`. To achieve this, you may perform the following operation any number of times: select any `i-th` character from the string and replace it with `\'0\'` or `\'1\'`. Return _the **minimum** number of operations needed to make the string alternate_.","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations needed to make the binary string alternate. n = len(s) pattern1 = \'\'.join(\'0\' if i % 2 == 0 else \'1\' for i in range(n)) pattern2 = \'\'.join(\'1\' if i % 2 == 0 else \'0\' for i in range(n)) diff1 = sum(1 for i in range(n) if s[i] != pattern1[i]) diff2 = sum(1 for i in range(n) if s[i] != pattern2[i]) return min(diff1, diff2)"},{"question":"You are given an array of integers, `arr`, and a positive integer `d`. Each integer in the array represents the height of a tree. You are tasked with determining the maximum number of trees that can be cut down while maintaining a visibility range `d`. Specifically, the visibility range `d` means that after cutting down any tree at index `i`, all trees within `d` units of index `i` (both to the left and right) must remain standing. Return _the maximum number of trees that can be cut down_ from the array `arr` while maintaining the visibility range `d`. If no trees can be cut down under the given constraints, return 0.","solution":"def max_trees_cut(arr, d): Calculates the maximum number of trees that can be cut down while keeping a visibility range such that no two cut trees are within `d` indices of each other. Parameters: arr (list of int): List of tree heights (not used in calculation). d (int): The visibility range. Returns: int: The maximum number of trees that can be cut down. if d <= 0: return 0 n = len(arr) i = 0 count = 0 while i < n: # Cutting current tree count += 1 # Move i to next potential tree to cut which is outside the visibility range i += d + 1 return count"},{"question":"You are given an array of positive integers `heights` where `heights[i]` represents the height of the `i`-th person. You are also given a positive integer `limit` representing the maximum combined height that two people can have while being paired together. Return the minimum number of pairs required such that each pair\'s combined height does not exceed the `limit`. Each person can only be paired once. Note that there can be people who are not paired with anyone.","solution":"def min_pairs(heights, limit): Returns the minimum number of pairs required such that no pair has a combined height exceeding the limit. heights.sort() left = 0 right = len(heights) - 1 pairs = 0 while left <= right: if heights[left] + heights[right] <= limit: left += 1 right -= 1 pairs += 1 return pairs"},{"question":"Given a binary tree, implement a function that returns the **leftmost** value in the last row of the tree. You can assume that the tree is non-empty and all the values are unique. **Note**: The last row of the tree is defined as the row farthest away from the root node. If there are multiple nodes in the last row, the leftmost node refers to the node with the smallest index position when the row is viewed from left to right. Return _the value of the leftmost node in the last row of the tree_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root: TreeNode) -> int: Finds the leftmost value in the last row of the binary tree. queue = deque([root]) current = None while queue: current = queue.popleft() # Push the right child first if current.right: queue.append(current.right) # Then push the left child if current.left: queue.append(current.left) return current.val"},{"question":"You are given a string `s` of length `n` and an integer `k`. Your task is to rearrange the characters of the string such that no two adjacent characters are the same. If it is not possible to rearrange the string to meet this condition, return an empty string `\\"\\"`. If there are multiple valid arrangements, return any of them. The rearrangement should be performed in such a way that each character appears in the resultant string with the same frequency as in the original string, and no two adjacent characters are the same.","solution":"from collections import Counter import heapq def reorganize_string(s, k): Reorganize a string such that no two adjacent characters are the same. Args: s (str): The input string. k (int): An unused parameter relevant for certain problem contexts, though it doesn\'t directly affect the algorithm here for reorganization. Returns: str: A reorganized string, or an empty string if reorganization is not possible. # Get the frequency of each character in the string char_count = Counter(s) # Create a max heap based on the frequency of characters max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) # Previous character holder (initially empty) prev_count, prev_char = 0, \'\' # Placeholder for the result result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 prev_char = char # If the length of the result matches the length of the input string, return result, else \\"\\" return \'\'.join(result) if len(result) == len(s) else \'\'"},{"question":"You are given a list of `n` unique integers where the list is in strictly increasing order and rotated at an unknown pivot index. For example, the list `[4, 5, 6, 7, 0, 1, 2]` is rotated at pivot index 4. Write a function to find the pivot index (the index of the smallest element). The pivot index is guaranteed to be present in the list. Return _the pivot index_.","solution":"def find_pivot_index(nums): Returns the index of the smallest element, which corresponds to the pivot index in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return left"},{"question":"You are given a list of integers `cost` where `cost[i]` is the cost of `i`-th step on a staircase. Once you pay the cost, you can either climb one or two steps. You need to find the minimum cost to reach the top of the floor. The starting position can either be from step `0` or step `1`. Return the minimum cost to reach the top of the floor. Example: - Input: cost = [10, 15, 20] - Output: 15 Explanation: You will start at step 1, pay 15, and then step to the top. The total cost is 15.","solution":"def minCostClimbingStairs(cost): Returns the minimum cost to reach the top of the floor from the given cost array. n = len(cost) if n == 0: return 0 if n == 1: return cost[0] # Initialize the dp array where dp[i] represents the minimum cost to reach the i-th step dp = [0] * (n+1) dp[0] = 0 dp[1] = 0 # since we can either start at step 0 or step 1 without any cost for i in range(2, n+1): dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) return dp[n]"},{"question":"You are given two integer arrays, `preorder` and `inorder`, where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree. Construct the binary tree and return its root. Implement the function `TreeNode buildTree(int[] preorder, int[] inorder)`, where `TreeNode` is a class that holds the tree structure with fields `int val`, `TreeNode left`, and `TreeNode right`. Note: You can assume that the tree does not contain duplicate elements.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): Given preorder and inorder traversal of a tree, construct the binary tree. if not preorder or not inorder: return None # Find the root from the preorder traversal (first element) root_val = preorder[0] root = TreeNode(root_val) # Find the index of the root in the inorder traversal mid = inorder.index(root_val) # Recursively build the left and right subtree root.left = buildTree(preorder[1:mid+1], inorder[:mid]) root.right = buildTree(preorder[mid+1:], inorder[mid+1:]) return root"},{"question":"You are given a list of `n` integers representing an elevation map where the width of each bar is 1. Suppose each integer represents the height of a bar at an index position along the list. The elevation map describes a series of units of water trapped after rainfall at various positions. You need to calculate the total amount of trapped water. Return the total amount of water that can be trapped.","solution":"def trap(height): Calculate the total amount of water that can be trapped. :param height: List[int] List representing the height of bars in elevation map :return: int Total units of water that can be trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(height[i], left_max[i - 1]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(height[i], right_max[i + 1]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"A connected graph is considered a **tree** if it has no cycles and exactly `n-1` edges where `n` is the number of nodes in the graph. You are given `n` nodes labeled from `0` to `n-1` and an array of edges where each edge is a pair `[ai, bi]` indicating that there is an edge between nodes `ai` and `bi` in the graph. Determine if the given graph is a tree. Return `true` if it is a tree, otherwise return `false`.","solution":"def is_tree(n, edges): Determine if the given graph is a tree. Parameters: n (int): Number of nodes. edges (List[List[int]]): List of edges. Returns: bool: True if the graph is a tree, False otherwise. if len(edges) != n - 1: return False parent = list(range(n)) # Helper function to find the root parent of a node def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] # Helper function to union two nodes def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX else: return False return True for a, b in edges: if not union(a, b): return False return True"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to find the sum of the values of all the nodes that are at an even level in the tree. The root of the tree is considered to be at level 0. Return the total sum.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_even_level_nodes(root): Returns the sum of all nodes values at even levels in a binary tree. if not root: return 0 level = 0 queue = [(root, level)] total_sum = 0 while queue: current, level = queue.pop(0) if level % 2 == 0: total_sum += current.value if current.left is not None: queue.append((current.left, level + 1)) if current.right is not None: queue.append((current.right, level + 1)) return total_sum"},{"question":"A palindrome is a string that reads the same backward as forward. Given a string `s`, you need to determine the length of the longest subsequence that is a palindrome. You should define a class `PalindromeSubsequence` that supports the following methods: - `PalindromeSubsequence(String s)` Constructor that initializes the input string `s`. - `int longestPalindromeSubseq()` Returns the length of the longest palindromic subsequence within the string `s`.","solution":"class PalindromeSubsequence: def __init__(self, s: str): self.s = s def longestPalindromeSubseq(self) -> int: n = len(self.s) if n == 0: return 0 # dp[i][j] will represent the length of the longest # palindromic subsequence in s[i..j] dp = [[0] * n for _ in range(n)] # single letters are palindromic of length 1 for i in range(n): dp[i][i] = 1 # build the dp table for length in range(2, n + 1): # length of the subsequence for i in range(n - length + 1): # start index of the subsequence j = i + length - 1 # end index of the subsequence if self.s[i] == self.s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to return _a 2D array_ containing all pairs of distinct indices `(i, j)` such that `nums[i] + nums[j] == target`. Each pair `(i, j)` should be listed in ascending order of `i`, and within each pair, the values of `i` should be less than `j`. If no such pairs exist, return an empty array.","solution":"def two_sum_indices(nums, target): Returns a 2D array containing all pairs of distinct indices (i, j) such that nums[i] + nums[j] == target. Each pair (i, j) is such that i < j and pairs are listed in ascending order of i. :param nums: List[int] - List of integers to evaluate :param target: int - Target sum for the pairs :return: List[List[int]] - 2D array of pairs of indices that sum to target result = [] n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target: result.append([i, j]) return result"},{"question":"You are provided with a **0-indexed** integer array `nums` containing `n` elements. Your task is to determine if there exists a **non-empty** subsequence of `nums` such that the sum of the elements in this subsequence is an **even** number. Return `true` if such a subsequence exists, and `false` otherwise. A **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def has_even_sum_subsequence(nums): Determines if there exists a non-empty subsequence of nums that has an even sum. :param nums: List[int] - input list of integers :return: bool - True if such a subsequence exists, False otherwise # If there\'s at least one even number, we can form an even-sum subsequence if any(num % 2 == 0 for num in nums): return True # If there\'s no even number but there are at least two odd numbers, # their sum will be even. odd_count = sum(1 for num in nums if num % 2 != 0) if odd_count >= 2: return True # If there\'s only one or zero elements in the array or we cannot form an even sum return False"},{"question":"Given an array of integers `heights` representing the height of buildings in a row, identify the largest rectangular area that can be formed within these buildings. The rectangle must be formed by consecutive buildings and the height of the rectangle is defined by the shortest building in that sequence. Return _the **maximum** rectangular area_ that can be formed.","solution":"def largest_rectangle_area(heights): Given an array of integers `heights`, identify the largest rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a 2D matrix `matrix` of integers where each row is sorted in ascending order and each column is sorted in ascending order, determine if a given target integer `target` exists in the matrix. Return `true` if the target value is found in the matrix, otherwise, return `false`. Write an efficient algorithm that minimizes the number of comparisons.","solution":"def search_matrix(matrix, target): Determine if target exists in a 2D matrix. Each row and column are sorted in ascending order. :param matrix: List[List[int]] :param target: int :return: bool if not matrix or not matrix[0]: return False # Start searching from the top-right corner of the matrix row, col = 0, len(matrix[0]) - 1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Implement a class `MedianFinder` that supports the following functionalities: * `MedianFinder()` - Initializes the object with an empty data structure. * `void addNum(int num)` - Adds an integer `num` to the data structure. * `double findMedian()` - Returns the median of all elements so far. The median is the middle number in an ordered list of numbers. If the size of the list is even, the median is the average of the two middle numbers. The algorithm should perform the find median operation in O(1) time and the add number operation in O(log n) time.","solution":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder object. self.low = [] # Max-heap to store the lower half of the numbers self.high = [] # Min-heap to store the upper half of the numbers def addNum(self, num: int): Adds an integer num to the data structure. # Add to max-heap heapq.heappush(self.low, -num) # Balance the heaps if self.low and self.high and -self.low[0] > self.high[0]: val = -heapq.heappop(self.low) heapq.heappush(self.high, val) # Ensure size property between heaps if len(self.low) > len(self.high) + 1: val = -heapq.heappop(self.low) heapq.heappush(self.high, val) elif len(self.high) > len(self.low): val = heapq.heappop(self.high) heapq.heappush(self.low, -val) def findMedian(self) -> float: Returns the median of all elements so far. if len(self.low) == len(self.high): return (-self.low[0] + self.high[0]) / 2.0 else: return -self.low[0]"},{"question":"You are given an array `books` where `books[i] = [starti, endi]` represents the start and end times of the `ith` book reading event. Two book reading events conflict if they overlap, i.e., one of their time intervals lies within the other. Determine the maximum number of non-conflicting book reading events that can be attended. Return _the maximum number of non-conflicting book reading events_.","solution":"def max_non_conflicting_events(books): Determines the maximum number of non-conflicting book reading events. Args: books (List[List[int]]): List of events where each event is a list [starti, endi]. Returns: int: Maximum number of non-conflicting book reading events. if not books: return 0 # Step 1: Sort the events by their end time books.sort(key=lambda x: x[1]) # Step 2: Use a greedy algorithm to select the maximum number of non-overlapping events max_events = 0 last_end_time = float(\'-inf\') for start, end in books: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"**Question 4**: Implement a class `TextProcessor` that processes input strings and provides the lexicographically smallest permutation of characters for each word. The words in the string are separated by spaces. * `TextProcessor()` initializes the TextProcessor object. * `String process(String inputText)` takes a single string `inputText` and returns a new string where each word\'s characters are sorted in lexicographical order. Words are defined as sequences of characters separated by spaces. The positions of spaces in the input string should be preserved in the output string. For example, given the input string `\\"bat apple zebra car\\"`, the output should be `\\"abt aelpp aberz acr\\"`. Note that punctuation marks and special characters should be treated as part of words. For instance, given the input string `\\"hello! world\\"`, the output should be `\\"!ehllo dlrow\\"`.","solution":"class TextProcessor: def __init__(self): pass def process(self, inputText): Returns a new string where each word\'s characters are sorted in lexicographical order. Words are defined as sequences of characters separated by spaces. Parameters: inputText (str): the input string to process Returns: str: the processed string with each word\'s characters sorted def sort_word(word): return \'\'.join(sorted(word)) return \' \'.join(sort_word(word) for word in inputText.split(\' \'))"},{"question":"You are given a list of `n` tasks that need to be completed as an array `tasks` where `tasks[i]` represents the time required to complete the `ith` task. Each task can be assigned to one of two workers in such a way that each worker works on a different subset of tasks, creating two subsets of tasks, one for each worker. The goal is to assign the tasks to the two workers in a way that minimizes the difference in the total time each worker spends completing their tasks. Return the minimum possible difference in total time spent between the two workers.","solution":"def min_difference_partition(tasks): total_time = sum(tasks) n = len(tasks) dp = [0] * (total_time // 2 + 1) for task in tasks: for j in range(total_time // 2, task - 1, -1): dp[j] = max(dp[j], dp[j - task] + task) worker1_time = dp[total_time // 2] worker2_time = total_time - worker1_time return abs(worker1_time - worker2_time)"},{"question":"You are given an array of integers `nums` representing the score of students in an exam and an integer `k`. Your task is to find the top `k` highest and the bottom `k` lowest scores. Return two lists: one containing the top `k` scores in descending order and another containing the bottom `k` scores in ascending order. If there are fewer than `k` scores available at the top or bottom, the list should contain all the available scores in the respective order. For example, given the array `nums = [50, 20, 70, 10, 60, 30, 40, 90]` and `k = 3`, the top `k` highest scores would be `[90, 70, 60]` and the bottom `k` lowest scores would be `[10, 20, 30]`. Return the lists as `[[90, 70, 60], [10, 20, 30]]`.","solution":"def top_bottom_k_scores(nums, k): Returns two lists: one containing the top `k` scores in descending order and another containing the bottom `k` scores in ascending order. # Sort the array to get both the highest and lowest scores nums_sorted = sorted(nums) # Get the bottom k scores (ascending order) bottom_k = nums_sorted[:k] # Get the top k scores (descending order) top_k = sorted(nums_sorted[-k:], reverse=True) return [top_k, bottom_k]"},{"question":"You are given an `m x n` binary matrix `grid` in which `0` represents an empty cell and `1` represents an obstacle. You are also given an integer `k` which represents the maximum number of obstacles you can remove. Return _the shortest path from the top-left cell `(0, 0)` to the bottom-right cell `(m - 1, n - 1)` that you can achieve by removing at most `k` obstacles_. If there is no valid path, return `-1`. You can move up, down, left, or right from a cell.","solution":"from collections import deque def shortestPath(grid, k): Return the shortest path from top-left to bottom-right by removing at most k obstacles. m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0, k)]) visited = {(0, 0, k)} while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_k = remaining_k - grid[nx][ny] if new_k >= 0 and (nx, ny, new_k) not in visited: if (nx, ny) == (m - 1, n - 1): return steps + 1 queue.append((nx, ny, steps + 1, new_k)) visited.add((nx, ny, new_k)) return -1"},{"question":"You are given a list of integers `nums` of size `n`, where `n` is always even. Your task is to partition `nums` into two subsets `A` and `B` such that *the sum of the elements in `A` and the sum of the elements in `B` are equal*. Return _the two subsets_ `A` _and_ `B`. For example: 1. If the input is `[1, 5, 11, 5]`, one possible output is `([1, 5, 5], [11])`. 2. If it is `[1, 2, 3, 4, 6]`, the output should be `([1, 6], [2, 3, 4])`. If there is no possible partition, return an empty list for both subsets.","solution":"def partition_equal_sum(nums): def can_partition(nums, n, subset1, total_subset1, total_sum): if total_subset1 * 2 == total_sum: return True if total_subset1 * 2 > total_sum or n == 0: return False # Don\'t include the current item in subset1 if can_partition(nums, n-1, subset1, total_subset1, total_sum): return True # Include the current item in subset1 subset1.append(nums[n-1]) if can_partition(nums, n-1, subset1, total_subset1 + nums[n-1], total_sum): return True subset1.pop() return False total_sum = sum(nums) if total_sum % 2 != 0: return ([], []) subset1 = [] if not can_partition(nums, len(nums), subset1, 0, total_sum): return ([], []) subset2 = nums[:] for item in subset1: subset2.remove(item) return (subset1, subset2)"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum number of unique integers you can get from the array by removing exactly `k` elements.","solution":"def max_unique_integers(nums, k): Returns the maximum number of unique integers in the array after removing exactly k elements. from collections import Counter elem_counts = Counter(nums) current_unique_count = len(elem_counts) remove_counts = sorted(elem_counts.values()) for count in remove_counts: if k >= count: k -= count current_unique_count -= 1 else: break return current_unique_count"},{"question":"You are given a binary string `s` of length `n`. In one operation, you can remove any substring of length `k` that consists entirely of the character `\'0\'` or the character `\'1\'`. Each removal operation has a cost of `k`. Find the **minimum total cost** to remove all substrings such that no consecutive characters in the remaining string are the same. Return _the **minimum total cost**_ to achieve this. If it\'s not possible to achieve this condition, return `-1`. * For example, given the string `s = \\"000111\\"` and `k = 3`, you can perform the following operations: 1. Remove the substring `\\"000\\"` at a cost of `3`, resulting in `\\"111\\"`. 2. Remove the substring `\\"111\\"` at a cost of `3`, resulting in an empty string. The minimum total cost here is `3 + 3 = 6`.","solution":"def minimum_cost_to_remove_substrings(s, k): n = len(s) # Check if it\'s even possible to perform removals as required. if len(set(s)) <= 1 and n % k == 0: return (n // k) * k total_cost = 0 i = 0 while i < n: j = i while j < n and s[i] == s[j]: j += 1 length = j - i if length % k != 0: return -1 total_cost += (length // k) * k i = j return total_cost"},{"question":"Sam is playing a video game that involves navigating through a forest represented by a **0-indexed** 2D grid `forest`. Each cell in the grid can either be walkable territory `1` or an impassable obstacle `0`. Sam starts at the top-left corner of the forest, and his goal is to reach the bottom-right corner. From any cell, Sam can move to any of its four directly adjacent cells (up, down, left, or right), but cannot move diagonally. Given the forest grid, return _the minimum number of steps required for Sam to reach the bottom-right corner from the top-left corner._ If there is no valid path, return `-1`.","solution":"from collections import deque def min_steps(forest): Returns the minimum number of steps required for Sam to reach the bottom-right corner from the top-left corner, or -1 if there is no valid path. if not forest or not forest[0]: return -1 rows, cols = len(forest), len(forest[0]) if forest[0][0] == 0 or forest[rows-1][cols-1] == 0: return -1 # Directions for right, left, down, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and forest[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"You are given an integer array `ratings` of length `n`, where `ratings[i]` represents the rating of the `ith` team. You have to distribute tickets to the teams based on their ratings with the following constraints: - Each team must get at least one ticket. - Teams with higher ratings must receive more tickets than their immediate neighbors. Return _the **minimum** number of tickets required to distribute among the teams satisfying the above constraints_.","solution":"def minimum_tickets(ratings): n = len(ratings) if n == 0: return 0 tickets = [1] * n # Every team gets at least one ticket # Traverse from left to right to ensure right neighbor gets more tickets if higher rating for i in range(1, n): if ratings[i] > ratings[i - 1]: tickets[i] = tickets[i - 1] + 1 # Traverse from right to left to ensure left neighbor gets more tickets if higher rating for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: tickets[i] = max(tickets[i], tickets[i + 1] + 1) return sum(tickets)"},{"question":"You are given a binary tree where each node has an integer value. Write a function to convert this binary tree into its mirror image. The mirror image of a binary tree is a tree where the left and right children of all non-leaf nodes are swapped. Return the root of the mirrored tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Function signature def mirrorTree(root: TreeNode) -> TreeNode: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirrorTree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively call mirrorTree on the left and right children mirrorTree(root.left) mirrorTree(root.right) return root"},{"question":"Design a data structure that supports inserting new values, removing values, and retrieving the element with the current minimum value, all in constant time. Implement the `MinStack` class: * `MinStack()` Initializes the stack object. * `void push(val)` Pushes the integer `val` onto the stack. * `void pop()` Removes the element on the top of the stack. * `int top()` Gets the top element of the stack. * `int getMin()` Retrieves the minimum element in the stack. All methods should operate in `O(1)` time complexity.","solution":"class MinStack: def __init__(self): Initializes the stack object. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes the integer `val` onto the stack. self.stack.append(val) # Push the minimum value to the min_stack if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack. if self.stack: popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Gets the top element of the stack. if self.stack: return self.stack[-1] return None def getMin(self) -> int: Retrieves the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return None"},{"question":"Given a list of `positions` and an integer `d`, return the maximum minimum distance between any two positions, where `positions[i]` represents the position of the ith house on a straight line. You are required to place `d` houses such that the minimum distance between any two houses is as large as possible.","solution":"def canPlaceHouses(positions, d, min_dist): count = 1 last_pos = positions[0] for i in range(1, len(positions)): if positions[i] - last_pos >= min_dist: count += 1 last_pos = positions[i] if count == d: return True return False def maxMinDistance(positions, d): positions.sort() low = 1 high = positions[-1] - positions[0] while low <= high: mid = (low + high) // 2 if canPlaceHouses(positions, d, mid): low = mid + 1 else: high = mid - 1 return high"},{"question":"Given a string `s` and an integer `n`, you need to decode the string by shifting each letter backwards by `n` positions. The string `s` contains only lowercase letters and all shifts are cyclic within the alphabet (i.e., a shifted by 1 becomes z). Return _the decoded string_ after shifting all letters backwards by `n` positions.","solution":"def decode_string(s, n): Decodes the given string s by shifting each letter backwards by n positions. decoded_chars = [] for char in s: shifted_index = (ord(char) - ord(\'a\') - n) % 26 decoded_char = chr(ord(\'a\') + shifted_index) decoded_chars.append(decoded_char) return \'\'.join(decoded_chars)"},{"question":"You are given a linked list, each node of which contains an integer value and a pointer to the next node. Implement a function to reorder the list such that the nodes appear in alternating increasing and decreasing order. Specifically, the list should be rearranged in such a way that the first node is the smallest, the second is the largest, the third is the second smallest, the fourth is the second largest, and so on. The relative order of the nodes within these constraints should be preserved. Return the head of the newly reordered list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorders the list such that the nodes appear in alternating increasing and decreasing order. Args: head (ListNode): The head of the linked list. Returns: ListNode: The new head of the reordered list. if not head or not head.next: return head # Convert linked list to list lst = [] current = head while current: lst.append(current.val) current = current.next # Sort the list lst.sort() # Create two pointers i, j = 0, len(lst) - 1 new_head = ListNode(0) # Dummy node current = new_head while i <= j: current.next = ListNode(lst[i]) current = current.next i += 1 if i <= j: current.next = ListNode(lst[j]) current = current.next j -= 1 return new_head.next"},{"question":"You are given an array of non-negative integers `nums`. Each element in the array represents a point on the number line. A **centroid point** is a value that minimizes the sum of the distances to all other points in the array. In this problem, the distance is defined as the absolute difference between two points. Find and return the **centroid point** for the given array `nums`. If there are multiple centroid points, return the smallest one.","solution":"def find_centroid_point(nums): Returns the centroid point that minimizes the sum of the distances to all other points in the array. nums.sort() n = len(nums) # The optimal position is the median. if n % 2 == 1: return nums[n // 2] else: return min(nums[n // 2 - 1], nums[n // 2])"},{"question":"Given a string `s`, return the length of the longest substring that contains at most 2 distinct characters. You may assume that the given string contains only lowercase English letters. If the string is empty, return 0. The function should efficiently handle long strings and aim for an O(n) time complexity solution.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. :param s: Input string containing only lowercase English letters. :return: Length of the longest substring that contains at most 2 distinct characters. if not s: return 0 start = 0 max_length = 0 char_map = {} for end in range(len(s)): char = s[end] char_map[char] = char_map.get(char, 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a set of `n` envelopes, each with a width and a height. One envelope can fit into another if and only if both the width and height of one envelope are greater than the width and height of the other envelope. Given a list of envelopes represented as pairs of integers `[width, height]`, return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).","solution":"from bisect import bisect_left def max_envelopes(envelopes): Returns the maximum number of envelopes you can Russian doll (i.e., put one inside the other). if not envelopes: return 0 # Sort the envelopes first by width in ascending order. # If the width is the same, sort by height in descending order. # This ensures that envelopes with the same width cannot be Russian dolled. envelopes.sort(key=lambda x: (x[0], -x[1])) def longest_increasing_subsequence(nums): dp = [] for num in nums: idx = bisect_left(dp, num) if idx < len(dp): dp[idx] = num else: dp.append(num) return len(dp) # Extract the heights and find the LIS with these heights. heights = [e[1] for e in envelopes] return longest_increasing_subsequence(heights)"},{"question":"You are given a matrix `grid` of size `m x n`, where each cell contains a non-negative integer representing the height of a building located at that position. You are allowed to increase the height of any building to any non-negative integer. However, to maintain the city\'s aesthetic, the condition that for any building in position `(i, j)`, the building heights of its North, South, East, and West adjacent buildings (if they exist) must not be greater than the height of the building at `(i, j)` by more than 1. Your task is to return _the **maximum** possible height of the tallest building_ in the matrix, ensuring that this condition is not violated for any building. **Note** that you cannot decrease the height of any existing building. [Example for clarity: Input: `grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` Output: 9]","solution":"def max_possible_height(grid): # If grid is empty return 0 if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) # We need to find the max possible height without violating the rule max_height = 0 # We iterate over the grid and find the maximum height of buildings for i in range(m): for j in range(n): max_height = max(max_height, grid[i][j]) return max_height"},{"question":"Given a linked list, an integer `k`, and a segment size `m`, write a function to reverse the nodes of the linked list `k` segments at a time. Each segment size should be exactly `m` nodes. If there are fewer than `m` nodes left to be reversed in a segment at any point, leave them as is. The nodes within each segment should be reversed individually, but segments should not be concatenated together. The function should return the modified linked list. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10` with `k = 2` and `m = 3`, the output should be `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 -> 9 -> 10`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_segments(head, k, m): def reverse_segment(head, m): prev = None current = head tail = head for _ in range(m): if not current: return prev, tail, current nxt = current.next current.next = prev prev = current current = nxt return prev, tail, current if not head or k <= 0 or m <= 0: return head dummy = ListNode(0) dummy.next = head prev_end = dummy current = head while True: tail = current for _ in range(m * k): if not tail: return dummy.next tail = tail.next for _ in range(k): if not current: return dummy.next new_head, new_tail, next_segment_start = reverse_segment(current, m) prev_end.next = new_head new_tail.next = next_segment_start prev_end = new_tail current = next_segment_start return dummy.next"},{"question":"You are given an integer array `nums` of length `n`, where `nums[i]` represents the number of coins at the `i-th` position in a row of `n` pots. You can collect coins from the pots according to the following rules: * You start at any pot. * From any pot, you can either move to the next pot (i.e., `i + 1`) or skip one pot and move to the pot after the next one (i.e., `i + 2`). * Once you collect coins from a pot, you can no longer collect coins from that pot again. Return _the maximum number of coins you can collect by following these rules_.","solution":"def max_coins(nums): Returns the maximum number of coins that can be collected according to the given rules. n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] elif n == 2: return max(nums[0], nums[1]) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a list of `n` flights represented as tuples `(src, dest, price)` where `src` and `dest` are the starting and ending airport codes, and `price` is the cost of the flight. Additionally, you are given two airport codes `start` and `end`, and an integer `k` representing the maximum number of stops you are allowed to make. Return _the minimum cost_ to travel from `start` to `end` with at most `k` stops. If there is no such route, return `-1`.","solution":"from heapq import heappop, heappush from collections import defaultdict, deque def find_cheapest_price(n, flights, start, end, k): Finds the cheapest flight route from start to end with at most k stops. graph = defaultdict(list) for u, v, price in flights: graph[u].append((v, price)) # Priority queue: (cost, current_node, stops) pq = [(0, start, 0)] while pq: cost, u, stops = heappop(pq) if u == end: return cost if stops <= k: for v, price in graph[u]: heappush(pq, (cost + price, v, stops + 1)) return -1"},{"question":"Given a 2D grid of integers where each cell represents elevation, implement an algorithm to find the minimum-effort path from the top-left cell to the bottom-right cell. The effort of a path is defined as the maximum difference in elevation between two consecutive cells along the path. You can move in four possible directions: up, down, left, or right. Write a function `minEffortPath(grid: List[List[int]]) -> int` that returns the minimum effort required to traverse from the top-left to the bottom-right cell of the grid.","solution":"from heapq import heappop, heappush from typing import List def minEffortPath(grid: List[List[int]]) -> int: Finds the minimum-effort path from the top-left to the bottom-right of the grid. The effort of a path is defined as the maximum difference in elevation between two consecutive cells along the path. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: current_effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: next_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if efforts[nx][ny] > next_effort: efforts[nx][ny] = next_effort heappush(min_heap, (next_effort, nx, ny)) return -1 # This should never be reached if the input grid is valid"},{"question":"You are given an `n`-ary tree, where each node may have at most `n` children. The tree is represented in a serialized format where each node is represented as a pair `(val, children)`, where `val` is the value of the node and `children` is a list of child nodes. Given the root of the tree, return the **maximum depth** of the tree. The **depth** of a tree is the number of edges in the longest path from the root to any leaf node. A leaf node is a node without children.","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root): if root is None: return 0 elif not root.children: return 1 else: # Recursively find the depth of each subtree and take the maximum return 1 + max(max_depth(child) for child in root.children)"},{"question":"A company wishes to analyze the productivity of its employees based on the start and end times of their work sessions throughout the day. They use a computer system to log these sessions, which outputs the data as a list of time intervals during which each employee was working. Each interval is represented as a pair of integers where the first integer is the start time and the second integer is the end time. Two intervals `[start1, end1]` and `[start2, end2]` are said to **overlap** if `end1 >= start2` and `start1 <= end2`. Given an array of intervals where each interval is represented by a list of two integers `[start, end]`, *merge all overlapping intervals, and return an array of the merged intervals*. The output should be the merged intervals in ascending order of their start times. For example: - Merging `[1, 3]`, `[2, 6]`, `[8, 10]`, and `[15, 18]` results in `[[1, 6], [8, 10], [15, 18]]`. - Merging `[1, 4]`, and `[4, 5]` results in `[[1, 5]]`. Consider the input array to be sorted in ascending order by the start times of the intervals.","solution":"def merge_intervals(intervals): Merge all overlapping intervals. :param intervals: List of intervals where each interval is represented by a list [start, end]. :return: List of merged intervals. if not intervals: return [] merged_intervals = [] current_interval = intervals[0] for i in range(1, len(intervals)): if current_interval[1] >= intervals[i][0]: # Overlapping intervals, merge them current_interval[1] = max(current_interval[1], intervals[i][1]) else: # No overlap, add the previous interval and reset current_interval merged_intervals.append(current_interval) current_interval = intervals[i] # Add the last interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"You are given a string `s` and a list of strings `words`. Your task is to find the **maximum** number of strings in `words` that are subsequences of `s`. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. Return this maximum count. If none of the strings in `words` are subsequences of `s`, return `0`. For example: - If `s` is \\"abracadabra\\" and `words` are [\\"abra\\", \\"bara\\", \\"cd\\", \\"xyz\\"], the result should be `3` because \\"abra\\", \\"bara\\", and \\"cd\\" are subsequences of `s`.","solution":"def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) def max_subsequences_count(s, words): count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"Given an integer array `nums` of size `n`, return the smallest subarray length such that the sum of the subarray is greater than or equal to a given integer `target`. If no subarray satisfies the condition, return `0`. Implement the `SubarrayFinder` class: - `SubarrayFinder()`: Initializes the `SubarrayFinder` object. - `int minSubArrayLen(int target, int[] nums)`: Returns the minimum length of a contiguous subarray of which the sum is at least `target`, or returns `0` if no such subarray exists.","solution":"class SubarrayFinder: def __init__(self): pass def minSubArrayLen(self, target, nums): n = len(nums) if n == 0: return 0 min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"Given a set of intervals `intervals` where `intervals[i] = [start_i, end_i]` represents all the events starting at `start_i` and ending at `end_i`. Return _the minimum number of intervals you need to remove so that the remaining intervals do not overlap_.","solution":"def eraseOverlapIntervals(intervals): Return the minimum number of intervals you need to remove so that the remaining intervals do not overlap. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as a two-element list. Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals by their end time intervals.sort(key=lambda interval: interval[1]) # Initialize the end point of the first interval end = intervals[0][1] count = 0 # Iterate through intervals starting from the second one for i in range(1, len(intervals)): # If the start of the current interval is less than the end of the previous, we have overlap if intervals[i][0] < end: count += 1 else: # Update the end to the end of the current interval end = intervals[i][1] return count"},{"question":"You are given a list `logs` where each entry is a dictionary with three fields: `\'uid\'` (an integer), `\'timestamp\'` (an integer), and `\'action\'` (a string, which can either be `\\"login\\"` or `\\"logout\\"`). Each `uid` represents a user, and the list is not necessarily in chronological order. Your task is to find the maximum number of users that were logged in simultaneously. A user is logged in from the time they perform a `\\"login\\"` action until they perform a corresponding `\\"logout\\"` action. If a user logs in more than once without logging out, only the most recent `\\"login\\"` is considered valid until a corresponding `\\"logout\\"` occurs. Return _the maximum number of users simultaneously logged in_.","solution":"def max_simultaneous_users(logs): Returns the maximum number of users simultaneously logged in. logs.sort(key=lambda x: x[\'timestamp\']) current_users = set() max_users = 0 for log in logs: if log[\'action\'] == \'login\': current_users.add(log[\'uid\']) elif log[\'action\'] == \'logout\': current_users.discard(log[\'uid\']) max_users = max(max_users, len(current_users)) return max_users"},{"question":"Given an integer `x`, return the integer part of the square root of `x`. For example, if `x` is 8, the integer part of the square root is 2. You are not allowed to use any built-in exponentiation function or operator (`**` or `^`). Your solution must have a time complexity better than O(n).","solution":"def integer_square_root(x): Returns the integer part of the square root of x. if x < 0: raise ValueError(\\"x must be non-negative\\") if x == 0 or x == 1: return x left, right = 1, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return mid elif mid * mid < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"Given an array of integers, find the length of the longest subsequence such that every element in the subsequence is an element that can be obtained by adding 1 to the previous element in the subsequence (consecutive elements). The subsequence does not necessarily have to be contiguous. For example, in the array `[1, 2, 3, 5, 6, 7, 8, 12, 13]`, the longest subsequence that satisfies the condition is `[1, 2, 3, 5, 6, 7, 8]` and its length is 7.","solution":"def longest_consecutive_subsequence(arr): Find the length of the longest subsequence such that every element in the subsequence can be obtained by adding 1 to the previous element in the subsequence. if not arr: return 0 nums_set = set(arr) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"**[Question 4]:** Given a string `s` consisting of lowercase letters, return the length of the longest substring that contains at most two distinct characters.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string s, returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < len(s): char_map[s[right]] = right if len(char_map) > 2: left_most = min(char_map.values()) del char_map[s[left_most]] left = left_most + 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given a list of `strings` and an integer `k`, your task is to return the `k` most frequent strings. If there are multiple strings with the same frequency, return them in lexicographical order. For any input list of `strings` and an integer `k`, output a list of the `k` most frequent strings, ordered first by frequency from highest to lowest, and then by lexicographical order for ties.","solution":"from collections import Counter def k_most_frequent_strings(strings, k): Returns the `k` most frequent strings from the list `strings`. # Count the frequency of each string count = Counter(strings) # Create a sorted list of strings by (-frequency, string) to handle ties lexicographically sorted_strings = sorted(count.keys(), key=lambda x: (-count[x], x)) # Return the top k elements return sorted_strings[:k]"},{"question":"You are given a binary tree with `n` nodes. Each node of the tree stores an integer value. Write a program to implement the following functionalities: 1. **Insert** a new node with a specified value into the binary tree following Binary Search Tree (BST) properties. 2. **Delete** a node with a specified value from the binary tree while maintaining the BST properties. 3. **Find** the nth smallest value in the binary tree. Implement the `BinarySearchTree` class: * `BinarySearchTree()` - Initializes an empty binary search tree. * `void insert(int value)` - Inserts a new node with the given value into the tree. * `void delete(int value)` - Removes the node with the given value from the tree. * `int findNthSmallest(int n)` - Returns the nth smallest value in the tree. If such a value does not exist, return `-1`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current def findNthSmallest(self, n): inorder = [] self._inorder_traversal(self.root, inorder) if n - 1 < len(inorder): return inorder[n - 1] else: return -1 def _inorder_traversal(self, node, inorder): if not node: return self._inorder_traversal(node.left, inorder) inorder.append(node.value) self._inorder_traversal(node.right, inorder)"},{"question":"You are given two strings `s1` and `s2`, where `s2` contains permutations of the characters in `s1`, but some characters in `s2` may be rearranged. Write a function to determine if `s2` **contains a permutation** of `s1`. Return `true` if it does, otherwise return `false`.","solution":"from collections import Counter def contains_permutation(s1, s2): Returns true if s2 contains any permutation of s1, otherwise returns false. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if window_counter == s1_counter: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] end_char = s2[i] window_counter[end_char] += 1 window_counter[start_char] -= 1 if window_counter[start_char] == 0: del window_counter[start_char] if window_counter == s1_counter: return True return False"},{"question":"You are given an array of `n` integers where each element represents time taken to complete a task. You have `2` workers available, and each worker can be assigned exactly one task. Each task assignment happens sequentially. Every time a worker finishes a task, they can be assigned another task from the remaining ones. Your goal is to form pairs of tasks such that the maximum time taken by either worker to complete his tasks is minimized. Return the minimum possible value of the maximum time taken by any worker.","solution":"def minimize_max_time(tasks): Given an array of task times, return the minimum possible value of the maximum time taken by any worker to complete his tasks by optimally pairing them. tasks.sort() # Sort tasks to pair longest tasks with shortest ones n = len(tasks) max_time = 0 for i in range(n // 2): # Pairing smallest task with largest remaining task current_time = tasks[i] + tasks[n - i - 1] max_time = max(max_time, current_time) return max_time"},{"question":"You are given an array `heights` representing the heights of buildings in a row, where `heights[i]` is the height of the `i-th` building. You can pick any two buildings to place a billboard such that the billboard spans from the top of the first building to the top of the second building. The **support cost** of placing a billboard between two buildings `heights[i]` and `heights[j]` (where `i < j`) is the height of the taller building among the two. Return _the **minimum** support cost to place the billboard between any two buildings._","solution":"def min_support_cost(heights): Find the minimum support cost to place a billboard between any two buildings. The support cost is the height of the taller building between the two. Args: heights (list of int): This list contains the heights of the buildings. Returns: int: The minimum support cost to place the billboard. n = len(heights) if n < 2: return 0 # Can\'t place a billboard if there are fewer than 2 buildings # Initialize the minimum support cost to a large value min_cost = float(\'inf\') # Iterate over all pairs of buildings for i in range(n): for j in range(i + 1, n): cost = max(heights[i], heights[j]) if cost < min_cost: min_cost = cost return min_cost"},{"question":"Write a function that takes a linked list and an integer `n` as input and removes the `n`-th node from the end of the list. Return the modified linked list. Assume `n` is always valid. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `n = 2`, your function should modify the list to `1 -> 2 -> 3 -> 5`. Define the node structure as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. dummy = ListNode(0, head) first = second = dummy # Move the first pointer n+1 steps ahead to maintain a gap of n nodes between first and second for _ in range(n + 1): first = first.next # Move both pointers until the first pointer reaches the end of the list while first: first = first.next second = second.next # Remove the n-th node from the end second.next = second.next.next return dummy.next"},{"question":"You are provided with an input string containing alphanumeric characters and spaces. Your task is to implement a function that rearranges the characters in such a way that all the letters come before all the digits, while preserving the relative order of both the letters and the digits. Spaces should be ignored in the final output, but their positions should be preserved as a single space between groups of letters and digits if needed. # Example: - Input: `\\"a1b c2d\\"` - Output: `\\"abc 12d\\"` Write a function that achieves this reordering as described.","solution":"def rearrange_string(input_str): Rearranges the input string to have all letters before all digits, while ignoring spaces in the final output but preserving a single space between groups of letters and digits if needed. letters = [] digits = [] result = [] for char in input_str: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) letters_str = \'\'.join(letters) digits_str = \'\'.join(digits) if letters_str and digits_str: return f\\"{letters_str} {digits_str}\\" else: return letters_str + digits_str"},{"question":"You are given a string `s` and a dictionary of words `dict`. The string `s` can be segmented into a space-separated sequence of one or more dictionary words from `dict`. Implement a function to determine if `s` can be segmented into a sequence of one or more dictionary words. * For example, given `s = \\"applepenapple\\"` and `dict = {\\"apple\\", \\"pen\\"}`, your function should return `True` because `\\"applepenapple\\"` can be segmented as `\\"apple pen apple\\"`. * For example, given `s = \\"catsandog\\"` and `dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}`, your function should return `False` because despite your best efforts, you cannot find a way to segment `\\"catsandog\\"` that uses all of the words in the dictionary. Define the function `def word_break(s: str, dict: Set[str]) -> bool:` to solve this problem.","solution":"def word_break(s: str, dict: set) -> bool: Determines if the string `s` can be segmented into a space-separated sequence of one or more dictionary words from `dict`. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in dict: dp[i] = True break return dp[n]"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You are allowed to apply the following operation any number of times: - Choose a non-empty prefix of the string `s` and flip all characters in that prefix (\'a\' becomes \'b\' and \'b\' becomes \'a\'). Return the minimum number of operations required to make the entire string consist of only one type of character (either all \'a\'s or all \'b\'s).","solution":"def min_operations_to_unify(s): Returns the minimum number of operations required to make the entire string consist of only one type of character (either all \'a\'s or all \'b\'s). # Count the number of prefix flips required to make all characters \'a\'. # This is the number of \'b\'s in the string, since each \'b\' needs a flip. count_flip_to_a = s.count(\'b\') # Count the number of prefix flips required to make all characters \'b\'. # This is the number of \'a\'s in the string, since each \'a\' needs a flip. count_flip_to_b = s.count(\'a\') # The minimum number of operations required will be the lesser of the two counts. return min(count_flip_to_a, count_flip_to_b)"},{"question":"You are given a string `s` and a list of strings `words`. Each word from the list of words can be used as a part of `s` in any order and can be repeated multiple times. Return _the length of the shortest string that can be formed using all the words in the given list at least once as substrings consecutively_. If there are multiple combinations, return the length of the smallest combination. If it is impossible to create such a string return `-1`. Answers within `10-5` of the actual answer will be considered accepted.","solution":"from itertools import permutations def shortest_string_length(s, words): Returns the length of the shortest string that contains all words from the list consecutively at least once. def can_form_string(st, words): for word in words: pos = st.find(word) if pos == -1: return False st = st[pos + len(word):] return True min_length = float(\'inf\') for perm in permutations(words): candidate = \'\'.join(perm) if can_form_string(s, perm): min_length = min(min_length, len(candidate)) return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **directed acyclic graph** (DAG) represented by an adjacency list `graph` where `graph[i]` is a list of all nodes `j` for which there is a directed edge from node `i` to node `j`. You are also given two integers `start` and `end`. Return _a list of all possible paths_ from `start` to `end` in the given graph. Each path should be represented as a list of the nodes in the path order. If there are no paths from `start` to `end`, return an empty list. The nodes in the graph are labeled from `0` to `n - 1`. For example: ``` graph = [[1,2], [3], [3], []] start = 0 end = 3 ``` Output: ``` [[0,1,3],[0,2,3]] ```","solution":"def allPathsSourceTarget(graph, start, end): def dfs(node, path, res): if node == end: res.append(path) return for neighbor in graph[node]: dfs(neighbor, path + [neighbor], res) result = [] dfs(start, [start], result) return result"},{"question":"You are given an integer `n` representing the number of houses in a village, arranged in a straight line and numbered from `1` to `n`. Each house `i` has a certain amount of gold stored in it, given by an array `gold[i]`. However, the villagers have a rule: If you rob a house, you cannot rob its immediate neighbors (i.e., you cannot rob house `i` if you have robbed house `i-1` or house `i+1`). Determine the maximum amount of gold you can rob without violating this rule. Return an integer representing this maximum amount.","solution":"def max_gold_robbed(gold): Function to determine the maximum gold that can be robbed without robbing two consecutive houses. :param gold: List of gold amounts stored in each house. :return: Maximum amount of gold that can be robbed. if not gold: return 0 n = len(gold) if n == 1: return gold[0] elif n == 2: return max(gold[0], gold[1]) dp = [0] * n dp[0] = gold[0] dp[1] = max(gold[0], gold[1]) for i in range(2, n): dp[i] = max(dp[i - 1], gold[i] + dp[i - 2]) return dp[-1]"},{"question":"Given an integer `n`, return an array of length `n` where the `i-th` element is the number of unique **binary search trees** that can be constructed with `i` distinct nodes. For example, if `n = 3`, your result should be `[1, 1, 2, 5]`, where: - there is 1 unique BST with 0 nodes, - there is 1 unique BST with 1 node, - there are 2 unique BSTs with 2 nodes, - there are 5 unique BSTs with 3 nodes. Return _the array_ as the output.","solution":"def num_trees(n): Return an array of length n+1 where the i-th element is the number of unique binary search trees that can be constructed with i distinct nodes. # Initialize an array to store the count of unique BSTs for each number of nodes dp = [0] * (n + 1) # Base case: There is 1 unique BST with 0 nodes (empty tree) dp[0] = 1 # Calculate number of unique BSTs for each number of nodes from 1 to n for i in range(1, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp"},{"question":"You are given a **non-empty** string `s` consisting of lowercase English letters. A **valid subsequence** of the string is defined as a sequence that can be derived from `s` by deleting some or no characters without changing the order of the remaining characters. Determine whether there exists a unique subsequence of length `k` that appears at least `p` times in the string. Return `true` if such a unique subsequence exists, or `false` otherwise.","solution":"from collections import defaultdict from itertools import combinations def has_unique_subsequence(s, k, p): Determine if there exists a unique subsequence of length k that appears at least p times in the string s. Parameters: s (str): string consisting of lowercase English letters k (int): length of the subsequence p (int): minimum required number of occurrences Returns: bool: True if such a unique subsequence exists, False otherwise. # Create a dictionary to count the frequency of each subsequence of length k subseq_counter = defaultdict(int) # Generate all possible subsequences of length k from the string for comb in combinations(range(len(s)), k): subseq = \'\'.join(s[i] for i in comb) subseq_counter[subseq] += 1 # Check if any subsequence appears at least p times for count in subseq_counter.values(): if count >= p: return True return False"},{"question":"Given a `m x n` matrix `board` containing `\'X\'` and `\'O\'`, capture all regions that are surrounded by `\'X\'`. A region is captured by flipping all `\'O\'`s into `\'X\'` in that surrounded region. An `\'O\'` is considered to be on the border if it is in the first row, last row, first column, or last column. Any `\'O\'` that is not on the border or not connected to an `\'O\'` on the border will be flipped to `\'X\'`. Return the resulting matrix after the capture operation.","solution":"def solve(board): Modifies the input `board` to capture all regions surrounded by \'X\'. if not board or not board[0]: return m, n = len(board), len(board[0]) def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != \'O\': return board[r][c] = \'E\' # Mark as visited (E stands for escape) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) # Start from \'O\'s on the borders and mark all connected \'O\'s. for i in range(m): if board[i][0] == \'O\': dfs(i, 0) if board[i][n-1] == \'O\': dfs(i, n-1) for j in range(n): if board[0][j] == \'O\': dfs(0, j) if board[m-1][j] == \'O\': dfs(m-1, j) # Flip all \'O\'s to \'X\'s and \'E\'s back to \'O\'s. for i in range(m): for j in range(n): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'E\': board[i][j] = \'O\' return board"},{"question":"You are given a matrix `mat` of integers. Your task is to implement a function that transforms `mat` in such a way that each element in the resulting matrix is the sum of all elements in the original matrix that are above or to the left of it, including the element itself. Return _the resulting matrix._","solution":"def transform_matrix(mat): Transforms the given matrix such that each element in the resulting matrix is the sum of all elements in the original matrix that are above or to the left of it, including the element itself. Parameters: mat (list of list of int): The original matrix. Returns: list of list of int: The transformed matrix. if not mat or not mat[0]: return [] rows = len(mat) cols = len(mat[0]) result = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): result[i][j] = mat[i][j] if i > 0: result[i][j] += result[i - 1][j] if j > 0: result[i][j] += result[i][j - 1] if i > 0 and j > 0: result[i][j] -= result[i - 1][j - 1] return result"},{"question":"Given an integer array `nums`, an integer `k`, and an integer `target`, find out if there exist two integers in `nums` whose sum is equal to `target`, where the difference between their indices is at most `k`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def contains_nearby_pair_with_sum(nums, k, target): value_indices = {} for i, num in enumerate(nums): complement = target - num if complement in value_indices and i - value_indices[complement] <= k: return True value_indices[num] = i return False"},{"question":"Given two strings, `string1` and `string2`, you are required to determine if `string2` can be formed by rearranging the letters of `string1` and then possibly inserting any number of spaces at any positions. In other words, `string2` must be an anagram of `string1` ignoring spaces. Return `true` if `string2` can be formed as described, otherwise return `false`.","solution":"def can_form_with_anagram(string1, string2): Returns True if string2 can be formed by rearranging the letters of string1 and possibly inserting any number of spaces at any positions, otherwise returns False. # Remove spaces from both strings string1 = string1.replace(\\" \\", \\"\\") string2 = string2.replace(\\" \\", \\"\\") # Sort the characters of both strings return sorted(string1) == sorted(string2)"},{"question":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Implement the `mergeKLists` function: * `ListNode mergeKLists(List<ListNode> lists)` that takes multiple linked lists and returns a single, merged sorted linked list.","solution":"from heapq import heappush, heappop class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merge k sorted linked lists and return it as one sorted linked list. :param lists: a list of ListNode, where each ListNode is the head of a sorted linked list. :return: ListNode, the head of the merged sorted linked list. if not lists: return None min_heap = [] for i, l in enumerate(lists): if l: heappush(min_heap, (l.val, i, l)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"You are implementing a simplified version of a memory manager for a computer system. The memory is represented by an array of a fixed size initialized to zero, where zero indicates free memory, and any positive integer represents an allocated memory block identifier. Your task is to implement the `SimpleMemoryManager` class that has the following functionalities: * `SimpleMemoryManager(int size)` Initializes the memory manager with the specified size. * `boolean allocate(int blockId, int size)` Allocates a block of memory with the given `blockId` and size. Returns `true` if the allocation is successful, or `false` if there is not enough contiguous free memory. * `boolean free(int blockId)` Frees the memory block with the specified `blockId`. Returns `true` if the block was successfully freed, or `false` if the block with the given `blockId` does not exist. * `int[] getMemoryState()` Returns the current state of the memory array. For instance, given the following series of operations: 1. `SimpleMemoryManager manager = new SimpleMemoryManager(10)` initializes a memory of size 10. 2. `manager.allocate(1, 3)` allocates block id 1 with size 3, resulting in the memory state `[1, 1, 1, 0, 0, 0, 0, 0, 0, 0]`. 3. `manager.allocate(2, 2)` allocates block id 2 with size 2, resulting in the memory state `[1, 1, 1, 2, 2, 0, 0, 0, 0, 0]`. 4. `manager.free(1)` frees block id 1, resulting in the memory state `[0, 0, 0, 2, 2, 0, 0, 0, 0, 0]`. 5. `manager.getMemoryState()` returns the current state of the memory `[0, 0, 0, 2, 2, 0, 0, 0, 0, 0]`.","solution":"class SimpleMemoryManager: def __init__(self, size): self.memory = [0] * size def allocate(self, blockId, size): free_blocks = 0 start = -1 for i in range(len(self.memory)): if self.memory[i] == 0: if start == -1: start = i free_blocks += 1 if free_blocks == size: for j in range(start, start + size): self.memory[j] = blockId return True else: start = -1 free_blocks = 0 return False def free(self, blockId): found = False for i in range(len(self.memory)): if self.memory[i] == blockId: self.memory[i] = 0 found = True return found def getMemoryState(self): return self.memory"},{"question":"Write a function that takes a string containing lowercase letters and a list of words, and returns the maximum number of words from the list that can be formed using the letters in the string. Each letter from the string can only be used once per word. Assume the words in the list do not contain any duplicate letters. Function Signature: `def max_words_formed(letters: str, words: List[str]) -> int` # Example: **Input:** ``` letters = \\"abcde\\" words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"] ``` **Output:** ``` 3 ``` **Explanation:** The words \\"a\\", \\"acd\\", and \\"ace\\" can be formed from the given letters. Hence the function returns 3.","solution":"from typing import List from collections import Counter def max_words_formed(letters: str, words: List[str]) -> int: letter_count = Counter(letters) max_words = 0 for word in words: word_count = Counter(word) can_form = True for char, count in word_count.items(): if letter_count[char] < count: can_form = False break if can_form: max_words += 1 return max_words"},{"question":"Write a function that takes a string `s` and a list of words `words` as input, and returns an array of all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. Each word in `words` has the same length. The order of words in the concatenation does not matter.","solution":"def find_substring(s, words): Returns all starting indices of substrings in s that are concatenations of each word in words exactly once and without any intervening characters. if not s or not words or len(words) == 0 or len(words[0]) == 0: return [] word_len = len(words[0]) num_words = len(words) total_len = word_len * num_words word_count = {} for word in words: word_count[word] = word_count.get(word, 0) + 1 result_indices = [] for i in range(word_len): left = i right = i temp_count = {} while right + word_len <= len(s): word = s[right:right + word_len] right += word_len if word in word_count: temp_count[word] = temp_count.get(word, 0) + 1 while temp_count[word] > word_count[word]: temp_count[s[left:left + word_len]] -= 1 left += word_len if right - left == total_len: result_indices.append(left) else: temp_count = {} left = right return result_indices"},{"question":"You are given two non-empty arrays `arr1` and `arr2` consisting of positive integers. A pair `(x, y)` where `x` is from `arr1` and `y` is from `arr2` is called a **good pair** if `gcd(x, y) == 1`, where `gcd` is the greatest common divisor. Return _the number of **good pairs**_ that can be formed between `arr1` and `arr2`.","solution":"from math import gcd def count_good_pairs(arr1, arr2): Returns the number of good pairs (x, y) where x is from arr1 and y is from arr2 and the gcd(x, y) == 1. count = 0 for x in arr1: for y in arr2: if gcd(x, y) == 1: count += 1 return count"},{"question":"Given an integer array `arr` of length `n`, you are allowed to perform the following operation any number of times: * Select any two elements `x` and `y` such that `x > y`, then subtract `y` from `x`. Your task is to determine the greatest common divisor (GCD) of all elements in the array after performing the above operation any number of times. Return this GCD. **Note:** The elements in the array after the operation should remain the same length as the original array.","solution":"from math import gcd from functools import reduce def find_gcd_of_array(arr): Returns the Greatest Common Divisor (GCD) of the array after performing the operation any number of times. The operation lets you subtract y from x when x > y. :param arr: List of integers :return: Integer representing the GCD of the array return reduce(gcd, arr)"},{"question":"Given an m x n binary matrix `grid`, where each cell contains `0` (representing water) or `1` (representing land), calculate the size of the largest rectangle containing only `1`s and return its area. You may assume all four edges of the grid are surrounded by water. Return the _area of the largest rectangle containing only `1`s_.","solution":"def maximalRectangle(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) height = [0] * (n + 1) max_area = 0 for row in grid: for i in range(n): height[i] = height[i] + 1 if row[i] == \'1\' else 0 stack = [-1] for i in range(n + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"Given the `head` of a singly linked list and an integer `n`, remove the `n`-th node from the end of the list and return its head. You must ensure that your implementation performs this in one pass through the list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns the head of the list. :param head: ListNode, the head of the singly linked list. :param n: int, the position of the node from the end to be removed. :return: ListNode, the head of the modified list. dummy = ListNode(0, head) first = dummy second = dummy # Move first ahead by n+1 steps for _ in range(n+1): first = first.next # Move both first and second until first reaches the end while first: first = first.next second = second.next # Remove the nth node from the end second.next = second.next.next return dummy.next"},{"question":"A museum displays exhibits in a single line, where each exhibit has a value associated with it. You are given an integer array `values` where `values[i]` represents the value of the `i-th` exhibit. You want to visit two exhibits such that the absolute difference between the values of the two exhibits is minimized. Return the minimum absolute difference possible between the values of any two different exhibits.","solution":"def min_absolute_difference(values): Returns the minimum absolute difference between the values of any two different exhibits. values.sort() min_diff = float(\'inf\') for i in range(1, len(values)): min_diff = min(min_diff, abs(values[i] - values[i - 1])) return min_diff"},{"question":"You are given an array of integers `arr` and a positive integer `k`. Your task is to divide the array into `k` non-empty consecutive subarrays with the goal to minimize the maximum sum of subarrays obtained. Return the minimized maximum sum. **Example:** Input: `arr = [7,2,5,10,8]`, `k = 2` Output: `18` Explanation: There are several ways to divide the array into 2 subarrays with a minimized maximum sum: - Subarray 1: [7, 2, 5] and Subarray 2: [10, 8] (maximum sum is 18) - Subarray 1: [7, 2] and Subarray 2: [5, 10, 8] (maximum sum is 23) By comparing the maximum sums, the minimum of them is 18. **Example:** Input: `arr = [1, 2, 3, 4, 5]`, `k = 2` Output: `9` Explanation: There are several ways to divide the array into 2 subarrays with a minimized maximum sum: - Subarray 1: [1, 2, 3] and Subarray 2: [4, 5] (maximum sum is 9) - Subarray 1: [1, 2, 3, 4] and Subarray 2: [5] (maximum sum is 10) By comparing the maximum sums, the minimum of them is 9. **Note:** The `input` array will have a length between 1 and 1000, and each element will be between 1 and 10000.","solution":"def minimize_maximum_subarray_sum(arr, k): def can_split(mid): subarray_count = 1 current_sum = 0 for num in arr: if current_sum + num > mid: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if can_split(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"A **shifted string** is a string where each character is substituted with another character that comes after it in the alphabet, with \'z\' wrapping around to \'a\'. For example, shifting \\"abc\\" by 1 results in \\"bcd\\" and shifting \\"xyz\\" by 2 results in \\"zab\\". Given a string `s` and an integer `k`, write a function that returns the shifted string after performing the shift operation `k` times. The function should handle both upper and lower case letters, maintaining the original case of each character.","solution":"def shifted_string(s, k): Shifts each character in the string `s` by `k` positions in the alphabet. Wraps around \'z\' to \'a\' and maintains the case of each character. shifted = [] for char in s: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') + k) % 26 + ord(\'A\')) else: new_char = char shifted.append(new_char) return \'\'.join(shifted)"},{"question":"You are given a string `s` that consists of only lowercase English letters. A **subsequence** of `s` is a string that is formed from `s` by deleting some (or none) of the characters without changing the order of the remaining characters. A subsequence is considered **universal** if it appears as a subsequence in every possible permutation of the string `t`, where `t` consists of all distinct characters of `s`. Return the length of the **longest** universal subsequence in `s`.","solution":"def longest_universal_subsequence_length(s): Returns the length of the longest universal subsequence in the given string `s`. A universal subsequence appears in every possible permutation of the string composed of distinct characters of `s`. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: Length of the longest universal subsequence. # If the string is empty, return 0 if not s: return 0 # Use a set to find the unique characters in the string unique_chars = set(s) # The longest universal subsequence will be the count of unique characters return len(unique_chars)"},{"question":"You are given two integer arrays `nums1` and `nums2`, and an integer `k`. Implement a data structure that efficiently performs the following operations for `k` times: 1. **Maximize the Sum**: Calculate the maximum sum possible by selecting exactly `k` elements from `nums1` and `nums2`. Reset the selected indices so they can be picked again in the future operations. 2. **Update an Element**: Update the value of an element in `nums1` or `nums2` given its index and the new value. Implement the `MaxSumDataStructure` class: * `MaxSumDataStructure(int[] nums1, int[] nums2, int k)` Initializes the object with the two integer arrays and the integer `k`. * `int maximizeSum()` Returns the maximum possible sum by selecting exactly `k` elements from both arrays, combined. * `void update(int index, int value, boolean isNums1)` Updates the element at `index` to `value` in `nums1` if `isNums1` is `true`, otherwise updates the element in `nums2`. A single index cannot be chosen more than once in the same `maximizeSum` operation. However, after each `maximizeSum`, the indices are reset, allowing reuse in subsequent `maximizeSum` operations.","solution":"import heapq class MaxSumDataStructure: def __init__(self, nums1, nums2, k): self.nums1 = nums1 self.nums2 = nums2 self.k = k def maximizeSum(self): combined = self.nums1 + self.nums2 heapq._heapify_max(combined) max_sum = 0 for _ in range(self.k): max_sum += heapq._heappop_max(combined) return max_sum def update(self, index, value, isNums1): if isNums1: self.nums1[index] = value else: self.nums2[index] = value"},{"question":"You are given a matrix `grid` of size `m x n` consisting of non-negative integers. A move consists of picking any cell in the matrix and incrementing its value by 1. Your goal is to make all cells in the matrix equal using the minimum number of moves. Return _the **minimum** number of moves required to make all cells in the matrix equal_.","solution":"def minMoves(grid): Returns the minimum number of moves required to make all cells in the matrix equal. # Flatten the grid into a list of values values = [cell for row in grid for cell in row] # Find the minimum value in the grid min_value = min(values) # Calculate the total number of moves needed moves = sum(value - min_value for value in values) return moves"},{"question":"You are given an array of integers `arr` and a target integer `x`. Determine if there exists a **subarray** (a contiguous non-empty sequence of elements) whose sum is exactly equal to `x`. Return `true` if such a subarray exists and `false` otherwise.","solution":"def subarray_sum_to_x(arr, x): Determine if there exists a subarray whose sum is exactly equal to x. Args: arr (list): The list of integers. x (int): The target sum. Returns: bool: True if such a subarray exists, False otherwise. current_sum = 0 prefix_sums = {0} for num in arr: current_sum += num if (current_sum - x) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"You are given two strings `s` and `t`, each consisting only of lowercase characters. You are allowed to remove zero or more characters from both strings. Return the length of the longest common subsequence (LCS) of `s` and `t`. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_common_subsequence(s, t): Returns the length of the longest common subsequence of strings s and t. m, n = len(s), len(t) # Initialize a (m+1) x (n+1) matrix to store the lengths of LCS. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the LCS is in the bottom-right corner of the matrix return dp[m][n]"},{"question":"You are given a list of integers `arr` and an integer `k`. Your task is to find the maximum sum of `k` consecutive elements within the list `arr`. Return _the **maximum possible sum** of `k` consecutive elements in the list_. Ensure your solution has optimal performance for large input sizes.","solution":"def max_sum_k_consecutive(arr, k): Returns the maximum sum of k consecutive elements in the list arr. if not arr or k <= 0 or k > len(arr): return 0 # Initialize the maximum sum with the sum of the first k elements. max_sum = current_sum = sum(arr[:k]) # Slide the window of size k through the array. for i in range(k, len(arr)): # Update the current sum by sliding the window to the right. current_sum += arr[i] - arr[i - k] # Update the maximum sum if the current sum is greater. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an integer array `arr` and an integer `k`, split the array into `k` non-empty subarrays such that the sum of their means is maximized. The mean of a subarray is the sum of the elements in the subarray divided by the number of elements in the subarray. Return _the maximum sum of the means_ of the `k` subarrays.","solution":"def max_sum_of_means(arr, k): Return the maximum sum of the means of k subarrays. from heapq import nlargest # To maximize sum of means, find the k largest elements in arr. # Since each subarray must have at least one element, consider the largest k elements. largest_elements = nlargest(k, arr) # The sum of these largest k elements\' means is the sum of largest k elements themselves. return sum(largest_elements)"},{"question":"You are given a list of `n` integers, `nums`, and a target sum `k`. Return the number of unique pairs of integers in the list that add up to `k`. A pair (nums[i], nums[j]) is considered unique if there is no other pair (nums[m], nums[n]) with indices i, j, m, and n such that `i != j` and `i != m` and `j != n` but nums[i] + nums[j] == nums[m] + nums[n].","solution":"def count_unique_pairs(nums, k): Returns the number of unique pairs of integers in the list that add up to k. Args: nums: List of integers. k: Target sum. Returns: count: The number of unique pairs that add up to k. seen = set() unique_pairs = set() for num in nums: complement = k - num if complement in seen: pair = tuple(sorted((num, complement))) unique_pairs.add(pair) seen.add(num) return len(unique_pairs)"},{"question":"You are given an array of `n` integers `nums`, where each integer represents the number of stones in a different pile. In each move, you can choose any pile of stones and remove any positive number of stones from that pile. However, in each move, you can only remove stones from one pile. Your goal is to determine if you can make all the piles empty simultaneously (i.e., make the number of stones in each pile zero). Return `true` if you can make all the piles simultaneously empty, otherwise return `false`.","solution":"def can_empty_piles_simultaneously(nums): Determines if it is possible to make all the piles empty simultaneously by removing any positive number of stones from one pile at a time. Returns true if possible, otherwise returns false. # Check if all numbers in the list are equal if all(x == nums[0] for x in nums): return True return False"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters and an integer `k`. You need to perform the following operation exactly `k` times: Select any character in the string and delete it. Your goal is to minimize the length of the longest substring that contains the same character after performing the operations. Return _the length of the longest substring that contains the same character after performing the operations._","solution":"def minimize_longest_substring_length(s, k): This function returns the length of the longest substring that contains the same character after performing exactly k deletions on the string s. from collections import Counter # Get the frequency of each character in the string freq = Counter(s) # Create a list of character frequencies in descending order frequencies = sorted(freq.values(), reverse=True) # Iterate over the frequencies to perform deletions for i in range(len(frequencies)): if k > 0: # Determine how many characters can be removed from the current group remove_count = min(frequencies[i], k) # Reduce the frequency of the current group frequencies[i] -= remove_count # Reduce the remaining number of deletions k -= remove_count else: # No more deletions left break # The maximum frequency in the modified list is our answer return max(frequencies) if frequencies else 0"},{"question":"You are given an array of n integers, `nums`, where `nums[i]` represents the number of invitations you sent to the i-th person. An invitation is considered valid if the invited person accepted it and attended the event. Each of the invited persons can bring their own guests, and each guest they bring will accept and attend the event. Determine the total number of people who attended the event if all invitations are accepted, including both the initially invited persons and their guests. Write a function `totalAttendees(int[] nums)` that returns the total number of attendees based on the given array. Example: - Input: `nums = [1, 2, 3]` - Output: `6` Explanation: - The first person invited 1 person, so 2 people attended (the inviter and the invitee). - The second person invited 2 people, so 3 people attended (the inviter and the invitees). - The third person invited 3 people, so 4 people attended (the inviter and the invitees). - Summing them up, we get 2 + 3 + 4 = 9 attendees.","solution":"def totalAttendees(nums): Returns the total number of attendees including both the initially invited persons and their guests. Parameters: nums (list of int): Array where nums[i] represents the number of invitations sent by the i-th person. Returns: int: Total number of attendees. return sum(invitations + 1 for invitations in nums)"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. Write a function that takes the head of the list as a parameter and returns the new head of the reversed list. Use O(1) space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses a singly linked list. :param head: ListNode - The head of the singly linked list :return: ListNode - The new head of the reversed singly linked list prev = None curr = head while curr: next_temp = curr.next # Save the next node curr.next = prev # Reverse the link prev = curr # Move prev up curr = next_temp # Move curr up return prev # prev will be the new head after the loop ends"},{"question":"You are given a list of non-negative integers `nums`. A **continuous subarray** is defined as a non-empty sequence of elements that appear consecutively in the array. The **degree** of an array is the maximum frequency of any of its elements. Find the length of the **shortest continuous subarray** of `nums` that has the same degree as `nums`. Return _the length of the shortest continuous subarray that has the same degree as the original array._","solution":"def findShortestSubArray(nums): from collections import defaultdict counts = defaultdict(int) first_index = {} last_index = {} for i, num in enumerate(nums): counts[num] += 1 if num not in first_index: first_index[num] = i last_index[num] = i degree = max(counts.values()) min_length = float(\'inf\') for num in counts: if counts[num] == degree: min_length = min(min_length, last_index[num] - first_index[num] + 1) return min_length"},{"question":"You are given a list of integers and an integer `target`. Your task is to find all unique pairs of integers in the list that sum up to the `target`. Each pair should be returned in sorted order, and the result should be a list of these pairs, sorted in ascending order based on the first element of each pair. If no pairs exist, return an empty list. Note that the same pair should not appear twice. Implement the function `findPairs(nums: List[int], target: int) -> List[Tuple[int, int]]`.","solution":"from typing import List, Tuple def findPairs(nums: List[int], target: int) -> List[Tuple[int, int]]: nums.sort() pairs = set() left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return sorted(pairs)"},{"question":"You are given a list of integers `nums`. You need to implement a data structure that supports two operations: * `void add(int val)`: Adds `val` to the list. * `int longestConsecutive()`: Returns the length of the longest consecutive elements sequence in the list. Your implementation should optimally handle multiple `add` and `longestConsecutive` operations. For example, for the sequence of operations `add(100)`, `add(4)`, `add(200)`, `add(1)`, `add(3)`, `add(2)`, `longestConsecutive()`, it should return 4 (The longest consecutive elements sequence is [1, 2, 3, 4]).","solution":"class LongestConsecutiveSequence: def __init__(self): self.nums = set() def add(self, val: int): Adds val to the list. self.nums.add(val) def longestConsecutive(self) -> int: Returns the length of the longest consecutive elements sequence in the list. longest_streak = 0 nums_set = self.nums for num in nums_set: if num - 1 not in nums_set: # check if it is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a list of strings `words` and another string `s`, where each string in `words` consists of lowercase English letters, and `s` is also a string of lowercase English letters. Your task is to determine if a string `target` can be formed using the characters in `s` and possibly some characters from any string in `words`. Return `true` if the `target` can be formed, otherwise return `false`. You can use each character from `s` and each string in `words` as many times as you want.","solution":"from collections import Counter def can_form_target(target, s, words): Determines if the target string can be formed using characters from string s and words. Parameters: target (str): The target string to form. s (str): The string providing characters. words (list): List of strings providing characters. Returns: bool: True if the target can be formed, False otherwise. # Create a counter for string s s_counter = Counter(s) # Aggregate all characters from words into a single counter words_counter = Counter() for word in words: words_counter.update(word) # Combine counters from s and words combined_counter = s_counter + words_counter # Check if there are enough characters to form the target target_counter = Counter(target) for char, count in target_counter.items(): if combined_counter[char] < count: return False return True"},{"question":"A company is evaluating a new software which implements a system with an access control list feature. The access control list is represented by an integer array `perm` of length `n`, where `perm[i]` is a unique integer representing the `i-th` resource. Initially, a user is granted access to sequential resources from `0` to `k-1` (inclusive). You need to determine if by shuffling the resources in `perm`, it is possible to maintain the same `k` access in any order. In other words, you need to check if the subarray formed by the first `k` elements of the `perm` array can be any permutation of integers from `0` to `k-1`. Return `true` if this is possible, otherwise return `false`.","solution":"def can_maintain_access_control(perm, k): Determines if the subarray formed by the first k elements of the perm array can be any permutation of integers from 0 to k-1. Args: perm (list of int): The array representing access control list. k (int): The number of initial resources granted access to the user. Returns: bool: True if the subarray formed by the first k elements of perm can be any permutation of integers from 0 to k-1, otherwise False. return sorted(perm[:k]) == list(range(k))"},{"question":"You are given an array of integers `arr` where each element represents the amount of water. Design a function that calculates the total amount of water that could be trapped after raining. The array represents an elevation map where the width of each bar is 1. Write a function `int trapWater(int[] arr)` that takes the array `arr` and returns the total amount of trapped water.","solution":"def trapWater(arr): Calculate the total amount of water that can be trapped after raining. Parameters: arr (List[int]): List of non-negative integers representing elevation map Returns: int: Total amount of trapped water if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) # Fill right_max array right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"You are given an array of distinct integers `arr`. An integer `d` is a valid divisor of `arr` if for every pair of integers `a` and `b` in the array, either `a % d == 0` or `b % d == 0` (or both). Determine if there exists a valid divisor of `arr`. Return `true` if there exists at least one valid divisor, otherwise, return `false`.","solution":"def has_valid_divisor(arr): Determines if there exists a valid divisor of the array \'arr\' as per the given conditions. A valid divisor \'d\' must satisfy: either `a % d == 0` or `b % d == 0` for every pair of integers `a` and `b` in the array. Args: arr (List[int]): The list of distinct integers. Returns: bool: True if there exists at least one valid divisor, otherwise False. if not arr: return False # Check every number in the array if it can be a valid divisor for i in range(len(arr)): d = arr[i] valid = True for a in arr: if a % d != 0: valid = False break if valid: return True return False"},{"question":"Given two integers `m` and `n`, create a function that returns a 2D array representing the first `m` rows by `n` columns of the **Pascal\'s Triangle**. Pascal\'s Triangle is constructed such that the entry at the `i-th` row and `j-th` column (1-indexed) is the binomial coefficient C(i-1, j-1). The outer two edges of the triangle are always 1, and each interior number is the sum of the two numbers directly above it. **Example:** Input: `m = 5`, `n = 3` Output: ``` [ [1, 0, 0], [1, 1, 0], [1, 2, 1], [1, 3, 3], [1, 4, 6] ] ```","solution":"def generate_pascals_triangle(m, n): Generate a 2D array representing the first m rows by n columns of the Pascal\'s Triangle. triangle = [[0] * n for _ in range(m)] for i in range(m): for j in range(min(i+1, n)): if j == 0 or j == i: triangle[i][j] = 1 else: triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j] return triangle"},{"question":"Given a `root` of a binary tree, a node `u` in the tree, and an integer `k`, return the value of the k-th ancestor of `u`. The k-th ancestor of a node `u` is defined as the k-th node in the path from `u` to the `root`. If there is no such ancestor, return `-1`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_ancestor(root, u, k): def find_path_to_node(root, target): if not root: return None if root.val == target: return [root] left_path = find_path_to_node(root.left, target) if left_path: return left_path + [root] right_path = find_path_to_node(root.right, target) if right_path: return right_path + [root] return None path_to_u = find_path_to_node(root, u) if not path_to_u or len(path_to_u) < k+1: return -1 return path_to_u[k].val"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to build an expression out of `nums` by inserting a plus or minus sign in front of each integer in `nums` and then concatenate all the integers. Your goal is to evaluate the expression to see if it equals to the given `target`. For example, given `nums = [1, 1, 1, 1, 1]` and `target = 3`, you can form the expression `+1 -1 +1 +1 +1` which evaluates to 3. Return the total number of ways to form such expressions. Implement the function `findTargetWays(nums: List[int], target: int) -> int` that returns the count of expressions that evaluate to the given `target`.","solution":"from typing import List def findTargetWays(nums: List[int], target: int) -> int: Returns the number of ways to add plus or minus before each integer in nums to get the target value. def calculate_ways(index, current_sum): # Base case: if we have considered all numbers if index == len(nums): return 1 if current_sum == target else 0 # Calculate ways by adding the current number add_way = calculate_ways(index + 1, current_sum + nums[index]) # Calculate ways by subtracting the current number subtract_way = calculate_ways(index + 1, current_sum - nums[index]) # Return total ways return add_way + subtract_way return calculate_ways(0, 0)"},{"question":"A company is organizing a programming challenge where participants need to form teams. Each team must consist of exactly 3 members. Given an array `participants` of integers where each integer represents the skill level of a participant, determine the maximum number of balanced teams that can be formed. A team is considered balanced if the skill level of the three members are consecutive integers. For example, a team with skill levels `[5, 6, 7]` is balanced, but `[4, 5, 7]` is not. *Return the maximum number of balanced teams that can be formed from the given participants.*","solution":"def max_balanced_teams(participants): from collections import Counter # Count the frequency of each skill level skill_count = Counter(participants) teams = 0 for skill in sorted(skill_count): while skill_count[skill] > 0 and skill_count[skill + 1] > 0 and skill_count[skill + 2] > 0: # Form a team with skill, skill+1, skill+2 teams += 1 skill_count[skill] -= 1 skill_count[skill + 1] -= 1 skill_count[skill + 2] -= 1 return teams"},{"question":"Given a 2D grid `board` representing a game of Tetris, return the grid after placing a new tetrimino. Each cell of the grid is either `0` (empty) or `1` (occupied). You are provided with the type of tetrimino and its starting position. The types of tetriminos are given as a list of their occupied cells relative to their top-left corner. The starting position is given as a tuple `(row, col)` indicating the position where the top-left corner of the tetrimino should be placed initially. The tetrimino will then fall vertically until it cannot move down any further. You need to simulate the falling of the tetrimino and return the resulting grid configuration. Examples of tetrimino types: - `I`: 4 consecutive cells in a row or column, e.g., `[(0,0), (0,1), (0,2), (0,3)]` - `O`: 2x2 block, e.g., `[(0,0), (0,1), (1,0), (1,1)]` - `T`: T-shaped, e.g., `[(0,1), (1,0), (1,1), (1,2)]` - `S`: S-shaped, e.g., `[(0,1), (0,2), (1,0), (1,1)]` - `Z`: Z-shaped, e.g., `[(0,0), (0,1), (1,1), (1,2)]` - `J`: J-shaped, e.g., `[(0,0), (1,0), (2,0), (2,1)]` - `L`: L-shaped, e.g., `[(0,1), (1,1), (2,0), (2,1)]` Write a function that takes the grid `board`, the type of tetrimino as a list of tuples, and the starting position `(row, col)`. The function should return the grid after the tetrimino has fallen and landed.","solution":"def place_tetrimino(board, tetrimino, start_pos): Simulates placing a tetrimino on a Tetris board and returns the resulting grid. :param board: List[List[int]], the 2D grid representing the Tetris board. :param tetrimino: List[Tuple[int, int]], list of coordinates representing the tetrimino shape. :param start_pos: Tuple[int, int], the starting position (row, col) for the top-left corner of the tetrimino. :return: List[List[int]], the Tetris board after the tetrimino has fallen. rows = len(board) cols = len(board[0]) start_r, start_c = start_pos # Apply tetrimino on the initial position positions = [(start_r + tr, start_c + tc) for tr, tc in tetrimino] # Check if positions are within boundaries def is_valid_position(positions): for r, c in positions: if r >= rows or c >= cols or r < 0 or c < 0 or board[r][c] == 1: return False return True def can_move_down(positions): return is_valid_position([(r + 1, c) for r, c in positions]) # Move the tetrimino down until it can\'t move while can_move_down(positions): positions = [(r + 1, c) for r, c in positions] # Place the tetrimino on the board for r, c in positions: board[r][c] = 1 return board"},{"question":"You are building a robot that can navigate a grid. The grid is represented by a `m x n` binary matrix where `0` represents an empty cell and `1` represents an obstacle. Your robot can move up, down, left, or right, and can only move to an empty cell (cells with value `0`). Write a function that determines the **shortest path** from the top-left corner (`0, 0`) to the bottom-right corner (`m-1, n-1`). If there is no such path, return `-1`. The function should return an integer representing the number of steps in the shortest path. * `int shortestPathBinaryMatrix(vector<vector<int>>& grid)`","solution":"from collections import deque def shortestPathBinaryMatrix(grid): m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)] queue = deque([(0, 0, 1)]) # (x, y, steps) grid[0][0] = 1 # Mark as visited while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: grid[nx][ny] = 1 # Mark as visited queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a string `s` representing a **sentence** and an array of strings `d` representing a **dictionary** of words. Your task is to find the **longest** string in the dictionary that can be formed by deleting some characters of the given string `s` without reordering the remaining characters. If there are multiple possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return an empty string. To summarize, implement the following function: * `string findLongestWord(string s, vector<string>& d)` - Returns the longest word in the dictionary that can be formed by deleting some characters of `s`. If there are multiple possible results, return the longest word with the smallest lexicographical order.","solution":"def findLongestWord(s, dictionary): def is_subsequence(x): it = iter(s) return all(c in it for c in x) sorted_dictionary = sorted(dictionary, key=lambda x: (-len(x), x)) for word in sorted_dictionary: if is_subsequence(word): return word return \\"\\""},{"question":"Given an integer array `arr` and an integer `k`, find out whether there is a subarray of length `k` that consists of only distinct elements. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def has_distinct_subarray(arr, k): Check if there is a subarray of length k that consists of only distinct elements. :param arr: List of integers :param k: Length of the desired subarray with distinct elements :return: True if such a subarray exists, False otherwise if len(arr) < k: return False # Use a sliding window approach to check each subarray for i in range(len(arr) - k + 1): if len(set(arr[i:i+k])) == k: return True return False"},{"question":"Given a binary tree, write a function to determine if it is symmetric. A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree. You have to return `True` if the tree is symmetric, otherwise `False`. The binary tree is represented using the TreeNode class: ``` class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function signature should be: ``` def isSymmetric(root: TreeNode) -> bool: ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: def isMirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left) if not root: return True return isMirror(root.left, root.right)"},{"question":"You are given a string `s` representing a mathematical expression containing only non-negative integers, the operators `+`, `-` and `*`, and parentheses `(` and `)`. The task is to implement a calculator to evaluate this expression and return the calculated result. The precedence of the operators is as follows: * Parentheses `()` have the highest precedence and can override other operators. * The `*` operator has higher precedence than `+` and `-`. * The `+` and `-` operators have the same precedence and are evaluated from left to right. The function should correctly handle the operator precedence to compute the final result. Return the calculated result as an integer.","solution":"def calculate(s: str) -> int: def helper(tokens): stack = [] num = 0 sign = \'+\' while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = helper(tokens) if token in \'+-*/)\' or not tokens: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack[-1] = stack[-1] * num elif sign == \'/\': stack[-1] = int(stack[-1] / num) # for Python 3 division truncation towards zero sign = token num = 0 if token == \')\': break return sum(stack) tokens = [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i].isdigit(): num = s[i] while i + 1 < len(s) and s[i + 1].isdigit(): i += 1 num += s[i] tokens.append(num) else: tokens.append(s[i]) i += 1 return helper(tokens)"},{"question":"Given a list of integers `nums`, where the list contains at least one integer, find and return the length of the longest contiguous subarray that contains **only** odd numbers. For example, given `nums = [1, 2, 3, 5, 7, 6, 1, 3]`, the longest contiguous subarray with only odd numbers is `[3, 5, 7]`, which has a length of 3. Return _the length of the longest contiguous subarray of odd numbers_.","solution":"def longest_odd_subarray_length(nums): Returns the length of the longest contiguous subarray that contains only odd numbers. max_length = 0 current_length = 0 for num in nums: if num % 2 != 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given a string `s` consisting of only lowercase English letters. You need to determine the frequency of each character in the string and then use this frequency data to construct a new string by reordering the original string so that no two adjacent characters are the same. If multiple valid strings are possible, return any of them. If it is not possible to rearrange the string to meet the condition, return an empty string.","solution":"import heapq from collections import Counter def reorganize_string(s): Reorganize the string such that no two adjacent characters are the same. Return the reorganized string if possible, otherwise return an empty string. # Count the frequency of each character freq = Counter(s) # Build a max heap based on character frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] # Iterate until the heap is empty while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Decrease the count and set prev_char and prev_count for the next iteration prev_count, prev_char = count + 1, char # Check if the result length is the same as the input length if len(result) == len(s): return \'\'.join(result) else: return \'\'"},{"question":"[Question] 4: You are given an integer matrix `grid` where each cell represents the number of fish in that part of the ocean. Starting from the top-left corner of the matrix, you are to find the maximum number of fish you can collect on a journey to the bottom-right corner. You can only move down or right at each step. Implement a function `maxFish(int[][] grid)` that returns the maximum fish collected.","solution":"def maxFish(grid): Returns the maximum number of fish collected from the top-left to the bottom-right corner of the grid by only moving either down or right. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp array to store the maximum fish collected up to each cell dp = [[0 for _ in range(cols)] for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for i in range(1, cols): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"You are given a **0-indexed** integer array `height` that represents the height of a series of buildings. The buildings are arranged in a row, and you need to perform the following operations: 1. **Raise** the height of a building by `1` unit. 2. **Reduce** the height of a building by `1` unit. You can choose to perform either of the operations any number of times on any building. Your task is to make the heights of all the buildings **equal** using the minimum number of operations. Return _the minimum number of operations required_ to make all buildings have the same height.","solution":"def min_operations_to_equal_height(heights): Returns the minimum number of operations required to make all buildings have the same height. # Find the median of the list of heights sorted_heights = sorted(heights) median = sorted_heights[len(heights) // 2] # Calculate the total number of operations required total_operations = sum(abs(h - median) for h in heights) return total_operations"},{"question":"Given a string `s` containing lowercase letters, determine _the length of the shortest substring_ that contains all unique characters present in the string. If there is no such substring, return `0`.","solution":"def shortest_substring_with_all_unique_chars(s): Returns the length of the shortest substring that contains all unique characters present in the input string s. If no such substring exists, returns 0. if not s: return 0 unique_chars = set(s) required_count = len(unique_chars) n = len(s) min_length = float(\'inf\') left = 0 char_count = {} formed = 0 for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 if char_count[char] == 1: formed += 1 while formed == required_count: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: formed -= 1 left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given a 0-indexed integer array `strength` and an integer `t`. Each element in `strength` represents the strength of soldiers standing in line. Return _a list of indexes of soldiers whose strength is at least_ `t`. The list should be sorted in ascending order. If no soldier\'s strength meets the criteria, return an empty list.","solution":"def filter_soldiers_by_strength(strength, t): Returns a list of indexes of soldiers whose strength is at least t. Parameters: - strength (list): A list of integers representing the strength of soldiers. - t (int): The threshold strength. Returns: - list: A list of indexes of soldiers whose strength is at least t. return [index for index, s in enumerate(strength) if s >= t]"},{"question":"Given an integer array `numbers`, find the **maximum product** of any three numbers in the array. Return the maximum product. # Sample Input/Output: - **Input:** `numbers = [1, 10, 2, 6, 5, 3]` - **Output:** `300` (The maximum product is obtained with numbers `6, 5, and 10`.) - **Input:** `numbers = [-10, -10, 5, 2]` - **Output:** `500` (The maximum product is obtained with numbers `-10, -10, and 5`.)","solution":"def maximum_product_of_three(numbers): Returns the maximum product of any three numbers in the given array. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of any three numbers. numbers.sort() # The maximum product of three numbers can either be the product # of the three largest numbers or the product of the two smallest # numbers (which could be negative, thus making a large positive # product) and the largest number. return max(numbers[-1] * numbers[-2] * numbers[-3], numbers[0] * numbers[1] * numbers[-1])"},{"question":"You are given a list of non-negative integers `nums` where each integer represents a plot of land and its value is the price of building a house on that land. A new regulation in the city requires that no two houses should be built on adjacent plots. Return _an integer_ `answer`_, the maximum amount of money you can earn by building houses according to the regulations._","solution":"def max_money(nums): Returns the maximum amount of money that can be earned by building houses on non-adjacent plots. if not nums: return 0 if len(nums) == 1: return nums[0] prev_two = 0 prev_one = 0 for num in nums: current = max(prev_one, prev_two + num) prev_two = prev_one prev_one = current return prev_one"},{"question":"Given an array of integers `arr`, and two integers `K` and `L` representing the lengths of two non-overlapping subarrays (C1 and C2), find the maximum sum of elements in the two subarrays. The subarrays must be non-overlapping, and they can be in any order. Return _the maximum sum of the elements in the two non-overlapping subarrays._ If it is not possible to find two such subarrays, return `-1`.","solution":"def maxSumTwoNoOverlap(arr, K, L): def maxSumSubarray(arr, length): n = len(arr) if n < length: return -1 max_sum = -float(\'inf\') current_sum = 0 for i in range(length): current_sum += arr[i] max_sum = current_sum for i in range(length, n): current_sum += arr[i] - arr[i - length] if current_sum > max_sum: max_sum = current_sum return max_sum def maxSumWithFixedFirst(arr, K, L): n = len(arr) max_sum = -1 for i in range(n - K + 1): sum1 = sum(arr[i:i + K]) for j in range(n - L + 1): if j + L <= i or j >= i + K: sum2 = sum(arr[j:j + L]) max_sum = max(max_sum, sum1 + sum2) return max_sum max_sum = max(maxSumWithFixedFirst(arr, K, L), maxSumWithFixedFirst(arr, L, K)) return max_sum"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes and `edges` representing the edges between the nodes, find the length of the longest path in the graph. The length of a path is the number of edges in the path. Return the length of _the **longest path**_ in the graph. Each edge has a weight of 1.","solution":"from collections import defaultdict, deque def longest_path_in_dag(n, edges): Find the length of the longest path in a directed acyclic graph (DAG). Parameters: n (int): Number of nodes in the graph. edges (list of tuples): Each tuple is an edge (u, v) representing a directed edge from u to v. Returns: int: The length of the longest path in the graph. # Build the graph and in-degree array graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Perform topological sort using Kahn\'s algorithm queue = deque([node for node in range(n) if in_degree[node] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Initialize distances to zero dist = [0] * n # Relax edges based on topological order for u in topo_order: for v in graph[u]: if dist[v] < dist[u] + 1: dist[v] = dist[u] + 1 return max(dist)"},{"question":"You are given a list of `n` integers representing a permutation of integers from `1` to `n`. You need to find and return the minimum number of \\"swap operations\\" required to sort the list in ascending order. In a single swap operation, you can pick any two indices and swap their elements. Implement the function `minSwapsToSort(nums: List[int]) -> int` that takes a list of integers `nums` and returns the minimum number of swaps required.","solution":"def minSwapsToSort(nums): Returns the minimum number of swaps required to sort the permutation list nums. n = len(nums) arr_pos = [*enumerate(nums)] arr_pos.sort(key=lambda it: it[1]) visited = {k: False for k in range(n)} answer = 0 for i in range(n): if visited[i] or arr_pos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][0] cycle_size += 1 if cycle_size > 0: answer += (cycle_size - 1) return answer"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a town. Each building has a water tank on its roof. When it rains, each building can collect water, but only to the extent that the height of water collected on a building is limited by the height of the shortest building on its immediate left and right. Implement a function `trapRainWater(int[] heights)` that calculates and returns the total amount of rainwater that can be trapped between the buildings. The buildings are represented in an array where each element is a non-negative integer representing the height of a building. For example: Input: `heights = [4,2,0,3,2,5]` Output: `9` In this example, 1 unit of water is collected between buildings with heights 4 and 2, 2 units of water between buildings with heights 2 and 3, and 3 units of water between buildings with heights 3 and 5, totaling to 9. Note: Your solution should be efficient in terms of both time and space complexity.","solution":"def trapRainWater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given an array of integers `arr`, find the maximum length of a contiguous subarray that has an equal number of even and odd integers.","solution":"def max_len_even_odd(arr): Returns the maximum length of a contiguous subarray that has an equal number of even and odd integers. n = len(arr) max_len = 0 diff = 0 sum_diff = {0: -1} # Maps diff to first occurrence index for i in range(n): if arr[i] % 2 == 0: diff += 1 else: diff -= 1 if diff in sum_diff: max_len = max(max_len, i - sum_diff[diff]) else: sum_diff[diff] = i return max_len"},{"question":"Write a function `findDuplicate` that takes an array of integers `nums` containing `n + 1` integers where each integer is in the range [1, n] inclusive. There is only one repeated number in `nums`, return this repeated number. You must solve this problem without modifying the array `nums` and use only constant extra space.","solution":"def findDuplicate(nums): Finds the duplicate number in an array containing n + 1 integers where each integer is between 1 and n inclusive. Arguments: nums -- List of integers with a single duplicate number. Returns: The duplicate number. # Using Floyd\'s Tortoise and Hare (Cycle Detection) method slow = nums[0] fast = nums[0] # Phase 1, finding the intersection point while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2, finding the entrance to the cycle slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"A warehouse has an inventory management system that keeps track of items based on their unique SKU numbers. Each SKU number is a string consisting of alphanumeric characters. An order is processed by scanning multiple SKU numbers, resulting in a list of SKU numbers that may contain duplicates. Write a function that processes this list and returns the SKU number that appears the most. If there is a tie between two or more SKU numbers, return the one that is lexicographically smallest. Example: - Input: list of SKUs: `[\\"A12\\", \\"B34\\", \\"A12\\", \\"C56\\", \\"B34\\", \\"B34\\"]` - Output: `\\"B34\\"`","solution":"from collections import Counter def most_frequent_sku(sku_list): Returns the SKU number that appears the most in the input list. If there is a tie, the lexicographically smallest SKU number is returned. :param sku_list: List of SKU numbers as strings :return: SKU number that appears the most frequently if not sku_list: return \\"\\" sku_counter = Counter(sku_list) max_count = max(sku_counter.values()) most_frequent_skus = [sku for sku, count in sku_counter.items() if count == max_count] return min(most_frequent_skus)"},{"question":"Given an array of integers representing the lengths of different ropes and an integer `k`, write an algorithm to cut the ropes into smaller pieces such that each piece has an integer length and the total number of pieces is at least `k`. Return _the maximum possible length of each piece that can be obtained_ while fulfilling this condition. If it is not possible to obtain at least `k` pieces, return `-1`.","solution":"def max_piece_length(ropes, k): Returns the maximum possible length of each piece that can be obtained while fulfilling the condition of getting at least k pieces from the given ropes. If it\'s not possible, returns -1. Parameters: ropes (list of int): The array of integers representing the lengths of the ropes. k (int): The required number of pieces. Returns: int: The maximum possible length of each piece, or -1 if not possible. def can_cut(length): return sum(rope // length for rope in ropes) >= k if k == 0 or not ropes: return -1 left, right = 1, max(ropes) result = -1 while left <= right: mid = (left + right) // 2 if can_cut(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given a string `s` which consists of lowercase English letters. You can apply the following operation any number of times: choose a non-empty substring of `s` and replace all the characters in it with a single character from \'a\' to \'z\'. Your goal is to form a string where no two adjacent characters are the same. Return _the **minimum** number of operations required to achieve this._","solution":"def min_operations(s): Returns the minimum number of operations required to ensure that no two adjacent characters in s are the same. if not s: return 0 operations = 0 # Iterate through the string and count the operations needed for i in range(1, len(s)): if s[i] == s[i - 1]: # When we find two consecutive characters the same, we need one operation operations += 1 return operations"},{"question":"Given a positive integer `n`, return an array of all the integers in the range `[1, n]` sorted in lexicographical order. For example, given `n = 13`, your output should be `[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]`. **Note:** You should implement an efficient solution that does not generate the entire list and then sort it. The solution should efficiently generate the numbers in lexicographical order directly.","solution":"def lexical_order(n): Returns an array of all integers in the range [1, n] sorted in lexicographical order. def dfs(num): if num > n: return result.append(num) for i in range(10): if 10 * num + i > n: return dfs(10 * num + i) result = [] for i in range(1, 10): dfs(i) return result"},{"question":"You are given an integer array `nums` and an integer `k`. You need to determine whether there is a **subarray** (not necessarily contiguous) of length `k` such that the sum of the subarray\'s elements is **even**. Return `true` if such a subarray exists, and `false` otherwise. Example: ``` Input: nums = [1, 2, 3, 4, 5], k = 3 Output: true Explanation: The subarray [2, 4, 3] has length 3 and sums to an even value (2 + 4 + 3 = 9). ```","solution":"def is_even_sum_subarray(nums, k): Determines whether there is a subarray of length k that sums to an even number. Args: nums (list): list of integers. k (int): the length of the subarray. Returns: bool: True if such a subarray exists, False otherwise. from itertools import combinations if k > len(nums): return False for subarray in combinations(nums, k): if sum(subarray) % 2 == 0: return True return False"},{"question":"Given an integer array `arr` of size `n`, where `n > 1`, and an integer `k`, return the maximum of the minimum values of each subarray of length `k`. A subarray is a contiguous portion of the array. [Question] 5:","solution":"def max_of_min(arr, k): Returns the maximum of the minimum values of each subarray of length `k`. Parameters: arr (list of int): The input array. k (int): The length of the subarray. Returns: int: The maximum of the minimum values of each subarray of length `k`. from collections import deque n = len(arr) if n == 0 or k > n: return None # Initialize deque and result Qi = deque() max_of_min_values = -float(\'inf\') # Process first k elements of array for i in range(k): while Qi and arr[i] <= arr[Qi[-1]]: Qi.pop() Qi.append(i) # Process the rest of the elements for i in range(k, n): # Find the minimum of the previous window max_of_min_values = max(max_of_min_values, arr[Qi[0]]) # Remove the elements which are out of this window while Qi and Qi[0] <= i - k: Qi.popleft() # Remove all elements larger than the currently being added element (remove useless elements) while Qi and arr[i] <= arr[Qi[-1]]: Qi.pop() Qi.append(i) # Compare the minimum of the last window max_of_min_values = max(max_of_min_values, arr[Qi[0]]) return max_of_min_values"},{"question":"Given an integer array `nums`, return the maximum difference between any increasing subsequence of length 2. If no such subsequence exists, return `0`. For example, given `nums = [4, 5, 1, 3, 2, 10]`, the output should be `9` because the maximum difference is between the numbers `1` and `10`. If given `nums = [5, 4, 3, 2]`, the output should be `0` as there is no increasing subsequence of length 2. **Note:** An increasing subsequence of length 2 is a pair `(nums[i], nums[j])` where `i < j` and `nums[i] < nums[j]`.","solution":"def max_diff_increasing_subsequence(nums): Returns the maximum difference between any increasing subsequence of length 2. If no such subsequence exists, return 0. max_diff = 0 n = len(nums) # Iterate over every pair (nums[i], nums[j]) for i in range(n): for j in range(i+1, n): if nums[i] < nums[j]: max_diff = max(max_diff, nums[j] - nums[i]) return max_diff"},{"question":"You are given a list of non-negative integers `nums`. Consider it as an arrangement of numbers in a circular order, which means the last element is adjacent to the first element. Your task is to determine the **maximum sum** of a non-empty subarray that is either in a linear arrangement or can be wrapped around (considering the circular nature). Return _the maximum sum of a non-empty subarray_.","solution":"def maxSubarraySumCircular(nums): Returns the maximum sum of a non-empty subarray in a circular array. def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far if max(nums) < 0: return max(nums) total_sum = sum(nums) max_kadane = kadane(nums) inverted_nums = [-x for x in nums] max_inverted_kadane = kadane(inverted_nums) return max(max_kadane, total_sum + max_inverted_kadane) # Example #print(maxSubarraySumCircular([1, -2, 3, -2])) # Output: 3 #print(maxSubarraySumCircular([5, -3, 5])) # Output: 10 #print(maxSubarraySumCircular([3, -1, 2, -1])) # Output: 4"},{"question":"You are given a list of integers `nums` and an integer `k`. Return the maximum sum of a non-empty substring (also sometimes referred to as a subarray) of `nums` that consists of at most `k` distinct integers. A substring is a contiguous subsequence of the array. For example, for the array `[1, 2, 1, 2, 3]` and `k = 2`, the maximum sum of a non-empty substring that consists of at most 2 distinct integers is `6` (the substring is `[1, 2, 1, 2]`).","solution":"def max_sum_subarray_with_k_distinct(nums, k): Returns the maximum sum of a non-empty substring with at most k distinct integers. from collections import defaultdict if not nums or k <= 0: return 0 current_sum = 0 max_sum = 0 start = 0 freq_map = defaultdict(int) for end in range(len(nums)): right_char = nums[end] freq_map[right_char] += 1 current_sum += right_char while len(freq_map) > k: left_char = nums[start] freq_map[left_char] -= 1 if freq_map[left_char] == 0: del freq_map[left_char] current_sum -= left_char start += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given a binary tree, return _the largest value on each level of the tree in the form of a list_. Here, the binary tree is represented by its root node, which contains integer values. Each node has left and right child pointers, or is null. The first element of the returned list should correspond to the root level, the second to the first level, and so on.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root): Given a binary tree, return the largest value on each level in the form of a list. if not root: return [] from collections import deque queue = deque([root]) largest_values_per_level = [] while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() if node: max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) largest_values_per_level.append(max_value) return largest_values_per_level"},{"question":"You are given an integer array `arr` of size `n`, where each element is distinct. Your task is to determine whether the array represents a valid Binary Search Tree (BST) preorder traversal. Return `true` if it is valid, and `false` otherwise. A valid BST preorder traversal is defined as follows: for any node `N`, all the elements in the left subtree (elements traversed before encountering `N` such that they are less than `N`) must appear before all the elements in the right subtree (elements greater than `N`).","solution":"def is_valid_BST_preorder(arr): Determines if a given array represents a valid BST preorder traversal. Args: arr: List[int] - the array to check Returns: bool: True if the array represents a valid BST preorder traversal, else False. stack = [] lower_bound = float(\'-inf\') for value in arr: if value < lower_bound: return False while stack and stack[-1] < value: lower_bound = stack.pop() stack.append(value) return True"},{"question":"You are given a list of `n` integers `nums` and an integer `k`. We define a contiguous subarray of `nums` as a segment that forms a sequence by taking consecutive elements in `nums`. Your goal is to identify the length of the shortest contiguous subarray whose sum is equal to or greater than `k`. If there is no such subarray, return `-1`. Note that the given `n` integers can include both positive and negative values.","solution":"def shortest_subarray_length(nums, k): Returns the length of the shortest contiguous subarray such that the sum of its elements is at least k. If no such subarray exists, return -1. from collections import deque n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = float(\'inf\') deque_index = deque() for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float(\'inf\') else -1"},{"question":"Given an integer array `nums` of length `n`, return _the **number of subarrays** that have an **even** sum_. A **subarray** is a contiguous (non-empty) sequence of elements within an array.","solution":"def count_even_sum_subarrays(nums): Returns the number of subarrays that have an even sum. :param nums: List[int] - List of integers :return: int - Number of subarrays with even sum n = len(nums) count_even = 0 count_odd = 0 current_sum = 0 result = 0 for num in nums: current_sum += num if current_sum % 2 == 0: # Current subarray sum is even result += 1 + count_even count_even += 1 else: # Current subarray sum is odd result += count_odd count_odd += 1 return result"},{"question":"Given a `rows x cols` matrix where each cell contains an integer, write a function to check if there is a path from the top-left corner to the bottom-right corner of the matrix, such that the sum of the integers along the path is equal to a given target. You can only move to the right or down from a cell. Return `true` if such a path exists, otherwise return `false`.","solution":"def is_path_sum(matrix, rows, cols, target): Checks if there is a path from the top-left to the bottom-right corner of the matrix where the sum of integers along the path equals the target. You can only move right or down. def dfs(r, c, current_sum): # If out of bounds, return false if r >= rows or c >= cols: return False # Add the current cell\'s value to the sum current_sum += matrix[r][c] # If we\'ve reached the bottom-right corner, check if the current sum equals the target if r == rows - 1 and c == cols - 1: return current_sum == target # Recurse: moving right and down return dfs(r + 1, c, current_sum) or dfs(r, c + 1, current_sum) return dfs(0, 0, 0)"},{"question":"You have been given a grid consisting of `n` rows and `m` columns, where each cell in the grid has a given height. You are also provided with two integer arrays `start` and `end`, each containing two elements representing the coordinates `[x, y]` of the starting and ending cells, respectively. Assume you can move from a cell to any of its adjacent cells (up, down, left, right), but only if the height difference between the start and destination cells is not more than `k`. Your goal is to determine whether there is a valid path from the `start` cell to the `end` cell under these conditions. Return _a boolean value indicating whether such a path exists_.","solution":"def can_traverse(grid, start, end, k): Returns True if there is a valid path from start to end considering the height difference constraint. :param List[List[int]] grid: 2D grid with height values. :param List[int] start: coordinates [x, y] of the starting cell. :param List[int] end: coordinates [x, y] of the ending cell. :param int k: maximum allowed height difference. :return bool: True if path exists, False otherwise. from collections import deque def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) visited = set() visited.add(tuple(start)) while queue: x, y = queue.popleft() if [x, y] == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"A **palindrome** is a string that reads the same forward and backward, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. Given a string `s`, return `true` if it is a palindrome, otherwise return `false`.","solution":"import re def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, otherwise False. A palindrome is a string that reads the same forward and backward, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. # Remove all non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() # Check if the cleaned string is a palindrome return cleaned_str == cleaned_str[::-1]"},{"question":"You are given an unsorted integer array `nums`. Write a function to find the smallest positive integer that does not appear in `nums`. Implement an optimal solution with linear time complexity and constant space complexity (excluding the space required for the input data). Return that smallest missing positive integer.","solution":"def first_missing_positive(nums): This function finds the smallest positive integer that does not appear in nums. It uses linear time complexity and constant space complexity. n = len(nums) # Move each positive integer to its corresponding index (1-based index) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap numbers to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # The first position where the number is not correct, return the index+1 for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, the missing number is n + 1 return n + 1"},{"question":"You are given a 2D `grid` of size `m x n` representing a maze where `0` represents an open space and `1` represents a wall. You start in the top-left corner of the maze `(0, 0)` and your goal is to reach the bottom-right corner `(m-1, n-1)` by moving exactly `k` steps. In one step, you can move up, down, left, or right to an adjacent cell. Return `true` if there\'s a path from the start to the goal that consists of exactly `k` steps, and `false` otherwise. **Note:** You cannot move outside the boundaries of the maze, and you cannot pass through walls.","solution":"def is_path_possible(grid, k): Determines if there\'s a path from the top-left to the bottom-right corner that consists of exactly k steps. :param grid: List[List[int]], the 2D grid representing the maze (0 is open, 1 is wall). :param k: int, the exact number of steps to reach the bottom-right corner. :return: bool, True if such a path exists, else False. m, n = len(grid), len(grid[0]) target = (m - 1, n - 1) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up if grid[0][0] == 1 or grid[m-1][n-1] == 1: return False def dfs(x, y, steps): if (x, y) == target and steps == k: return True if steps > k or x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 1: return False # Mark the cell as visited grid[x][y] = 1 found = False for d in directions: if dfs(x + d[0], y + d[1], steps + 1): found = True break # Unmark the cell grid[x][y] = 0 return found return dfs(0, 0, 0)"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the number of unique k-length subsequences that can be formed from `arr` such that each subsequence is strictly increasing. A subsequence is derived by deleting some or no elements from the array without changing the order of the remaining elements. Given: - `arr`, an integer array of length `n`. - `k`, an integer representing the length of the desired subsequence. Return the number of unique k-length strictly increasing subsequences that can be formed from `arr`.","solution":"from itertools import combinations def count_unique_strictly_increasing_subsequences(arr, k): Returns the number of unique k-length strictly increasing subsequences in the array. :param arr: List of integers :param k: Integer, the length of the desired subsequence :return: Integer, the count of unique k-length strictly increasing subsequences count = 0 seen = set() for comb in combinations(arr, k): if comb not in seen and all(comb[i] < comb[i + 1] for i in range(k - 1)): count += 1 seen.add(comb) return count"},{"question":"You are given a **0-indexed** integer array `a` and an integer `k`. Initially, the array is filled with zeros. You need to perform a sequence of operations described by another 2D array `operations` where `operations[i] = [starti, endi]`. For each operation `[starti, endi]`, increment the value of each element of `a` from `starti` to `endi` by 1. After applying all the operations, return the minimum number of elements in `a` that are greater than or equal to `k`.","solution":"def min_elements_greater_than_or_equal_k(a, k, operations): Returns the minimum number of elements in the array `a` that are greater than or equal to `k` after performing the given operations. # Apply the operations for start, end in operations: for i in range(start, end + 1): a[i] += 1 # Count how many elements are greater than or equal to `k` count = 0 for value in a: if value >= k: count += 1 return count"},{"question":"You are given an **unsorted** integer array `arr` and an integer `k`. Your task is to find the **kth largest** element in the array without sorting the entire array. Use the **Quickselect** algorithm to solve this problem. The function should return the `kth` largest element in the array. # Example: ```python arr = [3, 2, 1, 5, 6, 4] k = 2 ``` Output: ``` 5 ``` # Explanation: The 2nd largest element in the array is 5, as the array sorted in descending order would be [6,5,4,3,2,1]. To implement the Quickselect algorithm, you can follow these steps: 1. Choose a pivot element from the array. 2. Partition the array into elements greater than the pivot and elements less than the pivot. 3. Depending on the position of the kth largest element, recursively apply the same steps to the sub-array that contains the kth largest element.","solution":"def quickselect(arr, left, right, k): Helper function to perform the Quickselect operation. if left == right: return arr[left] pivot_index = partition(arr, left, right) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def partition(arr, left, right): Helper function to partition the array around the pivot. pivot = arr[right] i = left for j in range(left, right): if arr[j] > pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[right] = arr[right], arr[i] return i def find_kth_largest(arr, k): Finds the kth largest element in the array using Quickselect algorithm. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"You are given an integer array `heights` representing the heights of `n` people standing in a line. The goal is to arrange them in a queue such that the shorter person is always in front of the taller person. However, with the exception of people with the same height. For individuals of the same height, you must keep them in their original order. Return the array of heights arranged according to the given rules. Remember to maintain the relative order of people with the same height while ensuring that shorter individuals are positioned before taller ones.","solution":"def arrange_heights(heights): Arrange the heights such that the shorter person is always in front of the taller person, while maintaining the relative order of people with the same height. Parameters: heights (List[int]): List of heights of people in the queue. Returns: List[int]: Heights of people arranged in the desired order. return sorted(heights)"},{"question":"You are given `n` pairs of parentheses, and your task is to generate all combinations of well-formed (or valid) parentheses. Each pair of parentheses consists of an opening bracket `(` and a closing bracket `)`. Return _a list of strings where each string represents a combination of well-formed parentheses_. A combination of parentheses is considered well-formed if, for every opening bracket `(` there exists a corresponding closing bracket `)` and an opening bracket `(` must precede its corresponding closing bracket `)`.","solution":"def generate_parentheses(n): Generate all combinations of well-formed parentheses. Args: n: int - The number of pairs of parentheses. Returns: List[str] - A list of all combinations of well-formed parentheses. def backtrack(S, left, right): if len(S) == 2 * n: res.append(\\"\\".join(S)) return if left < n: S.append(\\"(\\") backtrack(S, left + 1, right) S.pop() if right < left: S.append(\\")\\") backtrack(S, left, right + 1) S.pop() res = [] backtrack([], 0, 0) return res"},{"question":"You are given a `2D` grid of cells, where each cell contains an integer representing its **height** above sea level. The task is to determine the **minimum effort** required to travel from the top-left cell of the grid to the bottom-right cell. The effort of a path is defined as the **maximum absolute difference** in heights between two consecutive cells in the path. You can move up, down, left, or right. Return the **minimum effort** required to travel from the top-left cell to the bottom-right cell. **Note**: * The grid is guaranteed to be connected, meaning there is at least one path from the top-left cell to the bottom-right cell. * The number of rows and columns in the grid is at least `2`.","solution":"import heapq def minimum_effort_path(heights): Returns the minimum effort required to travel from the top-left cell to the bottom-right cell. Args: heights (List[List[int]]): 2D grid of integers representing heights. Returns: int: Minimum effort required to travel from the top-left to the bottom-right cell. rows, cols = len(heights), len(heights[0]) efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: next_effort = max(current_effort, abs(heights[nx][ny] - heights[x][y])) if next_effort < efforts[nx][ny]: efforts[nx][ny] = next_effort heapq.heappush(min_heap, (next_effort, nx, ny)) return efforts[rows - 1][cols - 1]"},{"question":"You are given two strings, `str1` and `str2`. Write a function to determine if `str1` is a permutation of a substring in `str2`. Return `true` if `str1` is a permutation of a substring in `str2`, and `false` otherwise. A permutation is defined as a rearrangement of letters.","solution":"def is_permutation_of_substring(str1, str2): Returns True if str1 is a permutation of a substring in str2. from collections import Counter len_str1 = len(str1) len_str2 = len(str2) if len_str1 > len_str2: return False str1_counter = Counter(str1) window_counter = Counter(str2[:len_str1]) if window_counter == str1_counter: return True for i in range(len_str1, len_str2): window_counter[str2[i]] += 1 window_counter[str2[i - len_str1]] -= 1 if window_counter[str2[i - len_str1]] == 0: del window_counter[str2[i - len_str1]] if window_counter == str1_counter: return True return False"},{"question":"You are given a list of strings `words` and a string `target`. Your task is to construct the target string using the minimum number of concatenations of strings from `words`. You may use each string in `words` multiple times. If it is impossible to construct the target string, return -1. Otherwise, return the minimum number of concatenations needed. For example, given `words = [\\"ab\\", \\"a\\", \\"bc\\", \\"c\\"]` and `target = \\"abcbc\\"`, the minimum number of concatenations needed to construct the target string is `3` (\\"ab\\" + \\"c\\" + \\"bc\\").","solution":"def min_concatenations(words, target): Returns the minimum number of concatenations needed to construct the target string using strings from words list. If it is impossible to construct the target string, returns -1. n = len(target) dp = [float(\'inf\')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for word in words: if i >= len(word) and target[i-len(word):i] == word: dp[i] = min(dp[i], dp[i-len(word)] + 1) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"You are given an integer array `heights` representing the heights of buildings on a street from left to right. A building is considered safe if it has no taller building on its right side. Return _an array of indices of all the safe buildings_. The indices should be in ascending order.","solution":"def find_safe_buildings(heights): Returns the indices of buildings that are not blocked by taller buildings to their right. Parameters: heights (list): List of building heights. Returns: list: List of indices of safe buildings. n = len(heights) if n == 0: return [] safe_buildings = [] max_height_so_far = float(\'-inf\') for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: safe_buildings.append(i) max_height_so_far = heights[i] safe_buildings.sort() return safe_buildings"},{"question":"You are given a list of `n` non-negative integers and an integer `k`. Write a function that divides the list into `k` contiguous subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum. You should implement an algorithm that runs in `O(n log n)` time.","solution":"def splitArray(nums, k): Split the array into k contiguous subarrays such that the largest sum of any subarray is minimized. Parameters: nums (list): A list of non-negative integers. k (int): The number of subarrays. Returns: int: The minimized largest sum. def can_split(nums, k, mid): current_sum = 0 count = 1 for num in nums: if current_sum + num > mid: current_sum = num count += 1 if count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Given a `target` integer and an array of integer intervals `intervals`, where each interval is represented as `[start, end]` inclusive. Return _the minimum number of intervals you need to remove so that the remaining intervals do not overlap with the `target` interval. An interval `[a, b]` overlaps with the `target` interval `[c, d]` if `a` is less than or equal to `d` and `b` is greater than or equal to `c`._","solution":"def min_intervals_to_remove(target, intervals): Returns the minimum number of intervals to remove to ensure no overlapping with target interval. target_start, target_end = target remove_count = 0 for interval in intervals: start, end = interval if start <= target_end and end >= target_start: remove_count += 1 return remove_count"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` where `nums[i]` denotes the number of new users who signed up on the `i`-th day. Each new user is either **active** or **inactive** on any given day. Initially, all users are inactive. At the end of each day, you can send a personalized message to exactly one user, which will make the user active. Once a user becomes active, they remain active for all subsequent days. However, you cannot make more than one user active per day. Determine the maximum number of active users on the `k`-th day, where `k` is any valid day index from `0` to `n-1`. Each user becomes active immediately after receiving the message at the end of the day. Return _the maximum number of active users possible on the `k`-th day_.","solution":"def max_active_users(nums, k): Given a list of new users who signed up each day, determine the maximum number of active users possible on the k-th day if we can make exactly one user active per day. Args: nums : List[int] : list of new users each day k : int : day index for which we want to find the max active users Returns: int : maximum number of active users on k-th day # Calculate the total number of users up to day k total_users_up_to_k = sum(nums[:k+1]) # The maximum active users is the minimum between k+1 (days we can send messages) and total_users_up_to_k return min(k + 1, total_users_up_to_k)"},{"question":"You are given a 2D array `grid` of size `m x n` where each cell in the grid is either \'1\' (land) or \'0\' (water). A **region** in the grid is defined as a collection of connected \'1\'s (land cells) where connectivity can be horizontal or vertical (not diagonal). Two cells are connected if they are adjacent horizontally or vertically. The **size** of a region is the number of cells it contains. Return the **size** of the largest region in the `grid`. If there is no land cell, return 0.","solution":"def largest_region(grid): Returns the size of the largest region of connected \'1\'s in the grid. m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == \'0\' or visited[x][y]: return 0 visited[x][y] = True size = 1 # Explore all adjacent cells (up, down, left, right) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_region = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: max_region = max(max_region, dfs(i, j)) return max_region"},{"question":"You are given a string `s` containing only lowercase English letters. Your task is to determine if `s` can be transformed into a palindrome by permuting its characters. In other words, you need to check if the frequency of each character allows for a reordering of the string such that it reads the same forwards and backwards. If possible, return `true`; otherwise, return `false`.","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Palindrome can have at most one character with an odd count return odd_count <= 1"},{"question":"You are given an integer `n` representing the number of months you want to buy a three-month subscription plan. The subscription plan has the following price structure: - `monthlyPrice`: the price for one month; - `threeMonthPrice`: the price for three months (i.e., valid for three consecutive months). You need to determine the minimum cost to buy the subscription for exactly the given `n` months. You are allowed to buy the three-month subscription multiple times. Return the minimum cost. Example: ```python Input: n = 5, monthlyPrice = 10, threeMonthPrice = 25 Output: 40 Explanation: One way to get a subscription for 5 months is to buy a three-month subscription once (cost 25) and then buy the monthly subscription twice for the remaining 2 months (cost 20). Total cost = 25 + 20 = 45, which is not optimal. The optimal way is to buy one three-month subscription and two monthly subscriptions, achieving a total cost of 25 + 10 + 10 = 45. ```","solution":"def minimum_cost(n, monthlyPrice, threeMonthPrice): Calculate the minimum cost to buy the subscription for exactly n months. # Calculate the number of three-month subscriptions needed three_month_subscriptions = n // 3 # Calculate the remaining months after using three-month subscriptions remaining_months = n % 3 # Calculate the cost of using three-month subscriptions and the remaining months cost_with_three_month_subscriptions = (three_month_subscriptions * threeMonthPrice) + (remaining_months * monthlyPrice) # Alternative cost calculation by considering one additional three month subscription if it is cheaper cost_with_extra_three_month_subscription = ((three_month_subscriptions + 1) * threeMonthPrice) # The minimum cost will be the lesser of the two options return min(cost_with_three_month_subscriptions, cost_with_extra_three_month_subscription)"},{"question":"You are given an array of positive integers `nums` and an integer `k`. You need to form a sequence of consecutive subarrays from `nums` where each subarray contains exactly `k` elements. For each subarray, calculate the maximum element. Return an array of these maximum elements for all the consecutive subarrays. If the length of `nums` is less than `k`, return an empty array. For example, if `nums = [2, 1, 5, 1, 3, 2]` and `k = 3`, the consecutive subarrays would be `[2, 1, 5]`, `[1, 5, 1]`, `[5, 1, 3]`, and `[1, 3, 2]`. The corresponding maximum elements would be `[5, 5, 5, 3]`. Return _an array of these maximum elements_.","solution":"def max_elements_of_subarrays(nums, k): Given an array of positive integers nums and an integer k, this function returns an array containing the maximum element of each consecutive subarray of size k. :param nums: List[int] - the list of positive integers :param k: int - size of each subarray :return: List[int] - list of maximum elements of each subarray if len(nums) < k or k <= 0: return [] n = len(nums) max_elements = [max(nums[i:i+k]) for i in range(n - k + 1)] return max_elements"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Determine if there exist three elements in `nums` such that they sum up to a given target value `S`. Return `true` if such a triplet exists in the array; otherwise, return `false`.","solution":"def three_sum(nums, S): Returns True if there exists three elements in nums that sum up to S, otherwise False. n = len(nums) for i in range(n): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == S: return True elif total < S: left += 1 else: right -= 1 return False"},{"question":"A transportation company wants to track the most efficient routes taken by their drivers. You are given a list of `routes`, where each route is represented as a triplet `(start_city, end_city, time)`, denoting that a driver travels from `start_city` to `end_city` in `time` minutes. The company\'s aim is to find out the shortest travel time between any two cities. Write a function to find the shortest time needed to travel from a given `source_city` to a `destination_city`. If there is no possible route, return `-1`. The cities are represented as integers, and the routes list may contain duplicate entries indicating multiple ways between the same cities with different travel times.","solution":"import heapq from collections import defaultdict def find_shortest_time(routes, source_city, destination_city): Finds the shortest time to travel from source_city to destination_city. Parameters: routes: List of tuples (start_city, end_city, time) source_city: integer representing the starting city destination_city: integer representing the destination city Returns: The shortest travel time from source_city to destination_city, or -1 if no route exists. # Build the graph graph = defaultdict(list) for start, end, time in routes: graph[start].append((time, end)) # Min-heap to store (cost, city) heap = [(0, source_city)] # Dictionary to store the shortest path to each city shortest_path = {source_city: 0} while heap: curr_time, city = heapq.heappop(heap) if city == destination_city: return curr_time for time, next_city in graph[city]: new_time = curr_time + time if next_city not in shortest_path or new_time < shortest_path[next_city]: shortest_path[next_city] = new_time heapq.heappush(heap, (new_time, next_city)) return -1"},{"question":"You are given two **positive** integers `a` and `b`. Return _the smallest positive integer `x` such that both `x % a == 0` and `x % b == 0`_.","solution":"import math def smallest_common_multiple(a, b): Returns the smallest positive integer x such that both x % a == 0 and x % b == 0. return abs(a * b) // math.gcd(a, b)"},{"question":"Given a 2D grid `board` representing an `m x n` tic-tac-toe board with the following possible values: \'X\', \'O\', and \' \'. The board represents a game state, and you need to determine if either player has won the game or if the game is still ongoing. A player wins if they have three of their symbols (\'X\' or \'O\') in a row, column, or diagonal. Return `X` if player \'X\' has won, `O` if player \'O\' has won, `Draw` if all cells are filled with no winner, and `Pending` if the game is still ongoing (there are empty cells, and no player has won yet). For example: 1. If `board = [[\'X\', \'X\', \'X\'], [\'O\', \'O\', \' \'], [\' \', \' \', \' \']]`, the output should be `\\"X\\"`. 2. If `board = [[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'O\']]`, the output should be `\\"Draw\\"`. 3. If `board = [[\'X\', \'O\', \' \'], [\'O\', \' \', \' \'], [\' \', \' \', \' \']]`, the output should be `\\"Pending\\"`.","solution":"def check_tic_tac_toe(board): Checks the status of a tic-tac-toe game. :param board: List[List[str]] - a 2D list representing the game board :return: str - the game result (\\"X\\", \\"O\\", \\"Draw\\", or \\"Pending\\") n = len(board) # Check rows and columns for i in range(n): if board[i][0] != \' \' and all(board[i][j] == board[i][0] for j in range(n)): return board[i][0] if board[0][i] != \' \' and all(board[j][i] == board[0][i] for j in range(n)): return board[0][i] # Check diagonals if board[0][0] != \' \' and all(board[i][i] == board[0][0] for i in range(n)): return board[0][0] if board[0][n-1] != \' \' and all(board[i][n-1-i] == board[0][n-1] for i in range(n)): return board[0][n-1] # Check for draw or pending if all(board[i][j] != \' \' for i in range(n) for j in range(n)): return \\"Draw\\" else: return \\"Pending\\""},{"question":"You are given an integer array `nums`. The goal is to determine if there exists a subarray (a contiguous part of the array) whose sum is equal to zero. Return `true` if such a subarray exists and `false` otherwise.","solution":"def has_zero_sum_subarray(nums): Determines if there exists a contiguous subarray with a sum of zero. :param nums: List[int] - the input integer array :return: bool - True if such subarray exists, otherwise False prefix_sum = 0 seen_sums = set() for num in nums: prefix_sum += num if prefix_sum == 0 or prefix_sum in seen_sums: return True seen_sums.add(prefix_sum) return False"},{"question":"Given an integer array `arr` and an integer `target`, return _the number of subarrays whose sum is **exactly** equal to_ `target`. A **subarray** is a contiguous non-empty sequence of elements within an array. Use an efficient approach with a time complexity better than O(n^2).","solution":"def subarray_sum_count(arr, target): Returns the number of subarrays whose sum is exactly equal to target. :param arr: List of integers :param target: Integer target sum for subarrays :return: Number of subarrays whose sum equals to target from collections import defaultdict count = 0 current_sum = 0 sum_map = defaultdict(int) sum_map[0] = 1 # To handle cases where subarray starts from index 0 for num in arr: current_sum += num if (current_sum - target) in sum_map: count += sum_map[current_sum - target] sum_map[current_sum] += 1 return count"},{"question":"You are given a **0-indexed** array `heights` of size `n`, where `heights[i]` is the height of the `ith` tower. Two players, Alice and Bob, take turns choosing any tower and reducing its height by any positive integer they choose. A player loses if they cannot make a move (i.e., all towers have height zero). Alice always goes first. Return `true` if Alice has a winning strategy and `false` otherwise.","solution":"def alice_wins(heights): Determines if Alice has a winning strategy. :param heights: List[int] - Heights of the towers. :return: bool - True if Alice has a winning strategy, False otherwise. nim_sum = 0 for height in heights: nim_sum ^= height return nim_sum != 0"},{"question":"You are given a string `s` that consists of only lowercase English letters. You need to perform operations on this string according to the commands provided in `queries`. The commands consist of two types: - \\"replace x y\\": Replace all occurrences of the character `x` in the string `s` with the character `y`. - \\"count x\\": Count the number of occurrences of the character `x` in the string `s`. Return an array of integers `result`, where each element corresponds to the result of a \\"count\\" command in the order they appear in `queries`. Implement the function `processCommands(s, queries)` which takes a string `s` and a list of queries `queries` and returns the array `result`.","solution":"def processCommands(s, queries): Processes the given commands on the string and returns the results of \\"count\\" commands. :param s: A string consisting of only lowercase English letters. :param queries: A list of commands as strings. :return: A list of integers representing the results of \\"count\\" commands. results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"replace\\": x = parts[1] y = parts[2] s = s.replace(x, y) elif command == \\"count\\": x = parts[1] count = s.count(x) results.append(count) return results"},{"question":"You are given a list of `n` students and their respective scores in three subjects: Mathematics, Science, and English. The scores are given in a 2D array `scores`, where `scores[i] = [math_i, science_i, english_i]` represents the scores of the `i-th` student. Write a function to determine the rank of the student based on their total score. The rank is determined as follows: students with higher total scores are ranked higher. In case of a tie, students with the same total score are given the same rank, and the subsequent ranks are skipped accordingly. Return a list of integers where the `i-th` element is the rank of the `i-th` student. Note: The total score of a student is calculated as the sum of their scores in Mathematics, Science, and English.","solution":"def rank_students(scores): Determines the rank of students based on their total scores. :param scores: List of lists, where each inner list contains three scores (math, science, english) :return: List of integers representing the rank of each student n = len(scores) # Calculate total scores for each student total_scores = [(sum(score), idx) for idx, score in enumerate(scores)] # Sort students by total score in descending order total_scores.sort(reverse=True, key=lambda x: x[0]) # Assign ranks ranks = [0] * n current_rank = 0 prev_total_score = None prev_rank = 0 for i, (total_score, original_index) in enumerate(total_scores): if total_score != prev_total_score: current_rank = i + 1 prev_total_score = total_score ranks[original_index] = current_rank return ranks"},{"question":"You are given an integer array `nums` and a target integer `target`. You need to find out whether there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] = target`. Implement a function `boolean hasPairWithSum(int[] nums, int target)` that returns `true` if such a pair exists, otherwise returns `false`. * The function should aim for an optimal time complexity. * Ensure to handle cases where the array length is less than 2.","solution":"def has_pair_with_sum(nums, target): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] = target, else False. # Use a set to keep track of the numbers we have seen so far seen = set() for num in nums: # Check if there exists a number in seen such that num + that number equals target if target - num in seen: return True # Add num to seen to use it for next iterations seen.add(num) # If no pair is found return False"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a row. You can form a water trap by placing a plank between two buildings. The width of the water trap is determined by the index distance between the two buildings, and the height of the water trap is the shorter of the two buildings\' heights. You must find the maximum amount of water that can be trapped. _Return the maximum amount of trapped water._","solution":"def max_trapped_water(heights): Returns the maximum amount of water that can be trapped between buildings given their heights. n = len(heights) if n < 2: return 0 # Initialize two pointers left, right = 0, n - 1 max_water = 0 # Use two pointer method to find the maximum water trapped while left < right: # Calculate the current amount of trapped water height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update max_water if current_water is greater if current_water > max_water: max_water = current_water # Move the pointer pointing to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"There is a system that logs sensor data from a network of `n` sensors indexed from `0` to `n - 1`. Each sensor records a value at a particular timestamp. You are required to create a data structure that can efficiently handle the following operations: * `record(int timestamp, int sensorId, int value)`: Logs the `value` recorded by the sensor with `sensorId` at the given `timestamp`. * `sumRange(int startTime, int endTime, int sensorId)`: Returns the sum of values recorded by the sensor with `sensorId` between `startTime` and `endTime` (inclusive). Implement the `SensorDataLogger` class: * `SensorDataLogger()`: Initializes the data structure. * `void record(int timestamp, int sensorId, int value)`: Logs the sensor data. * `int sumRange(int startTime, int endTime, int sensorId)`: Returns the sum of recorded values as specified. Ensure that the methods you implement handle a large number of operations efficiently.","solution":"from collections import defaultdict class SensorDataLogger: def __init__(self): Initializes the data structure for logging sensor data. self.data = defaultdict(list) def record(self, timestamp, sensorId, value): Logs the value recorded by the sensor with sensorId at the given timestamp. self.data[sensorId].append((timestamp, value)) def sumRange(self, startTime, endTime, sensorId): Returns the sum of values recorded by the sensor with sensorId between startTime and endTime (inclusive). return sum(value for ts, value in self.data[sensorId] if startTime <= ts <= endTime)"},{"question":"You are given a string `s` consisting of lowercase English letters, which represents a text document. A **substring** is repeated if it appears more than once in the string. Write a program to find the longest repeated substring in `s`. If there are multiple longest repeated substrings with the same length, return the one which appears first in the string. If no repeated substring is found, return an empty string. To solve this, you can use a combination of string manipulation techniques and data structures. The substring should be at least length 2 to be considered repeated. Return _the longest repeated substring_ in `s`.","solution":"def longest_repeated_substring(s): Returns the longest repeated substring in `s`. If no repeated substring is found, returns an empty string. n = len(s) lrs = \\"\\" # Create the suffix array suffixes = sorted([s[i:] for i in range(n)]) # Compare adjacent suffixes to find the longest common prefix for i in range(n - 1): lcp = _longest_common_prefix(suffixes[i], suffixes[i + 1]) if len(lcp) > len(lrs): lrs = lcp return lrs def _longest_common_prefix(s1, s2): Returns the longest common prefix between two strings s1 and s2. min_len = min(len(s1), len(s2)) for i in range(min_len): if s1[i] != s2[i]: return s1[:i] return s1[:min_len]"},{"question":"Given an integer array `nums` containing unique elements, construct a binary search tree by inserting the elements in the order given by `nums`. Return the root of the binary search tree. Implement a function that will construct and return the root node of the BST, where a class `TreeNode` is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): # If the root is None, we create and return a new TreeNode with the value if root is None: return TreeNode(val) if val < root.val: # Insert value into the left subtree root.left = insert_into_bst(root.left, val) else: # Insert value into the right subtree root.right = insert_into_bst(root.right, val) return root def bst_from_preorder(nums): root = None for num in nums: root = insert_into_bst(root, num) return root"},{"question":"Implement a function that takes a string containing a mathematical expression and evaluates it to return the result. The expression could contain digits, \'+\', \'-\', \'*\', \'/\', \'(\', and \')\'. Make sure to handle the operator precedence correctly and support nested parentheses. The input expression is always a valid expression and does not contain any spaces. The result should be an integer.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing digits, \'+\', \'-\', \'*\', \'/\', \'(\', and \')\'. Handles operator precedence and nested parentheses. Assumes the input is always a valid expression and does not contain any spaces. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Truncate towards zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: # operator while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given an integer array `heights` representing the height of students in a class, where `heights[i]` is the height of the `ith` student. Each student is required to join a line such that no student in front of them is shorter than themselves, similar to a queue following non-decreasing order rule. Due to some discrepancies, a few students may not follow this rule, resulting in an out-of-order lineup. Return the minimum number of students that must be removed from the lineup to make the remaining lineup strictly follow the non-decreasing height order.","solution":"def minRemoveToLineup(heights): Returns the minimum number of students that must be removed so the remaining lineup follows a non-decreasing order. from bisect import bisect_left def length_of_lis(nums): Helper function to find the length of the longest increasing subsequence. sub = [] for x in nums: if len(sub) == 0 or sub[-1] <= x: sub.append(x) else: idx = bisect_left(sub, x) sub[idx] = x return len(sub) n = len(heights) lis_length = length_of_lis(heights) # Min number of removals needed is total number of students # minus the length of the longest subsequence that is already # in non-decreasing order. return n - lis_length"},{"question":"Given a binary tree, return the inorder traversal of its nodes\' values. Implement the function `inorderTraversal` that accepts the root of the binary tree as its parameter and returns a list of integers representing the inorder traversal of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Returns the inorder traversal of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: The inorder traversal (left, root, right) of the tree. def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) return list(inorder(root))"},{"question":"Given an array of `n` integers where `arr[i]` represents the **height** of the `ith` building, you are initially on the ground (height 0). You can jump up to a maximum height of `maxJump`. Determine the minimum number of jumps required to reach the top of each building from the ground. If it is not possible to reach a building, return `-1` for that building. Return an array where each element corresponds to the minimum number of jumps needed for each building in the input array.","solution":"def min_jumps_to_reach_buildings(heights, maxJump): Determine the minimum number of jumps to reach the top of each building. :param heights: List[int], where each element represents the height of a building. :param maxJump: int, the maximum height that can be jumped in one jump. :return: List[int], array of minimum jumps needed for each building or -1 if not possible. result = [] for height in heights: if height == 0: result.append(0) elif height <= maxJump: result.append(1) else: jumps = height // maxJump if height % maxJump != 0: jumps += 1 result.append(jumps) return result"},{"question":"**[Question 4]:** You are given a rectangular matrix `matrix` where each cell contains either a `0` or a `1`. A cell is called a `special` cell if the cell contains a `1` and all the other cells in its row and column are `0`. Given the matrix, find the number of special cells. Return the **count** of such special cells in the matrix.","solution":"def numSpecial(matrix): Returns the count of special cells in the matrix. A special cell is defined as a cell containing \\"1\\" where all other cells in its row and column are \\"0\\". rows = len(matrix) cols = len(matrix[0]) # Find the sum of each row and column row_sums = [sum(row) for row in matrix] col_sums = [sum(col) for col in zip(*matrix)] special_count = 0 # Iterate through the matrix to count the special cells for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and row_sums[i] == 1 and col_sums[j] == 1: special_count += 1 return special_count"},{"question":"You are given a list of integers `arr` of length `n`, representing the heights of n buildings in a row. Each building has a window that you can place a flower in if the height of the building is greater than the heights of the buildings immediately adjacent to it. An edge case occurs at the extremes where a building may have only one adjacent building. For these buildings, the comparison is only made with their single neighbor. Return a list of indices where flowers can be placed. Note that the indices should be in ascending order.","solution":"def find_flower_spots(arr): Return a list of indices where flowers can be placed. A flower can be placed at index i if arr[i] > arr[i-1] or arr[i+1]. Special cases for the first and last elements. n = len(arr) flower_spots = [] for i in range(n): if (i > 0 and i < n-1 and arr[i] > arr[i-1] and arr[i] > arr[i+1]) or (i == 0 and n > 1 and arr[i] > arr[i+1]) or (i == n-1 and arr[i] > arr[i-1]) or (n == 1): # Handle single element list flower_spots.append(i) return flower_spots"},{"question":"You are given a list of non-negative integers representing the amount of rainfall at different timestamps. Your task is to count the number of distinct subarrays of the list such that the sum of the subarray elements is greater than a given target `T`. The subarrays must be contiguous and contain at least one element. Return the result as an integer representing the count of such subarrays. **Function signature:** ```python def count_subarrays_with_sum_greater_than_target(rainfall: List[int], T: int) -> int: ```","solution":"def count_subarrays_with_sum_greater_than_target(rainfall, T): Return the count of distinct subarrays where the sum of the subarray elements is greater than target T. n = len(rainfall) count = 0 for start in range(n): curr_sum = 0 for end in range(start, n): curr_sum += rainfall[end] if curr_sum > T: count += 1 return count"},{"question":"Given a `2D` array `matrix` where each cell contains an integer representing an elevation at that point, find a path from the top-left corner to the bottom-right corner that minimizes the maximum difference in elevation between adjacent cells along the path. You may only move up, down, left, or right. Return _the minimum possible value of the maximum difference between adjacent cells in the optimal path_.","solution":"from collections import defaultdict, deque import heapq def min_max_diff(matrix): rows, cols = len(matrix), len(matrix[0]) def valid(x, y): return 0 <= x < rows and 0 <= y < cols def get_neighbors(x, y): for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if valid(nx, ny): yield nx, ny def dijkstra(): min_heap = [(0, 0, 0)] # (diff, x, y) max_diff = [[float(\'inf\')] * cols for _ in range(rows)] max_diff[0][0] = 0 while min_heap: current_diff, x, y = heapq.heappop(min_heap) if (x, y) == (rows - 1, cols - 1): return current_diff for nx, ny in get_neighbors(x, y): diff = abs(matrix[nx][ny] - matrix[x][y]) max_diff_to_next_cell = max(current_diff, diff) if max_diff_to_next_cell < max_diff[nx][ny]: max_diff[nx][ny] = max_diff_to_next_cell heapq.heappush(min_heap, (max_diff_to_next_cell, nx, ny)) return max_diff[rows - 1][cols - 1] return dijkstra()"},{"question":"You have been given the root of a binary tree and an integer `k`. Your task is to find all the nodes in the binary tree that are exactly `k` distance away from the root. Return the values of these nodes as a list. If there are no nodes at the distance `k`, return an empty list. The nodes in the list should be listed in the order they appear at that distance from left to right.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def nodes_at_k_distance(root, k): Returns the list of node values that are exactly k distance from the root. if root is None: return [] if k == 0: return [root.val] left_nodes = nodes_at_k_distance(root.left, k - 1) right_nodes = nodes_at_k_distance(root.right, k - 1) return left_nodes + right_nodes"},{"question":"Given a string `s` and a dictionary of words `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. **Example:** If you are given `s = \\"catsanddog\\"` and `wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]`, the solution should return the sentences: `[\\"cats and dog\\", \\"cat sand dog\\"]`. **Hint:** Implement a helper function that utilizes dynamic programming and backtracking to find and store possible sentences formed by valid words from the dictionary.","solution":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> List[str]: word_set = set(wordDict) memo = {} def backtrack(start): if start in memo: return memo[start] if start == len(s): return [\'\'] sentences = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: rest_sentences = backtrack(end) for sentence in rest_sentences: full_sentence = word + (\\"\\" if sentence == \\"\\" else \\" \\") + sentence sentences.append(full_sentence) memo[start] = sentences return sentences return backtrack(0)"},{"question":"You are given a string `s` made up of lowercase alphabets. You need to find the longest substring that can be formed by removing at most one character from `s` such that the remaining characters are in alphabetical order. Return the length of this longest alphabetical substring.","solution":"def longest_alphabetical_substring(s): Returns the length of the longest substring (with at most one character removed) where the remaining characters are in alphabetical order. n = len(s) if n == 0: return 0 max_length = 0 for i in range(n): # Check the substring without removing any character length = calculate_length(s, -1) max_length = max(max_length, length) # Check the substring by removing the ith character length = calculate_length(s[:i] + s[i+1:], i) max_length = max(max_length, length) return max_length def calculate_length(s, removed_index): Helper function to calculate the length of the longest alphabetical substring. max_length = 0 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a `0-indexed` array `heights` of size `n` where each element represents the height of a vertical pole. Initially, each pole has a flag on top of it. A pole is called a \'seen\' pole if it is visible when looking from the leftmost pole to the rightmost pole without any other pole blocking the view. Flags from higher poles block the view of flags from shorter or equal height poles to the right of them. For each pole, determine if its flag is visible or not. Return _an array of booleans where `True` represents a \'seen\' pole flag and `False` represents a \'blocked\' pole flag_.","solution":"def seen_poles(heights): This function determines if each pole\'s flag is visible when looking from the leftmost pole to the rightmost pole. Returns an array of booleans where True represents a \'seen\' pole flag and False represents a \'blocked\' pole flag. n = len(heights) if n == 0: return [] results = [False] * n max_height_so_far = -1 for i in range(n): if heights[i] > max_height_so_far: results[i] = True max_height_so_far = heights[i] return results"},{"question":"Given a `m x n` binary matrix `grid`, an island is a maximal 4-directionally (horizontal or vertical) connected group of `1`s. The perimeter of an island is the total length of the boundary of the island. Your task is to find the largest perimeter of any island in the `grid`. Return the largest perimeter encountered or `0` if there are no islands.","solution":"def largest_island_perimeter(grid): Find the largest perimeter of any island in the grid. :param grid: List[List[int]] :return: int rows = len(grid) cols = len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == 0: return 1 if grid[x][y] == -1: return 0 grid[x][y] = -1 perimeter = 0 perimeter += dfs(x + 1, y) perimeter += dfs(x - 1, y) perimeter += dfs(x, y + 1) perimeter += dfs(x, y - 1) return perimeter max_perimeter = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: max_perimeter = max(max_perimeter, dfs(i, j)) return max_perimeter"},{"question":"You are given an array of integers `weights` where `weights[i]` represents the weight of the `i-th` stone. Each stone can be either in the left or right pile. Find the minimum possible absolute difference between the sum of weights in the left pile and the sum of weights in the right pile. Return the minimum absolute difference.","solution":"def minimum_difference(weights): Returns the minimum possible absolute difference between the sum of weights in the left pile and the sum of weights in the right pile. total_weight = sum(weights) n = len(weights) # Using dynamic programming to find the closest sum to total_weight // 2 dp = [0] * (total_weight // 2 + 1) for weight in weights: for j in range(total_weight // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) closest_sum = dp[total_weight // 2] return abs(total_weight - 2 * closest_sum)"},{"question":"You are working on a system that needs to manage user sessions. Each session has a `start time` and an `end time`, represented as integers (the number of minutes from midnight, ranging from 0 to 1439). You are given a list of tuples where each tuple contains the `start time` and `end time` of a session. Your task is to merge all overlapping sessions into a single session. Two sessions `[start1, end1]` and `[start2, end2]` are considered overlapping if `start1 <= end2` and `start2 <= end1`. Return a list of tuples representing the merged sessions sorted by their start times. If a session\'s `end time` is earlier than its `start time`, it means the session continues through midnight and should be handled accordingly.","solution":"def merge_sessions(sessions): Merges overlapping sessions into single sessions. # Normalize sessions for those that end past midnight normalized_sessions = [] for start, end in sessions: if start <= end: normalized_sessions.append((start, end)) else: # Split into two sessions normalized_sessions.append((start, 1439)) # until end of the day normalized_sessions.append((0, end)) # from start of the day # Sort sessions by start time and handle merging normalized_sessions.sort(key=lambda x: x[0]) merged_sessions = [] for session in normalized_sessions: if not merged_sessions or merged_sessions[-1][1] < session[0]: merged_sessions.append(session) else: merged_sessions[-1] = (merged_sessions[-1][0], max(merged_sessions[-1][1], session[1])) return merged_sessions"},{"question":"Write a function that takes a positive integer `n` and returns the number of structurally unique binary search trees (BST) that store values `1` through `n`. A binary search tree is structurally unique if it is not possible to obtain the same tree structure by reordering the nodes. For example, for `n = 3`, there are 5 unique BSTs constructed from values `1, 2, 3`. Return the number of such unique BSTs.","solution":"def num_trees(n): Returns the number of structurally unique BSTs that can be formed with values from 1 to n. if n <= 0: return 0 # Initialize dp array where dp[i] will store the number of unique BSTs that can be # formed with i nodes. dp = [0] * (n + 1) dp[0] = 1 # There is one empty BST. # Calculate the number of unique BSTs for each number of nodes from 1 to n. for i in range(1, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. Your algorithm should run in `O(n)` time and use `O(1)` auxiliary space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed singly linked list. prev = None current = head while current: next_node = current.next # store next node current.next = prev # reverse the link prev = current # move prev to current node current = next_node # move to the next node return prev"},{"question":"You are given a list of integers `nums`. For each integer in the list, check if it is a palindrome. A palindrome is a number that reads the same forwards and backwards (e.g., 121 or 1331). Return a new list containing only the integers from `nums` that are palindromes.","solution":"def is_palindrome(n): Check if the given integer n is a palindrome. return str(n) == str(n)[::-1] def filter_palindromes(nums): Given a list of integers, return a list of palindromes. return [num for num in nums if is_palindrome(num)]"},{"question":"You are given a string `s` consisting of only characters `a` and `b`. You can delete any number of characters from `s` to create a new string. The goal is to form the string with the longest length possible such that it contains alternating characters `a` and `b` and starts with the character `a`. Return the longest alternating string you can form.","solution":"def longest_alternating_string(s): Returns the longest alternating string that starts with \'a\' and consists of characters \'a\' and \'b\'. result = [] expected_char = \'a\' for char in s: if char == expected_char: result.append(char) expected_char = \'b\' if expected_char == \'a\' else \'a\' return \'\'.join(result)"},{"question":"You are given an array of integers representing the amount of time (in minutes) that each task takes to complete, and an integer `n` representing a cooldown period between two similar tasks. Find the minimum amount of time required to complete all the tasks. Each task will be represented by a unique integer. The order in which tasks are presented in the array cannot be changed.","solution":"def minimum_time_to_complete_tasks(tasks, n): Calculate the minimum amount of time required to complete all tasks given the cooldown period `n` where each task is unique. Args: tasks (list of int): List of tasks\' durations n (int): Cooldown period (not relevant in this problem as each task is unique) Returns: int: Total time required to complete all tasks return sum(tasks)"},{"question":"You are given a string `s` consisting of lowercase letters. Determine if it can be recursively constructed by concatenating some string `p` with itself multiple times (i.e., `p + p + ... + p = s`). Return `true` if it can be constructed in this way, otherwise return `false`.","solution":"def can_be_constructed(s): Determine if the string s can be recursively constructed by concatenating some string p with itself multiple times. if not s: return False doubled_s = s + s sub_str = doubled_s[1:-1] return s in sub_str"},{"question":"Given an array of integers `nums`, construct a new array `count` where `count[i]` is the number of elements less than `nums[i]` to the right of `nums[i]`. Return the `count` array. For example, given the array `[5, 2, 6, 1]`, the method should return `[2, 1, 1, 0]` because: - There are 2 numbers less than 5 to the right of it: [2, 1]. - There is 1 number less than 2 to the right of it: [1]. - There is 1 number less than 6 to the right of it: [1]. - There are no numbers less than 1 to the right of it.","solution":"def count_smaller_elements(nums): Given an array of integers `nums`, returns an array `count` where `count[i]` is the number of elements less than `nums[i]` to the right of `nums[i]`. n = len(nums) count = [0] * n for i in range(n): for j in range(i + 1, n): if nums[j] < nums[i]: count[i] += 1 return count"},{"question":"You are given a 2D matrix `mat` of size `m x n`, consisting of non-negative integers. Your task is to find the **maximum** sum of elements in any **submatrix** of `mat` where the submatrix contains exactly `k` elements. Return the maximum sum found. If there are no valid submatrices that contain exactly `k` elements, return `-1`.","solution":"def max_sum_submatrix(mat, k): Finds the maximum sum of elements in any submatrix containing exactly k elements. Parameters: mat (List[List[int]]): 2D matrix of non-negative integers k (int): Number of elements in the submatrix Returns: int: Maximum sum of any submatrix containing exactly k elements or -1 if no such submatrix exists m, n = len(mat), len(mat[0]) if m * n < k: # It\'s not possible to have a k-element submatrix return -1 # Convert mat into a 1D array flat_mat = [mat[i][j] for i in range(m) for j in range(n)] # Sort flat_mat in descending order flat_mat.sort(reverse=True) # Get the sum of the first k elements max_sum = sum(flat_mat[:k]) return max_sum"},{"question":"You are given an array of integers `nums` and an integer `k`. Your goal is to create a subsequence of `nums` such that the difference between the maximum and minimum elements in the subsequence is at most `k`. The subsequence should be as long as possible. Return the length of such a subsequence. Note that the elements of the subsequence do not need to be contiguous in the array, but they must appear in the same relative order in which they appear in `nums`.","solution":"def longest_subsequence_with_diff_at_most_k(nums, k): Returns the length of the longest subsequence where the difference between the maximum and minimum elements is at most k. if not nums: return 0 nums.sort() start = 0 max_length = 0 for end in range(len(nums)): while nums[end] - nums[start] > k: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the length of the shortest subarray whose sum is at least `k`. If there is no such subarray, return -1. Consider the following constraints: - `1 <= arr.length <= 10^5` - `-10^5 <= arr[i] <= 10^5` - `1 <= k <= 10^9` Return the length of the shortest subarray with a sum of at least `k`, or -1 if no such subarray exists.","solution":"from collections import deque def shortest_subarray_sum_at_least_k(arr, k): Finds the length of the shortest subarray with a sum of at least k. Parameters: arr (List[int]): List of integers k (int): Target sum Returns: int: The length of the shortest subarray with sum at least k, or -1 if no such subarray exists n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] deque_index = deque() result = float(\'inf\') for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float(\'inf\') else -1"},{"question":"You are given a string `s` consisting of lowercase letters and an integer array `chars` where `chars[i]` represents the maximum number of times the `i-th` character (\'a\' + i) can appear in a subsequence. A subsequence is a sequence that can be derived by deleting some or no characters without changing the order of the remaining characters. Find the length of the **longest** subsequence of `s` that satisfies the constraints given in `chars`.","solution":"def longest_subsequence(s, chars): Returns the length of the longest subsequence of the string s that satisfies the constraints in chars. # Initialize a counter for the occurrences of each character char_count = [0] * 26 # Iterate through the string and count occurrences for char in s: char_count[ord(char) - ord(\'a\')] += 1 # Calculate the length of the longest valid subsequence longest_length = 0 for i in range(26): # Take the minimum of the available characters and the maximum allowed by chars[i] longest_length += min(char_count[i], chars[i]) return longest_length"},{"question":"Given an unsorted integer array `nums`, return _the smallest positive integer_ `k` _such that it cannot be represented as the sum of any subset of elements from_ `nums`. If all positive integers can be represented, return _the value of the sum of all the elements in_ `nums` _plus one_.","solution":"def smallest_nonrepresentable_sum(nums): Returns the smallest positive integer that cannot be represented as the sum of any subset of elements from nums. nums.sort() smallest_missing_sum = 1 for num in nums: if num > smallest_missing_sum: break smallest_missing_sum += num return smallest_missing_sum"},{"question":"You are given an array `nums` of `n` integers and an integer `k`. Your task is to determine if there are `k` consecutive elements in the array that have the same sum when forming a subarray of length `k` from those elements. You can form the subarray starting from any index `0 <= i <= n - k`. Return `true` if such a subarray exists and `false` otherwise.","solution":"def has_k_consecutive_subarray_with_same_sum(nums, k): Determines if there are k consecutive elements in the array that have the same sum when forming a subarray of length k from those elements. Parameters: nums (list): List of integers. k (int): Length of the subarray to check for consecutive sums. Returns: bool: True if such a subarray exists, False otherwise. if k > len(nums): return False # Calculate the sums of k-length subarrays subarray_sums = [sum(nums[i:i+k]) for i in range(len(nums) - k + 1)] # Check if any of these sums are the same return len(subarray_sums) != len(set(subarray_sums))"},{"question":"A company organizes a coding competition every year. Each participant\'s performance is recorded in an array called `scores`. Each element in the array represents the score of a participant. The competition encourages continuous improvement, so the company\'s goal is to identify the longest subarray where the scores are strictly increasing. Given an integer array `scores`, return _the length of the longest strictly increasing subarray_.","solution":"def longest_increasing_subarray(scores): if not scores: return 0 max_length = 1 current_length = 1 for i in range(1, len(scores)): if scores[i] > scores[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', return the length of the smallest substring that contains at least two \'a\'s and two \'b\'s. If no such substring exists, return -1.","solution":"def smallest_substring_with_two_as_and_two_bs(s): Given a string s consisting of only the characters \'a\' and \'b\', return the length of the smallest substring that contains at least two \'a\'s and two \'b\'s. If no such substring exists, return -1. n = len(s) min_length = float(\'inf\') # Initialize with a very large value for i in range(n): count_a = 0 count_b = 0 for j in range(i, n): if s[j] == \'a\': count_a += 1 elif s[j] == \'b\': count_b += 1 if count_a >= 2 and count_b >= 2: min_length = min(min_length, j - i + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"Given an `m x n` matrix `mat` of integers, return the maximum score of a path starting at `mat[0][0]` and ending at `mat[m-1][n-1]`. The score of a path is the minimum value in that path. For example, the score of the path 8 → 4 → 5 → 9 is 4. A path moves through matrix cells, starting from the top-left cell and moving to the bottom-right cell. You can only move either down or right at any point in time. Implement the `PathScore` class: * `PathScore(int[][] mat)` Initializes the `PathScore` object with the given matrix `mat`. * `int getMaxScore()` Returns the maximum score of a valid path from `mat[0][0]` to `mat[m-1][n-1]`.","solution":"from queue import PriorityQueue class PathScore: def __init__(self, mat): self.mat = mat self.m = len(mat) self.n = len(mat[0]) if self.m > 0 else 0 def getMaxScore(self): if not self.mat or not self.mat[0]: return 0 m, n = self.m, self.n directions = [(1, 0), (0, 1)] pq = PriorityQueue() pq.put((-self.mat[0][0], 0, 0)) visited = [[False] * n for _ in range(m)] visited[0][0] = True min_score = self.mat[0][0] while not pq.empty(): score, r, c = pq.get() score = -score min_score = min(min_score, score) if r == m - 1 and c == n - 1: return min_score for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: visited[nr][nc] = True pq.put((-self.mat[nr][nc], nr, nc)) return min_score"},{"question":"Given two integers `a` and `b`, their **Hamming distance** is the number of positions at which the corresponding bits are different. Write a function that, given an integer array `nums`, returns the sum of Hamming distances between all pairs of the integers in `nums`.","solution":"def hamming_distance(a, b): Calculate the Hamming distance between two integers. return bin(a ^ b).count(\'1\') def total_hamming_distance(nums): Calculate the sum of Hamming distances between all pairs of integers in the array nums. total_distance = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): total_distance += hamming_distance(nums[i], nums[j]) return total_distance"},{"question":"You are given a string `s` consisting of lowercase letters, and you want to perform some operations to create a new string `t`. In each operation, you can select any character from `s` and move it to any position in the string `t` (either at the beginning, the end, or between any two characters of `t`). After performing any number of such operations, the goal is to create the lexicographically smallest string `t`. Return the lexicographically smallest string `t` that can be obtained from `s` using the described operations.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by rearranging the characters of the given string `s`. Parameters: s (str): Input string consisting of lowercase letters. Returns: str: Lexicographically smallest string that can be obtained. # The smallest lexicographical string can be obtained by sorting the characters return \'\'.join(sorted(s))"},{"question":"You are given a collection of `n` integers representing the elevation of a mountainous terrain. The heights are provided in an array `heights`, where `heights[i]` is the elevation at point `i`. A mountain peak is defined as an element that is greater than its neighbors. An elevation `heights[i]` is considered a peak if it is greater than both `heights[i-1]` and `heights[i+1]` (for `i` in the range 1 to n-2). Write a function that finds all the indices of the peaks in the array and returns them in a list. If there are no peaks in the array, return an empty list. For example, given the input `heights = [1, 3, 2, 4, 1]`, the function should return `[1, 3]` since the elements at indices 1 and 3 are peaks.","solution":"def find_peaks(heights): Returns a list of indices where the elevation at that point is a peak. A peak is defined as an element that is greater than its neighbors. if len(heights) < 3: return [] peaks = [] for i in range(1, len(heights) - 1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: peaks.append(i) return peaks"},{"question":"Given an integer array `arr` of length `n` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement the function `rotateArray(arr, k)` that performs the rotation in-place. After rotation, the element at index `i` in the original array should move to index `(i + k) % n` in the rotated array. Return the rotated array.","solution":"def rotateArray(arr, k): Rotates the elements of the array to the right by k steps. Parameters: arr (list): Input array of integers. k (int): Number of steps to rotate the array. Returns: list: The array after rotation. n = len(arr) if n == 0: return arr k = k % n # To handle cases where k >= n return arr[-k:] + arr[:-k] # Rotate the array"},{"question":"Given a list of integers `nums`, you need to find the **maximum** possible sum of a subset of `nums` such that no two elements in the subset are adjacent in the original list. Return the maximum sum. For example, for the list `nums = [3, 2, 5, 10, 7]`, the subsets that follow the rule could be `[3, 5, 7]` or `[2, 10]`, and the maximum sum for these subsets would be `15`. The subsets must be chosen such that no two chosen elements are adjacent in the original array.","solution":"def max_subset_sum_no_adjacent(nums): Returns the maximum possible sum of a subset of nums such that no two elements in the subset are adjacent in the original list. if not nums: return 0 elif len(nums) == 1: return nums[0] # Initialize two variables to track the maximum sums # incl: maximum sum including the current element # excl: maximum sum excluding the current element incl = nums[0] excl = 0 for i in range(1, len(nums)): # Current max excluding i new_excl = max(incl, excl) # Current max including i incl = excl + nums[i] excl = new_excl return max(incl, excl)"},{"question":"You are given an integer array `nums` and an integer `k`. A contiguous subarray is called _nice_ if there are exactly `k` odd numbers in that subarray. Return _the number of nice subarrays_. Example input: ```python nums = [1, 1, 2, 1, 1] k = 3 ``` Example output: ```python 2 ``` The two nice subarrays are `[1, 1, 2, 1]` and `[1, 2, 1, 1]`.","solution":"def number_of_nice_subarrays(nums, k): Returns the number of nice subarrays with exactly k odd numbers. :param nums: List of integers. :param k: Integer, number of odd numbers required in the subarray. :return: Integer, number of nice subarrays. count = 0 prefix_counts = [0] * (len(nums) + 1) prefix_counts[0] = 1 odd_count = 0 for num in nums: if num % 2 == 1: odd_count += 1 if odd_count >= k: count += prefix_counts[odd_count - k] prefix_counts[odd_count] += 1 return count"},{"question":"You are given a string `s` and a list of strings `words`. You need to determine if `s` can be **constructed** by concatenating some of the strings in `words` any number of times. Any string in `words` can be used multiple times. Return `_true` if it is possible to construct `s` using the strings in `words`, otherwise return `false`_.","solution":"def can_construct(s, words): Returns True if `s` can be constructed by concatenating strings in `words`, otherwise False. def can_construct_helper(s, words, memo): if s == \\"\\": return True if s in memo: return memo[s] for word in words: if s.startswith(word): if can_construct_helper(s[len(word):], words, memo): memo[s] = True return True memo[s] = False return False return can_construct_helper(s, words, {})"},{"question":"Given an array of integers `nums`, return the maximum sum of all non-adjacent elements in the array. You can assume the array contains at least one positive integer. You are not allowed to use approaches that involve generating all possible subsets. Optimize for time complexity.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. Parameters: nums (list): List of integers Returns: int: The maximum sum of non-adjacent elements if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # Initialize the maximum sums for the first two elements prev_max = max(0, nums[0]) curr_max = max(prev_max, nums[1]) for i in range(2, n): new_max = max(curr_max, prev_max + nums[i]) prev_max = curr_max curr_max = new_max return curr_max"},{"question":"Given a matrix `mat` of size `m x n` and an integer `target`, write a function to return the position `[i, j]` of the target if it exists in the matrix, otherwise return `[-1, -1]`. The matrix follows these properties: - Integers in each row are sorted in ascending order from left to right. - Integers in each column are sorted in ascending order from top to bottom. Note: You can assume that `m` and `n` will not exceed 1000.","solution":"def search_matrix(mat, target): Search for the target in a matrix sorted by rows and columns. Returns the position [i, j] if the target exists, otherwise [-1, -1]. if not mat: return [-1, -1] rows, cols = len(mat), len(mat[0]) i, j = 0, cols - 1 while i < rows and j >= 0: if mat[i][j] == target: return [i, j] elif mat[i][j] < target: i += 1 else: j -= 1 return [-1, -1]"},{"question":"You are given an array of integers `nums` and an integer `k`. A contiguous subarray is called **valid** if the sum of its elements is less than `k`. Return _the count of **valid** contiguous subarrays in_ `nums`.","solution":"def count_valid_subarrays(nums, k): Returns the number of valid contiguous subarrays whose sum is less than k. :param nums: List of integers :param k: Integer threshold for subarrays sum :return: Integer count of valid subarrays n = len(nums) count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum < k: count += 1 else: break return count"},{"question":"Given a list of strings `words` representing names of people, a reference string `target` representing a target name, and an integer `k`, your task is to find the `k` names from `words` that are lexicographically closest to `target`. If there are ties, return the names in the order they appeared in the input list. Return an array of the `k` names.","solution":"def k_closest_names(words, target, k): Finds the k names from words that are lexicographically closest to target. Parameters: words (list of str): List of names. target (str): The target name. k (int): Number of closest names to find. Returns: list of str: List of k closest names to target. # Sort the words by their distance to the target, and then by their original position. closest_names = sorted(words, key=lambda x: (abs(ord(x[0]) - ord(target[0])), words.index(x))) return closest_names[:k]"},{"question":"You are given an array of integers `heights` where each element represents the height of a building. A building is considered good if there are no taller buildings to its right. You need to find out the number of good buildings in the array. For example, if `heights` is `[3, 7, 8, 3, 6, 1]`, the good buildings are `[8, 6, 1]` because there are no taller buildings to the right of these. Given the array `heights`, implement a function that returns the number of good buildings.","solution":"def count_good_buildings(heights): Returns the number of good buildings in the heights array. A good building is one which has no taller buildings to its right. if not heights: return 0 good_buildings = 0 max_height_to_right = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height_to_right: good_buildings += 1 max_height_to_right = height return good_buildings"},{"question":"You are given a string `txt` and an array `patterns` where `patterns[i]` is a substring. For each pattern `patterns[i]`, count the number of distinct characters in `patterns[i]` and determine the minimum number of unique characters that need to be added to make it an anagram of any substring of `txt`. If it is already an anagram or can be made into one without adding any new characters, return 0 for that pattern. Return an integer array `result` where `result[i]` is the minimum number of unique characters to be added for the `ith` pattern `patterns[i]`.","solution":"def min_unique_chars_to_add(txt, patterns): For each pattern, determine the minimum number of unique characters to be added to make it an anagram of any substring of `txt`. Parameters: - txt (str): the original text. - patterns (list of str): list of patterns to check. Returns: - list of int: minimum number of unique characters to be added for each pattern. txt_char_count = {} for char in txt: txt_char_count[char] = txt_char_count.get(char, 0) + 1 results = [] for pattern in patterns: pattern_char_count = {} for char in pattern: pattern_char_count[char] = pattern_char_count.get(char, 0) + 1 unique_needed = 0 for char in pattern_char_count: if char not in txt_char_count: unique_needed += 1 results.append(unique_needed) return results"},{"question":"You are given two integers `n` and `target`. Your task is to find _all unique combinations_ of `n` numbers that sum up to `target`. Each number in the combination must be an integer from `1` to `n` (inclusive), and each combination should be unique irrespective of the order of numbers in it. The resulting combinations should not contain duplicates. Your function should return the list of all such combinations sorted in ascending order (lexicographically). **Function Signature:** ```python def combination_sum(n: int, target: int) -> List[List[int]]: ``` **Example:** ```python n = 4 target = 5 Output: [[1, 4], [2, 3]] ``` # Note - The combinations `[1, 4]` and `[4, 1]` are considered the same and should only appear once. - Ensure your solution adheres to the constraints for time and space efficiency.","solution":"from typing import List def combination_sum(n: int, target: int) -> List[List[int]]: def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, n + 1): if i > target: # Early stop condition break backtrack(i + 1, target - i, path + [i]) result = [] backtrack(1, target, []) return result"},{"question":"You are given a list of `points` on a 2D plane, where `points[i] = [xi, yi]` represents the coordinates of the ith point. Implement the class `ClosestPoints` which supports the following methods: * `ClosestPoints()` Initializes the object. * `void addPoint(int x, int y)` Adds a point with coordinates `(x, y)` to the list of points. * `List getKClosestPoints(int k)` Returns the `k` closest points to the origin `(0, 0)`. The distance between two points `(x1, y1)` and `(x2, y2)` is calculated as the Euclidean distance: `√((x2 - x1)² + (y2 - y1)²)`. You should return the points in ascending order based on their distance to the origin. If two points have the same distance, order them by their x-coordinate, and if they still tie, order them by their y-coordinate. If `k` is greater than the number of points, return all the points.","solution":"import math from heapq import heappush, heappop class ClosestPoints: def __init__(self): self.points = [] def addPoint(self, x, y): self.points.append((x, y)) def getKClosestPoints(self, k): # Compute the distance and store in a min heap heap = [] for (x, y) in self.points: dist = math.sqrt(x ** 2 + y ** 2) heappush(heap, (dist, x, y)) # Extract the k closest points result = [] for _ in range(min(k, len(self.points))): dist, x, y = heappop(heap) result.append([x, y]) return result"},{"question":"You are given a 2D grid `grid` of size `m x n` consisting of non-negative integers. You are initially positioned at the top-left corner (0, 0) and your goal is to reach the bottom-right corner (m-1, n-1). Each cell in the grid represents the maximum number of steps you can take to move to the next cell either to the right or down. Return the minimum number of moves required to reach the bottom-right corner of the grid. If it\'s not possible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def minimum_moves(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # Right, Down visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (row, col, steps) while queue: row, col, steps = queue.popleft() if row == m - 1 and col == n - 1: return steps if visited[row][col]: continue visited[row][col] = True max_steps = grid[row][col] for dr, dc in directions: for step in range(1, max_steps + 1): new_row, new_col = row + dr * step, col + dc * step if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col]: queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"In a given string `s`, a \\"balanced\\" substring is one where the number of occurrences of \'L\' and \'R\' characters are the same. Write a function that returns the maximum number of balanced substrings that can be obtained from the input string `s`. The input string has only \'L\' and \'R\' characters and is guaranteed not to be empty.","solution":"def max_balanced_substrings(s): Returns the maximum number of balanced substrings in the input string `s`. A balanced substring has an equal number of \'L\' and \'R\' characters. balance = 0 # This will track the balance between \'L\' and \'R\' balanced_count = 0 # This will count the number of balanced substrings for char in s: if char == \'L\': balance += 1 else: # char == \'R\' balance -= 1 # When balance is zero, we found a balanced substring if balance == 0: balanced_count += 1 return balanced_count"},{"question":"You are given a **0-indexed** integer array `nums` representing the amount of money of each house in a row. A robber wants to maximize the amount of money they can steal, but they cannot steal from two adjacent houses. Determine the maximum amount of money the robber can steal without triggering any alarms. Return _this maximum amount_.","solution":"def rob(nums): This function takes a list of integers representing the amount of money in each house and returns the maximum amount of money the robber can steal without triggering any alarms by ensuring they do not rob two adjacent houses. if not nums: return 0 if len(nums) <= 2: return max(nums) # Using bottom-up dynamic programming approach prev2, prev1 = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): current = max(prev1, prev2 + nums[i]) prev2, prev1 = prev1, current return prev1"},{"question":"Write a function that takes a string `s` and an integer `k`, and returns _the length of the longest substring of `s` that contains at most `k` distinct characters_. If `k` is exceeded in any substring, it must not be included in the determination of the maximum length. Your function should have an optimal time complexity to handle large input sizes effectively.","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0 or not s: return 0 start = 0 max_length = 0 char_frequency = {} for end in range(len(s)): char = s[end] char_frequency[char] = char_frequency.get(char, 0) + 1 while len(char_frequency) > k: start_char = s[start] char_frequency[start_char] -= 1 if char_frequency[start_char] == 0: del char_frequency[start_char] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an array of integers `nums` representing a list of points on a number line. Your task is to find the smallest range `[a, b]` that includes at least one number from each of the `nums` subsets. The range `[a, b]` is defined by the minimum and maximum values selected from the points. If there are multiple ranges with the same length, return the range that starts with the smaller number. Implement a function `smallestRange(nums: List[List[int]]) -> List[int]` to achieve this.","solution":"from typing import List import heapq def smallestRange(nums: List[List[int]]) -> List[int]: pq = [] max_val = -float(\'inf\') # Initialize the priority queue with the first element of each list and find the initial max value for i in range(len(nums)): heapq.heappush(pq, (nums[i][0], i, 0)) max_val = max(max_val, nums[i][0]) best_range = [-float(\'inf\'), float(\'inf\')] # Loop until the end of one of the lists is reached while pq: min_val, row, col = heapq.heappop(pq) # Update the best range if necessary if max_val - min_val < best_range[1] - best_range[0]: best_range = [min_val, max_val] # If we are at the last element of the row, break the loop if col + 1 == len(nums[row]): break # Push the next element of the current row into the priority queue next_val = nums[row][col + 1] heapq.heappush(pq, (next_val, row, col + 1)) max_val = max(max_val, next_val) return best_range"},{"question":"You are given a binary tree root node containing integer values. Each path from the root node to a leaf node represents a number, where each node value along the path contributes a digit (from most significant to least significant). Construct the binary numbers for all root-to-leaf paths and return the sum of these binary numbers interpreted as integers. Implement a function called `sumRootToLeaf(root)` that returns the summed integer value for all root-to-leaf paths. The binary tree is defined by: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Consider the example tree: ``` 1 / 0 1 / / 0 1 0 1 ``` In this tree, the root-to-leaf paths represent the binary numbers `100`, `101`, `110`, and `111`. The function should return the sum of these numbers: `4 + 5 + 6 + 7 = 22`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): Return the sum of all root-to-leaf binary numbers interpreted as integers. def dfs(node, current_value): if not node: return 0 # Shift left (equivalent to multiply by 2) and add current node value current_value = (current_value << 1) | node.val # If it\'s a leaf node, return the current value if not node.left and not node.right: return current_value # Continue DFS on left and right children left_sum = dfs(node.left, current_value) right_sum = dfs(node.right, current_value) return left_sum + right_sum return dfs(root, 0)"},{"question":"Given a string `text` consisting of lowercase letters, and an integer `n`, find the length of the longest substring that contains at most `n` distinct characters. Return the length of the longest substring.","solution":"def longest_substring_with_n_distinct_chars(text, n): Returns the length of the longest substring with at most `n` distinct characters. from collections import defaultdict if n == 0: return 0 char_count = defaultdict(int) max_length = 0 start = 0 for end in range(len(text)): char_count[text[end]] += 1 while len(char_count) > n: char_count[text[start]] -= 1 if char_count[text[start]] == 0: del char_count[text[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"}]'),z={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},L={class:"card-container"},N={key:0,class:"empty-state"},S=["disabled"],D={key:0},C={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",N,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",C,"Loading...")):(n(),r("span",D,"See more"))],8,S)):l("",!0)])}const G=m(z,[["render",E],["__scopeId","data-v-d021d4ac"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/3.md","filePath":"library/3.md"}'),P={name:"library/3.md"},W=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{O as __pageData,W as default};
