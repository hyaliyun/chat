import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-bb10cc57"]]),S=JSON.parse('[{"question":"# Question: Implement a Custom Sorting Algorithm You are provided with two sorting algorithms: Quick Sort and Merge Sort. Your task is to implement a similar yet distinct custom sorting algorithm called \\"Custom Sort\\" that sorts a list of integers. Once implemented, benchmark its performance against the provided Quick Sort and Merge Sort algorithms using the included `benchmark_custom_sort` function. **Function Signature**: ```python def custom_sort(arr: List[int]) -> List[int]: pass ``` # Objectives: 1. Implement the `custom_sort` function to sort a list of integers. 2. Benchmark the performance of your custom sorting algorithm against Quick Sort and Merge Sort using the `benchmark_custom_sort` function. # Constraints: * The input list (`arr`) will contain integers ranging from -10^6 to 10^6. * The length of the input list will be between 1 and 10^5. * Your implementation should efficiently handle typical input sizes within the given constraints. # Example: ```python >>> custom_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> custom_sort([12, 4, 78, 34, 23, 56, 89]) [4, 12, 23, 34, 56, 78, 89] >>> custom_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] ``` # Guidelines: 1. Your custom sorting algorithm should not simply be a replication of Quick Sort or Merge Sort. 2. You should ensure your implementation is optimal for typical input sizes under the given constraints. 3. Use the following `benchmark_custom_sort` function to compare the performance of your implementation against Quick Sort and Merge Sort: ```python import timeit from typing import List def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result def benchmark_custom_sort() -> None: Benchmark code for comparing 3 functions, including a custom implementation. def do_benchmark(arr: List[int]) -> None: setup = \\"import __main__ as z\\" print(f\\"Benchmark when arr = {arr[:10]} (truncated for display):\\") print(f\\"{quick_sort(arr)[:10]} (truncated for display)\\") timing = timeit.timeit(f\\"z.quick_sort({arr[:10]})\\", setup=setup, number=10) print(f\\"Quick Sort runs in {timing} seconds\\") print(f\\"{merge_sort(arr)[:10]} (truncated for display)\\") timing = timeit.timeit(f\\"z.merge_sort({arr[:10]})\\", setup=setup, number=10) print(f\\"Merge Sort runs in {timing} seconds\\") print(f\\"{custom_sort(arr)[:10]} (truncated for display)\\") timing = timeit.timeit(f\\"z.custom_sort({arr[:10]})\\", setup=setup, number=10) print(f\\"Custom Sort runs in {timing} seconds\\") for arr in ([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], [12, 4, 78, 34, 23, 56, 89], [5, 2, 9, 1, 5, 6]): do_benchmark(arr) print() # Example implementations of quick_sort and merge_sort for the benchmark function. def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result ```","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def shell_sort(arr): n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 shell_sort(arr) return arr"},{"question":"# Question: Anagram Finder in a Text File Write a program that reads a text file and identifies all sets of anagrams present in the file. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. **Task Requirements:** 1. Implement a function `find_anagrams(file_path: str) -> List[List[str]]`: - **Description**: This function should read a text file where each line contains a single word. It should identify and return all sets of anagrams contained within the file. - **Input**: A string `file_path` which is the path to the text file containing words. - **Output**: A list of lists, where each sublist contains words that are anagrams of each other. # Constraints - The words in the file are made up of lowercase English letters only. - The file can be large, so the implementation should be efficient both in terms of time and space complexity. # Example Let\'s assume the contents of `words.txt` are: ``` listen silent enlist rat tar art cat tac act dog god ``` ```python # Example of find_anagrams function # Assuming the file \'words.txt\' contains the words above assert find_anagrams(\'words.txt\') == [[\'listen\', \'silent\', \'enlist\'], [\'rat\', \'tar\', \'art\'], [\'cat\', \'tac\', \'act\'], [\'dog\', \'god\']] ``` # Implementation Details - Ensure your solution can handle files with a large number of words efficiently. - Think about how you can use data structures to group words that are anagrams. - Remember to close the file properly after reading its contents. # Performance Requirements - Aim for O(n * m) time complexity, where n is the number of words in the file and m is the average length of the words. # Additional Notes - You can assume that the input file exists and is accessible for reading. - You can use standard Python libraries and data structures to aid with your implementation.","solution":"from typing import List from collections import defaultdict def find_anagrams(file_path: str) -> List[List[str]]: Reads a text file where each line contains a single word, and identifies and returns all sets of anagrams contained within the file. :param file_path: Path to the text file containing words :return: A list of lists, where each sublist contains words that are anagrams of each other anagram_dict = defaultdict(list) with open(file_path, \'r\') as file: for line in file: word = line.strip() sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) # Filter out entries that have less than 2 words (not an anagram) return [group for group in anagram_dict.values() if len(group) > 1]"},{"question":"# Network Packet Validity Checker You are tasked with implementing a utility to verify the validity of network packets based on a list of specified rules. # Objective: Write a function `validate_packets(packets: List[Dict[str, Any]], rules: Dict[str, List[Union[int, str]]]) -> List[int]` that takes a list of packet dictionaries and a dictionary of rules and returns a list of indices of the packets that are valid. # Requirements: 1. A packet is represented as a dictionary with keys corresponding to field names and values corresponding to field values. 2. The rules dictionary has field names as keys and a list of acceptable values or ranges as values. A range is specified as a list `[min, max]`. 3. A packet is valid only if it meets all the specified rules. 4. The function should ignore fields not specified in the rules and treat packets missing required fields as invalid. # Constraints: 1. `1 <= len(packets) <= 10^4` - The list can contain up to 10,000 packets. 2. Each packet dictionary can have up to 100 fields. 3. Each field name and value can be of string type and/or numerical type, but rules should be applied strictly based on their types. # Example: ```python >>> packets = [ ... {\\"src\\": \\"192.168.1.1\\", \\"dst\\": \\"192.168.2.1\\", \\"size\\": 150}, ... {\\"src\\": \\"192.168.1.2\\", \\"dst\\": \\"192.168.2.2\\", \\"size\\": 50}, ... {\\"src\\": \\"192.168.1.1\\", \\"dst\\": \\"192.168.2.1\\", \\"size\\": 2000} ... ] >>> rules = { ... \\"src\\": [\\"192.168.1.1\\", \\"192.168.1.2\\"], ... \\"dst\\": [\\"192.168.2.1\\", \\"192.168.2.3\\"], ... \\"size\\": [0, 1000] ... } >>> validate_packets(packets, rules) [0, 1] ``` # Hints: - Utilize Python\'s `in` keyword for checking membership in lists. - Carefully handle both ranges and explicit values during validation. - Ensure that the function skips unnecessary checks for fields not in the rules, improving efficiency.","solution":"from typing import List, Dict, Any, Union def validate_packets(packets: List[Dict[str, Any]], rules: Dict[str, List[Union[int, str]]]) -> List[int]: valid_indices = [] for i, packet in enumerate(packets): is_valid = True for field, rule in rules.items(): if field not in packet: is_valid = False break value = packet[field] if isinstance(rule, list) and len(rule) == 2 and isinstance(rule[0], int) and isinstance(rule[1], int): if not (rule[0] <= value <= rule[1]): is_valid = False break elif value not in rule: is_valid = False break if is_valid: valid_indices.append(i) return valid_indices"},{"question":"# Coding Assessment Question Context: You are required to implement an algorithm that sorts a list of strings based on their lengths. In case of a tie where two strings have the same length, the strings should maintain their relative order from the original list. This sorting approach is a stable sort. Task: Implement the function `stable_length_sort(strings: List[str]) -> List[str]` which: 1. Accepts a list of strings. 2. Returns a new list of strings sorted by their length in ascending order. Input: - `strings`: A list of strings where each string is non-empty and the list can have up to `1000` strings. Output: - A list of strings sorted by their length in ascending order and maintaining relative order for strings with the same length. Constraints: 1. `1 <= len(strings) <= 1000` (There will always be at least one string). 2. Each string will have a length between `1` and `100`. Example: ```python strings = [\\"word\\", \\"longest\\", \\"a\\", \\"verylongword\\", \\"mid\\"] assert stable_length_sort(strings) == [\\"a\\", \\"mid\\", \\"word\\", \\"longest\\", \\"verylongword\\"] ``` Note: - The sorting algorithm should be stable, maintaining the relative order of strings with the same length from the original list. You may use the following function skeleton: ```python def stable_length_sort(strings: List[str]) -> List[str]: pass ```","solution":"def stable_length_sort(strings): Sorts a list of strings based on their lengths in ascending order. If two strings have the same length, their relative order is preserved. Args: strings (List[str]): List of strings to be sorted. Returns: List[str]: List of strings sorted by their length. return sorted(strings, key=len)"},{"question":"# Generate Unique Acronyms Write a function that generates a unique acronym from a list of words. The acronym should be formed by taking the first letter of each word in the list, concatenating them in the order the words appear, and converting the resulting string to uppercase. Ensure that the resulting acronym is unique by appending a unique number to it if acronyms have already been used. Function Signature ```python def generate_unique_acronym(words: List[str], used_acronyms: Set[str]) -> str: pass ``` Input - `words`(List[str]): A list of words from which to generate the acronym. Each word consists solely of alphabetical characters. - `used_acronyms` (Set[str]): A set of previously generated acronyms. The result should not be one of these acronyms. Output - Returns a unique acronym, ensuring the output is a unique string. Constraints - Maximum length of `words` is 10. - Each word in `words` has at most 20 characters. - There can be up to 100 previously generated acronyms in `used_acronyms`. # Examples ```python generate_unique_acronym([\\"artificial\\", \\"intelligence\\"], {\\"AI\\", \\"AIT\\"}) # Returns \\"AI1\\" (or another unique variant if \\"AI1\\" exists in `used_acronyms`) generate_unique_acronym([\\"machine\\", \\"learning\\"], {\\"ML\\", \\"ML1\\"}) # Returns \\"ML2\\" ``` # Requirements - Implement the `generate_unique_acronym` function to create unique acronyms from a series of words. - Acronyms should be generated by concatenating the first letter of each word in the list. - Make sure the generated acronym does not conflict with the ones in `used_acronyms`. - If an acronym already exists in the `used_acronyms` set, append the smallest integer to it to make it unique. Ensure your solution efficiently checks for duplicate acronyms and generates a unique one. # Scenario In various fields such as technology, business, and science, acronyms ensure succinct communication of complex concepts. By ensuring acronyms are unique, organizations can avoid confusion and ensure clear communication of ideas or projects. This problem is practical for software dealing with automated generation of acronyms while ensuring they are unique within a specific context.","solution":"def generate_unique_acronym(words, used_acronyms): Generate a unique acronym from the list of words, ensuring no conflict with already used acronyms. base_acronym = \'\'.join(word[0] for word in words).upper() if base_acronym not in used_acronyms: return base_acronym i = 1 while f\\"{base_acronym}{i}\\" in used_acronyms: i += 1 return f\\"{base_acronym}{i}\\""},{"question":"# Context You are tasked with developing an employee management system that tracks employee data and allows for filtering based on various criteria. To start, you need to implement a function that can filter employees based on their experience level. # Task Write a Python function that filters a list of employee dictionaries based on a given minimum number of years of experience. Each employee dictionary contains the employee\'s name, position, and years of experience. # Function Signature ```python def filter_employees_by_experience(employees: list, min_experience: int) -> list: ``` # Requirements - Your function should return a list of dictionaries containing only the employees who have at least the specified number of years of experience. - Each dictionary in the input list has the following keys: `\\"name\\"`, `\\"position\\"`, and `\\"years_experience\\"`. - The function should handle and return an empty list if no employees meet the criteria. - Ensure that your function properly handles cases where the input list is empty. # Constraints - `employees` is a list containing up to 1000 employee dictionaries. - Each employee dictionary has the structure `{\\"name\\": str, \\"position\\": str, \\"years_experience\\": int}`. - `min_experience` is a non-negative integer. # Example Usage ```python employee_list = [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Engineer\\", \\"years_experience\\": 5}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"years_experience\\": 8}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Intern\\", \\"years_experience\\": 1} ] result = filter_employees_by_experience(employee_list, 4) print(result) # Output: [{\'name\': \'Alice\', \'position\': \'Engineer\', \'years_experience\': 5}, {\'name\': \'Bob\', \'position\': \'Manager\', \'years_experience\': 8}] ``` # Notes - Consider using a list comprehension for concise code. - Ensure that your function\'s performance is efficient even with the maximum number of employees. - Test your function with varying lengths of the employee list and different values of `min_experience`.","solution":"def filter_employees_by_experience(employees: list, min_experience: int) -> list: Filters a list of employees based on a given minimum number of years of experience. Args: employees (list): List of dictionaries representing employees. Each dictionary has keys \'name\', \'position\', and \'years_experience\'. min_experience (int): The minimum number of years of experience required to pass the filter. Returns: list: A list of dictionaries representing the employees who meet the experience criteria. return [employee for employee in employees if employee[\'years_experience\'] >= min_experience]"},{"question":"# Tiling a Floor with L-shaped Tiles Given a 2D grid representing a floor of size `m x n`, write a function `can_tile_fully(m: int, n: int) -> bool` that checks if the floor can be fully tiled by L-shaped tiles of size 2x2 with one square removed (forming an L shape). Each L-shaped tile covers exactly 3 squares. Next, write a function `find_full_tiling_grids(m_min: int, m_max: int, n_min: int, n_max: int) -> list` that finds all grid dimensions within the given ranges `[m_min, m_max]` and `[n_min, n_max]` where the floor can be fully tiled by L-shaped tiles. It returns a list of tuples `(m, n)` representing the grid dimensions that can be fully tiled. Input * `m: int` and `n: int` - The dimensions of the floor grid. * `m_min: int`, `m_max: int`, `n_min: int`, and `n_max: int` - The range boundaries for grid dimensions. Output * `can_tile_fully` returns a Boolean `True` if the floor can be fully tiled by L-shaped tiles, else `False`. * `find_full_tiling_grids` returns a list of tuples representing the grid dimensions within the given ranges that can be fully tiled. Constraints * 1 <= m, n <= 100 * 1 <= m_min <= m_max <= 100 * 1 <= n_min <= n_max <= 100 Example ```python def can_tile_fully(m: int, n: int) -> bool: return (m * n) % 3 == 0 def find_full_tiling_grids(m_min: int, m_max: int, n_min: int, n_max: int) -> list: return [(i, j) for i in range(m_min, m_max + 1) for j in range(n_min, n_max + 1) if can_tile_fully(i, j)] ``` Check for grids that can be fully tiled within the range `[1, 10]` for both dimensions. Example Run ```python assert can_tile_fully(3, 3) == True assert can_tile_fully(2, 2) == False assert find_full_tiling_grids(1, 10, 1, 10) == [(1, 3), (1, 6), (1, 9), (2, 6), (2, 9), ..., (10, 6), (10, 9)] # other expected values ```","solution":"def can_tile_fully(m: int, n: int) -> bool: Returns True if a m x n grid can be fully tiled by L-shaped tiles of size 2x2 with one square removed (each covering 3 squares), False otherwise. # Check if the total number of squares is divisible by 3 return (m * n) % 3 == 0 def find_full_tiling_grids(m_min: int, m_max: int, n_min: int, n_max: int) -> list: Returns a list of grid dimensions within the given ranges [m_min, m_max] and [n_min, n_max] that can be fully tiled by L-shaped tiles. return [(i, j) for i in range(m_min, m_max + 1) for j in range(n_min, n_max + 1) if can_tile_fully(i, j)]"},{"question":"# Problem Statement You are implementing an algorithm that processes strings containing encoded characters to decode them into their original form. Each encoded character in the string follows the format `k[char]` where `k` is the number of times the character `char` should be repeated. Your goal is to handle nested encodings and multiple groups of characters. # Function Signature ```python def decode_string(s: str) -> str: Decodes a string according to the provided encoding rules. Args: - s (str): The encoded string containing characters and patterns in the form `k[char]`. Returns: - str: The decoded string. ``` # Input - A string `s` containing encoded characters. - The string `s` will only consist of digits, lowercase English letters, and brackets (`[]`). # Output - A string representing the decoded form of the input. # Constraints - The length of `s` will be in the range `[1, 30]`. - The decoding will not result in over 10^4 characters. # Example ```python s = \\"3[a]2[bc]\\" assert decode_string(s) == \\"aaabcbc\\" s = \\"2[abc]3[cd]ef\\" assert decode_string(s) == \\"abcabccdcdcdef\\" s = \\"10[a]\\" assert decode_string(s) == \\"aaaaaaaaaa\\" s = \\"2[3[a]b]\\" assert decode_string(s) == \\"aaabaaab\\" ``` # Requirements 1. You must implement the `decode_string` function. 2. Your implementation should handle multiple and nested encodings. 3. Your solution should strive for efficient use of space and time.","solution":"def decode_string(s: str) -> str: Decodes a string according to the provided encoding rules. Args: - s (str): The encoded string containing characters and patterns in the form `k[char]`. Returns: - str: The decoded string. stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): # if the character is a number, calculate the full number current_num = current_num * 10 + int(char) elif char == \\"[\\": # push the current string and the number onto the stack stack.append((current_string, current_num)) # reset current string and number current_string = \\"\\" current_num = 0 elif char == \\"]\\": # pop the string and number from the stack and repeat the current_string accordingly last_string, num = stack.pop() current_string = last_string + num * current_string else: # if the character is a letter, add it to the current string current_string += char return current_string"},{"question":"# Problem Statement Consider a “special” number that is comprised of consecutive digits starting from 1 in an increasing order. For example, the number 12345678910 is a “special” number because it concatenates 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10 consecutively. The first 10 digits of this number are 1234567891. You are tasked with finding the `n`-th digit in this infinitely long sequence of consecutive numbers. Implement a function `find_nth_digit(n)` that finds the digit at the `n`-th position in this sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` # Input * `n` (int): The position in the sequence to find the digit (1-indexed). # Output * Returns an integer representing the digit at the `n`-th position in the sequence. # Constraints * `1 <= n <= 10^9` # Example ```python find_nth_digit(10) == 1 find_nth_digit(11) == 0 find_nth_digit(12) == 1 ``` # Additional Notes You are expected to devise an efficient algorithm to find the digit at the `n`-th position without generating the entire sequence up to `n` digits. # Algorithm 1. Determine the range of numbers (e.g., single digits, double digits, triple digits, etc.) that includes the `n`-th position. 2. Identify the exact number that contains the `n`-th digit based on the determined range. 3. Extract and return the `n`-th digit from the identified number. # Edge Cases * Ensure the correct digit is identified for very small values of `n`. * For large values of `n`, the algorithm must efficiently navigate through the digit ranges.","solution":"def find_nth_digit(n: int) -> int: if n <= 0: raise ValueError(\\"n must be a positive integer\\") digit_length = 1 num_count = 9 while n > digit_length * num_count: n -= digit_length * num_count digit_length += 1 num_count *= 10 index = n - 1 start = 10**(digit_length - 1) number = start + index // digit_length return int(str(number)[index % digit_length])"},{"question":"# Context: As a software developer, you have been assigned to create a system that identifies whether a given string is a valid mathematical expression based on correctly matched parentheses, brackets, and braces. This is crucial for validating inputs in a mathematical modeling application. # Problem Statement: Implement the function `is_valid_expression` using the given skeleton code. The function should take a string as input and return a boolean indicating whether the string is a valid expression with correctly balanced and nested parentheses, brackets, and braces. # Function Signature: ```python def is_valid_expression(expression: str) -> bool: ``` # Input: * **expression**: A string containing characters including \'(\', \')\', \'[\', \']\', \'{\', \'}\', and other alphanumeric or special characters commonly found in mathematical expressions. # Output: * **validity**: A boolean indicating whether the input string is a valid expression with respect to the balance and nesting of parentheses, brackets, and braces. # Constraints: * The string length will be in the range of 1 to 1000. * The function should ignore characters that are not parentheses, brackets, or braces. # Example: ```python # Example 1: expression = \\"(a + b) * [c - d] / {e + f}\\" # The function should return True, as all types of brackets are correctly balanced and nested. # Example 2: expression = \\"3 * (x + y] - z\\" # The function should return False, as there is a mismatch between \'(\' and \']\'. # Example 3: expression = \\"{[(a - b) * (c + d)] - (e / f)}\\" # The function should return True, as all types of brackets are correctly balanced and nested. # Example 4: expression = \\"{[(])}\\" # The function should return False, as the brackets are not correctly nested. print(is_valid_expression(expression)) # Expected output for examples listed ``` # Notes: 1. The function should only consider \'(\', \')\', \'[\', \']\', \'{\', and \'}\' for checking the balance and nesting. 2. Use a stack-based approach to ensure efficient and correct handling of nested structures. 3. The function should be able to handle strings with multiple types of parentheses. # Evaluation Criteria: * **Correctness**: The function should correctly determine the validity of the expression in terms of parentheses, brackets, and braces. * **Efficiency**: Use appropriate data structures to ensure the function operates efficiently within the given constraints. * **Edge Handling**: The function should robustly handle various edge cases, including empty strings and strings without any parentheses, brackets, or braces. * **Code Quality**: The solution should be clean, readable, and well-documented.","solution":"def is_valid_expression(expression: str) -> bool: Returns True if the input string is a valid expression with correctly balanced and nested parentheses, brackets, and braces. Otherwise, returns False. # Define the matching pairs of parentheses, brackets, and braces matching_pairs = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} # Initialize an empty stack to keep track of opened symbols stack = [] # Iterate over each character in the expression for char in expression: # If the character is an opening symbol, push it onto the stack if char in \'({[\': stack.append(char) # If the character is a closing symbol elif char in \')}]\': # Check if the stack is empty or the top of the stack does not match the corresponding opening symbol if not stack or stack[-1] != matching_pairs[char]: return False # Otherwise, pop the top of the stack stack.pop() # The expression is valid if the stack is empty (all symbols were matched) return not stack"},{"question":"# Context Emily is developing a sophisticated library management system, and she needs functionality to help categorize books based on their subjects. She wants to assign each book a unique category identifier based on its subject and title. However, she noticed that some books have identical titles but differ in their subjects, and she wants to ensure that each unique combination of title and subject is associated with a distinct identifier. # Task Write a function `categorize_books` that accepts a list of books, where each book is represented as a tuple containing its title and subject. The function should assign a unique integer identifier to each unique combination of title and subject. # Input - A list of tuples, where each tuple contains: - A string `title` representing the title of the book. - A string `subject` representing the subject of the book. # Output - A dictionary where keys are tuples (title, subject) and values are unique integers starting from 0. # Example ```python books = [ (\\"Data Structures\\", \\"Computer Science\\"), (\\"Data Structures\\", \\"Algorithms\\"), (\\"Machine Learning\\", \\"Artificial Intelligence\\"), (\\"Data Structures\\", \\"Computer Science\\") ] categorize_books(books) ``` Expected Output: ``` { (\\"Data Structures\\", \\"Computer Science\\"): 0, (\\"Data Structures\\", \\"Algorithms\\"): 1, (\\"Machine Learning\\", \\"Artificial Intelligence\\"): 2 } ``` # Constraints - The list of books can contain up to 10000 entries. - Each title and subject combination is guaranteed to have at least one duplicate entry in the list. # Performance Requirements - Ensure the function handles large lists efficiently, maximizing the use of data structures and minimizing redundant computations.","solution":"def categorize_books(books): Categorizes books based on their title and subject, assigning a unique integer identifier to each unique combination. Args: books (list of tuples): A list where each tuple contains a title and a subject. Returns: dict: A dictionary where keys are (title, subject) tuples and values are unique integers starting from 0. book_dict = {} for i, book in enumerate(set(books)): book_dict[book] = i return book_dict"},{"question":"**Context**: You are developing a function to clean up a list of email addresses by identifying invalid entries based on specific criteria. The function should check for entries that do not contain an `@` symbol, have leading or trailing spaces, or have characters other than letters, digits, or certain special characters (`._%+-`). The function should categorize the invalid email addresses based on these rules and print them accordingly. Finally, the function should raise a ValueError with a message specifying the total number of invalid email addresses. **Task**: Create a function `validate_email_addresses` that accepts a list of email addresses, validates them according to the described rules, and handles the output and exceptions as specified. **Function Signature**: ```python def validate_email_addresses(email_addresses: List[str]) -> None: ``` **Input**: - `email_addresses`: A list of strings representing email addresses. **Output**: - Print invalid email addresses according to specified categories: missing `@`, containing leading/trailing spaces, containing invalid characters. - Raise a `ValueError` with a message indicating the count of invalid email addresses. **Examples**: ```python email_addresses = [ \\"valid.email@example.com\\", \\" invalid@example.com\\", \\"invalid@ example.com\\", \\"invalid@example. com\\", \\"inva lid@example.com\\", \\"missingatsymbol.com\\", \\"invalid@special!char.com\\" ] validate_email_addresses(email_addresses) ``` Expected Output: ``` 3 emails contain leading/trailing spaces: invalid@example.com invalid@ example.com invalid@example. com 2 emails contain invalid characters: inva lid@example.com invalid@special!char.com 1 emails are missing the @ symbol: missingatsymbol.com 6 invalid emails ``` Note: The function should raise a `ValueError` with the message \\"6 invalid emails\\". **Constraints**: - Each email address should be a non-empty string. - Email addresses containing valid ASCII characters only. - The input list `email_addresses` is not guaranteed to be free from duplicates.","solution":"from typing import List import re def validate_email_addresses(email_addresses: List[str]) -> None: invalid_spaces = [] invalid_chars = [] missing_at_symbol = [] # Regex to match valid character portion of email (excluding `@` symbol). valid_char_pattern = re.compile(r\'^[A-Za-z0-9._%+-]+\') for email in email_addresses: if email.strip() != email: # Check for leading or trailing spaces invalid_spaces.append(email) elif \'@\' not in email: # Check for missing `@` symbol missing_at_symbol.append(email) else: local, domain = email.split(\'@\', 1) if not (valid_char_pattern.match(local) and valid_char_pattern.match(domain)): invalid_chars.append(email) invalid_count = len(invalid_spaces) + len(invalid_chars) + len(missing_at_symbol) if invalid_spaces: print(f\\"{len(invalid_spaces)} emails contain leading/trailing spaces:\\") for email in invalid_spaces: print(email) if invalid_chars: print(f\\"{len(invalid_chars)} emails contain invalid characters:\\") for email in invalid_chars: print(email) if missing_at_symbol: print(f\\"{len(missing_at_symbol)} emails are missing the @ symbol:\\") for email in missing_at_symbol: print(email) print(f\\"{invalid_count} invalid emails\\") raise ValueError(f\\"{invalid_count} invalid emails\\")"},{"question":"# Problem Description You are tasked with creating a program that can simulate the behavior of a bank\'s transaction processing system. The system should handle deposits, withdrawals, and balance inquiries, all while maintaining user authentication. # Objective **Implement the class** `BankAccount` **with the following methods and attributes**: - `__init__(self, account_number: str, password: str)`: Initializes a new bank account with the provided account number and password. - `deposit(self, amount: float) -> float`: Deposits the specified amount to the account and returns the new balance. - `withdraw(self, amount: float, password: str) -> float`: Withdraws the specified amount from the account if the correct password is provided and returns the new balance. Raises an exception if the password is incorrect or if there are insufficient funds. - `balance_inquiry(self, password: str) -> float`: Returns the current balance if the correct password is provided. Raises an exception if the password is incorrect. # Constraints - The initial balance of the account is 0.0. - The account number is a string of exactly 10 digits. - The password is a string between 6 and 12 characters in length. - Deposits and withdrawals are strictly positive amounts. - Raise an appropriate exception if any of the constraints are violated. # Example ```python account = BankAccount(\\"1234567890\\", \\"securePassword\\") print(account.deposit(150.0)) # Expected Output: 150.0 try: print(account.withdraw(50.0, \\"securePassword\\")) # Expected Output: 100.0 except Exception as e: print(str(e)) try: print(account.balance_inquiry(\\"wrongPassword\\")) # Expected Output: Exception(\\"Invalid password\\") except Exception as e: print(str(e)) try: print(account.withdraw(200.0, \\"securePassword\\")) # Expected Output: Exception(\\"Insufficient funds\\") except Exception as e: print(str(e)) print(account.balance_inquiry(\\"securePassword\\")) # Expected Output: 100.0 ``` # Hints - Remember to validate inputs such as account number length, password length, and transaction amounts. - Think about how to securely handle password verification. - Consider edge cases where the balance might go below zero and handle them appropriately.","solution":"class BankAccount: def __init__(self, account_number: str, password: str): if len(account_number) != 10 or not account_number.isdigit(): raise ValueError(\\"Account number must be exactly 10 digits.\\") if len(password) < 6 or len(password) > 12: raise ValueError(\\"Password must be between 6 and 12 characters in length.\\") self.account_number = account_number self.password = password self.balance = 0.0 def deposit(self, amount: float) -> float: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount return self.balance def withdraw(self, amount: float, password: str) -> float: if password != self.password: raise ValueError(\\"Invalid password.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.balance < amount: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount return self.balance def balance_inquiry(self, password: str) -> float: if password != self.password: raise ValueError(\\"Invalid password.\\") return self.balance"},{"question":"# Problem Description: Implement a function that simulates the behavior of an LRU (Least Recently Used) Cache. The cache should have a fixed size, and it should eject the least recently used item when the cache reaches capacity and a new item is inserted. # Function Signature: ```python def LRUCache(capacity: int) -> None: def get(key: int) -> int: def put(key: int, value: int) -> None: ``` # Input: * `capacity` (int): The maximum number of items the cache can hold. * `key` (int): The key of the item to be retrieved or inserted. * `value` (int): The value of the item to be inserted. # Output: * `get()` should return the value associated with the key if the key exists in the cache, otherwise return -1. * `put()` should insert the value with the associated key into the cache. If the cache is at capacity, eject the least recently used item before inserting the new item. # Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` # Constraints: 1. All keys and values will be integers. 2. The cache capacity will be a positive integer greater than 0. # Notes: - Consider utilizing a data structure that allows for constant time retrievals and updates, such as a dictionary combined with a doubly linked list. - Ensure that the `get()` and `put()` operations perform efficiently within the constraints.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"# Problem Statement: You are working on an application that manages user permissions for various resources. Each user can be assigned specific permissions for different resources, and these permissions are represented as strings. Write a function that determines if a user has all the necessary permissions required to access a specific resource. # Function Signature: ```python def has_required_permissions(user_permissions: dict[str, list[str]], resource: str, required_permissions: list[str]) -> bool: Check if the user has all required permissions for a resource. :param user_permissions: Dictionary with keys as resource names and values as lists of permissions. :param resource: The resource for which permissions are being checked. :param required_permissions: List of permissions required to access the resource. :return: True if the user has all required permissions; otherwise, False. ``` # Input: * `user_permissions` (dict[str, list[str]]): A dictionary where the keys are resource names and the values are lists of permissions the user has for each resource. * `resource` (str): The resource for which the permissions are being checked. * `required_permissions` (list[str]): The list of permissions needed to access the resource. # Output: * bool: `True` if the user has all the required permissions for the resource; otherwise, `False`. # Constraints: 1. `1 <= len(user_permissions) <= 1000` 2. `1 <= len(resource) <= 100` 3. `1 <= len(required_permissions) <= 100` 4. `1 <= len(permission) <= 100` for each permission in `user_permissions` and `required_permissions` # Example: 1. `has_required_permissions({\\"file1\\": [\\"read\\", \\"write\\"], \\"file2\\": [\\"read\\"]}, \\"file1\\", [\\"read\\", \\"write\\"])` should return `True` 2. `has_required_permissions({\\"file1\\": [\\"read\\", \\"write\\"], \\"file2\\": [\\"read\\"]}, \\"file2\\", [\\"write\\"])` should return `False` 3. `has_required_permissions({\\"file1\\": [\\"read\\"], \\"file2\\": [\\"read\\", \\"write\\", \\"execute\\"]}, \\"file2\\", [\\"read\\", \\"execute\\"])` should return `True` 4. `has_required_permissions({\\"file1\\": [\\"read\\"], \\"file2\\": [\\"read\\"]}, \\"file3\\", [\\"read\\"])` should return `False` # Instructions: * Implement the function `has_required_permissions` to correctly determine if the user has the necessary permissions for a given resource. * Ensure the function passes the given examples. * Validate that the input dictionary contains the resource before checking permissions. If the resource is not in the dictionary, return `False`.","solution":"def has_required_permissions(user_permissions: dict[str, list[str]], resource: str, required_permissions: list[str]) -> bool: Check if the user has all required permissions for a resource. :param user_permissions: Dictionary with keys as resource names and values as lists of permissions. :param resource: The resource for which permissions are being checked. :param required_permissions: List of permissions required to access the resource. :return: True if the user has all required permissions; otherwise, False. if resource not in user_permissions: return False user_permissions_for_resource = user_permissions[resource] return all(permission in user_permissions_for_resource for permission in required_permissions)"},{"question":"# Problem Statement You are given a singly linked list-based queue, which currently supports standard operations like enqueue, dequeue, front, and is_empty. Your task is to extend this queue with new methods to perform the following operations: 1. **Rotate Queue**: Write a method `rotate` within the `LinkedQueue` class that rotates the queue so that the front element moves to the back of the queue and every other element shifts one position forward. This should be done in place. 2. **Find Middle Element**: Write a method `find_middle` within the `LinkedQueue` class that finds and returns the middle element of the queue. If the queue has an even number of elements, return the first of the two middle elements. # Expected Input and Output 1. **Rotate Queue**: - **Input**: None (invoked on a queue instance) - **Output**: None (modifies the queue in place) - **Example**: ```python queue = LinkedQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.rotate() print(queue) # Output: 2->3->4->1 ``` 2. **Find Middle Element**: - **Input**: None (invoked on a queue instance) - **Output**: Integer (the middle element of the queue) - **Example**: ```python queue = LinkedQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) print(queue.find_middle()) # Output: 3 queue.enqueue(6) print(queue.find_middle()) # Output: 3 ``` # Constraints * You must not use any additional data structures aside from the provided queue methods to perform these operations. * The queue may contain any number of elements, including zero. Implement the `rotate` and `find_middle` methods in `LinkedQueue` class based on the already provided queue code.","solution":"class LinkedQueue: class Node: __slots__ = \'element\', \'next\' def __init__(self, element, next=None): self.element = element self.next = next def __init__(self): self._front = None self._rear = None self._size = 0 def enqueue(self, element): new_node = self.Node(element) if self.is_empty(): self._front = new_node else: self._rear.next = new_node self._rear = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise Exception(\'Queue is empty\') result = self._front.element self._front = self._front.next self._size -= 1 if self.is_empty(): self._rear = None return result def front(self): if self.is_empty(): raise Exception(\'Queue is empty\') return self._front.element def is_empty(self): return self._size == 0 def __str__(self): result = [] current = self._front while current: result.append(current.element) current = current.next return \'->\'.join(map(str, result)) def rotate(self): if self._size > 1: old_front = self._front self._front = old_front.next old_front.next = None self._rear.next = old_front self._rear = old_front def find_middle(self): if self.is_empty(): raise Exception(\'Queue is empty\') slow = self._front fast = self._front while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow.element"},{"question":"Coding Assessment Question # Context You are working on a problem where you need to efficiently find all pairs of words from a given list that are anagrams of each other. An anagram is a word formed by rearranging the letters of another, such as \\"angel\\" and \\"glean\\". # Task Write a function that takes a list of words and returns a list of lists, where each sublist contains words that are anagrams of each other. # Function Specifications - **Function Name**: `find_anagrams` - **Input**: A list of words (`words: List[str]`). - **Output**: A list of lists, each containing words that are anagrams of each other (`List[List[str]]`). # Constraints - Each word consists of lowercase alphabetical characters only. - The length of each word is bounded by a reasonable constant. - The length of the list of words does not exceed `10^4`. # Performance Requirements - The solution should be efficient, aiming for linearithmic time complexity, i.e., O(n log n) where n is the number of words, or a reasonable approximation of it. # Example Usage ```python words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"golego\\", \\"abc\\", \\"cab\\"] anagrams = find_anagrams(words) print(anagrams) # Expected output: [[\'listen\', \'silent\', \'enlist\', \'inlets\'], [\'google\', \'golego\'], [\'abc\', \'cab\']] ``` # Notes - Words that do not have any anagrams within the list should be omitted from the result. - Ensure your function handles edge cases such as an empty input list or a list with no anagrams efficiently. # Hints - Consider using a hash map (dictionary) to group words by sorted character sequences.","solution":"def find_anagrams(words): Finds all anagram pairs from a list of words and returns a list of lists containing these anagrams. Anagrams are words formed by rearranging the letters of another word. :param words: List[str] - A list of words :return: List[List[str]] - A list of lists containing groups of anagrams from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort the word to find the anagram key key = \'\'.join(sorted(word)) anagrams[key].append(word) # Return only groups of anagrams which have more than one member return [group for group in anagrams.values() if len(group) > 1]"},{"question":"# Advanced Coding Assessment Question Context You are tasked with creating a feature for a music streaming application that lets users generate playlists based on favorites. The user can store their favorite songs represented as an integer ID in various lists and combine them to form consolidated playlists. Problem Statement Implement a class `FavoritesManager` to manage the user\'s lists of favorite songs and combine them into consolidated playlists. 1. Implement the class `FavoritesManager` with the following functionalities: - Initialize with an optional dictionary named `favorite_lists` where keys are user-defined names of lists, and values are lists of integers representing song IDs. - A method `add_favorite_list` that adds a new list of favorite songs or updates an existing one. - A method `combine_playlists` that takes a list of user-defined names and returns a consolidated list of unique song IDs from the specified favorite lists. 2. Ensure proper handling of edge cases: - Provide meaningful error messages if a specified list does not exist. - Handle cases where no lists are provided for combination gracefully. Constraints * Each song ID is a unique integer. * The input lists will not be empty. * The maximum number of song IDs across all lists will not exceed 10^5. Function Signatures * `class FavoritesManager` - `__init__(self, favorite_lists: dict[str, list[int]] = {}) -> None` - `add_favorite_list(self, list_name: str, song_ids: list[int]) -> None` - `combine_playlists(self, list_names: list[str]) -> list[int]` Input and Output * `FavoritesManager.__init__(favorite_lists: dict[str, list[int]] = {})` - **Input**: An optional dictionary where keys are strings corresponding to list names, and values are lists of integers representing song IDs. - **Initialization**: Stores the provided dictionary or initializes an empty one if none is provided. * `FavoritesManager.add_favorite_list(list_name: str, song_ids: list[int])` - **Input**: A string `list_name` representing the name of the favorite list and a list of integers `song_ids` representing the song IDs. - **Output**: None. The method will update the `favorite_lists` attribute. * `FavoritesManager.combine_playlists(list_names: list[str])` - **Input**: A list of strings `list_names` representing the names of the favorite lists to be combined. - **Output**: A list of integers representing the unique song IDs from the specified lists. - **Raises**: `ValueError` if any of the specified list names do not exist. Example Usage ```python # Initializing the FavoritesManager with some pre-defined lists favs = FavoritesManager({ \\"rock\\": [101, 102, 103], \\"pop\\": [201, 202, 203], \\"jazz\\": [301, 302, 303], }) # Adding a new list of favorite songs favs.add_favorite_list(\\"country\\", [401, 402, 403]) # Combining two playlists combined_playlist = favs.combine_playlists([\\"rock\\", \\"pop\\"]) print(combined_playlist) # Outputs: [101, 102, 103, 201, 202, 203] # Handling edge cases try: favs.combine_playlists([\\"rock\\", \\"classical\\"]) except ValueError as e: print(e) # Outputs: favorite list classical does not exist # Combining playlists gracefully when an empty list of names is provided empty_combined_playlist = favs.combine_playlists([]) print(empty_combined_playlist) # Outputs: [] ``` This question pertains to handling collections and sets, leveraging Python\'s list and dictionary functionalities proficiently. The problem and requirements match the complexity and style of the original question set effectively.","solution":"class FavoritesManager: def __init__(self, favorite_lists: dict[str, list[int]] = {}): self.favorite_lists = favorite_lists def add_favorite_list(self, list_name: str, song_ids: list[int]) -> None: self.favorite_lists[list_name] = song_ids def combine_playlists(self, list_names: list[str]) -> list[int]: combined_set = set() for name in list_names: if name not in self.favorite_lists: raise ValueError(f\\"favorite list {name} does not exist\\") combined_set.update(self.favorite_lists[name]) return list(combined_set)"},{"question":"# Question: Graph Shortest Path using Dijkstra\'s Algorithm Context In computer science, finding the shortest path in a weighted graph is a common problem with numerous applications, including network routing, geographical mapping, and AI navigation. Dijkstra\'s algorithm is a well-known technique for solving this problem on graphs with non-negative weights. Problem Write a function `shortest_path(num_nodes: int, edges: list[tuple[int, int, float]], start_node: int, end_node: int) -> float` that takes: - `num_nodes` (int): The number of nodes in the graph (node labels are from 0 to num_nodes - 1). - `edges` (list[tuple[int, int, float]]): A list of tuples, each representing an edge in the format (u, v, w) where u and v are nodes and w is the weight of the edge. - `start_node` (int): The starting node for the path. - `end_node` (int): The destination node for the path. The function should output the shortest path distance from the `start_node` to the `end_node`. If no such path exists, return `float(\'inf\')`. Input and Output Format - **Input**: - An integer `num_nodes` representing the number of nodes. - A list `edges` containing tuples of edges. - Integers `start_node` and `end_node` representing the start and end nodes. - **Output**: - A float representing the shortest path distance. If no path exists, return `float(\'inf\')`. Constraints - The number of nodes `num_nodes` will range from 1 to 1000. - The number of edges will range from 0 to 2000. - All edge weights will be non-negative floats. Example ```python from typing import List, Tuple def shortest_path(num_nodes: int, edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: # Your implementation here # Example Usage num_nodes = 5 edges = [ (0, 1, 2.5), (1, 2, 1.0), (2, 3, 4.0), (0, 3, 10.0), (1, 4, 2.0), (3, 4, 1.0) ] start_node = 0 end_node = 3 print(shortest_path(num_nodes, edges, start_node, end_node)) # Output: 7.5 ``` Clarify that the function implementation should utilize Dijkstra\'s algorithm to ensure efficiency. Potential pitfalls include managing the priority queue and handling cases where no path exists between the given nodes. Ensure your function is scalable and optimal for the given constraints.","solution":"import heapq from typing import List, Tuple import sys def shortest_path(num_nodes: int, edges: List[Tuple[int, int, float]], start_node: int, end_node: int) -> float: # Create an adjacency list graph = {i: [] for i in range(num_nodes)} for u, v, w in edges: graph[u].append((v, w)) # If the graph is undirected, also add the reverse edge # graph[v].append((u, w)) # Initialize distances and the priority queue distances = [float(\'inf\')] * num_nodes distances[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is greater than the currently known distance, skip it if current_distance > distances[current_node]: continue # Visit neighbours for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end_node] if distances[end_node] != float(\'inf\') else float(\'inf\')"},{"question":"# Time-based Event Monitoring You are tasked with implementing a function to monitor the number of active events at any given time. Given the start and end times of multiple events, your function should return a list which shows the number of active events at each queried time point. Function Specifications Write a function `event_monitor` with the following signature: ```python def event_monitor(events: list[tuple[int, int]], queries: list[int]) -> list[int]: ``` Input - `events`: A list of tuples where each tuple represents the start and end time of an event. Each tuple has two integers: - `(start_time, end_time)`: Start time and end time of the event (both inclusive) measured in seconds. - `queries`: A list of integers where each integer represents a query time point in seconds. Output The function should return a list of integers, where each integer represents the number of events that are active at the corresponding queried time point. Constraints * The number of events, `n`, will be such that `1 <= n <= 1000`. * The number of queries, `m`, will be such that `1 <= m <= 1000`. * Event times and query times are non-negative integers. Example ```python events = [(1, 5), (3, 7), (6, 8)] queries = [2, 4, 6, 8] result = event_monitor(events, queries) print(result) # Output: [1, 2, 2, 1] ``` Notes 1. An event is considered active if the query time lies within its start and end time (both inclusive). 2. Ensure the function optimally checks all events for the given queries to handle the upper limits efficiently. In this example, the function `event_monitor` should determine that: - At query time 2, only the first event (1, 5) is active. - At query time 4, both the first (1, 5) and second (3, 7) events are active. - At query time 6, the second (3, 7) and third (6, 8) events are active. - At query time 8, only the third event (6, 8) is active.","solution":"def event_monitor(events: list[tuple[int, int]], queries: list[int]) -> list[int]: Returns the number of active events at each query time point. Parameters: events (list of tuples): List of (start_time, end_time) tuples indicating event duration. queries (list of int): List of query time points. Returns: list of int: List of counts of active events at each query time point. result = [] for query in queries: count = sum(start <= query <= end for start, end in events) result.append(count) return result"},{"question":"# Largest Sum Contiguous Subarray Scenario You are working on an application that requires analyzing large datasets for patterns within numerical sequences. One common task is to identify and evaluate the largest possible contiguous sum within a dataset, which helps in identifying peaks or clusters of high values. Problem Statement Write a function `find_largest_sum_subarray` that finds the largest sum of any contiguous subarray within the given array. The function should handle both positive and negative numbers, as well as zeroes. Function Signature ```python def find_largest_sum_subarray(array: list[int]) -> int: ``` Input - `array` (list[int]): A list containing integer values, both positive and negative. Output - Returns an integer representing the largest sum of any contiguous subarray within the given array. Examples ```python assert find_largest_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 # Example: [3, 4, -1, 2, 1] assert find_largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # Example: [4, -1, 2, 1] assert find_largest_sum_subarray([-1, -2, -3, -4]) == -1 # Example: [-1] assert find_largest_sum_subarray([5, 4, -1, 7, 8]) == 23 # Example: [5, 4, -1, 7, 8] ``` Constraints - The input array may contain both positive and negative integers and can vary in length. Performance Requirements - The function should be optimized for performance to handle large arrays efficiently. Aim for a solution within O(n) time complexity, where n is the length of the array. Notes - Ensure the function considers edge cases such as arrays with all negative numbers, arrays containing a single element, and empty arrays. - Pay attention to handling arrays of large sizes to ensure the solution is scalable and performs well.","solution":"def find_largest_sum_subarray(array): Returns the largest sum of any contiguous subarray within the given array. if not array: return 0 max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Question: Array Element Frequency Matching A retail company wants to analyze how often certain products are purchased together. They have logs of purchase orders, where each order lists the product IDs. The company aims to find matches of specific products within these orders to optimize stock inventory based on purchase patterns. Task: Write a function that takes a list of purchase orders and a target product ID. Your function should return the indices of orders where the target product ID appears, as well as the frequency count of the target product ID across all orders. Ensure the function handles edge cases elegantly, especially when dealing with large datasets or empty orders. Requirements: 1. **Input**: - A list of purchase orders `orders` (a list of lists of integers, where each sublist represents a purchase order containing product IDs). - An integer `target_product_id`. 2. **Output**: - A list of indices of orders where the target product ID appears. - The total count of the target product ID in all orders. Constraints: - The number of orders (m) is between 0 and 10^5. - The maximum number of products in a single order (n) is 10^3. - Each product ID is an integer within the range of 1 to 10^6. - Handle scenarios where `orders` might be an empty list or contain empty lists. Example: ```python >>> find_product_matches([[1001, 1002], [1003], [1001, 1004, 1001]], 1001) ([0, 2], 3) >>> find_product_matches([[2002, 2003], [2004], [2003, 2004, 2002]], 2005) ([], 0) >>> find_product_matches([], 1001) ([], 0) ``` # Your task: 1. Implement the function `find_product_matches` to identify the orders containing the target product ID and the overall appearance count. 2. Ensure that your function is efficient in both time and space complexity, considering the possible input size. 3. Handle invalid cases and edge cases appropriately. **Function signature**: ```python def find_product_matches(orders: list, target_product_id: int) -> tuple: pass ``` Note: - You should not use any in-built search functions. - Provide a brief explanation of your approach and how you handle edge cases and exceptions.","solution":"def find_product_matches(orders, target_product_id): Finds the indices of orders containing the target product ID and counts the frequency of the target product ID. Parameters: orders (list of list of int): A list of purchase orders with product IDs. target_product_id (int): The product ID to search for. Returns: tuple: A tuple containing a list of indices where the target product ID appears and the frequency count of the target product ID. indices = [] count = 0 for i, order in enumerate(orders): if target_product_id in order: indices.append(i) count += order.count(target_product_id) return (indices, count)"},{"question":"# Coding Assessment Question Question: You have been asked to write a function that simulates a simple algorithm for evaluating arithmetic expressions involving addition and multiplication. The arithmetic expressions are given as strings and should follow specific rules for clarity. Implement the function `evaluate_expression`. Function Details: * **Function Name**: `evaluate_expression` * **Input**: A single argument `expression` which is a string representing the arithmetic expression. * **Output**: An integer that is the result of evaluating the expression. * The expression will consist of integer numbers and the operations `+` and `*`. * Numbers and operators are always separated by single spaces for simplicity. * **Constraints**: * The input string will contain only valid expressions, and its length will not exceed 100 characters. * You must handle edge cases carefully and assume all operations follow standard arithmetic precedence (multiplication before addition). * **Performance Requirement**: The function should efficiently parse and compute the result in linear time relative to the size of the input. Example: ```python >>> print(evaluate_expression(\\"2 + 3 * 4\\")) 14 >>> print(evaluate_expression(\\"5 + 6 + 7 * 2\\")) 25 >>> print(evaluate_expression(\\"3 * 4 + 2\\")) 14 >>> print(evaluate_expression(\\"10 + 5 * 2 + 3\\")) 23 >>> print(evaluate_expression(\\"2 + 2\\")) 4 ``` Make sure to handle any valid arithmetic expressions that conform to the constraints. Document your code appropriately and ensure edge cases (such as an expression with only one number) are managed. # Explanation: This additional question fits the style, length, and complexity of the existing assessment questions. It requires the candidate to parse and evaluate expressions with correct operator precedence, testing their understanding of string manipulation, arithmetic operations, and algorithm implementation in Python.","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing integers and the operators `+` and `*`, following the standard arithmetic precedence (multiplication before addition). Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of evaluating the expression. # Split the expression into tokens for easier manipulation tokens = expression.split() # First pass: Handle all multiplications i = 0 while i < len(tokens): if tokens[i] == \'*\': # Perform the multiplication and overwrite the operator and the next number tokens[i - 1] = str(int(tokens[i - 1]) * int(tokens[i + 1])) # Remove the operator and the next number as they are already evaluated del tokens[i:i + 2] else: i += 1 # Second pass: Handle all additions result = 0 i = 0 while i < len(tokens): if tokens[i] == \'+\': result += int(tokens[i + 1]) i += 2 else: result += int(tokens[i]) i += 1 return result"},{"question":"Problem: Rotate Matrix Implement a function to rotate an NxN 2D matrix 90 degrees clockwise. # Input 1. An integer **N** (1 <= N <= 100) denoting the dimension of a square matrix. 2. An NxN matrix (provided as a list of lists) containing integers (-1000 <= matrix[i][j] <= 1000). # Output 1. A list of lists denoting the NxN matrix rotated 90 degrees clockwise. # Function Signature ```python def rotate_matrix(matrix: List[List[int]], N: int) -> List[List[int]]: pass ``` # Examples Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] N = 3 print(rotate_matrix(matrix, N)) # Output: [[7,4,1],[8,5,2],[9,6,3]] ``` Example 2: ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] N = 4 print(rotate_matrix(matrix, N)) # Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] ``` # Notes 1. The rotation operation should be performed in-place without using any additional matrices if possible. 2. Consider how matrix indices change when rotated to achieve optimal results. 3. Ensure your solution is efficient, especially for larger values of N.","solution":"def rotate_matrix(matrix, N): Rotates an NxN matrix 90 degrees clockwise. Args: matrix (List[List[int]]): NxN matrix containing integers N (int): The dimension of the square matrix Returns: List[List[int]]: The rotated NxN matrix for layer in range(N // 2): first = layer last = N - 1 - layer for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"# Prefix Sum Array and Range Sum Query You are tasked with handling queries on an array to find the sum of elements within a specific range. Utilize the concept of a prefix sum array to efficiently answer range sum queries. Your task is to implement a prefix sum array construction and range sum query functions. # Function Definitions Implement the following functions: 1. **`construct_prefix_sum`**: Constructs a prefix sum array from the given list of integers. ```python def construct_prefix_sum(arr: List[int]) -> List[int]: Constructs a prefix sum array from the given array. :param arr: A list of integers. :return: A list of integers representing the prefix sum array. pass ``` 2. **`range_sum_query`**: Computes the sum of elements in the given range using the prefix sum array. ```python def range_sum_query(prefix_sum: List[int], left: int, right: int) -> int: Computes the sum of elements in the given range [left, right] using the prefix sum array. :param prefix_sum: A list of integers representing the prefix sum array. :param left: The starting index of the range (inclusive). :param right: The ending index of the range (inclusive). :return: The sum of elements in the specified range. pass ``` # Requirements 1. **Performance**: * Ensure the prefix sum array construction takes **O(n)** time. * Ensure each range sum query is answered in **O(1)** time. 2. **Edge Cases**: * Handle cases where the array is empty. * Test with ranges that cover the entire array. * Test with differing sizes of arrays and multiple queries. # Input and Output * **Input**: A list of integers and multiple queries defined by their left and right indices. * **Output**: The sum of elements in the specified range for each query. # Example ```python # Example array arr = [1, 2, 3, 4, 5, 6] # Construct prefix sum array prefix_sum = construct_prefix_sum(arr) # Range queries queries = [(0, 2), (1, 4), (3, 5), (0, 5)] # Perform range sum queries results = [range_sum_query(prefix_sum, left, right) for left, right in queries] print(results) ``` *Expected Output*: ```python [6, 14, 15, 21] ``` 1. For the range (0, 2), the sum is 1 + 2 + 3 = 6. 2. For the range (1, 4), the sum is 2 + 3 + 4 + 5 = 14. 3. For the range (3, 5), the sum is 4 + 5 + 6 = 15. 4. For the range (0, 5), the sum is 1 + 2 + 3 + 4 + 5 + 6 = 21.","solution":"from typing import List def construct_prefix_sum(arr: List[int]) -> List[int]: Constructs a prefix sum array from the given array. :param arr: A list of integers. :return: A list of integers representing the prefix sum array. if not arr: return [] prefix_sum = [0] * len(arr) prefix_sum[0] = arr[0] for i in range(1, len(arr)): prefix_sum[i] = prefix_sum[i - 1] + arr[i] return prefix_sum def range_sum_query(prefix_sum: List[int], left: int, right: int) -> int: Computes the sum of elements in the given range [left, right] using the prefix sum array. :param prefix_sum: A list of integers representing the prefix sum array. :param left: The starting index of the range (inclusive). :param right: The ending index of the range (inclusive). :return: The sum of elements in the specified range. if not prefix_sum: return 0 if left == 0: return prefix_sum[right] return prefix_sum[right] - prefix_sum[left - 1]"},{"question":"# Scenario You are developing a simplified simulation of a city traffic control system. The system needs to monitor and manage traffic at an intersection using a traffic light controller. The traffic light can be in one of three states: RED, YELLOW, or GREEN and the goal is to change the light based on a set time sequence. # Task Implement a class `TrafficLight` that simulates the behavior of a traffic light. Your class should support changing light states in a cyclic sequence (RED -> GREEN -> YELLOW -> RED) and provide the current state of the light. # Function Signatures Below are the methods you need to implement within the `TrafficLight` class: ```python class TrafficLight: def __init__(self) -> None: Initializes the traffic light with an initial state RED. def change_light(self) -> None: Changes the light state in the sequence RED -> GREEN -> YELLOW -> RED. def current_state(self) -> str: Returns: str: The current state of the traffic light (\'RED\', \'YELLOW\', \'GREEN\'). ``` # Input * Initially, the traffic light starts in the RED state. * The `change_light` method will be called to change the state to the next one in the sequence. # Output * The `current_state` method will return the current state as a string. # Constraints * The methods should handle the state transitions without errors. * Each state change should follow the sequence RED -> GREEN -> YELLOW -> RED. # Expected Complexity * The operations should be performed in constant time O(1). # Example Usage ```python traffic_light = TrafficLight() print(traffic_light.current_state()) # Expected output: \\"RED\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"GREEN\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"YELLOW\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"RED\\" ```","solution":"class TrafficLight: def __init__(self) -> None: Initializes the traffic light with an initial state RED. self.states = [\\"RED\\", \\"GREEN\\", \\"YELLOW\\"] self.current_index = 0 def change_light(self) -> None: Changes the light state in the sequence RED -> GREEN -> YELLOW -> RED. self.current_index = (self.current_index + 1) % 3 def current_state(self) -> str: Returns: str: The current state of the traffic light (\'RED\', \'YELLOW\', \'GREEN\'). return self.states[self.current_index] # Example usage traffic_light = TrafficLight() print(traffic_light.current_state()) # Expected output: \\"RED\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"GREEN\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"YELLOW\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"RED\\""},{"question":"# Coding Assessment Question **Scenario**: You are designing a system requiring data manipulation and analysis over a range of elements, a common task for search engines and data analytics platforms. Consequently, you need to efficiently handle dynamic data updates and retrieval requests. Binary Indexed Trees, also known as Fenwick Trees, are suitable for this purpose due to their ability to efficiently perform both point updates and range queries. **Task**: Implement the `FenwickTree` class by completing the following methods: 1. **build**: ```python def build(self, a: list[int]) -> None: ``` - **Input**: - `a` (list[int]): Original array to construct the Fenwick Tree from. - **Output**: None 2. **update**: ```python def update(self, idx: int, delta: int) -> None: ``` - **Input**: - `idx` (int): The index to be updated. - `delta` (int): The value to add to the index. - **Output**: None 3. **query**: ```python def query(self, idx: int) -> int: ``` - **Input**: - `idx` (int): The index up to which the sum is required. - **Output**: Return the sum of elements from the start of the array up to the given index (`[0, idx]`). 4. **range_query**: ```python def range_query(self, left: int, right: int) -> int: ``` - **Input**: - `left` (int): Left boundary of the range. - `right` (int): Right boundary of the range. - **Output**: Return the sum of elements within the range `[left, right]`. **Constraints**: - You may assume the input array size will not exceed `10^5`. - The values in the input array will be within the range `[-10^6, 10^6]`. **Example**: ```python A = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) print(fenwick_tree.query(4)) # Output: 3 (1 + (-2) + 3 + (-4) + 5 = 3) print(fenwick_tree.range_query(3, 7)) # Output: 10 (-4 + 5 + (-6) + 7 + 8 = 10) fenwick_tree.update(2, 5) # A[2] becomes 8 (3 + 5 = 8) print(fenwick_tree.query(4)) # Output: 8 (1 + (-2) + 8 + (-4) + 5 = 8) ```","solution":"class FenwickTree: def __init__(self, size: int): Initializes a Fenwick Tree for handling \'size\' elements. self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: Builds the Fenwick Tree using the given array a. for idx, value in enumerate(a): self.update(idx, value) def update(self, idx: int, delta: int) -> None: Updates the element at index idx by adding delta to it. idx += 1 while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: Returns the sum of elements from the start of the array up to index idx. idx += 1 sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_query(self, left: int, right: int) -> int: Returns the sum of elements within the range [left, right]. return self.query(right) - self.query(left - 1)"},{"question":"# Problem Statement You have been given a task to implement a function that calculates the greatest common divisor (GCD) of a list of integers. The GCD of a list of numbers is the largest positive integer that divides all numbers in the list without leaving a remainder. Your task is to implement a function `find_gcd_of_list(numbers: List[int]) -> int` that takes a list of integers and returns their GCD. # Function Signature ```python from typing import List def find_gcd_of_list(numbers: List[int]) -> int: pass ``` # Input * `numbers`: A list of integers (e.g., `[12, 15, 21]`). # Output * An integer representing the GCD of the given list of integers (e.g., `3`). # Constraints * The list `numbers` will contain between 2 and 1,000 elements. * Each element of the list will be an integer between `1` and `10^9`. # Example ```python assert find_gcd_of_list([12, 15, 21]) == 3 assert find_gcd_of_list([5, 10, 20]) == 5 assert find_gcd_of_list([11, 13, 17]) == 1 ``` # Notes * To efficiently find the GCD, you might want to use the Euclidean algorithm. * Consider edge cases such as when the list contains the same numbers, or when the numbers are all prime to each other. * Your solution should remain efficient even for the upper constraint limits.","solution":"from typing import List from math import gcd from functools import reduce def find_gcd_of_list(numbers: List[int]) -> int: This function calculates the GCD of a list of integers. return reduce(gcd, numbers)"},{"question":"# Problem Statement You are given a list of non-negative integers representing the heights of blocks stacked vertically at each position along a horizontal axis. Your task is to write a function `trap_rain_water` that calculates how much water can be trapped after raining. The amount of water trapped at any position is determined by the height of the shortest block to the left and right of that position minus the height of the block at that position. # Function Signature ```python def trap_rain_water(heights: list[int]) -> int: ``` # Input * A list of non-negative integers `heights` (0 ≤ length of heights ≤ 10^4). Each integer represents the height at a specific position. # Output * An integer representing the total volume of water that can be trapped. # Constraints - The heights of the blocks are non-negative integers. - The length of the list will not exceed 10^4. # Example ```python # Example 1 heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_rain_water(heights)) # Expected output: 6 # Example 2 heights = [4, 2, 0, 3, 2, 5] print(trap_rain_water(heights)) # Expected output: 9 ``` # Additional Notes - Edge cases such as an empty list or a list with no possibility of trapping water should return 0. - Ensure that your function correctly handles lists with varying heights and positions efficiently.","solution":"def trap_rain_water(heights: list[int]) -> int: Calculates the total volume of water that can be trapped after raining given a list of block heights. :param heights: List of non-negative integers representing the heights of blocks :return: An integer representing the total volume of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"**Scenario**: You are developing a scheduling application where tasks are organized by priority. Implement a priority queue that supports dynamic priority levels and automatic resizing of the internal storage when capacity is reached. **Requirements**: 1. Implement the `DynamicPriorityQueue` class that supports dynamic resizing. 2. Override the `insert` method to automatically resize the internal storage when the priority queue is full. Double the size of the storage when resizing. 3. Maintain all standard operations (`insert`, `extract_max`, `peek`, `is_empty`, `__len__`) similar to standard priority queues, but adjusted for dynamic capacity. 4. Handle underflow conditions in the `extract_max` method appropriately. **Function Specifications**: - **insert(priority, data):** - Input: An integer `priority` and any `data` type to be inserted. - Output: The `DynamicPriorityQueue` object itself after the insertion. - **extract_max():** - Input: None. - Output: The data item with the highest priority. Raises an exception if the queue is empty. - **peek():** - Input: None. - Output: The data item with the highest priority without removing it. Returns `None` if the queue is empty. - **is_empty():** - Input: None. - Output: Boolean value `True` if the priority queue is empty, otherwise `False`. - **__len__():** - Input: None. - Output: Integer representing the number of elements in the priority queue. ```python class DynamicPriorityQueue: def __init__(self, capacity: int): self.capacity = capacity self.size = 0 self.storage = [None] * capacity self.priorities = [None] * capacity def insert(self, priority, data): if self.size >= self.capacity: self._resize(2 * self.capacity) self.priorities[self.size] = priority self.storage[self.size] = data self.size += 1 self._heapify_up(self.size - 1) return self def extract_max(self): if self.is_empty(): raise IndexError(\\"Priority queue is empty\\") max_data = self.storage[0] self.size -= 1 self.storage[0] = self.storage[self.size] self.priorities[0] = self.priorities[self.size] self._heapify_down(0) return max_data def peek(self): if self.is_empty(): return None return self.storage[0] def is_empty(self): return self.size == 0 def __len__(self): return self.size def _resize(self, new_capacity): new_storage = [None] * new_capacity new_priorities = [None] * new_capacity for i in range(self.size): new_storage[i] = self.storage[i] new_priorities[i] = self.priorities[i] self.storage = new_storage self.priorities = new_priorities self.capacity = new_capacity def _heapify_up(self, index): parent = (index - 1) // 2 if parent >= 0 and self.priorities[index] > self.priorities[parent]: self._swap(index, parent) self._heapify_up(parent) def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < self.size and self.priorities[left] > self.priorities[largest]: largest = left if right < self.size and self.priorities[right] > self.priorities[largest]: largest = right if largest != index: self._swap(index, largest) self._heapify_down(largest) def _swap(self, i, j): self.priorities[i], self.priorities[j] = self.priorities[j], self.priorities[i] self.storage[i], self.storage[j] = self.storage[j], self.storage[i] ``` **Constraints**: 1. The initial capacity should be set through the constructor parameter. 2. Priority queue operations should maintain O(log n) time complexity. 3. Resizing should only happen during an `insert` operation when the priority queue is full. **Example**: ```python pq = DynamicPriorityQueue(2) pq.insert(10, \\"high\\") pq.insert(5, \\"medium\\") print(pq.peek()) # Output: \\"high\\" pq.insert(15, \\"highest\\") # This operation should double the capacity print(pq.peek()) # Output: \\"highest\\" pq.extract_max() print(pq.peek()) # Output: \\"high\\" ```","solution":"class DynamicPriorityQueue: def __init__(self, capacity: int): self.capacity = capacity self.size = 0 self.storage = [None] * capacity self.priorities = [None] * capacity def insert(self, priority, data): if self.size >= self.capacity: self._resize(2 * self.capacity) self.priorities[self.size] = priority self.storage[self.size] = data self.size += 1 self._heapify_up(self.size - 1) return self def extract_max(self): if self.is_empty(): raise IndexError(\\"Priority queue is empty\\") max_data = self.storage[0] self.size -= 1 self.storage[0] = self.storage[self.size] self.priorities[0] = self.priorities[self.size] self._heapify_down(0) return max_data def peek(self): if self.is_empty(): return None return self.storage[0] def is_empty(self): return self.size == 0 def __len__(self): return self.size def _resize(self, new_capacity): new_storage = [None] * new_capacity new_priorities = [None] * new_capacity for i in range(self.size): new_storage[i] = self.storage[i] new_priorities[i] = self.priorities[i] self.storage = new_storage self.priorities = new_priorities self.capacity = new_capacity def _heapify_up(self, index): parent = (index - 1) // 2 if parent >= 0 and self.priorities[index] > self.priorities[parent]: self._swap(index, parent) self._heapify_up(parent) def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < self.size and self.priorities[left] > self.priorities[largest]: largest = left if right < self.size and self.priorities[right] > self.priorities[largest]: largest = right if largest != index: self._swap(index, largest) self._heapify_down(largest) def _swap(self, i, j): self.priorities[i], self.priorities[j] = self.priorities[j], self.priorities[i] self.storage[i], self.storage[j] = self.storage[j], self.storage[i]"},{"question":"# Rotate Array Problem Context You are given an array `nums` and an integer `k`. The array `nums` is rotated `k` places to the right. Task Write a function that rotates the array in-place to the right by `k` steps. Function Signature ```python def rotate_array(nums: list[int], k: int) -> None: Rotates the array in-place to the right by k steps. Args: nums (list[int]): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None Examples: >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 3) >>> arr [5, 6, 7, 1, 2, 3, 4] >>> arr = [-1, -100, 3, 99] >>> rotate_array(arr, 2) >>> arr [3, 99, -1, -100] ``` Inputs * `nums`: List of integers representing the array to rotate. (1 <= len(nums) <= 10^5, -10^4 <= nums[i] <= 10^4) * `k`: Integer representing the number of steps to rotate the array. (0 <= k <= 10^5) Output * The function does not return anything but modifies the `nums` array in-place. Constraints * Try to come up with a solution that uses only O(1) extra space. * The rotation operation should be performed in-place. Examples ```python assert (lambda arr: rotate_array(arr, 3) or arr == [5, 6, 7, 1, 2, 3, 4])([1, 2, 3, 4, 5, 6, 7]) assert (lambda arr: rotate_array(arr, 2) or arr == [3, 99, -1, -100])([-1, -100, 3, 99]) assert (lambda arr: rotate_array(arr, 0) or arr == [1, 2, 3])([1, 2, 3]) assert (lambda arr: rotate_array(arr, 4) or arr == [2, 1])([1, 2]) ``` Requirements 1. Ensure the solution considers performance and does not use more than O(1) additional space. 2. Handle edge cases such as k being 0 or greater than the length of the array. 3. Provide clear and concise function documentation. This question introduces an additional problem that focuses on array manipulation and in-place operations, matching the complexity and scope of the existing set.","solution":"def rotate_array(nums: list[int], k: int) -> None: Rotates the array in-place to the right by k steps. Args: nums (list[int]): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None n = len(nums) # Handle cases where k is greater than the length of the array k = k % n # Reverse the entire array nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the array nums[k:] = reversed(nums[k:]) # Example usage: # arr = [1, 2, 3, 4, 5, 6, 7] # rotate_array(arr, 3) # print(arr) # Output: [5, 6, 7, 1, 2, 3, 4]"},{"question":"# Coding Assessment Question Objective: Develop an understanding of string manipulation and frequency analysis by counting character occurrences in a given text. Function to Implement: You need to implement a function `character_frequency_analysis(text: str) -> dict` according to the following specifications: 1. The function should take a single string as input. 2. Ignore case, i.e., \'A\' and \'a\' should be considered the same character. 3. Count the frequency of each character in the string. 4. Return a dictionary where the keys are characters and the values are their respective counts. 5. Only alphanumeric characters (letters and digits) should be counted. Input: - A string `text` containing arbitrary characters (including spaces and punctuation). Output: - A dictionary with characters as keys and their respective counts as values. Constraints: - The input string `text` should have a length between 1 and 10^5 characters. - Only alphabetic characters (A-Z, a-z) and digits (0-9) should be included in the output dictionary. - Characters should be counted case-insensitively. Examples: ```python >>> character_frequency_analysis(\\"Hello World!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> character_frequency_analysis(\\"Python 3.8\\") {\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 1, \'3\': 1, \'8\': 1} ``` Additional Tests for Validation: ```python # Validate case sensitivity >>> character_frequency_analysis(\\"AaAa\\") {\'a\': 4} # Validate alphanumeric characters >>> character_frequency_analysis(\\"123, abc! 456.\\") {\'1\': 1, \'2\': 1, \'3\': 1, \'a\': 1, \'b\': 1, \'c\': 1, \'4\': 1, \'5\': 1, \'6\': 1} # Validate input length >>> character_frequency_analysis(\\"\\") Traceback (most recent call last): ... ValueError: Input string must be non-empty. >>> character_frequency_analysis(\\"a\\"*100001) Traceback (most recent call last): ... ValueError: Input string must be between 1 and 100000 characters long. ``` Function Signature: ```python def character_frequency_analysis(text: str) -> dict: pass ```","solution":"def character_frequency_analysis(text: str) -> dict: Analyzes the frequency of each alphanumeric character in the given text. Parameters: text (str): The input text to analyze Returns: dict: A dictionary with characters as keys and their respective counts as values if not (1 <= len(text) <= 100000): raise ValueError(\\"Input string must be between 1 and 100000 characters long.\\") frequency = {} for char in text: if char.isalnum(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Data Structures and Algorithm Efficiency Problem Statement You are given a binary tree represented as a sequence of integers in level-order traversal, where `None` represents a missing node. Implement a function to determine whether the binary tree is complete. A complete binary tree is one where all levels are fully filled except possibly for the last level, which is filled from left to right. Function to Implement Implement the function `is_complete_binary_tree` which takes one parameter: 1. **nodes**: A list of integers and `None` values representing the binary tree in level-order traversal. The function should return a boolean indicating whether the binary tree is complete or not. Example Input ```python nodes = [1, 2, 3, 4, 5, 6] ``` Example Output ```python True ``` Constraints - The list `nodes` will have at least 1 element and at most 10^4 elements. - Each element in the list is either an integer within the range of [-10^5, 10^5] or `None`. Additional Information - The root of the tree is always nodes[0]. - Standardize the representation of missing nodes with `None`. ```python def is_complete_binary_tree(nodes): Determine if the binary tree represented by `nodes` in level-order traversal is a complete binary tree. :param nodes: List of integers and None values representing the binary tree :return: Boolean indicating whether the binary tree is complete if not nodes: return True i = 0 while i < len(nodes) and nodes[i] is not None: i += 1 while i < len(nodes): if nodes[i] is not None: return False i += 1 return True ``` Notes - Your function should efficiently traverse the list and verify completeness according to the definition. - Aim for an O(n) solution where n is the number of nodes in the tree.","solution":"def is_complete_binary_tree(nodes): Determine if the binary tree represented by `nodes` in level-order traversal is a complete binary tree. :param nodes: List of integers and None values representing the binary tree :return: Boolean indicating whether the binary tree is complete if not nodes: return True n = len(nodes) index = 0 # Find the first missing node and store its index while index < n and nodes[index] is not None: index += 1 # If all nodes are present, it\'s a complete binary tree if index == n: return True # After the first None, all subsequent elements must also be None while index < n: if nodes[index] is not None: return False index += 1 return True"},{"question":"# Context: You need to optimize a large dataset processing task using multi-threading. Given a list of integers, you will split the list into chunks and compute the sum of squares of the integers in each chunk using multiple threads concurrently. Finally, you will combine the partial results from each thread to obtain the total sum of squares for the entire list. # Task: 1. **Implement Multi-threaded Sum of Squares**: - Create a function that divides the list of integers into chunks. - Compute the sum of squares for each chunk using a separate thread for each chunk. - Combine the results from all threads to produce the final sum of squares. # Requirements: 1. **Chunk Division**: - Divide the list into (n) approximately equal chunks, where (n) is the number of threads. 2. **Threaded Sum of Squares Calculation**: - Each thread should compute the sum of squares for its respective chunk and store the result. - Use Python\'s `threading` module to manage threads. 3. **Final Calculation**: - After all threads complete their computation, sum the results of all threads to get the total sum of squares. # Implementation: - Implement the `sum_of_squares_multithreaded` function. - Ensure thread-safe shared storage for partial results. - Manage thread lifecycle (start, join) appropriately. # Input & Output: - **Input**: - A list of integers `data`. - Number of threads `num_threads`. - **Output**: - The total sum of squares of all integers in the list. # Constraints: - You may assume the total number of integers in the list will be divisible by the number of threads. - Implementations should handle edge cases such as an empty list or a single chunk. Below is the sample structure of the code where you need to add the specified features. ```python import threading def sum_of_squares(arr): return sum(x ** 2 for x in arr) def sum_of_squares_multithreaded(data, num_threads): def worker(data_chunk, results, index): results[index] = sum_of_squares(data_chunk) if not data: return 0 chunk_size = len(data) // num_threads threads = [] results = [0] * num_threads for i in range(num_threads): start_index = i * chunk_size end_index = (i + 1) * chunk_size data_chunk = data[start_index:end_index] thread = threading.Thread(target=worker, args=(data_chunk, results, i)) threads.append(thread) thread.start() for thread in threads: thread.join() return sum(results) # Example usage if __name__ == \\"__main__\\": data = [i for i in range(1, 10001)] num_threads = 4 result = sum_of_squares_multithreaded(data, num_threads) print(\\"Total sum of squares:\\", result) ``` **Notes**: - Ensure the `worker` function accurately computes the sum of squares for its chunk and stores the result in a thread-safe manner. - Handle the initialization and joining of threads properly to ensure all computations complete before summing the results.","solution":"import threading def sum_of_squares(arr): Computes the sum of squares of the integers in the array. return sum(x ** 2 for x in arr) def sum_of_squares_multithreaded(data, num_threads): Computes the sum of squares of the integers in the data array using multi-threading. Parameters: - data (list of int): List of integers - num_threads (int): Number of threads to use Returns: - int: Total sum of squares of the integers def worker(data_chunk, results, index): results[index] = sum_of_squares(data_chunk) if not data: return 0 chunk_size = (len(data) + num_threads - 1) // num_threads threads = [] results = [0] * num_threads for i in range(num_threads): start_index = i * chunk_size end_index = min((i + 1) * chunk_size, len(data)) data_chunk = data[start_index:end_index] thread = threading.Thread(target=worker, args=(data_chunk, results, i)) threads.append(thread) thread.start() for thread in threads: thread.join() return sum(results)"},{"question":"# Task: Write a function `find_missing_number(nums: list[int]) -> int` that finds the smallest missing positive integer from an unsorted list of integers. # Requirements: * **Input**: * `nums`: A list of integers. * Constraints: * 1 ≤ len(nums) ≤ 10^5 * -10^6 ≤ nums[i] ≤ 10^6 * **Output**: * An integer representing the smallest missing positive integer. # Example: ```python assert find_missing_number([1, 2, 0]) == 3 assert find_missing_number([3, 4, -1, 1]) == 2 assert find_missing_number([7, 8, 9, 11, 12]) == 1 assert find_missing_number([1, 2, 3, 4, 5, 6]) == 7 assert find_missing_number([-5, -10, -1]) == 1 ``` # Explanation of Examples: 1. In the list `[1, 2, 0]`, the smallest missing positive integer is `3`. 2. In the list `[3, 4, -1, 1]`, the smallest missing positive integer is `2`. 3. In the list `[7, 8, 9, 11, 12]`, the smallest missing positive integer is `1`. 4. In the list `[1, 2, 3, 4, 5, 6]`, the smallest missing positive integer is `7`. 5. In the list `[-5, -10, -1]`, the smallest missing positive integer is `1`. # Performance Expectations: * Time complexity should be O(n). * Space complexity should be O(1), not counting the input list. Note: You can assume all input lists will be valid.","solution":"def find_missing_number(nums: list[int]) -> int: Finds the smallest missing positive integer in an unsorted list of integers. Args: nums: List[int] - A list of integers. Returns: int - The smallest missing positive integer. n = len(nums) # Place each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_pos = nums[i] - 1 nums[i], nums[correct_pos] = nums[correct_pos], nums[i] # Find the first missing positive integer for i in range(n): if nums[i] != i + 1: return i + 1 # if all positions are correct, the missing integer is n + 1 return n + 1"},{"question":"# Coding Assessment Question: Generating Prime Numbers Using Sieve of Eratosthenes Scenario: As part of a numerical analysis software project, you have been asked to implement a function that generates a list of prime numbers up to a given limit using the Sieve of Eratosthenes algorithm. This function will be used in various modules that require the identification of prime numbers for different calculations and optimizations. Problem Statement: Write a Python function to generate and return a list of all prime numbers up to a specified integer limit using the Sieve of Eratosthenes algorithm. Additionally, ensure the function can handle large limits efficiently and provide meaningful feedback if the input is invalid. Requirements: 1. A function `generate_primes(limit: int) -> list`. 2. Handle edge cases such as limits that are less than 2. 3. Provide clear error messages for invalid inputs. 4. Ensure the solution has optimal time complexity for large limits. Input: - An integer `limit` which specifies the upper boundary (inclusive) for the range of numbers to check for primality. Output: - A list of integers representing the prime numbers up to and including the given limit. Constraints: - The limit should be a non-negative integer. Example: ```python limit = 30 primes = generate_primes(limit) print(primes) # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] limit = 50 primes = generate_primes(limit) print(primes) # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` Additional Notes: - Consider edge cases such as when the limit is 0 or 1, where there are no prime numbers. - Your solution should be efficient and utilize the Sieve of Eratosthenes algorithm properly to handle large limits within a reasonable time. - The function should gracefully handle non-integer inputs by raising an appropriate exception. This question assesses your understanding of fundamental algorithms in number theory, and your ability to efficiently implement them and handle different input scenarios effectively.","solution":"def generate_primes(limit): Generates a list of all prime numbers up to the given limit using the Sieve of Eratosthenes algorithm. :param limit: An integer representing the upper boundary (inclusive) to check for prime numbers. :return: A list of integers representing prime numbers up to the given limit. if not isinstance(limit, int): raise ValueError(\\"Input must be an integer.\\") if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes. for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiples in range(start*start, limit + 1, start): sieve[multiples] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Maximum Products of Three Numbers You are given an integer array `arr`. Write a function `maximum_product_of_three(arr: list[int]) -> int` that returns the maximum product of any three distinct numbers in the array. Input: - `arr`: A list of integers (3 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6) Output: - An integer representing the maximum product of any three distinct numbers from the array. Constraints: - You must achieve a time complexity of O(n * log n) and a space complexity of O(1). Example: ```python >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([10, 3, 5, 6, 20]) 1200 ``` Context: In computational problems involving large datasets, determining the maximum product of any subset of elements can have substantial implications in fields like data analysis, financial computations, scientific research, and optimization. The challenge is to efficiently identify the optimal combination of three numbers, which can involve both extremely positive and negative values. Your implementation should handle large input sizes within the provided constraints effectively.","solution":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct numbers from the array. arr.sort() # The possible max product combinations are: # 1. Product of the three largest values # 2. Product of the two smallest values (possibly negatives) and the largest value return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"# **Coding Assessment Question** **String Manipulation and Data Encoding** In this task, you will implement and test additional functionalities for the `StringManipulator` class. The objective is to demonstrate your understanding of string operations, encoding, and decoding by completing the methods as specified below. **Task** 1. **Reverse Words Method**: Implement a method `reverse_words` to return a string with the order of the words reversed while maintaining the character order within each word. ```python def reverse_words(self, text: str) -> str: Return the input string with the order of the words reversed. >>> StringManipulator().reverse_words(\\"hello world\\") \'world hello\' >>> StringManipulator().reverse_words(\\"The quick brown fox\\") \'fox brown quick The\' >>> StringManipulator().reverse_words(\\"\\") \'\' # Implement the method here ``` 2. **Caesar Cipher Encode**: Implement a method `caesar_cipher_encode` to encode the string using Caesar Cipher technique by shifting characters by a given number. ```python def caesar_cipher_encode(self, text: str, shift: int) -> str: Return the input string encoded with Caesar Cipher using the specified shift. >>> StringManipulator().caesar_cipher_encode(\\"abc\\", 1) \'bcd\' >>> StringManipulator().caesar_cipher_encode(\\"xyz\\", 3) \'abc\' >>> StringManipulator().caesar_cipher_encode(\\"Hello, World!\\", 5) \'Mjqqt, Btwqi!\' # Implement the method here ``` 3. **Caesar Cipher Decode**: Implement a method `caesar_cipher_decode` to decode the string encoded using Caesar Cipher by shifting characters back by the given number. ```python def caesar_cipher_decode(self, text: str, shift: int) -> str: Return the input string decoded from Caesar Cipher using the specified shift. >>> StringManipulator().caesar_cipher_decode(\\"bcd\\", 1) \'abc\' >>> StringManipulator().caesar_cipher_decode(\\"abc\\", 3) \'xyz\' >>> StringManipulator().caesar_cipher_decode(\\"Mjqqt, Btwqi!\\", 5) \'Hello, World!\' # Implement the method here ``` **Function Signature** ```python class StringManipulator: # Existing methods def reverse_words(self, text: str) -> str: # Implement here pass def caesar_cipher_encode(self, text: str, shift: int) -> str: # Implement here pass def caesar_cipher_decode(self, text: str, shift: int) -> str: # Implement here pass ``` **Input and Output Formats** * The `reverse_words` method should return a string with the order of words reversed. * The `caesar_cipher_encode` method should return a string where each character is shifted by the specified number of positions in the alphabet. * The `caesar_cipher_decode` method should return a string where each character is shifted back by the specified number of positions in the alphabet. **Constraints/Limitations** * The `reverse_words` method should handle empty strings and multiple whitespace characters appropriately. * The `caesar_cipher_encode` and `caesar_cipher_decode` methods should maintain the case of the characters. * Non-alphabet characters should remain unchanged in the `caesar_cipher_encode` and `caesar_cipher_decode` methods. * Assume the shift value for the Caesar Cipher will be a non-negative integer.","solution":"class StringManipulator: def reverse_words(self, text: str) -> str: Return the input string with the order of the words reversed. words = text.split() reversed_words = words[::-1] return \' \'.join(reversed_words) def caesar_cipher_encode(self, text: str, shift: int) -> str: Return the input string encoded with Caesar Cipher using the specified shift. encoded_text = [] for char in text: if char.isalpha(): shift_base = 65 if char.isupper() else 97 encoded_char = chr((ord(char) - shift_base + shift) % 26 + shift_base) encoded_text.append(encoded_char) else: encoded_text.append(char) return \'\'.join(encoded_text) def caesar_cipher_decode(self, text: str, shift: int) -> str: Return the input string decoded from Caesar Cipher using the specified shift. return self.caesar_cipher_encode(text, -shift)"},{"question":"# Scenario You are participating in a robotics competition where you need to program a basic navigation system for your autonomous robot. The competition field is a grid, and the robot must navigate from a starting position to a specified goal position. Each cell in the grid has a different terrain cost associated with it, which represents the amount of energy required by the robot to move through that cell. The robot can only move directly up, down, left, or right. # Task You need to implement a function that calculates the minimum cost for the robot to move from the start position to the goal position using a given grid of terrain costs. You should use Dijkstra\'s algorithm to find the least costly path. # Function Signature ```python def calculate_minimum_cost(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> int: ``` # Input 1. `grid` (List[List[int]]): A 2D list of integers where each integer represents the terrain cost of a cell. The dimensions of the grid are at most 100x100. 2. `start` (Tuple[int, int]): A tuple (x, y) representing the starting position of the robot in the grid. (0 ≤ x < len(grid), 0 ≤ y < len(grid[0])) 3. `goal` (Tuple[int, int]): A tuple (x, y) representing the goal position of the robot in the grid. # Output The function should return the minimum cost to move from the start position to the goal position as an integer. # Constraints * All terrain costs in the grid are non-negative integers. * The start position and the goal position are within the bounds of the grid. # Example ```python >>> grid = [ ... [1, 3, 1, 5], ... [2, 1, 0, 2], ... [3, 1, 1, 3], ... [5, 2, 1, 1] ... ] >>> calculate_minimum_cost(grid, (0, 0), (3, 3)) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> calculate_minimum_cost(grid, (0, 0), (2, 2)) 21 ``` # Important Note Ensure your function handles different grid sizes up to the maximum limit efficiently. You may find it helpful to use a priority queue (heap) for implementing Dijkstra\'s algorithm.","solution":"from typing import List, Tuple import heapq def calculate_minimum_cost(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> int: def is_inside_grid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(grid[start[0]][start[1]], start[0], start[1])] # (cost, x, y) costs = [[float(\'inf\')] * cols for _ in range(rows)] costs[start[0]][start[1]] = grid[start[0]][start[1]] while pq: current_cost, x, y = heapq.heappop(pq) if (x, y) == goal: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if is_inside_grid(nx, ny): new_cost = current_cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return -1 # This should never be reached if input is reasonable as per constraints"},{"question":"# Coding Challenge: Rotate Matrix Problem Description Given a square matrix `matrix`, write a function that rotates the matrix by 90 degrees in the clockwise direction. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input - `matrix` (list of list of integers): A 2D square list where each element represents an integer. # Output - Returns a list of list of integers representing the rotated matrix. # Constraints - The size of the matrix, `n`, is between 1 and 500. # Example ```python # Example 1: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2: matrix = [ [5] ] # Output should be: # [ # [5] # ] # Example 3: matrix = [ [1, 0], [0, 1] ] # Output should be: # [ # [0, 1], # [1, 0] # ] # Example 4: matrix = [ [2, 4, 6, 8], [1, 3, 5, 7], [9, 11, 13, 15], [10, 12, 14, 16] ] # Output should be: # [ # [10, 9, 1, 2], # [12, 11, 3, 4], # [14, 13, 5, 6], # [16, 15, 7, 8] # ] ``` # Constraints and Requirements - You should handle both small and large sized matrices efficiently. - Aim to keep your algorithm within O(n^2) time complexity as matrix manipulation inherently involves processing all elements. # Performance Requirements - The function should handle the maximum matrix size of 500x500 efficiently. # Scenario In a graphical application or game, you need to rotate elements for rendering transformations. This operation is essential for updating the view based on user interactions or animations.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the input matrix by 90 degrees in the clockwise direction. Args: matrix (list of list of ints): A 2D square matrix to be rotated. Returns: list of list of ints: A new matrix that has been rotated by 90 degrees clockwise. n = len(matrix) # Create a new n x n matrix for the result result = [[0] * n for _ in range(n)] # Populate the result matrix for i in range(n): for j in range(n): result[j][n - 1 - i] = matrix[i][j] return result"},{"question":"# Task: Implement a Parking Lot Management System Problem Statement: You are required to implement a class `ParkingLot` to simulate a parking lot management system. This system should handle vehicle parking and retrieval, keeping track of free and occupied slots efficiently. Details: - **Class**: `ParkingLot` - **Methods** - `__init__(self, capacity: int) -> None`: Initializes the parking lot with a given capacity. - `park_vehicle(self, vehicle_plate: str) -> bool`: Parks a vehicle with the given plate number. Returns `True` if successful, `False` if the lot is full. - `leave_lot(self, vehicle_plate: str) -> bool`: Frees the spot occupied by the vehicle with the given plate number. Returns `True` if successful, `False` if the vehicle is not found. - `get_occupied_slots(self) -> int`: Returns the number of occupied slots. Constraints: - The parking lot\'s capacity is between 1 and 10,000. - Each vehicle has a unique plate number string (1 to 10 alphanumeric characters). - You may assume plate numbers are case-sensitive. - Attempting to park an already parked vehicle should return `False`. - The system should be able to handle multiple operations efficiently. Scenario: Consider a parking lot management system at a busy airport where vehicles arrive and depart frequently. The system needs to keep track of available slots and ensure quick parking and retrieval to prevent delays. Edge Cases: - Parking a vehicle when the lot is full. - Attempting to retrieve a vehicle not parked in the lot. - Handling repeated park and retrieval operations efficiently. Skeleton Code: ```python class ParkingLot: def __init__(self, capacity: int) -> None: self.capacity = capacity self.occupied_slots = 0 self.vehicles = set() def park_vehicle(self, vehicle_plate: str) -> bool: if self.occupied_slots < self.capacity and vehicle_plate not in self.vehicles: self.vehicles.add(vehicle_plate) self.occupied_slots += 1 return True return False def leave_lot(self, vehicle_plate: str) -> bool: if vehicle_plate in self.vehicles: self.vehicles.remove(vehicle_plate) self.occupied_slots -= 1 return True return False def get_occupied_slots(self) -> int: return self.occupied_slots ``` Hints: 1. Utilize a set to store the plate numbers, ensuring O(1) time complexity for park and leave operations. 2. Handle edge cases such as parking a vehicle when full or removing a vehicle not in the lot appropriately. 3. Ensure the system scales efficiently with the constraints provided. Implement the `ParkingLot` class along with methods for parking, retrieving, and checking the number of occupied slots. Write corresponding test cases to verify its correctness in various scenarios.","solution":"class ParkingLot: def __init__(self, capacity: int) -> None: self.capacity = capacity self.occupied_slots = 0 self.vehicles = set() def park_vehicle(self, vehicle_plate: str) -> bool: if self.occupied_slots < self.capacity and vehicle_plate not in self.vehicles: self.vehicles.add(vehicle_plate) self.occupied_slots += 1 return True return False def leave_lot(self, vehicle_plate: str) -> bool: if vehicle_plate in self.vehicles: self.vehicles.remove(vehicle_plate) self.occupied_slots -= 1 return True return False def get_occupied_slots(self) -> int: return self.occupied_slots"},{"question":"# **Binary Search Tree Operations** Binary Search Trees (BST) are fundamental data structures used for efficient data storage, searching, and retrieval. In this task, you are required to implement a function that performs multiple operations on a Binary Search Tree. **BST Operations** 1. **Insert Operation**: Inserts a given value into the BST. 2. **Search Operation**: Searches for a given value in the BST, returning True if found, otherwise False. 3. **Delete Operation**: Deletes a given value from the BST if it exists. 4. **In-Order Traversal**: Returns the elements of the BST in sorted order. **Task** 1. Implement a class `BST` that contains methods to perform the operations `insert`, `search`, `delete`, and `in_order_traversal`. 2. Ensure the BST maintains its properties after each operation. Input: - The values to be inserted, searched, or deleted as specified in method calls. Output: - Results from search operations and the final sorted list of BST elements after performing all insertions and deletions. Constraints: - Values to be inserted, searched, or deleted will be integers. - Duplicates may be inserted. **Example** ```python # Initialize BST bst = BST() # Insert values bst.insert(7) bst.insert(3) bst.insert(10) bst.insert(1) bst.insert(5) # Search values print(bst.search(3)) # True print(bst.search(6)) # False # Delete value bst.delete(3) # In-Order Traversal print(bst.in_order_traversal()) # [1, 5, 7, 10] ``` **Function Definitions** ```python class BST: def __init__(self): self.root = None class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key): # Code to insert a new node with the given key. def search(self, key): # Code to search a given key in BST. def delete(self, key): # Code to delete a node with the given key. def in_order_traversal(self): # Code to perform in-order traversal and return the sorted list of elements. ``` **Note** - Ensure that the tree is balanced for optimal time complexity. - Handle edge cases such as insertion of duplicate values, searching in an empty tree, and deleting non-existent values. - Focus on the correctness and efficiency of the operations. This question will test your understanding of data structures, specifically Binary Search Trees, and your ability to implement core operations while maintaining the BST properties.","solution":"class BST: def __init__(self): self.root = None class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = self.Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = self.Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) else: return self._search(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp_val = self._min_value_node(root.right).val root.val = temp_val root.right = self._delete(root.right, temp_val) return root def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, root, res): if root: self._in_order_traversal(root.left, res) res.append(root.val) self._in_order_traversal(root.right, res)"},{"question":"Custom Priority Queue Implementation You are tasked with implementing a custom priority queue using a min-heap. Your main goal will be to manage tasks with specific priorities, allowing for the dynamic insertion and removal of tasks based on their priority. # Requirements 1. Implement a class `CustomPriorityQueue` with the following methods: - `insert(task: str, priority: int) -> None`: Inserts a task with a given priority into the queue. - `extract_min() -> str`: Removes and returns the task with the lowest priority. - `peek_min() -> str`: Returns the task with the lowest priority without removing it. 2. Tasks are represented as strings, and priorities are integers, with a lower number indicating a higher priority. 3. Use a min-heap to implement the priority queue to ensure efficient insertion and extraction operations. # Constraints 1. Priorities will be positive integers. 2. There can be multiple tasks with the same priority. 3. You can assume that the `extract_min` and `peek_min` methods will not be called on an empty queue. # Example ```python pq = CustomPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) print(pq.peek_min()) # Output: \\"task2\\" print(pq.extract_min()) # Output: \\"task2\\" print(pq.peek_min()) # Output: \\"task3\\" ``` **Hint**: Use the heapq module from Python\'s standard library to manage the heap operations.","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] def insert(self, task: str, priority: int) -> None: heapq.heappush(self.heap, (priority, task)) def extract_min(self) -> str: return heapq.heappop(self.heap)[1] def peek_min(self) -> str: return self.heap[0][1]"},{"question":"# Context A company requires a utility to convert strings into their respective ASCII values for a new encryption feature they are developing. The utility must allow repeated conversions and ensure efficient handling of large strings. # Task Implement a function `string_to_ascii` that converts each character of a given string into its corresponding ASCII value. Additionally, ensure the function validates the input and handles large strings efficiently. # Requirements * Your function should take one parameter: a string `input_str`. * Your function should raise a `ValueError` with an appropriate message if: - The input is not a string. * Optimize for the efficient conversion of large strings. * Add a docstring and appropriate error handling as seen in the provided code snippets. # Function Signature ```python def string_to_ascii(input_str: str) -> List[int]: pass ``` # Example Usage ```python >>> string_to_ascii(\\"hello\\") [104, 101, 108, 108, 111] >>> string_to_ascii(\\"world\\") [119, 111, 114, 108, 100] >>> string_to_ascii(\\"\\") [] >>> string_to_ascii(123) Traceback (most recent call last): ... ValueError: input_str must be a string ``` # Constraints and Considerations * Ensure the function handles both small and large strings efficiently. * Optimize for repeated conversions if possible. * The function should return an empty list for an empty string. * Import necessary modules if needed and follow best practices for code clarity and performance.","solution":"from typing import List def string_to_ascii(input_str: str) -> List[int]: Converts each character of the input string into its corresponding ASCII value. Parameters: input_str (str): The input string to convert. Returns: List[int]: A list of ASCII values corresponding to the characters of the input string. Raises: ValueError: If input_str is not a string. if not isinstance(input_str, str): raise ValueError(\\"input_str must be a string\\") return [ord(char) for char in input_str]"},{"question":"# Coding Assessment Question Objective Implement a function to parse a log file and summarize the frequency of different types of actions performed, with an option to filter actions by severity level. Function Signature ```python def summarize_logs(file_path: str, severity_level: str = None) -> dict: pass ``` Input * `file_path`: A string representing the path to the log file. * `severity_level`: An optional string that represents the minimum severity level to include in the summary. Possible values are `\\"INFO\\"`, `\\"WARNING\\"`, and `\\"ERROR\\"`. Default is `None`, meaning all actions should be included. Output * A dictionary where the keys are action types and the values are the counts of occurrences of those actions. Example ```python # Given the following content in `logs.txt`: # [INFO] User login # [WARNING] Disk space low # [ERROR] Unable to save file # [INFO] User logout # [ERROR] Database connection failed # Calling the function as: action_summary = summarize_logs(\\"logs.txt\\") ``` Should return: ```python { \\"User login\\": 1, \\"Disk space low\\": 1, \\"Unable to save file\\": 1, \\"User logout\\": 1, \\"Database connection failed\\": 1 } ``` Calling the function with a specified severity level: ```python action_summary = summarize_logs(\\"logs.txt\\", \\"ERROR\\") ``` Should return: ```python { \\"Unable to save file\\": 1, \\"Database connection failed\\": 1 } ``` Constraints * The log file may contain a large number of entries. * Ensure the function efficiently processes the log file. * Only consider log entries that start with the specified severity level or higher. Implementation Notes 1. Read and parse the log file line by line. 2. Extract the severity level and the action from each log entry. 3. Only include actions in the output summary if they meet the severity level requirement. 4. Handle possible cases of malformed log entries gracefully. Additional Considerations Students should account for edge cases such as empty log files, varying formats of log entries, and unsupported severity levels. Ensure the implementation is robust and can handle different file sizes efficiently.","solution":"def summarize_logs(file_path: str, severity_level: str = None) -> dict: severity_order = {\\"INFO\\": 1, \\"WARNING\\": 2, \\"ERROR\\": 3} severity_threshold = severity_order.get(severity_level, 0) action_counts = {} with open(file_path, \'r\') as file: for line in file: try: parts = line.split(\'] \') severity = parts[0].strip(\'[\') action = parts[1].strip() if severity_order.get(severity, 0) >= severity_threshold: if action in action_counts: action_counts[action] += 1 else: action_counts[action] = 1 except IndexError: continue # Skip malformed lines return action_counts"},{"question":"# Question Context A developer needs to review a collection of log entries from a server to identify all unique IP addresses recorded within a specific time frame. Each log entry consists of a timestamp and an IP address. Your task is to extract and return a sorted list of these unique IP addresses within the given range of timestamps. Objective Write a function `unique_ips_within_timeframe` that processes the log entries and extracts the unique IP addresses within the specified time frame. Function Signature ```python def unique_ips_within_timeframe(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: ``` Input - **logs**: A list of tuples, each containing a timestamp (string in \\"YYYY-MM-DD HH:MM:SS\\" format) and an IP address (string). - **start_time**: The start of the time frame (string in \\"YYYY-MM-DD HH:MM:SS\\" format). - **end_time**: The end of the time frame (string in \\"YYYY-MM-DD HH:MM:SS\\" format). Output - A list of unique IP addresses (strings) sorted in ascending order, found within the given time frame. Constraints - Timestamps are provided in the format \\"YYYY-MM-DD HH:MM:SS\\". - The start_time is inclusive, and the end_time is exclusive. - The input logs are sorted by timestamp in ascending order. Example 1. Given logs: ```python logs = [ (\\"2023-01-01 10:00:00\\", \\"192.168.1.1\\"), (\\"2023-01-01 10:30:00\\", \\"192.168.1.2\\"), (\\"2023-01-01 11:00:00\\", \\"192.168.1.3\\"), (\\"2023-01-01 11:30:00\\", \\"192.168.1.1\\"), (\\"2023-01-01 12:00:00\\", \\"192.168.1.4\\"), (\\"2023-01-01 12:30:00\\", \\"192.168.1.2\\"), ] ``` 2. Calling `unique_ips_within_timeframe(logs, \\"2023-01-01 10:00:00\\", \\"2023-01-01 12:00:00\\")` should return `[\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\"]`. Additional Requirements - Raise a `ValueError` with an appropriate message if **start_time** is not in the correct format or if **end_time** is less than or equal to **start_time**. # Notes - Ensure your function handles various edge cases, such as overlapping or non-overlapping time frames. - Optimize for both time and space complexities where possible.","solution":"from typing import List, Tuple from datetime import datetime def unique_ips_within_timeframe(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: Extract and return the sorted list of unique IP addresses recorded within the given time frame. Parameters: logs (List[Tuple[str, str]]): A list of tuples containing a timestamp and an IP address. start_time (str): The start of the time frame (inclusive). end_time (str): The end of the time frame (exclusive). Returns: List[str]: Sorted list of unique IP addresses within the time frame. try: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") except ValueError: raise ValueError(\\"Timestamp format should be \'YYYY-MM-DD HH:MM:SS\'\\") if end_dt <= start_dt: raise ValueError(\\"end_time must be greater than start_time\\") unique_ips = set() for timestamp, ip in logs: current_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= current_dt < end_dt: unique_ips.add(ip) return sorted(unique_ips)"},{"question":"# Question: Sum of Series with Negative Values You are tasked with implementing a function to sum the values in a list that contains both positive and negative integers. The input list may also contain zeroes. The function should return the sum of all the elements. Implement the following function: **1. Function `sum_of_series(series: list) -> int`:** * **Input**: A list of integers. * **Output**: An integer representing the sum of the series. * **Constraints**: * Raise a `ValueError` for invalid input or if the input list is empty. Example ```python >>> sum_of_series([1, -2, 3, -4, 5]) 3 >>> sum_of_series([0, 0, 0, 0]) 0 >>> sum_of_series([-1, -2, -3, -4]) -10 >>> sum_of_series([5]) 5 >>> sum_of_series([]) Traceback (most recent call last): ... ValueError: Input list is empty or invalid. ``` Notes: * Your function should raise a `ValueError` if the input is not a list of integers or if the list is empty. * Consider edge cases, such as an empty list and lists with only negative numbers. Performance Requirements * Your implementation should be O(n) in time complexity and O(1) in space complexity. **Good Luck!**","solution":"def sum_of_series(series): Returns the sum of values in a series/list that contains integers. Parameters: series (list of int): The input list of integers. Returns: int: The sum of all integers in the series. Raises: ValueError: If the input is not a list or if the list is empty. if not isinstance(series, list) or not all(isinstance(i, int) for i in series) or not series: raise ValueError(\\"Input list is empty or invalid.\\") return sum(series)"},{"question":"# Scenario You are developing software for a company that processes large sets of geographical data. One task is to find the closest pair of coordinates among a given set of coordinates. # Function Details Implement a function `find_closest_pair` that takes a list of tuples where each tuple contains two floating-point numbers representing the latitude and longitude of a coordinate point. The function should return a tuple of tuples containing the two coordinates that are closest to each other. # Requirements - The function should use the Euclidean distance formula to compute the distance between two points. - The function should return the coordinates in the order they appear in the list. - If the list has fewer than two coordinates, the function should raise a `ValueError`. # Input and Output - **Input**: - `coordinates` (list of tuples): Each tuple contains two floats, representing the latitude and longitude of a point. - **Output**: - Return a tuple containing two tuples, each tuple having two floats, representing the closest pair of coordinates. # Constraints - The coordinates list will contain at least 2 points and no more than 1000 points. - Latitude and longitude values range from -180.0 to 180.0. # Example ```python # Example of a function call coords = [(34.0522, -118.2437), (40.7128, -74.0060), (37.7749, -122.4194), (34.0522, -118.2436)] closest_pair = find_closest_pair(coords) print(closest_pair) # Expected output: ((34.0522, -118.2437), (34.0522, -118.2436)) coords = [(19.4326, -99.1332), (51.5074, -0.1278), (48.8566, 2.3522), (40.4168, -3.7038)] closest_pair = find_closest_pair(coords) print(closest_pair) # Expected output: ((51.5074, -0.1278), (48.8566, 2.3522)) ``` # Notes Handle edge cases such as when coordinates are extremely close to each other. Ensure that the function runs efficiently even for the upper limit of input size. A nested loop to compare each point with every other point may be acceptable for this range of constraints.","solution":"import math def euclidean_distance(coord1, coord2): return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2) def find_closest_pair(coordinates): if len(coordinates) < 2: raise ValueError(\\"At least two coordinates are required\\") min_distance = float(\'inf\') closest_pair = None for i in range(len(coordinates)): for j in range(i + 1, len(coordinates)): distance = euclidean_distance(coordinates[i], coordinates[j]) if distance < min_distance: min_distance = distance closest_pair = (coordinates[i], coordinates[j]) return closest_pair"},{"question":"# Time-Sensitive Task Manager Objective Create a `TaskManager` class that allows users to efficiently manage and complete a list of tasks, each with a specific deadline and priority. The system should handle tasks dynamically, ensuring high-priority tasks are addressed first, especially close to their deadlines. Instructions 1. **Class Definition**: Write a class `TaskManager` that: - Maintains a list of tasks, each with a name, deadline, and priority. - Provides methods to add and remove tasks. - Allows extracting the highest priority task considering deadlines. - Automatically updates task priorities as deadlines approach. 2. **Class Methods**: - `add_task(name: str, deadline: datetime, priority: int) -> None`: Adds a `Task` with a specified name, deadline, and priority. - `remove_task(name: str) -> None`: Removes a `Task` based on its name. - `get_next_task() -> dict`: Returns the most urgent `Task` as a dictionary with keys `name`, `deadline`, and `priority`. - `update_priorities() -> None`: Updates priority values for all tasks based on their proximity to their deadlines. 3. **Task Priority Rules**: - Tasks can have priority values between 1 (highest) and 10 (lowest). - Task priorities should increase as their deadlines get closer. - Ensure that tasks that are close to missing their deadlines are automatically adjusted to the highest priority. 4. **Task Validation**: - Tasks should not have deadlines set in the past. - Ensure there are no duplicate task names. # Example Here\'s an example of how your `TaskManager` can be used: ```python from datetime import datetime, timedelta # Create an instance of TaskManager manager = TaskManager() # Add tasks manager.add_task(\\"Submit report\\", datetime.now() + timedelta(days=1), 3) manager.add_task(\\"Plan meeting\\", datetime.now() + timedelta(days=3), 5) manager.add_task(\\"Code review\\", datetime.now() + timedelta(hours=8), 4) # Update priorities based on current time manager.update_priorities() # Get the next task to be addressed next_task = manager.get_next_task() print(\\"Next Task:\\", next_task) # Remove a task by name manager.remove_task(\\"Plan meeting\\") ``` Constraints - The date and time handling should utilize Python\'s `datetime` module for accuracy. - Initial task priorities range strictly from 1 to 10. - Maximum number of tasks the `TaskManager` can handle at a time is 50.","solution":"from datetime import datetime, timedelta class TaskManager: def __init__(self): self.tasks = [] # List to store tasks as dictionaries with keys: name, deadline, priority def add_task(self, name: str, deadline: datetime, priority: int) -> None: # Check that the deadline is not in the past if deadline < datetime.now(): raise ValueError(\\"The deadline should be in the future\\") # Check for duplicate task names if any(task[\'name\'] == name for task in self.tasks): raise ValueError(\\"A task with this name already exists\\") # Add the task to the list self.tasks.append({\'name\': name, \'deadline\': deadline, \'priority\': priority}) def remove_task(self, name: str) -> None: self.tasks = [task for task in self.tasks if task[\'name\'] != name] def get_next_task(self) -> dict: self.update_priorities() # Sort the tasks first by priority, then by deadline sorted_tasks = sorted(self.tasks, key=lambda x: (x[\'priority\'], x[\'deadline\'])) return sorted_tasks[0] if sorted_tasks else None def update_priorities(self) -> None: current_time = datetime.now() for task in self.tasks: time_remaining = (task[\'deadline\'] - current_time).total_seconds() # Prioritize tasks near their deadlines (within 1 day) by setting higher priority if time_remaining < 24 * 60 * 60: # less than 1 day remaining task[\'priority\'] = 1 elif time_remaining < 2 * 24 * 60 * 60: # 1 to 2 days remaining task[\'priority\'] = min(2, task[\'priority\']) elif time_remaining < 3 * 24 * 60 * 60: # 2 to 3 days remaining task[\'priority\'] = min(3, task[\'priority\']) else: # The farther the deadline, the lower the priority becomes; normalize between 4 and 10 days_remaining = time_remaining // (24 * 60 * 60) task[\'priority\'] = min(max(4, 10 - int(days_remaining)), task[\'priority\'])"},{"question":"# Data Transformation and Aggregation Write a Python function to process a CSV file containing sales data and generate a summary report. The file contains rows with the columns: `Date`, `ProductID`, `QuantitySold`, and `SalePrice`. Your task is to calculate the total revenue and total quantity sold for each `ProductID`. Function Signature ```python def summarize_sales(input_csv: str, output_csv: str) -> None: Process sales data from a CSV file and generate a summary report. Args: input_csv (str): The filename of the input CSV containing sales data. output_csv (str): The filename of the output CSV to write the summary report. Returns: None ``` Constraints 1. The input CSV file contains an arbitrary number of rows. 2. Each row contains four columns: `Date`, `ProductID`, `QuantitySold`, and `SalePrice`. 3. The `Date` column is in the format `YYYY-MM-DD`. 4. The `ProductID` is a string identifier for the product. 5. `QuantitySold` is an integer representing the number of units sold. 6. `SalePrice` is a float representing the price at which each unit is sold. Requirements 1. Implement the `summarize_sales` function to read the input CSV file. 2. Aggregate the total revenue and total quantity sold for each `ProductID`. 3. Write the summarized data to the output CSV file with columns: `ProductID`, `TotalQuantitySold`, `TotalRevenue`. 4. Ensure the output CSV contains one row per `ProductID`. Example Assuming `sales.csv` contains: ``` Date,ProductID,QuantitySold,SalePrice 2023-01-01,A134,5,10.0 2023-01-02,B247,3,20.0 2023-01-01,A134,7,10.0 2023-01-03,B247,2,20.0 ``` Calling the function as follows: ```python summarize_sales(\'sales.csv\', \'summary.csv\') ``` The `summary.csv` should contain: ``` ProductID,TotalQuantitySold,TotalRevenue A134,12,120.0 B247,5,100.0 ``` Notes - Handle potential edge cases, such as missing columns or improper data types, with appropriate error messages. - Focus on efficient file reading and writing operations. - Ensure the output is written in a comma-separated format and maintain the order of columns as specified in the requirements.","solution":"import csv def summarize_sales(input_csv: str, output_csv: str) -> None: Process sales data from a CSV file and generate a summary report. Args: input_csv (str): The filename of the input CSV containing sales data. output_csv (str): The filename of the output CSV to write the summary report. Returns: None # Dictionary to hold the summary data summary = {} # Reading the input CSV file with open(input_csv, mode=\'r\', newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: product_id = row[\'ProductID\'] quantity_sold = int(row[\'QuantitySold\']) sale_price = float(row[\'SalePrice\']) total_revenue = quantity_sold * sale_price if product_id not in summary: summary[product_id] = {\'TotalQuantitySold\': 0, \'TotalRevenue\': 0.0} summary[product_id][\'TotalQuantitySold\'] += quantity_sold summary[product_id][\'TotalRevenue\'] += total_revenue # Writing the summary to the output CSV file with open(output_csv, mode=\'w\', newline=\'\') as csvfile: fieldnames = [\'ProductID\', \'TotalQuantitySold\', \'TotalRevenue\'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for product_id, data in summary.items(): writer.writerow({ \'ProductID\': product_id, \'TotalQuantitySold\': data[\'TotalQuantitySold\'], \'TotalRevenue\': data[\'TotalRevenue\'] })"},{"question":"# Find Missing Element in Consecutive List In a list of consecutive integers where exactly one integer is missing, you need to identify the missing integer. The list will always have at least two numbers and all the integers in the list will be unique. Problem Statement Implement the function `find_missing_element(numbers: List[int]) -> int`. This function should determine and return the missing integer in the provided list. # Input - `numbers` (List[int]): A list of unique consecutive integers with one integer missing. # Output - Returns an integer: The missing integer in the list. # Constraints - The length of the list will be at least 2 and at most 10^6. - The integers in the list can be both positive and negative, but they will always form a consecutive series with exactly one missing element. # Performance Requirements - The algorithm should run with a time complexity of O(n) and a space complexity of O(1). # Example ```python numbers = [1, 2, 4, 5] missing_element = find_missing_element(numbers) assert missing_element == 3 numbers = [-3, -2, -1, 0, 1, 2, 4] missing_element = find_missing_element(numbers) assert missing_element == 3 numbers = [10, 11, 12, 14] missing_element = find_missing_element(numbers) assert missing_element == 13 ``` Your task is to implement the function `find_missing_element` that performs this task while considering the constraints and requirements outlined above.","solution":"def find_missing_element(numbers): Identifies the missing integer in a list of consecutive integers. Parameters: numbers (List[int]): A list of unique consecutive integers with one integer missing. Returns: int: The missing integer in the list. n = len(numbers) total_num_elements = n + 1 sum_of_elements = sum(numbers) first_element = min(numbers) last_element = max(numbers) expected_sum = (total_num_elements * (first_element + last_element)) // 2 missing_element = expected_sum - sum_of_elements return missing_element"},{"question":"# Coding Assessment Question You are tasked with implementing a function to simulate a simple file system. The file system supports directory creation and listing directory contents. Your function should be able to create nested directories and print the directory structure. # Inputs * commands: A list of strings representing the commands to be executed on the file system. - Each command will be one of the following: - `\\"mkdir <path>\\"`: Create a directory at the specified path. If parent directories do not exist, recursively create them. - `\\"ls <path>\\"`: List the contents of the directory at the specified path. Return a list of directory names in lexicographical order. # Outputs * A list of strings representing the output of `\\"ls <path>\\"` commands. # Constraints * The directory paths are specified in a Unix-like format using `/` as the directory separator. * The input paths for `mkdir` and `ls` commands are always valid and within a reasonable depth (e.g., no more than 255 characters per path). # Example ```python commands = [ \\"mkdir /home\\", \\"mkdir /home/user\\", \\"mkdir /home/user/docs\\", \\"mkdir /home/user/docs/assignments\\", \\"mkdir /home/user/photos\\", \\"ls /home/user\\", \\"ls /home/user/docs\\" ] # Expected output: [ # [\\"docs\\", \\"photos\\"], # [\\"assignments\\"] # ] ``` # Implementation You need to complete the implementation of the `simulate_file_system` function: ```python def simulate_file_system(commands): from collections import defaultdict file_system = defaultdict(list) def add_directory(path): parts = path.strip(\'/\').split(\'/\') current = file_system for part in parts: if part not in current: current[part] = defaultdict(list) current = current[part] def list_directory(path): parts = path.strip(\'/\').split(\'/\') current = file_system for part in parts: if part not in current: return [] current = current[part] return sorted(current.keys()) result = [] for command in commands: if command.startswith(\\"mkdir \\"): path = command[6:].strip() add_directory(path) elif command.startswith(\\"ls \\"): path = command[3:].strip() result.append(list_directory(path)) return result # Test your implementation with multiple cases to ensure correctness. ```","solution":"def simulate_file_system(commands): from collections import defaultdict file_system = defaultdict(dict) def add_directory(path): parts = path.strip(\'/\').split(\'/\') current = file_system for part in parts: if part not in current: current[part] = {} current = current[part] def list_directory(path): parts = path.strip(\'/\').split(\'/\') current = file_system for part in parts: if part not in current: return [] current = current[part] return sorted(current.keys()) result = [] for command in commands: if command.startswith(\\"mkdir \\"): path = command[6:].strip() add_directory(path) elif command.startswith(\\"ls \\"): path = command[3:].strip() result.append(list_directory(path)) return result"},{"question":"You are asked to enhance an existing function `fetch_openweather_city_data` to improve its capability to handle various edge cases and optimize performance. The function should collect weather data from the OpenWeatherMap API and process the information as specified. Ensure to include the following improvements: 1. **Error Handling**: - Properly manage non-2xx HTTP responses and invalid API keys. - Incorporate retries with a fixed delay and limited attempts in case of transient issues (e.g., temporary server unavailability). 2. **Performance**: - Introduce asynchronous I/O to handle multiple city requests concurrently, utilizing Python\'s `aiohttp` and `asyncio`. 3. **Data Validation**: - Verify that the response contains the expected data structure before accessing it. - Provide default values or handle cases where certain fields may be missing in the response. Write the function `fetch_openweather_city_data_async` with the following signature: ```python import aiohttp # You are allowed to use aiohttp for this task import asyncio from typing import List, Dict, Union async def fetch_openweather_city_data_async(cities: List[str], api_key: str) -> List[Dict[str, Union[str, float, int]]]: # Your implementation here ``` # Input: - `cities` (list of str): A list of city names to fetch weather data for. - `api_key` (str): Your API key for authenticating with the OpenWeatherMap API. # Output: - Returns a list of dictionaries, each containing the following weather details for one city: - `city` (str) - `temperature` (float) - `humidity` (int) - `weather_description` (str) # Constraints: - You may assume the cities list contains valid city names. - The API key should be valid and not exceed rate limits. - The function should handle up to 20 city requests concurrently and complete within a reasonable time frame (e.g., a few seconds for 20 cities). # Example: ```python import asyncio cities = [\\"London\\", \\"Paris\\", \\"New York\\"] api_key = \\"your_api_key\\" weather_data = asyncio.run(fetch_openweather_city_data_async(cities, api_key)) print(weather_data) ``` This code should print a list of dictionaries containing weather details (temperature, humidity, and weather description) for each city in the input list.","solution":"import aiohttp import asyncio from typing import List, Dict, Union async def fetch_weather_for_city(session, city, api_key, retries=3, delay=1): url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\" for attempt in range(retries): try: async with session.get(url) as response: if response.status == 200: data = await response.json() if \'main\' in data and \'weather\' in data: return { \\"city\\": city, \\"temperature\\": data[\'main\'].get(\'temp\', float(\'nan\')), \\"humidity\\": data[\'main\'].get(\'humidity\', 0), \\"weather_description\\": data[\'weather\'][0].get(\'description\', \'No description\') } else: return { \\"city\\": city, \\"temperature\\": float(\'nan\'), \\"humidity\\": 0, \\"weather_description\\": \'Invalid data\' } elif response.status == 401: raise ValueError(\\"Invalid API key\\") else: # For non-2xx responses (excluding 401) await asyncio.sleep(delay) except aiohttp.ClientError: # Wait before retrying in case of transient network issues await asyncio.sleep(delay) # If all retries fail return { \\"city\\": city, \\"temperature\\": float(\'nan\'), \\"humidity\\": 0, \\"weather_description\\": \'Request failed after retries\' } async def fetch_openweather_city_data_async(cities: List[str], api_key: str) -> List[Dict[str, Union[str, float, int]]]: async with aiohttp.ClientSession() as session: tasks = [fetch_weather_for_city(session, city, api_key) for city in cities] return await asyncio.gather(*tasks)"},{"question":"Scenario You are developing a new feature for a ride-sharing application. The feature is supposed to analyze the duration of rides based on historical data. Given a list of ride durations in minutes, implement a function that detects any anomalies. An anomaly is defined as a duration that deviates from the mean duration by more than 2 standard deviations. # Question Write a function `detect_anomalies` that takes as input a list of ride durations and performs the following tasks: 1. Calculate the mean and standard deviation of the ride durations. 2. Identify any anomalies based on the criteria above. 3. Return a list of indices where anomalies are found. # Input * A list of integers (e.g., `[15, 20, 25, 950, 30, 18, 22, 19, 21, 20]`). # Output * A list of integers representing the indices of the anomalous ride durations. # Constraints 1. The list will contain up to (10^6) elements. 2. Each element in the list will be a positive integer less than (10^6). # Example ```python detect_anomalies([15, 20, 25, 950, 30, 18, 22, 19, 21, 20]) # Output: [3] detect_anomalies([15, 16, 15, 14, 15]) # Output: [] detect_anomalies([20, 22, 19]) # Output: [] ``` # Notes * The function must handle empty lists by raising a `ValueError`. * Use Welford\'s method to calculate mean and standard deviation for numerical stability when dealing with large datasets. # Function Signature ```python def detect_anomalies(durations: list) -> list: pass ```","solution":"import math def detect_anomalies(durations): if not durations: raise ValueError(\\"The list of durations is empty.\\") # Variables to store the mean and variance mean = 0 M2 = 0 n = 0 # Welford\'s online algorithm to calculate mean and variance for x in durations: n += 1 delta = x - mean mean += delta / n delta2 = x - mean M2 += delta * delta2 if n < 2: raise ValueError(\\"At least two durations are required to detect anomalies.\\") variance = M2 / (n - 1) stddev = math.sqrt(variance) anomalies = [] for i, x in enumerate(durations): if abs(x - mean) > 2 * stddev: anomalies.append(i) return anomalies"},{"question":"# Coding Question You are given a list of points on a 2D plane, where each point is represented as a tuple `(x, y)` of its coordinates. Your task is to implement a function `find_closest_points` that takes the list of points and a target point, and returns the `k` closest points to the target point based on Euclidean distance. Function Signature ```python def find_closest_points( points: list[tuple[int, int]], target: tuple[int, int], k: int ) -> list[tuple[int, int]]: Find the k closest points to a target point. Parameters: - points (list[tuple[int, int]]): A list of points on a 2D plane. - target (tuple[int, int]): A tuple representing the coordinates of the target point. - k (int): The number of closest points to return. Returns: - list[tuple[int, int]]: A list of the k closest points to the target. pass ``` Input 1. `points`: A list of `n` points where each point is represented as a tuple `(x, y)` with `x` and `y` being integers. 2. `target`: A tuple `(x, y)` representing the coordinates of the target point. 3. `k`: An integer (1 ≤ `k` ≤ `n`) indicating the number of closest points to return. Output A list of `k` tuples representing the closest points to the target point based on Euclidean distance. Example ```python points = [(1, 2), (3, 4), (1, -1), (-1, -2), (5, 2)] target = (0, 0) k = 3 # Output: [(1, -1), (1, 2), (-1, -2)] ``` Constraints: - **Performance** should be optimized to handle large inputs efficiently. - Assume all points have distinct coordinates. Notes: - Use the Euclidean distance formula to compute the distance between points. - Consider utilizing a min-heap or sorting mechanism to determine the k closest points efficiently. - Pay attention to edge cases where points might be equidistant to the target point.","solution":"import math from heapq import nsmallest def find_closest_points(points, target, k): Find the k closest points to a target point. Parameters: - points (list[tuple[int, int]]): A list of points on a 2D plane. - target (tuple[int, int]): A tuple representing the coordinates of the target point. - k (int): The number of closest points to return. Returns: - list[tuple[int, int]]: A list of the k closest points to the target. def euclidean_distance(point): return math.sqrt((point[0] - target[0]) ** 2 + (point[1] - target[1]) ** 2) closest_points = nsmallest(k, points, key=euclidean_distance) return closest_points"},{"question":"A popular game involves arranging different pieces within a grid. You are given a grid represented by an `n x n` matrix filled with integers. A piece is defined as a vertical or horizontal line of contiguous cells with the same integer value. Your task is to find the longest piece in the grid. # Task Write a function `longest_piece(grid: List[List[int]]) -> int` that takes a grid as an input and returns the length of the longest contiguous piece in the grid. # Input - A list of lists, `grid`, representing an `n x n` matrix of integers where (1 ≤ n ≤ 100). # Output - An integer representing the length of the longest contiguous piece in the grid. # Constraints - The grid will only contain integers between `0` and `100`. - The function should be efficient in terms of time complexity. # Example ```python # Example case grid = [ [1, 2, 2, 2, 3], [4, 5, 6, 7, 8], [9, 0, 0, 0, 0], [1, 1, 1, 5, 6], [7, 8, 9, 4, 4] ] longest_piece(grid) # 4 ``` # Implementation Notes 1. Traverse the grid to find all horizontal and vertical pieces. 2. Keep track of the lengths of the contiguous pieces. 3. Return the length of the longest piece found.","solution":"from typing import List def longest_piece(grid: List[List[int]]) -> int: n = len(grid) def get_max_len(sequence): max_len = cur_len = 1 for i in range(1, len(sequence)): if sequence[i] == sequence[i-1]: cur_len += 1 else: max_len = max(max_len, cur_len) cur_len = 1 return max(max_len, cur_len) max_length = 0 # Check horizontal pieces for row in grid: max_length = max(max_length, get_max_len(row)) # Check vertical pieces for col in range(n): column = [grid[row][col] for row in range(n)] max_length = max(max_length, get_max_len(column)) return max_length"},{"question":"# Coding Assessment Question Scenario We\'ve been delving into string manipulation and pattern recognition algorithms. Your task is to implement a function that recognizes and processes a specific type of pattern within a given text. Problem Statement Implement a function `encode_string(s: str) -> str` that encodes a string based on the frequency and order of characters in it. The encoding should follow these rules: 1. Each group of consecutive identical characters in the input string should be replaced by the character followed by the number of occurrences of that character (e.g., \\"aaabb\\" becomes \\"a3b2\\"). Input - A string `s` where (1 leq |s| leq 10^5). The string consists only of lowercase English letters. Output - Returns the encoded version of the given string. Constraints - Ensure the function processes the string efficiently to handle the upper limit of the input size. - Handle edge cases such as strings with no repeated characters or strings with all identical characters. Example ```python assert encode_string(\\"aaabb\\") == \\"a3b2\\" assert encode_string(\\"a\\") == \\"a1\\" assert encode_string(\\"abc\\") == \\"a1b1c1\\" assert encode_string(\\"zzz\\") == \\"z3\\" ```","solution":"def encode_string(s: str) -> str: Encodes the string based on the frequency and order of characters. Args: s (str): The input string consisting of lowercase English letters. Returns: str: Encoded string as per the given rules. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(f\\"{s[i - 1]}{count}\\") count = 1 # Append the last group of characters encoded_string.append(f\\"{s[-1]}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Longest Common Subsequence (LCS) in Two Strings with Path Reconstruction Objective You have been provided with a base implementation to find the longest common subsequence (LCS) between two strings. However, the current implementation only returns the length of the LCS. In real-world applications, it is often necessary to reconstruct the actual LCS itself. Task Modify the existing LCS implementation to not only calculate the length of the LCS but also reconstruct the sequence itself. You need to adapt the algorithm to backtrack and build the LCS string. Input 1. **String 1**: A string representing the first sequence. 2. **String 2**: A string representing the second sequence. Output 1. **Length of LCS**: An integer representing the length of the longest common subsequence. 2. **LCS String**: A string representing the actual longest common subsequence found. Constraints 1. The length of each input string does not exceed 1000. 2. The input strings contain only uppercase English letters. Performance Requirements * The solution should have a time complexity not exceeding O(n*m), where n and m are the lengths of the two input strings. * Space complexity should be managed efficiently to allow backtracking for LCS reconstruction. Scenario Consider two DNA sequences represented by strings. Identifying the longest common subsequence between these two sequences is crucial for understanding similarities and evolutionary relationships. Example ```python string1 = \\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\" string2 = \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\" # Expected output: Length of LCS = 20, LCS String = \\"GTCGTCGGAAGCCGGCCGAA\\" ``` Implement the modified algorithm in a class `LongestCommonSubsequence` with the following methods: - `compute_lcs_length`: Computes and returns the length of the LCS. - `compute_lcs`: Computes and returns the actual LCS string along with its length. ```plaintext class LongestCommonSubsequence: def __init__(self, string1: str, string2: str): # Constructor to initialize the strings def compute_lcs_length(self) -> int: # Method to compute the length of the LCS only def compute_lcs(self) -> (int, str): # Method to compute the length and the actual LCS string # Example usage lcs_solver = LongestCommonSubsequence(string1, string2) lcs_length = lcs_solver.compute_lcs_length() lcs_length, lcs_string = lcs_solver.compute_lcs() ```","solution":"class LongestCommonSubsequence: def __init__(self, string1: str, string2: str): self.string1 = string1 self.string2 = string2 self.m = len(string1) self.n = len(string2) self.dp = [[0] * (self.n + 1) for _ in range(self.m + 1)] def compute_lcs_length(self) -> int: for i in range(1, self.m + 1): for j in range(1, self.n + 1): if self.string1[i - 1] == self.string2[j - 1]: self.dp[i][j] = self.dp[i - 1][j - 1] + 1 else: self.dp[i][j] = max(self.dp[i - 1][j], self.dp[i][j - 1]) return self.dp[self.m][self.n] def compute_lcs(self) -> (int, str): self.compute_lcs_length() i, j = self.m, self.n lcs = [] while i > 0 and j > 0: if self.string1[i - 1] == self.string2[j - 1]: lcs.append(self.string1[i - 1]) i -= 1 j -= 1 elif self.dp[i - 1][j] > self.dp[i][j - 1]: i -= 1 else: j -= 1 lcs.reverse() return self.dp[self.m][self.n], \'\'.join(lcs)"},{"question":"# Coding Problem: Longest Subsequence by Sum Context: In data analysis and algorithm development, it is often necessary to find subsequences within sequences that satisfy specific criteria. One common problem is identifying the longest subsequence of numbers within an array that has a sum less than or equal to a given target value. Task: Write a function `longest_subsequence_by_sum(arr, target_sum)` that: 1. Finds the longest subsequence within the array `arr` such that the sum of its elements is less than or equal to `target_sum`. 2. Returns the length of this longest subsequence and the subsequence itself. **Functions to Implement**: 1. **find_longest_subsequence**: This function computes the longest subsequence and its length. 2. **longest_subsequence_by_sum**: This function integrates the computation to return the desired results. # Example: ```python def longest_subsequence_by_sum( arr: list[int], target_sum: int ) -> tuple[int, list[int]]: # Write your implementation here. pass ``` Given: ```python arr = [5, 1, 3, 2, 5, 7, 3, 9] target_sum = 10 ``` For the input: ```python longest_subsequence_by_sum(arr, target_sum) ``` Expected Output: ```python (3, [1, 3, 5]) ``` Constraints: * Length of the array (0 ≤ length ≤ 1000). * Values in the array (0 ≤ value ≤ 1000). * Target sum (0 ≤ target ≤ 10000). * The function should be optimized to handle the upper limits efficiently. Performance Requirements: - Ensure the solution is efficient in both time and space complexity. - Handle edge cases where the array might be empty or no valid subsequence exists. Implementation Notes: - Use dynamic programming or sliding window techniques to solve the problem efficiently. - Accurately identify and return the longest subsequence and its length. - The solution must handle different configurations of the array and target value correctly.","solution":"def longest_subsequence_by_sum(arr, target_sum): Finds the longest subsequence within the array `arr` such that the sum of its elements is less than or equal to `target_sum`. Args: arr (list[int]): The input array. target_sum (int): The target sum. Returns: tuple: A tuple containing the length of the longest subsequence and the subsequence itself. n = len(arr) if n == 0: return (0, []) max_length = 0 longest_subseq = [] for i in range(n): current_sum = 0 current_subseq = [] for j in range(i, n): if current_sum + arr[j] <= target_sum: current_sum += arr[j] current_subseq.append(arr[j]) if len(current_subseq) > max_length: max_length = len(current_subseq) longest_subseq = current_subseq.copy() else: break return (max_length, longest_subseq)"},{"question":"Find Missing Numbers in an Array You are required to implement a Python function to find all the missing numbers in an array that should contain consecutive numbers from the smallest to the largest number in the array. Your function should use a minimum amount of extra space beyond the input array itself. # Problem Statement Design a function `find_missing_numbers` that takes a list of integers and returns a list of all missing integers in sorted order. **Function Signature**: ```python def find_missing_numbers(arr: list[int]) -> list[int]: pass ``` # Input - `arr`: A list of integers containing duplicates and unordered elements (1 <= len(arr) <= 1000, each integer -10^4 <= arr[i] <= 10^4). # Output - A list of all missing integers in sorted order between the minimum and maximum integer of the array. # Example ```python assert find_missing_numbers([1, 3, 5]) == [2, 4] assert find_missing_numbers([-3, -1, 0, 2, 4]) == [-2, 1, 3] ``` # Constraints - The function should handle cases where no numbers are missing. - The function must not use extra space more than O(1) beyond the output list. - Negative numbers and zeros should also be considered. # Clarifications - If the array already contains all numbers in the range, the function should return an empty list. - Duplicates in the input array should be ignored when determining missing numbers. # Additional Information - The function should efficiently find missing numbers while adhering to the space constraints. - Sorting the array or calculating missing in a space-efficient manner is encouraged.","solution":"def find_missing_numbers(arr: list[int]) -> list[int]: Returns the list of missing numbers in the range of the smallest to largest number in the given list. if not arr: return [] min_num, max_num = min(arr), max(arr) num_set = set(arr) missing_numbers = [num for num in range(min_num, max_num + 1) if num not in num_set] return missing_numbers"},{"question":"# Problem Statement: You are given a list of integers `nums` representing a stream of integers where ( n = text{len}(nums) ). You need to find the median of the stream after each new integer is added. The median is the middle value in an ordered list. If the list has an even number of elements, the median is the average of the two middle values. # Function Signature: ```python def find_medians(nums: list[int]) -> list[float]: pass ``` # Input: * `nums` - A list of integers representing the stream of incoming numbers. # Output: * A list of floating-point numbers representing the median after each new integer is added to the stream. # Constraints: * All integers will be between (-10^5) and (10^5). * The function should raise a `ValueError` if the input is not a list of integers. * The function should return an empty list if the input list is empty. # Performance Requirements: * Time Complexity should be (O(n log n)), where (n) is the number of integers in the stream. * Space Complexity should be (O(n)). # Examples: ```python >>> find_medians([2, 1, 5, 7, 2, 0, 5]) [2, 1.5, 2, 3.5, 2, 2, 2] >>> find_medians([1, 2, 3, 4, 5]) [1, 1.5, 2, 2.5, 3] >>> find_medians([5, 3, 8, 9, 2]) [5, 4, 5, 6.5, 5] >>> find_medians(\'stream\') Traceback (most recent call last): ... ValueError: The numbers should be a list of integers. >>> find_medians([1, 2, \'3\']) Traceback (most recent call last): ... ValueError: The numbers should be a list of integers. >>> find_medians([1, 2, -300000]) Traceback (most recent call last): ... ValueError: The numbers should be between -100000 and 100000. >>> find_medians([]) [] ``` # Description: Implement the function `find_medians` to compute the median of the integers received after each new integer in the stream. Ensure to handle all edge cases and raise appropriate errors for invalid inputs.","solution":"import heapq def find_medians(nums: list[int]) -> list[float]: if not isinstance(nums, list) or not all(isinstance(num, int) for num in nums): raise ValueError(\\"The numbers should be a list of integers.\\") if any(num < -100000 or num > 100000 for num in nums): raise ValueError(\\"The numbers should be between -100000 and 100000.\\") min_heap = [] # Min-heap for the larger half max_heap = [] # Max-heap for the smaller half (simulated with negative values) medians = [] for num in nums: if len(max_heap) == 0 or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) # Balance the heaps if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) # Calculate the median if len(max_heap) > len(min_heap): medians.append(float(-max_heap[0])) else: medians.append((float(-max_heap[0]) + float(min_heap[0])) / 2.0) return medians"},{"question":"# Question: Implement a Moving Average Filter for Time Series Data You are tasked with implementing a moving average filter for a time series dataset. The moving average filter is commonly used in signal processing and time series analysis to smooth out short-term fluctuations and highlight longer-term trends or cycles. Description: The moving average filter operates by averaging a window of a specified size over the time series data. The window slides along the time series, and for each position of the window, the average of the data points within the window is calculated and assigned as the new value. Function Signature: ```python import numpy as np def moving_average_filter(data: np.ndarray, window_size: int) -> np.ndarray: Implements the moving average filter on a time series dataset. Parameters: data (ndarray): A numpy array of numeric values representing the time series data. window_size (int): The size of the moving window for which the average is calculated. Returns: ndarray: An array of the smoothed data using the moving average filter. ``` Input: * `data`: A numpy array of numeric values, representing the time series data. * `window_size`: An integer specifying the number of data points in each window. Output: * A numpy array of the same size as the input `data`, containing the smoothed values calculated using the moving average filter. For positions where the full window cannot be applied (the edges of the data array), use the available data points to compute the average. Constraints: * The input `data` will contain at least one numeric value and will not contain NaN or infinite values. * The `window_size` will be a positive integer less than or equal to the length of the `data` array. Example: ```python >>> import numpy as np >>> data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) >>> window_size = 3 >>> moving_average_filter(data, window_size) array([ 1. , 1.5, 2. , 3. , 4. , 5. , 6. , 7. , 8. , 9. ]) ``` Implement the `moving_average_filter` function according to the above specifications.","solution":"import numpy as np def moving_average_filter(data: np.ndarray, window_size: int) -> np.ndarray: Implements the moving average filter on a time series dataset. Parameters: data (ndarray): A numpy array of numeric values representing the time series data. window_size (int): The size of the moving window for which the average is calculated. Returns: ndarray: An array of the smoothed data using the moving average filter. # Initialize the output array with the same shape as input data filtered_data = np.zeros_like(data, dtype=float) # Calculate the moving average for each position in the data for i in range(len(data)): # Determine the window start and end indices start_idx = max(0, i - window_size + 1) end_idx = i + 1 # Calculate the average for the data points in the window filtered_data[i] = np.mean(data[start_idx:end_idx]) return filtered_data"},{"question":"# Question Objective Write a function `find_non_repeating_substring` that finds the length of the longest substring in a given string where all characters are distinct. This problem involves identifying the maximum segment in a string where no characters are repeated. Algorithm Explanation To solve this problem, a sliding window technique using two pointers can be employed: 1. Initialize two pointers, `start` and `end`, both initially set to the beginning of the string. 2. Expand the window by moving `end` to the right, checking if each character is unique in the current substring. 3. If a repeating character is found, move the `start` pointer to the right position such that all characters in the window are unique again. 4. Keep track of the maximum length encountered during the process. Input and Output * **Input**: A string `s`. * **Output**: An integer representing the length of the longest substring with all distinct characters. Constraints * Consider strings with characters that are part of the ASCII set. * The function should handle both empty strings and strings with repeating characters. * Aim for a time complexity of O(n) and space complexity of O(min(n, m)), where `n` is the length of the string and `m` is the charset size (128 for ASCII). * The function signature should be: `def find_non_repeating_substring(s: str) -> int`. Scenario You are developing a text-editor feature that highlights the longest segment in a given document where no characters are duplicated. This helps users quickly identify unique segments of text. Example ```python >>> s = \\"abcabcbb\\" >>> find_non_repeating_substring(s) 3 # \\"abc\\" is the longest substring with all distinct characters >>> s = \\"bbbbb\\" >>> find_non_repeating_substring(s) 1 # \\"b\\" is the longest substring with all distinct characters >>> s = \\"pwwkew\\" >>> find_non_repeating_substring(s) 3 # \\"wke\\" is the longest substring with all distinct characters >>> s = \\"\\" >>> find_non_repeating_substring(s) 0 # There are no characters in the string, so the length is 0 >>> s = \\"aAbBcC\\" >>> find_non_repeating_substring(s) 6 # \\"aAbBcC\\" is the longest substring with all distinct characters ``` Develop the `find_non_repeating_substring` function to correctly determine the length of the longest distinct character substring for the given examples and scenarios.","solution":"def find_non_repeating_substring(s: str) -> int: Finds the length of the longest substring with all distinct characters. char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Problem Statement: You are provided with a binary search tree (BST) implementation. Extend the BST class with the following functionalities: 1. **find_lca(node1, node2)**: Implement a method to find the lowest common ancestor (LCA) of two given nodes in the BST. The method should return the value of the LCA node. 2. **find_distance(node1, node2)**: Implement a method to find the distance between two nodes in the BST. The distance between two nodes is defined as the number of edges in the shortest path connecting them. If either of the nodes does not exist in the tree, return `-1`. # Expected Input and Output Formats: * For `find_lca(node1, node2)`: * **Input**: * `node1` (int): The value of the first node. * `node2` (int): The value of the second node. * **Output**: * Returns an integer representing the value of the LCA node. * For `find_distance(node1, node2)`: * **Input**: * `node1` (int): The value of the first node. * `node2` (int): The value of the second node. * **Output**: * Returns an integer representing the distance between the two nodes. If either node does not exist, return `-1`. # Constraints: 1. Assume all values in the BST are unique. 2. The number of nodes in the tree can be up to `N = 10^4`. 3. Each node\'s value will be between `1` and `10^6`. # Example: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) print(bst.find_lca(5, 15)) # 10 print(bst.find_distance(5, 35)) # 4 print(bst.find_distance(5, 40)) # -1 (40 does not exist in the tree) ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert_rec(self.root, key) def _insert_rec(self, root, key): if root is None: return TreeNode(key) if key < root.key: root.left = self._insert_rec(root.left, key) else: root.right = self._insert_rec(root.right, key) return root def find_lca(self, node1, node2): # Implement the LCA finding algorithm pass def find_distance(self, node1, node2): # Implement the algorithm to find the distance between two nodes in the BST pass ``` ```python # You can run your tests here bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) print(bst.find_lca(5, 15)) # Expected: 10 print(bst.find_distance(5, 35)) # Expected: 4 print(bst.find_distance(5, 40)) # Expected: -1 ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert_rec(self.root, key) def _insert_rec(self, root, key): if root is None: return TreeNode(key) if key < root.key: root.left = self._insert_rec(root.left, key) else: root.right = self._insert_rec(root.right, key) return root def find_lca(self, node1, node2): def _find_lca(node, p, q): if not node: return None if node.key > p and node.key > q: return _find_lca(node.left, p, q) if node.key < p and node.key < q: return _find_lca(node.right, p, q) return node lca_node = _find_lca(self.root, node1, node2) return lca_node.key if lca_node else None def find_distance(self, node1, node2): def _find_lca(node, p, q): if not node: return None if node.key > p and node.key > q: return _find_lca(node.left, p, q) if node.key < p and node.key < q: return _find_lca(node.right, p, q) return node def _find_level(node, key, level): if not node: return -1 if node.key == key: return level left_level = _find_level(node.left, key, level + 1) if left_level != -1: return left_level return _find_level(node.right, key, level + 1) lca_node = _find_lca(self.root, node1, node2) if not lca_node: return -1 dist1 = _find_level(self.root, node1, 0) dist2 = _find_level(self.root, node2, 0) lca_dist = _find_level(self.root, lca_node.key, 0) if dist1 == -1 or dist2 == -1 or lca_dist == -1: return -1 return (dist1 - lca_dist) + (dist2 - lca_dist)"},{"question":"# Largest Increasing Subsequence Sum Problem You are given an array of integers. Your task is to find the sum of the largest increasing subsequence in the array. An increasing subsequence is a sequence of values derived from the array by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def largest_increasing_subsequence_sum(arr: list) -> int: Returns the sum of the largest increasing subsequence in the array. Parameters: arr (list): the array of integers Returns: int: the sum of the largest increasing subsequence ``` Input * A list of integers `arr`. Output * An integer representing the sum of the largest increasing subsequence in the array. Constraints * 1 <= len(arr) <= 1000 * -1000 <= arr[i] <= 1000 for any valid index i Example Given the following array: ```python arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] ``` Calling `largest_increasing_subsequence_sum(arr)` should return `255`. Explanation: The largest increasing subsequence is [10, 22, 33, 50, 60, 80], and the sum is 255. Requirements * The function should handle large arrays efficiently with a time complexity of at most O(n^2). * Consider edge cases such as arrays with all negative numbers or arrays with all identical elements.","solution":"def largest_increasing_subsequence_sum(arr: list) -> int: Returns the sum of the largest increasing subsequence in the array. Parameters: arr (list): the array of integers Returns: int: the sum of the largest increasing subsequence n = len(arr) if n == 0: return 0 # Initialize an array to store the maximum sum of increasing subsequence ending at each index sums = arr[:] # Fill the sums array using Dynamic Programming for i in range(1, n): for j in range(i): if arr[i] > arr[j] and sums[i] < sums[j] + arr[i]: sums[i] = sums[j] + arr[i] # The maximum value in sums array is the result return max(sums)"},{"question":"# Question: Implementing Linked List Cycle Detection and Removal You are provided with a singly linked list, which may contain a cycle. Your task is to implement a function that detects if a cycle exists, removes it if present, and returns the head of the modified list. # Input and Output Formats Function Signature ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> ListNode: pass ``` Inputs: - `head` (ListNode): The head node of the linked list. Outputs: - The function should return the head of the modified linked list after removing any cycles present. Constraints: - The linked list can contain up to 10^5 nodes. - The values of the nodes are integers and within the range `-10^9` to `10^9`. Performance Requirements: - The function should be efficient, with an expected time complexity of O(n) and space complexity of O(1). Examples: ```python # Example 1 # Input: head -> [3 -> 2 -> 0 -> -4 -> 2] (Cycle at node with value 2) # Output: head -> [3 -> 2 -> 0 -> -4] # Example 2 # Input: head -> [1 -> 2 -> 1] (Cycle at node with value 1) # Output: head -> [1 -> 2] # Example 3 # Input: head -> [1] (No cycle) # Output: head -> [1] # Utility to create linked list and cycle def create_linked_list_with_cycle(values, pos): if not values: return None head = ListNode(values[0]) current = head cycle_entry = None for index, value in enumerate(values[1:], start=1): current.next = ListNode(value) current = current.next if index == pos: cycle_entry = current current.next = cycle_entry return head # Example usage head = create_linked_list_with_cycle([3, 2, 0, -4], 1) detect_and_remove_cycle(head) # Output: 3 -> 2 -> 0 -> -4 ``` # Scenario In many applications involving linked lists, cycles can cause unintended infinite loops, leading to performance issues and unexpected behavior. Detecting and removing cycles ensures that the linked list functions correctly without anomalies. Your task is to efficiently detect and remove any cycles in the given linked list.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> ListNode: if not head or not head.next: return head slow, fast = head, head cycle_found = False # Using Floyd\'s Cycle Detection Algorithm to detect the cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_found = True break if not cycle_found: return head # Reset slow to head to find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # Move fast one step further to find the node just before the start of the cycle while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None return head"},{"question":"# Question Create a function `longest_common_suffix` that takes a list of strings as input and returns the longest common suffix shared among all the strings in the list. If there is no common suffix, return an empty string. Function Signature ```python def longest_common_suffix(strs: List[str]) -> str: ``` Input * `strs`: A list of strings with lengths between 0 and 1000. Output * A string representing the longest common suffix shared among all input strings. Constraints * The input list will have at least one string. * Each string will contain only lowercase English letters. Example ```python >>> longest_common_suffix([\\"running\\", \\"swimming\\", \\"ringing\\"]) \\"ing\\" >>> longest_common_suffix([\\"apple\\", \\"banana\\", \\"cherry\\"]) \\"\\" >>> longest_common_suffix([\\"evaporation\\", \\"inflation\\", \\"nation\\"]) \\"ation\\" >>> longest_common_suffix([\\"dog\\", \\"frog\\", \\"log\\"]) \\"og\\" ``` In the case of `longest_common_suffix([\\"running\\", \\"swimming\\", \\"ringing\\"])`, the output is \\"ing\\" because it is the longest suffix common to all three strings.","solution":"from typing import List def longest_common_suffix(strs: List[str]) -> str: if not strs: return \\"\\" # Reverse all strings in the list reversed_strs = [s[::-1] for s in strs] # Find the longest common prefix of the reversed strings longest_suffix = \\"\\" for chars in zip(*reversed_strs): if all(char == chars[0] for char in chars): longest_suffix += chars[0] else: break # Reverse the result to get the longest common suffix return longest_suffix[::-1]"},{"question":"# Merge K Sorted Lists You are given an array of `k` linked lists, each of which is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it. To achieve this, you should use a min-heap (priority queue) to efficiently merge the lists. **Function Signature**: ```python from typing import List, Optional class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into a single sorted linked list. ``` **Input Format**: * `lists`: A list of `k` linked lists, where each linked list is represented by the head node of type `ListNode`. **Output Format**: * The head node of the merged sorted linked list. **Constraints**: * `0 <= k <= 100` * `0 <= length of any linked list <= 500` * `-10^4 <= Node.val <= 10^4` **Example**: ```python # Helper function to create a linked list from a list def create_linked_list(arr: List[int]) -> Optional[ListNode]: if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert a linked list to a list def linked_list_to_list(node: Optional[ListNode]) -> List[int]: result = [] while node: result.append(node.val) node = node.next return result # Create test case lists = [ create_linked_list([1, 4, 5]), create_linked_list([1, 3, 4]), create_linked_list([2, 6]) ] merged_head = merge_k_sorted_lists(lists) print(linked_list_to_list(merged_head)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` **Hint**: - Use a min-heap (priority queue) to keep track of the smallest current node among the lists. **Explanation**: 1. Initialize a min-heap and push the head of each linked list (if not null) into the heap. 2. Repeatedly extract the minimum node from the heap and append it to the result list. 3. If the extracted node has a next node, push the next node into the heap. 4. Continue until the heap is empty.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # Custom comparator for ListNode to be used in heap ListNode.__lt__ = lambda self, other: self.val < other.val min_heap = [] # Initialize the heap with the head nodes of each list for l in lists: if l is not None: heapq.heappush(min_heap, l) dummy = ListNode() current = dummy while min_heap: # Extract the smallest node smallest = heapq.heappop(min_heap) current.next = smallest current = current.next # If the extracted node has a next node, push it to the heap if smallest.next: heapq.heappush(min_heap, smallest.next) return dummy.next"},{"question":"# Problem Statement You are required to implement a function called `flatten_nested_list` that transforms a nested list of integers into a single, flat list of integers. Nested lists can be arbitrarily deep. # Function Signature ```python def flatten_nested_list(nested_list: list) -> list: pass ``` # Input * A nested list `nested_list` of integers. The list may be empty or contain integers and/or other lists with integers. # Output * A list of integers, flattened from the nested structure, maintaining the order of appearance. # Example ```python # Example 1 assert flatten_nested_list([1, [2, [3, 4], 5]]) == [1, 2, 3, 4, 5] # Example 2 assert flatten_nested_list([]) == [] # Example 3 assert flatten_nested_list([[-1, [0, [1, 2], 3]]]) == [-1, 0, 1, 2, 3] ``` # Constraints * The function should correctly handle deeply nested lists. * The function should maintain the order of elements as they appear in the original nested structure. * The solution should account for lists containing both integers and other lists. # Requirements * **Recursion/Iteration**: The implementation may use recursion or an iterative approach. * **Efficiency**: Aim for a clear and efficient solution with minimal auxiliary space.","solution":"def flatten_nested_list(nested_list: list) -> list: Flattens a nested list of integers into a single list of integers. Args: nested_list (list): A nested list containing integers and/or other lists. Returns: list: A flattened list of integers. def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(nested_list))"},{"question":"# Markdown Parser Context: A markdown parser parses markdown formatted text to transform it into HTML. Markdown is a simple way to format text that can be converted to HTML. Examples include converting headers, bold text, italics, and lists. This will provide functionality to convert markdown syntax into HTML correctly. Task: Implement a class `MarkdownParser` that can convert a given markdown string to its corresponding HTML string. Requirements: 1. **Class Definition** - Implement the class `MarkdownParser` that provides methods to parse markdown strings. - The class should have a method `parse(self, markdown_text: str) -> str` which converts the given markdown formatted text to HTML. 2. **Markdown to HTML Conversion Rules** - Convert headers: - `#` for `<h1>`, `` for `<h2>`, up to `` for `<h6>` - Convert bold text: - `**text**` or `__text__` to `<b>text</b>` - Convert italic text: - `*text*` or `_text_` to `<i>text</i>` - Convert unordered lists: - Lines starting with `* `, `- ` or `+ ` should be converted to list items within `<ul>` tags. 3. **Edge Cases Handling** - Ensure the parser handles different orders and combinations of markdown elements. - Handle unformatted text correctly within the markdown text. Input/Output: - **Input**: ``` markdown_text = \\"# Header 1n Header 2n**bold text** and *italic text*n- Item 1n- Item 2\\" ``` - **Output**: ``` <h1>Header 1</h1><h2>Header 2</h2><b>bold text</b> and <i>italic text</i><ul><li>Item 1</li><li>Item 2</li></ul> ``` Constraints: - The input string is a valid markdown text with consistent formatting rules. - The input string may contain a mix of headers, bold, italic, and list items. Example Usage: ```python >>> parser = MarkdownParser() >>> markdown_text = \\"# Header 1n Header 2n**bold text** and *italic text*n- Item 1n- Item 2\\" >>> parser.parse(markdown_text) # \\"<h1>Header 1</h1><h2>Header 2</h2><b>bold text</b> and <i>italic text</i><ul><li>Item 1</li><li>Item 2</li></ul>\\" >>> markdown_text = \\"# Header 3nNormal textn+ List item\\" >>> parser.parse(markdown_text) # \\"<h3>Header 3</h3>Normal text<ul><li>List item</li></ul>\\" ```","solution":"import re class MarkdownParser: def parse(self, markdown_text: str) -> str: result = [] lines = markdown_text.split(\'n\') in_list = False for line in lines: # Headers if line.startswith(\'#\'): header_level = len(line.split()[0]) header_text = line[header_level:].strip() result.append(f\\"<h{header_level}>{header_text}</h{header_level}>\\") # List Items elif re.match(r\\"^[*-+]s+\\", line): if not in_list: result.append(\\"<ul>\\") in_list = True list_item_text = line[2:].strip() result.append(f\\"<li>{list_item_text}</li>\\") # End List else: if in_list: result.append(\\"</ul>\\") in_list = False result.append(self.parse_inline(line)) # If there was an unclosed list at the end of the text if in_list: result.append(\\"</ul>\\") return \'\'.join(result) def parse_inline(self, text: str) -> str: # Bold text = re.sub(r\\"**(.*?)**\\", r\\"<b>1</b>\\", text) text = re.sub(r\\"__(.*?)__\\", r\\"<b>1</b>\\", text) # Italic text = re.sub(r\\"*(.*?)*\\", r\\"<i>1</i>\\", text) text = re.sub(r\\"_(.*?)_\\", r\\"<i>1</i>\\", text) return text"},{"question":"# Unique Element Finder You are tasked with finding elements in a list that appear only once. Your function should identify and return these unique elements in the order they first appear in the input list. If no such elements are found, return an empty list. Function Signature ```python def find_unique_elements(collection: list) -> list: ``` # Input - `collection` (list): A list of integers, which may contain duplicates. The list could be empty as well. # Output - Returns a list of integers that appear exactly once in the input list, in the same order as their first occurrence. # Constraints 1. The input list should contain integers. 2. Duplicate values are allowed. 3. If the list is empty, return an empty list. 4. Ensure the function preserves the order of the unique elements as they appear in the input list. # Performance Requirements - Aim for an average time complexity of O(n) where n is the number of elements in the list. # Example ```python print(find_unique_elements([4, 5, 6, 4, 7, 8, 6])) # Output: [5, 7, 8] print(find_unique_elements([1, 2, 3, 2, 1])) # Output: [3] print(find_unique_elements([])) # Output: [] print(find_unique_elements([10, 20, 30, 40, 50])) # Output: [10, 20, 30, 40, 50] print(find_unique_elements([99, 99, 99])) # Output: [] ``` # Detailed Requirements 1. The function should iterate through the list and count the occurrences of each element. 2. Once the counting is complete, it should identify the elements that appear exactly once. 3. Construct and return a list of these unique elements, maintaining their first-seen order from the input list. 4. Avoid using additional external libraries or built-in functions that directly solve the problem. # Edge Cases to Consider 1. Lists with single elements. 2. Lists where all elements are the same. 3. Lists with several unique elements interspersed with duplicates. 4. Very large lists to test performance.","solution":"def find_unique_elements(collection: list) -> list: Finds and returns the elements that appear exactly once in the given collection list. Maintains the order of first appearance of these unique elements. Parameters: collection (list): A list of integers, which may contain duplicates. Returns: list: A list of integers that appear exactly once in the input list, in the order of their first occurrence. from collections import Counter # Create a counter to store the frequency of each element frequency = Counter(collection) # Create a list to hold unique elements in the order of their first appearance unique_elements = [item for item in collection if frequency[item] == 1] return unique_elements"},{"question":"# Problem Statement You are given an integer array `arr` of length `n` (1 ≤ n ≤ 2 * 10^5). Your task is to determine if there exists a triplet (i, j, k) where 0 ≤ i < j < k < n such that: - arr[i] < arr[j] < arr[k] Input - A single integer array `arr` with length `n` (1 ≤ n ≤ 2 * 10^5). Output - Return `True` if there exists such a triplet, otherwise return `False`. Example ```python >>> increasing_triplet([1, 2, 3, 4, 5]) True >>> increasing_triplet([5, 4, 3, 2, 1]) False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) True ``` Constraints - The solution must run in O(n) time complexity for the input size. Requirements - Use a linear scan approach to ensure the implementation meets the time complexity constraints. Use two auxiliary variables to track the smallest and the second smallest elements found during the scan to help determine the existence of the triplet. Additional Notes Consider the use of two variables to keep track of potential candidates for the triplet as you iterate through the array in a single pass.","solution":"def increasing_triplet(arr): Determine if there exists a triplet (i, j, k) where 0 ≤ i < j < k < n such that: arr[i] < arr[j] < arr[k] :param arr: List[int] - The input list of integers. :return: bool - True if there exists such a triplet, otherwise False. if len(arr) < 3: return False first = float(\'inf\') second = float(\'inf\') for num in arr: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"Question: Sorting Logs by Criteria # Background You are a software engineer tasked with processing and sorting log entries for a server monitoring system. Log entries consist of metadata details followed by alphanumeric content. The logs need to be sorted according to specific criteria to support efficient querying and analysis of the log data. # Task Write a Python function that sorts a list of log entries with the following criteria: 1. **Log Categorization**: - An **alphanumeric log** is defined as a log entry where the content (everything after the first space) consists of both letters and digits. - A **letter log** is defined as a log entry where the content consists only of letters. 2. **Sorting Criteria**: - **Letter logs** come before **alphanumeric logs**. - **Letter logs** are sorted lexicographically by their content. If the content of two logs is identical, then they are sorted by their identifiers. - **Alphanumeric logs** maintain their relative order from the input (they are not sorted). # Specifications - Implement a function `sort_logs(logs: List[str]) -> List[str]`. - The function takes a list of log entries (`logs`) and returns a list of sorted log entries based on the criteria. # Requirements - **Input**: - A list of strings where each string represents a log entry. Each log entry consists of an identifier followed by content, separated by a space. - **Output**: - A list of strings representing the sorted log entries. - **Constraints**: - The number of log entries will not exceed 1000. - Each log entry will have at least one letter or digit after the identifier. - Log content will not contain any leading or trailing whitespace. - The identifiers are guaranteed to be unique. # Example ```python # Example usage: logs = [ \\"d1 8 1 5 1\\", \\"a1 9 2 3 1\\", \\"q2 act car\\", \\"b4 zoo\\", \\"c3 act bus\\" ] sorted_logs = sort_logs(logs) print(sorted_logs) # Output: [\\"c3 act bus\\", \\"q2 act car\\", \\"b4 zoo\\", \\"d1 8 1 5 1\\", \\"a1 9 2 3 1\\"] ``` # Evaluation - Ensure the function correctly categorizes and sorts logs as described. - Verify that letter logs are sorted lexicographically and alphabetically by their identifiers when contents are identical. - Confirm that alphanumeric logs maintain their original order. - The solution should handle the maximum constraints efficiently.","solution":"from typing import List def sort_logs(logs: List[str]) -> List[str]: def log_key(log: str): identifier, content = log.split(\\" \\", 1) # Determine if the log is a letter log or alphanumeric log if content.replace(\\" \\", \\"\\").isalpha(): # Letter logs are given a secondary key (0) and sorted by their content and identifier return (0, content, identifier) else: # Alphanumeric logs are given a secondary key (1) and maintain their relative order return (1,) return sorted(logs, key=log_key)"},{"question":"# Problem Statement: A shipping company wants to optimize the placement of packages in its delivery vans. Each van has a maximum weight capacity, and each package has a specified weight. Given a list of package weights and the maximum weight capacity of a single van, determine the minimum number of vans required to transport all packages without exceeding the weight capacity of any van. # Function Signature: ```python def min_vans_required(package_weights: List[int], max_capacity: int) -> int: pass ``` # Parameters: - `package_weights` (List[int]): A list of integers where each integer represents the weight of a package. - `max_capacity` (int): An integer representing the maximum weight capacity of a single van. # Returns: - `int`: The minimum number of vans required. # Constraints: - 1 ≤ len(package_weights) ≤ 1000 - 1 ≤ package_weights[i] ≤ 1000 - 1 ≤ max_capacity ≤ 1000 # Example: ```python assert min_vans_required([5, 10, 15, 20, 25], 50) == 2 assert min_vans_required([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 4 assert min_vans_required([50, 50, 50, 50], 100) == 2 ``` **Note:** - For the first example, you can group the packages as follows: [5, 10, 15, 20] in one van (total weight 50) and [25] in another van. - Ensure the function efficiently calculates the minimum number of vans required given the constraints. - Consider the optimal packing strategy to fit as many packages into as few vans as possible.","solution":"from typing import List from bisect import bisect_right def min_vans_required(package_weights: List[int], max_capacity: int) -> int: # Sort the package weights for optimal placement package_weights.sort(reverse=True) vans = [] for weight in package_weights: placed = False # Try to place the current package in an existing van for i in range(len(vans)): if vans[i] + weight <= max_capacity: vans[i] += weight placed = True break # If it doesn\'t fit in any existing van, use a new van if not placed: vans.append(weight) return len(vans)"},{"question":"**Question**: You are given a set of tasks, each with a specific duration and a unique priority level. You need to implement a scheduling function that determines the order of task execution to minimize the sum of the waiting times weighted by the priority of the tasks. Implement the function `optimal_schedule(tasks)` that returns a list of task ids in the order they should be executed to achieve the minimum weighted waiting time sum. # The function takes: * `tasks`: A list of tuples. Each tuple contains three values: * an integer representing the task\'s unique id, * an integer representing the task\'s duration, * an integer representing the task\'s priority (higher value means higher priority). # The function returns: * A list of integers representing the task ids in the optimal execution order. # Example: ```python >>> tasks = [(1, 3, 2), (2, 1, 3), (3, 2, 1)] >>> optimal_schedule(tasks) [2, 3, 1] >>> tasks = [(1, 5, 1), (2, 2, 2), (3, 1, 3)] >>> optimal_schedule(tasks) [3, 2, 1] ``` # Explanation: In the first example: - Task 2 is completed first (duration 1, priority 3), followed by Task 3 (duration 2, priority 1) and finally Task 1 (duration 3, priority 2). This ordering minimizes the weighted waiting time sum. In the second example: - Task 3 is completed first (duration 1, priority 3), followed by Task 2 (duration 2, priority 2) and finally Task 1 (duration 5, priority 1). # Constraints: * All task durations and priorities are positive integers. * The list of tasks can contain up to 1000 tasks.","solution":"def optimal_schedule(tasks): Determines the optimal order of tasks to minimize the sum of weighted waiting times. Parameters: tasks (list of tuples): A list where each tuple contains three integers: - task id - task duration - task priority Returns: list: A list of task ids in the optimal order. # Sort tasks based on the product of priority and duration (highest first) sorted_tasks = sorted(tasks, key=lambda x: (x[2] / x[1]), reverse=True) return [task[0] for task in sorted_tasks]"},{"question":"# Prime Factorization Develop a function that calculates the prime factorization of a given integer. The function should take an integer as input and return a dictionary where the keys are prime factors and the values are their respective exponents. Function Signature ```python def prime_factorization(n: int) -> dict: Computes the prime factorization of the given integer. Args: n: The integer to factorize (as an int). Returns: A dictionary containing the prime factors of n as keys and their corresponding exponents as values. Example: >>> prime_factorization(60) {2: 2, 3: 1, 5: 1} >>> prime_factorization(100) {2: 2, 5: 2} # Your code goes here ``` Input and Output * **Input**: * `n` (int): The integer to be factorized. The integer will be greater than 1. * **Output**: - Return a dictionary with prime factors of `n` as keys and their respective exponents as values. Constraints * The input integer will be greater than 1 but within a range that allows the function to compute the prime factors efficiently. Performance Requirements * The function should handle factorization efficiently, using methods optimized for integers typically up to several million.","solution":"def prime_factorization(n: int) -> dict: Computes the prime factorization of the given integer. Args: n: The integer to factorize (as an int). Returns: A dictionary containing the prime factors of n as keys and their corresponding exponents as values. factors = {} # Start with the smallest prime factor divisor = 2 while n >= divisor: if n % divisor == 0: if divisor in factors: factors[divisor] += 1 else: factors[divisor] = 1 n //= divisor else: divisor += 1 return factors # Example usage print(prime_factorization(60)) # {2: 2, 3: 1, 5: 1} print(prime_factorization(100)) # {2: 2, 5: 2}"},{"question":"# Context You are working on an e-commerce website and need to implement a feature that checks product availability in the inventory system. This feature should help to dynamically update the product listing based on stock levels. # Task Write a Python function that checks the availability of a given product in the inventory. The function should take the product\'s unique ID as input and return the product\'s name, its current stock level, and availability status (in stock or out of stock). The function should handle errors gracefully and return meaningful messages in case of any issues. # Function Signature ```python def check_product_availability(product_id: int) -> dict: ``` # Requirements - Your function should return a dictionary with four keys: `\\"product_id\\"`, `\\"product_name\\"`, `\\"stock_level\\"`, and `\\"availability\\"`. - `\\"product_id\\"`: The unique ID of the product. - `\\"product_name\\"`: The name of the product. - `\\"stock_level\\"`: The current stock level of the product. - `\\"availability\\"`: Either `\\"In stock\\"` or `\\"Out of stock\\"`. - In case of any error (e.g., invalid product ID, network issue, etc.), return an error message in a dictionary format with a single key `\\"error\\"` and its associated message. - If the product ID is invalid, return the message `\\"Invalid product ID.\\"`. - If unable to fetch the product details due to a network issue, return the message `\\"Failed to fetch product details.\\"`. - Use the provided `API_ENDPOINT_URL` which simulates inventory lookup. # Constraints - Use the built-in **requests** library. - Each request should have a timeout of 5 seconds (`timeout=5`). # Example Usage ```python result = check_product_availability(12345) if \\"error\\" in result: print(\\"Error:\\", result[\\"error\\"]) else: print(f\\"Product ID: {result[\'product_id\']}\\") print(f\\"Product Name: {result[\'product_name\']}\\") print(f\\"Stock Level: {result[\'stock_level\']}\\") print(f\\"Availability: {result[\'availability\']}\\") ``` # Notes - Consider using exception handling to manage network issues and invalid product IDs. - Ensure your function is robust and handles unexpected situations gracefully. - Make sure each key in the returned dictionary has a proper value or error message.","solution":"import requests API_ENDPOINT_URL = \\"https://fake-inventory-api.com/product\\" def check_product_availability(product_id: int) -> dict: Checks the availability of a given product in the inventory. Args: product_id (int): The unique ID of the product. Returns: dict: A dictionary containing product_id, product_name, stock_level, and availability. If there is an error, a dictionary with the key \\"error\\" and an error message is returned. if not isinstance(product_id, int) or product_id <= 0: return {\\"error\\": \\"Invalid product ID.\\"} try: response = requests.get(f\\"{API_ENDPOINT_URL}/{product_id}\\", timeout=5) response.raise_for_status() product_data = response.json() return { \\"product_id\\": product_data[\\"product_id\\"], \\"product_name\\": product_data[\\"product_name\\"], \\"stock_level\\": product_data[\\"stock_level\\"], \\"availability\\": \\"In stock\\" if product_data[\\"stock_level\\"] > 0 else \\"Out of stock\\" } except requests.exceptions.RequestException: return {\\"error\\": \\"Failed to fetch product details.\\"} except KeyError: return {\\"error\\": \\"Invalid product data received.\\"}"},{"question":"# Coding Assessment Question: Image Compression using Singular Value Decomposition Context A team of software engineers is working on an application that requires compressing images without significant loss of quality. The team decides to use Singular Value Decomposition (SVD) for this purpose. As a member of the team, you are tasked with implementing the image compression algorithm. Problem Specification You are given a grayscale image represented as a 2D Numpy array. You must implement a function to compress the image using SVD, keeping only the top k singular values. Task 1. **Implement Image Compression using SVD Function**: * Function name: `compress_image_svd` * Input: * `image` (np.ndarray): A 2D array of shape ((m, n)) representing a grayscale image. * `k` (int): The number of singular values to keep for compression. * Output: * (np.ndarray): A 2D array of the compressed image with the same shape as the input image ((m, n)). * Constraints: * The value of `k` must be less than or equal to the smaller dimension of the image (min(m, n)). Sample Input and Output # Example ```python import numpy as np # Sample grayscale image represented as a matrix image = np.array([ [255, 0, 0, 255], [0, 255, 255, 0], [255, 255, 0, 0], [0, 0, 255, 255] ]) k = 2 compressed_image = compress_image_svd(image, k) assert compressed_image.shape == image.shape ``` Performance Requirements * Your solution should efficiently handle images of typical size (e.g., 512x512 or larger). * Utilize efficient numpy functions for matrix decomposition and reconstruction.","solution":"import numpy as np def compress_image_svd(image, k): Compresses an image using Singular Value Decomposition (SVD) by retaining only the top k singular values. Parameters: image (np.ndarray): A 2D array of shape (m, n) representing the grayscale image. k (int): The number of singular values to keep for compression. Returns: np.ndarray: A 2D array of the compressed image with the same shape as the input image (m, n). # Perform Singular Value Decomposition U, S, VT = np.linalg.svd(image, full_matrices=False) # Retain only the top k singular values/components S = np.diag(S[:k]) U = U[:, :k] VT = VT[:k, :] # Reconstruct the compressed image compressed_image = np.dot(U, np.dot(S, VT)) return compressed_image"},{"question":"# Context In a warehouse, items are identified by unique codes that follow a specific format. These codes are composed of an uppercase letter indicating the category, a dash, followed by a digit indicating the section, another dash, and finally a sequence of lowercase letters indicating the item description. # Task Write a function `is_warehouse_code_valid(code: str) -> bool` that checks if a given string represents a valid warehouse item code following the aforementioned format. # Input - A string `code` that represents the warehouse item code. # Output - Return `True` if the `code` follows the specified format; otherwise, return `False`. # Constraints - The input string should consist of the format: one uppercase letter, a dash, one digit, a dash, followed by a sequence of lowercase letters. - The input should only contain the allowed characters and format without any leading or trailing spaces or any other characters. # Example Tests ```python print(is_warehouse_code_valid(\\"A-1-abc\\")) # Should return: True print(is_warehouse_code_valid(\\"B-2-xzz\\")) # Should return: True print(is_warehouse_code_valid(\\"C-3-aBc\\")) # Should return: False print(is_warehouse_code_valid(\\"1-1-abc\\")) # Should return: False print(is_warehouse_code_valid(\\"D-9-xyz-\\")) # Should return: False print(is_warehouse_code_valid(\\"E_2_xyz\\")) # Should return: False print(is_warehouse_code_valid(\\"F-5-abcdef\\")) # Should return: True print(is_warehouse_code_valid(\\"G-4-\\")) # Should return: False print(is_warehouse_code_valid(\\"H--6-lmn\\")) # Should return: False print(is_warehouse_code_valid(\\"A-1-123\\")) # Should return: False print(is_warehouse_code_valid(\\"A-1-abc \\")) # Should return: False ``` # Notes: - Ensure to verify the structure strictly and return `False` if it deviates in any form. - Validation should not be case-sensitive except for the formatting requirements of the uppercase letter and lowercase letters in the sequence.","solution":"import re def is_warehouse_code_valid(code: str) -> bool: Checks if the given string represents a valid warehouse item code. Format should be: one uppercase letter, a dash, a digit, a dash, followed by lowercase letters. Args: code (str): The warehouse item code. Returns: bool: True if the code is valid, False otherwise. # Regular expression to match the specified format pattern = r\'^[A-Z]-d-[a-z]+\' return bool(re.match(pattern, code))"},{"question":"# Question: Counting Valid Encodings Context Imagine you are given a string of digits representing an encoding scheme, where each digit or pair of digits is mapped to a letter in the alphabet: \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'. Your task is to determine the number of distinct ways to decode the string. Function Definition Complete the function `count_encodings` that accepts a single parameter: - `s` (str): a string of digits. The function should return the number of ways the string can be decoded following the described encoding rules. Example: ```python def count_encodings(s: str) -> int: Returns the number of distinct ways to decode the string \'s\' >>> count_encodings(\\"12\\") 2 >>> count_encodings(\\"226\\") 3 >>> count_encodings(\\"0\\") 0 >>> count_encodings(\\"10\\") 1 # Your implementation here # Example usage count_encodings(\\"12\\") ``` Constraints: - The input string `s` will only contain digits and will have a length between 1 and 1000. - The string does not contain any non-digit characters. - Consider edge cases like \'0\' and other invalid encoding scenarios where the output should be 0.","solution":"def count_encodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to be decoded for i in range(1, n + 1): # Check the last one digit if s[i - 1] != \'0\': dp[i] += dp[i - 1] # Check the last two digits if they form a valid encoding if i > 1 and \'10\' <= s[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"# Database Table Join and Aggregation **Problem Statement**: You are given two tables, `Employees` and `Departments`, representing a company’s organizational structure. The `Employees` table contains information about each employee, including their salary and department ID, while the `Departments` table contains department names and a unique department ID. Your task is to write a SQL query to find the sum of salaries for each department. # Tables 1. `Employees`: - `id` (integer): Unique identifier for the employee - `name` (string): Name of the employee - `salary` (integer): Salary of the employee - `department_id` (integer): ID of the department the employee belongs to 2. `Departments`: - `department_id` (integer): Unique identifier for the department - `department_name` (string): Name of the department # Expected Output The query should return a list with the department names and the total salary spent in each department, ordered by the total salary in descending order. # Example Given the following tables: **Employees**: | id | name | salary | department_id | |-----|----------|--------|---------------| | 1 | Alice | 70000 | 1 | | 2 | Bob | 80000 | 2 | | 3 | Charlie | 90000 | 2 | | 4 | David | 60000 | 1 | | 5 | Eve | 60000 | 3 | **Departments**: | department_id | department_name | |---------------|-----------------| | 1 | HR | | 2 | Engineering | | 3 | Sales | Your query should return: | department_name | total_salary | |-----------------|--------------| | Engineering | 170000 | | HR | 130000 | | Sales | 60000 | # SQL Query Write a SQL query to find the total salary for each department, ordered by total salary in descending order. ```sql SELECT Departments.department_name, SUM(Employees.salary) as total_salary FROM Employees JOIN Departments ON Employees.department_id = Departments.department_id GROUP BY Departments.department_name ORDER BY total_salary DESC ``` # Detailed Explanation: 1. **Join the Tables**: Use an `INNER JOIN` to combine the `Employees` and `Departments` tables on `department_id`. 2. **Aggregate Salaries**: Use `SUM` to calculate the total salary for each department. 3. **Group by Department**: Group the results by `department_name` to ensure that the totals are computed for each department separately. 4. **Order the Results**: Order the final results by `total_salary` in descending order to show departments with the higher total salaries first.","solution":"def department_total_salaries(employees, departments): Given two tables of employees and departments, Returns a list of tuples with department names and total salary, ordered by total salary in descending order. # Join Employees and Departments on department_id joined_data = [ (emp[\'name\'], emp[\'salary\'], dept[\'department_name\']) for emp in employees for dept in departments if emp[\'department_id\'] == dept[\'department_id\'] ] # Calculate total salary for each department salary_by_department = {} for _, salary, department_name in joined_data: if department_name not in salary_by_department: salary_by_department[department_name] = 0 salary_by_department[department_name] += salary # Convert to a list of tuples and sort by total salary in descending order result = sorted( [(dept_name, total_salary) for dept_name, total_salary in salary_by_department.items()], key=lambda x: x[1], reverse=True ) return result"},{"question":"# Sudoku Solver **Context**: You are building a software tool that helps users solve Sudoku puzzles. A standard Sudoku puzzle is a 9x9 grid where some cells contain numbers ranging from 1 to 9, and the rest are empty (denoted by 0). The goal is to fill the grid such that each row, each column, and each of the nine 3x3 subgrids contain all the numbers from 1 to 9 without repetition. **Task**: Implement a method that solves a given Sudoku puzzle. This method should modify the grid in place to reflect the solved puzzle or indicate that the puzzle cannot be solved. **Instructions**: 1. Complete the `solveSudoku` method for the `SudokuSolver` class. 2. Use a backtracking algorithm to fill in the puzzle. 3. Ensure the method returns `True` if the puzzle is solved, and `False` if it cannot be solved. **Input Format**: - A 9x9 list of lists representing the Sudoku grid. The grid contains integers, where 0 represents empty cells. **Output Format**: - The method modifies the grid in place and returns a boolean indicating if the puzzle was solved. **Constraints**: - The input grid will always be a 9x9 matrix. - The provided puzzle will have a unique solution if it is solvable. ```python class SudokuSolver: def __init__(self, board): self.board = board def solveSudoku(self): Solves the Sudoku puzzle in place. :return: Boolean indicating if the puzzle was solved. def is_valid(board, row, col, num): # Check if num can be placed in board[row][col] def solver(board): # Implement backtracking algorithm to solve Sudoku return solver(self.board) ``` **Example**: ```python puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(puzzle) solver.solveSudoku() assert puzzle == [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ```","solution":"class SudokuSolver: def __init__(self, board): self.board = board def solveSudoku(self): Solves the Sudoku puzzle in place. :return: Boolean indicating if the puzzle was solved. def is_valid(board, row, col, num): # Check if num is not repeated in the current row for x in range(9): if board[row][x] == num: return False # Check if num is not repeated in the current column for x in range(9): if board[x][col] == num: return False # Check if num is not repeated in the current 3x3 box startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if board[i + startRow][j + startCol] == num: return False return True def solver(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solver(board): return True board[row][col] = 0 return False return True return solver(self.board)"},{"question":"# Coding Assessment Question Scenario Customer orders are critical to track and manage efficiently. An efficient way to update the logistics system is necessary. Each order has a unique ID, and needs to be processed in the given order of data arrival. A new requirement is to ensure consistent order processing times, to simplify management. Task Implement a function `process_orders` that schedules order processing by creating a list with each order processed at a fixed interval of time. Function Signature ```python def process_orders(order_ids: list[int], interval: int) -> list[str]: Processes orders by scheduling them at fixed intervals from the start of the process. :param order_ids: A list of unique integers, representing order IDs to be processed. :param interval: An integer, representing the fixed interval of processing time in minutes. :return: A list of strings, each indicating the order ID and its scheduled processing time. Note: The first order starts processing at minute 0. ``` Input - A list of integers `order_ids` - unique order IDs to process, where: * `1 <= len(order_ids) <= 100` * `1 <= order_ids[i] <= 10^6` - An integer `interval` - the fixed processing time interval in minutes, where: * `1 <= interval <= 60` Output - A list of strings. Each string represents an order ID and its scheduled processing time in the format `\\"Order {order_id} will be processed at minute {time}\\"`. Constraints - Process each order ID at a fixed `interval` of time starting from minute 0. Examples - Example 1: ```python order_ids = [101, 102, 103] interval = 10 return = [\\"Order 101 will be processed at minute 0\\", \\"Order 102 will be processed at minute 10\\", \\"Order 103 will be processed at minute 20\\"] ``` - Example 2: ```python order_ids = [2001, 2002] interval = 15 return = [\\"Order 2001 will be processed at minute 0\\", \\"Order 2002 will be processed at minute 15\\"] ``` - Example 3: ```python order_ids = [303] interval = 5 return = [\\"Order 303 will be processed at minute 0\\"] ``` Notes - Ensure the scheduled processing times are calculated based on a start time of minute 0. - The output should maintain the order as given in the input list of order IDs.","solution":"def process_orders(order_ids: list[int], interval: int) -> list[str]: Processes orders by scheduling them at fixed intervals from the start of the process. :param order_ids: A list of unique integers, representing order IDs to be processed. :param interval: An integer, representing the fixed interval of processing time in minutes. :return: A list of strings, each indicating the order ID and its scheduled processing time. Note: The first order starts processing at minute 0. result = [] for i, order_id in enumerate(order_ids): result.append(f\\"Order {order_id} will be processed at minute {i * interval}\\") return result"},{"question":"Queue Implementation with Custom Exception Handling You are developing a task scheduling system requiring a custom queue to manage tasks. Your task is to implement a `TaskQueue` class with specific functionalities and custom exception handling. # Task 1. **class TaskQueue**: - This class should have the following methods: 2. **enqueue(task: str) -> None**: - Adds the specified task to the end of the queue. - Constraints: - The task must be a non-empty string. - If an invalid (empty) task is provided, raise an `InvalidTaskError` with the message \\"Task cannot be empty.\\" 3. **dequeue() -> str**: - Removes and returns the task at the front of the queue. - Constraints: - If the queue is empty, raise an `EmptyQueueError` with the message \\"No tasks in the queue.\\" 4. **peek() -> str**: - Returns the task at the front of the queue without removing it. - Constraints: - If the queue is empty, raise an `EmptyQueueError` with the message \\"No tasks in the queue.\\" 5. **is_empty() -> bool**: - Returns `True` if the queue is empty, otherwise `False`. 6. **size() -> int**: - Returns the number of tasks in the queue. # Example Usage ```python >>> queue = TaskQueue() >>> queue.enqueue(\\"Task 1\\") >>> queue.enqueue(\\"Task 2\\") >>> queue.size() 2 >>> queue.peek() \'Task 1\' >>> queue.dequeue() \'Task 1\' >>> queue.size() 1 >>> queue.is_empty() False >>> queue.dequeue() \'Task 2\' >>> queue.is_empty() True >>> queue.dequeue() Traceback (most recent call last): ... EmptyQueueError: No tasks in the queue ``` # Exceptions 1. **class InvalidTaskError(Exception)**: - Raised when an invalid task is enqueued. 2. **class EmptyQueueError(Exception)**: - Raised when an operation is attempted on an empty queue. # Additional Requirements 1. **Edge Cases**: - Ensure the `enqueue` method handles invalid (empty) task inputs by raising an `InvalidTaskError`. - Ensure the `dequeue` and `peek` methods handle empty queue scenarios by raising an `EmptyQueueError`. Implement the `TaskQueue` class and the custom exceptions with the described requirements and exception handling.","solution":"class InvalidTaskError(Exception): Raised when an invalid task is enqueued pass class EmptyQueueError(Exception): Raised when an operation is attempted on an empty queue pass class TaskQueue: def __init__(self): self.queue = [] def enqueue(self, task: str) -> None: if not task: raise InvalidTaskError(\\"Task cannot be empty\\") self.queue.append(task) def dequeue(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue.pop(0) def peek(self) -> str: if self.is_empty(): raise EmptyQueueError(\\"No tasks in the queue\\") return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def size(self) -> int: return len(self.queue)"},{"question":"# Problem Statement Implement a function to find the longest substring of a given string that contains no more than `k` distinct characters. The function should return both the longest substring and its length. # Input/Output Formats - **Input**: - A string `s` and an integer `k` representing the number of distinct characters allowed in the substring. - **Output**: - A tuple containing the longest substring and its length. # Constraints - The length of string `s` is between 1 and 10,000. - The integer `k` is a non-negative integer. - If `k` is 0, return an empty string and length 0. # Example ```python s = \\"eceba\\" k = 2 print(LongestSubstringWithKDistinct(s, k)) # Expected Output: (\\"ece\\", 3) s = \\"aa\\" k = 1 print(LongestSubstringWithKDistinct(s, k)) # Expected Output: (\\"aa\\", 2) ``` # Task Implement the `LongestSubstringWithKDistinct` function using a sliding window technique. The function should iterate through the string while maintaining a count of the distinct characters in the current window. If the count exceeds `k`, the window should be adjusted accordingly to maintain the constraint. Use a hashmap to keep track of the characters and their frequencies to efficiently manage the window. ```python def LongestSubstringWithKDistinct(s: str, k: int) -> tuple: if k == 0: return (\\"\\", 0) n = len(s) left = 0 right = 0 max_length = 0 start = 0 char_map = {} while right < n: if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 start = left right += 1 return (s[start:start + max_length], max_length) ```","solution":"def LongestSubstringWithKDistinct(s: str, k: int) -> tuple: if k == 0: return (\\"\\", 0) n = len(s) left = 0 right = 0 max_length = 0 start = 0 char_map = {} while right < n: # add right character to char_map or update its count if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 # shrink the window from the left if the distinct character count exceeds k while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 # update the maximum length and starting index of the substring if right - left + 1 > max_length: max_length = right - left + 1 start = left right += 1 return (s[start:start + max_length], max_length)"},{"question":"# Context Sorting algorithms are a fundamental topic in computer science, used to arrange elements in a list in a specific order. One common algorithm is Merge Sort, a divide-and-conquer algorithm that recursively splits a list into halves, sorts each half, and then merges them back together in sorted order. # Problem Statement Implement a function, `merge_sort(arr)`, which takes a list of integers and returns a new list with the elements sorted in ascending order. Your task is to implement the Merge Sort algorithm from scratch, without using any built-in sorting functions. # Function Signature ```python def merge_sort(arr: list) -> list: pass ``` # Input * `arr`: A list of integers of length `n`, where `1 <= n <= 1000`. # Output * A new list of integers with the elements of `arr` sorted in ascending order. # Constraints * All elements in the input list are integers. * The input list `arr` will have at least one element and no more than 1000 elements. # Example ```python arr = [34, 7, 23, 32, 5, 62] sorted_arr = merge_sort(arr) print(sorted_arr) ``` # Explanation In this example, the `merge_sort` function would recursively split the list `[34, 7, 23, 32, 5, 62]` into smaller sublists, sort each sublist, and merge them back together in ascending order. # Performance Requirements Your solution should be efficient enough to handle input lists up to the maximum length of 1000 while maintaining the typical performance characteristics of O(n log n) for Merge Sort.","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left, right): merged = [] i = j = 0 # Merge two sorted lists while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # Collect remaining elements (if any) merged.extend(left[i:]) merged.extend(right[j:]) return merged # Split the list into halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Problem Statement: Implement a function to simulate a simple online bookstore\'s inventory management system. Your task is to develop functions to add and remove books, search for books by title, and track stock levels. # Requirements: 1. **Book Addition:** - Implement a function `add_book(title: str, author: str, price: float, quantity: int) -> None` that adds a book to the inventory. - Ensure that the function can handle duplicate books by merging the quantities and updating the price and author if they differ. 2. **Book Removal:** - Implement a function `remove_book(title: str, quantity: int) -> None` that removes a specified quantity of a particular book from the inventory. - If the quantity to be removed exceeds the current stock, remove the book entirely from the inventory. 3. **Book Search:** - Implement a function `search_book(title: str) -> Optional[Dict[str, Any]]` that searches for a book by its title and returns a dictionary containing its details (`title`, `author`, `price`, `quantity`). If the book is not found, return `None`. 4. **Stock Report:** - Implement a function `get_stock_report() -> List[Dict[str, Any]]` that returns a list of dictionaries, each representing a book in the inventory with its details (`title`, `author`, `price`, `quantity`). # Input/Output Formats: * **Input:** - `title`: A string representing the book title. - `author`: A string representing the author of the book. - `price`: A float representing the price of the book. - `quantity`: An integer representing the quantity of the book. * **Output:** - `add_book`: None - `remove_book`: None - `search_book`: A dictionary with the book\'s details or `None`. - `get_stock_report`: A list of dictionaries with details for each book in the inventory. # Constraints: - Title and author strings will have a maximum length of 100 characters. - Price will be a positive float. - Quantity will be a non-negative integer. - The inventory will not exceed 1,000 book titles at any given time. - Ensure operations are performed efficiently, considering the inventory size constraints. # Sample Usage: ```python # Initialize the inventory system add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10.99, 5) add_book(\\"1984\\", \\"George Orwell\\", 8.99, 10) add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 12.99, 3) # Search for a book book = search_book(\\"1984\\") print(\\"Book found:\\", book) # Remove books from inventory remove_book(\\"1984\\", 5) remove_book(\\"The Great Gatsby\\", 8) # Generate stock report report = get_stock_report() print(\\"Stock report:\\", report) ``` **Note:** The inventory system should automatically handle cases where book titles are added more than once, correctly updating the book\'s details and merging quantities.","solution":"class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, price: float, quantity: int) -> None: if title in self.inventory: if self.inventory[title][\'author\'] != author or self.inventory[title][\'price\'] != price: self.inventory[title][\'author\'] = author self.inventory[title][\'price\'] = price self.inventory[title][\'quantity\'] += quantity else: self.inventory[title] = {\'author\': author, \'price\': price, \'quantity\': quantity} def remove_book(self, title: str, quantity: int) -> None: if title in self.inventory: if quantity >= self.inventory[title][\'quantity\']: del self.inventory[title] else: self.inventory[title][\'quantity\'] -= quantity def search_book(self, title: str) -> dict: return self.inventory.get(title, None) def get_stock_report(self) -> list: return [{\'title\': title, \'author\': details[\'author\'], \'price\': details[\'price\'], \'quantity\': details[\'quantity\']} for title, details in self.inventory.items()] # Initialize the inventory system instance for testing inventory_instance = BookstoreInventory()"},{"question":"# Problem Statement Given a matrix of integers `matrix` where each row is sorted in non-decreasing order, write a function `search_matrix(matrix: List[List[int]], target: int) -> bool` to determine if a given target value exists in the matrix. The function should return `True` if the target is found and `False` otherwise. # Function Signature ```python def search_matrix(matrix: List[List[int]], target: int) -> bool: ``` # Input * `matrix` (List[List[int]]): A list of lists where each list represents a row and each row is sorted in non-decreasing order. - The number of rows will be between 1 and 100. - The number of columns will be between 1 and 100. * `target` (int): An integer value to search for in the matrix. # Output * (bool): `True` if `target` is found in the matrix, `False` otherwise. # Constraints * Each row is sorted in non-decreasing order. * The total number of elements in the matrix will be between 1 and 10000. # Examples ```python >>> search_matrix([[1, 3, 5], [7, 8, 10], [12, 13, 15]], 8) True >>> search_matrix([[1, 3, 5], [7, 8, 10], [12, 13, 15]], 6) False >>> search_matrix([[1, 3, 5]], 5) True ``` # Implementation Requirements * The solution should complete in O(m + n) time complexity, where m is the number of rows and n is the number of columns. * The algorithm should start the search from the top-right corner or bottom-left corner of the matrix and adjust its position based on the comparison with the target value.","solution":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> bool: Determines if a given target value exists in a matrix where each row is sorted in non-decreasing order. Args: matrix (List[List[int]]): A list of lists of integers. target (int): The integer value to search for. Returns: bool: True if the target is found in the matrix, False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: current_value = matrix[row][col] if current_value == target: return True elif current_value > target: col -= 1 else: row += 1 return False"},{"question":"# Problem Statement: Create a Python function that connects to a public weather API to retrieve the current weather information for a given city. The function should format the retrieved data and write the weather details to a specified file. Handle potential issues like invalid city names or network failures gracefully. # Function Signature: ```python def fetch_and_save_weather_data(city_name: str, api_key: str, filename: str) -> None: Fetches current weather data for the given city and saves it to a file. Parameters: city_name (str): Name of the city. api_key (str): API key for authenticating with the weather service. filename (str): Name of the file to save the weather details. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. ``` # Input: - `city_name`: A string representing the name of the city to fetch weather data for. - `api_key`: A string representing the API key for accessing the weather service. - `filename`: A string representing the name of the file where to save the weather details. # Output: - None (Details should be written to the given file). # Example Invocation: ```python # Fetch weather data for \'New York\' and save to \'weather.txt\' fetch_and_save_weather_data(\'New York\', os.environ.get(\\"WEATHER_API_KEY\\", \\"\\"), \'weather.txt\') ``` # Constraints: 1. **Token Handling**: The function should raise a `ValueError` if `api_key` is blank. 2. **Error Handling**: Handle cases where the city does not exist or there\'s a network failure gracefully. Include retries for transient network issues. 3. **File Operations**: Ensure proper reading and writing to files, handling file I/O errors appropriately. 4. **Performance**: Optimize network calls to avoid unnecessary delays, and make sure the data is written efficiently. Use the following weather API endpoint for fetching weather data: ``` http://api.openweathermap.org/data/2.5/weather?q=<city_name>&appid=<api_key> ``` # Notes: * **Authentication** will be done using the API key. Include it in the URL query parameters. * Avoid hardcoding the filename; pass it as a function argument. * Provide comprehensive comments and documentation to explain the logic and error handling involved.","solution":"import requests import os def fetch_and_save_weather_data(city_name: str, api_key: str, filename: str) -> None: Fetches current weather data for the given city and saves it to a file. Parameters: city_name (str): Name of the city. api_key (str): API key for authenticating with the weather service. filename (str): Name of the file to save the weather details. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. if not api_key: raise ValueError(\\"API key is required\\") url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={api_key}\\" try: response = requests.get(url) response.raise_for_status() # Raise HTTPError for bad responses except requests.exceptions.RequestException as e: raise IOError(f\\"Network error: {e}\\") try: weather_data = response.json() if weather_data.get(\\"cod\\") != 200: raise IOError(f\\"Error retrieving weather data: {weather_data.get(\'message\', \'Unknown error\')}\\") with open(filename, \\"w\\") as file: file.write(str(weather_data)) except Exception as e: raise IOError(f\\"File operation failed: {e}\\")"},{"question":"# Scenario You are creating a tool to help analyze financial investments. One of the tasks is to predict future stock prices based on historical data. To achieve this, you need to implement a sliding window mechanism that calculates the moving average over a specified window size. This moving average helps smooth out short-term fluctuations and highlight longer-term trends or cycles. # Task Implement a class `MovingAverage` with the following methods: 1. `__init__(self, window_size: int)`: Constructor to initialize the MovingAverage with a specified window size. 2. `next(self, val: float) -> float`: Method to add a new value and return the current moving average. # Constraints * The `window_size` will be at most (10^5). * New values will be added sequentially using the `next` method. * Values will be floating-point numbers within the range of (-10^4) to (10^4). # Input * Initialization of `MovingAverage` with an integer `window_size`. * Multiple calls to the `next(val)` method with `val` being a floating-point number. # Output * For each call to `next(val)`, return the current moving average as a floating-point number. # Examples ```python # Example usage moving_average = MovingAverage(3) print(moving_average.next(1)) # 1.0 print(moving_average.next(10)) # 5.5 print(moving_average.next(3)) # 4.66667 print(moving_average.next(5)) # 6.0 ``` # Notes * The moving average should take into account only the last `window_size` values. * If fewer than `window_size` values have been added, the average should be computed using all the values present so far. * Ensure your implementation efficiently handles the sliding window operation. * You may assume that calls to `next(val)` are less frequent than the maximum possible `window_size`.","solution":"from collections import deque class MovingAverage: def __init__(self, window_size: int): self.window_size = window_size self.queue = deque() self.total = 0.0 def next(self, val: float) -> float: if len(self.queue) == self.window_size: self.total -= self.queue.popleft() self.queue.append(val) self.total += val return self.total / len(self.queue)"},{"question":"# Problem Statement You are given a string containing a sequence of open and close parentheses. Your task is to implement a function `min_remove_to_make_valid` that removes the minimum number of parentheses to make the input string valid. An input string is considered valid if: 1. Open parentheses `(` are closed by the corresponding close parentheses `)`. 2. The parentheses are properly nested. The output should be a valid string with the minimum number of deletions. # Function Definition ```python def min_remove_to_make_valid(s: str) -> str: :param s: A string containing parentheses. :return: A valid string with the minimum number of removals. ``` # Input * `s` is a string with length between [1, 10^5]. # Output * Return a string with the minimum number of deletions to make the input string valid. # Constraints * The input string only contains lowercase letters and parentheses `(` and `)`. # Performance Requirements * Ensure the solution handles large datasets efficiently, preferably in linear time complexity, O(n). # Example Example 1: ```python s = \\"lee(t(c)o)de)\\" # Output: \\"lee(t(c)o)de\\" ``` Example 2: ```python s = \\"a)b(c)d\\" # Output: \\"ab(c)d\\" ``` Example 3: ```python s = \\"))((\\" # Output: \\"\\" ``` # Note * The order of the characters should be preserved. * If multiple valid strings can be obtained by removing the minimum number of parentheses, return any of them. * The function should handle special cases such as strings without parentheses or strings entirely composed of misplaced parentheses.","solution":"def min_remove_to_make_valid(s: str) -> str: Remove the minimum number of parentheses to make the input string valid. :param s: A string containing parentheses. :return: A valid string with the minimum number of removals. stack = [] to_remove = set() # First pass: Identify indices of parentheses to be removed for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: to_remove.add(i) # Add remaining unmatched \'(\' indices to `to_remove` to_remove.update(stack) # Build the result string excluding the indices in `to_remove` result = [] for i, char in enumerate(s): if i not in to_remove: result.append(char) return \'\'.join(result)"},{"question":"# Coding Assessment Question: Climate Data Analysis Scenario As part of a climate study, you are tasked with analyzing temperature and precipitation data collected from various weather stations over several years. Each weather station records daily temperature and precipitation levels, and this data is stored in a structured format. Problem Statement Implement a Python class `ClimateAnalyzer` to manage the climate data and perform analysis. The class will support functionalities to: 1. Load data from a CSV file. 2. Calculate the average temperature and total precipitation for each year. 3. Identify the year with the highest average temperature and the year with the highest total precipitation. Requirements 1. The class should be initialized with the file path of the CSV containing the climate data. 2. Implement a method `load_data` to load data from the CSV file. The CSV file has the following columns: `year`, `month`, `day`, `temperature`, `precipitation`. 3. Implement methods to calculate: - `average_temperature_per_year`: Returns a dictionary with years as keys and average temperatures as values. - `total_precipitation_per_year`: Returns a dictionary with years as keys and total precipitation as values. 4. Implement methods to identify: - `year_with_highest_average_temp`: Returns the year with the highest average temperature. - `year_with_highest_precipitation`: Returns the year with the highest total precipitation. Input/Output Format - **Input**: CSV file path for the class initialization and the CSV file contains the following data: - Columns: `year`, `month`, `day`, `temperature`, `precipitation` - Example: ```csv year,month,day,temperature,precipitation 2020,1,1,15.5,2.0 2020,1,2,16.0,0.0 2020,1,3,14.0,1.0 ... ``` - **Output**: Various methods output dictionaries or year integers as specified. - **Constraints**: - The data is well-formed without missing values. - The temperatures are floating-point numbers and precipitation levels are non-negative floating-point numbers. **Performance:** The solution should handle large datasets efficiently. Example Scenario ```python # Creating an instance and loading data analyzer = ClimateAnalyzer(\\"climate_data.csv\\") analyzer.load_data() # Calculating average temperature per year avg_temp = analyzer.average_temperature_per_year() print(\\"Average Temperature per Year:\\", avg_temp) # Calculating total precipitation per year total_precip = analyzer.total_precipitation_per_year() print(\\"Total Precipitation per Year:\\", total_precip) # Finding the year with the highest average temperature year_high_temp = analyzer.year_with_highest_average_temp() print(\\"Year with Highest Average Temperature:\\", year_high_temp) # Finding the year with the highest total precipitation year_high_precip = analyzer.year_with_highest_precipitation() print(\\"Year with Highest Total Precipitation:\\", year_high_precip) ``` Implementation Details: - Utilize pandas for data manipulation. - Ensure the solution efficiently handles large datasets. - Implement error handling for file I/O operations and data calculations. Happy coding!","solution":"import pandas as pd class ClimateAnalyzer: def __init__(self, file_path): self.file_path = file_path self.data = None def load_data(self): Load climate data from a CSV file. self.data = pd.read_csv(self.file_path) def average_temperature_per_year(self): Calculate the average temperature for each year. Returns: dict: A dictionary with years as keys and average temperatures as values. avg_temp_per_year = self.data.groupby(\'year\')[\'temperature\'].mean().to_dict() return avg_temp_per_year def total_precipitation_per_year(self): Calculate the total precipitation for each year. Returns: dict: A dictionary with years as keys and total precipitations as values. total_precip_per_year = self.data.groupby(\'year\')[\'precipitation\'].sum().to_dict() return total_precip_per_year def year_with_highest_average_temp(self): Identify the year with the highest average temperature. Returns: int: The year with the highest average temperature. avg_temp_per_year = self.average_temperature_per_year() return max(avg_temp_per_year, key=avg_temp_per_year.get) def year_with_highest_precipitation(self): Identify the year with the highest total precipitation. Returns: int: The year with the highest total precipitation. total_precip_per_year = self.total_precipitation_per_year() return max(total_precip_per_year, key=total_precip_per_year.get)"},{"question":"# Context You are developing a file management application that allows users to organize and manage their files in an efficient manner. One of the core functionalities of this application is to detect and handle duplicate files. Since files can be large, checking for duplicates based solely on content comparison can be computationally expensive. Instead, you are tasked with using a hashing technique to achieve this efficiently. # Problem Statement Create a function `find_duplicates` which takes the following arguments: 1. `file_names`: a list of strings, where each string represents the name of a file. 2. `file_contents`: a list of strings, where each string represents the content of the corresponding file. The function should return a list of all file names that have duplicates based on their content. # Input - `file_names`: List of strings `[name1, name2, ..., namen]` where `0 < n ≤ 1000` and `1 ≤ len(namei) ≤ 100`. - `file_contents`: List of strings `[content1, content2, ..., contentn]` where `0 ≤ len(contenti) ≤ 10000`. # Output - Returns a list of strings containing the names of all files that have duplicates in the form of their content. # Constraints Ensure your function performs efficiently, handling edge cases, including: - Files with empty content. - No duplicates at all. - Multiple pairs/groups of duplicate files. # Example ```python file_names = [\\"file1.txt\\", \\"file2.txt\\", \\"file3.bmp\\", \\"file4.txt\\", \\"file5.pdf\\"] file_contents = [\\"hello world\\", \\"data structures\\", \\"hello world\\", \\"data structures\\", \\"algorithms\\"] find_duplicates(file_names, file_contents) # Expected Output: [\\"file1.txt\\", \\"file2.txt\\", \\"file3.bmp\\", \\"file4.txt\\"] ``` # Notes - Make sure to use an appropriate hashing technique to detect duplicates in an efficient manner. - Consider edge cases such as files with identical content but different names, and handle them correctly.","solution":"def find_duplicates(file_names, file_contents): Function to find duplicate files based on their content. Parameters: file_names (list of str): List containing the names of the files. file_contents (list of str): List containing the contents of the corresponding files. Returns: list of str: List of file names which have duplicate content. content_to_files = {} for file_name, content in zip(file_names, file_contents): if content in content_to_files: content_to_files[content].append(file_name) else: content_to_files[content] = [file_name] duplicates = [] for files in content_to_files.values(): if len(files) > 1: duplicates.extend(files) return duplicates"},{"question":"# Problem: Matrix Transposition and Element Summation You are tasked with implementing a function that performs two operations on a given matrix: transpose the matrix and compute the sum of elements in each row of the transposed matrix. This task will help understand matrix manipulation and basic arithmetic operations in Python. Function Signature ```python def transpose_and_sum(matrix: List[List[int]]) -> Tuple[List[List[int]], List[int]]: Transposes the given matrix and computes the sum of elements in each row of the transposed matrix. Args: matrix (List[List[int]]): A 2D list representing the matrix. Returns: Tuple[List[List[int]], List[int]]: A tuple containing the transposed matrix and a list with the sum of elements in each row of the transposed matrix. pass ``` Input: * **matrix (List[List[int])**: A 2D list representing the original matrix, where each sub-list represents a row of the matrix. The dimensions of the matrix are such that: - 1 <= len(matrix) <= 1000 - 1 <= len(matrix[0]) <= 1000 Output: * Returns a tuple containing: - A 2D list representing the transposed matrix. - A list of integers representing the sum of elements in each row of the transposed matrix. Constraints: * The matrix will have at least one row and one column. * Elements of the matrix are integers within the range -10^6 to 10^6. Context: Imagine you are performing data transformations where you need to reshape and aggregate data. In this scenario, understanding the manipulation of 2D arrays and aggregating row sums after transposition is essential. Examples: ```python >>> transpose_and_sum([[1, 2, 3], [4, 5, 6]]) ([[1, 4], [2, 5], [3, 6]], [5, 7, 9]) >>> transpose_and_sum([[7, 8], [9, 10], [11, 12]]) ([[7, 9, 11], [8, 10, 12]], [27, 30]) >>> transpose_and_sum([[1]]) ([[1]], [1]) ``` Notes: * To transpose a matrix, swap its rows and columns. * Ensure your solution is efficient for large matrices, considering the upper bound of the input size. * Edge cases like a single-element matrix should be handled gracefully. Ensure to use built-in Python functions and list comprehensions effectively to achieve both tasks.","solution":"from typing import List, Tuple def transpose_and_sum(matrix: List[List[int]]) -> Tuple[List[List[int]], List[int]]: Transposes the given matrix and computes the sum of elements in each row of the transposed matrix. Args: matrix (List[List[int]]): A 2D list representing the matrix. Returns: Tuple[List[List[int]], List[int]]: A tuple containing the transposed matrix and a list with the sum of elements in each row of the transposed matrix. # Transpose the matrix transposed_matrix = list(map(list, zip(*matrix))) # Calculate the sum of elements in each row of the transposed matrix row_sums = [sum(row) for row in transposed_matrix] return transposed_matrix, row_sums"},{"question":"# Objective Develop and simplify solutions for the Bracket Sequence Validation problem. This task will help measure your ability to manage stacks, string processing, and ensure code correctness for common algorithmic challenges. # Problem Statement Implement the following function to validate if a given string is a balanced sequence of brackets. The brackets considered are `(), [], {}`. 1. **is_balanced(input_string: str) -> bool** - Determines if the input string consists of balanced brackets. - **Input**: - `input_string`: A string containing any characters, but only `(), [], {}` brackets are considered for validation. - **Output**: - `True` if the string has balanced brackets. - `False` otherwise. # Constraints - Only `(), [], {}` brackets present in the input string are considered for validation, other characters should be ignored. - The input string can be of length between 1 and 1000000, inclusive. - The function should raise `ValueError` if the input string is empty. # Examples 1. **Valid Brackets** ```python is_balanced(\\"()\\") -> True is_balanced(\\"([]{})\\") -> True is_balanced(\\"{[()]}\\") -> True is_balanced(\\"abc[d{e(f)g}h]i\\") -> True ``` 2. **Invalid Brackets** ```python is_balanced(\\"(\\") -> False is_balanced(\\"({)}\\") -> False is_balanced(\\"{[}]\\") -> False is_balanced(\\"a[b{c}d\\") -> False ``` # Function Signature ```python def is_balanced(input_string: str) -> bool: pass ``` # Notes - Implement a stack-based approach to solve the problem. - Ensure to ignore non-bracket characters while validating. - Validate your implementations with comprehensive test cases, including edge cases and large inputs for performance checks.","solution":"def is_balanced(input_string: str) -> bool: if not input_string: raise ValueError(\\"Input string cannot be empty\\") stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} opening_brackets = matching_bracket.values() for char in input_string: if char in opening_brackets: stack.append(char) elif char in matching_bracket: if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False return not stack"},{"question":"# String Permutation Checker You are required to write a function that checks whether one string is a permutation of another. Two strings are permutations of each other if they contain the same characters with the same frequencies. Problem Statement Implement the function `is_permutation(s1: str, s2: str) -> bool` which will: 1. Take two strings `s1` and `s2`. 2. Determine if `s2` is a permutation of `s1`. 3. Return `True` if `s2` is a permutation of `s1`, otherwise return `False`. You are not allowed to use any built-in sort function. Instead, you should use a hash map to count the frequency of characters in both strings and then compare these frequencies. Input and Output Formats * **Input**: * `s1` (string): The first string. * `s2` (string): The second string. * **Output**: * `bool`: A boolean indicating whether `s2` is a permutation of `s1`. Constraints: * Both input strings will only contain lowercase alphabets. * The length of each string will not exceed 100 characters. Example ```python # Example usage print(is_permutation(\\"abc\\", \\"bca\\")) # Output: True print(is_permutation(\\"abc\\", \\"abcd\\")) # Output: False print(is_permutation(\\"hello\\", \\"ollhe\\")) # Output: True ``` Explanation In the first example, \\"abc\\" and \\"bca\\" have the same characters with the same frequencies, so the function returns `True`. In the second example, the lengths and characters differ, so it returns `False`. In the third example, \\"hello\\" and \\"ollhe\\" contain the same characters with the same frequencies, so it returns `True`.","solution":"def is_permutation(s1: str, s2: str) -> bool: Check if `s2` is a permutation of `s1`. :param s1: The first string :param s2: The second string :return: True if s2 is a permutation of s1, False otherwise if len(s1) != len(s2): return False char_count = {} # Count characters in s1 for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract characters count based on s2 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"# Problem Statement Given a list of integers, write a function `filter_and_reverse` that first filters out the negative integers from the list and then returns the non-negative integers in reverse order. Your function should meet the following requirements: 1. The function should filter out all negative integers. 2. The function should return the remaining integers in reverse order. # Function Signature ```python def filter_and_reverse(input_list: list) -> list: pass ``` # Input * `input_list` (list): A list of integers which can contain negative and non-negative integers, including zero. # Output * The function should return a list of non-negative integers in reverse order. # Constraints * The input list can contain up to 1000 integers. * The integers in the list can be in the range from -1000 to 1000. # Example ```python >>> filter_and_reverse([1, -2, 3, -4, 5]) [5, 3, 1] >>> filter_and_reverse([-1, -2, -3, -4]) [] >>> filter_and_reverse([0, 1, 2, 3]) [3, 2, 1, 0] >>> filter_and_reverse([]) [] ``` # Notes * Be sure to handle edge cases such as an empty list or a list that contains only negative integers. * The function should handle a variety of list sizes up to the maximum constraint.","solution":"def filter_and_reverse(input_list: list) -> list: Filters out negative integers and returns the non-negative integers in reverse order. Args: input_list (list): A list of integers. Returns: list: A list of non-negative integers in reverse order. # Filter out negative integers filtered_list = [num for num in input_list if num >= 0] # Reverse the filtered list reversed_list = filtered_list[::-1] return reversed_list"},{"question":"# Coding Question: Median of Two Sorted Arrays **Scenario**: You are a software developer tasked with developing a statistical analysis tool for a research department. One part of this analysis involves efficiently finding the median of two sorted arrays of integers. The median is a measure used to find the middle value of a data set, which effectively divides the dataset into two halves. **Problem**: Write a function `find_median_sorted_arrays` that takes in two sorted arrays and returns the median of the combined arrays. # Requirements: 1. The arrays passed to the function are both sorted in non-decreasing order. 2. The function should run in (O(log(min(n, m)))) time complexity, where (n) and (m) are the lengths of the input arrays. # Function Signature: ```python def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: Find the median of two sorted arrays. Args: nums1 (list of int): The first sorted array. nums2 (list of int): The second sorted array. Returns: float: The median of the combined sorted arrays. Examples: >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([0, 0], [0, 0]) 0.0 ``` # Constraints: - The total length of the combined arrays does not exceed (2*10^5). - The inputs are all integers. - No additional constraints are added related to the values within the arrays. # Examples: 1. **Input**: `[1, 3]`, `[2]` **Output**: `2.0` (The combined array is `[1, 2, 3]` and the median is `2.0`). 2. **Input**: `[1, 2]`, `[3, 4]` **Output**: `2.5` (The combined array is `[1, 2, 3, 4]` and the median is `(2 + 3) / 2 = 2.5`). 3. **Input**: `[0, 0]`, `[0, 0]` **Output**: `0.0` (The combined array is `[0, 0, 0, 0]` and the median is `(0 + 0) / 2 = 0.0`). ```python def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: def merge(arr1, arr2): sorted_arr = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: sorted_arr.append(arr1[i]) i += 1 else: sorted_arr.append(arr2[j]) j += 1 sorted_arr.extend(arr1[i:]) sorted_arr.extend(arr2[j:]) return sorted_arr def find_median(sorted_arr): n = len(sorted_arr) mid = n // 2 if n % 2 == 0: return (sorted_arr[mid - 1] + sorted_arr[mid]) / 2 else: return sorted_arr[mid] merged_array = merge(nums1, nums2) return find_median(merged_array) ```","solution":"def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: def merge(arr1, arr2): sorted_arr = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: sorted_arr.append(arr1[i]) i += 1 else: sorted_arr.append(arr2[j]) j += 1 sorted_arr.extend(arr1[i:]) sorted_arr.extend(arr2[j:]) return sorted_arr def find_median(sorted_arr): n = len(sorted_arr) mid = n // 2 if n % 2 == 0: return (sorted_arr[mid - 1] + sorted_arr[mid]) / 2 else: return sorted_arr[mid] merged_array = merge(nums1, nums2) return find_median(merged_array)"},{"question":"# Binary Tree and Path Sum You are provided with a class definition for a binary tree node which includes several methods such as `insert`, `find`, and `delete`. Your task is to implement a new method `has_path_sum` for the `BinaryTree` class, which determines if the tree has a root-to-leaf path such that adding up all the values along the path equals the given target sum. Requirements: 1. **Input**: The method `has_path_sum` should take one input parameter `target_sum` (other than `self` for the class method), which is the desired sum of the path. 2. **Output**: The method should return a boolean value (`True` or `False`) indicating whether such a path exists. 3. **Performance Constraints**: The method should ideally run in O(n) time complexity, where n is the number of nodes in the tree. 4. **Corner Cases**: Handle edge cases where the tree is empty (should return `False`). Function Signature: ```python def has_path_sum(self, target_sum: int) -> bool ``` Example: ```python # Example 1 binary_tree = make_binary_tree([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, 1]) assert binary_tree.has_path_sum(22) == True # Path present: 5 -> 4 -> 11 -> 2 # Example 2 binary_tree = make_binary_tree([1, 2, 3]) assert binary_tree.has_path_sum(5) == False # No path with sum 5 ``` **Note**: The tree is constructed from a list where `None` signifies missing nodes in the standard level-order traversal of the binary tree. You should thoroughly test your implementation with various edge cases to ensure its robustness.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def has_path_sum(self, target_sum): def has_path_sum_helper(node, current_sum): if not node: return False current_sum += node.value if not node.left and not node.right: # Reached a leaf node return current_sum == target_sum # Otherwise, continue the search on left and right subtrees return has_path_sum_helper(node.left, current_sum) or has_path_sum_helper(node.right, current_sum) return has_path_sum_helper(self.root, 0) # Helper function to construct binary tree from list def make_binary_tree(values): if not values: return BinaryTree() nodes = [None if val is None else TreeNode(val) for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return BinaryTree(root)"},{"question":"# Coding Assessment Question Objective: Implement a function that rotates a square matrix 90 degrees clockwise. Then, create another function that verifies if two matrices are identical after rotation. Problem Statement: You need to create a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that rotates a given NxN matrix 90 degrees clockwise. Additionally, create another function `are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool` that checks if one matrix is identical to another after being rotated 90 degrees clockwise. Input: 1. `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]`: - A square matrix represented as a list of lists of integers. 2. `are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool`: - Two square matrices represented as lists of lists of integers. Output: 1. `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]`: - A new matrix which is the result of rotating the input matrix 90 degrees clockwise. 2. `are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool`: - A boolean value indicating whether the original matrix, after being rotated 90 degrees clockwise, is identical to the rotated matrix (True) or not (False). Constraints: - The input matrix for `rotate_matrix` should be a non-empty NxN matrix where 1 ≤ N ≤ 100. - Both input matrices for `are_matrices_identical_after_rotation` should be non-empty NxN matrices where 1 ≤ N ≤ 100. - The elements of the matrices are integers within the range [-1000, 1000]. Example: ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> are_matrices_identical_after_rotation([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True ``` Requirements: - Perform the matrix rotation in place or create a new matrix. - Ensure that inputs are properly validated before processing. - Handle any invalid or unexpected inputs gracefully.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n-i-1] = matrix[i][j] return new_matrix def are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool: Checks if the original matrix is identical to the rotated matrix after a 90 degrees rotation. rotated_90 = rotate_matrix(original) return rotated == rotated_90"},{"question":"**[Question 2]: Fibonacci Subsequence Sum** You are asked to find the sum of a specific subsequence within the Fibonacci sequence. Given a start and end index, compute the sum of the Fibonacci numbers in that range, inclusive. # Input: - Two integers `start` and `end` representing the starting and ending indices in the Fibonacci sequence (0-indexed). # Output: - An integer representing the sum of the Fibonacci numbers from `start` to `end`, inclusive. # Constraints: - `0 <= start <= end <= 10^5` # Performance Requirements: - Your algorithm should compute the Fibonacci numbers efficiently. - Avoid recomputation using techniques such as memoization or iterative approaches. # Function Signature: ```python def fibonacci_subsequence_sum(start: int, end: int) -> int: ``` # Example: ```python >>> fibonacci_subsequence_sum(2, 5) 12 # Fibonacci sequence: 0, 1, 1, 2, 3, 5; Sum of 1, 2, 3, 5 is 12 >>> fibonacci_subsequence_sum(0, 2) 2 # Fibonacci sequence: 0, 1, 1; Sum of 0, 1, 1 is 2 >>> fibonacci_subsequence_sum(10, 15) 151 # Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610; Sum of 55, 89, 144, 233, 377, 610 is 1518 ``` **Note**: Ensure your function handles large values of `end` efficiently by avoiding unnecessary recomputation and uses optimal space complexity.","solution":"def fibonacci_subsequence_sum(start: int, end: int) -> int: Returns the sum of the Fibonacci numbers from the start to end indices, inclusive. if start < 0 or end < 0 or start > end: raise ValueError(\\"Invalid input: start and end must be non-negative and start must be less than or equal to end.\\") if start == end == 0: return 0 # Initialize the first two Fibonacci numbers and a variable to track their sum fib = [0, 1] # Generate the Fibonacci sequence up to the \'end\' index for _ in range(2, end + 1): fib.append(fib[-1] + fib[-2]) # Compute the sum of the subsequence from start to end return sum(fib[start:end+1])"},{"question":"# Question You have been given an array `heights` representing the heights of buildings in a skyline and a positive integer `k`. A building can be moved to any position at most `k` units from its original position. Your task is to find the maximum possible sum of heights for any contiguous subarray of length `k`. Implement the function `max_height_sum` that takes an array of integers `heights` and an integer `k`, and returns the maximum possible sum of heights for any contiguous subarray of length `k`. Function Signature ```python def max_height_sum(heights: list[int], k: int) -> int: pass ``` Input * `heights` (list of int): A list of integers where each integer represents the height of a building (1 ≤ len(heights) ≤ 10^5 and 1 ≤ heights[i] ≤ 10^4 for all valid `i`). * `k` (int): A positive integer representing the length of the contiguous subarray (1 ≤ k ≤ len(heights)). Output * `int`: The maximum possible sum of heights for any contiguous subarray of length `k`. Constraints * The input `heights` contains only positive integers. * The input `k` is guaranteed to be less than or equal to the length of the `heights` array. Examples 1. `max_height_sum([1, 3, 2, 5, 6, 4], 3)` should return `15`, where the subarray `[5, 6, 4]` gives the maximum sum. 2. `max_height_sum([4, 2, 1, 3, 6], 2)` should return `9`, where the subarray `[3, 6]` gives the maximum sum. Requirements * Implement the function using an efficient approach, such as a sliding window technique. * Avoid using brute force methods that would result in a high time complexity. Additional Context * Use the sliding window technique to efficiently calculate the sum of the contiguous subarrays of length `k`. * Consider potential edge cases where the array contains a very high or low distribution of building heights.","solution":"def max_height_sum(heights: list[int], k: int) -> int: Returns the maximum sum of heights for any contiguous subarray of length k. Uses sliding window technique for efficient computation. # Initial sum of the first window of size k current_sum = sum(heights[:k]) max_sum = current_sum # Use sliding window approach to find the maximum sum of subarrays of size k for i in range(k, len(heights)): current_sum += heights[i] - heights[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"# Inventory Management System You are tasked with developing a function to manage and update an inventory system. This system needs to keep track of different products and their quantities in a store. Function Signature ```python def update_inventory(existing_inventory: dict, new_stock: dict) -> dict: pass ``` # Instructions 1. **Functionality**: You are provided with a function `update_inventory` that takes two dictionaries: - `existing_inventory`: A dictionary where keys are product names (strings) and values are the current quantity in the inventory (integers). - `new_stock`: A dictionary where keys are product names (strings) and values are the quantities to add to the inventory (integers). 2. **Updating the Inventory**: - The function should update the `existing_inventory` by adding the quantities from the `new_stock`. - If a product from `new_stock` does not exist in the `existing_inventory`, it should be added with its corresponding quantity. - The function should return the updated inventory as a dictionary. 3. **Error Handling**: - If any quantity in either dictionary is negative, raise a `ValueError` with a message indicating that quantities cannot be negative. - Ensure that the product names are consistent (case-sensitive). # Expected Input and Output * **Input**: - `existing_inventory`: a dictionary representing the current inventory with product names as keys and their quantities as values. - `new_stock`: a dictionary representing the new stock to be added to the inventory with product names as keys and their quantities as values. * **Output**: - A dictionary representing the updated inventory after adding the new stock quantities. # Constraints 1. All quantities must be non-negative integers. 2. Product names should be case-sensitive. # Example ```python >>> update_inventory({\\"apple\\": 50, \\"banana\\": 30}, {\\"apple\\": 20, \\"orange\\": 40}) {\'apple\': 70, \'banana\': 30, \'orange\': 40} >>> update_inventory({\\"apple\\": 50}, {\\"apple\\": -10}) ValueError: Quantities cannot be negative >>> update_inventory({\\"Milk\\": 10}, {\\"milk\\": 5}) {\'Milk\': 10, \'milk\': 5} ``` # Note Ensure that the function correctly updates the inventory, handles all edge cases, and raises appropriate errors for invalid inputs.","solution":"def update_inventory(existing_inventory: dict, new_stock: dict) -> dict: Updates the existing inventory with the new stock quantities. Args: existing_inventory (dict): A dictionary with product names as keys and their quantities as values. new_stock (dict): A dictionary with product names as keys and the quantities to add to the inventory as values. Returns: dict: The updated inventory with the new stock quantities added. Raises: ValueError: If any quantity is negative. for product, quantity in new_stock.items(): if quantity < 0: raise ValueError(\\"Quantities cannot be negative\\") if product in existing_inventory: existing_inventory[product] += quantity else: existing_inventory[product] = quantity return existing_inventory"},{"question":"# Coding Assessment Question **Context**: You are tasked with finding the shortest path lengths from a single source vertex to all other vertices in a weighted directed graph using Dijkstra\'s algorithm. **Challenge**: Implement the function `dijkstra(graph: List[List[Tuple[int, int]]], source: int) -> List[int]` that receives an adjacency list of a weighted directed graph and a source vertex, and returns a list of shortest path lengths from the source vertex to every other vertex. **Specifications**: - The graph is represented as an adjacency list where each index `i` represents a node, and each element `graph[i]` is a list of tuples `(v, w)` where `v` is a node connected by an outgoing edge from node `i` with weight `w`. - The function should return a list of shortest path lengths from the source vertex to each node, where the length of the shortest path to the source itself is 0. - If a node is unreachable from the source, its shortest path length should be infinity (`float(\'inf\')`). **Input**: - `graph`: List of lists of tuples, where each tuple `(v, w)` represents an edge from the current node to node `v` with weight `w`. - `source`: The source vertex from which shortest paths are calculated. **Output**: - A list of shortest path lengths from the source vertex to each node. **Constraints**: - The number of nodes (n) and number of edges (e) are such that (0 leq n, e leq 10^4). - Edge weights are non-negative integers. **Example**: ```python # Input graph = [ [(1, 2), (2, 4)], # Node 0 has edges to Node 1 (weight 2) and Node 2 (weight 4) [(2, 1)], # Node 1 has an edge to Node 2 (weight 1) [(3, 3)], # Node 2 has an edge to Node 3 (weight 3) [] # Node 3 has no outgoing edges ] source = 0 # Output print(dijkstra(graph, source)) # Output: [0, 2, 3, 6] ``` **Note**: - Use appropriate data structures to ensure efficient implementation, such as priority queues. - Ensure edge cases like an empty graph or nodes with no outgoing edges are handled correctly. **Additional Notes**: - Feel free to use helper functions to modularize your code. - Assume that the input graph will be connected if there are non-zero nodes and edges.","solution":"import heapq def dijkstra(graph, source): Implements Dijkstra\'s algorithm to find the shortest path lengths from the source node to all other nodes. # Number of nodes in the graph n = len(graph) # Initialize the distances with infinity distances = [float(\'inf\')] * n distances[source] = 0 # Priority queue to store (distance, node) pairs pq = [(0, source)] while pq: current_distance, current_node = heapq.heappop(pq) # If we have already found a shorter path, skip processing if current_distance > distances[current_node]: continue # Explore the neighbors of the current node for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a shorter path to neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Question: Implement Batched Matrix Exponential You are working on a numerical computation library, and one of the functions that need to be implemented is a batched version of the matrix exponential, which is used in solving systems of linear differential equations. Task Implement the function `batched_matrix_exponential(matrices)` in Python. This function should compute the matrix exponential `exp(A)` for each 2D square matrix `A` in a batch. Function Details - **Input**: - `matrices` (np.ndarray): A batch of 2D square matrices of shape `(batch_size, n, n)`. - **Output**: - `result` (np.ndarray): A batch of matrix exponentials of shape `(batch_size, n, n)`. Constraints - Each matrix in the batch is a square matrix with the same dimensions (e.g., `n x n`). - Ensure the function handles matrices whose entries aren\'t necessarily integers. - The function should efficiently handle batches with at least ten 5x5 matrices. Example ```python import numpy as np def batched_matrix_exponential(matrices): # Your implementation here # Example usage batch = np.array([ [[0.0, 1.0], [-1.0, 0.0]], [[1.0, 0.0], [0.0, 1.0]], [[0.0, 0.0], [0.0, 0.0]] ]) result = batched_matrix_exponential(batch) print(result) # Output: Expected matrix exponentials # [ # [[cos(1), sin(1)], [-sin(1), cos(1)]], # exp([[0, 1], [-1, 0]]) # [[e, 0], [0, e]], # exp([[1, 0], [0, 1]]) # [[1, 0], [0, 1]] # exp([[0, 0], [0, 0]]) # ] batch = np.array([[[-2.0, 1.0], [1.0, -2.0]], [[1.0, 2.0], [3.0, 4.0]]]) result = batched_matrix_exponential(batch) print(result) # Output will be the matrix exponentials of the input matrices # [ # [[0.08533664, 0.40600585], [0.40600585, 0.08533664]], # [[51.9687951 , 74.73656472], [112.10484086, 164.07363596]] # ] ``` Remember to handle any edge cases and ensure numerical stability when computing the matrix exponential.","solution":"import numpy as np from scipy.linalg import expm def batched_matrix_exponential(matrices): Compute the matrix exponential for each 2D square matrix in a batch. Parameters: matrices (np.ndarray): A batch of 2D square matrices of shape (batch_size, n, n). Returns: np.ndarray: A batch of matrix exponentials of shape (batch_size, n, n). batch_size = matrices.shape[0] result = np.empty_like(matrices) for i in range(batch_size): result[i] = expm(matrices[i]) return result"},{"question":"# Shortest Path in Weighted Graph You are given a directed weighted graph represented as an adjacency list. Write a function `shortest_path(graph, start, end)` that computes the shortest path (in terms of total edge weight) from the `start` vertex to the `end` vertex in the graph and returns the total weight of this path. If there is no path from `start` to `end`, return -1. Input * `graph` is represented as an adjacency list. It is a dictionary where keys are vertices and values are lists of tuples. Each tuple consists of a vertex that can be reached directly from the key vertex and the weight of the respective edge. * `start` and `end` are integers representing the starting and ending vertices respectively. Output * Return an integer representing the total weight of the shortest path from `start` to `end`. If no path exists, return -1. Constraints * The graph can have cycles, but there will be no negative weight cycles. * Vertices are numbered from `0` to `N-1`, where `N` is the number of vertices in the graph. * Weights of the edges are non-negative integers. * The graph may be empty with `N=0`. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 end = 3 print(shortest_path(graph, start, end)) # Output: 3 ``` **Explanation**: The shortest path from vertex 0 to vertex 3 is through vertices 2 and 1, which has a total weight of 1 + 2 + 1 = 4. There is another path from 0 to 3 through vertex 1, but its total weight is 4 + 1 = 5 which is longer. Therefore, the shortest path has a total weight of 3.","solution":"import heapq def shortest_path(graph, start, end): Computes the shortest path in terms of total edge weight from the start vertex to the end vertex. Parameters: graph (dict): An adjacency list where keys are vertices and values are lists of tuples representing neighbors and edge weights. start (int): The starting vertex. end (int): The ending vertex. Returns: int: The total weight of the shortest path from `start` to `end`. If no path exists, return -1. if start == end: return 0 # Priority queue to hold (current weight, vertex) pq = [(0, start)] # Dictionary to hold the shortest path to each vertex shortest_paths = {start: 0} while pq: current_weight, current_vertex = heapq.heappop(pq) if current_vertex == end: return current_weight for neighbor, weight in graph.get(current_vertex, []): path_weight = current_weight + weight if neighbor not in shortest_paths or path_weight < shortest_paths[neighbor]: shortest_paths[neighbor] = path_weight heapq.heappush(pq, (path_weight, neighbor)) return -1 # If the end vertex is not reachable from the start vertex"},{"question":"# Problem Statement To assist in developing an automated grading system for multiple-choice exams, you need to write a function that evaluates a student\'s answer sheet against an answer key. Create a function `grade_exam(answer_key: List[str], student_answers: List[str]) -> int` that takes two lists of strings, `answer_key` and `student_answers`, as inputs and returns an integer representing the student\'s score. Each correct answer earns the student 1 point, while incorrect answers do not affect the score. # Input - Two lists of strings `answer_key` and `student_answers` where: - `answer_key` contains the correct answers to the exam. - `student_answers` contains the student\'s answers to the exam. - Both lists will be of the same length, representing the number of questions in the exam. - Each element in the lists will be a string representing the answer to a question (e.g., \\"A\\", \\"B\\", \\"C\\", \\"D\\"). # Output - The function should return an integer representing the total score the student received. # Constraints - Both `answer_key` and `student_answers` will have lengths between 1 and 100 inclusive. - Each element in the lists will be one of the strings \\"A\\", \\"B\\", \\"C\\", or \\"D\\". # Example - `grade_exam([\\"A\\", \\"C\\", \\"B\\", \\"D\\"], [\\"A\\", \\"C\\", \\"D\\", \\"D\\"])` should return `3` because the student answered the first three questions correctly. # Implementation Note Ensure that your implementation accurately calculates the number of correct answers and appropriately handles variations in answers as specified in the lists.","solution":"def grade_exam(answer_key, student_answers): Evaluates a student\'s answer sheet against an answer key. Args: answer_key (list of str): The correct answers to the exam. student_answers (list of str): The student\'s answers to the exam. Returns: int: The student\'s score based on the number of correct answers. score = 0 for correct, student in zip(answer_key, student_answers): if correct == student: score += 1 return score"},{"question":"# Consistent Hashing with Virtual Nodes Implement a consistent hashing mechanism to distribute keys uniformly across a dynamically changing set of servers. In this problem, we will use virtual nodes to improve the uniformity of the key distribution. You need to design a class `ConsistentHashing` with the following methods: 1. **Constructor**: Initializes the consistent hashing mechanism. 2. **`add_server`**: Adds a new server to the hash ring with a given number of virtual nodes. 3. **`remove_server`**: Removes a server from the hash ring. 4. **`get_server`**: Finds the server responsible for the given key. Requirements: - Implement a consistent hashing algorithm with virtual nodes. - Ensure that the addition of a new server and removal of an existing server has minimal impact on the placement of keys. - Use a good hashing function for node and key placement. # Implementation Details: ```python class ConsistentHashing: def __init__(self) -> None: Initializes the consistent hashing with an empty hash ring. self.ring = {} self.servers = [] self.virtual_nodes = 100 # Default number of virtual nodes per server def add_server(self, server: str) -> None: Adds a new server to the hash ring with virtual nodes. Parameters: server (str): The identifier of the server to be added. for i in range(self.virtual_nodes): virtual_node_hash = hash(f\'{server}-{i}\') self.ring[virtual_node_hash] = server self.servers.append(server) self.ring = dict(sorted(self.ring.items())) def remove_server(self, server: str) -> None: Removes a server from the hash ring. Parameters: server (str): The identifier of the server to be removed. for i in range(self.virtual_nodes): virtual_node_hash = hash(f\'{server}-{i}\') if virtual_node_hash in self.ring: del self.ring[virtual_node_hash] self.servers.remove(server) self.ring = dict(sorted(self.ring.items())) def get_server(self, key: str) -> str: Finds the server responsible for the given key. Parameters: key (str): The key to be looked up. Returns: str: The server responsible for the key. key_hash = hash(key) for node_hash in self.ring: if key_hash <= node_hash: return self.ring[node_hash] return self.ring[list(self.ring.keys())[0]] # Wrap-around case ``` Example Use: ```python ch = ConsistentHashing() ch.add_server(\\"server1\\") ch.add_server(\\"server2\\") ch.add_server(\\"server3\\") print(ch.get_server(\\"my_key1\\")) # Outputs the server responsible for \\"my_key1\\" print(ch.get_server(\\"my_key2\\")) # Outputs the server responsible for \\"my_key2\\" ch.remove_server(\\"server2\\") print(ch.get_server(\\"my_key1\\")) # Outputs the new server responsible for \\"my_key1\\" after removal print(ch.get_server(\\"my_key2\\")) # Outputs the new server responsible for \\"my_key2\\" after removal ``` # Constraints: - The server identifiers and keys will be alphanumeric strings. - The number of servers will be in the range 1 <= number of servers <= 10^2. - Length of server identifiers and keys will be in the range 1 <= length <= 100. # Performance: - The addition and removal of servers should be efficient and minimize key movement across servers.","solution":"class ConsistentHashing: def __init__(self, virtual_nodes=100) -> None: Initializes the consistent hashing with an empty hash ring. Parameters: virtual_nodes (int): Number of virtual nodes per server. self.ring = {} self.servers = {} self.virtual_nodes = virtual_nodes def add_server(self, server: str) -> None: Adds a new server to the hash ring with virtual nodes. Parameters: server (str): The identifier of the server to be added. for i in range(self.virtual_nodes): virtual_node_key = f\'{server}-{i}\' virtual_node_hash = hash(virtual_node_key) self.ring[virtual_node_hash] = server self.servers[server] = self.virtual_nodes self._sort_ring() def remove_server(self, server: str) -> None: Removes a server from the hash ring. Parameters: server (str): The identifier of the server to be removed. if server in self.servers: for i in range(self.servers[server]): virtual_node_key = f\'{server}-{i}\' virtual_node_hash = hash(virtual_node_key) if virtual_node_hash in self.ring: del self.ring[virtual_node_hash] del self.servers[server] self._sort_ring() def get_server(self, key: str) -> str: Finds the server responsible for the given key. Parameters: key (str): The key to be looked up. Returns: str: The server responsible for the key. key_hash = hash(key) for node_hash in self.ring: if key_hash <= node_hash: return self.ring[node_hash] return self.ring[sorted(self.ring.keys())[0]] # Wrap-around case def _sort_ring(self): Sorts the hash ring keys for consistent traversal. self.ring = dict(sorted(self.ring.items()))"},{"question":"# Context You are developing a utility for a large online bookstore. The task involves managing the inventory of books, where each book is represented by its ISBN number and its popularity—determined by customer reviews. The operations needed are adding new books, updating the popularity of existing books, tracking the top k popular books, and outputting the entire inventory sorted by ISBN. # Task Implement the following operations using a suitable data structure: 1. Add a new book to the inventory. 2. Update the popularity of an existing book. 3. Retrieve the top k popular books. 4. Output the entire inventory sorted by ISBN. Implement the function with the following specifications: # Function Signature ```python def manage_book_inventory(operations: list[tuple[str, int, int]], k: int) -> tuple[list[int], list[int]]: ``` # Input * `operations`: A list of tuples, where each tuple represents an operation. The first element of the tuple is a string indicating the type of the operation - either \\"add\\", \\"update\\", or \\"retrieve\\". - For \\"add\\" and \\"update\\" operations, the tuple includes two additional integers: the ISBN of the book and its popularity. - For \\"retrieve\\" operations, the tuple includes only one additional integer, which indicates the number of top popular books to retrieve (i.e., k). * `k`: An integer for the number of top popular books to be retrieved. # Output * Returns a tuple of two lists: 1. A list of integers representing the ISBNs of the top k popular books in descending order of their popularity. 2. A list of integers representing the entire inventory sorted by ISBN. # Constraints * The ISBN numbers are unique. * Multiple \\"retrieve\\" operations can be included in the `operations` list. * The ISBN number will be within the range ([10^8, 10^9]). * The popularity value will be within the range ([0, 10^6]). * The inventory can contain up to (10^5) books. # Example ```python operations = [ (\\"add\\", 100000001, 300), (\\"add\\", 100000002, 500), (\\"add\\", 100000003, 200), (\\"update\\", 100000001, 800), (\\"retrieve\\", 0, 2), (\\"add\\", 100000004, 700), (\\"retrieve\\", 0, 3) ] k = 2 print(manage_book_inventory(operations, k)) # Output: ([100000001, 100000004], [100000001, 100000002, 100000003, 100000004]) ``` # Note - Handle the case where fewer books than k are available when retrieving the top k books. - Ensure the function performs efficiently for large input sizes, especially for frequent retrieval and update operations.","solution":"def manage_book_inventory(operations, k): inventory = {} def sort_inventory(): return sorted(inventory.items()) def top_k_books(): return sorted(inventory.items(), key=lambda x: (-x[1], x[0]))[:k] for operation in operations: if operation[0] == \\"add\\": isbn = operation[1] popularity = operation[2] if isbn not in inventory: inventory[isbn] = popularity elif operation[0] == \\"update\\": isbn = operation[1] popularity = operation[2] if isbn in inventory: inventory[isbn] = popularity sorted_inventory = [isbn for isbn, _ in sort_inventory()] top_books = [isbn for isbn, _ in top_k_books()] return (top_books, sorted_inventory)"},{"question":"# Sudoku Solver You have been tasked with creating a Sudoku solver. Using Python, you will write a function to solve a given 9x9 Sudoku puzzle. The puzzle will be provided as a list of lists where empty cells are represented by 0. # Requirements: 1. **Sudoku Solver Function** - Write a function to solve the Sudoku puzzle. - `solve_sudoku(board: list[list[int]]) -> bool` 2. **Helper Functions** - Develop helper functions to check the validity of numbers. - `is_valid(board: list[list[int]], row: int, col: int, num: int) -> bool` 3. **File Handling Functions** - Write functions to handle reading the Sudoku puzzle from a file and writing the solved puzzle to a file. - `read_sudoku_from_file(filename: str) -> list[list[int]]` - `write_sudoku_to_file(filename: str, board: list[list[int]]) -> None` # Constraints: - The Sudoku puzzle must be a 9x9 grid with values ranging from 0-9. - The function should return `True` if the puzzle is solved correctly, otherwise `False`. - The functions should handle file read/write errors gracefully. # Example Sudoku Puzzle: ```python puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9], ] ``` # Example Functions: ```python def solve_sudoku(board: list[list[int]]) -> bool: empty = find_empty(board) if not empty: return True row, col = empty for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def is_valid(board: list[list[int]], row: int, col: int, num: int) -> bool: for i in range(9): if board[row][i] == num or board[i][col] == num: return False box_x, box_y = row // 3, col // 3 for i in range(box_x * 3, box_x * 3 + 3): for j in range(box_y * 3, box_y * 3 + 3): if board[i][j] == num: return False return True def find_empty(board: list[list[int]]) -> tuple[int, int]: for i in range(9): for j in range(9): if board[i][j] == 0: return i, j return None def read_sudoku_from_file(filename: str) -> list[list[int]]: with open(filename, \'r\') as file: board = [] for line in file: board.append([int(num) for num in line.strip().split()]) return board def write_sudoku_to_file(filename: str, board: list[list[int]]) -> None: with open(filename, \'w\') as file: for row in board: file.write(\\" \\".join(map(str, row)) + \'n\') ``` # Example Usage: ```python def main() -> None: input_filename = \\"sudoku_input.txt\\" output_filename = \\"sudoku_solved.txt\\" board = read_sudoku_from_file(input_filename) if solve_sudoku(board): write_sudoku_to_file(output_filename, board) print(\\"Sudoku puzzle solved and written to\\", output_filename) else: print(\\"No solution exists for the Sudoku puzzle\\") if __name__ == \'__main__\': main() ``` Implement these functions and test with appropriate Sudoku puzzle files to ensure correctness and performance.","solution":"def solve_sudoku(board: list[list[int]]) -> bool: Solves the given 9x9 Sudoku puzzle. :param board: 2D list representing the sudoku table with 0s as empty spaces. :return: True if the puzzle is solved correctly, otherwise False. empty = find_empty(board) if not empty: return True row, col = empty for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def is_valid(board: list[list[int]], row: int, col: int, num: int) -> bool: Checks whether it is valid to place the `num` in the given cell. :param board: 2D list representing the sudoku table. :param row: Row index of the cell. :param col: Column index of the cell. :param num: Number to be placed in the cell. :return: True if valid, otherwise False. for i in range(9): if board[row][i] == num or board[i][col] == num: return False box_x, box_y = row // 3, col // 3 for i in range(box_x * 3, box_x * 3 + 3): for j in range(box_y * 3, box_y * 3 + 3): if board[i][j] == num: return False return True def find_empty(board: list[list[int]]) -> tuple[int, int]: Finds the next empty cell in the board. :param board: 2D list representing the sudoku table. :return: Tuple of row and column index of the empty cell; None if all cells are filled. for i in range(9): for j in range(9): if board[i][j] == 0: return i, j return None def read_sudoku_from_file(filename: str) -> list[list[int]]: Reads a Sudoku puzzle from a file. :param filename: Name of the file containing the Sudoku puzzle. :return: 2D list representing the Sudoku puzzle. board = [] with open(filename, \'r\') as file: for line in file: board.append([int(num) for num in line.strip().split()]) return board def write_sudoku_to_file(filename: str, board: list[list[int]]) -> None: Writes the solved Sudoku puzzle to a file. :param filename: Name of the file to write the solved puzzle. :param board: 2D list representing the solved Sudoku puzzle. with open(filename, \'w\') as file: for row in board: file.write(\\" \\".join(map(str, row)) + \'n\')"},{"question":"# Sum of Two Numbers as k You are tasked with developing a function that checks if any pair of numbers from the list can be added up to match a given target sum k. Problem Statement Implement a function `check_pair_sum(nums: list, k: int) -> bool` that determines if there are any two distinct numbers in the list `nums` that add up to the integer `k`. # Input * `nums` (list): A list of integers. * `k` (int): The target sum that two numbers from the list should add up to. # Output * A boolean value: - `True` if there exists at least one pair of distinct numbers in the list that sum up to `k`. # Constraints * The list `nums` can be empty. * If the list is empty or contains fewer than two elements, the function should return `False`. * There may be duplicate numbers in the list. # Function Signature ```python def check_pair_sum(nums: list, k: int) -> bool: pass ``` # Examples ```python >>> check_pair_sum([2, 1, 8, 4, 7, 3], 10) True >>> check_pair_sum([1, 3, 5, 7], 12) True >>> check_pair_sum([1, 3, 5, 7], 2) False >>> check_pair_sum([], 5) False >>> check_pair_sum([5], 5) False ``` # Instructions - Utilize a set to store the numbers and check if the complement (`k - x`) is already in the set as you iterate through the list. - Ensure the implementation is efficient and handles various edge cases correctly. - Follow good coding practices, ensuring the code is clean and well-documented.","solution":"def check_pair_sum(nums: list, k: int) -> bool: Determines if there are any two distinct numbers in the list that add up to the integer k. Args: nums (list): A list of integers k (int): The target sum that two numbers from the list should add up to Returns: bool: True if there exists at least one pair of distinct numbers in the list that sum up to k, otherwise False seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"# Scenario In many real-world applications, it is important to analyze and summarize textual data. One common task is identifying the frequency of each unique word in a given document. This can be especially useful in linguistic studies, content analysis, and in building features for machine learning models. # Task Write a Python function `word_frequency(text: str) -> dict` that takes a string of text and returns a dictionary with each unique word as keys and their respective frequencies as values. The function should ignore case, punctuation, and should treat all forms of whitespace (spaces, tabs, newlines) as word separators. # Input Specifications * `text`: A string containing the text to be analyzed. # Output Specifications * A dictionary with words as keys and their frequencies as values. # Constraints * The input text can be of considerable length, such as the contents of a book or article. * Words should be treated case-insensitively (\'Python\' and \'python\' should be considered the same word). * Punctuation (e.g., .,!?\\") should be stripped from words. * Multiple whitespace characters should be treated as a single separator. # Example ```python >>> word_frequency(\\"Hello, world! This is a test. This test tests the test function.\\") { \\"hello\\": 1, \\"world\\": 1, \\"this\\": 2, \\"is\\": 1, \\"a\\": 1, \\"test\\": 3, \\"tests\\": 1, \\"the\\": 1, \\"function\\": 1 } >>> word_frequency(\\"Python is great! Python is widely used.\\") { \\"python\\": 2, \\"is\\": 2, \\"great\\": 1, \\"widely\\": 1, \\"used\\": 1 } ``` # Requirements * Use regular expressions to handle punctuation and whitespace separation. * Ensure the function\'s performance is optimized for texts of substantial length. * Consider edge cases such as empty strings or strings containing only punctuation.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Returns a dictionary with each unique word as keys and their respective frequencies as values. The function ignores case, punctuation, and treats all forms of whitespace as word separators. # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Split text into words by any whitespace words = text.split() # Count the frequency of each word freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"# String Manipulation: Longest Substring with k Distinct Characters Implement a function to find the length of the longest substring in a given string that contains at most `k` distinct characters. Scenario You are developing a text analysis feature that highlights the longest span within a text document containing at most `k` unique characters. Your task is to write a function that identifies this span, enabling efficient data summarization and pattern recognition. # Functional Requirements - **Function Name**: `longest_substring_k_distinct` - **Input**: * `text`: A string of alphanumeric characters (both uppercase and lowercase). * `k`: An integer representing the maximum number of distinct characters allowed. - **Output**: * An integer representing the length of the longest substring that meets the criteria. # Example ```python # Input: text = \\"araaci\\" k = 2 # Output: longest_length = 4 # Explanation: The substring \\"araa\\" contains only two distinct characters, \'a\' and \'r\'. ``` # Implementation Constraints 1. **Sliding Window Technique**: Utilize an efficient approach, such as the sliding window technique, to maintain the balance between complexity and performance. 2. **Edge Cases**: Handle various edge cases including minimal input length, `k` exceeding the number of unique characters in the string, and strings with high character repetition. 3. **Performance**: Aim for a solution with a time complexity of O(n). # Additional Information - **Assumptions**: * Input will always be a valid non-empty string. * The integer `k` will be a non-negative integer. - **Constraints**: * 1 <= len(text) <= 10^5 * 1 <= k <= len(text) Ensure the code is clean, well-documented, and gracefully handles different edge cases.","solution":"def longest_substring_k_distinct(text, k): Finds the length of the longest substring with at most k distinct characters. :param text: A string of alphanumeric characters. :param k: An integer representing the maximum number of distinct characters. :return: An integer representing the length of the longest substring that meets the criteria. if k == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(len(text)): char_count[text[right]] = char_count.get(text[right], 0) + 1 while len(char_count) > k: char_count[text[left]] -= 1 if char_count[text[left]] == 0: del char_count[text[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Question: Extract Unique Words from a Sentence You are required to implement a function that extracts all unique words from a given sentence, ignoring case and punctuation, and returns them in alphabetical order. Function: `extract_unique_words` Implement the function `extract_unique_words(sentence: str) -> List[str]`. **Input:** - `sentence`: A string representing a sentence which may include punctuation. **Output:** - A list of unique words (strings) from the sentence, sorted in alphabetical order and converted to lowercase. **Constraints:** - The sentence contains only alphabetic characters, spaces, and punctuation marks (`,`, `.`, `!`, `?`, `;`, `:`). - Words are separated by spaces and punctuation. **Example:** ```python assert extract_unique_words(\\"Hello, World! Hello, everyone.\\") == [\\"everyone\\", \\"hello\\", \\"world\\"] assert extract_unique_words(\\"A quick brown-fox, jumps; over the lazy dog!\\") == [\\"a\\", \\"brown\\", \\"dog\\", \\"fox\\", \\"jumps\\", \\"lazy\\", \\"over\\", \\"quick\\", \\"the\\"] ``` **Edge Cases to Consider:** - Sentences with multiple punctuation marks. - Sentences with mixed casing (e.g., uppercase, lowercase). - Sentences where all words are already in lowercase. - An empty string should return an empty list.","solution":"import re from typing import List def extract_unique_words(sentence: str) -> List[str]: Extracts unique words from a sentence, ignoring case and punctuation, and returns them in alphabetical order. :param sentence: A string representing a sentence. :return: A list of unique words sorted in alphabetical order. # Normalize the case and remove punctuation sentence = sentence.lower() words = re.findall(r\'bw+b\', sentence) # Get unique words unique_words = sorted(set(words)) return unique_words"},{"question":"# Question: Implement the Softmax Activation Function In this task, you will implement the Softmax activation function, which is extensively used in neural networks, particularly in the output layer of classification models. The Softmax function converts a vector of raw scores (logits) into a probability distribution. Mathematically, the Softmax function `f` applied to a vector `z` is defined as: ``` f(z_i) = exp(z_i) / sum(exp(z_j) for j in range(len(z))) ``` Where ( z_i ) is the i-th element in the vector `z`, and the denominator is the sum of exponentials of all the elements in the vector `z`. Your task is to write a function that computes the Softmax function over an input array of real numbers. Function Signature ```python def softmax(vector: List[float]) -> List[float]: pass ``` Input - `vector` (List[float]): A list of N real numbers representing the input logits. Output - A list of N real numbers after applying the Softmax function, representing the probability distribution. Constraints - The length of the vector can be between 1 and (10^6). - The value of each element in the vector is a real number that fits in the standard floating-point precision. Examples ```python >>> softmax([2.0, 1.0, 0.1]) [0.659001137504847, 0.2424329715225462, 0.09856589097260668] >>> softmax([-1.0, -2.0, -3.0]) [0.6652409557748219, 0.24472847105479764, 0.09003057317038046] ``` Notes - Ensure that the output probabilities sum to 1. - Handle numerical stability using techniques like subtracting the max element from the logits before exponentiation. - Ensure your solution is optimized for large `vector` sizes up to (10^6) entries. # End of Question","solution":"from typing import List import math def softmax(vector: List[float]) -> List[float]: Compute the Softmax of a list of numbers. Args: vector (List[float]): A list of numbers (logits). Returns: List[float]: The probability distribution after applying Softmax. max_val = max(vector) exp_values = [math.exp(v - max_val) for v in vector] sum_exp_values = sum(exp_values) probabilities = [ev / sum_exp_values for ev in exp_values] return probabilities"},{"question":"# Medication Dosage Schedule Validator You are given a class `MedicationDosage` that helps manage and validate the medication dosages prescribed to patients. Each dosage has a specific time interval and amount. The objective is to ensure that the daily medication plan for a patient does not exceed given limits and adheres to specified intervals between doses. Task Write a function `is_valid_dosage(schedule: list[tuple[int, int]], max_daily_dosage: int, min_interval: int) -> bool` that determines if the medication schedule is valid according to the given constraints. # Function Signature ```python def is_valid_dosage(schedule: list[tuple[int, int]], max_daily_dosage: int, min_interval: int) -> bool: ``` # Input - `schedule`: List of tuples where each tuple contains two integers representing the timing (in minutes from midnight) and amount of a single dose. - `max_daily_dosage`: An integer representing the maximum allowable dosage per day. - `min_interval`: An integer representing the minimum allowable interval (in minutes) between any two doses. # Output - Return `True` if the schedule is valid according to the given constraints, `False` otherwise. # Constraints - The length of `schedule` will be between 1 and 100. - The amount of each dose will be a positive integer. - `max_daily_dosage` is a positive integer. - `min_interval` is a positive integer. - Timing of doses is given in minutes from midnight (0 to 1440). # Notes - Ensure that the total dosage in the schedule does not exceed `max_daily_dosage`. - Ensure that the interval between any two consecutive doses is at least `min_interval` minutes. # Example ```python # Example 1: # Total dosage is 300 + 100 + 250 = 650 which is within the max daily limit of 1000. # The intervals between consecutive doses are 120 and 240, both at least 120 minutes apart. print(is_valid_dosage([(60, 300), (180, 100), (420, 250)], 1000, 120)) # Output: True # Example 2: # Total dosage is 300 + 100 + 700 = 1100 which exceeds the max daily limit of 1000. print(is_valid_dosage([(60, 300), (180, 100), (420, 700)], 1000, 120)) # Output: False # Example 3: # Total dosage is 300 + 100 = 400 which is within the max daily limit of 600. # The interval between doses is 60 which is less than the required 120 minutes. print(is_valid_dosage([(60, 300), (120, 100)], 600, 120)) # Output: False ``` # Additional Context - Sort the schedule by timing to efficiently check intervals and cumulative dosages. - Utilize simple arithmetic and list operations to ensure constraints are met.","solution":"def is_valid_dosage(schedule, max_daily_dosage, min_interval): Determines if the medication schedule is valid according to the given constraints. Parameters: schedule (list[tuple[int, int]]): List of tuples where each tuple contains two integers representing the timing (in minutes from midnight) and amount of a single dose. max_daily_dosage (int): Maximum allowable dosage per day. min_interval (int): Minimum allowable interval (in minutes) between any two doses. Returns: bool: True if the schedule is valid, False otherwise. # Sort the schedule by timing schedule.sort(key=lambda x: x[0]) total_dosage = 0 previous_time = None for i, (time, dosage) in enumerate(schedule): total_dosage += dosage if total_dosage > max_daily_dosage: return False if previous_time is not None and time - previous_time < min_interval: return False previous_time = time return True"},{"question":"# Problem Statement You are required to implement a function that generates a list of prime factors for a given number. The input will be a positive integer, and the function should return a list of all prime factors in ascending order. # Detailed Instructions * **Function Name**: `prime_factors` * **Input**: - `n` - a positive integer representing the number to be factored. * **Output**: - Returns a list of integers which are the prime factors of `n`. # Requirements 1. If `n` is 1, return an empty list, since 1 has no prime factors. 2. The factors should be calculated such that each factor appears as many times as it divides the number. # Examples ```python >>> prime_factors(28) [2, 2, 7] >>> prime_factors(13) [13] >>> prime_factors(1) [] >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(100) [2, 2, 5, 5] ``` # Constraints * `1 <= n <= 10**6` # Performance Requirements * The function should be efficient in computing the prime factors and must operate within a reasonable time for the upper constraints. Good luck!","solution":"def prime_factors(n): Returns a list of prime factors of the given number n in ascending order. factors = [] # Handle the smallest prime number, which is 2 while n % 2 == 0: factors.append(2) n = n // 2 # Handle odd factors from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n = n // factor factor += 2 # If n is still greater than 2, then n itself is a prime factor if n > 2: factors.append(n) return factors"},{"question":"Shape Coloring Algorithm Problem Statement You are given an `n x m` grid which represents a 2D plane. Some cells of the grid may contain shapes (marked with `1`) and others may be empty (marked with `0`). Write a function `shape_color(grid: List[List[int]]) -> int` that returns the maximum count of distinct shapes that can be colored on the grid, where a shape is a connected group of cells marked with `1`. Two cells are considered connected if they are adjacent horizontally or vertically. Shape coloring rules: 1. Each shape must have a unique color. 2. Cells marked with `0` are considered empty and are not part of any shape. Input * `grid (List[List[int]])`: A 2D array representing the grid (1 <= n, m <= 1000). Output * Return an integer representing the maximum count of distinct shapes. Constraints * The function should handle grids up to 1000x1000 efficiently. * You can assume at least one shape is present in the input grid. Examples ```python def shape_color(grid: List[List[int]]) -> int: # Your code here # Example usage grid1 = [[1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0], [0, 1, 1, 0, 0]] print(shape_color(grid1)) # Output: 3 grid2 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] print(shape_color(grid2)) # Output: 3 ``` Explanation For the first example: - There are three distinct shapes marked with 1. 1. First shape is four `1`s at the top left corner. 2. Second shape consists of four `1`s in the top right and bottom middle. 3. Third shape consists of two `1`s at the bottom left corner. For the second example: - Each `1` is isolated, hence there are three distinct shapes. - Each shape can be uniquely colored. Note * Efficiently handles traversal and marking of connected shapes. * Ensures traversal logic accurately counts distinct shapes without double-counting.","solution":"def shape_color(grid): n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < n and 0 <= j < m and not visited[i][j] and grid[i][j] == 1: visited[i][j] = True stack.extend([(i-1, j), (i+1, j), (i, j-1), (i, j+1)]) shape_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) shape_count += 1 return shape_count"},{"question":"# Task In this task, you need to implement the `kth_smallest_element` function to find the k-th smallest element in an unsorted array. Additionally, you will write a `test_kth_smallest_element` function to verify the correctness of your implementation with different test cases. # Requirements: * Implement `kth_smallest_element` to: - Utilize a min-heap or another efficient selection algorithm to determine the k-th smallest element. - Handle edge cases where the k-value is out of range (i.e., greater than the array length or less than 1). * Implement `test_kth_smallest_element` to: - Test the function with various arrays and k-values. - Print the k-th smallest element for each test case. # Input Format: - `input_array`: A list of integers. - `k`: An integer representing the k-th position you need to find. # Output Format: - Print the k-th smallest element if k is within the valid range. - Print an appropriate message if k is out of range. # Constraints: - The array will have up to (10^5) elements. - The elements of the array are within the range of ([-10^6, 10^6]). - The value of k is positive and can be any integer. # Example Usage: Given: ```python input_array = [7, 10, 4, 3, 20, 15] k = 3 ``` After running `kth_smallest_element` function, the output might be: ```python The 3rd smallest element is 7 ``` Given: ```python input_array = [7, 10, 4, 3, 20, 15] k = 0 ``` After running `kth_smallest_element` function, the output might be: ```python k is out of range ``` Implement the functions `kth_smallest_element` and `test_kth_smallest_element` to check if your solution works correctly.","solution":"import heapq def kth_smallest_element(input_array, k): Returns the k-th smallest element in the input_array. if k < 1 or k > len(input_array): return \\"k is out of range\\" return heapq.nsmallest(k, input_array)[-1]"},{"question":"# Coding Challenge **Scenario**: You are given an integer array representing the heights of a series of buildings lined up from left to right. The width of each building is 1. Your task is to calculate the largest rectangular area that can be formed in the skyline by combining adjacent buildings. **Function Signature**: ```python def largest_rectangle_area(heights: list[int]) -> int: pass ``` # Input * `heights` (list[int]): A list of integers representing the heights of buildings. # Output * (int): The area of the largest rectangle in the skyline. # Constraints * (1 leq text{len(heights)} leq 10^5) * (0 leq text{heights[i]} leq 10^4) # Examples **Example 1** * Input: ```python heights = [2, 1, 5, 6, 2, 3] ``` * Output: `10` - Explanation: The largest rectangle can be formed between the third and fourth buildings (heights 5 and 6), spanning a width of 2 and a height of 5. **Example 2** * Input: ```python heights = [2, 4] ``` * Output: `4` - Explanation: The largest rectangle is the second building itself with height 4 and width 1. # Guidelines: * Use a stack-based approach to efficiently compute the largest rectangle area in linear time. * Consider edge cases such as when the array is completely empty or contains a single element. * Ensure the solution can handle the upper constraint limits without exceeding time complexity of (O(N)).","solution":"def largest_rectangle_area(heights: list[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Scenario You have been assigned to develop a function that processes a list of transactions and aggregates the balance for each account. Each transaction contains an account id, an amount, and a type (deposit or withdrawal). # Task Write a Python function `aggregate_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]` that accepts a list of transactions and returns a dictionary with account ids as keys and their respective balances as values. # Requirements - Each transaction is represented as a dictionary with three keys: \\"account_id\\" (str), \\"amount\\" (float), and \\"type\\" (str, either \\"deposit\\" or \\"withdrawal\\"). - The function should aggregate the balances correctly by adding deposits and subtracting withdrawals. - Initialize any new account id with a balance of 0. - Handle potential invalid transaction types gracefully by skipping them. # Input and Output - **Input**: - `transactions` (List[Dict[str, Union[str, float]]]): A list of transaction dictionaries. - **Output**: A dictionary with account ids as keys and their final balances (float) as values. # Code Template ```python from typing import List, Dict, Union def aggregate_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: balances = {} for transaction in transactions: account_id = transaction[\\"account_id\\"] amount = transaction[\\"amount\\"] tr_type = transaction[\\"type\\"] if account_id not in balances: balances[account_id] = 0.0 if tr_type == \\"deposit\\": balances[account_id] += amount elif tr_type == \\"withdrawal\\": balances[account_id] -= amount else: continue # Skip invalid transaction types return balances # Example usage (do not include in submission): # transactions = [ # {\\"account_id\\": \\"A1\\", \\"amount\\": 100.0, \\"type\\": \\"deposit\\"}, # {\\"account_id\\": \\"A1\\", \\"amount\\": 50.0, \\"type\\": \\"withdrawal\\"}, # {\\"account_id\\": \\"A2\\", \\"amount\\": 200.0, \\"type\\": \\"deposit\\"} # ] # print(aggregate_balances(transactions)) # Output: {\'A1\': 50.0, \'A2\': 200.0} ``` **Constraints**: - The function should handle a large list of transactions efficiently. - Ensure proper validation and correct handling of corner cases like empty input lists or invalid data formats.","solution":"from typing import List, Dict, Union def aggregate_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: balances = {} for transaction in transactions: account_id = transaction[\\"account_id\\"] amount = transaction[\\"amount\\"] tr_type = transaction[\\"type\\"] if account_id not in balances: balances[account_id] = 0.0 if tr_type == \\"deposit\\": balances[account_id] += amount elif tr_type == \\"withdrawal\\": balances[account_id] -= amount else: continue # Skip invalid transaction types return balances"},{"question":"# Word Scramble Generator Scenario You are helping to develop an educational game that helps students improve their vocabulary and spelling skills. In this game, players are given a scrambled version of a word and must unscramble it to find the original word. Your task is to write a function that generates a set of scrambled words from a given list of words. The scrambling should be random, and the function should ensure that the scrambled word is different from the original word. Input and Output Requirements You need to implement the following function: 1. **`scramble_words(word_list: list) -> dict`**: * **Input**: A list of words (strings), each consisting of lowercase alphabets only. * **Output**: A dictionary where the keys are the original words and the values are their scrambled counterparts. The scrambling should be accomplished such that the scrambled word is always different from the original word. Example Usage and Expected Results ```python assert scramble_words([\'apple\', \'banana\', \'cherry\']) != {\'apple\': \'apple\', \'banana\': \'banana\', \'cherry\': \'cherry\'} # The scrambled version will vary because it\'s random, but should be consistently different from the original. possible_scrambles = scramble_words([\'cat\', \'dog\', \'fish\']) assert \'cat\' in possible_scrambles assert \'dog\' in possible_scrambles assert \'fish\' in possible_scrambles scrambled_cat = possible_scrambles[\'cat\'] scrambled_dog = possible_scrambles[\'dog\'] scrambled_fish = possible_scrambles[\'fish\'] assert scrambled_cat != \'cat\' and sorted(scrambled_cat) == sorted(\'cat\') assert scrambled_dog != \'dog\' and sorted(scrambled_dog) == sorted(\'dog\') assert scrambled_fish != \'fish\' and sorted(scrambled_fish) == sorted(\'fish\') ``` Constraints * Each word in the input list will only contain lowercase alphabets and have a length between 3 and 15 characters. * No word will be an empty string. * Ensure that the scrambled version of a word is always a valid permutation that differs from the original. * Use randomness responsibly to ensure variety in the scrambled words without creating identical mappings. This assessment will test your ability to apply list and string manipulation techniques, as well as ensure proper randomization and usage of data structures in Python.","solution":"import random def scramble_words(word_list): Takes a list of words and returns a dictionary where each word is mapped to a scrambled version of itself. The scrambled version will always be different from the original word. scrambled_dict = {} for word in word_list: scrambled = list(word) while True: random.shuffle(scrambled) scrambled_word = \'\'.join(scrambled) if scrambled_word != word: scrambled_dict[word] = scrambled_word break return scrambled_dict"},{"question":"# Problem Statement: You are required to implement a **Version-Controlled Array**. This data structure allows you to perform point updates on an array of integers and query the value of an element at any version of the array. Each update creates a new version, and queries should be able to retrieve the value at a specific version. Function Signatures: 1. `__init__(self, size: int) -> None`: Initialize the Version-Controlled Array with the given size, where all elements are initially 0. 2. `update(self, index: int, value: int) -> None`: Update the array at the given index to the given value, creating a new version with this update. 3. `query(self, version: int, index: int) -> int`: Return the value at the given index in the specified version of the array. Constraints: - The size of the array `N` will be between `1` and `10^5`. - The value of each element `arr[i]` will be between `-10^9` and `10^9`. - There will be at most `10^5` operations (combined update and query calls). - The version number `version` will be between `0` and the current version number inclusive. Example: ```python >>> vca = VersionControlledArray(5) >>> vca.query(0, 3) 0 >>> vca.update(3, 100) >>> vca.query(1, 3) 100 >>> vca.update(0, 50) >>> vca.query(0, 0) 0 >>> vca.query(2, 0) 50 >>> vca.update(4, 200) >>> vca.query(2, 4) 0 >>> vca.query(3, 4) 200 >>> vca.update(4, 20) >>> vca.query(4, 4) 20 >>> vca.query(3, 4) 200 ``` # Implementation: You are required to implement the `VersionControlledArray` class to meet the given specifications. Pay special attention to maintaining the immutability of versions and ensuring the efficiency of your implementation.","solution":"class VersionControlledArray: def __init__(self, size: int) -> None: self.versions = [[0] * size] # Initialize with one version where all elements are 0 self.size = size def update(self, index: int, value: int) -> None: new_version = self.versions[-1][:] # Create a copy of the latest version new_version[index] = value # Update the value at the specified index self.versions.append(new_version) # Append the new version to the list def query(self, version: int, index: int) -> int: return self.versions[version][index] # Return the value at the specified version and index"},{"question":"# Problem Description A team of developers is working on a project, and they need to ensure that all their Python function names follow the PEP 8 standard, which mandates that function names should be written in snake_case. You need to write a function that takes a list of function names in camelCase and converts them to snake_case. # Function Signature ```python def convert_to_snake_case(function_names: list) -> list: ``` # Input * `function_names` (list of str): A list of function names following the camelCase convention. # Output * (list of str): A list of function names converted to the snake_case convention. # Constraints * The number of function names, `n`, will be in the range [1, 10^4]. * Each function name will only contain lowercase and uppercase English letters and will be between 1 and 30 characters long. * Function names will not contain any leading or trailing spaces. # Example Cases Example 1: ```python function_names = [\\"getUserName\\", \\"calculateInterest\\", \\"isPalindrome\\"] output = [\\"get_user_name\\", \\"calculate_interest\\", \\"is_palindrome\\"] ``` Example 2: ```python function_names = [\\"convertToSnakeCase\\", \\"validateData\\", \\"printAllResults\\"] output = [\\"convert_to_snake_case\\", \\"validate_data\\", \\"print_all_results\\"] ``` Example 3: ```python function_names = [\\"findMaxValue\\", \\"mergeSortedArrays\\", \\"binarySearch\\"] output = [\\"find_max_value\\", \\"merge_sorted_arrays\\", \\"binary_search\\"] ``` # Additional Information 1. You can use regular expressions (regex) to identify the camelCase patterns and perform the conversion to snake_case. 2. The solution should efficiently handle the maximum input size within a reasonable time frame. 3. Ensure to maintain the integrity of the function names, avoiding any misinterpretation of special cases.","solution":"import re def convert_to_snake_case(function_names: list) -> list: Converts a list of function names from camelCase to snake_case. Args: function_names (list of str): A list of function names in camelCase. Returns: list of str: A list of function names converted to snake_case. snake_case_functions = [] for name in function_names: # Convert camelCase to snake_case using regex snake_name = re.sub(\'([A-Z])\', r\'_1\', name).lower() snake_case_functions.append(snake_name) return snake_case_functions"},{"question":"# Scenario You are developing a logistics management system that involves the optimization of delivery routes for trucks. Each truck has a limited capacity, and every delivery consists of a varying number of packages, each with a specific weight. Your system needs to efficiently allocate deliveries to trucks such that no truck is overloaded and the number of trucks used is minimized. # Question Implement an efficient algorithm to allocate deliveries to a minimum number of trucks based on their capacity limitations. Given the weight limit of each truck and a list of package weights, return the minimum number of trucks required to carry all packages without exceeding the weight limit of any truck. Requirements 1. Implement the `min_number_of_trucks(weights: List[int], truck_capacity: int) -> int` function. 2. The input list `weights` contains `n` integers where each integer represents the weight of a package. 3. The `truck_capacity` is an integer representing the maximum weight a truck can carry. 4. Return the minimum number of trucks required. Example ```python # Define package weights and truck capacity weights = [10, 20, 30, 40, 50] # Package weights truck_capacity = 70 # Maximum weight a truck can carry # Perform allocation to find the minimum number of trucks required num_trucks = min_number_of_trucks(weights, truck_capacity) # Outputs print(f\\"Minimum number of trucks required: {num_trucks}\\") ``` # Constraints and Performance - `1 <= n <= 1000` - `1 <= weights[i] <= 1000` for `0 <= i < n` - `1 <= truck_capacity <= 10000` - Aim to minimize the number of trucks used while ensuring that no truck is overloaded. The solution should consider efficient allocation strategies which may include sorting the packages and using the first-fit or other heuristic methods to optimize the allocation process. --- This question requires a similar level of cognitive and technical skills as the provided KD-Tree nearest neighbor search question, including understanding of algorithms, optimization strategies, and problem-solving abilities.","solution":"from typing import List def min_number_of_trucks(weights: List[int], truck_capacity: int) -> int: Returns the minimum number of trucks required to carry all packages without exceeding the weight limit of any truck. # Sort the weights in decreasing order to apply First-Fit Decreasing (FFD) heuristic weights.sort(reverse=True) # List to track the remaining capacity of each truck trucks = [] for weight in weights: placed = False for i in range(len(trucks)): if trucks[i] >= weight: trucks[i] -= weight placed = True break if not placed: # Need a new truck trucks.append(truck_capacity - weight) return len(trucks)"},{"question":"# Problem Statement **Context**: You have been tasked with developing a system that can evaluate expressions written in a custom postfix notation. Postfix notation, also known as Reverse Polish Notation (RPN), is a mathematical notation in which every operator follows all of its operands. It eliminates the need for parentheses that are required by infix notation. For example, the postfix expression for the infix expression \\"3 + 4 * 2 / (1 - 5)^2\\" is \\"3 4 2 * 1 5 - 2 ^ / +\\". Your task is to handle basic arithmetic operations which include addition, subtraction, multiplication, division, and exponentiation. **Task**: Implement the `evaluate_postfix_expression` function which takes a postfix expression as a string and evaluates it to return the result as a float. # Function Signature ```python def evaluate_postfix_expression(expression: str) -> float: pass ``` # Input - `expression`: A string containing a postfix expression (1 ≤ len(expression) ≤ 10^4). # Output - A float representing the evaluated result of the postfix expression. # Constraints - The postfix expression contains only valid arithmetic operators `+`, `-`, `*`, `/`, and `^`. - Operands are always non-negative integers and the result won\'t exceed the limitations of a float. - The expression will be space-separated. # Example ```python evaluate_postfix_expression(\\"3 4 2 * 1 5 - 2 ^ / +\\") # Output: 1.6 evaluate_postfix_expression(\\"6 3 2 ^ / 5 +\\") # Output: 2.5 ``` **Hint**: You can use a stack to evaluate the postfix expression. Push operands on the stack and pop when an operator is encountered for evaluation, then push the result back onto the stack.","solution":"def evaluate_postfix_expression(expression: str) -> float: from math import pow def apply_operation(operand1, operand2, operator): if operator == \'+\': return operand1 + operand2 elif operator == \'-\': return operand1 - operand2 elif operator == \'*\': return operand1 * operand2 elif operator == \'/\': return operand1 / operand2 elif operator == \'^\': return pow(operand1, operand2) else: raise ValueError(f\\"Invalid operator: {operator}\\") stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(float(token)) else: operand2 = stack.pop() operand1 = stack.pop() result = apply_operation(operand1, operand2, token) stack.append(result) return stack[0]"},{"question":"# Scenario You are developing a system to manage and analyze sales data for an online store. Your goal is to implement features that allow adding sales records, retrieving the highest sale, calculating the average sale, and filtering sales based on specific criteria. # Task Description Implement a `SalesManager` class that should provide the following functionalities: 1. Add a new sales record. 2. Retrieve the highest sale. 3. Calculate the average sale. 4. Retrieve all sales records that exceed a certain amount. # Input and Output Formats `SalesManager` class should have the following methods: - `add_sale(amount: float)`: Adds a new sales record with the given amount. - `get_highest_sale() -> float`: Returns the amount of the highest sale. - `get_average_sale() -> float`: Returns the average amount of all sales. - `filter_sales(min_amount: float) -> List[float]`: Returns a list of sales records where each sale amount exceeds `min_amount`. # Constraints - Sales amounts are positive floating-point numbers. - The number of sales records (`n`) will not exceed (10^5). # Example ```python manager = SalesManager() manager.add_sale(100.0) manager.add_sale(250.5) manager.add_sale(75.0) assert manager.get_highest_sale() == 250.5 assert manager.get_average_sale() == 141.83333333333334 assert manager.filter_sales(80.0) == [100.0, 250.5] manager.add_sale(300.0) assert manager.get_highest_sale() == 300.0 ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"class SalesManager: def __init__(self): self.sales = [] def add_sale(self, amount: float): self.sales.append(amount) def get_highest_sale(self) -> float: if not self.sales: return 0.0 return max(self.sales) def get_average_sale(self) -> float: if not self.sales: return 0.0 return sum(self.sales) / len(self.sales) def filter_sales(self, min_amount: float): return [sale for sale in self.sales if sale > min_amount]"},{"question":"# Coffee Break Scheduler You are assigned the task of improving the scheduling system for organizing regular coffee breaks within a company. Each employee has a preferred time slot during which they would like to take a break. The goal is to ensure that no two employees are scheduled for a break at the same time. Problem Statement You need to write a function that schedules coffee breaks efficiently, ensuring no overlap between any two employees\' breaks. # Function Signature ```python def schedule_coffee_breaks(employee_preferences): Determine a non-overlapping coffee break schedule for employees based on their preferred time slots. :param employee_preferences: Dictionary where keys are employee names and values are lists representing their preferred time slots. :return: A dictionary where keys are employee names and values are assigned coffee break slots. pass ``` # Requirements 1. **Function Implementation**: Implement the `schedule_coffee_breaks` function. It should take a dictionary with employee preferences and return a dictionary with assigned coffee break slots. 2. **No Overlaps**: Ensure that no two employees are scheduled for a coffee break at the same time. 3. **Constraints**: If it is not possible to assign a non-overlapping break for an employee, return `\\"Not Possible\\"` for that employee. 4. **Preferences Handling**: Consider the initial preferences of employees and try to assign a break from their preferred slots wherever feasible. # Input - `employee_preferences`: A dictionary where keys are employee names (strings) and values are lists of their preferred time slots (strings). Example Input ```python employee_preferences = { \\"Alice\\": [\\"10:00-10:30\\", \\"11:00-11:30\\"], \\"Bob\\": [\\"10:00-10:30\\", \\"11:00-11:30\\"], \\"Charlie\\": [\\"11:00-11:30\\"], \\"David\\": [\\"10:30-11:00\\"] } ``` # Output - Return a dictionary where each key is an employee name and the value is the assigned coffee break slot or \\"Not Possible\\". Example Output ```python { \\"Alice\\": \\"10:00-10:30\\", \\"Bob\\": \\"11:00-11:30\\", \\"Charlie\\": \\"Not Possible\\", \\"David\\": \\"10:30-11:00\\" } ``` # Constraints - Assume there are no more than 50 employees. - The time slots are in 30-minute increments between \\"09:00\\" and \\"18:00\\". - The time slots are in the format \\"HH:MM-HH:MM\\". # Note - Implement an efficient scheduling algorithm that respects employee preferences and minimizes unsatisfied employees. - If multiple valid schedules are possible, any correct and non-overlapping assignment will be accepted.","solution":"def schedule_coffee_breaks(employee_preferences): Determine a non-overlapping coffee break schedule for employees based on their preferred time slots. :param employee_preferences: Dictionary where keys are employee names and values are lists representing their preferred time slots. :return: A dictionary where keys are employee names and values are assigned coffee break slots. assigned_slots = {} used_slots = set() # Iterate through each employee and their preferences for employee, preferences in employee_preferences.items(): assigned = False for slot in preferences: if slot not in used_slots: assigned_slots[employee] = slot used_slots.add(slot) assigned = True break if not assigned: assigned_slots[employee] = \\"Not Possible\\" return assigned_slots"},{"question":"# Coding Assessment Question **Background**: Sorting algorithms are fundamental in computer science, often serving as building blocks for more complex algorithms. One such algorithm is the \\"Merge Sort\\", a divide-and-conquer algorithm that splits the array into halves, sorts them recursively, and then merges the sorted halves. **Task**: Write a function `merge_sort` in Python that implements the Merge Sort algorithm, taking a list of integers as input and returning the sorted list. # Requirements: 1. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - `arr` (List[int]): A list of integers to be sorted. 3. **Output**: - `List[int]`: The sorted list of integers. 4. **Constraints**: - The length of the input list can be up to 1000 elements. 5. **Performance**: - The solution should have an average time complexity of O(n log n) and space complexity of O(n). # Example: ```python arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(arr)) # Expected output: [3, 9, 10, 27, 38, 43, 82] arr = [5, 1, 4, 2, 8] print(merge_sort(arr)) # Expected output: [1, 2, 4, 5, 8] ``` # Notes: - Emphasize the clarity and correctness of your implementation. - Write comprehensive test cases to cover various scenarios, such as empty lists, already sorted lists, and lists with duplicate elements.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: This function implements the Merge Sort algorithm to sort a list of integers. if len(arr) <= 1: return arr # Divide the array into two halves middle = len(arr) // 2 left_half = merge_sort(arr[:middle]) right_half = merge_sort(arr[middle:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: This helper function merges two sorted lists into a single sorted list. sorted_list = [] i = j = 0 # Loop through both lists and append the smaller elements to the sorted list while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append any remaining elements in the left list while i < len(left): sorted_list.append(left[i]) i += 1 # Append any remaining elements in the right list while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Matrix Diagonal Traversal You are provided with an `m x n` matrix, where each cell contains an integer. Your goal is to traverse the matrix diagonally and collect all elements in a specific order. Starting from the top-left element (first element of the first row), the traversal should proceed down the diagonals from the first row to the last column, and collect elements in those diagonals. Write a function `diagonal_traversal(matrix: List[List[int]]) -> List[int]` that returns the elements of the matrix in the specified diagonal order. # Function Signature ```python def diagonal_traversal(matrix: List[List[int]]) -> List[int]: ``` # Input * `matrix` (List[List[int]]): A 2D list representing the m x n matrix, where each element is an integer. * Assume 1 <= m, n <= 1000 and each element in the matrix is between -10^5 and 10^5. # Output * Returns a list of integers representing the elements of the matrix traversed in the diagonal order. # Constraints * The matrix will be non-empty and contains integers. # Example ```python assert diagonal_traversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 4, 3, 5, 7, 6, 8, 9] assert diagonal_traversal([ [1, 2], [3, 4], [5, 6] ]) == [1, 2, 3, 4, 5, 6] ``` # Explanation For the first example: * The 1st diagonal contains [1]. * The 2nd diagonal contains [2, 4]. * The 3rd diagonal contains [3, 5, 7]. * The 4th diagonal contains [6, 8]. * The 5th diagonal contains [9]. Thus, the output list is [1, 2, 4, 3, 5, 7, 6, 8, 9]. For the second example: * The 1st diagonal contains [1]. * The 2nd diagonal contains [2, 3]. * The 3rd diagonal contains [4, 5]. * The 4th diagonal contains [6]. Thus, the output list is [1, 2, 3, 4, 5, 6].","solution":"from typing import List def diagonal_traversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for diag in range(m + n - 1): if diag < n: i, j = 0, diag else: i, j = diag - n + 1, n - 1 while i < m and j >= 0: result.append(matrix[i][j]) i += 1 j -= 1 return result"},{"question":"# Word Morphing Sequence You are given a start word, an end word, and a dictionary of valid words. Your task is to find the shortest transformation sequence from the start word to the end word such that only one letter can be changed at a time, and each transformed word must exist in the dictionary. Return the sequence of words that represents this transformation. If there are multiple transformation sequences of the same length, you may return any of them. If no such transformation sequence exists, return an empty list. **Function Signature**: ```python def word_morphing_sequence(start: str, end: str, word_dict: set) -> List[str]: pass ``` # Description: - **Input**: - `start` (str): The starting word. - `end` (str): The ending word. - `word_dict` (set of str): A set containing all valid words. - **Output**: - A list of strings representing the transformation sequence (including the start and end words). # Constraints: - All given words have the same length. - Only one letter can be changed at a time. - The transformed word must exist in the given dictionary. - Ensure the function is optimized to handle word dictionaries up to 5,000 words in length. # Examples: 1. `word_morphing_sequence(\\"hit\\", \\"cog\\", {\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"})` should return `[\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"]`. 2. `word_morphing_sequence(\\"hit\\", \\"cog\\", {\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"})` should return `[]`. # Notes: - The problem is essentially a shortest path problem in an unweighted graph where each word is a node and edges exist between words that differ by one letter. - It is recommended to use Breadth-First Search (BFS) for finding the shortest transformation sequence. - Consider edge cases where start or end words are not in the dictionary, or transformation is not possible.","solution":"from typing import List, Set, Tuple from collections import deque def word_morphing_sequence(start: str, end: str, word_dict: Set[str]) -> List[str]: if start == end: return [start] if end not in word_dict: return [] word_dict.add(start) word_dict.add(end) queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end: return path + [end] if next_word in word_dict and next_word not in visited: visited.add(next_word) queue.append((next_word, path + [next_word])) return []"},{"question":"# Question: You are developing an application that involves processing dates and calculating differences in days between two dates. Write a function to achieve this. Task: 1. **Function: `calculate_date_difference(date1: str, date2: str) -> int`** - Input: - `date1`: A string representing the first date in the format \'YYYY-MM-DD\'. - `date2`: A string representing the second date in the format \'YYYY-MM-DD\'. - Output: - An integer representing the number of days between `date1` and `date2`. - Implementation details: - Ensure the function correctly calculates the difference in days, regardless of the order of `date1` and `date2`. - Handle any potential edge cases such as leap years, month lengths, and different years. Examples: ```python calculate_date_difference(\'2023-03-31\', \'2023-04-02\') # Output: 2 calculate_date_difference(\'2023-01-01\', \'2022-12-25\') # Output: 7 ``` Ensure your solution is efficient, correctly handles edge cases, and achieves the expected output format.","solution":"from datetime import datetime def calculate_date_difference(date1: str, date2: str) -> int: Calculate the difference in days between two dates. Parameters: - date1: str : First date in \'YYYY-MM-DD\' format - date2: str : Second date in \'YYYY-MM-DD\' format Returns: - int : Number of days between date1 and date2 date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) return abs((d2 - d1).days)"},{"question":"# Coding Assessment: Implementing K-Nearest Neighbors (KNN) **Objective**: Implement the K-Nearest Neighbors (KNN) algorithm to classify a set of instances. This will demonstrate your understanding of distance measures and classification based on neighborhood voting. # Problem Statement Given a series of steps and predefined functions for KNN, implement additional functionality to further classify unknown instances using the trained KNN model. Your task is to complete the KNN process, ensuring proper distance calculations and neighbor voting. # Scenario A research lab wants to use KNN to categorize their sample data into different specimen types. They have historical data with known classifications. Your role is to implement the classification model and use it to predict new specimen types given their features. # Requirements 1. **Function to Calculate Euclidean Distance**: * Input: Two points represented as lists of feature values. * Output: Euclidean distance between the two points. 2. **Function to Fit KNN Model**: * Input: `features` (2D list of feature values), `labels` (list of corresponding labels). * Output: A dictionary containing the training features and labels. 3. **Function to Predict Instances**: * Input: `unknown_features` (2D list of feature values of unknown instances), `model` (Fitted model dictionary from step 2), `k` (number of nearest neighbors to consider). * Output: List of predicted classes for the unknown instances. 4. **Utility Function to Calculate Accuracy**: * Input: `actual_labels` (list of actual classes), `predicted_labels` (list of predicted classes). * Output: Accuracy percentage. # Input and Output Format **Function 1: calculate_euclidean_distance** ```python def calculate_euclidean_distance(point1: list[float], point2: list[float]) -> float: pass ``` **Function 2: fit_knn_model** ```python def fit_knn_model(features: list[list[float]], labels: list[int]) -> dict: pass ``` **Function 3: predict_instances** ```python def predict_instances(unknown_features: list[list[float]], model: dict, k: int) -> list[int]: pass ``` **Function 4: calculate_accuracy** ```python def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: pass ``` # Constraints * Assume that all features are numeric and standardized (mean of 0 and standard deviation of 1). * The value of `k` will always be a positive integer and less than or equal to the number of instances in the training set. * Ties in neighbor voting should be resolved by choosing the class with the smallest label value. # Example ```python # Example data features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], ] labels = [0, 0, 1, 1] # Fit the KNN model model = fit_knn_model(features, labels) # New instances unknown_features = [ [1.2, 2.1], [6.0, 7.5], ] # Predict using the model with k = 3 predicted = predict_instances(unknown_features, model, 3) print(predicted) # Expected output: [0, 1] # Calculate accuracy (assuming actual labels are provided for testing) actual_labels = [0, 1] accuracy = calculate_accuracy(actual_labels, predicted) print(accuracy) # Expected output: 100.0 ``` * **Edge Cases**: * Handle cases where there are ties in the nearest neighbor votes. * Ensure the algorithm can handle situations where the number of instances is very small. # Submission Complete the missing functions to calculate Euclidean distance, fit the KNN model, predict classes for unknown instances, and calculate the accuracy of predictions. Ensure your solution passes provided examples and edge cases effectively.","solution":"import math from collections import Counter def calculate_euclidean_distance(point1: list[float], point2: list[float]) -> float: Calculate the Euclidean distance between two points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def fit_knn_model(features: list[list[float]], labels: list[int]) -> dict: Fit the KNN model with the given features and labels. return {\'features\': features, \'labels\': labels} def predict_instances(unknown_features: list[list[float]], model: dict, k: int) -> list[int]: Predict the class of instances using the KNN model. def get_neighbors(training_features, training_labels, test_instance, k): distances = [] for feature, label in zip(training_features, training_labels): distance = calculate_euclidean_distance(test_instance, feature) distances.append((label, distance)) distances.sort(key=lambda x: x[1]) return [label for label, _ in distances[:k]] training_features = model[\'features\'] training_labels = model[\'labels\'] predictions = [] for unknown in unknown_features: neighbors = get_neighbors(training_features, training_labels, unknown, k) most_common = Counter(neighbors).most_common(1)[0][0] predictions.append(most_common) return predictions def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: Calculate the accuracy of the predictions. correct = sum(1 for actual, predicted in zip(actual_labels, predicted_labels) if actual == predicted) return (correct / len(actual_labels)) * 100"},{"question":"# Sum of Squared Differences Write a function that calculates the sum of squared differences between two lists of equal length. The function should return the sum of the squared differences of corresponding elements. Function Signature ```python def sum_squared_differences(list1: list, list2: list) -> int: ``` Inputs - `list1` (list of int): The first list of integers. - `list2` (list of int): The second list of integers, must be of the same length as `list1`. Output - (int): The sum of the squared differences of corresponding elements from the two lists. Constraints - Both input lists can have a minimum length of 1. - The length of `list1` and `list2` will be the same. - Elements of both lists will be non-negative integers. Example Usage ```python >>> sum_squared_differences([1, 2, 3], [4, 5, 6]) 27 >>> sum_squared_differences([10, 20, 30], [10, 20, 30]) 0 >>> sum_squared_differences([0, 0, 0], [1, 2, 3]) 14 ``` Explanation Write a function that: 1. Reads in the two input lists. 2. Iterates through the lists and calculates the squared difference for each pair of corresponding elements. 3. Sums up all the squared differences. 4. Returns the accumulated sum. Each squared difference is calculated as ( (list1[i] - list2[i])^2 ), and the function should efficiently handle lists of the specified characteristics. Ensure your solution handles all specified edge cases and is optimized for performance.","solution":"def sum_squared_differences(list1, list2): Returns the sum of the squared differences between two lists of equal length. return sum((a - b) ** 2 for a, b in zip(list1, list2))"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a software module to keep track of the version control history of files in a code repository. Specifically, your job is to implement a system that can quickly identify the earliest common ancestor (or common commit) of two given commits in the repository. This is crucial, for instance, when resolving merge conflicts. To achieve this, you will use the Binary Lifting technique, which allows efficient querying of the Lowest Common Ancestor (LCA) in a tree. Task Implement the `build_binary_lifting_table` and `find_earliest_common_ancestor` functions to construct a Binary Lifting table for a given repository commit history and efficiently retrieve the earliest common ancestor of two commits. Function Definitions 1. **build_binary_lifting_table**: * **Input**: - An integer `n` representing the number of commits. - A list of pairs where each pair `(c1, c2)` indicates that `c2` is a direct parent of `c1`. * **Output**: A 2D list representing the constructed Binary Lifting Table. * **Constraints**: - The input list of pairs is non-empty. - The number of commits `n` is at least 1 and may be up to (10^5). - Each commit is referenced by a unique integer. - The relationships describe a valid tree structure without cycles. 2. **find_earliest_common_ancestor**: * **Input**: - A Binary Lifting Table generated from `build_binary_lifting_table`. - Two integers (`commit1`, `commit2`) representing the commits for the query. * **Output**: An integer representing the earliest common ancestor commit. * **Constraints**: - Ensure both commits are valid and exist within the bounds of the repository. Sample Usage ```python binary_lifting_table = build_binary_lifting_table(7, [(1, 0), (2, 0), (3, 1), (4, 1), (5, 2), (6, 2)]) assert find_earliest_common_ancestor(binary_lifting_table, 3, 4) == 1 assert find_earliest_common_ancestor(binary_lifting_table, 3, 5) == 0 binary_lifting_table = build_binary_lifting_table(5, [(2, 1), (3, 1), (4, 2)]) assert find_earliest_common_ancestor(binary_lifting_table, 3, 4) == 1 assert find_earliest_common_ancestor(binary_lifting_table, 2, 4) == 2 ``` # Requirements * Implement the core algorithm as described. * Validate inputs to ensure error handling for edge cases, such as invalid commit references and non-rooted trees. * Use efficient methods to ensure performance scales well with the number of commits. Constraints * Maximum number of commits ( n leq 10^5 ). * Ensure your implementation can handle both small and large trees effectively.","solution":"import math def build_binary_lifting_table(n, parent_pairs): Constructs the Binary Lifting Table for a given list of parent-child relationships. Parameters: n (int): Number of commits. parent_pairs (List[Tuple[int, int]]): Parent-child relationships. Returns: List[List[int]]: Binary Lifting Table. LOG = math.ceil(math.log2(n)) parent = [-1] * n children = [[] for _ in range(n)] # Construct the tree for c1, c2 in parent_pairs: parent[c1] = c2 children[c2].append(c1) depth = [-1] * n binary_lifting = [[-1] * (LOG + 1) for _ in range(n)] # Depth-first search to fill depth and binary lifting table def dfs(node, par): depth[node] = depth[par] + 1 if par != -1 else 0 binary_lifting[node][0] = par for i in range(1, LOG + 1): if binary_lifting[node][i - 1] != -1: binary_lifting[node][i] = binary_lifting[binary_lifting[node][i - 1]][i - 1] else: binary_lifting[node][i] = -1 for child in children[node]: if child != par: dfs(child, node) # Assume a single root in the tree for i in range(n): if parent[i] == -1: root = i break dfs(root, -1) return binary_lifting, depth def find_earliest_common_ancestor(binary_lifting, depth, commit1, commit2): Finds the earliest common ancestor of two commits using the Binary Lifting Table. Parameters: binary_lifting (List[List[int]]): Binary Lifting Table. depth (List[int]): Depth of each node in the tree. commit1 (int): First commit. commit2 (int): Second commit. Returns: int: The earliest common ancestor commit. if depth[commit1] < depth[commit2]: commit1, commit2 = commit2, commit1 LOG = len(binary_lifting[0]) - 1 # Lift commit1 to the same depth as commit2 for i in range(LOG, -1, -1): if depth[commit1] - (1 << i) >= depth[commit2]: commit1 = binary_lifting[commit1][i] if commit1 == commit2: return commit1 for i in range(LOG, -1, -1): if binary_lifting[commit1][i] != -1 and binary_lifting[commit1][i] != binary_lifting[commit2][i]: commit1 = binary_lifting[commit1][i] commit2 = binary_lifting[commit2][i] return binary_lifting[commit1][0]"},{"question":"# Problem Statement You are required to develop a new geometric class called `Rectangle`, which represents a rectangle on a 2D surface. A `Rectangle` is a specific type of `Polygon` and should adhere to the following requirements: 1. **Initialization**: A rectangle is initialized with two sides: width and height. 2. **Area Calculation**: Implement a method to calculate the area of the rectangle. 3. **Perimeter Calculation**: Implement a method to calculate the perimeter of the rectangle. 4. **Error Handling**: Ensure that invalid rectangle configurations (where sides are non-positive values) are caught and appropriate errors are raised. # Implementation Details - Create a `Rectangle` class that: - Inherits from the `Polygon` class. - Ensures the sides are valid positive values. - Implement the `area` and `perimeter` methods. # Input & Output Formats - **Input**: The rectangle will be initialized with two sides. - `Rectangle(width: Side, height: Side)` - **Output**: - `area()` method should return a float representing the area of the rectangle. - `perimeter()` method should return a float representing the perimeter of the rectangle. # Constraints - Sides must be positive numeric values. # Example ```python # Assume the Side class and other dependencies are implemented as defined in the provided snippets. r = Rectangle(Side(4), Side(5)) print(r.area()) # Expected output: 20.0 print(r.perimeter()) # Expected output: 18.0 r_invalid = Rectangle(Side(0), Side(5)) # Should raise ValueError: Invalid sides for a rectangle. ``` # Performance Requirements - Ensure the implementation is efficient in terms of validating sides and computing the area and perimeter. - Raise appropriate errors for invalid input.","solution":"class Polygon: pass class Rectangle(Polygon): def __init__(self, width, height): if width <= 0 or height <= 0: raise ValueError(\\"Invalid sides for a rectangle. Both sides must be positive.\\") self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height)"},{"question":"# Coding Assessment Question Scenario A tech company is building a new inventory tracking system for their warehouse. The system must keep track of the quantities of various items over time. An essential feature of this system is the ability to efficiently find the maximum quantity of any item within specific time intervals. Task Write a class `InventoryTracker` that supports the following operations: 1. `add_item(name: str, quantity: int, time: int) -> None`: Adds a given quantity of an item at a specific time. 2. `max_quantity_between(start_time: int, end_time: int) -> int`: Returns the maximum quantity of any item within the given time interval `[start_time, end_time]`. Input * `name` is a string representing the item\'s name (1 <= len(name) <= 50). * `quantity` is a non-negative integer representing the quantity added. * `time` is a non-negative integer representing the time the item was added (1 <= time <= 10^9). * `start_time` and `end_time` are non-negative integers specifying the time interval to check the maximum quantity (1 <= start_time <= end_time <= 10^9). Output * The `max_quantity_between` method should return the maximum quantity of any item in the specified interval. Constraints * The system must handle up to 10^5 `add_item` operations. * The system must handle up to 10^5 `max_quantity_between` queries. Example ```python class InventoryTracker: def __init__(self): # Implement the initialization def add_item(self, name: str, quantity: int, time: int) -> None: # Implement add_item def max_quantity_between(self, start_time: int, end_time: int) -> int: # Implement max_quantity_between # Example Usage tracker = InventoryTracker() tracker.add_item(\\"item1\\", 50, 10) tracker.add_item(\\"item2\\", 20, 15) tracker.add_item(\\"item3\\", 35, 20) tracker.add_item(\\"item1\\", 75, 25) tracker.add_item(\\"item2\\", 40, 30) print(tracker.max_quantity_between(10, 20)) # Output: 50 print(tracker.max_quantity_between(15, 25)) # Output: 75 print(tracker.max_quantity_between(5, 40)) # Output: 75 ``` Additional Notes * The system should efficiently handle large volumes of data. * The implementation should consider edge cases like overlapping intervals and multiple updates for the same item. * The operations should ensure that the querying process is as optimized as possible to handle the upper limits of the constraints efficiently.","solution":"import bisect class InventoryTracker: def __init__(self): self.data = [] def add_item(self, name: str, quantity: int, time: int) -> None: bisect.insort(self.data, (time, quantity)) def max_quantity_between(self, start_time: int, end_time: int) -> int: left_index = bisect.bisect_left(self.data, (start_time, float(\'-inf\'))) right_index = bisect.bisect_right(self.data, (end_time, float(\'inf\'))) max_quantity = 0 for i in range(left_index, right_index): max_quantity = max(max_quantity, self.data[i][1]) return max_quantity"},{"question":"# Question: Implement a Custom List Class with Reversible Append Operation Your task is to design a custom list class named `ReversibleList` that supports standard list operations and introduces a reversible append operation. You will implement a method to append elements and another to reverse the last n append operations. **Function Signature:** ```python class ReversibleList: def __init__(self): self.data = [] self.history = [] def append(self, item: int) -> None: # Your code here def reverse_last_n_appends(self, n: int) -> None: # Your code here ``` # Input Format - The `append` method should accept a single integer `item`. - The `reverse_last_n_appends` method should accept a single integer `n`, representing the number of last append operations to be reversed. # Output Format After the `reverse_last_n_appends` operation, the list should reflect the state before the last `n` appended items were added. # Constraints - Append operations and their reversals should update the list accurately and efficiently. - Ensure `n` is a non-negative integer and it should be less than or equal to the number of append operations performed. # Example ```python rl = ReversibleList() rl.append(1) rl.append(2) rl.append(3) rl.append(4) assert rl.data == [1, 2, 3, 4] rl.reverse_last_n_appends(2) assert rl.data == [1, 2] ``` In the example, the first three append operations add elements `1`, `2`, and `3` to the list, and the fourth append adds `4`. The `reverse_last_n_appends(2)` method call removes the last two appended elements (`3` and `4`), leaving the list as `[1, 2]`. # Notes - Ensure the class handles edge cases, such as reversing more appends than available. - Maintain performance efficiency for both list operations and history tracking of append operations. - The list should dynamically adjust and correctly reflect append and reverse operations in all scenarios. This question tests students\' ability to manipulate data structures, implement custom classes, and handle operations\' state persistency.","solution":"class ReversibleList: def __init__(self): self.data = [] self.history = [] def append(self, item: int) -> None: self.data.append(item) self.history.append(item) def reverse_last_n_appends(self, n: int) -> None: if n > len(self.history): raise ValueError(\\"Cannot reverse more elements than have been appended\\") for _ in range(n): item = self.history.pop() self.data.remove(item)"},{"question":"# Question: Multi-threaded Matrix Multiplication You are tasked with implementing a multi-threaded approach to matrix multiplication. Matrix multiplication involves computing the product of two matrices, where each element of the resulting matrix is the dot product of a row from the first matrix and a column from the second matrix. The goal is to enhance the performance of this operation by using multiple threads to perform the computations in parallel. # Instructions: 1. Implement a function `multi_threaded_matrix_multiplication` that takes two matrices `A` and `B` and returns their product matrix `C`. 2. Use Python\'s `threading` module to create multiple threads so that parts of the computation can be carried out simultaneously. 3. Ensure that the function handles matrices of various sizes, including edge cases such as empty matrices or matrices with only one row or column. # Input * Two matrices `A` and `B`, represented as lists of lists of integers/floats. The dimensions of the matrices are such that the number of columns in `A` is equal to the number of rows in `B`. ```python A = [[a11, a12, ..., a1n], [a21, a22, ..., a2n], ... [am1, am2, ..., amn]] B = [[b11, b12, ..., b1p], [b21, b22, ..., b2p], ... [bn1, bn2, ..., bnp]] ``` # Output * A result matrix `C`, represented as a list of lists of integers/floats, where each element `c_ij` is computed as: ``` python C[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + ... + A[i][n]*B[n][j] ``` # Constraints * The dimensions of the input matrices are such that the product is well-defined. * Ensure that your solution handles large matrices efficiently using appropriate synchronization mechanisms where necessary. * The threading approach should not lead to race conditions or deadlocks. # Example ```python A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] print(multi_threaded_matrix_multiplication(A, B)) # Output: [[19, 22], [43, 50]] ``` Test your implementation with different types and sizes of matrices to ensure its correctness and efficiency.","solution":"import threading def multi_threaded_matrix_multiplication(A, B): Multiplies two matrices A and B using multiple threads. if not A or not B: return [] # Get the dimensions of the matrices num_rows_A, num_cols_A = len(A), len(A[0]) num_rows_B, num_cols_B = len(B), len(B[0]) # Initialize the result matrix with zeros C = [[0 for _ in range(num_cols_B)] for _ in range(num_rows_A)] def calculate_element(i, j): C[i][j] = sum(A[i][k] * B[k][j] for k in range(num_cols_A)) # Create a list to hold the threads threads = [] # Create and start a thread for each element in the result matrix for i in range(num_rows_A): for j in range(num_cols_B): thread = threading.Thread(target=calculate_element, args=(i, j)) threads.append(thread) thread.start() # Wait for all threads to complete for thread in threads: thread.join() return C"},{"question":"# Text-Based RPG Inventory System Problem Description: You are tasked with implementing an inventory management system for a text-based RPG game. The system should allow players to add items, remove items, and display an organized list of items currently in their inventory. Function Signatures: ```python def add_item(inventory: dict, item_name: str, quantity: int) -> dict: Adds a specified quantity of an item to the inventory. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to add. - quantity (int): The quantity of the item to add. Returns: - dict: The updated inventory. pass def remove_item(inventory: dict, item_name: str, quantity: int) -> dict: Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current amount, the item is removed completely from the inventory. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to remove. - quantity (int): The quantity of the item to remove. Returns: - dict: The updated inventory. pass def display_inventory(inventory: dict) -> None: Displays the current inventory in a readable format. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. Returns: - None: This function prints the inventory and does not return anything. pass ``` Input: - For `add_item`: - `inventory`: A dictionary representing the current inventory with item names as keys and quantities as values. - `item_name`: A string representing the name of the item to add. - `quantity`: An integer representing the quantity of the item to add. - For `remove_item`: - `inventory`: A dictionary representing the current inventory with item names as keys and quantities as values. - `item_name`: A string representing the name of the item to remove. - `quantity`: An integer representing the quantity of the item to remove. - For `display_inventory`: - `inventory`: A dictionary representing the current inventory with item names as keys and quantities as values. Output: - For `add_item` and `remove_item`: A dictionary representing the updated inventory. - For `display_inventory`: None (prints the inventory). Constraints: - Quantities must be non-negative integers. - If an attempt is made to remove more items than are present in the inventory, the item should be removed completely. - The inventory should be displayed in alphabetical order of item names. Example: ```python # Example usage of the functions. current_inventory = { \\"potion\\": 3, \\"elixir\\": 2, \\"mana crystal\\": 5 } # Add items current_inventory = add_item(current_inventory, \\"potion\\", 2) current_inventory = add_item(current_inventory, \\"herb\\", 4) # Remove items current_inventory = remove_item(current_inventory, \\"potion\\", 5) current_inventory = remove_item(current_inventory, \\"elixir\\", 1) # Display inventory display_inventory(current_inventory) ``` Output upon displaying inventory: ``` herb: 4 mana crystal: 5 potion: 0 ```","solution":"def add_item(inventory: dict, item_name: str, quantity: int) -> dict: Adds a specified quantity of an item to the inventory. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to add. - quantity (int): The quantity of the item to add. Returns: - dict: The updated inventory. if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity return inventory def remove_item(inventory: dict, item_name: str, quantity: int) -> dict: Removes a specified quantity of an item from the inventory. If the quantity to remove exceeds the current amount, the item is removed completely from the inventory. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. - item_name (str): The name of the item to remove. - quantity (int): The quantity of the item to remove. Returns: - dict: The updated inventory. if item_name in inventory: if inventory[item_name] <= quantity: del inventory[item_name] else: inventory[item_name] -= quantity return inventory def display_inventory(inventory: dict) -> None: Displays the current inventory in a readable format. Args: - inventory (dict): The player\'s current inventory, with item names as keys and quantities as values. Returns: - None: This function prints the inventory and does not return anything. for item in sorted(inventory): print(f\\"{item}: {inventory[item]}\\")"},{"question":"# Question: Implement a Recursive Quick Sort You need to implement the quick sort algorithm using recursion. Given a list of integers, return the list sorted in ascending order using a recursive quick sort. Function Signature ```python def recursive_quick_sort(arr: list[int]) -> list[int]: pass ``` Input * A list of integers called `arr`. Output * A list of integers sorted in ascending order. Constraints * The input list will have a length between 0 and 1000. * Elements in the list are between -10^6 and 10^6. * Sorting must be performed using a quick sort algorithm implemented recursively. Requirements * Ensure the provided function is recursive. * Avoid using built-in sorting functions. Example ```python print(recursive_quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Notes * Ensure to handle edge cases such as empty lists and lists with a single element. * Your solution should be efficient in terms of both time and space complexity. * Implementing the partition procedure effectively is crucial for this task.","solution":"def recursive_quick_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return recursive_quick_sort(left) + middle + recursive_quick_sort(right)"},{"question":"# Scenario You are developing a logging system for a web application where each log message is associated with multiple tags and timestamps. To efficiently query and filter log messages, you decide to create a class `LogSystem` that supports adding log entries and querying them based on timestamps and tags. # Task Implement the `LogSystem` class which supports adding log entries and querying log entries based on a given time range and optional tags. # Details 1. **Class `LogSystem` Implementation**: * Attributes and methods as mentioned in the task. * Essential methods: `add_log`, `query_logs`. 2. **Method `add_log(timestamp: str, message: str, tags: List[str])`**: * Adds a log entry with the given timestamp, message, and tags. * The `timestamp` should be in the format \\"YYYY-MM-DD HH:MM:SS\\". 3. **Method `query_logs(start_time: str, end_time: str, tags: Optional[List[str]] = None) -> List[str]`**: * Returns a list of log messages that fall within the provided time range. * If `tags` are provided, only include log messages that match all the given tags. * The `start_time` and `end_time` should be in the format \\"YYYY-MM-DD HH:MM:SS\\". # Input * `timestamp`: A string representing the time of the log message in the format \\"YYYY-MM-DD HH:MM:SS\\". * `message`: A string containing the log message. * `tags`: A list of strings representing the tags associated with the log message. * `start_time`: A string representing the start of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". * `end_time`: A string representing the end of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". * `tags` (optional): A list of strings representing the tags that the log messages must match to be included in the query result. # Output * `add_log`: No return value. * `query_logs`: A list of log messages (strings) that match the time range and, if provided, the tags. # Constraints * Ensure the `timestamp`, `start_time`, and `end_time` are properly formatted and are valid timestamps. * Handle edge cases where no log messages match the time range or tags. * Optimize for querying speed, especially when dealing with large numbers of log entries. # Example ```python # Initialize LogSystem log_system = LogSystem() # Add log entries log_system.add_log(\\"2023-10-01 12:00:00\\", \\"Server started\\", [\\"server\\", \\"start\\"]) log_system.add_log(\\"2023-10-01 12:01:00\\", \\"User login\\", [\\"user\\", \\"login\\"]) log_system.add_log(\\"2023-10-01 12:02:00\\", \\"User logout\\", [\\"user\\", \\"logout\\"]) log_system.add_log(\\"2023-10-01 12:03:00\\", \\"Server error\\", [\\"server\\", \\"error\\"]) # Query log entries print(log_system.query_logs(\\"2023-10-01 12:00:00\\", \\"2023-10-01 12:02:00\\")) # Expected output: [\\"Server started\\", \\"User login\\", \\"User logout\\"] print(log_system.query_logs(\\"2023-10-01 12:00:00\\", \\"2023-10-01 12:02:00\\", [\\"user\\"])) # Expected output: [\\"User login\\", \\"User logout\\"] print(log_system.query_logs(\\"2023-10-01 12:00:00\\", \\"2023-10-01 12:02:00\\", [\\"server\\"])) # Expected output: [\\"Server started\\"] ``` # Notes 1. Ensure to handle and report invalid input formats and types gracefully. 2. The class should maintain efficient storage and retrieval of log entries, considering potential large-scale data.","solution":"from typing import List, Optional from datetime import datetime class LogSystem: def __init__(self): self.logs = [] def add_log(self, timestamp: str, message: str, tags: List[str]): self.logs.append((timestamp, message, set(tags))) def query_logs(self, start_time: str, end_time: str, tags: Optional[List[str]] = None) -> List[str]: start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") result = [] for log in self.logs: log_time, message, log_tags = log log_dt = datetime.strptime(log_time, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= log_dt <= end_dt: if tags: if all(tag in log_tags for tag in tags): result.append(message) else: result.append(message) return result"},{"question":"# Question **Background**: You are working on an e-commerce platform, and one of your tasks is to implement a feature that helps in sorting products based on their prices. To optimize the sorting process, you have chosen to implement the Merge Sort algorithm. The Merge Sort algorithm is a comparison-based sorting technique based on the divide-and-conquer approach. **Task**: Write a function `merge_sort` that takes a list of prices and returns the list sorted in ascending order using the Merge Sort algorithm. **Function Signature**: ```python def merge_sort(prices: list[int]) -> list[int]: pass ``` **Input**: * `prices` (list of integers): A list of integers representing the prices of products. **Output**: * (list of integers): A list of integers representing the prices sorted in ascending order. **Constraints**: * The length of the input list, ( n ), will be ( 1 leq n leq 10^5 ). * The prices can range from ( 1 leq text{price} leq 10^9 ). **Requirements**: * Ensure the function is efficiently implemented to handle large input sizes up to ( 10^5 ). **Examples**: ```python # Example 1 prices = [1200, 700, 1500, 300, 500] sorted_prices = merge_sort(prices) print(sorted_prices) # Expected: [300, 500, 700, 1200, 1500] # Example 2 prices = [450, 200, 800, 100, 650] sorted_prices = merge_sort(prices) print(sorted_prices) # Expected: [100, 200, 450, 650, 800] ``` **Notes**: * The Merge Sort algorithm divides the input list into two halves, calls itself for the two halves, and then merges the two sorted halves. * The merge function is used for merging two halves. * The `merge_sort` function follows a recursive approach. * Ensure your implementation maintains a time complexity of ( mathcal{O}(n log n) ).","solution":"def merge_sort(prices: list[int]) -> list[int]: if len(prices) <= 1: return prices # Helper function to merge two sorted lists def merge(left: list[int], right: list[int]) -> list[int]: sorted_list = [] left_pointer, right_pointer = 0, 0 while left_pointer < len(left) and right_pointer < len(right): if left[left_pointer] < right[right_pointer]: sorted_list.append(left[left_pointer]) left_pointer += 1 else: sorted_list.append(right[right_pointer]) right_pointer += 1 if left_pointer < len(left): sorted_list.extend(left[left_pointer:]) if right_pointer < len(right): sorted_list.extend(right[right_pointer:]) return sorted_list mid = len(prices) // 2 left_half = merge_sort(prices[:mid]) right_half = merge_sort(prices[mid:]) return merge(left_half, right_half)"},{"question":"# Coding Assessment Question You are developing a feature for an inventory management system that helps to categorize items based on their sizes. Your task is to write a function that categorizes items into predefined size categories based on their measurements. # Task Write a function `categorize_item` that takes a single parameter: - `dimension` (float): The size of the item (e.g., length, width, or height). The function should return a string representing the category of the item based on the following criteria: - \\"Small\\" if the dimension is less than 20.0 - \\"Medium\\" if the dimension is between 20.0 (inclusive) and 50.0 (inclusive) - \\"Large\\" if the dimension is greater than 50.0 Additionally, ensure the function can handle various edge cases, such as negative or zero values. Function Signature ```python def categorize_item(dimension: float) -> str: ``` Input/Output Formats - The input consists of: - `dimension`: A float representing the size of the item. - The output is: - A string representing the category of the item size. Constraints - -1000.0 ≤ `dimension` ≤ 100000.0 Performance Requirements - The categorization should be determined in constant time, O(1). # Example ```python >>> categorize_item(15.0) \'Small\' >>> categorize_item(25.5) \'Medium\' >>> categorize_item(45.0) \'Medium\' >>> categorize_item(60.0) \'Large\' >>> categorize_item(0) \'Small\' >>> categorize_item(-10) \'Small\' ```","solution":"def categorize_item(dimension: float) -> str: Categorizes an item based on its dimension. Parameters: dimension (float): The size of the item. Returns: str: The category of the item (\\"Small\\", \\"Medium\\", \\"Large\\"). if dimension < 20.0: return \\"Small\\" elif 20.0 <= dimension <= 50.0: return \\"Medium\\" else: return \\"Large\\""},{"question":"# Question: Detecting Cyclic Numbers Introduction In mathematics, a cyclic number is a number in which cyclic permutations of the digits are successive multiples of the number. For example, the number `142857`: - `142857 * 1 = 142857` - `142857 * 2 = 285714` - `142857 * 3 = 428571` - `142857 * 4 = 571428` - `142857 * 5 = 714285` - `142857 * 6 = 857142` All the results are cyclic permutations of `142857`. In this coding assessment, you are required to check if a given number is cyclic. Task Write a function `is_cyclic` that determines if the given number is a cyclic number. Function Signature ```python def is_cyclic(number: int) -> bool: Determines if the given number is a cyclic number. Parameters: number (int): The number to check. Returns: bool: True if the number is cyclic, False otherwise. ``` Input Format * An integer `number (1 <= number < 10^6)`, the number to check for cyclicity. Output Format * Return a boolean value, `True` if the number is cyclic, and `False` otherwise. Example ```python print(is_cyclic(142857)) # Output: True print(is_cyclic(123456)) # Output: False ``` # Constraints * The number will always be a positive integer less than `10^6`. # Performance Requirements The solution should verify if the given number is cyclic by checking all required multiples and permutations within a reasonable computational time. The algorithm should handle repeats and avoid unnecessary recomputations to maximize efficiency.","solution":"def is_cyclic(number: int) -> bool: Determines if the given number is a cyclic number. Parameters: number (int): The number to check. Returns: bool: True if the number is cyclic, False otherwise. num_str = str(number) # Convert the number to a string for easy manipulation length = len(num_str) # Generate all cyclic permutations of the original number string cyclic_permutations = {num_str[i:] + num_str[:i] for i in range(length)} # Check if all multiples from 1 to \'length\' when multiplied result in cyclic permutations for i in range(1, length + 1): # Calculate the multiple multiple = number * i # Convert the multiple to a string for comparison multiple_str = str(multiple) # If the length of the multiple string is different from the original number, return False if len(multiple_str) != length: return False # Check if this multiplied result exists in cyclic permutations set if multiple_str not in cyclic_permutations: return False # If all checks are passed, number is cyclic return True"},{"question":"# FizzBuzz with a Twist You are tasked with creating a modified version of the classic FizzBuzz problem. Your function should print numbers from 1 to a given integer `n`. However, for multiples of a given divisor `x`, print \\"Fizz\\" instead of the number, for multiples of another given divisor `y`, print \\"Buzz\\", and for multiples of both `x` and `y`, print \\"FizzBuzz\\". Additionally, for every prime number between 1 and `n`, print \\"Prime\\". Detailed Instructions: 1. Write a function `fizz_buzz_prime` with the following parameters: - `n`: An integer denoting the range of numbers to print (from 1 to `n`). - `x`: An integer representing the first divisor. - `y`: An integer representing the second divisor. 2. The function should perform the following tasks: - Validate that all parameters (`n`, `x`, `y`) are positive integers and `n` is greater than or equal to 1. - Print \\"Fizz\\" for numbers that are multiples of `x`, \\"Buzz\\" for multiples of `y`, \\"FizzBuzz\\" for multiples of both `x` and `y`, and \\"Prime\\" for prime numbers. - If a number does not satisfy any of the above conditions, print the number itself. Constraints: - Do not use any additional libraries or modules. - Prime numbers take precedence over the FizzBuzz rules. If a number is prime and a multiple of `x` or `y`, print \\"Prime\\". Function Signature: ```python def fizz_buzz_prime(n: int, x: int, y: int) -> None: ``` Example: ```python # Example 1: fizz_buzz_prime(15, 3, 5) # Output: # 1 # Prime # Fizz # Prime # Buzz # Fizz # 7 # Prime # Fizz # Buzz # 11 # Fizz # Prime # 14 # FizzBuzz # Example 2: fizz_buzz_prime(10, 2, 3) # Output: # 1 # Prime # Fizz # Prime # Buzz # Prime # Fizz # Prime # 9 # Buzz ```","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def fizz_buzz_prime(n, x, y): Prints numbers from 1 to n with specific rules: - Print \\"Fizz\\" for multiples of x - Print \\"Buzz\\" for multiples of y - Print \\"FizzBuzz\\" for multiples of both x and y - Print \\"Prime\\" for prime numbers # Validate inputs if not (isinstance(n, int) and isinstance(x, int) and isinstance(y, int) and n > 0 and x > 0 and y > 0): raise ValueError(\\"All inputs must be positive integers, and n must be greater than or equal to 1.\\") result = [] for i in range(1, n + 1): if is_prime(i): result.append(\\"Prime\\") elif i % x == 0 and i % y == 0: result.append(\\"FizzBuzz\\") elif i % x == 0: result.append(\\"Fizz\\") elif i % y == 0: result.append(\\"Buzz\\") else: result.append(str(i)) print(\\"n\\".join(result))"},{"question":"# Coding Assessment Question: Dictionary Merging Utility Context In many software applications, managing and merging configurations or settings stored in dictionaries is a common task. Often, dictionaries need to be combined in such a way that their nested structures are preserved and correctly integrated. Task Implement a function that merges two dictionaries. The function should recursively merge nested dictionaries: if a key exists in both dictionaries, and both values are also dictionaries, these should be merged. Otherwise, the value from the second dictionary should overwrite the one in the first dictionary. Function Signature ```python def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merges dict2 into dict1 preserving nested structures. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: The merged dictionary. ``` Input - `dict1` and `dict2` are two dictionaries possibly containing nested dictionaries. Output - The function should return a dictionary which is the result of merging `dict2` into `dict1`. Constraints - Both dictionaries can contain nested dictionaries to any depth. - The merging should be recursive and preserve the integrity of the nested structures. - Non-dictionary values from `dict2` should overwrite those from `dict1` when conflicts occur. Example ```python # Example 1 dict1 = { \'a\': 1, \'b\': {\'x\': 2, \'y\': 3} } dict2 = { \'b\': {\'y\': 4, \'z\': 5}, \'c\': 6 } print(merge_dictionaries(dict1, dict2)) # Expected output: {\'a\': 1, \'b\': {\'x\': 2, \'y\': 4, \'z\': 5}, \'c\': 6} # Example 2 dict1 = { \'k1\': {\'subk1\': {\'subsubk1\': 1}}, \'k2\': 2 } dict2 = { \'k1\': {\'subk1\': {\'subsubk2\': 2}}, \'k3\': 3 } print(merge_dictionaries(dict1, dict2)) # Expected output: {\'k1\': {\'subk1\': {\'subsubk1\': 1, \'subsubk2\': 2}}, \'k2\': 2, \'k3\': 3} # Example 3 dict1 = { \'alpha\': {\'beta\': {\'gamma\': {\'delta\': 4}}}, } dict2 = { \'alpha\': {\'beta\': {\'gamma\': {\'epsilon\': 5}}}, } print(merge_dictionaries(dict1, dict2)) # Expected output: {\'alpha\': {\'beta\': {\'gamma\': {\'delta\': 4, \'epsilon\': 5}}}} ``` Additional Notes - Consider using recursion to handle the merging of nested dictionaries. - Ensure your function is robust and handles edge cases such as empty dictionaries or varying levels of nesting.","solution":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merges dict2 into dict1 preserving nested structures. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: The merged dictionary. for key in dict2: if (key in dict1 and isinstance(dict1[key], dict) and isinstance(dict2[key], dict)): dict1[key] = merge_dictionaries(dict1[key], dict2[key]) else: dict1[key] = dict2[key] return dict1"},{"question":"# Coding Challenge You have been provided with a sophisticated algorithm to compute the factorial of a large number efficiently using recursion and memoization. Factorial calculations are fundamental in various computational problems, from combinatorics to simulations and data analysis. Objective Your task is to implement a function that computes the factorial of a given non-negative integer, utilizing recursion and memoization to optimize performance for large inputs. Requirements - Implement the function `factorial` that calculates and returns the factorial of a given non-negative integer. - Utilize a helper function and a dictionary to store computed values to avoid redundant calculations. Function Signature ```python def factorial(n: int) -> int: pass ``` Input - `n`: An integer representing the number you need to compute the factorial of. - Example: 5 Output - An integer representing the factorial of the input number. Constraints - The input will be a non-negative integer. - You should handle possible exceptions for invalid input values such as negative integers gracefully. Example Here is an example of how your function should work: ```python >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(0) 1 ``` Code Template Use the following template to start your implementation: ```python from typing import Dict def factorial(n: int, memo: Dict[int, int] = {}) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n in memo: return memo[n] if n in (0, 1): return 1 result = n * factorial(n - 1, memo) memo[n] = result return result if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Feel free to use this structure to implement the function and ensure it calculates factorials efficiently using memoization.","solution":"from typing import Dict def factorial(n: int, memo: Dict[int, int] = {}) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n in memo: return memo[n] if n in (0, 1): return 1 result = n * factorial(n - 1, memo) memo[n] = result return result"},{"question":"# Graph Traversal: Depth-First Search (DFS) and Breadth-First Search (BFS) Scenario You are working on a project that involves navigation and search algorithms on graphs. Understanding the fundamental differences and use-cases for Depth-First Search (DFS) and Breadth-First Search (BFS) is crucial. Given an undirected graph represented as an adjacency list and a starting node, you need to implement both DFS and BFS traversal methods. Input and Output * Input: * A dictionary `graph` where keys are node identifiers (integers) and values are lists of neighboring node identifiers (integers). * An integer `start` representing the starting node for the traversal. * Output: * Two lists of integers, one representing the order of nodes visited during DFS traversal from the starting node and the other representing the order of nodes visited during BFS traversal from the starting node. Constraints * The graph can have up to 1000 nodes. * Each node identifier will be a unique integer. * The graph may be disconnected, but only consider the connected component that includes the starting node. * The node identifiers are positive integers. Performance Requirements * Both DFS and BFS traversals should complete within 1 second for the largest input size (1000 nodes with each node having up to 50 neighbors). Functions Definition ```python def depth_first_search(graph: dict[int, list[int]], start: int) -> list[int]: Perform a Depth-First Search (DFS) traversal on a graph. Args: graph (dict[int, list[int]]): The graph represented as an adjacency list. start (int): The starting node for the traversal. Returns: list[int]: The order of nodes visited during DFS traversal. # Implementation goes here def breadth_first_search(graph: dict[int, list[int]], start: int) -> list[int]: Perform a Breadth-First Search (BFS) traversal on a graph. Args: graph (dict[int, list[int]]): The graph represented as an adjacency list. start (int): The starting node for the traversal. Returns: list[int]: The order of nodes visited during BFS traversal. # Implementation goes here ``` Implement the above methods to facilitate comparisons between DFS and BFS traversals. Example ```python # Example 1: graph = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2] } start = 1 print(depth_first_search(graph, start)) # Example Output: [1, 2, 4, 5, 3] print(breadth_first_search(graph, start)) # Example Output: [1, 2, 3, 4, 5] # Example 2: graph = { 1: [2], 2: [1, 3, 4], 3: [2, 5], 4: [2], 5: [3] } start = 2 print(depth_first_search(graph, start)) # Example Output: [2, 1, 3, 5, 4] print(breadth_first_search(graph, start)) # Example Output: [2, 1, 3, 4, 5] ``` Implement DFS and BFS traversal methods to explore and navigate undirected graphs, comparing their performance and outputs.","solution":"def depth_first_search(graph: dict[int, list[int]], start: int) -> list[int]: Perform a Depth-First Search (DFS) traversal on a graph. Args: graph (dict[int, list[int]]): The graph represented as an adjacency list. start (int): The starting node for the traversal. Returns: list[int]: The order of nodes visited during DFS traversal. visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) # Use reversed to maintain the correct order return visited def breadth_first_search(graph: dict[int, list[int]], start: int) -> list[int]: Perform a Breadth-First Search (BFS) traversal on a graph. Args: graph (dict[int, list[int]]): The graph represented as an adjacency list. start (int): The starting node for the traversal. Returns: list[int]: The order of nodes visited during BFS traversal. visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited"},{"question":"# Coding Assessment Question Context: String manipulation and pattern recognition are pivotal tasks in programming and play crucial roles in data validation, processing, and transformation. One common task is to check if a given string pattern matches a specific structure. Task: Write a function `is_valid_password(password: str) -> bool` that checks if the provided password matches the following criteria: 1. It must contain at least 8 characters but no more than 20 characters. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from `!@#%^&*()_+-=[]{}|;:,.<>?`. Requirements: 1. Implement a function `is_valid_password(password: str) -> bool`. 2. The function should: - Return `True` if the password meets all the criteria. - Return `False` otherwise. Input: - `password` (str): The password string to be validated. Output: - Returns `True` if the password is valid, `False` otherwise. Constraints: - The function should efficiently validate the password against the given rules. - Must utilize string methods, loops, and/or regular expressions as appropriate. Example: ```python >>> is_valid_password(\\"Password1!\\") True >>> is_valid_password(\\"password1!\\") False >>> is_valid_password(\\"PASSWORD1!\\") False >>> is_valid_password(\\"Pass1!\\") False >>> is_valid_password(\\"ValidPassword123!\\") True >>> is_valid_password(\\"InvalidPassw0rd\\") False ``` Edge Cases: - A password that is exactly 8 characters long and fulfills all criteria should return `True`. - A password that is exactly 20 characters long and fulfills all criteria should return `True`. - Passwords shorter than 8 characters or longer than 20 characters should return `False`.","solution":"import re def is_valid_password(password: str) -> bool: Checks if the provided password meets the specified criteria. length_criteria = 8 <= len(password) <= 20 uppercase_criteria = re.search(r\'[A-Z]\', password) is not None lowercase_criteria = re.search(r\'[a-z]\', password) is not None digit_criteria = re.search(r\'d\', password) is not None special_char_criteria = re.search(r\'[!@#%^&*()_+-=[]{}|;:,.<>?]\', password) is not None return all([length_criteria, uppercase_criteria, lowercase_criteria, digit_criteria, special_char_criteria])"},{"question":"# Given Context You are implementing a caching mechanism to optimize API requests in a web application. The goal is to store the results of expensive API calls locally to reduce response times for frequently requested data. You need to design a caching system that stores API responses and invalidates the cache based on a given TTL (Time To Live). # Task 1. Implement a `Cache` class with methods to get and set data, ensuring that the cache invalidates entries after a specified TTL. 2. Modify the `fetch_data` function to utilize the `Cache` class, caching responses and checking the cache before making API requests. 3. Ensure that data older than the TTL is not returned and a new API request is made instead. # Input and Output Formats * **Cache Class Definition**: - `set(key: str, value: any, ttl: int)`: Stores the value in the cache for the given key with a TTL. - `get(key: str) -> any`: Retrieves the value from the cache for the given key if it is still valid; returns `None` otherwise. * **fetch_data function**: - `fetch_data(api_url: str, cache: Cache) -> any`: Fetches data from the API and utilizes the cache to store and retrieve data. * **Constraints**: - Cache should invalidate entries after the TTL has expired. - Utilize the `requests` library to make API requests. # Example Scenario Assume a weather application needs to fetch the latest temperature data for a specific location. The data should be cached to reduce load and latency, but it should also ensure freshness by invalidating cache entries after a specific period. # Starter Code ```python import json import requests import time class Cache: def __init__(self): self.cache = {} self.ttl = {} def set(self, key: str, value: any, ttl: int): self.cache[key] = value self.ttl[key] = time.time() + ttl def get(self, key: str) -> any: if key in self.cache and self.ttl[key] > time.time(): return self.cache[key] return None def fetch_data(api_url: str, cache: Cache) -> any: cached_data = cache.get(api_url) if cached_data: return cached_data response = requests.get(api_url) data = response.json() cache.set(api_url, data, ttl=60) # Cache for 60 seconds return data # Example Usage if __name__ == \\"__main__\\": cache = Cache() api_url = \\"https://api.weatherapi.com/v1/current.json?key=your_api_key&q=San%20Francisco\\" result = fetch_data(api_url, cache) print(json.dumps(result, indent=2)) ``` This example demonstrates integrating a caching mechanism into the `fetch_data` function to store and retrieve data efficiently, ensuring cache invalidation based on the defined TTL.","solution":"import json import requests import time class Cache: def __init__(self): self.cache = {} self.ttl = {} def set(self, key: str, value: any, ttl: int): self.cache[key] = value self.ttl[key] = time.time() + ttl def get(self, key: str) -> any: if key in self.cache and self.ttl[key] > time.time(): return self.cache[key] if key in self.cache: del self.cache[key] del self.ttl[key] return None def fetch_data(api_url: str, cache: Cache) -> any: cached_data = cache.get(api_url) if cached_data is not None: return cached_data response = requests.get(api_url) response.raise_for_status() data = response.json() cache.set(api_url, data, ttl=60) # Cache for 60 seconds return data"},{"question":"# Context: In many software systems, occasions arise where fixed-point numbers (numbers with a fixed number of decimal places) are preferred over floating-point numbers to avoid precision errors. One common task is adding a large array of such fixed-point numbers efficiently. # Problem Statement: Write a function `sum_fixed_point` that takes a list of strings representing fixed-point numbers and returns their sum as a string. Each string will follow a fixed-point format having the same number of decimal places. # Function Signature: ```python def sum_fixed_point(numbers: List[str]) -> str: ``` # Input: - `numbers`: a list of strings where each string represents a fixed-point number with up to 15 digits before the decimal point and exactly 4 digits after the decimal point. # Output: - Returns a string representing the sum of all input fixed-point numbers in the same fixed-point format. # Constraints: - The number of elements in the list will be between 1 and 10,000. - Each fixed-point number will be in the range from `-1,000,000,000.0000` to `1,000,000,000.0000`. # Example: ```python >>> sum_fixed_point([\\"123.4567\\", \\"76.5433\\"]) \\"200.0000\\" >>> sum_fixed_point([\\"-1234.5678\\", \\"5678.1234\\"]) \\"4443.5556\\" ``` # Additional Information: You might find the `decimal.Decimal` class useful for handling fixed-point arithmetic operations efficiently. Here is a snippet on how you can use it: ```python from decimal import Decimal def sum_fixed_point(numbers: List[str]) -> str: total = sum(Decimal(num) for num in numbers) return f\\"{total:.4f}\\" ```","solution":"from typing import List from decimal import Decimal def sum_fixed_point(numbers: List[str]) -> str: Returns the sum of fixed-point numbers given in the list as a string. Each number in the list will have up to 15 digits before the decimal point and exactly 4 digits after the decimal point. total = sum(Decimal(num) for num in numbers) return f\\"{total:.4f}\\""},{"question":"# Coding Assessment Question Context As part of an optimization project, your company needs to simplify data structures by removing duplicate elements. One of the requirements is to address lists of integers and ensure all elements are unique, while also preserving the order of their first appearance. Your task is to implement this functionality. Task Write a Python function `remove_duplicates` that performs the following operations: 1. Iterate through the input list of integers. 2. Remove duplicates while preserving the order of their first occurrence. 3. Return the modified list of integers. Function Signature ```python def remove_duplicates(nums: List[int]) -> List[int]: ``` Input * `nums` (a list of integers): A list of integers that may contain duplicates. Output * A list of integers with duplicates removed, preserving the original order of their first appearance. Constraints 1. The input list `nums` will contain integers within the range `[-1000, 1000]`. 2. The input list `nums` can have at most `10000` elements. Example ```python # Example nums = [1, 2, 3, 2, 1, 4, 5] print(remove_duplicates(nums)) # Output: [1, 2, 3, 4, 5] nums = [7, 8, 7, 9, 7, 10, 11] print(remove_duplicates(nums)) # Output: [7, 8, 9, 10, 11] nums = [1, 1, 1, 1, 1] print(remove_duplicates(nums)) # Output: [1] ``` Notes * Do not use any in-built Python functions specifically designed to remove duplicates or convert the list to a set. * Handle edge cases where the input list might be empty.","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Remove duplicates from the list while preserving the order of first appearance. Args: nums: List[int] - A list of integers that may contain duplicates. Returns: List[int] - A list of integers with duplicates removed. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"Problem Statement: Write a function `sort_by_other` that sorts a list of integers based on the order of another list of indices. The function should rearrange the elements in the first list such that their new positions correspond to the same-indexed elements in the second list. If the length of the index list exceeds the length of the input list, ignore the extra indices. # Expected Function Signature: ```python from typing import List def sort_by_other(values: List[int], indices: List[int]) -> List[int]: pass ``` # Input: * `values` (List[int]): A list of integers to be rearranged. * `indices` (List[int]): A list of integer indices representing the new order in which to rearrange the elements of `values`. # Output: * Returns a list of integers, rearranged according to the provided indices. # Constraints: * Values and indices will be valid lists of integers. * Indices list will contain unique elements. * Indices are zero-based and are non-negative. * `len(indices)` will be in the range `[0, len(values)]`. # Performance Requirements: * Your solution should aim for O(n) time complexity. * Aim for efficient space complexity while achieving the correct functionality. # Examples: * `sort_by_other([10, 20, 30], [2, 0, 1])` should return `[30, 10, 20]` * `sort_by_other([4, 5, 6, 7], [3, 2, 0, 1])` should return `[7, 6, 4, 5]` * `sort_by_other([42, 99], [1, 0])` should return `[99, 42]` * `sort_by_other([1, 2, 3], [0, 1, 2])` should return `[1, 2, 3]` * `sort_by_other([100, 200, 300], [2, 0])` should return `[300, 100]` # Notes: 1. Ensure to handle an empty `indices` list by returning an empty list. 2. Handle the case where indices are within the range of the values list. 3. If the length of `indices` is less than `values`, rearrange only the elements up to the length of `indices`. 4. Avoid nested loops to maintain the required time complexity. 5. Carefully manage index-based operations to prevent out-of-range errors.","solution":"from typing import List def sort_by_other(values: List[int], indices: List[int]) -> List[int]: This function sorts elements of \'values\' based on the specified order provided by \'indices\'. if not values or not indices: return [] sorted_list = [None] * len(indices) for i, idx in enumerate(indices): if idx < len(values): sorted_list[i] = values[idx] return sorted_list"},{"question":"# Slicing the Array Problem You are tasked with finding the maximum sum of any contiguous subarray of a given array of integers. The subarray must meet additional constraints related to its length: the length of the subarray must be between two given integer values, inclusive. # Input * An integer array `nums` where `1 ≤ len(nums) ≤ 10^5` and `-10^4 ≤ nums[i] ≤ 10^4`. * Two integers `min_len` and `max_len` where `1 ≤ min_len ≤ max_len ≤ len(nums)`. # Output * An integer representing the maximum sum of any contiguous subarray that has a length between `min_len` and `max_len`, inclusive. # Function Signature ```python def max_contiguous_subarray_sum(nums: List[int], min_len: int, max_len: int) -> int: pass ``` # Example Example 1 ```python max_contiguous_subarray_sum([1, -2, 3, -1, 2, -1, 5, -3], 2, 4) ➞ 6 # (from the subarray [2, -1, 5]) ``` Example 2 ```python max_contiguous_subarray_sum([-3, 4, -1, 2, -6, 1, 3, 4], 3, 5) ➞ 8 # (from the subarray [-1, 2, -6, 1, 3, 4]) ``` # Constraints - The sum of the elements in the subarray should be maximized within the allowed range of lengths. - The subarray should be a contiguous sequence of elements from the input array. # Instructions 1. Implement the function `max_contiguous_subarray_sum(nums: List[int], min_len: int, max_len: int) -> int`. 2. Ensure the function efficiently computes the result to handle scenarios where `len(nums)` is very large. 3. Take into consideration all edge cases based on the provided constraints to ensure robustness, especially cases where the length constraints are right at the edges of the array size.","solution":"from typing import List def max_contiguous_subarray_sum(nums: List[int], min_len: int, max_len: int) -> int: n = len(nums) max_sum = float(\'-inf\') # Calculate the prefix sums for nums to use in subarray sum calculations prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] # Iterate over each starting index of the subarray for start in range(n): # Iterate over each ending index within the allowed length limits for end in range(start + min_len - 1, min(start + max_len, n)): subarray_sum = prefix_sums[end + 1] - prefix_sums[start] max_sum = max(max_sum, subarray_sum) return max_sum"},{"question":"# Problem Statement You are given a positive integer `n`. Your task is to write a function that decomposes this integer into the smallest number of perfect squares which sum to `n`, and returns the count of these squares. # Input - The input is a single positive integer `n` (1 ≤ n ≤ 10,000). # Output - An integer representing the least number of perfect squares that sum to `n`. # Example Your implementation should produce the following outputs: ```python print(min_num_squares(12)) print(min_num_squares(13)) ``` Expected Output: ```python 3 2 ``` # Explanation For `n = 12`, the result is 3 because 12 can be decomposed into 4 (2^2) + 4 (2^2) + 4 (2^2). For `n = 13`, the result is 2 because 13 can be decomposed into 9 (3^2) + 4 (2^2). # Function Signature ```python def min_num_squares(n: int) -> int: pass ``` # Constraints - The solution should be efficient in terms of both time and space complexity. - Utilizes dynamic programming to achieve optimal results within the given constraints.","solution":"def min_num_squares(n: int) -> int: import math # Create a dp array to store the minimum number of squares that sum to every number up to n dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Base case # Loop through all numbers from 1 to n for i in range(1, n + 1): # Loop through all square numbers less than the current number i j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"# Weather Data Analyzer You are required to implement a function that analyzes weather data from a given JSON API and extracts key information. Objective: Write the `analyze_weather_data` function to: * Fetch weather data from a provided API URL. * Parse the JSON response and extract relevant weather information. * Return a formatted string summary of the weather data. Function Signature: ```python def analyze_weather_data(api_url: str) -> str: Fetches and analyzes weather data from the provided API URL. Args: - api_url: str: The URL of the weather data API. Returns: - str: A summary string of the weather data. ``` Input: * `api_url` (str): A string URL pointing to the weather data API. Output: * A string summarizing the weather data. Constraints: * The API URL should be valid and properly formatted. * The function should include error handling for: - Network-related exceptions. - Invalid API responses or JSON data. - API-specific error codes or missing fields in the response. Example JSON Response: ```json { \\"location\\": { \\"name\\": \\"San Francisco\\", \\"region\\": \\"California\\", \\"country\\": \\"USA\\" }, \\"current\\": { \\"temperature\\": 15, \\"wind_speed\\": 10, \\"wind_dir\\": \\"NW\\", \\"pressure\\": 1012, \\"humidity\\": 72, \\"precip\\": 0.0, \\"cloudcover\\": 75, \\"feelslike\\": 15 } } ``` Example Output: ``` Location: San Francisco, California, USA Current Temperature: 15°C Wind: 10 km/h NW Pressure: 1012 hPa Humidity: 72% Precipitation: 0.0 mm Cloud Cover: 75% Feels Like: 15°C ``` Example Usage: ```python try: summary = analyze_weather_data(\\"https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=San+Francisco\\") print(summary) except Exception as e: print(f\\"Failed to retrieve weather data: {e}\\") ``` # Additional Notes: - Parse the JSON response carefully and handle missing or unexpected fields. - The summary should only include relevant weather data, formatted clearly. - Use appropriate error messages to guide users when issues arise with the API request or response data.","solution":"import requests def analyze_weather_data(api_url: str) -> str: Fetches and analyzes weather data from the provided API URL. Args: - api_url: str: The URL of the weather data API. Returns: - str: A summary string of the weather data. try: response = requests.get(api_url) response.raise_for_status() # Raise HTTPError for bad responses data = response.json() location = data.get(\'location\', {}) current = data.get(\'current\', {}) location_name = location.get(\'name\', \'Unknown Location\') location_region = location.get(\'region\', \'\') location_country = location.get(\'country\', \'\') temperature = current.get(\'temperature\', \'N/A\') wind_speed = current.get(\'wind_speed\', \'N/A\') wind_dir = current.get(\'wind_dir\', \'N/A\') pressure = current.get(\'pressure\', \'N/A\') humidity = current.get(\'humidity\', \'N/A\') precip = current.get(\'precip\', \'N/A\') cloudcover = current.get(\'cloudcover\', \'N/A\') feelslike = current.get(\'feelslike\', \'N/A\') summary = ( f\\"Location: {location_name}, {location_region}, {location_country}n\\" f\\"Current Temperature: {temperature}°Cn\\" f\\"Wind: {wind_speed} km/h {wind_dir}n\\" f\\"Pressure: {pressure} hPan\\" f\\"Humidity: {humidity}%n\\" f\\"Precipitation: {precip} mmn\\" f\\"Cloud Cover: {cloudcover}%n\\" f\\"Feels Like: {feelslike}°C\\" ) return summary except requests.RequestException as e: return f\\"Failed to retrieve weather data: {e}\\" except ValueError as e: return f\\"Invalid JSON response: {e}\\""},{"question":"# Problem Statement You are given a list of people\'s names and their birthdates. You need to calculate each person\'s exact age in years, months, and days as of a given reference date. The date format for both birthdates and the reference date will be \\"YYYY-MM-DD\\". Develop a function that, for each person, computes their age by comparing their birthdate with the reference date, and returns a list of strings where each string contains the person\'s name and their exact age in the format \\"Name: X years, Y months, Z days\\". # Input ```txt The function should accept two parameters: 1. `people`: a list of strings where each string is in the format \\"Name, Birthdate\\" (e.g., \\"John Doe, 1990-05-14\\"). 2. `reference_date`: a string representing the reference date in the format \\"YYYY-MM-DD\\". ``` # Output ```txt The function should return a list of strings, where each string contains the person\'s name and their age in the format \\"Name: X years, Y months, Z days\\". ``` # Constraints * The birthdate will always be before the reference date. * The input list `people` will contain at least one entry. * Dates are valid and accurately reflect the Gregorian calendar. # Example Input ```python people = [\\"Alice Smith, 1985-10-30\\", \\"Bob Johnson, 1992-04-20\\"] reference_date = \\"2023-09-11\\" ``` Expected Output ```python [\\"Alice Smith: 37 years, 10 months, 12 days\\", \\"Bob Johnson: 31 years, 4 months, 22 days\\"] ``` # Implementation Implement the function `calculate_ages` which takes in a list of people and a reference date, and returns a list of formatted age strings: ```python def calculate_ages(people: list[str], reference_date: str) -> list[str]: # implementation details pass ``` Note: Ensure that the function handles edge cases such as leap years correctly.","solution":"from datetime import datetime from dateutil.relativedelta import relativedelta def calculate_ages(people, reference_date): reference_date = datetime.strptime(reference_date, \\"%Y-%m-%d\\") ages = [] for person in people: name, birthdate = person.split(\', \') birthdate = datetime.strptime(birthdate, \\"%Y-%m-%d\\") age_delta = relativedelta(reference_date, birthdate) age_str = f\\"{name}: {age_delta.years} years, {age_delta.months} months, {age_delta.days} days\\" ages.append(age_str) return ages"},{"question":"# Problem Statement **Context**: You are developing a text processing tool that needs to identify and correct common typographical errors, particularly contiguous duplicate characters in a word that typically appear due to fast typing or accidental key presses. The input words may contain one or more sequences of such duplicate characters, and your task is to remove the extra characters leaving only one occurrence of each letter in such sequences. For instance, the word \\"leeetttterrr\\" should be corrected to \\"leter\\". **Task**: Implement the `remove_duplicate_characters` function that takes in a string and returns a new string where consecutive duplicate characters are reduced to a single character. # Function Signature: ```python def remove_duplicate_characters(input_text: str) -> str: Remove consecutive duplicate characters in a given string. Parameters: - input_text (str): A string possibly containing sequences of consecutive duplicate characters. Returns: - str: A new string with consecutive duplicates reduced to a single character. ``` # Input: - `input_text`: A string of length `n` (0 <= n <= 10^5) containing upper and lower case English letters and spaces. # Output: - A string where consecutive duplicate characters are reduced to a single occurrence. # Constraints: - The input string can be empty. - The input string can contain spaces. Spaces should be treated as characters that can also be duplicated. # Example: ```python input_text_1 = \\"heeelllooo wooorrld\\" output_1 = remove_duplicate_characters(input_text_1) # Expected Output: \\"helo world\\" input_text_2 = \\"Thiiiss iiiis aaannn exaaamplee\\" output_2 = remove_duplicate_characters(input_text_2) # Expected Output: \\"This is an example\\" ``` **Note**: Your function should handle both upper and lower case letters, and it should preserve the original case of the characters.","solution":"def remove_duplicate_characters(input_text: str) -> str: Remove consecutive duplicate characters in a given string. Parameters: - input_text (str): A string possibly containing sequences of consecutive duplicate characters. Returns: - str: A new string with consecutive duplicates reduced to a single character. if not input_text: return \\"\\" # Initialize result with the first character result = [input_text[0]] # Iterate over the string starting from the second character for i in range(1, len(input_text)): if input_text[i] != input_text[i - 1]: result.append(input_text[i]) return \'\'.join(result)"},{"question":"# Question: Longest Subarray with Equal Number of 0s and 1s Context: You are given a binary array containing only `0`s and `1`s. Your task is to find the length of the longest contiguous subarray that has an equal number of `0`s and `1`s. Implement an efficient algorithm to achieve this, avoiding nested loops and brute force approaches. Requirements: 1. Implement a function `find_max_length(nums: list[int]) -> int` that returns the length of the longest contiguous subarray with an equal number of `0`s and `1`s. 2. The function should handle cases where the input array is empty by returning `0`. Input: - `nums`: A list of integers containing only `0`s and `1`s. Example: `[0, 1, 0, 1, 1, 0]` Output: - An integer representing the length of the longest contiguous subarray with equal number of `0`s and `1`s. Constraints: - The length of the array will not exceed `10^5`. - The elements of the array are either `0` or `1`. Performance Requirements: - Time complexity should be O(n). - Space complexity should be O(n). Example: ```python nums = [0, 1, 0, 1, 1, 0] find_max_length(nums) # Output should be 4 ``` Scenario: Consider you work with binary data streams and you want to find sequences that show an even distribution of bits to ensure data consistency. This function helps identify the longest balanced sequence of `0`s and `1`s efficiently. Write your implementation in Python and make sure to handle edge cases such as an array containing no elements or no valid subarray.","solution":"def find_max_length(nums): Return the length of the longest contiguous subarray with an equal number of 0s and 1s. if not nums: return 0 # Converts list of 0s and 1s into a list of -1s and 1s respectively. nums = [-1 if num == 0 else 1 for num in nums] # Dictionary to store the first occurrence of each cumulative sum. cumulative_sum_map = {0: -1} max_length = 0 cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num if cumulative_sum in cumulative_sum_map: max_length = max(max_length, i - cumulative_sum_map[cumulative_sum]) else: cumulative_sum_map[cumulative_sum] = i return max_length"},{"question":"# Coding Question: Efficient Subarray Sum **Context**: You need to calculate the sum of contiguous subarrays within an array of integers efficiently. Given the constraints of the system, the goal is to implement a solution that computes the sum in optimal time. **Task**: Implement the **Maximum Subarray Sum** algorithm, tasked with finding the largest sum of any contiguous subarray. **Input**: * A list of integers `nums` where `1 <= |nums| <= 10000` and `-10^4 <= nums[i] <= 10^4`. **Output**: * An integer representing the largest sum of any contiguous subarray within `nums`. **Constraints**: * You must implement the algorithm utilizing Kadane\'s Algorithm to ensure O(n) time complexity. * Handle both positive and negative numbers, as well as arrays containing all negative numbers. * Ensure the solution is stable and handles edge cases gracefully. * Follow good engineering practices and write clean, readable code. **Specification**: Function Signature: `def max_subarray_sum(nums: list[int]) -> int:` **Example**: ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 ```","solution":"def max_subarray_sum(nums: list[int]) -> int: Returns the largest sum of any contiguous subarray within the given list of integers. Uses Kadane\'s Algorithm to achieve optimal time complexity. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Question: Implement a Stack with Minimum Retrieval Context Stacks are a fundamental data structure used to store elements in a last-in, first-out (LIFO) manner. In addition to standard stack functionalities (push and pop), it can be useful to retrieve the minimum element efficiently at any point. Task Implement a stack that supports push, pop, and retrieving the minimum element in constant time. You need to define a class `MinStack` to accomplish this. Classes and Methods 1. **MinStack** - **Constructor**: - `__init__(self) -> None`: Initializes the empty stack. - **Push Element**: - `push(self, val: int) -> None`: Pushes an element onto the stack. - **Pop Element**: - `pop(self) -> None`: Removes the element on the top of the stack. - **Top Element**: - `top(self) -> int`: Gets the element on the top of the stack. - **Get Minimum Element**: - `get_min(self) -> int`: Retrieves the minimum element in the stack. Input and Output Format - **Class: `MinStack`** - **Constructor**: - **Input**: None - **Output**: Initializes an empty stack. - **Method: `push`** - **Input**: - `val`: Integer to be pushed onto the stack. - **Output**: `None` - **Method: `pop`** - **Input**: None - **Output**: `None` - **Method: `top`** - **Input**: None - **Output**: Integer value on the top of the stack. - **Method: `get_min`** - **Input**: None - **Output**: Integer value of the minimum element in the stack. Example Usage ```python # Example Usage min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 ``` Constraints - The methods `push`, `pop`, `top`, and `get_min` should all run in constant time. - Integers can have a value between `-10^5` and `10^5`. - The stack will not be empty when `top` or `get_min` is called.","solution":"class MinStack: def __init__(self) -> None: self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"# Question You are given two lists of integers, `lst1` and `lst2`, each of which represents a set of ranges. Each range is defined by a pair of elements—the start and the end of the range (both inclusive). Your task is to implement the function `merge_ranges` which merges these ranges and returns a new list of merged ranges without overlapping intervals. # Constraints 1. Each list elements must be sorted in ascending order. 2. Each range in the lists is represented by two integers [start, end], where 0 <= start <= end <= 10^6. 3. The resulting merged ranges should be returned as a list of lists, also sorted in ascending order. # Function Signature ```python def merge_ranges(lst1: List[List[int]], lst2: List[List[int]]) -> List[List[int]]: ... ``` # Input Format - `lst1`: A list of lists, where each sublist comprises two integers representing the inclusive range [start, end]. - `lst2`: A list of lists, where each sublist comprises two integers representing the inclusive range [start, end]. # Output Format - A list of lists representing the merged ranges, without any overlapping intervals. # Example ```python lst1 = [[1, 3], [5, 7]] lst2 = [[2, 4], [6, 8]] output = merge_ranges(lst1, lst2) print(output) # Expected: [[1, 4], [5, 8]] ``` # Additional Requirements: 1. Raise a `ValueError` if any start value is greater than end value within a range in the input lists. 2. Ensure the output list is sorted and contains no overlapping ranges. Implement the function to accomplish the above requirements.","solution":"from typing import List def merge_ranges(lst1: List[List[int]], lst2: List[List[int]]) -> List[List[int]]: def validate_ranges(ranges: List[List[int]]) -> None: for start, end in ranges: if start > end: raise ValueError(\\"Start value cannot be greater than end value in the given ranges.\\") # Validate input ranges validate_ranges(lst1) validate_ranges(lst2) # Merge both lists merged = sorted(lst1 + lst2, key=lambda x: x[0] ) # Merge overlapping ranges if not merged: return [] result = [] current_start, current_end = merged[0] for start, end in merged[1:]: if start <= current_end: current_end = max(current_end, end) else: result.append([current_start, current_end]) current_start, current_end = start, end result.append([current_start, current_end]) return result"},{"question":"# Sorting Custom Objects You are given a file containing a list of employees. Each employee has a name, age, and salary. Your task is to implement a Python class to handle the employee information, and create a function that reads a file, stores the information in custom objects, and sorts the list of employees based on a given attribute. # Class Definition and Sorting Function 1. **Employee Class**: Define a Python class `Employee` to store details of each employee with the following attributes: - `name`: A string representing the name of the employee. - `age`: An integer representing the age of the employee. - `salary`: A float representing the salary of the employee. 2. **Function to Read and Sort Employees**: Implement the function `read_and_sort_employees(file_path: str, sort_by: str) -> list` - Reads a file where each line contains details of an employee in the format: `name,age,salary` (without spaces). - Creates an instance of `Employee` for each line in the file. - Sorts the list of employees by the given attribute (`sort_by` which can be either \'name\', \'age\', or \'salary\'). - Returns the sorted list of employee objects. # Function Signature: ```python class Employee: def __init__(self, name: str, age: int, salary: float): pass def read_and_sort_employees(file_path: str, sort_by: str) -> list: pass ``` # Input: * `file_path`: A string representing the path to the input file. * `sort_by`: A string indicating the attribute to sort by (\'name\', \'age\', \'salary\'). # Output: * The function should return a list of `Employee` objects sorted by the specified attribute. # Constraints: * Age will be a non-negative integer. * Salary will be a non-negative float. * Names will be valid strings without special characters or digits. # Example Input File: Assume the file `employees.txt` contains the following lines: ``` John,30,60000.0 Jane,25,65000.0 Doe,40,55000.0 Alice,35,70000.0 Bob,28,50000.0 ``` # Example Usage: ```python employees_sorted_by_name = read_and_sort_employees(\'employees.txt\', \'name\') for emp in employees_sorted_by_name: print(emp.name, emp.age, emp.salary) # Output: # Alice 35 70000.0 # Bob 28 50000.0 # Doe 40 55000.0 # Jane 25 65000.0 # John 30 60000.0 ``` ```python employees_sorted_by_age = read_and_sort_employees(\'employees.txt\', \'age\') for emp in employees_sorted_by_age: print(emp.name, emp.age, emp.salary) # Output: # Jane 25 65000.0 # Bob 28 50000.0 # John 30 60000.0 # Alice 35 70000.0 # Doe 40 55000.0 ``` # Implement the class and function to handle the given operations correctly and efficiently.","solution":"class Employee: def __init__(self, name: str, age: int, salary: float): self.name = name self.age = age self.salary = salary def read_and_sort_employees(file_path: str, sort_by: str) -> list: employees = [] with open(file_path, \'r\') as file: for line in file: name, age, salary = line.strip().split(\',\') employees.append(Employee(name, int(age), float(salary))) if sort_by == \'name\': employees.sort(key=lambda emp: emp.name) elif sort_by == \'age\': employees.sort(key=lambda emp: emp.age) elif sort_by == \'salary\': employees.sort(key=lambda emp: emp.salary) return employees"},{"question":"# Problem You are tasked with implementing a simplified version of the Markov Chain simulation for weather prediction. Your job is to create a simulation that models weather changes over a sequence of days based on given transition probabilities between different weather states (sunny, cloudy, rainy). # Function Signature ```python def simulate_weather( days: int, initial_state: str, transition_matrix: dict ) -> dict: pass ``` # Parameters - **days** `(int)`: The number of days to simulate (1 ≤ days ≤ 365). - **initial_state** `(str)`: The initial weather state, which is one of \\"sunny\\", \\"cloudy\\", or \\"rainy\\". - **transition_matrix** `(dict)`: A dictionary representing the transition probabilities between states. Each key is a weather state (string) and each value is a dictionary with keys as possible next states (strings) and values as respective probabilities (floats). # Returns - **result** `(dict)`: A dictionary with the final counts of each weather state across the simulation period. - `{\\"sunny\\": <number of sunny days>, \\"cloudy\\": <number of cloudy days>, \\"rainy\\": <number of rainy days>}` # Detailed Requirements 1. **Initialization**: - Begin the simulation with the given `initial_state`. 2. **Simulation Loop**: - For each day, determine the next weather state based on the transition probabilities provided in the `transition_matrix`. - Use a random selection mechanism to transition from the current state to the next state according to the provided probabilities. 3. **Count Days**: - Track the count of each weather state throughout the simulation. 4. **Return Final Counts**: - After running the simulation for `days` number of days, return the counts of each weather state. # Example ```python days = 30 initial_state = \\"sunny\\" transition_matrix = { \\"sunny\\": {\\"sunny\\": 0.8, \\"cloudy\\": 0.15, \\"rainy\\": 0.05}, \\"cloudy\\": {\\"sunny\\": 0.2, \\"cloudy\\": 0.6, \\"rainy\\": 0.2}, \\"rainy\\": {\\"sunny\\": 0.1, \\"cloudy\\": 0.4, \\"rainy\\": 0.5} } result = simulate_weather( days, initial_state, transition_matrix ) print(result) # Output: {\'sunny\': X, \'cloudy\': Y, \'rainy\': Z} ``` In this example, replace `X`, `Y`, and `Z` with the resulting counts of sunny, cloudy, and rainy days after the simulation runs for `days` number of days.","solution":"import random def simulate_weather(days: int, initial_state: str, transition_matrix: dict) -> dict: Simulates weather changes over a sequence of days based on transition probabilities. Parameters: days (int): The number of days to simulate (1 ≤ days ≤ 365). initial_state (str): The initial weather state (\\"sunny\\", \\"cloudy\\", or \\"rainy\\"). transition_matrix (dict): A dictionary representing the transition probabilities between states. Each key is a weather state (string) and each value is a dictionary with keys as possible next states (strings) and values as respective probabilities (floats). Returns: dict: A dictionary with the final counts of each weather state across the simulation period. {\\"sunny\\": <number of sunny days>, \\"cloudy\\": <number of cloudy days>, \\"rainy\\": <number of rainy days>} # Initialize counts for each weather state weather_counts = {\\"sunny\\": 0, \\"cloudy\\": 0, \\"rainy\\": 0} # Set the initial state current_state = initial_state weather_counts[current_state] += 1 # Simulate the weather changes over the given number of days for _ in range(1, days): next_state_probs = transition_matrix[current_state] next_state = random.choices( population=list(next_state_probs.keys()), weights=list(next_state_probs.values()) )[0] weather_counts[next_state] += 1 current_state = next_state return weather_counts"},{"question":"# Binary Tree Level Order Traversal You have been given the task of performing a level order traversal (also known as breadth-first traversal) on a binary tree. Your goal is to traverse the tree level by level and return the nodes\' values grouped by each level in a nested list. Write a function `level_order_traversal(root: TreeNode) -> List[List[int]]` that takes: - `root`: the root node of the binary tree. The function should output a list of lists, where each list represents the nodes\' values at a particular level from top to bottom. Constraints: 1. The tree node values are integers. 2. The binary tree can be empty. 3. Use only standard libraries and data structures. 4. Optimize to handle large trees efficiently. Expected Input/Output: - Input: ```python # Binary Tree: # 3 # / # 9 20 # / # 15 7 ``` ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) ``` - Output: ```python [[3], [9, 20], [15, 7]] ``` Example: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(level_order_traversal(root)) # Output: [[1], [2, 3], [4, 5, 6, 7]] ``` Notes: 1. Ensure your function handles edge cases such as an empty binary tree. 2. Validate the input to ensure it is a proper binary tree node. 3. Focus on minimizing time and space complexity for traversing the tree.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level = [] for i in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Assessment Question Context You are tasked with developing a simplified version of a REST API that allows clients to create, read, and delete notes. Each note consists of a unique identifier, a title, and content. For simplicity, the notes will be stored in memory as a dictionary. Question Write a Python class called `NotesAPI` that simulates a REST API for managing notes. The class should provide methods for creating a new note, reading an existing note by its ID, and deleting a note by its ID. The `NotesAPI` class should include the following methods: 1. `create_note`: Takes a title and content as input, generates a unique ID for the note, stores it, and returns the ID. 2. `get_note`: Takes a note ID as input and returns the title and content of the corresponding note. 3. `delete_note`: Takes a note ID as input and deletes the corresponding note. Class Signature ```python class NotesAPI: def __init__(self): self.notes = {} self.next_id = 1 def create_note(self, title: str, content: str) -> int: pass def get_note(self, note_id: int) -> tuple[str, str]: pass def delete_note(self, note_id: int) -> bool: pass ``` Input - `title` (str): The title of the note. - `content` (str): The content of the note. - `note_id` (int): The unique identifier of the note. Output - `create_note`: Returns an integer representing the unique ID of the newly created note. - `get_note`: Returns a tuple containing the title and content of the note. - `delete_note`: Returns a boolean indicating whether the deletion was successful. Constraints - The note ID should be a unique integer that increments for each new note. - If a note with the specified ID does not exist in `get_note` or `delete_note`, handle it gracefully and return `None` for `get_note` and `False` for `delete_note`. - Ensure the `NotesAPI` class can maintain state between method calls. Example ```python api = NotesAPI() # Creating notes note_id_1 = api.create_note(\\"First Note\\", \\"This is the first note.\\") note_id_2 = api.create_note(\\"Second Note\\", \\"This is the second note.\\") # Reading notes note_1 = api.get_note(note_id_1) print(note_1) # Output: (\'First Note\', \'This is the first note.\') note_2 = api.get_note(note_id_2) print(note_2) # Output: (\'Second Note\', \'This is the second note.\') # Deleting notes delete_success = api.delete_note(note_id_1) print(delete_success) # Output: True # Attempting to read a deleted note note_1 = api.get_note(note_id_1) print(note_1) # Output: None ``` Guidelines - Use internal state to store notes as a dictionary where keys are note IDs, and values are dictionaries containing title and content. - Ensure the unique ID generator is thread-safe if used in a multithreaded environment. - Implement appropriate error-handling mechanisms for non-existent notes.","solution":"class NotesAPI: def __init__(self): self.notes = {} self.next_id = 1 def create_note(self, title: str, content: str) -> int: note_id = self.next_id self.notes[note_id] = {\\"title\\": title, \\"content\\": content} self.next_id += 1 return note_id def get_note(self, note_id: int) -> tuple[str, str] or None: note = self.notes.get(note_id) if note is not None: return note[\\"title\\"], note[\\"content\\"] return None def delete_note(self, note_id: int) -> bool: if note_id in self.notes: del self.notes[note_id] return True return False"},{"question":"# Implement a Queue with Fixed Array Size and Circular Buffer You are tasked with implementing a queue data structure using a fixed-size array and a circular buffer technique. A circular buffer works by wrapping around to the beginning of the array when it reaches the end. # Requirements: 1. Implement a `CircularQueue` class with the following methods: * `__init__(self, capacity)`: Initializes the queue with a fixed array of given `capacity`. * `enqueue(self, value)`: Adds `value` to the end of the queue. If the queue is full, an exception should be raised. * `dequeue(self)`: Removes the value from the front of the queue and returns it. If the queue is empty, an exception should be raised. * `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. * `is_full(self)`: Returns `True` if the queue is full, otherwise `False`. * `size(self)`: Returns the number of elements in the queue. * `peek(self)`: Returns the value at the front of the queue without removing it. If the queue is empty, an exception should be raised. 2. Ensure the use of a circular buffer to handle the queue operations efficiently. 3. Provide appropriate handling of edge cases, such as enqueuing to a full queue or dequeuing from an empty queue. # Constraints: * You may use internal state variables (e.g., `front`, `rear`, `count`) to manage the circular queue. * The queue should handle integers in the range [-10^6, 10^6]. * The size of the array (capacity) will be a positive integer given during initialization. # Input Format: You will receive: * A sequence of method calls for the `CircularQueue` class. Each method call may include parameters as specified in the requirements. # Output Format: For each method call, return the appropriate result based on the operation. For `enqueue` and `dequeue`, which modify the queue, return `None`. # Example Usage: ```python cq = CircularQueue(3) # Initialize a circular queue with capacity 3 cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.is_full()) # Output: True print(cq.dequeue()) # Output: 1 cq.enqueue(4) print(cq.peek()) # Output: 2 print(cq.size()) # Output: 3 print(cq.is_empty()) # Output: False ``` Implement the circular queue using fixed-size array and circular buffer technique.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, value): if self.is_full(): raise Exception(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity def size(self): return self.count def peek(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") return self.queue[self.front]"},{"question":"# Problem Statement You are given a list of strings `words` and a string `target`. Write a function `find_close_matches(target: str, words: list) -> list` that finds all strings in `words` that differ from `target` by exactly one character. The function should return a list of such words. If no such words exist, return an empty list. Input - `words`: A list of strings containing lowercase alphabets. - `target`: A string containing lowercase alphabets. Output - A list of strings from `words` that differ from `target` by exactly one character. Constraints - All strings in `words` and the `target` will have the same length, `n`, such that `1 <= n <= 100`. - The number of strings in `words` is `1 <= len(words) <= 1000`. Example ```python words = [\\"hello\\", \\"hella\\", \\"helly\\", \\"helicopter\\"] target = \\"hello\\" print(find_close_matches(target, words)) # Output: [\\"hella\\", \\"helly\\"] words = [\\"apple\\", \\"apply\\", \\"angle\\", \\"amble\\"] target = \\"apple\\" print(find_close_matches(target, words)) # Output: [\\"apply\\"] words = [\\"worry\\", \\"world\\", \\"words\\", \\"wordy\\"] target = \\"worry\\" print(find_close_matches(target, words)) # Output: [\\"wordy\\"] ``` Requirements - Your implementation should efficiently compare each string in `words` to the `target` string. - You should not use any external library functions other than the standard Python libraries.","solution":"def find_close_matches(target, words): def is_one_char_diff(str1, str2): diff_count = 0 for a, b in zip(str1, str2): if a != b: diff_count += 1 if diff_count > 1: return False return diff_count == 1 return [word for word in words if is_one_char_diff(word, target)]"},{"question":"# Question: Implement a Simple Speech Recognition System You are tasked with writing a function to implement a simple speech recognition system using the MFCC (Mel-Frequency Cepstral Coefficients) features and a K-nearest neighbors classifier. This exercise will test your understanding of audio processing, feature extraction, and machine learning. # Function Signature: ```python def simple_speech_recognition(train_audio_files: list[str], test_audio_file: str, k: int) -> str: pass ``` # Input: 1. `train_audio_files` (list[str]): List of file paths to the training audio files. Each file should have an associated text file with the same name but with a \'.txt\' extension that contains the transcribed text. 2. `test_audio_file` (str): Path to the test audio file. 3. `k` (int): The number of nearest neighbors to consider in the KNN classifier. # Output: 1. The recognized text for the test audio file. # Constraints: 1. The audio files should be in WAV format. 2. The transcribed text files should be in plain text format and contain the exact textual content of the corresponding audio file. 3. `k` should be a positive integer. # Example Usage: ```python recognized_text = simple_speech_recognition([\\"path_to_train_audio1.wav\\", \\"path_to_train_audio2.wav\\"], \\"path_to_test_audio.wav\\", 3) print(recognized_text) ``` # Performance Requirements: 1. The function should correctly recognize the text from the test audio file. 2. The implementation should handle multiple audio files and efficiently process them. # Task: * Implement the described function. * Extract MFCC features from the audio files. * Use a K-nearest neighbors classifier to match the MFCC features of the test audio file to those of the training files. * Perform necessary checks and exception handling to ensure robustness. * Test the function with multiple audio files of varying lengths and contents to verify its accuracy. # Notes: * Use of libraries such as librosa for audio processing and sklearn for machine learning is encouraged. * Ensure proper audio normalization and feature scaling before feeding data into the classifier.","solution":"import librosa import numpy as np from sklearn.neighbors import KNeighborsClassifier import os def simple_speech_recognition(train_audio_files, test_audio_file, k): Implement a simple speech recognition system using MFCC features and K-nearest neighbors. Args: train_audio_files (list[str]): List of file paths to the training audio files. test_audio_file (str): Path to the test audio file. k (int): The number of nearest neighbors to consider in the KNN classifier. Returns: str: Recognized text for the test audio file. if k <= 0: raise ValueError(\\"The number of nearest neighbors \'k\' must be a positive integer\\") def extract_mfcc(file_path): # Load audio file y, sr = librosa.load(file_path, sr=None) # Extract MFCC features mfcc_features = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13) # Aggregate MFCC to get a fixed-size feature vector mfcc_features_mean = np.mean(mfcc_features, axis=1) return mfcc_features_mean def load_transcript(file_path): with open(file_path, \'r\') as file: return file.read().strip() training_data = [] training_labels = [] # Extract features and labels from training data for audio_path in train_audio_files: mfcc_features = extract_mfcc(audio_path) transcript_path = os.path.splitext(audio_path)[0] + \'.txt\' transcript_text = load_transcript(transcript_path) training_data.append(mfcc_features) training_labels.append(transcript_text) # Convert list to numpy array training_data = np.array(training_data) # Train KNN classifier knn = KNeighborsClassifier(n_neighbors=k) knn.fit(training_data, training_labels) # Extract features from test audio file test_mfcc_features = extract_mfcc(test_audio_file).reshape(1, -1) # Predict the transcript for the test audio file recognized_text = knn.predict(test_mfcc_features) return recognized_text[0]"},{"question":"# Coding Assessment Question **Scenario**: You are contributing to a project that involves processing text data to analyze word frequency in books. Your task is to implement a function that reads multiple files and extracts the most common words, excluding a predefined list of stop words. **Task**: Implement a function `find_most_common_words` that processes multiple text files and returns the top `N` most common words, excluding any stop words. **Function Signature**: ```python def find_most_common_words(file_paths: list, stop_words: list, top_n: int) -> list: Processes the text files, extracts and returns the most common words excluding any stop words. Args: file_paths (list): List of paths to text files. stop_words (list): List of words to exclude from the frequency count. top_n (int): Number of top common words to return. Returns: list: List of tuples (word, frequency), sorted by frequency in descending order. ``` **Example**: ```python file_paths = [\'book1.txt\', \'book2.txt\'] stop_words = [\'the\', \'and\', \'is\', \'in\', \'it\'] top_n = 5 common_words = find_most_common_words(file_paths, stop_words, top_n) for word, frequency in common_words: print(f\\"Word: {word}, Frequency: {frequency}\\") ``` **Constraints**: 1. Your function must: - Read and process multiple files efficiently. - Exclude the words present in the provided list of stop words. - Handle large text files without causing memory issues. - Return results sorted by frequency in descending order. 2. Consider edge cases such as empty files or files with only stop words. **Performance Boundaries**: - Ensure that your function can handle processing files totaling up to 100 MB in size without significant performance degradation. **Additional Notes**: - You can use libraries like `collections` for counter functionalities. - Make sure to handle file reading errors gracefully. - Properly structure and comment your code for readability and maintainability.","solution":"from collections import Counter def find_most_common_words(file_paths, stop_words, top_n): Processes the text files, extracts and returns the most common words excluding any stop words. Args: file_paths (list): List of paths to text files. stop_words (list): List of words to exclude from the frequency count. top_n (int): Number of top common words to return. Returns: list: List of tuples (word, frequency), sorted by frequency in descending order. stop_words_set = set(stop_words) word_counter = Counter() for file_path in file_paths: try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = line.split() filtered_words = [word for word in words if word.lower() not in stop_words_set] word_counter.update(filtered_words) except FileNotFoundError: print(f\\"File {file_path} not found.\\") except Exception as e: print(f\\"Error reading file {file_path}: {e}\\") return word_counter.most_common(top_n)"},{"question":"# Coding Assessment Question Context You are building a command-line utility that processes log files generated by a web server. Each log file records HTTP requests with information such as IP address, request method, URL, and response status code. Your task is to parse these log files and generate a summary report. Question Write a Python function named `parse_log_file` that processes a web server log file and returns a summary report. The function should read the log file, extract the relevant request information, and compile the report which includes the total number of requests, the number of requests per method (GET, POST, etc.), and the number of requests that resulted in different status codes (e.g., 200, 404, 500). Function Signature ```python def parse_log_file(file_path: str) -> dict: pass ``` Input - `file_path` (str): The path to the log file to be processed. Output - A dictionary containing the summary report: - `total_requests` (int): The total number of requests in the log file. - `methods` (dict): A dictionary with HTTP methods as keys and their respective counts as values. - `status_codes` (dict): A dictionary with status codes as keys and their respective counts as values. Constraints - Assume that each line in the log file contains a single HTTP request and is formatted as follows: ``` <IP address> - - [<Date>] \\"<Method> <URL> HTTP/1.1\\" <Status code> <Size> ``` - Handle edge cases such as an empty log file gracefully. - Assume the log file can be large, so ensure the function processes the entries efficiently. Example ```python # Contents of log file located at \'/path/to/log_file.log\' # 192.168.1.1 - - [12/Oct/2023:14:12:25 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 # 192.168.1.2 - - [12/Oct/2023:14:15:43 +0000] \\"POST /submit-form HTTP/1.1\\" 404 512 # 192.168.1.3 - - [12/Oct/2023:14:20:12 +0000] \\"GET /about.html HTTP/1.1\\" 200 2048 report = parse_log_file(\'/path/to/log_file.log\') print(report) # Output: { # \'total_requests\': 3, # \'methods\': {\'GET\': 2, \'POST\': 1}, # \'status_codes\': {\'200\': 2, \'404\': 1} # } ``` Guidelines - Open and read the log file line-by-line to handle large files efficiently. - Use regular expressions to parse each log entry and extract the required information. - Compile the extracted information into the summary report and return it.","solution":"import re from collections import defaultdict def parse_log_file(file_path: str) -> dict: Processes a web server log file and returns a summary report. Args: file_path (str): The path to the log file to be processed. Returns: dict: A dictionary with the summary report: - total_requests: The total number of requests. - methods: Counts of request methods (GET, POST, etc.). - status_codes: Counts of response status codes (200, 404, etc.). total_requests = 0 methods = defaultdict(int) status_codes = defaultdict(int) log_line_pattern = re.compile(r\'S+ - - [S+ +d+] \\"(?P<method>S+) S+ S+\\" (?P<status>d+) d+\') with open(file_path, \'r\') as file: for line in file: match = log_line_pattern.match(line) if match: total_requests += 1 method = match.group(\'method\') status = match.group(\'status\') methods[method] += 1 status_codes[status] += 1 return { \'total_requests\': total_requests, \'methods\': dict(methods), \'status_codes\': dict(status_codes) }"},{"question":"# Question: Grid Pathways to Reach the Goal You are given an `m x n` grid. A robot starts at the top-left corner (0, 0) and needs to move to the bottom-right corner (m-1, n-1). The robot can only move either down or right at any point in time. However, some cells in the grid may be blocked and the robot cannot go through them. The goal is to find all the unique paths from the start to the goal. Write a function `find_unique_paths` that returns the number of unique paths available considering the blocked cells. Function Signature ```python def find_unique_paths(grid: List[List[int]]) -> int: ``` Input - `grid` (List[List[int]]): an `m x n` list of lists where each element is either 0 (unblocked cell) or 1 (blocked cell). Output - Returns an integer representing the number of unique paths from (0,0) to (m-1, n-1). Constraints - The grid dimensions `m` and `n` will be between 1 and 100. - An unblocked cell is represented by `0` and a blocked cell is represented by `1`. - The top-left and bottom-right cell will always be unblocked. Example ```python grid1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert find_unique_paths(grid1) == 2 grid2 = [ [0, 1], [0, 0] ] assert find_unique_paths(grid2) == 1 ``` Explanation - For `grid1`, there are two unique paths: - Right -> Right -> Down -> Down - Down -> Down -> Right -> Right - For `grid2`, there is only one unique path: - Down -> Right","solution":"from typing import List def find_unique_paths(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # Blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"# Coding Assessment Question You are tasked with implementing an algorithm that verifies whether a given string pattern can be found in some form (either directly or as a permutation) in a given text string. Specifically, your function should check if any permutation of the pattern exists as a substring within the text. # Input and Output Formats - **Input**: Two strings `pattern` and `text` where `1 <= len(pattern) <= 1000` and `1 <= len(text) <= 10000`. - **Output**: A boolean value `True` if any permutation of the pattern exists as a substring in the text, `False` otherwise. # Constraints - The characters are limited to lowercase English letters. - Efficient solutions that handle the upper bounds of input sizes are required. # Function Signature ```python def check_permutation_in_string(pattern: str, text: str) -> bool: pass ``` # Example ```python >>> check_permutation_in_string(\\"ab\\", \\"eidbaooo\\") True >>> check_permutation_in_string(\\"ab\\", \\"eidboaoo\\") False ``` # Detailed Description - **Edge Cases**: Consider patterns that are empty or equal to the length of the text. - **Special Scenarios**: Long text strings with varying characters and multiple repetitions of the pattern. # Notes Efficient string comparison techniques such as sliding window and frequency matching can be helpful. Optimize the algorithm to quickly discard segments of the text that cannot possibly contain a permutation of the pattern.","solution":"def check_permutation_in_string(pattern: str, text: str) -> bool: from collections import Counter len_pattern = len(pattern) len_text = len(text) if len_pattern > len_text: return False pattern_counter = Counter(pattern) window_counter = Counter(text[:len_pattern]) if pattern_counter == window_counter: return True for i in range(len_pattern, len_text): window_counter[text[i]] += 1 window_counter[text[i - len_pattern]] -= 1 if window_counter[text[i - len_pattern]] == 0: del window_counter[text[i - len_pattern]] if pattern_counter == window_counter: return True return False"},{"question":"# Coding Assessment Question As a backend engineer, you are tasked with improving an inventory management system that tracks products and their prices. The system currently consists of a simple database and a basic interface to add, remove, and update product details. Your goal is to enhance the system by adding functionality to handle bulk data updates efficiently and ensure the system remains robust under various conditions. Your task is to: 1. Implement a function to process and update product prices in bulk from a given list. 2. Add error handling to manage possible input errors and database constraints. 3. Write a function to retrieve the most expensive products within a specified price range. 4. Include brief documentation for the new functions and update the existing ones (if any). Expected Input and Output **Function 1**: `def bulk_update_prices(products: list[dict[str, str | float]]) -> None`: Process and update product prices in bulk. - **Input**: A list of dictionaries where each dict contains \'product_id\' (str) and \'new_price\' (float). - **Output**: None; update the database with new prices. **Function 2**: `def get_expensive_products(min_price: float, max_price: float, limit: int = 10) -> list[dict[str, str | float]]`: Retrieve the most expensive products within a specified price range. - **Input**: - `min_price` (float): Minimum price to filter products. - `max_price` (float): Maximum price to filter products. - `limit` (int): Number of products to retrieve. - **Output**: A list of dictionaries containing product details for the most expensive products within the specified range. # Constraints - Ensure the bulk update efficiently handles large datasets without significant performance degradation. - Include input validation to handle incorrect data types or missing values. - Properly handle database constraints, such as non-existent product IDs or invalid price ranges. - Ensure the system can handle concurrency issues when multiple updates are processed simultaneously.","solution":"# Let\'s assume we have a simple in-memory database represented by a dictionary for this task. # In a real-world scenario, you would interact with an actual database using an ORM or direct SQL queries. # Here is a simple in-memory database database = { \'products\': [ {\'product_id\': \'p1\', \'name\': \'Product 1\', \'price\': 100.0}, {\'product_id\': \'p2\', \'name\': \'Product 2\', \'price\': 150.0}, {\'product_id\': \'p3\', \'name\': \'Product 3\', \'price\': 200.0}, ] } def bulk_update_prices(products: list[dict[str, str | float]]) -> None: Updates the prices of multiple products in the database. Args: products (list): A list of dictionaries with \'product_id\' (str) and \'new_price\' (float). Raises: ValueError: If product_id is not found or new_price is invalid. product_map = {product[\'product_id\']: product for product in database[\'products\']} for item in products: product_id = item.get(\'product_id\') new_price = item.get(\'new_price\') if not product_id or product_id not in product_map: raise ValueError(f\\"Product ID {product_id} not found.\\") if not isinstance(new_price, (int, float)) or new_price < 0: raise ValueError(f\\"Invalid price {new_price} for product ID {product_id}.\\") product_map[product_id][\'price\'] = new_price def get_expensive_products(min_price: float, max_price: float, limit: int = 10) -> list[dict[str, str | float]]: Retrieves the most expensive products within a specified price range. Args: min_price (float): Minimum price to filter products. max_price (float): Maximum price to filter products. limit (int): Number of products to retrieve (default is 10). Returns: list: A list of dictionaries containing product details. Raises: ValueError: If min_price or max_price is invalid. if min_price < 0 or max_price < min_price: raise ValueError(\\"Invalid price range.\\") filtered_products = [p for p in database[\'products\'] if min_price <= p[\'price\'] <= max_price] filtered_products.sort(key=lambda x: -x[\'price\']) # Sort by price descending return filtered_products[:limit]"},{"question":"# Task: Evaluate Postfix Expression **Scenario**: In this task, you\'ll evaluate a given postfix (or Reverse Polish Notation) expression. Postfix notation is a mathematical notation in which operators follow their operands. **Function Details**: * **Function Name**: `evaluate_postfix` * **Input Parameters**: - `expression` (List[str]): A list of strings representing both numbers and operators in postfix notation. * **Output**: - A float representing the result of the evaluated expression. * **Error Handling**: - If the input list is empty, raise a `ValueError` with the message \\"Expression cannot be empty\\". - If the input list contains invalid characters (e.g., letters or special characters other than operators `+`, `-`, `*`, `/`), raise a `ValueError` with the message \\"Invalid character in expression\\". * **Example Usage**: ```python >>> evaluate_postfix([\\"2\\", \\"3\\", \\"+\\", \\"4\\", \\"*\\"]) 20.0 >>> evaluate_postfix([\\"10\\", \\"2\\", \\"/\\", \\"3\\", \\"-\\"]) 2.0 >>> evaluate_postfix([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14.0 >>> evaluate_postfix([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2.0 >>> evaluate_postfix([]) Traceback (most recent call last): ... ValueError: Expression cannot be empty >>> evaluate_postfix([\\"2\\", \\"3\\", \\"a\\", \\"+\\"]) Traceback (most recent call last): ... ValueError: Invalid character in expression ``` # Constraints: - The number of elements (n) in the expression will be in the range of 1 ≤ n ≤ 10^5. - Each element in the expression list will be a string representing a number (which can be negative or positive, integer or float) or an operator (`+`, `-`, `*`, `/`). - The evaluation should handle edge cases like division by zero gracefully by raising a `ZeroDivisionError`. Ensure that the evaluation algorithm is efficient and handles large expressions within a reasonable time.","solution":"def evaluate_postfix(expression): Evaluates the given postfix (Reverse Polish Notation) expression. Args: expression (List[str]): A list of strings representing both numbers and operators in postfix notation. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is empty or contains invalid characters. ZeroDivisionError: If a division by zero is attempted. if not expression: raise ValueError(\\"Expression cannot be empty\\") stack = [] for token in expression: if token in {\'+\', \'-\', \'*\', \'/\'}: if len(stack) < 2: raise ValueError(\\"Insufficient values in expression\\") right = stack.pop() left = stack.pop() if token == \'+\': stack.append(left + right) elif token == \'-\': stack.append(left - right) elif token == \'*\': stack.append(left * right) elif token == \'/\': if right == 0: raise ZeroDivisionError(\\"Division by zero\\") stack.append(left / right) else: try: stack.append(float(token)) except ValueError: raise ValueError(\\"Invalid character in expression\\") if len(stack) != 1: raise ValueError(\\"The expression did not result in a single value\\") return stack.pop()"},{"question":"# Context In this task, you need to work with data structures and string manipulation to build a utility function. Given a list of dictionaries, each representing a person with their name and a list of friends\' names, you are to create a function that returns a list of unique names sorted alphabetically. # Problem Statement Write a function that consolidates all the unique names from the input list, including names and friends\' names, and sorts them alphabetically. # Requirements - Implement a function `consolidate_names(data: List[dict]) -> List[str]` which: * Accepts a list of dictionaries, where each dictionary contains: - `name` (str): The name of a person. - `friends` (List[str]): A list of friends\' names. * Aggregates all unique names, including `name` and their `friends`. * Returns the sorted list of unique names in alphabetical order. # Input - `data (List[dict])`: A list of dictionaries, each containing a `name` key (str) and a `friends` key (List[str]). # Output - Returns a list of strings, which are sorted unique names. # Example ```python data = [ {\\"name\\": \\"Alice\\", \\"friends\\": [\\"Bob\\", \\"Charlie\\"]}, {\\"name\\": \\"Bob\\", \\"friends\\": [\\"Alice\\", \\"David\\"]}, {\\"name\\": \\"Charlie\\", \\"friends\\": [\\"Alice\\"]} ] result = consolidate_names(data) print(result) ``` Expected output: ``` [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] ``` # Constraints - Each name and friends\' name will consist of alphabetic characters only and have a maximum length of 50 characters. - The input list will contain at most 100,000 dictionaries. - Any single user will have at most 1,000 friends. # Notes - Ensure the function efficiently handles the potential large input size. - Consider using Python\'s set data structure for gathering unique names.","solution":"from typing import List, Dict def consolidate_names(data: List[Dict[str, List[str]]]) -> List[str]: unique_names = set() for person in data: # Add the person\'s name to the set unique_names.add(person[\'name\']) # Add each friend\'s name to the set unique_names.update(person[\'friends\']) # Sort the unique names alphabetically and return return sorted(unique_names)"},{"question":"# Question: Implement a Function to Merge K Sorted Linked Lists You are asked to implement a function that merges k sorted linked lists into a single sorted linked list. Each individual linked list is sorted in ascending order. The merged linked list should also be sorted in ascending order. Task: Implement the function `merge_k_sorted_lists(lists: List[ListNode]) -> ListNode` where `ListNode` is a class representing a single node in a linked list. # Constraints: - Each linked list contains nodes with integer values. - There can be up to `k` linked lists where `1 <= k <= 100`. - Each linked list can contain up to 10,000 nodes. # Requirements: 1. **Function Signature**: `def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode:` 2. **Input/Output**: - **Input**: A list `lists` with `k` linked lists represented by `ListNode` objects. - **Output**: A single merged linked list represented by a `ListNode` object. 3. You should aim for an efficient solution, preferably using a heap-based approach to optimize the merge process. # Example: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] merged_list = merge_k_sorted_lists(lists) # should produce 1->1->2->3->4->4->5->6 in the linked list representation ``` # Performance Note: The optimal implementation should aim to merge the k lists in O(N log k) time complexity where N is the total number of nodes across all linked lists. Consider using a min-heap to achieve efficient merging. # Clarification: - If the input list `lists` is empty, return `None`. - If any of the individual linked lists is empty, handle it gracefully by skipping such lists during the merge process.","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] # Initialize the heap for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Question: Validate and Calculate Average Age You are required to implement a function that calculates the average age from a list of ages provided as strings. Your function should first validate that the inputs are valid non-negative integers. If the input list is empty or contains any invalid age, your function should raise a `ValueError` with an appropriate error message. Input: - A list of strings, each representing an age. Output: - A single float, representing the average of the valid ages rounded to two decimal places. Constraints: - Each age should be a non-negative integer. - The input list may contain leading or trailing spaces around the numeric strings. - An empty list or any invalid age entry should trigger a `ValueError`. Examples: ```python def average_age(age_list: list) -> float: Calculate the average age from a list of valid age strings. :param age_list: list: A list of strings representing ages. :return: float: The average age rounded to two decimal places. Examples: >>> average_age([\\"23\\", \\"45\\", \\"36\\"]) 34.67 >>> average_age([\\" 23 \\", \\"45\\", \\" 36\\"]) 34.67 >>> average_age([\\"1 23\\", \\"45\\", \\"36\\"]) Traceback (most recent call last): ... ValueError: Invalid age entered >>> average_age([]) Traceback (most recent call last): ... ValueError: The list is empty >>> average_age([\\"23\\", \\"-45\\", \\"36\\"]) Traceback (most recent call last): ... ValueError: Invalid age entered >>> average_age([\\"23\\", \\"45\\", \\"\\"]) Traceback (most recent call last): ... ValueError: Invalid age entered if not age_list: raise ValueError(\\"The list is empty\\") valid_ages = [] for age in age_list: age = age.strip() if not age.isdigit() or int(age) < 0: raise ValueError(\\"Invalid age entered\\") valid_ages.append(int(age)) if not valid_ages: raise ValueError(\\"No valid ages in the list\\") average = sum(valid_ages) / len(valid_ages) return round(average, 2) if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Your task is to implement the `average_age` function following the specifications above.","solution":"def average_age(age_list: list) -> float: Calculate the average age from a list of valid age strings. :param age_list: list: A list of strings representing ages. :return: float: The average age rounded to two decimal places. if not age_list: raise ValueError(\\"The list is empty\\") valid_ages = [] for age in age_list: age = age.strip() if not age.isdigit() or int(age) < 0: raise ValueError(\\"Invalid age entered\\") valid_ages.append(int(age)) average = sum(valid_ages) / len(valid_ages) return round(average, 2)"},{"question":"# Scenario: As a software engineer, you\'re tasked with optimizing the performance of a website. One of the key areas for improvement is the loading speed of large data tables. To do this, you\'ll implement a caching mechanism to store the most frequently accessed rows of the table, reducing database hits and improving response times. # Task: Implement a class `Cache` that provides a simple caching mechanism using a Least Recently Used (LRU) strategy. The class should support adding, accessing, and removing items while maintaining the LRU order. # Specifications: 1. The class should have the following methods: ```python class Cache: def __init__(self, capacity: int): # Initialize the cache with a given capacity def get(self, key: int) -> int: # Retrieve the value associated with the key # Return -1 if the key is not found def put(self, key: int, value: int): # Add a new key-value pair to the cache # Evict the least recently used item if the cache exceeds its capacity ``` 2. The methods should adhere to the following specifications: * `__init__`: Initializes the cache with a given capacity. * `get`: Retrieves the value associated with the key if it exists, marking the item as recently used. Returns `-1` if the key is not found. * `put`: Adds a new key-value pair to the cache. If the key already exists, update the value and mark the item as recently used. If the cache exceeds its capacity, evict the least recently used item. # Input: * `capacity`: An `int` indicating the maximum capacity of the cache. * `key`: An `int` representing the key to be accessed or added. * `value`: An `int` representing the value to be added to the cache. # Output: * The `get` method returns the value associated with a key, or `-1` if the key is not found. * The `put` method adds a key-value pair to the cache and manages the LRU order. # Constraints: * The cache capacity (`capacity`) will be between 1 and 1000. * The `key` and `value` will be non-negative integers. # Examples: 1. ```python cache = Cache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) # returns 1 cache.put(3, 3) # evicts key 2 cache.get(2) # returns -1 (not found) cache.put(4, 4) # evicts key 1 cache.get(1) # returns -1 (not found) cache.get(3) # returns 3 cache.get(4) # returns 4 ``` 2. ```python cache = Cache(1) cache.put(1, 1) cache.put(2, 2) # evicts key 1 cache.get(1) # returns -1 (not found) cache.get(2) # returns 2 ``` # Notes: * You may assume the get and put operations will always be called with valid key-value pairs. * Ensure to handle the eviction properly and maintain the order of least recently used items accurately to match the behavior of an LRU cache.","solution":"from collections import OrderedDict class Cache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # mark as recently used return self.cache[key] def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove least recently used item"},{"question":"# Problem Statement Given a list of integers, you need to write a function that generates all possible combinations of these integers and returns a list of these combinations sorted lexicographically. Each combination should be of a specified length `k`. # Task Create a function that generates all unique combinations of the input list elements of a given length and returns these combinations sorted in lexicographic order. # Function Signature ```python def generate_combinations(arr: list, k: int) -> list: Generate all combinations of length k sorted lexicographically ``` # Input and Output * **Input**: * A list of integers `arr` (e.g., `arr = [1, 2, 3]`). * An integer `k`, specifying the length of each combination. * **Output**: A list of lists containing all possible combinations of length `k` from `arr`, sorted in lexicographic order. # Constraints * `1 <= len(arr) <= 15` * `1 <= k <= len(arr)` * Elements of `arr` are unique integers. * The input list is not necessarily sorted. # Example ```python >>> generate_combinations([3, 1, 2], 2) [[1, 2], [1, 3], [2, 3]] >>> generate_combinations([4, 5, 6], 1) [[4], [5], [6]] >>> generate_combinations([5, 3, 2, 8], 3) [[2, 3, 5], [2, 3, 8], [2, 5, 8], [3, 5, 8]] ``` # Additional Notes * The combinations should be generated in lexicographical order based on the input. * Use built-in functions from itertools library if needed. * Ensure that the function handles edge cases, such as when `k` is 1 or equal to the length of the list. ```python from itertools import combinations def generate_combinations(arr: list, k: int) -> list: arr.sort() return [list(c) for c in combinations(arr, k)] # Example usage: print(generate_combinations([3, 1, 2], 2)) # Output: [[1, 2], [1, 3], [2, 3]] print(generate_combinations([4, 5, 6], 1)) # Output: [[4], [5], [6]] print(generate_combinations([5, 3, 2, 8], 3)) # Output: [[2, 3, 5], [2, 3, 8], [2, 5, 8], [3, 5, 8]] ```","solution":"from itertools import combinations def generate_combinations(arr: list, k: int) -> list: Generate all combinations of length k sorted lexicographically. Params: - arr (list of int): The list of unique integers. - k (int): The length of each combination. Returns: - list of list of int: The sorted list of combinations. arr.sort() return [list(c) for c in combinations(arr, k)]"},{"question":"# Calendar Event Manager You are tasked with creating a utility to manage events in a calendar. The utility should allow adding events, retrieving events occurring on a specific date, and removing events by their IDs. # Function Signature ```python class CalendarEventManager: def __init__(self): self.events = {} def add_event(self, event_date: str, event_name: str, event_description: str) -> int: ... def get_events(self, event_date: str) -> list: ... def remove_event(self, event_id: int) -> bool: ... ``` # Input Descriptions - `event_date` (str): The date of the event in the format \\"YYYY-MM-DD\\". - `event_name` (str): The name of the event. - `event_description` (str): A brief description of the event. - `event_id` (int): A unique integer that identifies an event. # Output Descriptions - `add_event`: Returns an integer representing the unique ID assigned to the added event. - `get_events`: Returns a list of dictionaries representing events scheduled for the given date. Each dictionary contains the keys \\"id\\", \\"name\\", and \\"description\\". - `remove_event`: Returns `True` if the event was successfully removed, and `False` otherwise. # Constraints 1. Ensure the ID of each event is unique. 2. The method `get_events` should return an empty list if there are no events on the specified date. 3. The method `remove_event` should return `False` if an event with the given ID does not exist. # Example ```python calendar = CalendarEventManager() # Add events to the calendar event_id1 = calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") event_id2 = calendar.add_event(\\"2023-11-25\\", \\"Workshop\\", \\"Python programming workshop\\") event_id3 = calendar.add_event(\\"2023-11-26\\", \\"Conference\\", \\"Tech conference\\") # Retrieve events for a specific date events = calendar.get_events(\\"2023-11-25\\") print(events) # Expected result: # [ # {\'id\': event_id1, \'name\': \'Meeting\', \'description\': \'Project status update meeting\'}, # {\'id\': event_id2, \'name\': \'Workshop\', \'description\': \'Python programming workshop\'} # ] # Remove an event result = calendar.remove_event(event_id1) print(result) # Expected result: True # Try to remove the same event again result = calendar.remove_event(event_id1) print(result) # Expected result: False ``` # Additional Information Ensure the class has robust error handling for invalid date formats, unique ID management, and checking for non-existent events during removal attempts.","solution":"class CalendarEventManager: def __init__(self): self.events = {} self.next_id = 1 def add_event(self, event_date: str, event_name: str, event_description: str) -> int: event_id = self.next_id self.next_id += 1 if event_date not in self.events: self.events[event_date] = [] event = { \'id\': event_id, \'name\': event_name, \'description\': event_description } self.events[event_date].append(event) return event_id def get_events(self, event_date: str) -> list: if event_date not in self.events: return [] return self.events[event_date] def remove_event(self, event_id: int) -> bool: for event_date, events in self.events.items(): for event in events: if event[\'id\'] == event_id: events.remove(event) return True return False"},{"question":"# Coding Assessment Question Scenario In a database system, indexing plays a crucial role in efficiently retrieving data. One of the main tasks is determining the number of unique indexes for each category in a given dataset. This data is represented as a list of tuples, where each tuple corresponds to a specific record containing a category and an index. Task Write a function named `count_unique_indexes` that takes a single argument: 1. A list of tuples `records` where each tuple contains two strings: a `category` and an `index`. The function should return a dictionary where the keys are the categories, and the values are the number of unique indexes associated with each category. Input * `records`: A list of tuples, where each tuple contains two strings: - The first string (category) represents the category name. - The second string (index) represents the index name. Output * A dictionary where each key is a category, and the corresponding value is the count of unique indexes in that category. Constraints * Categories and indexes are non-empty strings consisting of alphanumeric characters. * The length of the `records` list is at most (10^6). Function Signature ```python def count_unique_indexes(records: List[Tuple[str, str]]) -> Dict[str, int]: ``` # Example ```python assert count_unique_indexes([ (\\"fruit\\", \\"apple\\"), (\\"fruit\\", \\"banana\\"), (\\"fruit\\", \\"apple\\"), (\\"tech\\", \\"laptop\\"), (\\"tech\\", \\"phone\\"), (\\"fruit\\", \\"cherry\\"), (\\"tech\\", \\"phone\\"), ]) == {\\"fruit\\": 3, \\"tech\\": 2} assert count_unique_indexes([ (\\"book\\", \\"fiction\\"), (\\"book\\", \\"fantasy\\"), (\\"music\\", \\"rock\\"), (\\"music\\", \\"jazz\\"), (\\"book\\", \\"fiction\\"), (\\"music\\", \\"jazz\\"), (\\"book\\", \\"non-fiction\\"), (\\"music\\", \\"pop\\") ]) == {\\"book\\": 3, \\"music\\": 3} ``` Explanation - In the first example, \\"fruit\\" has 3 unique indexes: \\"apple\\", \\"banana\\", and \\"cherry\\". \\"Tech\\" has 2 unique indexes: \\"laptop\\" and \\"phone\\". - In the second example, \\"book\\" category has 3 unique indexes: \\"fiction\\", \\"fantasy\\", and \\"non-fiction\\". \\"Music\\" category has 3 unique indexes: \\"rock\\", \\"jazz\\", and \\"pop\\". Notes - Pay attention to efficiently counting unique indexes in each category given the potentially large size of records. - Use data structures like `set` to help efficiently track unique indexes.","solution":"def count_unique_indexes(records): Returns a dictionary with the count of unique indexes for each category. :param records: A list of tuples, where each tuple contains a category and an index. :type records: List[Tuple[str, str]] :return: A dictionary with categories as keys and counts of unique indexes as values. :rtype: Dict[str, int] from collections import defaultdict category_to_indexes = defaultdict(set) for category, index in records: category_to_indexes[category].add(index) return {category: len(indexes) for category, indexes in category_to_indexes.items()}"},{"question":"# Stock Price Analyzer You have been hired as a software developer for a financial analytics firm. Your task is to develop a script that analyzes stock prices obtained from a public API and provides insights to traders. Requirements: 1. **Function `fetch_stock_prices`**: - Takes a stock symbol and an API key as inputs. - Asynchronously fetches the historical stock prices for the past month from the specified API. - Includes robust error handling for API request failures and parsing errors. - Validates the JSON response to ensure it contains the expected structure. - Returns a list of dictionaries containing `date` and `closing_price`. 2. **Function `calculate_average_closing_price`**: - Takes the list of dictionaries returned by `fetch_stock_prices`. - Calculates and returns the average closing price. 3. **Constraints**: - You must use the `aiohttp` library for making asynchronous requests. - Timeout for the HTTP request should be 5 seconds. - Ensure efficient use of resources and handle potential exceptions gracefully. Input & Output Formats: * The `fetch_stock_prices` function should return a list of dictionaries each containing `date` and `closing_price`. * The `calculate_average_closing_price` function should return a float representing the average closing price. Example: Given a hypothetical API key `\\"test_api_key\\"` and stock symbol `\\"AAPL\\"`, the script should: 1. Fetch the historical stock prices. 2. Handle any potential errors gracefully. 3. Calculate the average closing price. ```python import aiohttp import asyncio _STOCK_API = \\"https://financialmodelingprep.com/api/v3/historical-price-full/\\" async def fetch_stock_prices(stock_symbol: str, stock_api_key: str) -> list: async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{_STOCK_API}{stock_symbol}?apikey={stock_api_key}\\", timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data: {response.status}\\") json_response = await response.json() historical_data = json_response.get(\'historical\', []) return [{\'date\': entry[\'date\'], \'closing_price\': entry[\'close\']} for entry in historical_data] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def calculate_average_closing_price(stock_data: list) -> float: try: if not stock_data: raise ValueError(\\"No stock data available.\\") total = sum(item[\'closing_price\'] for item in stock_data) return total / len(stock_data) except Exception as e: print(f\\"An error occurred while calculating the average: {e}\\") return 0.0 if __name__ == \\"__main__\\": stock_symbol = \\"AAPL\\" api_key = \\"<Your Stock API key goes here>\\" stock_prices = asyncio.run(fetch_stock_prices(stock_symbol, api_key)) average_closing_price = calculate_average_closing_price(stock_prices) print(f\\"Average closing price for {stock_symbol}: {average_closing_price}\\") ```","solution":"import aiohttp import asyncio _API_URL = \\"https://financialmodelingprep.com/api/v3/historical-price-full/\\" async def fetch_stock_prices(stock_symbol: str, stock_api_key: str) -> list: async with aiohttp.ClientSession() as session: try: async with session.get(f\\"{_API_URL}{stock_symbol}?apikey={stock_api_key}\\", timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data: {response.status}\\") json_response = await response.json() historical_data = json_response.get(\'historical\', []) return [{\'date\': entry[\'date\'], \'closing_price\': entry[\'close\']} for entry in historical_data] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def calculate_average_closing_price(stock_data: list) -> float: try: if not stock_data: raise ValueError(\\"No stock data available.\\") total = sum(item[\'closing_price\'] for item in stock_data) return total / len(stock_data) except Exception as e: print(f\\"An error occurred while calculating the average: {e}\\") return 0.0"},{"question":"**Scenario**: You are given the task of calculating the sum of all prime numbers less than or equal to a given limit `n`. This problem will help examine your ability to implement algorithms related to prime numbers and optimize the efficiency for large inputs. **Problem Statement**: Write a function `sum_primes(n: int) -> int` that computes the sum of all prime numbers less than or equal to `n`. # Function Signature ```python def sum_primes(n: int) -> int: ``` # Input * `n` (2 <= n <= 10^6): An integer representing the upper limit for calculating the sum of prime numbers. # Output * An integer representing the sum of all prime numbers less than or equal to `n`. # Constraints * Ensure your solution is efficient and works within an acceptable time limit (ideally O(n log log n) using the Sieve of Eratosthenes algorithm). * Consider edge cases where `n` is a very small prime number. # Example ```python >>> sum_primes(10) 17 # because primes less than or equal to 10 are 2, 3, 5, and 7, and their sum is 17. >>> sum_primes(5) 10 # because primes less than or equal to 5 are 2, 3, and 5, and their sum is 10. >>> sum_primes(2) 2 # because 2 is the only prime number less than or equal to 2. >>> sum_primes(30) 129 # because primes less than or equal to 30 are 2, 3, 5, 7, 11, 13, 17, 19, 23, and 29, and their sum is 129. ``` # Note - Optimize your function to handle input values close to the upper limit efficiently. - Check for correctness by validating the result with different values of `n`.","solution":"def sum_primes(n: int) -> int: Computes the sum of all prime numbers less than or equal to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 prime_sum = sum(i for i, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"RGB Sorting Algorithm **Context**: You are provided with a list of colors represented as \'R\', \'G\', and \'B\', mapping to red, green, and blue respectively. The task is to sort the list so that all \'R\'s come first, followed by \'G\'s and then \'B\'s. **Function Specification**: Write a function `sort_rgb(colors: list[str]) -> list[str]` that sorts the list according to the order \'R\', \'G\', \'B\'. **Input**: - A list of characters where each character is one of [\'R\', \'G\', \'B\']. **Output**: - A list of characters sorted in the order \'R\', \'G\', \'B\'. **Constraints**: - You must sort the list in (O(n)) time complexity. - You cannot use the built-in sort function. - The length of the input list will be between 1 and 10^6 inclusive. **Performance**: - Your solution should handle large lists efficiently in terms of both time and space, maintaining linear time complexity. **Sample Input and Output**: ```python assert sort_rgb([\'G\', \'B\', \'R\', \'R\', \'B\', \'G\']) == [\'R\', \'R\', \'G\', \'G\', \'B\', \'B\'] assert sort_rgb([\'B\', \'G\', \'B\', \'R\', \'G\', \'R\']) == [\'R\', \'R\', \'G\', \'G\', \'B\', \'B\'] assert sort_rgb([\'R\', \'G\', \'R\', \'R\', \'G\', \'G\']) == [\'R\', \'R\', \'R\', \'G\', \'G\', \'G\'] ```","solution":"def sort_rgb(colors): Sorts the list such that all \'R\'s come first, followed by \'G\'s and then \'B\'s. red_count = colors.count(\'R\') green_count = colors.count(\'G\') blue_count = colors.count(\'B\') return [\'R\'] * red_count + [\'G\'] * green_count + [\'B\'] * blue_count"},{"question":"# Problem Statement: Context: A Fibonacci sequence is a series of numbers in which each number (after the first two) is the sum of the two preceding ones. The task is to generate Fibonacci numbers in an optimized manner and effectively identify Fibonacci numbers from a given list with performance considerations. Task: 1. Implement the `generate_fibonacci(n)` function to generate the first `n` Fibonacci numbers while considering memory constraints. 2. Implement the `is_fibonacci_number(x)` function to determine if a provided number is a Fibonacci number using mathematical properties for efficient validation. Function Signature: ```python def generate_fibonacci(n: int) -> list def is_fibonacci_number(x: int) -> bool ``` Input Formats: - `generate_fibonacci(n)`: An integer `n` representing the number of Fibonacci numbers to generate. - `is_fibonacci_number(x)`: An integer `x` to be tested if it belongs to the Fibonacci series. Output Formats: - `generate_fibonacci(n)`: Returns a list of the first `n` Fibonacci numbers. - `is_fibonacci_number(x)`: Returns a boolean value indicating if the number `x` is part of the Fibonacci series. Constraints: - 0 < n <= 1000 - 0 <= x <= 10^10 - Handle large values and edge cases effectively. Example: ```python # Example inputs for generate_fibonacci print(generate_fibonacci(5)) # [0, 1, 1, 2, 3] print(generate_fibonacci(10)) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Example inputs for is_fibonacci_number print(is_fibonacci_number(5)) # True print(is_fibonacci_number(6)) # False print(is_fibonacci_number(21)) # True print(is_fibonacci_number(100)) # False ``` Performance Requirements: - Ensure both functions are optimized for time and space complexity. - Properly handle edge cases and very large integer values. Implementation Details: - The `generate_fibonacci(n)` function should utilize iterative techniques to prevent stack overflow and manage memory efficiently. - The `is_fibonacci_number(x)` function should use mathematical identities, such as checking if `5*x^2 + 4` or `5*x^2 -4` are perfect squares for efficient Fibonacci number verification.","solution":"import math def generate_fibonacci(n: int) -> list: Generates the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate. :return: A list of the first n Fibonacci numbers. if n == 0: return [] fib_sequence = [0, 1] if n == 1: return [0] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence def is_fibonacci_number(x: int) -> bool: Checks if a number is a Fibonacci number. :param x: The number to be checked. :return: True if x is a Fibonacci number, False otherwise. # Returns True if n is a perfect square def is_perfect_square(n): s = int(math.isqrt(n)) return s * s == n # Check the two conditions for x to be a Fibonacci number return is_perfect_square(5 * x * x + 4) or is_perfect_square(5 * x * x - 4)"},{"question":"# Problem Statement You are given a binary search tree (BST) and a target integer `k`. Your task is to implement a function to determine if any two distinct elements in the BST add up to `k`. If such a pair exists, return a tuple of the two values; otherwise, return an empty tuple. # Function Signature ```python def find_pair_with_sum(root: \'TreeNode\', k: int) -> tuple: ``` # Input - `root`: The root of the binary search tree, represented as a `TreeNode` object (defined below). - `k`: An integer representing the target sum. # Output - A tuple of two integers representing the values of the nodes that add up to `k`, or an empty tuple if no such pair exists. # Constraints - The number of nodes in the BST will be in the range [1, 10^4]. - Each node’s value falls within the integer range [-10^5, 10^5]. - All node values in the BST are unique. - You may assume `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Examples ```python # Example 1 # Tree: # 5 # / # 3 6 # / # 2 4 7 root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) k = 9 print(find_pair_with_sum(root, k)) # Output: (2, 7) # Example 2 root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) k = 28 print(find_pair_with_sum(root, k)) # Output: () # Example 3 root = TreeNode(1) k = 2 print(find_pair_with_sum(root, k)) # Output: () # Example 4 # Tree: # 5 # / # 3 6 # / # 2 7 root = TreeNode(5, TreeNode(3, TreeNode(2), None), TreeNode(6, None, TreeNode(7))) k = 9 print(find_pair_with_sum(root, k)) # Output: (2, 7) ``` # Notes 1. The function should return values in ascending order, i.e., (2, 7) instead of (7, 2). 2. You may assume that each value in the BST is unique. 3. The solution should aim for a time complexity better than O(n^2).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_pair_with_sum(root: TreeNode, k: int) -> tuple: def in_order_traverse(node): if not node: return [] return in_order_traverse(node.left) + [node.val] + in_order_traverse(node.right) values = in_order_traverse(root) left, right = 0, len(values) - 1 while left < right: current_sum = values[left] + values[right] if current_sum == k: return (values[left], values[right]) elif current_sum < k: left += 1 else: right -= 1 return ()"},{"question":"# **Rotation Cipher Algorithm** Scenario: You are developing a simple rotation cipher for encoding and decoding text messages. The cipher shifts each character in the alphabet by a fixed number of positions. For example, with a shift of 3, \'a\' becomes \'d\', \'b\' becomes \'e\', and so on. Similarly, the decoding process should return the text to its original form by reversing the shift. Task: Implement two methods, `encode` and `decode`, in a class `RotationCipher`. The `encode` method should convert the input text into a ciphered string by shifting each character by a predefined number of positions. The `decode` method should revert the ciphered string back to the original text by applying the reverse shift. Method Specifications: 1. **encode(text: str, shift: int) -> str** - **Input**: A string `text` to be encoded and an integer `shift` representing the number of positions to shift each character. - **Output**: A string containing the encoded text. 2. **decode(cipher_text: str, shift: int) -> str** - **Input**: A string `cipher_text` representing the encoded text and an integer `shift` used during the encoding process. - **Output**: The original string after decoding the cipher text. Constraints: - The methods should handle both uppercase and lowercase characters, maintaining their cases. - Non-alphabetic characters should remain unchanged. - The `decode` method should apply the reverse of the shift used in `encode`. - The `shift` value can be any integer (both positive and negative). Example: ```python from rotation_cipher import RotationCipher # assume the code is in a file named \'rotation_cipher.py\' # Encoding the text encoded_text = RotationCipher.encode(\\"Hello, World!\\", 3) # Decoding the text decoded_text = RotationCipher.decode(encoded_text, 3) # Check the equality assert decoded_text == \\"Hello, World!\\" ``` Your task is to implement these methods with the given specifications.","solution":"class RotationCipher: @staticmethod def encode(text: str, shift: int) -> str: def shift_character(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_character(c, shift) for c in text) @staticmethod def decode(cipher_text: str, shift: int) -> str: return RotationCipher.encode(cipher_text, -shift)"},{"question":"Palindrome Checker with Wildcards # Scenario You need to create a function that checks if a given string can be rearranged to form a palindrome, where some characters can be replaced by any letter. Such characters are denoted by a wildcard `*`. # Function to Implement Write a function `can_form_palindrome` which takes a single string containing alphabetic characters (both uppercase and lowercase) and/or the wildcard character `*`. The function should determine if it is possible to rearrange the string into a palindrome after replacing the wildcard characters with any alphabetic characters. # Function Signature ```python def can_form_palindrome(s: str) -> bool: pass ``` # Input - A single string `s` containing alphabetic characters (A-Z, a-z) and wildcards `*`. (1 ≤ len(s) ≤ 1000) # Output - A boolean indicating whether it is possible to rearrange the string into a palindrome after replacing the wildcard characters with any alphabetic characters. # Constraints - The function should treat uppercase and lowercase letters as different characters. - You need to handle strings efficiently for their length constraint. - All special characters in the input string are valid wildcards or alphabetic characters. # Example ```python can_form_palindrome(\\"a*ba*\\") ``` Output: ```python True ``` ```python can_form_palindrome(\\"abc*ba\\") ``` Output: ```python True ``` ```python can_form_palindrome(\\"abcd*ba\\") ``` Output: ```python False ``` # Notes - A palindrome reads the same forwards and backwards (e.g., \\"racecar\\", \\"level\\"). - If the original string without wildcards can already be rearranged into a palindrome, the function should return True. - If the number of needed wildcard replacements is greater than the number of wildcards available, the function should return False.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: # Count the occurrences of each character char_count = Counter(s) # Count the number of odd occurrences of characters (ignoring wildcards) odd_count = sum(1 for count in char_count.values() if count % 2 != 0 and count != \'*\') # Count the number of wildcards wildcard_count = char_count.get(\'*\', 0) # For the string to be rearranged into a palindrome: # If the length of the string is even, all characters must have even counts # If the length is odd, exactly one character can have an odd count # Wildcards can be used to balance characters to make all counts even or one count odd # If the odd_count is less than or equal to the wildcard_count + 1 (for odd length palindrome) # or odd_count is less than or equal to wildcard_count (for even length palindrome), # then it is possible to rearrange the string into a palindrome if odd_count <= wildcard_count + 1: return True else: return False"},{"question":"# Store and Display Weather Data Scenario: You are working on a weather application that needs to store weather data for a list of cities and display the current temperature of a city when queried. This will help users to get quick updates on the weather in their city. Task: Write a Python class `WeatherApp` that encapsulates the operations of storing weather data for multiple cities and retrieving the current temperature for a given city. The application should be flexible enough to accommodate updates to weather data. Requirements: 1. The class should initialize with an empty dictionary to hold the weather data. 2. Implement a method `add_city_weather(city_name: str, temperature: float) -> None` to add or update the weather data for a city. 3. Implement a method `get_city_temperature(city_name: str) -> Optional[float]` to retrieve the current temperature of a specified city. 4. Implement a method `remove_city_weather(city_name: str) -> bool` to remove the weather data for a specified city if it exists. 5. Ensure that the class handles cities with and without existing weather data gracefully. # Class Signature ```python class WeatherApp: def __init__(self): pass def add_city_weather(self, city_name: str, temperature: float) -> None: pass def get_city_temperature(self, city_name: str) -> Optional[float]: pass def remove_city_weather(self, city_name: str) -> bool: pass ``` Input * `city_name`: A string representing the city name (e.g., \\"San Francisco\\"). * `temperature`: A float representing the current temperature in Celsius. Constraints * City names should be case-insensitive. * Temperatures should be stored in Celsius and can range from -50.0 to 50.0. * If querying a city with no stored weather data, `get_city_temperature` should return `None`. Output * `add_city_weather`: It should update the weather data but does not return anything. * `get_city_temperature`: It should return the temperature as a float or `None` if the city is not found. * `remove_city_weather`: It should return `True` if the city was found and removed, otherwise `False`. Notes * The solution should ensure efficient data storage and retrieval operations. * Proper exception handling should be in place to handle edge cases. # Example Usage ```python app = WeatherApp() app.add_city_weather(\\"Paris\\", 15.5) print(app.get_city_temperature(\\"paris\\")) # Output: 15.5 print(app.get_city_temperature(\\"London\\")) # Output: None app.add_city_weather(\\"London\\", 10.0) print(app.get_city_temperature(\\"London\\")) # Output: 10.0 print(app.remove_city_weather(\\"London\\")) # Output: True print(app.get_city_temperature(\\"London\\")) # Output: None ```","solution":"from typing import Optional class WeatherApp: def __init__(self): self.weather_data = {} def add_city_weather(self, city_name: str, temperature: float) -> None: self.weather_data[city_name.lower()] = temperature def get_city_temperature(self, city_name: str) -> Optional[float]: return self.weather_data.get(city_name.lower()) def remove_city_weather(self, city_name: str) -> bool: if city_name.lower() in self.weather_data: del self.weather_data[city_name.lower()] return True return False"},{"question":"**Problem Statement: Efficient String Manipulation for CamelCase Conversion** Your task is to write a function that converts a given string in snake_case format to camelCase format. This function should efficiently handle strings with different types of characters and lengths, ensuring a smooth conversion process. # Function Signature ```python def snake_to_camel(s :str) -> str: Convert the string s from snake_case to camelCase. Parameters: s (str): The input string in snake_case format. Returns: str: The string in camelCase format. ``` # Requirements 1. The function should handle strings of various lengths, including an empty string. 2. It should correctly process strings with multiple underscores, including leading and trailing underscores. 3. The function must preserve the case of the initial characters appropriately. 4. The function should not use any external libraries for string manipulation. # Input Format - A single string, `s`, which is in snake_case format. # Output Format - A single string converted to camelCase format. # Constraints - The input string, `s`, should consist of lowercase letters and underscore characters `a-z` and `_`. # Example ```python >>> snake_to_camel(\\"hello_world\\") \\"helloWorld\\" >>> snake_to_camel(\\"convert_this_string_to_camel_case\\") \\"convertThisStringToCamelCase\\" >>> snake_to_camel(\\"example\\") \\"example\\" >>> snake_to_camel(\\"\\") \\"\\" >>> snake_to_camel(\\"___multiple___underscores__\\") \\"multipleUnderscores\\" ``` Provide clear documentation of your approach and include at least 5 test cases, ensuring to cover typical cases, boundary cases, and edge cases to demonstrate the function\'s correctness and robustness.","solution":"def snake_to_camel(s: str) -> str: Convert the string s from snake_case to camelCase. Parameters: s (str): The input string in snake_case format. Returns: str: The string in camelCase format. if not s: return s # Split the string into parts based on underscores and remove empty parts parts = [part for part in s.split(\'_\') if part] # Initialize the camelCase string with the first part camel_case = parts[0] if parts else \\"\\" # Convert following parts to Capitalized form and concatenate them for part in parts[1:]: camel_case += part.capitalize() return camel_case"},{"question":"# Coding Assessment Question Scenario You have been given the responsibility to extend a small mathematical computation library used in signal processing. One of the new functionalities needed is the ability to compute the greatest common divisor (GCD) of two large numbers using an efficient recursive approach. Problem Statement Implement a function `gcd_recursive(a: int, b: int) -> int` where: * `a` and `b` are the two non-negative integers for which the GCD has to be computed. The function should return the greatest common divisor of `a` and `b`. Implementation Details: * **Input Format**: - `a` and `b` are non-negative integers: 0 ≤ a, b ≤ 10^12. * **Output Format**: - Return an integer representing the greatest common divisor of `a` and `b`. * **Performance Requirements**: - Ensure the function is highly efficient and can handle the upper limit of the input constraints within a reasonable time frame. - Use the Euclidean algorithm for computing the GCD recursively, which ensures optimal performance. Additional Constraints: * Handle the case where either `a` or `b` is zero. * Ensure there are no unnecessary repeated calculations. Example: * Example 1: ```python >>> gcd_recursive(48, 18) 6 ``` Explanation: The GCD of 48 and 18 is 6. * Example 2: ```python >>> gcd_recursive(270, 192) 6 ``` Explanation: The GCD of 270 and 192 is 6. * Example 3: ```python >>> gcd_recursive(0, 25) 25 ``` Explanation: The GCD of 0 and 25 is 25 because any number\'s GCD with 0 is the number itself. * Example 4: ```python >>> gcd_recursive(17, 13) 1 ``` Explanation: The GCD of 17 and 13 is 1 as they are coprime. Notes: * Include basic error handling and ensure that inputs fall within the specified constraints. * Document the base case and recursive case assumptions in your implementation.","solution":"def gcd_recursive(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm recursively. Parameters: - a: int, a non-negative integer - b: int, a non-negative integer Returns: - int, the greatest common divisor of `a` and `b` if b == 0: return a return gcd_recursive(b, a % b)"},{"question":"# Coding Assessment Question Problem Statement Write a function `find_longest_arith_seq(arr: List[int]) -> int` that determines the length of the longest arithmetic subsequence in a given list of integers. # Function Signature ```python def find_longest_arith_seq(arr: List[int]) -> int: ``` # Input * `arr` (1 ≤ len(arr) ≤ 1000, -10^4 ≤ arr[i] ≤ 10^4): A list of integers. # Output * Returns an integer representing the length of the longest arithmetic subsequence found in the list. # Constraints * An arithmetic subsequence is a sequence of numbers such that the difference between consecutive elements is constant. * The elements of the subsequence do not need to be contiguous in the list. # Performance Requirements * Aim for `O(n^2)` in time complexity for the solution. # Example ```python assert find_longest_arith_seq([3, 6, 9, 12]) == 4 assert find_longest_arith_seq([9, 4, 7, 2, 10]) == 3 ``` # Implementation Notes 1. **Dynamic Programming**: Use a 2D array or dictionary to store the length of the longest arithmetic subsequence ending at each index with every possible difference. 2. **Traversal**: Iterate over pairs of elements to calculate and update the lengths of subsequences. 3. **Result Extraction**: Traverse the DP structure to find and return the maximum length found.","solution":"from typing import List from collections import defaultdict def find_longest_arith_seq(arr: List[int]) -> int: # If the array length is 1 or less, return the length of the array. if len(arr) <= 1: return len(arr) # Use a dictionary to store the lengths of the arithmetic sequences. dp = [defaultdict(int) for _ in range(len(arr))] max_length = 2 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] # Update the dp array with the maximum length of sequence ending at i with difference diff if diff in dp[j]: dp[i][diff] = max(dp[i][diff], dp[j][diff] + 1) else: dp[i][diff] = 2 # Update the maximum length found so far max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"# Largest Connected Component in a Graph Given an undirected graph represented as an adjacency matrix, you are tasked with implementing a function that finds the largest connected component in the graph. A connected component in a graph is a set of vertices such that there is a path between any two vertices in this set, and no vertex in the set is connected to a vertex outside of the set. Function Signature ```python def largest_connected_component(adj_matrix: list) -> int: pass ``` Input * `adj_matrix` (list of list of int): A 2D list representing the adjacency matrix of the undirected graph. Output * `int`: The size of the largest connected component in the graph. Constraints * The adjacency matrix will contain only 0s and 1s. * The size of the adjacency matrix will be between 1x1 and 100x100 (inclusive). Example ```python >>> largest_connected_component([ [0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0] ]) 4 >>> largest_connected_component([ [0, 1], [1, 0] ]) 2 >>> largest_connected_component([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 1 ``` Instructions 1. Implement a function to find and count the number of vertices in each connected component. 2. Use Depth First Search (DFS) or Breadth First Search (BFS) to explore the graph. 3. Ensure that each vertex is only visited once for efficiency. 4. Return the size of the largest connected component found.","solution":"def largest_connected_component(adj_matrix): def dfs(node): stack = [node] count = 0 while stack: cur = stack.pop() if not visited[cur]: visited[cur] = True count += 1 for neighbor in range(len(adj_matrix)): if adj_matrix[cur][neighbor] == 1 and not visited[neighbor]: stack.append(neighbor) return count n = len(adj_matrix) visited = [False] * n largest = 0 for i in range(n): if not visited[i]: component_size = dfs(i) largest = max(largest, component_size) return largest"},{"question":"# **Graph Shortest Path Optimization** You are tasked with optimizing a delivery route in a city represented by a graph where intersections are nodes and roads are edges. The graph is weighted, and the weights represent the travel times between intersections. You need to implement an algorithm to find the shortest path from a central warehouse to multiple delivery locations. # Task 1. **Implement Dijkstra\'s Algorithm**: Write a function to find the shortest path from the warehouse to each delivery location. 2. **Optimize for Multiple Deliveries**: Modify the function so that it handles multiple destinations by computing the shortest path from the warehouse to each delivery point in an efficient manner. # Function Signature Implement the function using the signature below: ```python def optimize_delivery_routes(num_nodes: int, edges: list[tuple[int, int, int]], start: int, destinations: list[int]) -> list[int]: pass ``` # Input - **num_nodes**: Integer representing the total number of intersections in the city. - **edges**: List of tuples (u, v, w) where `u` and `v` are intersections connected by a road with travel time `w`. - **start**: Integer representing the starting intersection (warehouse). - **destinations**: List of integers representing intersections where deliveries need to be made. # Output - Return a list of integers representing the shortest travel times from the \'start\' intersection to each of the \'destinations\' intersections in the same order as given in the input. # Constraints - `1 <= num_nodes <= 1000` - `0 <= w <= 1000` (weights are non-negative) - Each node is connected to at least one other node. - There are no self-loops or multiple edges between any pair of nodes. # Example ```python num_nodes = 5 edges = [(0, 1, 10), (0, 2, 5), (1, 2, 2), (1, 3, 1), (2, 1, 3), (2, 3, 9), (2, 4, 2), (3, 4, 4), (4, 3, 6)] start = 0 destinations = [3, 4] # Expected Output: [9, 7] print(optimize_delivery_routes(num_nodes, edges, start, destinations)) ``` # Notes - Utilize a priority queue (heap) to efficiently implement Dijkstra\'s algorithm. - Ensure your solution scales well with the constraints provided. - Validate with multiple test cases to ensure correctness and efficiency of your solution.","solution":"import heapq from collections import defaultdict import sys def optimize_delivery_routes(num_nodes, edges, start, destinations): def dijkstra(start): distances = {node: float(\'inf\') for node in range(num_nodes)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Build the graph graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Get the shortest distances from the start node to all other nodes shortest_distances = dijkstra(start) # Extract the distances to the required destinations result = [shortest_distances[d] for d in destinations] return result"},{"question":"# Coding Assessment Question: Minimum Edit Distance Context You are developing a text editor that provides suggestions for corrections by determining the similarity between words. To achieve this, you need to calculate the minimum number of operations required to transform one string into another. The allowed operations are insertion, deletion, and substitution of a single character. Task Write a function `min_edit_distance(str1, str2)` that takes two strings: * `str1` (the original word) * `str2` (the target word) The function should return an integer representing the minimum number of operations required to convert `str1` into `str2`. Constraints 1. `1 <= len(str1), len(str2) <= 500` 2. Both strings consist of lowercase English letters only. Requirements 1. Use dynamic programming to efficiently compute the minimum edit distance. 2. Ensure the solution works within a reasonable time frame for the given constraints. Example ```python def min_edit_distance(str1, str2): # your implementation here # Example usage print(min_edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(min_edit_distance(\\"flaw\\", \\"lawn\\")) # Output: 2 print(min_edit_distance(\\"intention\\", \\"execution\\")) # Output: 5 ``` # Hints * Consider a 2D table where `dp[i][j]` represents the edit distance between the first `i` characters of `str1` and the first `j` characters of `str2`. * Use the following recurrence relations to populate the table: * `dp[i][0] = i` (deleting all characters from `str1`) * `dp[0][j] = j` (inserting all characters into `str2`) * If `str1[i-1] == str2[j-1]`, then `dp[i][j] = dp[i-1][j-1]` * If `str1[i-1] != str2[j-1]`, then `dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])`","solution":"def min_edit_distance(str1, str2): Returns the minimum number of operations required to transform str1 into str2. Operations allowed are insertion, deletion, and substitution of a single character. m, n = len(str1), len(str2) # Create a dp array to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # i deletions for j in range(n + 1): dp[0][j] = j # j insertions for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j - 1], # substitution dp[i - 1][j], # deletion dp[i][j - 1]) # insertion return dp[m][n]"},{"question":"# Calendar Date Calculator **Objective:** Write a function that calculates the date after adding a specific number of days to a given date. **Function Signature:** ```python def calculate_date(start_date: str, days_to_add: int) -> str: ... ``` **Input:** * `start_date` (str): The starting date as a string in the format \\"YYYY-MM-DD\\". * `days_to_add` (int): The number of days to add to the `start_date`. **Output:** * Returns a string representing the new date in the format \\"YYYY-MM-DD\\". **Constraints:** * The input date will be a valid date. * The number of days to add can be positive, negative, or zero. * Consider leap years and varying days in months. * Assume the input date and the number of days to add will not result in a date outside the practical computational range of dates (i.e., within the year 1000 to 3000). **Examples:** ```python # Example 1 start_date = \\"2023-03-01\\" days_to_add = 5 print(calculate_date(start_date, days_to_add)) # Output: \\"2023-03-06\\" # Example 2 start_date = \\"2021-12-31\\" days_to_add = 1 print(calculate_date(start_date, days_to_add)) # Output: \\"2022-01-01\\" # Example 3 start_date = \\"2019-02-28\\" days_to_add = 1 print(calculate_date(start_date, days_to_add)) # Output: \\"2019-03-01\\" # Example 4 start_date = \\"2020-02-28\\" days_to_add = 1 print(calculate_date(start_date, days_to_add)) # Output: \\"2020-02-29\\" # Example 5 start_date = \\"2023-01-01\\" days_to_add = -1 print(calculate_date(start_date, days_to_add)) # Output: \\"2022-12-31\\" ``` **Scenario:** You are developing a scheduling application that needs to calculate future or past dates to set reminders, schedule tasks, or manage timelines for various projects. Implement the date calculation function that accurately determines the new date when adding or subtracting days from a given start date, and ensure it handles edge cases, including leap years and month transitions properly.","solution":"from datetime import datetime, timedelta def calculate_date(start_date: str, days_to_add: int) -> str: Calculates the date after adding a specific number of days to a given date. Parameters: start_date (str): The starting date as a string in the format \\"YYYY-MM-DD\\". days_to_add (int): The number of days to add to the start_date. Returns: str: The resulting date in the format \\"YYYY-MM-DD\\". start_date_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") new_date_dt = start_date_dt + timedelta(days=days_to_add) return new_date_dt.strftime(\\"%Y-%m-%d\\")"},{"question":"# Problem Statement You need to implement a system that tracks the visitors in a museum. Each visitor\'s entry and exit times are recorded, and the system should be able to report the number of visitors at any given time. # Requirements 1. **Log Entry/Exit Time**: Define functionality to log the entry and exit times for each visitor. 2. **Query Visitor Count**: Implement the functionality to query the number of visitors at a specific time. Implement a class `MuseumTracker` with the following methods: * `log_entry_exit(self, entry_time: str, exit_time: str) -> None`: Log the entry and exit times for a visitor. * `query_visitors(self, time: str) -> int`: Query the number of visitors present in the museum at a given time. # Input and Output Formats 1. **log_entry_exit** * **Input**: `entry_time` and `exit_time` as strings in \\"HH:MM\\" format. * **Output**: None. 2. **query_visitors** * **Input**: Time as a string in \\"HH:MM\\" format. * **Output**: Integer representing the number of visitors present at the given time. # Example ```python tracker = MuseumTracker() # Log Entry/Exit Times tracker.log_entry_exit(\\"10:00\\", \\"12:00\\") tracker.log_entry_exit(\\"11:00\\", \\"13:00\\") tracker.log_entry_exit(\\"12:30\\", \\"14:00\\") # Query Visitors assert tracker.query_visitors(\\"10:30\\") == 1 assert tracker.query_visitors(\\"11:30\\") == 2 assert tracker.query_visitors(\\"12:30\\") == 2 assert tracker.query_visitors(\\"13:30\\") == 1 assert tracker.query_visitors(\\"14:30\\") == 0 ``` # Constraints: * `entry_time` and `exit_time` are always in the \\"HH:MM\\" format and within 24-hour time (00:00 to 23:59). * The `entry_time` will always be less than `exit_time`. * Multiple visitors can enter and exit at the same times. # Notes: - The times are within the same day. - Consider using a list to store entry and exit times and iterate over it to count visitors during the queries efficiently.","solution":"class MuseumTracker: def __init__(self): self.visitors = [] def log_entry_exit(self, entry_time: str, exit_time: str) -> None: self.visitors.append((entry_time, exit_time)) def query_visitors(self, time: str) -> int: count = 0 for entry_time, exit_time in self.visitors: if entry_time <= time < exit_time: count += 1 return count"},{"question":"# Question: Calculate Simple Interest **Objective:** Write a function to calculate simple interest for a given set of parameters: principal amount, rate of interest, and time period. **Function Signature:** ```python def calculate_simple_interest(principal: float, rate: float, time: float) -> float: ... ``` **Function Description:** - The function takes three float arguments: principal, rate, and time. - Using the formula `Simple Interest = (Principal * Rate * Time) / 100`, the function calculates and returns the simple interest. **Constraints:** - All input values (principal, rate, and time) must be non-negative. - If any of the input values are negative, the function must raise a `ValueError` with the message \\"Inputs must be non-negative\\". **Input:** - `principal`: a float representing the principal amount. - `rate`: a float representing the annual rate of interest in percentage. - `time`: a float representing the time period in years. **Output:** - A float representing the calculated simple interest. **Example:** ```python >>> calculate_simple_interest(principal=1000, rate=5, time=2) 100.0 >>> calculate_simple_interest(principal=1500, rate=3.5, time=3) 157.5 >>> calculate_simple_interest(principal=2000, rate=4, time=1.5) 120.0 ``` **Error Handling:** - If `principal`, `rate`, or `time` are negative, raise `ValueError(\\"Inputs must be non-negative\\")`. **Note:** Make sure to include test cases to handle edge cases and validate that your implementation handles invalid inputs appropriately.","solution":"def calculate_simple_interest(principal: float, rate: float, time: float) -> float: if principal < 0 or rate < 0 or time < 0: raise ValueError(\\"Inputs must be non-negative\\") simple_interest = (principal * rate * time) / 100 return simple_interest"},{"question":"# Array Product Problem Statement Given an array of integers, write a function `array_product` that returns a new array such that each element at index `i` of the new array is the product of all the elements in the original array except the one at `i`. Function Signature ```python def array_product(array: list[int]) -> list[int]: ``` Input - An array of integers `array` with: - 1 ≤ len(array) ≤ 1000 - -10^9 ≤ array[i] ≤ 10^9 Output - A list of integers representing the product of all elements in the given array except the one at each index `i`. Examples ```python >>> array_product([1, 2, 3, 4]) [24, 12, 8, 6] >>> array_product([5, 10, 2, 4, 1]) [80, 40, 200, 100, 400] >>> array_product([4, 3, 2, 1, 0]) [0, 0, 0, 0, 24] >>> array_product([2, 2, 2, 2]) [8, 8, 8, 8] >>> array_product([1]) [1] ``` Constraints and Expectations - Your solution should handle arrays with a single element by returning a list containing only that element. - Be mindful of potential overflow issues with large integer values, and ensure the function executes efficiently even with the maximum input size. - Avoid division to achieve the desired result, considering edge cases such as arrays containing zero. Notes - Implement the function in a way that makes use of additional space efficiently while keeping the overall time complexity as optimal as possible. - Think about using prefix and suffix products for an optimal solution without using extra division operations.","solution":"def array_product(array: list[int]) -> list[int]: n = len(array) if n == 1: return [1] # Initialize arrays to hold prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i-1] * array[i-1] # Calculate suffix products for i in range(n-2, -1, -1): suffix_products[i] = suffix_products[i+1] * array[i+1] # Calculate the result by multiplying prefix and suffix products result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"# Problem Statement You are developing a navigation system for a theme park that includes several attractions connected by paths. Each attraction can be represented as a node in a graph, and each path can be represented as an edge with a given distance. To optimize travel time within the park, the system needs to calculate the shortest path between any two attractions. Write a function that, given the number of attractions, the list of paths with distances, and the specific starting and ending attractions, returns the shortest distance between the starting and ending attractions using Dijkstra\'s algorithm. # Task Write a function `shortest_path_in_theme_park` that takes four arguments: 1. An integer \'num_attractions\' representing the number of attractions (nodes). 2. A list of tuples \'paths\', where each tuple contains three integers (u, v, d). Here (u, v) represents an edge between attractions u and v, and d represents the distance between them. 3. An integer \'start\' representing the starting attraction. 4. An integer \'end\' representing the ending attraction. The function should return the shortest distance between the start and end attractions. # Function Signature ```python def shortest_path_in_theme_park(num_attractions: int, paths: List[Tuple[int, int, int]], start: int, end: int) -> int: ``` # Input - `num_attractions` (1 ≤ num_attractions ≤ 1000): The number of attractions in the park. - `paths` (0 ≤ len(paths) ≤ 5000): A list of tuples, where each tuple contains three integers (u, v, d) representing a path from attraction u to attraction v with distance d (1 ≤ d ≤ 1000). - `start` (1 ≤ start ≤ num_attractions): The starting attraction. - `end` (1 ≤ end ≤ num_attractions): The ending attraction. # Output - Returns an integer representing the shortest distance between the start and end attractions. # Example ```python shortest_path_in_theme_park( num_attractions=5, paths=[ (1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 2) ], start=1, end=5 ) # Output: 8 ``` # Constraints & Considerations - Ensure that the function efficiently handles the entire range of possible inputs. - Consider edge cases such as: - No paths at all. - Disconnected attractions where the end attraction cannot be reached from the start attraction. - Multiple paths between the same pair of attractions with different distances. - Utilize appropriate data structures to optimize the performance of Dijkstra\'s algorithm, such as priority queues. # Scenario Imagine you are creating a navigation app for a popular theme park. The app needs to provide visitors with the shortest walking path between attractions to improve their experience. Your solution will help ensure they spend less time traveling and more time enjoying the attractions. The code you write is foundational to achieving these goals efficiently and reliably.","solution":"import heapq def shortest_path_in_theme_park(num_attractions, paths, start, end): # Create a graph from paths graph = {i: [] for i in range(1, num_attractions + 1)} for u, v, d in paths: graph[u].append((d, v)) graph[v].append((d, u)) # Initialize Dijkstra\'s algorithm priority_queue = [(0, start)] shortest_distances = {i: float(\'inf\') for i in range(1, num_attractions + 1)} shortest_distances[start] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: return current_distance if current_distance > shortest_distances[current_node]: continue for distance, neighbor in graph[current_node]: distance_via_current = current_distance + distance if distance_via_current < shortest_distances[neighbor]: shortest_distances[neighbor] = distance_via_current heapq.heappush(priority_queue, (distance_via_current, neighbor)) return -1 if shortest_distances[end] == float(\'inf\') else shortest_distances[end]"},{"question":"# Problem Statement **Linked List Reordering** You are provided with a singly linked list, and your task is to reorder the list in a specific pattern. The pattern involves placing the first node, then the last node, then the second node, then the second last node, and so on. # Requirements: 1. You need to implement the `ReorderLinkedList` class. 2. The class should reorder the linked list as described. # Implementation Details: - Implement the following methods: 1. `__init__(self, head: Optional[ListNode])` - Initializes the `ReorderLinkedList` with the given head of the linked list. 2. `reorder(self) -> Optional[ListNode]` - Reorders the linked list in place to follow the described pattern. 3. `print_list(self) -> None` - Prints the reordered list for verification purposes (optional but recommended for debugging). # Expected Input and Output - **Input**: - A head of the singly linked list with nodes defined as `ListNode(val)` - **Output**: - The head of the reordered linked list # Constraints: - The list should contain at least one element. - The node values are integers and are provided in no particular order. - Your solution should not involve copying the nodes into another data structure; instead, it should perform the reorder in place. # Sample Usage: ```python class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next class ReorderLinkedList: def __init__(self, head: Optional[ListNode]): self.head = head def reorder(self) -> Optional[ListNode]: if not self.head or not self.head.next: return self.head # Split list into two halves slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next first_half, second_half = self.head, slow.next slow.next = None # Reverse second half prev, curr = None, second_half while curr: next_temp = curr.next curr.next = prev prev, curr = curr, next_temp second_half = prev # Merge two halves\' nodes alternately first, second = first_half, second_half while second: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2 return self.head def print_list(self) -> None: node = self.head while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") # Sample linked list creation head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) # Reordering and printing reorder_list = ReorderLinkedList(head) reorder_list.reorder() reorder_list.print_list() # Expected output: 1 -> 5 -> 2 -> 4 -> 3 -> None ``` # Note: This problem assumes the input linked list nodes are already defined and linked together. Make sure to handle edge cases such as empty lists and lists with a single node gracefully. This exercise tests your ability to manipulate linked list pointers and understand in-place modifications.","solution":"class ListNode: def __init__(self, val: int = 0, next: \'ListNode\' = None): self.val = val self.next = next class ReorderLinkedList: def __init__(self, head: ListNode): self.head = head def reorder(self) -> ListNode: if not self.head or not self.head.next: return self.head # Step 1: Split the list into two halves slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next second_half = slow.next slow.next = None first_half = self.head # Step 2: Reverse the second half prev, curr = None, second_half while curr: next_temp = curr.next curr.next = prev prev, curr = curr, next_temp second_half = prev # Step 3: Merge two halves alternatingly first, second = first_half, second_half while second: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2 return self.head def linked_list_to_list(head: ListNode) -> list: result = [] current = head while current: result.append(current.val) current = current.next return result def list_to_linked_list(lst: list) -> ListNode: if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head"},{"question":"# Coding Assessment Question: Sorting a Linked List in Place **Problem Statement**: You are tasked with implementing an algorithm to sort a singly linked list in ascending order. A linked list is a data structure composed of nodes where each node contains a value and a reference (or link) to the next node in the sequence. Your function should perform the sorting in place, that is, it should not use additional space for a new list but adjust the links between the nodes themselves. Implement a function `sort_linked_list` which takes the head of a linked list as input and returns the head of the sorted linked list. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sort_linked_list(head: ListNode) -> ListNode: pass ``` **Expected Inputs**: - `head` (`ListNode`): The head node of the linked list. **Expected Outputs**: - Returns the head node of the sorted linked list (`ListNode`). **Constraints**: - The number of nodes in the linked list is in the range `[0, 5000]`. - The value of each node in the linked list is an integer in the range `[-10^4, 10^4]`. **Examples**: 1. Given linked list: `4 -> 2 -> 1 -> 3` - Calling `sort_linked_list(head)` should transform the linked list to `1 -> 2 -> 3 -> 4`. 2. Given linked list: `-1 -> 5 -> 3 -> 4 -> 0` - Calling `sort_linked_list(head)` should transform the linked list to `-1 -> 0 -> 3 -> 4 -> 5`. **Requirements**: - Ensure Doctest is used to validate the function automatically. - Handle edge cases like empty linked list `{}`, and linked lists with one node gracefully. - Optimal solutions should strive for O(n log n) time complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort(head): if not head or not head.next: return head def split_list(head): slow, fast = head, head pre_slow = None while fast and fast.next: pre_slow, slow, fast = slow, slow.next, fast.next.next mid = slow pre_slow.next = None return head, mid def merge_lists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val <= l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next left, right = split_list(head) left = merge_sort(left) right = merge_sort(right) return merge_lists(left, right) def sort_linked_list(head: ListNode) -> ListNode: return merge_sort(head)"},{"question":"# Question: CSV File Parsing and Summarization You are required to implement functions to parse a CSV (Comma-Separated Values) file, extract specific data, and calculate summary statistics. Function 1: `read_csv_file_to_list` Implement the function `read_csv_file_to_list(file_path: str) -> list[list[str]]`. **Input:** - `file_path`: A string representing the path to a CSV file. **Output:** - A list of lists where each inner list represents a row from the CSV file, with each element in the inner list representing a cell\'s value as a string. **Constraints:** - Assume the CSV file has a header row and at least one data row. - The CSV file is properly formatted with values separated by commas. **Example:** ```python # CSV file content: # Name,Age,Department # Alice,30,HR # Bob,25,IT assert read_csv_file_to_list(\\"employees.csv\\") == [ [\\"Name\\", \\"Age\\", \\"Department\\"], [\\"Alice\\", \\"30\\", \\"HR\\"], [\\"Bob\\", \\"25\\", \\"IT\\"] ] ``` Function 2: `calculate_average_age` Implement the function `calculate_average_age(data: list[list[str]]) -> float`. **Input:** - `data`: A list of lists, where each inner list represents a row of the CSV file, including a header row. **Output:** - A floating-point number representing the average age of employees. **Constraints:** - The header row will always contain the column \\"Age\\". - All age values are valid integers. **Example:** ```python assert calculate_average_age([ [\\"Name\\", \\"Age\\", \\"Department\\"], [\\"Alice\\", \\"30\\", \\"HR\\"], [\\"Bob\\", \\"25\\", \\"IT\\"] ]) == 27.5 ``` Edge Cases to Consider: - Functions should handle an empty file or files with no data rows gracefully. - `calculate_average_age` should ignore the header row and compute the average correctly even if some rows are missing the Age value (e.g., handle such cases as if they do not exist).","solution":"import csv def read_csv_file_to_list(file_path: str) -> list[list[str]]: Reads a CSV file and returns its content as a list of lists. Each inner list represents a row from the CSV file. data = [] with open(file_path, newline=\'\') as csvfile: csvreader = csv.reader(csvfile) for row in csvreader: data.append(row) return data def calculate_average_age(data: list[list[str]]) -> float: Calculates the average age from a list of lists. The first row is assumed to be the header that contains an \\"Age\\" column. age_index = data[0].index(\\"Age\\") total_age = 0 count = 0 for row in data[1:]: # Skip the header row try: age = int(row[age_index]) total_age += age count += 1 except (ValueError, IndexError): continue # Skip rows where age is missing or invalid return total_age / count if count > 0 else 0.0"},{"question":"# Coding Question Objective Write a Python function that takes a string as input and returns the first non-repeating character, considering all unicode characters and punctuation. # Function Signature ```python def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the string. If no such character exists, return an empty string. ``` # Input * A string `input_str` containing any characters including unicode and punctuations. # Output * Return the first non-repeating character as a string. * If there is no non-repeating character, return an empty string. # Constraints * Handle case insensitivity. # Examples ```python print(first_non_repeating_char(\'Swiss\')) # \'S\' print(first_non_repeating_char(\'Hello!\')) # \'H\' print(first_non_repeating_char(\'!!\')) # \'\' print(first_non_repeating_char(\'Alphabet!!\')) # \'A\' print(first_non_repeating_char(\'你好你好\')) # \'\' ``` Requirements - Implement the function considering all edge cases discussed. - Ensure efficient performance, ideally O(n) time complexity. - Include a main block to read input string and print the first non-repeating character.","solution":"def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the string. If no such character exists, return an empty string. from collections import Counter # Create a counter for all characters in the string char_count = Counter(input_str) # Iterate over the string and return the first character with count 1 for char in input_str: if char_count[char] == 1: return char # No non-repeating character found return \'\'"},{"question":"Write a function that generates a sequence of Fibonacci numbers up to the nth number specified by the user. Fibonacci numbers start with two 1s, and each subsequent number is the sum of the two preceding numbers. # Requirements: Implement a function `generate_fibonacci(n: int) -> list[int]` with the following parameter: * `n` (int): The number of Fibonacci numbers to generate. (1 ≤ n ≤ 10^7) # Expected Output: The function should return a list of the first `n` Fibonacci numbers. # Constraints: * If `n` is 0 or negative, return an empty list. * The implementation should handle large values of `n` efficiently in terms of time complexity. # Examples: ```python >>> generate_fibonacci(5) [1, 1, 2, 3, 5] >>> generate_fibonacci(1) [1] >>> generate_fibonacci(10) [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> generate_fibonacci(0) [] >>> generate_fibonacci(-5) [] ``` # Performance Considerations: Ensure the implementation can handle the potential upper limits of input sizes efficiently in terms of both time and space. Consider using an iterative approach rather than a recursive one to avoid stack overflow errors for very large `n`. # Notes: - Make sure to validate the input parameter `n` to meet the constraints. - Aim for the function to run in O(n) time complexity.","solution":"def generate_fibonacci(n: int) -> list[int]: Generates a sequence of up to the nth Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: list[int]: A list containing the first n Fibonacci numbers. if n <= 0: return [] # Initial two Fibonacci numbers fibonacci_sequence = [1] if n == 1: return fibonacci_sequence fibonacci_sequence.append(1) for i in range(2, n): next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return fibonacci_sequence"},{"question":"# Sort Custom Objects by Date Objective: To demonstrate the ability to work with custom Python objects, string parsing, and sorting algorithms. Problem Description: You are tasked with writing a function `sort_objects(objects: list) -> list` that takes a list of objects and returns a list of these objects sorted by a date attribute. Each object in the input list has two string attributes: `name` and `date`, where `date` is represented as a string in the format \\"YYYY-MM-DD\\". Input: - `objects`: a list of objects where each object has the attributes `name` (a string) and `date` (a string in \\"YYYY-MM-DD\\" format). Output: - A list of objects sorted by the `date` attribute in ascending order. If two objects have the same date, their relative order should be maintained as in the input list (i.e., stable sorting). Constraints: - The list can contain up to 1000 objects. - Dates are always valid and in the correct format. - The `name` attribute can be any string. Requirements: 1. The solution should parse the date string and use it for sorting. 2. Use Python\'s built-in capabilities for sorting to ensure efficient performance. 3. The sorting should be stable to keep the initial order among objects with the same date. Example Usage: ```python class CustomObject: def __init__(self, name: str, date: str): self.name = name self.date = date objects = [ CustomObject(\\"Event 1\\", \\"2023-09-12\\"), CustomObject(\\"Event 2\\", \\"2022-05-20\\"), CustomObject(\\"Event 3\\", \\"2023-09-12\\"), CustomObject(\\"Event 4\\", \\"2021-11-01\\") ] sorted_objects = sort_objects(objects) for obj in sorted_objects: print(obj.name, obj.date) ``` Example Output: ``` Event 4 2021-11-01 Event 2 2022-05-20 Event 1 2023-09-12 Event 3 2023-09-12 ``` Implementation Strategy: 1. Define a custom class `CustomObject` with `name` and `date` attributes. 2. Implement the function `sort_objects` that utilizes Python\'s sorting functions to order the objects by their `date`. 3. Convert the date string to a datetime object for accurate comparison. 4. Return the sorted list of objects. ```python from datetime import datetime class CustomObject: def __init__(self, name: str, date: str): self.name = name self.date = date def sort_objects(objects: list) -> list: Sort a list of CustomObject instances by their date attribute in ascending order. :param objects: List of CustomObject instances with \'name\' and \'date\' attributes. :return: List of CustomObject instances sorted by the \'date\' attribute. # Sort objects using the date attribute return sorted(objects, key=lambda obj: datetime.strptime(obj.date, \\"%Y-%m-%d\\")) # Example usage objects = [ CustomObject(\\"Event 1\\", \\"2023-09-12\\"), CustomObject(\\"Event 2\\", \\"2022-05-20\\"), CustomObject(\\"Event 3\\", \\"2023-09-12\\"), CustomObject(\\"Event 4\\", \\"2021-11-01\\") ] sorted_objects = sort_objects(objects) for obj in sorted_objects: print(obj.name, obj.date) ``` Implement the function ensuring it effectively sorts the objects by date, maintaining the input order for same-date objects, and includes handling of string parsing and sorting logic.","solution":"from datetime import datetime class CustomObject: def __init__(self, name: str, date: str): self.name = name self.date = date def sort_objects(objects: list) -> list: Sort a list of CustomObject instances by their date attribute in ascending order. :param objects: List of CustomObject instances with \'name\' and \'date\' attributes. :return: List of CustomObject instances sorted by the \'date\' attribute. # Sort objects using the date attribute return sorted(objects, key=lambda obj: datetime.strptime(obj.date, \\"%Y-%m-%d\\")) # Example usage objects = [ CustomObject(\\"Event 1\\", \\"2023-09-12\\"), CustomObject(\\"Event 2\\", \\"2022-05-20\\"), CustomObject(\\"Event 3\\", \\"2023-09-12\\"), CustomObject(\\"Event 4\\", \\"2021-11-01\\") ] sorted_objects = sort_objects(objects) for obj in sorted_objects: print(obj.name, obj.date)"},{"question":"# Coding Assessment Question: Balanced Parantheses Expression Background: In programming, balanced parentheses are crucial for correctly constructing expressions and data structures. A string consisting of parentheses `(` and `)` is said to be balanced if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. For example, the strings `()`, `(())`, and `(()()` are balanced, but the strings `(`, `)`, `(()`, and `())(` are not. Your task is to write a function to determine the longest substring of a given string of parentheses that forms a balanced sequence. # Function Signature ```python def longest_balanced_substring(s: str) -> int: pass ``` # Input - `s` (str): A string containing only characters `(` and `)`. # Output - An integer representing the length of the longest balanced substring of the given string. # Constraints - The length of the input string `s` will not exceed 10^5. # Example ```python def test_longest_balanced_substring(): assert longest_balanced_substring(\\"(()\\") == 2, \\"Test case 1 failed\\" assert longest_balanced_substring(\\")()())\\") == 4, \\"Test case 2 failed\\" assert longest_balanced_substring(\\"\\") == 0, \\"Test case 3 failed\\" assert longest_balanced_substring(\\"((()))\\") == 6, \\"Test case 4 failed\\" print(\\"All test cases pass\\") ``` # Notes - The function should efficiently find the longest balanced substring within the given constraints.","solution":"def longest_balanced_substring(s: str) -> int: stack = [-1] max_length = 0 for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"# Coding Assessment: Matrix Diagonal Sum Given an `n x n` matrix, write a program to calculate the sum of the elements on its primary (main) diagonal and secondary (anti) diagonal. You need to implement the core function `diagonalSums(matrix)` to complete the task. Requirements 1. **diagonalSums(matrix)** - **Input**: - `matrix`: List[List[int]], a 2D list representing an `n x n` matrix. - **Output**: - Returns a tuple containing two integers representing the sum of the primary diagonal and the sum of the secondary diagonal, respectively. - **Constraints**: - The matrix will always be square (`n x n`) with `0 < n <= 100`. - The elements of the matrix will be integers in the range `-1000` to `1000`. Example ```python # Given a 3x3 matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] primary_sum, secondary_sum = diagonalSums(matrix) # Expected: (15, 15) # Explanation: # Primary diagonal: 1 + 5 + 9 = 15 # Secondary diagonal: 3 + 5 + 7 = 15 # Given a 4x4 matrix matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] primary_sum, secondary_sum = diagonalSums(matrix) # Expected: (34, 34) # Explanation: # Primary diagonal: 1 + 6 + 11 + 16 = 34 # Secondary diagonal: 4 + 7 + 10 + 13 = 34 ``` Use the above-mentioned function definition to implement the required functionality. Make sure to accurately handle matrices of different sizes within the given constraints.","solution":"def diagonalSums(matrix): Calculates the sum of the primary and secondary diagonals of a square matrix. Args: matrix (List[List[int]]): A 2D list representing an n x n matrix. Returns: Tuple[int, int]: A tuple containing the sum of the primary diagonal and the sum of the secondary diagonal. n = len(matrix) primary_sum = 0 secondary_sum = 0 for i in range(n): primary_sum += matrix[i][i] secondary_sum += matrix[i][n - i - 1] return (primary_sum, secondary_sum)"},{"question":"# Problem Statement: You need to implement a simple spell checker. The spell checker will receive two lists of words: the dictionary and the document. The purpose is to return the list of words from the document that are not found in the dictionary. # Requirements: 1. Implement a function `find_misspelled_words(dictionary: List[str], document: List[str]) -> List[str]`. 2. The function should take two lists of strings as input: - `dictionary`: a list of correctly spelled words. - `document`: a list of words to be checked. 3. The function should return a list of words from the document that are not found in the dictionary. 4. The solution must be case-sensitive. # Input and Output Formats: - The `dictionary` is a list of strings, each representing a correctly spelled word. - The `document` is a list of strings, each representing a word to check against the dictionary. - The function returns a list of strings, each representing a misspelled word. # Constraints: - All words in the dictionary and document consist of only lowercase and uppercase English letters. - The length of each word is between 1 and 100 characters. - The dictionary list will contain between 1 and 10^5 words. - The document list will contain between 1 and 10^5 words. # Example: ```python from typing import List def find_misspelled_words(dictionary: List[str], document: List[str]) -> List[str]: dict_set = set(dictionary) # Convert dictionary list to set for faster lookup misspelled_words = [word for word in document if word not in dict_set] return misspelled_words # Example usage: dictionary = [\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"] document = [\\"apple\\", \\"aple\\", \\"banana\\", \\"grap\\", \\"orange\\", \\"grape\\", \\"berry\\"] print(find_misspelled_words(dictionary, document)) # Expected: [\'aple\', \'grap\', \'berry\'] ``` Complete the function `find_misspelled_words` to ensure it meets the provided requirements and works as illustrated in the example usage.","solution":"from typing import List def find_misspelled_words(dictionary: List[str], document: List[str]) -> List[str]: Returns the list of words from the document that are not found in the dictionary. dict_set = set(dictionary) # Convert dictionary list to set for faster lookup misspelled_words = [word for word in document if word not in dict_set] return misspelled_words"},{"question":"# Coding Question Context You are developing a command-line utility that allows users to search for files within a directory based on specific criteria. The current implementation only supports basic file searching without considering various important factors like file extensions, file sizes, and last modified dates. Task Write a function `search_files` that enhances the search functionality by allowing users to specify file extensions, size constraints, and modification date ranges. The function should also handle errors gracefully and provide meaningful output. Function Signature ```python def search_files(directory: str, file_extension: str = None, min_size: int = None, max_size: int = None, start_date: str = None, end_date: str = None) -> list: pass ``` Requirements 1. **Inputs**: * `directory` (str): The directory path to search in. * `file_extension` (str, optional): The file extension to filter files by (e.g., \\".txt\\"). * `min_size` (int, optional): The minimum file size in bytes. * `max_size` (int, optional): The maximum file size in bytes. * `start_date` (str, optional): The start of the modified date range in \\"YYYY-MM-DD\\" format. * `end_date` (str, optional): The end of the modified date range in \\"YYYY-MM-DD\\" format. 2. **Output**: * Returns a list of filenames that match the specified criteria. 3. **Constraints**: * Handle the case where the directory does not exist or is inaccessible. * Make sure the function can handle large directories efficiently. * Validate the input date strings and convert them to date objects as necessary. * If no filters are specified, return all files in the directory. 4. **Performance**: * Ensure the function operates efficiently even with a large number of files and deep directory structures. * Avoid unnecessary re-scanning of the directory. Example: ```python if __name__ == \\"__main__\\": files = search_files(directory=\\"/path/to/search\\", file_extension=\\".log\\", min_size=1024, max_size=1048576, start_date=\\"2023-01-01\\", end_date=\\"2023-12-31\\") for file in files: print(file) ``` Notes: * Implement logging to capture errors (e.g., invalid date format, directory not found) and normal operation. * Ensure the implementation is clean and includes sufficient documentation and comments.","solution":"import os from datetime import datetime import logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s %(levelname)s:%(message)s\') def search_files(directory: str, file_extension: str = None, min_size: int = None, max_size: int = None, start_date: str = None, end_date: str = None) -> list: Search for files in the specified directory based on file extension, size constraints, and modification date ranges. Parameters: directory (str): The directory path to search in. file_extension (str, optional): The file extension to filter files by. min_size (int, optional): The minimum file size in bytes. max_size (int, optional): The maximum file size in bytes. start_date (str, optional): The start of the modified date range in \\"YYYY-MM-DD\\" format. end_date (str, optional): The end of the modified date range in \\"YYYY-MM-DD\\" format. Returns: list: A list of filenames that match the specified criteria. if not os.path.isdir(directory): logging.error(f\\"The directory {directory} does not exist or is inaccessible.\\") return [] matched_files = [] start_dt = None end_dt = None if start_date: try: start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") except ValueError: logging.error(f\\"Invalid start date format: {start_date}. Use \'YYYY-MM-DD\' format.\\") return [] if end_date: try: end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") except ValueError: logging.error(f\\"Invalid end date format: {end_date}. Use \'YYYY-MM-DD\' format.\\") return [] for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_stat = os.stat(file_path) file_size = file_stat.st_size file_mtime = datetime.fromtimestamp(file_stat.st_mtime) if file_extension and not file.endswith(file_extension): continue if min_size and file_size < min_size: continue if max_size and file_size > max_size: continue if start_dt and file_mtime < start_dt: continue if end_dt and file_mtime > end_dt: continue matched_files.append(file_path) return matched_files"},{"question":"# Identify the Smallest Missing Positive Integer Write a function that takes an array of integers and returns the smallest missing positive integer. Your function should have a linear time complexity O(n) and constant space complexity O(1). Requirements: 1. Implement the `find_smallest_missing_positive` function. 2. Your function should modify the input array in-place. 3. The function should handle arrays with both positive and negative integers, as well as duplicate values. # Constraints: - The input array will have at most 100,000 elements. - The elements of the input array will be within the range `[-1,000,000, 1,000,000]`. - Performance is critical and the function must run in O(n) time complexity. Function Signature: ```python def find_smallest_missing_positive(arr: List[int]) -> int: Finds the smallest missing positive integer in the given array. Args: arr (List[int]): Input list of integers. Returns: int: The smallest missing positive integer. ``` # Example Usage: ```python print(find_smallest_missing_positive([3, 4, -1, 1])) # Expected: 2 print(find_smallest_missing_positive([1, 2, 0])) # Expected: 3 print(find_smallest_missing_positive([7, 8, 9, 11, 12])) # Expected: 1 ``` # Additional Notes: - Consider edge cases like the presence of negative numbers, duplicates, and arrays that are already in sequence. - Assume you cannot use extra space such as another array or list; constant space constraints imply in-place modifications. - Pay attention to the time complexity and ensure that your solution efficiently handles the input size and constraints.","solution":"def find_smallest_missing_positive(arr): Finds the smallest missing positive integer in the given array. Args: arr (List[int]): Input list of integers. Returns: int: The smallest missing positive integer. n = len(arr) # Step 1: Mark non-positive and out of bound numbers for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Step 2: Use the index as a hash key and mark corresponding positions as visited for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Step 3: The first index which has a positive number, the index+1 is missing for i in range(n): if arr[i] > 0: return i + 1 # Step 4: If no positive index found, return n + 1 (all numbers 1 to n are present) return n + 1"},{"question":"# Optimal Task Scheduling with Dependency Constraints Context You are tasked with developing a task scheduling system for workflows where certain tasks depend on the completion of others. Each task needs to be completed in optimal order considering these dependencies. Problem Statement Write a function `task_scheduler` that determines an optimal order in which to schedule a series of tasks given their dependencies. This order should ensure that no tasks are scheduled before their dependencies are completed. Function Signature ```python def task_scheduler(tasks: list[str], dependencies: list[tuple[str, str]]) -> list[str]: pass ``` Input - `tasks` (list of str): A list of tasks represented by their unique ids. - `dependencies` (list of tuple): A list of dependencies where each tuple `(a, b)` means task `b` depends on task `a`. Output - Returns a list of tasks in the order they should be scheduled. Constraints - `1 <= len(tasks) <= 10^5` - Each task id is unique. - The dependencies list can be empty. - Tasks and dependencies will not form a circular dependency. Requirements - The implementation should be optimal in terms of time complexity. - Properly handle edge cases including empty dependencies or circular dependencies. - Check for and raise an error if the tasks list or any dependency tuple is malformed. Example ```python assert task_scheduler( [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")] ) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert task_scheduler( [\\"a\\", \\"b\\", \\"c\\"], [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\")] ) == [\\"a\\", \\"b\\", \\"c\\"] or [\\"a\\", \\"c\\", \\"b\\"] assert task_scheduler( [\\"e\\", \\"f\\", \\"g\\", \\"h\\"], [(\\"e\\", \\"h\\"), (\\"f\\", \\"h\\"), (\\"g\\", \\"f\\")] ) == [\\"e\\", \\"g\\", \\"f\\", \\"h\\"] ```","solution":"from collections import defaultdict, deque def task_scheduler(tasks, dependencies): Determines an optimal order to schedule tasks given their dependencies. Args: - tasks (list of str): List of unique task ids. - dependencies (list of tuple): Each tuple (a, b) meaning task b depends on task a. Returns: - list of str: List of tasks in the order they should be scheduled, or raises ValueError if input is invalid. # Build graph and in-degree counter graph = defaultdict(list) in_degree = {task: 0 for task in tasks} for a, b in dependencies: if a not in tasks or b not in tasks: raise ValueError(\\"The dependency tuple contains tasks not in the tasks list.\\") graph[a].append(b) in_degree[b] += 1 # Find all nodes with in-degree of 0 zero_in_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) # List to store the ordered tasks task_order = [] while zero_in_degree_queue: task = zero_in_degree_queue.popleft() task_order.append(task) # For all neighbors, reduce their in-degree for neighbor in graph[task]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add to queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Check if we have added all tasks to the order if len(task_order) == len(tasks): return task_order else: raise ValueError(\\"There exists a circular dependency among the tasks.\\")"},{"question":"# Problem Statement You are given a list of string representations of integer numbers. Your task is to write a function that sorts these numbers in ascending numerical order. Strings that are not valid integers should be ignored. The function should handle edge cases and validate inputs appropriately. # Function Signature ```python def sort_integer_strings(numbers: list) -> list: pass ``` # Inputs - `numbers (list)`: A list of strings representing integer numbers. Each string may represent a valid or invalid integer. # Outputs - `sorted_numbers (list)`: A list of strings representing valid integer numbers sorted in ascending numerical order. # Constraints 1. Each element of the `numbers` list is a string of length up to 100 characters. 2. The list `numbers` can contain up to 10,000 elements. 3. The strings can include positive and negative integers, but may also include strings that are not valid integers (such as empty strings or alphabetic characters). # Examples ```python # Example 1 numbers = [\\"10\\", \\"2\\", \\"-5\\", \\"30\\", \\"invalid\\", \\"42\\"] print(sort_integer_strings(numbers)) # Output: [\\"-5\\", \\"2\\", \\"10\\", \\"30\\", \\"42\\"] # Example 2 numbers = [\\"abc\\", \\"123\\", \\"456\\", \\"none\\", \\"-10\\"] print(sort_integer_strings(numbers)) # Output: [\\"-10\\", \\"123\\", \\"456\\"] # Example 3 numbers = [\\"zero\\", \\"-0\\", \\"0\\", \\"+5\\", \\"5.1\\", \\"-5\\"] print(sort_integer_strings(numbers)) # Output: [\\"-5\\", \\"-0\\", \\"0\\", \\"+5\\"] ``` # Notes - Ensure your solution skips strings that cannot be converted to valid integers. - Negative integers should be considered correctly during sorting. - Strings representing integers with a \'+\' or \'-\' sign should be handled appropriately. - Concentrate on creating an efficient solution that can handle the maximum input size efficiently.","solution":"def sort_integer_strings(numbers: list) -> list: This function sorts a list of string representations of integer numbers in ascending numerical order. Strings that are not valid integers are ignored. Arguments: numbers -- a list of strings representing integer numbers Returns: A list of strings representing valid integer numbers sorted in ascending numerical order. valid_numbers = [] for number in numbers: try: val = int(number) valid_numbers.append(number) except ValueError: continue # Sorting based on integer values valid_numbers.sort(key=int) return valid_numbers"},{"question":"**Context**: In many computational tasks, it is essential to process sequences and perform transformations. For instance, in text preprocessing, word sequences are often converted to numerical sequences that can be further analyzed or fed into models. **Objective**: Your task is to implement a function that encodes a given string by converting each alphabetical character into its corresponding number based on its position in the alphabet. The function should ignore non-alphabet characters and handle both uppercase and lowercase letters seamlessly. # Task Description: Implement the function `alphabet_position(text: str) -> str` that takes in a string and returns a new string where each alphabetical character from the input is replaced by its position in the alphabet. The positions are 1-based, meaning \'a\' or \'A\' should be transformed to \'1\', \'b\' or \'B\' to \'2\', and so on. Non-alphabet characters should be ignored in the output string. # Input Format: *A single argument: `text` (type: `str`). The input string containing any characters. # Output Format: * Returns a `str` containing the numerical positions separated by spaces where alphabetical characters have been replaced by their positions in the alphabet. # Constraints: 1. The input string can have up to (10^6) characters. 2. The input string can contain uppercase letters, lowercase letters, digits, punctuation, or spaces. 3. Non-alphabet characters are ignored in the transformation. # Examples: ```python # Example 1 text = \\"Hello World!\\" print(alphabet_position(text)) # Output: \\"8 5 12 12 15 23 15 18 12 4\\" # Example 2 text = \\"Python 3.8\\" print(alphabet_position(text)) # Output: \\"16 25 20 8 15 14\\" ```","solution":"def alphabet_position(text: str) -> str: Converts each alphabetical character in the input text to its corresponding number based on its position in the alphabet. Non-alphabet characters are ignored. :param text: The input string containing any characters. :return: A string containing the numerical positions separated by spaces. positions = [] for char in text: if char.isalpha(): positions.append(str(ord(char.lower()) - ord(\'a\') + 1)) return \\" \\".join(positions)"},{"question":"# Question You are managing an inventory system for a book store. The system must allow for adding books, removing books, and tracking inventory levels. Implement a class `BookInventory` to manage the inventory. Class Signature ```python class BookInventory: def __init__(self): pass def add_book(self, title: str, author: str, quantity: int) -> None: pass def remove_book(self, title: str, author: str, quantity: int) -> None: pass def get_inventory(self) -> dict: pass ``` # Methods 1. **`__init__`** - This method should initialize an empty inventory. Inventory should be a dictionary where keys are (title, author) tuples and values are the quantities of the books. 2. **`add_book`** - This method should add books to the inventory. - **Arguments:** - `title` (str): The title of the book. - `author` (str): The author of the book. - `quantity` (int): The number of copies to add (must be a positive integer). 3. **`remove_book`** - This method should remove books from the inventory. - **Arguments:** - `title` (str): The title of the book. - `author` (str): The author of the book. - `quantity` (int): The number of copies to remove (must be a positive integer). - **Constraints:** - If the book does not exist in the inventory, raise a `KeyError` with a message indicating the missing book. - If the quantity to remove is greater than the available quantity, raise a `ValueError` with a message indicating the issue. 4. **`get_inventory`** - This method should return the entire inventory as a dictionary. # Constraints - Book titles and authors are non-empty strings. - Quantities are positive integers. # Example ```python inventory = BookInventory() # Adding books to inventory inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5) inventory.add_book(\\"1984\\", \\"George Orwell\\", 10) # Retrieving inventory print(inventory.get_inventory()) # Expected output: {(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"): 5, (\\"1984\\", \\"George Orwell\\"): 10} # Removing books inventory.remove_book(\\"1984\\", \\"George Orwell\\", 5) # Retrieving inventory print(inventory.get_inventory()) # Expected output: {(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"): 5, (\\"1984\\", \\"George Orwell\\"): 5} # Attempt to remove more books than available inventory.remove_book(\\"1984\\", \\"George Orwell\\", 6) # Expected outcome: Raises ValueError with message \\"Cannot remove 6 books; only 5 available.\\" # Attempt to remove a non-existent book inventory.remove_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1) # Expected outcome: Raises KeyError with message \\"The book The Catcher in the Rye by J.D. Salinger does not exist.\\" # Attempt to remove a book with negative quantity inventory.remove_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", -1) # Expected outcome: Raises ValueError with message \\"Cannot remove a negative quantity of books.\\" ``` Ensure to test the methods extensively with both expected and edge case scenarios to validate the implementation.","solution":"class BookInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer.\\") key = (title, author) if key in self.inventory: self.inventory[key] += quantity else: self.inventory[key] = quantity def remove_book(self, title: str, author: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer.\\") key = (title, author) if key not in self.inventory: raise KeyError(f\\"The book {title} by {author} does not exist.\\") if self.inventory[key] < quantity: raise ValueError(f\\"Cannot remove {quantity} books; only {self.inventory[key]} available.\\") self.inventory[key] -= quantity if self.inventory[key] == 0: del self.inventory[key] def get_inventory(self) -> dict: return self.inventory"},{"question":"# Coding Assessment Question Context A palindrome is a sequence of characters that reads the same backward as forward. An interesting variation of this concept is the *weight-balanced palindrome*. In this context, a weight-balanced palindrome is a string that is a palindrome and where the sum of the ASCII values of the characters in the first half equals the sum of the ASCII values of the characters in the second half. Task Write a function `is_weight_balanced_palindrome(s: str) -> bool` that checks if a given string (s) is a weight-balanced palindrome. Input * A string (s) where (1 leq text{len}(s) leq 1000). Output * A boolean value `True` if the string is a weight-balanced palindrome, otherwise `False`. Constraints * The function should handle both even and odd length strings. * Consider edge cases such as single-character strings or strings with all identical characters. Example ```python def is_weight_balanced_palindrome(s: str) -> bool: # Implementation here pass # Example Usage print(is_weight_balanced_palindrome(\\"radar\\")) # Output: False print(is_weight_balanced_palindrome(\\"abba\\")) # Output: True print(is_weight_balanced_palindrome(\\"a\\")) # Output: True print(is_weight_balanced_palindrome(\\"abccba\\")) # Output: True ``` # Requirements * Check if the string is a palindrome. * Calculate and compare the ASCII value sums of the first and second halves. * Handle strings of both even and odd lengths appropriately. This question assesses your ability to manipulate strings, perform arithmetic on character values, and implement logical checks efficiently in Python.","solution":"def is_weight_balanced_palindrome(s: str) -> bool: Checks if a given string is a weight-balanced palindrome. # Check if the string is a palindrome if s != s[::-1]: return False # Calculate the mid-point of the string mid = len(s) // 2 # Calculate the ASCII sum of the first half and second half if len(s) % 2 == 0: first_half_sum = sum(ord(c) for c in s[:mid]) second_half_sum = sum(ord(c) for c in s[mid:]) else: first_half_sum = sum(ord(c) for c in s[:mid]) second_half_sum = sum(ord(c) for c in s[mid+1:]) # Compare the sums return first_half_sum == second_half_sum"},{"question":"# Question You are tasked with writing a function `check_anagram_pairs` to evaluate pairs of strings and determine if each pair forms an anagram. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Specifications - Function: `check_anagram_pairs(pairs: list[tuple[str, str]]) -> list[bool]` - **Input**: - `pairs`: A list of tuples, each containing two strings to be analyzed. - **Output**: - A list of boolean values indicating if each pair of strings is an anagram (True) or not (False). Constraints - Each string in a pair contains only lowercase alphabetic characters. - Max length of each string: 100 characters. - Max number of string pairs: 500. Example ```python >>> pairs = [(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"bellow\\"), (\\"race\\", \\"care\\"), (\\"example\\", \\"samples\\")] >>> check_anagram_pairs(pairs) [True, False, True, False] ```","solution":"def check_anagram_pairs(pairs): Determine if each pair in a list of tuples forms an anagram. Args: pairs: list of tuples, where each tuple contains two strings. Returns: List of booleans indicating if each pair are anagrams. def is_anagram(str1, str2): return sorted(str1) == sorted(str2) return [is_anagram(pair[0], pair[1]) for pair in pairs]"},{"question":"# Problem Statement: You are given a string representing the movement of a robot in a 2D grid. The string consists of the characters \'L\' (left), \'R\' (right), \'U\' (up), and \'D\' (down). Your task is to determine if the robot returns to the origin (0, 0) after executing all the movements. # Function Signature: ```python def is_at_origin(movements: str) -> bool ``` # Input: - `movements` (str): A string of movements. (1 ≤ len(movements) ≤ 100) # Output: - (bool): Return `True` if the robot returns to the origin, otherwise `False`. # Examples: ```python # Example 1: is_at_origin(\\"UDLLRR\\") # Returns: True # Example 2: is_at_origin(\\"UUDLL\\") # Returns: False # Example 3: is_at_origin(\\"LDRU\\") # Returns: True ``` # Constraints: - The robot can move freely within the grid. - The input string will only contain the characters \'L\', \'R\', \'U\', and \'D\'. - The function should efficiently handle inputs cases with a maximum length of 100. # Explanation: - \'L\' decreases the x-coordinate, \'R\' increases the x-coordinate. - \'U\' increases the y-coordinate, \'D\' decreases the y-coordinate. - The robot is back at the origin if the sum of \'L\' and \'R\' movements are equal and the sum of \'U\' and \'D\' movements are equal.","solution":"def is_at_origin(movements: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all the movements. Parameters: movements (str): A string of movements. Returns: bool: True if the robot returns to the origin, else False. x, y = 0, 0 for move in movements: if move == \'L\': x -= 1 elif move == \'R\': x += 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 # The robot is back at the origin if both coordinates are zero return x == 0 and y == 0"},{"question":"# Problem Statement You are to implement a function that simulates a simple hash map using linear probing to handle collisions. Implement a `HashMap` class with the following functionality: # Requirements 1. Implement a class called `HashMap`. 2. The class should support the following methods: - `__init__(self, size: int)`: Initialize the hash map with a fixed size. - `put(self, key: int, value: int)`: Insert a (key, value) pair into the hash map. If the key already exists, update its value. - `get(self, key: int) -> int`: Retrieve the value associated with the given key. If the key doesn\'t exist, return `None`. - `remove(self, key: int)`: Remove the key (and its corresponding value) from the hash map. 3. Implement linear probing to handle collisions. 4. Use the simple modulo operation as the hash function. # Constraints - The keys and values will be integers. - The size of the hash map will be given during initialization and is a positive integer. # Class Definition ```python class HashMap: def __init__(self, size: int): pass def put(self, key: int, value: int): pass def get(self, key: int) -> int: pass def remove(self, key: int): pass ``` # Example Usage ```python # Example usage: hash_map = HashMap(10) hash_map.put(1, 1) assert hash_map.get(1) == 1 assert hash_map.get(2) is None hash_map.put(2, 2) assert hash_map.get(2) == 2 hash_map.put(1, 10) assert hash_map.get(1) == 10 hash_map.remove(2) assert hash_map.get(2) is None assert hash_map.get(1) == 10 ``` # Notes - Consider edge cases such as inserting into a full hash map or removing keys that do not exist. - Ensure your implementation handles collisions correctly by probing to the next available slot. # Additional Information You will typically not need to resize the hash map for this exercise. Ensure the methods behave correctly under the constraints and intended collision handling method (linear probing).","solution":"class HashMap: def __init__(self, size: int): self.size = size self.map = [None] * size def _hash(self, key: int) -> int: return key % self.size def put(self, key: int, value: int): idx = self._hash(key) while self.map[idx] is not None and self.map[idx][0] != key: idx = (idx + 1) % self.size self.map[idx] = (key, value) def get(self, key: int) -> int: idx = self._hash(key) for _ in range(self.size): if self.map[idx] is None: return None if self.map[idx][0] == key: return self.map[idx][1] idx = (idx + 1) % self.size return None def remove(self, key: int): idx = self._hash(key) for _ in range(self.size): if self.map[idx] is None: return if self.map[idx][0] == key: self.map[idx] = None break idx = (idx + 1) % self.size # Rehash the following elements in the cluster idx = (idx + 1) % self.size while self.map[idx] is not None: rehashed_key, value = self.map[idx] self.map[idx] = None self.put(rehashed_key, value) idx = (idx + 1) % self.size"},{"question":"# Coding Assessment Question **Scenario**: You have been assigned to create software for filtering duplicate text entries in a large dataset. Your system will have to identify if two given text entries are anagrams of each other, meaning they contain the same characters but in a different order. For each comparison, you will return a boolean value indicating whether or not the texts are anagrams. # Problem Statement: Implement a function `are_anagrams(text1: str, text2: str)` to determine if the two input texts are anagrams of each other. The function should return a boolean indicating this result. # Requirements: 1. **Input**: - Two strings `text1` and `text2` with lengths `m` and `n` respectively. 2. **Output**: - A boolean value: * `True` if `text1` and `text2` are anagrams. * `False` otherwise. 3. **Constraints**: - The lengths of strings `text1` and `text2` will be between 0 and 1000. - The characters in the strings include alphabet `[a-zA-Z]` only and may contain mixed case. # Examples: ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") True >>> are_anagrams(\\"Programming\\", \\"Gram Ring Mop\\") False >>> are_anagrams(\\"Dusty\\", \\"Study\\") True >>> are_anagrams(\\"Random\\", \\"Words\\") False >>> are_anagrams(\\"\\", \\"\\") True # Both strings are empty >>> are_anagrams(\\"a\\", \\"\\") # One string is empty False >>> are_anagrams(\\"abcd\\", \\"dcab\\") True ``` # Guidelines: * Ensure your function handles different cases like empty strings, strings with varied cases, and no anagram found. * The solution should be efficient even for upper constraint limits with O(n) time complexity where n is the length of the strings. * You may assume the inputs are always valid strings containing only alphabetic characters.","solution":"def are_anagrams(text1: str, text2: str) -> bool: Determine if two given texts are anagrams of each other. :param text1: First text string. :param text2: Second text string. :return: True if text1 and text2 are anagrams; otherwise, False. # Normalize the strings by converting them to lowercase and sorting the characters normalized_text1 = sorted(text1.lower()) normalized_text2 = sorted(text2.lower()) return normalized_text1 == normalized_text2"},{"question":"# Binary Search on Almost Sorted Array Problem Description Given an array of n integers that is almost sorted, which means each element may be at most one position away from its correct sorted order location, write a function to efficiently find and return the index of a target element using a modified Binary Search algorithm. Function Signature ```python def binary_search_almost_sorted(arr: Sequence[int], target: int) -> int: Returns the index of the target element if found; otherwise, return -1. Args: arr (Sequence[int]): The almost sorted array to search within. target (int): The target element to find. Returns: int: The index of the target element or -1 if not found. pass ``` Requirements - **Input**: - `arr`: an almost sorted array of integers. - `target`: an integer to search for. - **Output**: - Return the index of the target element, if found. Otherwise, return -1. Constraints - The array `arr` may contain up to 10^6 elements. - Elements in `arr` will be integers, and the target `target` will also be an integer. - Ensure the solution runs efficiently, aiming for better than O(n) complexity. Example ```python >>> binary_search_almost_sorted([3, 2, 10, 4, 40], 4) 3 >>> binary_search_almost_sorted([10, 3, 40, 20, 50, 80, 70], 40) 2 >>> binary_search_almost_sorted([3, 2, 10, 4, 40], 5) -1 >>> binary_search_almost_sorted([1, 2, 3, 4, 5], 3) 2 ``` Discussion - Illustrate how you adapt the binary search to account for the almost sorted property of the array. - Describe any edge cases you considered, such as duplicate elements or the minimal size array. - Test the function with arrays of various sizes and target positions to ensure consistent performance and correctness.","solution":"def binary_search_almost_sorted(arr, target): Returns the index of the target element if found; otherwise, return -1. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 # Check if the middle element is the target if arr[mid] == target: return mid # Check if the previous element is the target if mid - 1 >= 0 and arr[mid - 1] == target: return mid - 1 # Check if the next element is the target if mid + 1 < len(arr) and arr[mid + 1] == target: return mid + 1 # Adjust the search range if arr[mid] < target: low = mid + 2 else: high = mid - 2 # Target is not found return -1"},{"question":"# Problem Statement You are managing a team of developers, and one of their tasks involves parsing a collection of log entries from a system. Each entry consists of a timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format, followed by a log message. Your team needs a function to extract specific information for analytics. Your task is to write a function `extract_logs` that takes: - `logs` (a list of strings, where each string represents a log entry in the format \\"YYYY-MM-DD HH:MM:SS - <message>\\") - `date` (a string specifying a date in \\"YYYY-MM-DD\\" format) The function should return a list of log messages that come from the specified date. If the input date has no corresponding log entries, the function should return an empty list. Input: - `logs`: List of strings (1 <= len(logs) <= 10^4) - `date`: string (a valid date in \\"YYYY-MM-DD\\" format) Output: - A list of log messages (strings) that correspond to the specified date. Constraints: - Each log entry will only contain the date once in the format provided. - The log entries are guaranteed to follow the specified format. - Assume the timestamps in `logs` are chronologically sorted. # Examples: 1. `extract_logs([\\"2023-01-01 12:00:00 - System rebooted\\", \\"2023-01-01 12:30:00 - System check completed\\", \\"2023-01-02 09:00:00 - User login\\"], \\"2023-01-01\\")` should return `[\\"System rebooted\\", \\"System check completed\\"]`. 2. `extract_logs([\\"2023-07-15 08:45:00 - Backup completed\\", \\"2023-07-16 13:15:00 - Disk cleanup\\"], \\"2023-07-16\\")` should return `[\\"Disk cleanup\\"]`. 3. `extract_logs([\\"2022-11-10 10:10:10 - New user added\\", \\"2022-11-11 11:11:11 - Security patch applied\\"], \\"2022-11-09\\")` should return `[]`. # Notes: - The date format used in logs is \\"YYYY-MM-DD HH:MM:SS\\", and the date input is in \\"YYYY-MM-DD\\" format. - The `date` input assumes a valid date string. - Timestamps are provided in chronological order, which might be useful for optimizing the implementation.","solution":"def extract_logs(logs, date): Extracts log messages from logs that match the given date. Args: logs (list of str): List of log entries in the format \\"YYYY-MM-DD HH:MM:SS - <message>\\" date (str): A specific date in \\"YYYY-MM-DD\\" format Returns: list of str: List of log messages that match the given date result = [] for log in logs: if log.startswith(date): message = log.split(\\" - \\", 1)[1] # Split on the first occurrence of \\" - \\" and take the message part result.append(message) return result"},{"question":"# Binary Tree Traversal **Background**: Binary Trees are a fundamental data structure in computer science, widely used in various applications such as expression parsing, searching, and hierarchical data representation. Traversal methods like Inorder, Preorder, and Postorder are common techniques to visit all nodes of a tree in a specific order. **Task**: You are to implement three traversal methods for a given binary tree: Inorder, Preorder, and Postorder. Each method should return the nodes\' values in the respective traversal order. # Function Specifications 1. **Inorder Traversal (inorder_traversal)** - **Input**: - `root` (TreeNode): Root node of the binary tree. - **Output**: - List of integers representing the node values in Inorder traversal (e.g., [1, 3, 2]). 2. **Preorder Traversal (preorder_traversal)** - **Input**: - `root` (TreeNode): Root node of the binary tree. - **Output**: - List of integers representing the node values in Preorder traversal (e.g., [1, 2, 3]). 3. **Postorder Traversal (postorder_traversal)** - **Input**: - `root` (TreeNode): Root node of the binary tree. - **Output**: - List of integers representing the node values in Postorder traversal (e.g., [3, 2, 1]). # Constraints - The input tree can be empty, represented by a `None` value for the root. - TreeNode class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: Given a binary tree: ``` 1 / 2 3 / 4 5 ``` ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> inorder_traversal(root) [4, 2, 5, 1, 3] >>> preorder_traversal(root) [1, 2, 4, 5, 3] >>> postorder_traversal(root) [4, 5, 2, 3, 1] ``` *To implement binary tree traversals, you may use recursion or iterative methods. Recursion provides a straightforward approach while iterative methods may require additional stack data structures.*","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree. if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def preorder_traversal(root): Returns the preorder traversal of a binary tree. if root is None: return [] return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right) def postorder_traversal(root): Returns the postorder traversal of a binary tree. if root is None: return [] return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]"},{"question":"# Diagonal Traverse of a Matrix Description You need to implement a function that returns the diagonal traversal of a given 2D matrix. The elements of the matrix should be traversed in a diagonal order. Implementation Implement the function `diagonal_traverse(matrix: List[List[int]]) -> List[int]` that takes a 2D list `matrix` and returns a list of integers representing the matrix\'s elements in diagonal order. Constraints 1. The matrix can have arbitrary dimensions. 2. The number of rows (M) and number of columns (N) are such that 1 ≤ M, N ≤ 1000. Function Signature ```python from typing import List def diagonal_traverse(matrix: List[List[int]]) -> List[int]: pass ``` Input Format * A 2D list `matrix` representing the matrix to be traversed. Each element of the matrix is an integer. Output Format * A list of integers representing the elements of the matrix in diagonal order. Example Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ```python [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` Additional Information 1. If the matrix is empty, return an empty list. 2. Ensure that the function works efficiently within the given constraints.","solution":"from typing import List def diagonal_traverse(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] intermediate = [] for d in range(rows + cols - 1): intermediate.clear() r = 0 if d < cols else d - cols + 1 c = d if d < cols else cols - 1 while r < rows and c > -1: intermediate.append(matrix[r][c]) r += 1 c -= 1 if d % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) return result"},{"question":"# Coding Assessment Question Scenario You are refining a utility library that handles common string manipulation tasks. As part of this library, you need to implement a function that reverses the words in a string while preserving the whitespaces and the initial order of the words. Task Implement the following function: ```python def reverse_words(s: str) -> str: Reverses the words in a given string while maintaining the original whitespace positions. Parameters: - s: A string where words are separated by spaces. Returns: - A string with the words reversed but original whitespaces preserved. ``` Requirements 1. **`reverse_words` Implementation**: Handle various cases such as multiple consecutive spaces and leading/trailing spaces. 2. **Input Constraints**: The input string can only contain printable ASCII characters. 3. **Output**: A string with the original whitespaces preserved but with the words reversed. Example ```python assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" assert reverse_words(\\" hello world \\") == \\" world hello \\" assert reverse_words(\\"a good example\\") == \\"example good a\\" ``` Additional Notes - Words are defined as contiguous sequences of non-space characters. - Handle edge cases such as empty strings and strings with only spaces. - Optimize for performance, especially with longer strings.","solution":"def reverse_words(s: str) -> str: Reverses the words in a given string while maintaining the original whitespace positions. Parameters: - s: A string where words are separated by spaces. Returns: - A string with the words reversed but original whitespaces preserved. # Split words on spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space result = \' \'.join(reversed_words) return result"},{"question":"# String Compression Checker **Scenario**: You need to write a function that takes a string and returns a compressed version of it. The compression scheme is simple: for each group of repeated characters, replace the group with the character and the number of occurrences. If the compressed string is not smaller than the original string, return the original string instead. The function should be efficient enough to handle large input strings up to length 10,000. **Function Signature**: ```python def compress_string(s: str) -> str: pass ``` **Input**: - `s` (str): The input string. **Output**: - Returns the compressed version of the string, or the original string if compression does not make it shorter. **Constraints**: - The input string `s` can be any length from 1 to 10,000 characters. - The input string contains only uppercase and lowercase English letters (no spaces or special characters). **Performance Requirements**: - The function should handle the maximum input size efficiently within a reasonable time frame. **Example**: ```python >>> compress_string(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> compress_string(\\"abc\\") \'abc\' >>> compress_string(\\"aabbcc\\") \'aabbcc\' >>> compress_string(\\"a\\") \'a\' >>> compress_string(\\"aaabbbbccddddd\\") \'a3b4c2d5\' ``` **Additional Notes**: - You are encouraged to use efficient string manipulation techniques to minimize the computational overhead. - Ensure that the function handles edge cases, such as strings with no repeating characters or strings where compression does not reduce the length.","solution":"def compress_string(s: str) -> str: Compresses the input string using the counts of repeated characters. If the compressed string is not shorter than the original, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement Create a function that takes an integer `n` and returns the nth number in the sequence formed by arranging all positive integers in increasing order and then concatenating their digits into a single string. Essentially, you are tasked with finding the nth character in this infinitely long string representation. **Input Format:** - An integer `n` representing the position in the concatenated sequence (1 ≤ `n` ≤ 10^12). **Output Format:** - A single character representing the nth digit in the concatenated sequence of all positive integers. # Function Signature ```python def find_nth_digit(n: int) -> str: pass ``` # Constraints and Considerations: - Given the substantial input range, focus on an efficient solution. - Use properties of number lengths and digit counts to navigate through the sequence without explicitly constructing large strings. - Consider breaking down the problem based on digit length (e.g., 1-9, 10-99, etc.) # Example ```python print(find_nth_digit(15)) # Expected output: \\"2\\" (as the sequence up to the 15th digit is \'123456789101112\', and the 15th digit is \'2\') print(find_nth_digit(20)) # Expected output: \\"1\\" (as the sequence up to the 20th digit is \'123456789101112131415\', and the 20th digit is \'1\') ``` # Notes - Avoid explicitly generating the sequence up to `n`, given the large potential size. - Optimize by calculating ranges of numbers contributing to given positions and directly determining the targeted digit. - The approach should ideally involve mathematical determination of digit positions within specific number groups.","solution":"def find_nth_digit(n: int) -> str: length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length digit_index = (n - 1) % length return str(start)[digit_index]"},{"question":"# Question: Sentence Reversal with Punctuation Preservation You are provided with an input string that contains a sentence with words separated by spaces and punctuation marks such as commas, periods, exclamation marks, and question marks. Your task is to write a function `reverse_sentence_preserve_punctuation(sentence: str) -> str` that reverses the words in the sentence while preserving the positions of the punctuation marks. # Constraints * The input string `sentence` will have a length up to 1000 characters. * The sentence will contain only words (composed of alphabetical characters) and punctuation marks (, . ! ?). * The sentence will contain at least one word. * There will be no consecutive punctuation marks, and each punctuation mark will be adjacent to a word. # Input * `sentence` : string # Output * A string representing the sentence with the words reversed, while preserving the punctuation marks positions. # Examples Example 1 ```python sentence = \\"Hello, world!\\" output = \\"world, Hello!\\" ``` Example 2 ```python sentence = \\"Welcome to the coding world.\\" output = \\"world coding the to Welcome.\\" ``` Example 3 ```python sentence = \\"How are you doing today?\\" output = \\"today doing you are How?\\" ``` # Additional Notes * You must handle inputs that do not conform to the specifications by raising a `ValueError`. * The solution should consider the positions of punctuation marks while reversing the words efficiently. Implement the function `reverse_sentence_preserve_punctuation(sentence)`, ensuring it handles all the specified requirements efficiently.","solution":"import re def reverse_sentence_preserve_punctuation(sentence: str) -> str: Reverses the words in the sentence while preserving the positions of the punctuation marks. if not sentence or not isinstance(sentence, str): raise ValueError(\\"The input must be a valid non-empty string.\\") # Split the sentence into words and punctuation marks words = re.findall(r\'bw+b\', sentence) punctuations = re.findall(r\'[,.!?]\', sentence) # Create an iterator for words reversed_words_iter = iter(reversed(words)) result = [] word_idx = 0 for word in re.split(r\'(W+)\', sentence): if re.match(r\'w+\', word): result.append(next(reversed_words_iter)) else: result.append(word) return \'\'.join(result)"},{"question":"# Product Discount Calculation You are asked to write a function that calculates the total price of a list of products after applying a discount. The discount should be applied only to products whose original prices exceed a specified threshold. Background The function will take a dictionary of products with their original prices, a discount percentage, and a price threshold. The discount percentage should be applied to all products that have prices higher than the threshold. The final price should be rounded to two decimal places. Requirements Implement a function `apply_discount(prices: dict, discount: float, threshold: float) -> dict` that: * Takes three arguments: - `prices`: A dictionary where keys are product names (strings) and values are their original prices (floats). - `discount`: A float representing the discount percentage to be applied. - `threshold`: A float representing the price threshold above which the discount is applied. * Returns a new dictionary with product names and their prices after applying the discount. * Handles edge cases, such as an empty dictionary and non-dictionary inputs. * Should not use any imports except `pprint` and `time` for testing purposes. # Function Signature ```python def apply_discount(prices: dict, discount: float, threshold: float) -> dict: pass ``` # Input - `prices`: A dictionary where keys are product names (strings) and values are floats (0 <= |price| <= 10000). - `discount`: A float representing the discount percentage (0 <= |discount| <= 100). - `threshold`: A float representing the price threshold (0 <= |threshold| <= 10000). # Output - A dictionary where keys are product names and values are the new prices after applying the discount. The prices should be rounded to two decimal places. # Constraints - The dictionary will only contain positive floats for prices. - The discount percentage will be a non-negative float. - The threshold will be a non-negative float. Example You should include validation through docstring tests: ```python def apply_discount(prices: dict, discount: float, threshold: float) -> dict: Returns a dictionary with product prices after applying discount >>> apply_discount({}, 10.0, 100) {} >>> apply_discount({\\"product1\\": 150.0}, 10.0, 100) {\'product1\': 135.0} >>> apply_discount({\\"product1\\": 90.0, \\"product2\\": 200.0}, 20.0, 100) {\'product1\': 90.0, \'product2\': 160.0} >>> apply_discount({\\"product1\\": 100.0, \\"product2\\": 100.0}, 50.0, 100) {\'product1\': 100.0, \'product2\': 100.0} >>> apply_discount({\\"product1\\": 250.0, \\"product2\\": 350.0}, 10.0, 200) {\'product1\': 225.0, \'product2\': 315.0} if not isinstance(prices, dict): raise ValueError(\\"Prices should be a dictionary\\") if not isinstance(discount, (float, int)) or not isinstance(threshold, (float, int)): raise ValueError(\\"Discount and threshold should be floats or integers\\") discounted_prices = {} for product, price in prices.items(): if price > threshold: new_price = price * (1 - discount / 100) discounted_prices[product] = round(new_price, 2) else: discounted_prices[product] = price return discounted_prices ``` # Testing In addition to the examples provided, ensure to test a variety of price lists to verify the function handles different scenarios, including boundary values, dangling decimals, and performance on large datasets.","solution":"def apply_discount(prices: dict, discount: float, threshold: float) -> dict: Returns a dictionary with product prices after applying discount :param prices: A dictionary where keys are product names and values are their original prices. :param discount: A float representing the discount percentage to be applied. :param threshold: A float representing the price threshold above which the discount is applied. :return: A dictionary where keys are product names and values are the new prices after applying the discount. >>> apply_discount({}, 10.0, 100) {} >>> apply_discount({\\"product1\\": 150.0}, 10.0, 100) {\'product1\': 135.0} >>> apply_discount({\\"product1\\": 90.0, \\"product2\\": 200.0}, 20.0, 100) {\'product1\': 90.0, \'product2\': 160.0} >>> apply_discount({\\"product1\\": 100.0, \\"product2\\": 100.0}, 50.0, 100) {\'product1\': 100.0, \'product2\': 100.0} >>> apply_discount({\\"product1\\": 250.0, \\"product2\\": 350.0}, 10.0, 200) {\'product1\': 225.0, \'product2\': 315.0} if not isinstance(prices, dict): raise ValueError(\\"Prices should be a dictionary\\") if not (isinstance(discount, (float, int)) and isinstance(threshold, (float, int))): raise ValueError(\\"Discount and threshold should be floats or integers\\") discounted_prices = {} for product, price in prices.items(): if price > threshold: new_price = price * (1 - discount / 100) discounted_prices[product] = round(new_price, 2) else: discounted_prices[product] = price return discounted_prices"},{"question":"# Problem Statement You are given an array of integers. Your task is to implement the quicksort algorithm to sort the array in ascending order. Your implementation should handle arrays containing negative numbers as well as positive numbers, and should be optimized for efficient in-place sorting. # Input Format * An integer array ( A ) of size ( n ) where ( n ) can range from ( 0 ) to ( 10^5 ). # Output Format * The sorted array in ascending order. # Constraints * The elements of the array can be any integer value, positive or negative. * The array can be empty as well. # Example ```python For an input array [3, -2, 5, 1, 0], the output should be [-2, 0, 1, 3, 5]. ``` # Instructions 1. Do not use built-in sort functions. 2. Optimize for both time and space complexity. # Solution Template Here is a starting template for your solution: ```python def quicksort(array, low, high): if low < high: pi = partition(array, low, high) quicksort(array, low, pi - 1) quicksort(array, pi + 1, high) def partition(array, low, high): pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 if __name__ == \\"__main__\\": user_input = input(\\"Enter numbers separated by a comma:n\\").strip() unsorted = [int(item) for item in user_input.split(\\",\\")] if unsorted: quicksort(unsorted, 0, len(unsorted) - 1) print(unsorted) ``` In your implementation, ensure that you handle all edge cases effectively and test the function against a variety of input scenarios before finalizing your code.","solution":"def quicksort(array, low, high): if low < high: pi = partition(array, low, high) quicksort(array, low, pi - 1) quicksort(array, pi + 1, high) def partition(array, low, high): pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 def quicksort_wrapper(array): if array: quicksort(array, 0, len(array) - 1) return array"},{"question":"# Coding Assessment Question Task You are required to write a Python program that processes data from a CSV file containing information about various books and their attributes, and calculates specific metrics based on the data. Function Specifications Write a function `analyze_books(csv_filepath: str) -> dict` that: * Takes a single input: * `csv_filepath` (string): The file path to the CSV file containing book information. * Returns a dictionary containing the following keys: * \\"total_books\\" (integer): Total number of books listed in the file. * \\"average_rating\\" (float): The average rating of all books. * \\"highest_rated_book\\" (string): The title of the book with the highest rating. * \\"ratings_by_genre\\" (dictionary): A dictionary where keys are genres and values are the average ratings for those genres. CSV File Format The CSV file will have the following columns: * `title` (string): The title of the book. * `author` (string): The author of the book. * `genre` (string): The genre of the book. * `rating` (float): The rating of the book (on a scale from 0 to 5). The CSV file is guaranteed to have a header row. Constraints * Use the `csv` library to handle reading the CSV file. * Handle cases where the file might not exist or be accessible. * Handle cases where the CSV content might be improperly formatted. * The function should have minimal external dependencies other than the `csv` library. * Ensure that the function is robust and handles exceptions such as file errors and missing data gracefully. Example **CSV File Content:** ``` title,author,genre,rating The Great Gatsby,F. Scott Fitzgerald,Fiction,4.5 To Kill a Mockingbird,Harper Lee,Fiction,4.7 The Lean Startup,Eric Ries,Business,4.3 The Pragmatic Programmer,Andrew Hunt,Technology,4.8 ``` **Input:** ```python csv_filepath = \\"books.csv\\" book_data = analyze_books(csv_filepath) print(book_data) ``` **Expected Output:** ```python { \\"total_books\\": 4, \\"average_rating\\": 4.575, \\"highest_rated_book\\": \\"The Pragmatic Programmer\\", \\"ratings_by_genre\\": { \\"Fiction\\": 4.6, \\"Business\\": 4.3, \\"Technology\\": 4.8 } } ``` Performance Requirements * The function should be efficient and complete execution within a reasonable time frame (under 2 seconds for files up to 10,000 rows). Additional Context Book ratings can occasionally be missing or improperly formatted, so ensure your solution can handle such cases by using sensible default values or implementing error handling mechanisms where appropriate.","solution":"import csv from collections import defaultdict def analyze_books(csv_filepath: str) -> dict: try: with open(csv_filepath, mode=\'r\', encoding=\'utf-8\') as file: reader = csv.DictReader(file) total_books = 0 total_ratings = 0 highest_rating = -float(\'inf\') highest_rated_book = \\"\\" ratings_by_genre = defaultdict(list) for row in reader: try: title = row[\'title\'] genre = row[\'genre\'] rating = float(row[\'rating\']) # Update the total book count total_books += 1 # Update total ratings for average calculation total_ratings += rating # Check if current book has the highest rating if rating > highest_rating: highest_rating = rating highest_rated_book = title # Update ratings by genre ratings_by_genre[genre].append(rating) except (ValueError, KeyError): # Handle cases with improper data continue # Calculate average rating average_rating = total_ratings / total_books if total_books else 0 # Calculate average ratings by genre avg_ratings_by_genre = { genre: sum(ratings) / len(ratings) for genre, ratings in ratings_by_genre.items() } return { \\"total_books\\": total_books, \\"average_rating\\": average_rating, \\"highest_rated_book\\": highest_rated_book, \\"ratings_by_genre\\": avg_ratings_by_genre } except FileNotFoundError: print(f\\"File at {csv_filepath} not found.\\") return { \\"total_books\\": 0, \\"average_rating\\": 0.0, \\"highest_rated_book\\": \\"\\", \\"ratings_by_genre\\": {} }"},{"question":"# Question You are developing a feature for an online text editor to automatically detect and correct common typographical errors. Specifically, you need to handle the following scenarios: 1. Replace any occurrence of the word \\"teh\\" with \\"the\\". 2. Replace any occurrence of \\"recieve\\" with \\"receive\\". 3. Insert a space after a period if it is immediately followed by a letter (e.g., \\"end.This\\" should become \\"end. This\\"). # Function Requirements correct_typo * **Input**: A string `text` containing sentences. * **Output**: A corrected string with all specified typographical errors fixed. # Constraints * The input string `text` will have a maximum length of 10^6 characters. * Only lowercase letters, uppercase letters, periods, and spaces are allowed in `text`. # Example ```python text = \\"I am trying to recieve teh message.end.This is teh second test.\\" # Correct typographical errors corrected_text = correct_typo(text) print(corrected_text) # Output should be \\"I am trying to receive the message. end. This is the second test.\\" ``` Notes: * Ensure the function performs efficiently considering the large possible size of the input. * The function should handle the input string in a single pass (linear time complexity) if possible.","solution":"def correct_typo(text): Correct common typographical errors in the input text. Parameters: text (str): The input text to be corrected. Returns: str: The corrected text. import re # Replace \\"teh\\" with \\"the\\" text = text.replace(\\"teh\\", \\"the\\") # Replace \\"recieve\\" with \\"receive\\" text = text.replace(\\"recieve\\", \\"receive\\") # Insert a space after a period if it is immediately followed by a letter text = re.sub(r\'.(?=[A-Za-z])\', \'. \', text) return text"},{"question":"# Coding Question: Implement a Products Price Aggregator **Scenario:** You are tasked with implementing a function to aggregate product prices from different e-commerce websites. Your task involves fetching price data from various sources, normalizing it, and providing an aggregated view. To facilitate testing, you will use mocking to simulate the price data retrieval from web APIs. **Function Implementation**: Implement the function `aggregate_prices(product: str) -> dict:` which: 1. Fetches price data from three different e-commerce websites using separate functions `get_price_from_site1(product: str)`, `get_price_from_site2(product: str)`, and `get_price_from_site3(product: str)`. 2. Aggregates the prices by computing the average price. 3. Returns a dictionary with the product name, individual prices from each site, and the average price. **Testing Requirement**: Write unit tests to verify your implementation using `unittest.mock`. The tests should: 1. Ensure the functions to fetch prices are called correctly. 2. Verify that the prices are aggregated and averaged correctly. 3. Ensure the returned dictionary contains accurate and correctly computed data. **Function Signatures**: ```python def get_price_from_site1(product: str) -> float: # Mocked function, do not need to implement pass def get_price_from_site2(product: str) -> float: # Mocked function, do not need to implement pass def get_price_from_site3(product: str) -> float: # Mocked function, do not need to implement pass def aggregate_prices(product: str) -> dict: # Your implementation here pass ``` # Input: - `product` (str): the name of the product for which prices need to be aggregated. # Output: - A dictionary containing: - `product`: the product name (str). - `site1_price`: price from site1 (float). - `site2_price`: price from site2 (float). - `site3_price`: price from site3 (float). - `average_price`: the average price across the sites (float). # Constraints: - Assume that the prices returned from the sites are always positive floating-point numbers. - Handle cases where one or more sites are unavailable and treat their prices as zero in averaging. - The function should be tested with mocked price retrieval operations meaning actual API calls should not be performed. Example: ```python from unittest.mock import patch @patch(\\"your_module.get_price_from_site1\\") @patch(\\"your_module.get_price_from_site2\\") @patch(\\"your_module.get_price_from_site3\\") def test_aggregate_prices(mock_site1, mock_site2, mock_site3): mock_site1.return_value = 100.0 mock_site2.return_value = 150.0 mock_site3.return_value = 200.0 expected_output = { \'product\': \'laptop\', \'site1_price\': 100.0, \'site2_price\': 150.0, \'site3_price\': 200.0, \'average_price\': 150.0 } result = aggregate_prices(\'laptop\') assert result == expected_output ``` **Note**: Ensure all described mock assertions and required data checks are demonstrated in your tests.","solution":"from typing import Dict def get_price_from_site1(product: str) -> float: pass def get_price_from_site2(product: str) -> float: pass def get_price_from_site3(product: str) -> float: pass def aggregate_prices(product: str) -> Dict[str, float]: site1_price = get_price_from_site1(product) site2_price = get_price_from_site2(product) site3_price = get_price_from_site3(product) total_price = site1_price + site2_price + site3_price average_price = total_price / 3 if total_price > 0 else 0 return { \'product\': product, \'site1_price\': site1_price, \'site2_price\': site2_price, \'site3_price\': site3_price, \'average_price\': average_price }"},{"question":"# Word Frequency Analysis Coding Challenge **Context**: You are given a large text file, and you need to analyze the frequency of each word in the text. Your task is to write a function that reads the file and returns a list of the most frequent words with their counts. # Function Implementation Implement a function named `get_most_frequent_words` that accepts two parameters: 1. `file_path` (str): The path to the text file. 2. `top_n` (int): The number of top most frequent words to return. The function should perform the following: 1. Validate the inputs to ensure `file_path` is a non-empty string and `top_n` is a positive integer. 2. Read the text file from the given `file_path`. 3. Normalize the text by converting it to lowercase, and remove any punctuation. 4. Split the text into words. 5. Count the frequency of each word. 6. Return a list of dictionaries, each containing: * `word`: The word itself. * `count`: The frequency of the word in the text. **Specifications**: - If `file_path` is invalid (e.g., `None`, empty string, or file not found) or `top_n` is not a positive integer, return `None`. - Return an empty list if no words are found. - In case of any file reading error or exceptional circumstances, return `None`. - Ignore case and punctuation when counting word frequencies. # Example ```python import string from collections import Counter def get_most_frequent_words(file_path: str, top_n: int) -> list | None: if not file_path or not isinstance(file_path, str) or not isinstance(top_n, int) or top_n <= 0: return None try: with open(file_path, \'r\') as file: text = file.read().lower() text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) words = text.split() word_counts = Counter(words) most_common_words = word_counts.most_common(top_n) result = [ {\'word\': word, \'count\': count} for word, count in most_common_words ] return result except Exception: return None ``` **Test Cases**: 1. `get_most_frequent_words(None, 5)` should return `None` 2. `get_most_frequent_words(\\"\\", 5)` should return `None` 3. `get_most_frequent_words(\\"valid_file_path.txt\\", -1)` should return `None` 4. `get_most_frequent_words(\\"valid_file_path.txt\\", 5)` should return a list of dictionaries with the top 5 most frequent words and their counts. **Notes**: - Use the provided code snippet for base implementation. - Ensure proper error handling and edge case management. - Develop additional test cases to cover various scenarios including different file contents and values for `top_n`.","solution":"import string from collections import Counter def get_most_frequent_words(file_path: str, top_n: int) -> list | None: if not file_path or not isinstance(file_path, str) or not isinstance(top_n, int) or top_n <= 0: return None try: with open(file_path, \'r\') as file: text = file.read().lower() text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) words = text.split() word_counts = Counter(words) most_common_words = word_counts.most_common(top_n) result = [ {\'word\': word, \'count\': count} for word, count in most_common_words ] return result except Exception: return None"},{"question":"# Coding Assessment Question **Context**: The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers, you need to calculate the Hamming distance between them. **Problem**: Implement the `hamming_distance` function that calculates the Hamming distance between two non-negative integers. **Function Signature**: ```python def hamming_distance(x: int, y: int) -> int: ``` **Input**: * x, y: Two non-negative integers where 0 ≤ x, y ≤ 10^9. **Output**: * The function should return the Hamming distance between the two input integers. **Constraints**: * Ensure that your solution works efficiently for large inputs. **Performance Requirements**: * The algorithm should have a time complexity of O(n), where n is the number of bits needed to represent the integers (potentially O(log_max(x, y)) base 2). **Examples**: 1. `hamming_distance(1, 4)` should return `2` 2. `hamming_distance(3, 1)` should return `1` 3. `hamming_distance(0, 0)` should return `0` 4. `hamming_distance(7, 10)` should return `3` **Edge Cases**: 1. Handle the case where both numbers are the same: `hamming_distance(8, 8)` should return `0`. 2. Handle the case where one number is zero: `hamming_distance(0, 15)` should return `4`. 3. Handle the case where the numbers have a wide bit range: `hamming_distance(1024, 4096)` should return `2`.","solution":"def hamming_distance(x: int, y: int) -> int: Calculates the Hamming distance between two non-negative integers. :param x: First non-negative integer :param y: Second non-negative integer :return: The Hamming distance between x and y xor = x ^ y distance = 0 while xor: distance += xor & 1 xor >>= 1 return distance"},{"question":"# Problem Statement You are tasked with implementing a function to simulate the workings of a basic LRU (Least Recently Used) Cache. This cache will store a fixed number of recent items, removing the least recently used item when the cache hits its capacity limit. # Function to Implement Implement the function `lru_cache(capacity: int, operations: List[Tuple[str, int]]) -> List[int]` which: * Simulates an LRU Cache with a given capacity and processes a series of operations. * Returns a list of results generated for each \'get\' operation. # Input Format 1. `capacity` (int): An integer representing the maximum number of items the cache can hold. 2. `operations` (List[Tuple[str, int]]): A list of tuples where each tuple represents an operation: * The first element of the tuple can be either \'get\' or \'put\'. * If the operation is \'get\', the second element represents the key to retrieve. * If the operation is \'put\', the second element represents the key to insert. If the key is already present, it should be updated to be the most recently used. # Output Format * Returns a list of integers, where each integer is the result of a \'get\' operation. If the key is not found in the cache, it should return -1. # Constraints * Cache capacity will always be a positive integer. * The number of operations will always be a non-negative integer. * Memory constraints should be considered for larger dataset operations. # Example Given the following input: ```python capacity = 2 operations = [(\'put\', 1), (\'put\', 2), (\'get\', 1), (\'put\', 3), (\'get\', 2), (\'put\', 4), (\'get\', 1), (\'get\', 3), (\'get\', 4)] ``` The expected output is: ```python [1, -1, -1, 3, 4] ``` # Notes * \'get\' operation should return the value of the key if the key is present in the cache; otherwise, it should return -1. * \'put\' operation should add the key to the cache and mark it as most recently used. If the cache is at capacity, it should evict the least recently used item before adding the new key. * Handle edge cases such as empty operations or repeated keys efficiently. * Ensure that all operations adhere to the LRU cache property.","solution":"from collections import OrderedDict def lru_cache(capacity: int, operations: list): Simulates the workings of a basic LRU Cache. :param capacity: int: The maximum number of items the cache can hold. :param operations: List[Tuple[str, int]]: A list of tuples representing operations: \'get\' or \'put\'. :return: List[int]: A list of results for each \'get\' operation. cache = OrderedDict() result = [] for op in operations: if op[0] == \'get\': key = op[1] if key in cache: result.append(key) cache.move_to_end(key) else: result.append(-1) elif op[0] == \'put\': key = op[1] if key in cache: cache.move_to_end(key) cache[key] = 1 # We\'re storing dummy values as the problem doesn\'t specify what values to store if len(cache) > capacity: cache.popitem(last=False) return result"},{"question":"**Context:** You are asked to develop a utility that computes the sum of elements in a given range of an integer array. This problem frequently arises in the context of competitive programming and performance-critical applications where efficient data retrieval is crucial. # Task: Write a class-based solution using a Segment Tree data structure that allows efficient range sum queries and updates to the array. The Segment Tree should support the following operations: - `build(arr)`: Constructs the Segment Tree from the given array `arr`. - `update(index, value)`: Updates the element at `index` to `value`. - `range_sum(left, right)`: Returns the sum of elements between indices `left` and `right` inclusive. # Specifications: 1. The class should implement the Segment Tree such that: - `build` operation has O(n) time complexity. - `update` and `range_sum` operations have O(log n) time complexity. 2. Handle all edge cases mentioned. # Input and Output: Your methods must match the following signatures: - `build(arr: List[int]) -> None` - `update(index: int, value: int) -> None` - `range_sum(left: int, right: int) -> int` # Constraints: - Assume all elements in the array are integers. - Initial array length is between 1 and 10^5. - Each element in the array is between -10^5 and 10^5. - Maximum number of operations (update + range_sum): 10^5. **Example:** ```python seg_tree = SegmentTree() arr = [1, 3, 5, 7, 9, 11] seg_tree.build(arr) assert seg_tree.range_sum(1, 3) == 15 # 3 + 5 + 7 seg_tree.update(1, 10) assert seg_tree.range_sum(1, 3) == 22 # 10 + 5 + 7 seg_tree.update(2, 0) assert seg_tree.range_sum(1, 3) == 17 # 10 + 0 + 7 try: seg_tree.range_sum(3, 1) except ValueError: assert True # Expected behavior for invalid range ```","solution":"class SegmentTree: def build(self, arr): Constructs the Segment Tree from the given array. self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): Updates the element at index to value. pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): Returns the sum of elements between indices left and right inclusive. if left > right: raise ValueError(\\"Left index cannot be greater than right index\\") left += self.n right += self.n sum_ = 0 while left <= right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 0: sum_ += self.tree[right] right -= 1 left //= 2 right //= 2 return sum_"},{"question":"You are tasked with creating a system to track and manage student grades for a course. The system should be able to store grades for individual students, calculate the average grade for each student, and determine the overall course average. # Task Implement a class that can store and calculate student grades. Your class should be able to add grades for specific students, compute the average grade for a student, and compute the overall average grade for the course. # Class Signature ```python class GradeTracker: def __init__(self): Initializes an empty GradeTracker. pass def add_grade(self, student_name: str, grade: float) -> None: Adds a grade for a specific student. Args: student_name (str): The name of the student. grade (float): The grade to be added. pass def get_student_average(self, student_name: str) -> float: Computes the average grade for a specific student. Args: student_name (str): The name of the student. Returns: float: The average grade of the student. pass def get_course_average(self) -> float: Computes the overall average grade for the course. Returns: float: The overall course average grade. pass ``` # Input * `student_name`: A string containing the name of the student. * `grade`: A float representing the grade to be added for a student. * The `get_student_average` method takes a single string argument, the name of the student. * The `get_course_average` method does not take any arguments. # Output * The `add_grade` method does not return a value. * The `get_student_average` method returns a float representing the average grade of the specified student. * The `get_course_average` method returns a float representing the overall course average grade. # Constraints * Each student may have multiple grades assigned to them. * The grades are floating-point numbers and can range between 0.0 and 100.0. * If there are no grades for a student, `get_student_average` should return 0.0. * If there are no grades in the course at all, `get_course_average` should return 0.0. # Examples ```python tracker = GradeTracker() tracker.add_grade(\\"Alice\\", 90.0) tracker.add_grade(\\"Alice\\", 80.0) tracker.add_grade(\\"Bob\\", 70.0) >>> tracker.get_student_average(\\"Alice\\") 85.0 >>> tracker.get_student_average(\\"Bob\\") 70.0 >>> tracker.get_course_average() 80.0 >>> tracker.add_grade(\\"Bob\\", 60.0) >>> tracker.get_student_average(\\"Bob\\") 65.0 >>> tracker.get_course_average() 75.0 ``` # Additional Notes * The class should handle multiple students, each with their own set of grades. * Ensure the averages are computed accurately and efficiently. * Think about edge cases, such as students with no grades or an empty course.","solution":"class GradeTracker: def __init__(self): Initializes an empty GradeTracker. self.student_grades = {} def add_grade(self, student_name: str, grade: float) -> None: Adds a grade for a specific student. Args: student_name (str): The name of the student. grade (float): The grade to be added. if student_name not in self.student_grades: self.student_grades[student_name] = [] self.student_grades[student_name].append(grade) def get_student_average(self, student_name: str) -> float: Computes the average grade for a specific student. Args: student_name (str): The name of the student. Returns: float: The average grade of the student. if student_name not in self.student_grades or not self.student_grades[student_name]: return 0.0 total = sum(self.student_grades[student_name]) count = len(self.student_grades[student_name]) return total / count def get_course_average(self) -> float: Computes the overall average grade for the course. Returns: float: The overall course average grade. total_sum = 0 total_count = 0 for grades in self.student_grades.values(): total_sum += sum(grades) total_count += len(grades) if total_count == 0: return 0.0 return total_sum / total_count"},{"question":"# Detect Cycle in a Directed Graph Context You are developing a software that needs to work with various graph structures. One common problem is determining whether a directed graph contains a cycle. Detecting cycles in directed graphs is crucial for tasks like scheduling, network analysis, and dependency resolution in package managers. Problem Statement Write a function `detect_cycle_in_directed_graph` that takes the number of nodes and the list of edges of a directed graph and determines whether the graph contains a cycle. Input Format - An integer `n` representing the number of nodes in the graph, where `1 <= n <= 10^4`. - A list `edges` of tuples, where each tuple `(u, v)` represents a directed edge from node `u` to node `v`. - The total number of edges is `m`, where `0 <= m <= 10^4`. Output Format - Return `True` if the graph contains a cycle; otherwise, return `False`. Constraints - The graph may be empty with no nodes and edges. - Nodes are labeled from `0` to `n-1`. Performance Requirements - The time complexity should ideally be O(n + m), leveraging depth-first search (DFS) or another efficient graph traversal algorithm. - The space complexity should be in line with handling the input sizes. Function Signature ```python def detect_cycle_in_directed_graph(n: int, edges: list[tuple[int, int]]) -> bool: pass ``` Example ```python def detect_cycle_in_directed_graph(n: int, edges: list[tuple[int, int]]) -> bool: Determines if a directed graph contains a cycle. from collections import defaultdict def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() visiting = set() for node in range(n): if node not in visited: if dfs(node): return True return False # Example Usage n = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] print(detect_cycle_in_directed_graph(n, edges)) # Output: True ``` Write unit tests to validate the implementation thoroughly, ensuring all edge cases are handled appropriately.","solution":"def detect_cycle_in_directed_graph(n: int, edges: list[tuple[int, int]]) -> bool: Determines if a directed graph contains a cycle. from collections import defaultdict def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() visiting = set() for node in range(n): if node not in visited: if dfs(node): return True return False"},{"question":"# Question: Pair Sum Combination Search You need to implement a function that identifies whether there exists a pair of integers in a given list that sums up to a specified target value. Additionally, another function should return all unique pairs that sum up to the target value without any duplicates. Implement the Following Functions: **1. Function `has_pair_with_sum(lst: list, target: int) -> bool`:** * **Input**: A list of integers `lst` and an integer `target`. * **Output**: A boolean value indicating whether there exists a pair of integers in the list that sums up to the target. * **Constraints**: * Raise a `ValueError` for invalid or empty input. **2. Function `find_pairs_with_sum(lst: list, target: int) -> List[Tuple[int, int]]`:** * **Input**: A list of integers `lst` and an integer `target`. * **Output**: A list of unique integer tuples, each containing a pair of integers from the input list that sum up to the target. Each pair should be presented in ascending order within the tuple. * **Constraints**: * Raise a `ValueError` for invalid or empty input. Example ```python >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([], 8) ValueError: The input list cannot be empty. >>> find_pairs_with_sum([1, 2, 3, 4, 5], 7) [(2, 5), (3, 4)] >>> find_pairs_with_sum([1, 1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3, 9], 8) [] >>> find_pairs_with_sum([], 8) ValueError: The input list cannot be empty. ``` Notes: * Ensure that each pair returned by `find_pairs_with_sum` is unique and sorted in non-decreasing order within the pair. * Consider edge cases, such as invalid inputs and lists with insufficient elements. Performance Requirements: * The implementation of `has_pair_with_sum` should be O(n) in time complexity and O(n) in space complexity. * The implementation of `find_pairs_with_sum` should be O(n^2) in time complexity and O(n) in space complexity. **Good Luck!**","solution":"def has_pair_with_sum(lst, target): Determines if there exists a pair of integers in `lst` that sums up to `target`. Parameters: lst (list): List of integers. target (int): Target sum value. Returns: bool: True if such a pair exists, False otherwise. Raises: ValueError: If the input list is invalid or empty. if not lst: raise ValueError(\\"The input list cannot be empty.\\") seen = set() for num in lst: if target - num in seen: return True seen.add(num) return False def find_pairs_with_sum(lst, target): Finds all unique pairs of integers in `lst` that sum up to `target`. Parameters: lst (list): List of integers. target (int): Target sum value. Returns: list of tuples: List of unique pairs that sum up to `target`. Raises: ValueError: If the input list is invalid or empty. if not lst: raise ValueError(\\"The input list cannot be empty.\\") pairs = set() seen = {} for num in lst: if target - num in seen: pair = tuple(sorted((num, target - num))) pairs.add(pair) seen[num] = True return list(pairs)"},{"question":"# Problem Statement Write a function `find_factors` that computes all the factors of a given positive integer. The function should return a list of integers representing the factors, sorted in ascending order. # Function Signature ```python def find_factors(number: int) -> list: ``` # Parameters: - `number` (int): A positive integer for which the factors need to be found. Must be greater than zero. # Returns: - A list of integers representing the factors of the given number, sorted in ascending order. # Constraints: - The function must raise a `ValueError` if `number` is less than or equal to zero. # Example ```python # Example 1 print(find_factors(12)) # Output: [1, 2, 3, 4, 6, 12] # Example 2 print(find_factors(7)) # Output: [1, 7] # Example 3 print(find_factors(16)) # Output: [1, 2, 4, 8, 16] # Example 4 print(find_factors(25)) # Output: [1, 5, 25] # Example 5 print(find_factors(1)) # Output: [1] ``` Notes: - Ensure that the function performs input validation and handles erroneous inputs gracefully by raising appropriate exceptions. - You can assume that the input will be an integer within the range of typical computational constraints.","solution":"def find_factors(number: int) -> list: Computes all the factors of a given positive integer. Args: number (int): A positive integer for which the factors need to be found. Must be greater than zero. Returns: list: A list of integers representing the factors of the given number, sorted in ascending order. Raises: ValueError: If number is less than or equal to zero. if number <= 0: raise ValueError(\\"number must be greater than zero\\") factors = [] for i in range(1, number + 1): if number % i == 0: factors.append(i) return factors"},{"question":"# **Question: Implement a Real-Time Moving Average Filter** You are tasked with writing a function to apply a moving average filter to a real-time stream of numerical data. A moving average filter smooths data by averaging consecutive values in a specified window size. **Your task:** Implement a function `moving_average_filter` that processes a stream of numerical data in real-time, outputting the filtered signal with the help of a moving average filter. **Function Signature:** ```python from typing import List def moving_average_filter(signal: List[float], window_size: int) -> List[float]: pass ``` **Requirements:** 1. **Inputs**: - `signal`: A list of floating-point numbers representing the data stream. - `window_size`: An integer representing the number of consecutive samples to average. 2. **Outputs**: - **List of float**: The filtered signal as a list of floating-point numbers. 3. **Constraints**: - `signal` should be a list containing up to 1,000,000 floating-point values. - `window_size` is a positive integer and will be less than or equal to the length of `signal`. 4. **Performance**: - The function should efficiently handle the upper limit of the `signal` size, i.e., 1,000,000 samples. 5. **Implementation Notes**: - The moving average for the first `window_size-1` elements can be the average of the available preceding elements. - The function should update the average progressively to simulate real-time data processing. Here is a sample usage: ```python # Example Usage filtered_signal = moving_average_filter([10, 20, 30, 40, 50, 60], 3) print(filtered_signal) # Output should be smoothened values ``` Explain how you ensure the solution is correct and optimized for real-time applications.","solution":"from typing import List def moving_average_filter(signal: List[float], window_size: int) -> List[float]: Apply a moving average filter to the input signal with the specified window size. Args: signal (List[float]): The input data stream as a list of floats. window_size (int): The number of consecutive samples to average. Returns: List[float]: The filtered signal. if window_size <= 0 or window_size > len(signal): raise ValueError(\\"window_size must be a positive integer and less than or equal to the length of signal\\") n = len(signal) filtered_signal = [] window_sum = 0.0 for i in range(n): window_sum += signal[i] if i >= window_size: window_sum -= signal[i - window_size] if i < window_size - 1: filtered_signal.append(window_sum / (i + 1)) else: filtered_signal.append(window_sum / window_size) return filtered_signal"},{"question":"You are required to implement a method in the given `LinkedList` code that removes all duplicate values from the list. The objective of the new method is to ensure that each value appears only once in the list. # Task Implement a method `remove_duplicates(self) -> None` in the `LinkedList` class which removes all duplicate values from the list. # Input This implementation does not require any input as it operates on the `LinkedList` instance itself. However, it is expected that the list will already contain nodes added by `append`. # Output Removing duplicates will modify the list structure internally to ensure no duplicate values but will not produce an explicit function output. # Constraints * You may not use additional data structures like hash sets for this problem; you need to accomplish this within the linked list using the available node traversal. * Maintain the basic properties of a LinkedList. # Example Consider the following sequence of events: ```python lst = LinkedList() lst.append(1) lst.append(2) lst.append(2) lst.append(3) lst.append(3) lst.append(4) print([n.value for n in lst.to_list()]) # Output: [1, 2, 2, 3, 3, 4] lst.remove_duplicates() print([n.value for n in lst.to_list()]) # Output: [1, 2, 3, 4] ``` # Tips 1. You can use nested loops to compare each element with every other element in the list to identify and remove duplicates. 2. Alternatively, as you traverse the list, compare each node\'s value with the next node\'s value and remove it if they are the same. Implement your solution inside the `LinkedList` class below.","solution":"class LinkedList: class Node: def __init__(self, value, next=None): self.value = value self.next = next def __init__(self): self.head = None def append(self, value): if not self.head: self.head = self.Node(value) else: current = self.head while current.next: current = current.next current.next = self.Node(value) def to_list(self): elements = [] current = self.head while current: elements.append(current) current = current.next return elements def remove_duplicates(self): current = self.head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Longest Increasing Subsequence Subset Sum You are given a list of integers. Your task is to implement the following function: 1. **longest_subsequence_sum(nums)**: - **Input**: A list of integers `nums`. - **Output**: Return the maximum sum of the longest increasing subsequence in the list. - **Constraints**: * There can be multiple subsequences with the same length; consider the one with the maximum sum. **Function Signature**: ```python def longest_subsequence_sum(nums: list[int]) -> int: pass ``` # Example ```python # Example usage: nums = [10, 22, 9, 33, 21, 50, 41, 60, 80] # Test longest_subsequence_sum assert longest_subsequence_sum(nums) == 255 # The subsequence is [10, 22, 33, 50, 60, 80] nums = [3, 4, -1, 0, 6, 2, 3] assert longest_subsequence_sum(nums) == 13 # The subsequence is [3, 4, 6] nums = [3, 2] assert longest_subsequence_sum(nums) == 3 # The subsequence is [3] nums = [-1, -2, -3, -4, -5] assert longest_subsequence_sum(nums) == -1 # The subsequence is [-1] ``` **Note**: - Your implementation should be efficient in terms of time complexity. - Handle edge cases such as an empty list or a list with all non-positive integers.","solution":"def longest_subsequence_sum(nums: list[int]) -> int: if not nums: return 0 n = len(nums) dp = nums[:] max_sum = dp[0] for i in range(1, n): for j in range(i): if nums[i] > nums[j] and dp[i] < dp[j] + nums[i]: dp[i] = dp[j] + nums[i] max_sum = max(max_sum, dp[i]) return max_sum"},{"question":"# Coding Question Context: As a software engineer, you are tasked with developing a utility function for managing and processing batches of numerical data. One specific functionality needed is to determine linear trends and general statistics efficiently from the provided lists of numbers. Requirements: 1. **Function Implementations**: * Implement the `is_arithmetic_series` function to check if a list forms an arithmetic series. * Implement the `mean_median_mode` function to calculate mean, median, and mode of a list of numbers. 2. **Input Format**: * A list of integers. 3. **Output Format**: * `is_arithmetic_series`: A boolean value (`True` if it is an arithmetic series, `False` otherwise). * `mean_median_mode`: A tuple containing three elements - mean (float), median (float), and mode (int). 4. **Constraints**: * The list can contain zero or more integers. * Handle the cases of empty and invalid lists by raising `ValueError` where appropriate. * If there is more than one mode, return the smallest one. Function Signatures: ```python def is_arithmetic_series(series: list) -> bool: pass def mean_median_mode(series: list) -> tuple: pass ``` Example: ```python # Example for is_arithmetic_series print(is_arithmetic_series([1, 3, 5, 7])) # Output: True print(is_arithmetic_series([2, 4, 7, 10])) # Output: False print(is_arithmetic_series([5, 10, 15])) # Output: True # Example for mean_median_mode print(mean_median_mode([1, 3, 3, 9])) # Output: (4.0, 3.0, 3) print(mean_median_mode([2, 2, 2, 2])) # Output: (2.0, 2.0, 2) print(mean_median_mode([1, 3, 8, 9, 9])) # Output: (6.0, 8.0, 9) print(mean_median_mode([7, 8, 7])) # Output: (7.333333333333333, 7.0, 7) ``` Description: 1. **`is_arithmetic_series` Function**: * Takes a list of integers `series` as input. * Raises `ValueError` for non-list inputs or empty lists. * Returns `True` if the input list is an arithmetic series, `False` otherwise. 2. **`mean_median_mode` Function**: * Takes a list of integers `series` as input. * Raises `ValueError` for non-list inputs or empty lists. * Calculates the mean, median, and mode of the input list and returns them in a tuple. * If the list contains more than one mode, return the smallest one.","solution":"def is_arithmetic_series(series: list) -> bool: Checks if the given list forms an arithmetic series. Args: series (list): A list of integers. Returns: bool: True if it is an arithmetic series, False otherwise. if not isinstance(series, list) or not all(isinstance(x, int) for x in series): raise ValueError(\\"Input should be a list of integers\\") if len(series) < 2: return True diff = series[1] - series[0] for i in range(1, len(series) - 1): if series[i + 1] - series[i] != diff: return False return True def mean_median_mode(series: list) -> tuple: Calculates the mean, median, and mode of a list of numbers. Args: series (list): A list of integers. Returns: tuple: A tuple containing mean (float), median (float), and mode (int). if not isinstance(series, list) or not all(isinstance(x, int) for x in series): raise ValueError(\\"Input should be a list of integers\\") if len(series) == 0: raise ValueError(\\"The list should not be empty\\") n = len(series) mean = sum(series) / n sorted_series = sorted(series) if n % 2 == 0: median = (sorted_series[n//2 - 1] + sorted_series[n//2]) / 2 else: median = sorted_series[n//2] from collections import Counter counts = Counter(sorted_series) max_freq = max(counts.values()) mode_candidates = [k for k, v in counts.items() if v == max_freq] mode = min(mode_candidates) return (mean, median, mode)"},{"question":"# Flight Board Management System You have been tasked with developing a function for an airport\'s flight information display system. The system must handle a series of operations to manage incoming and outgoing flights, and display the current status of flights. Implement a function `flight_info_system` that processes various operations and returns the results of requests for flight information. **Function Signature**: ```python def flight_info_system(operations: List[str]) -> List[str]: ``` **Input**: - `operations`: a list of strings representing operations related to flight management. Each string can be one of the following: - `\\"arrival <flight_number>\\"`: Indicates the arrival of a flight and adds it to the list of arriving flights. - `\\"depart <flight_number>\\"`: Indicates the departure of a flight and removes it from the list of arriving flights. - `\\"next_departure\\"`: Returns the flight number of the next flight scheduled to depart. - `\\"current_flights\\"`: Returns a comma-separated list of all flight numbers currently in the system. - `\\"clear\\"`: Clears all flight information from the system. **Output**: - List of strings representing the results of the operations: - For `\\"next_departure\\"`, return the flight number of the departing flight. - For `\\"current_flights\\"`, return a comma-separated string of flight numbers. - Ignore the output for `\\"arrival\\"`, `\\"depart\\"`, and `\\"clear\\"` operations. **Constraints**: - You can assume that no invalid operations will be provided in the input. - Flight numbers are unique. - Operations are case sensitive. **Example**: ```python operations = [ \\"arrival AA101\\", \\"arrival BA202\\", \\"next_departure\\", \\"depart AA101\\", \\"next_departure\\", \\"arrival DL303\\", \\"current_flights\\", \\"clear\\", \\"current_flights\\" ] assert flight_info_system(operations) == [ \\"AA101\\", \\"BA202\\", \\"BA202,DL303\\", \\"\\" ] ``` **Notes**: 1. Follow the provided constraints and ensure efficient handling of flight operations. 2. The sequence of operations should be handled in the order they appear in the input list. 3. Ensure to return the proper results in the exact format as described.","solution":"def flight_info_system(operations): flight_set = set() result = [] for operation in operations: op_parts = operation.split() if op_parts[0] == \\"arrival\\": flight_set.add(op_parts[1]) elif op_parts[0] == \\"depart\\": if op_parts[1] in flight_set: flight_set.remove(op_parts[1]) elif op_parts[0] == \\"next_departure\\": if flight_set: result.append(min(flight_set)) elif op_parts[0] == \\"current_flights\\": result.append(\\",\\".join(sorted(flight_set))) elif op_parts[0] == \\"clear\\": flight_set.clear() return result"},{"question":"# Next Greater Element **Problem Description**: Given a list of integers, you are required to find the \\"next greater element\\" for each element in the list. The \\"next greater element\\" for an element `x` in the list is the first element on the right side of `x` that is greater than `x`. If no such element exists, return `-1` for that position. Write a function named `next_greater_elements(nums: List[int]) -> List[int]` that takes a list of integers and returns a list where each element is replaced by its next greater element. **Function Signature**: ```python def next_greater_elements(nums: List[int]) -> List[int]: pass ``` **Input**: * `nums` (1 ≤ len(nums) ≤ 10^4, -10^9 ≤ nums[i] ≤ 10^9): A list of integers. **Output**: * Returns a list of integers where each integer is replaced by the next greater element, or `-1` if no such element exists. **Examples**: ```python next_greater_elements([4, 5, 2, 10, 8]) # Returns [5, 10, 10, -1, -1] next_greater_elements([3, 2, 1]) # Returns [-1, -1, -1] next_greater_elements([1, 3, 2, 4]) # Returns [3, 4, 4, -1] ``` **Constraints**: * The algorithm should run in linear time, `O(n)`, where `n` is the length of the input list. * You may assume that the input list is non-empty. **Hints**: 1. Use a stack to keep track of indices of elements for which we have not found the next greater element yet. 2. Traverse the list once while maintaining the stack to ensure an efficient solution.","solution":"from typing import List def next_greater_elements(nums: List[int]) -> List[int]: n = len(nums) res = [-1] * n stack = [] for i in range(n): while stack and nums[stack[-1]] < nums[i]: index = stack.pop() res[index] = nums[i] stack.append(i) return res"},{"question":"# Context: In computer graphics, mapping points from one coordinate space to another is a fundamental task, especially in transformations and rendering. This involves various linear algebra operations, which are central to graphics programming. # Objective: Implement a function that computes the coordinates of a point after applying a 2D linear transformation matrix. This function should handle edge cases such as when the point or matrix provided is invalid. # Problem Statement: Write a function `transform_point` that applies a 2D transformation matrix to a point and returns the new coordinates of the point. The transformation matrix is a 2x2 matrix, and the point is represented as a tuple of x and y coordinates. [ begin{bmatrix} a & b c & d end{bmatrix} ] The new coordinates ( (x_{text{new}}, y_{text{new}}) ) are computed as: [ begin{bmatrix} x_{text{new}} y_{text{new}} end{bmatrix} = begin{bmatrix} a & b c & d end{bmatrix} begin{bmatrix} x y end{bmatrix} ] Function Signature: ```python def transform_point(matrix: [[float, float], [float, float]], point: (float, float)) -> (float, float): pass ``` Input: - `matrix`: A 2x2 nested list representing the transformation matrix, e.g., [[a, b], [c, d]]. Each element should be a floating-point number. - `point`: A tuple of two floating-point numbers representing the x and y coordinates of the point. Output: - Returns a tuple of two floating-point numbers representing the new coordinates after transformation. Constraints: - If the matrix is not a 2x2 list or contains non-float elements, raise an `Exception` with message `\\"Invalid transformation matrix\\"`. - If the point is not a tuple of two floats, raise an `Exception` with message `\\"Invalid point coordinates\\"`. # Examples: ```python >>> transform_point([[1, 2], [3, 4]], (1, 1)) (3.0, 7.0) >>> transform_point([[0.5, 0], [0, 0.5]], (2, 4)) (1.0, 2.0) >>> transform_point([[1, 0], [0, 1]], (5, -3)) (5.0, -3.0) >>> transform_point([[1, 2], [3, 4]], \\"point\\") Exception: Invalid point coordinates >>> transform_point([[1, 2, 3], [4, 5, 6]], (1, 1)) Exception: Invalid transformation matrix ```","solution":"def transform_point(matrix: [[float, float], [float, float]], point: (float, float)) -> (float, float): Applies a 2D transformation matrix to a point and returns the new coordinates. matrix: a 2x2 nested list representing the transformation matrix. point: a tuple of two floating-point numbers representing the x and y coordinates of the point. Returns a tuple of two floating-point numbers representing the new coordinates. # Validate matrix if not (isinstance(matrix, list) and len(matrix) == 2 and all(isinstance(row, list) and len(row) == 2 for row in matrix) and all(isinstance(elem, (int, float)) for row in matrix for elem in row)): raise Exception(\\"Invalid transformation matrix\\") # Validate point if not (isinstance(point, tuple) and len(point) == 2 and all(isinstance(coord, (int, float)) for coord in point)): raise Exception(\\"Invalid point coordinates\\") # Matrix multiplication a, b = matrix[0] c, d = matrix[1] x, y = point new_x = a * x + b * y new_y = c * x + d * y return (new_x, new_y)"},{"question":"# Question: Find Kth Largest Element in an Array You are given an array of integers. Your task is to write a function that returns the Kth largest element in the given array. # Function Signature ```python def find_kth_largest(nums: list, k: int) -> int: Finds the Kth largest element in the given array. Parameters: nums (list): A list of integers (1 ≤ len(nums) ≤ 1000). k (int): An integer (1 ≤ k ≤ len(nums)). Returns: int: The Kth largest element in the array. ``` # Input - A list of integers, `nums` (1 ≤ len(nums) ≤ 1000). - An integer, `k` (1 ≤ k ≤ len(nums)). # Output - An integer representing the Kth largest element in the array. # Example ```python # Input nums = [3, 2, 1, 5, 6, 4] k = 2 # Output 5 ``` ```python # Input nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 # Output 4 ``` # Notes - You can assume the array does not contain any duplicate values. - Aim to write an efficient solution that leverages appropriate data structures or algorithms for finding the Kth largest element. - Avoid using simple sorting methods if possible. Instead, think about heap data structures or other algorithms that can solve this problem in less than O(n log n) time complexity.","solution":"import heapq def find_kth_largest(nums: list, k: int) -> int: Finds the Kth largest element in the given array. Parameters: nums (list): A list of integers (1 ≤ len(nums) ≤ 1000). k (int): An integer (1 ≤ k ≤ len(nums)). Returns: int: The Kth largest element in the array. # Use a min-heap of size k to keep track of the top k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"# Context Graph traversal algorithms are essential in many applications including networking, social network analysis, and solving puzzles or games. Depth-First Search (DFS) and Breadth-First Search (BFS) are two fundamental graph traversal techniques widely used in computer science. # Problem Statement You are required to extend the provided `Graph` class to include methods for both Depth-First Search (DFS) and Breadth-First Search (BFS). The graph representation is an adjacency list where nodes are represented by strings. # Function Specifications: DFS: **Input**: - `start`: A string representing the starting node. **Output**: - Returns a list of nodes visited in the order of DFS traversal. BFS: **Input**: - `start`: A string representing the starting node. **Output**: - Returns a list of nodes visited in the order of BFS traversal. # Example: ```python g = Graph() g.add_edge(\\"A\\", \\"B\\") g.add_edge(\\"A\\", \\"C\\") g.add_edge(\\"B\\", \\"D\\") g.add_edge(\\"C\\", \\"D\\") g.add_edge(\\"D\\", \\"E\\") # DFS starting from node \\"A\\" print(g.dfs(\\"A\\")) # Output: [\\"A\\", \\"B\\", \\"D\\", \\"E\\", \\"C\\"] # BFS starting from node \\"A\\" print(g.bfs(\\"A\\")) # Output: [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] ``` # Constraints: - You may assume that every node is reachable from the start node. - The graph does not contain any cycles. - Each node has at most 10 directly connected nodes. - The graph does not have more than 100 nodes. # Additional Notes: - Ensure that both the DFS and BFS methods handle graphs with varying structures appropriately. - You may reuse code or data structures such as stacks or queues as needed, but the methods must follow the specified input and output formats. - Include edge cases in your implementation such as handling graphs with only one node or no edges. # Graph Class Definition: ```python class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, node1, node2): if node1 not in self.adjacency_list: self.adjacency_list[node1] = [] if node2 not in self.adjacency_list: self.adjacency_list[node2] = [] self.adjacency_list[node1].append(node2) self.adjacency_list[node2].append(node1) # For undirected graph def dfs(self, start): # Implement DFS here pass def bfs(self, start): # Implement BFS here pass ```","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, node1, node2): if node1 not in self.adjacency_list: self.adjacency_list[node1] = [] if node2 not in self.adjacency_list: self.adjacency_list[node2] = [] self.adjacency_list[node1].append(node2) self.adjacency_list[node2].append(node1) # For undirected graph def dfs(self, start): visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(neighbour for neighbour in self.adjacency_list[node] if neighbour not in visited) return visited def bfs(self, start): visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(neighbour for neighbour in self.adjacency_list[node] if neighbour not in visited) return visited"},{"question":"# Problem Statement You are tasked with developing a system to manage a parking lot efficiently. The system should support adding vehicles, removing vehicles, and retrieving the current status of the parking lot, including which parking spaces are occupied and which are free. # Objectives 1. **Manage Parking Space**: Implement the `ParkingLot` class that initializes with a given number of parking spots. 2. **Vehicle Management**: Enable addition and removal of vehicles by registration number. 3. **Status Retrieval**: Provide the current status of the parking lot, including occupied and free spaces. # Function Signatures - `__init__(self, num_spots: int)` - `park_vehicle(self, reg_number: str) -> str` - `remove_vehicle(self, reg_number: str) -> str` - `get_status(self) -> dict[str, list[int | str]]` # Example ```python P = ParkingLot(10) print(P.park_vehicle(\\"ABC123\\")) # Output: \\"Vehicle ABC123 parked at spot 1.\\" print(P.park_vehicle(\\"XYZ789\\")) # Output: \\"Vehicle XYZ789 parked at spot 2.\\" print(P.remove_vehicle(\\"ABC123\\")) # Output: \\"Vehicle ABC123 removed from spot 1.\\" print(P.get_status()) # Output: {\\"occupied\\": [(2, \\"XYZ789\\")], \\"free\\": [1, 3, 4, 5, 6, 7, 8, 9, 10]} ``` # Constraints - There will be at most 10,000 parking spots. - Registration numbers are non-empty strings up to 20 characters in length. - All registration numbers are unique. # Hints 1. Use a list to manage parking spots and a dictionary to map registration numbers to parking spots. 2. Ensure the addition and removal of vehicles handle edge cases, such as trying to park when the lot is full or removing a non-existent vehicle. # Performance Requirements - Your solution should efficiently handle operations within the maximum constraints in acceptable time limits.","solution":"class ParkingLot: def __init__(self, num_spots: int): Initializes a ParkingLot with the given number of spots. self.num_spots = num_spots self.spots = [None] * num_spots self.reg_to_spot = {} def park_vehicle(self, reg_number: str) -> str: Parks the vehicle with the given registration number in the next available spot. if reg_number in self.reg_to_spot: return f\\"Vehicle {reg_number} is already parked.\\" for i in range(self.num_spots): if self.spots[i] is None: self.spots[i] = reg_number self.reg_to_spot[reg_number] = i + 1 return f\\"Vehicle {reg_number} parked at spot {i + 1}.\\" return \\"Parking lot is full.\\" def remove_vehicle(self, reg_number: str) -> str: Removes the vehicle with the given registration number from the parking lot. if reg_number not in self.reg_to_spot: return f\\"Vehicle {reg_number} not found.\\" spot_index = self.reg_to_spot[reg_number] - 1 self.spots[spot_index] = None del self.reg_to_spot[reg_number] return f\\"Vehicle {reg_number} removed from spot {spot_index + 1}.\\" def get_status(self) -> dict: Provides the current status of the parking lot, showing occupied and free spots. occupied = [(i + 1, reg) for i, reg in enumerate(self.spots) if reg is not None] free = [i + 1 for i, reg in enumerate(self.spots) if reg is None] return {\\"occupied\\": occupied, \\"free\\": free}"},{"question":"# Problem: Identify and Correct Invalid Parentheses You are given a string containing only parentheses: `(` and `)`. Your task is to write a program that modifies the string to make all parentheses pairs valid. Specifically, you need to determine the minimum number of parentheses to remove to make the string valid, as well as output the resulting valid string. A string of parentheses is valid if: 1. The parentheses are correctly opened and closed. 2. Any opening parenthesis `(` must have a corresponding closing parenthesis `)` and vice versa. Input * A string `s` which contains only the characters `(` and `)`. Output * An integer, corresponding to the count of removed parentheses. * A string, which is the resulting valid string after removals. Constraints * The length of string `s` will be within the range 1 ≤ |s| ≤ 10^5. Example ```python find_min_removals(\\"()())()\\" == (1, \\"()()()\\") find_min_removals(\\")(\\" == (2, \\"\\")) ``` # Note * In the first example, one closing parenthesis at index 4 is removed to make the string valid. * In the second example, both parentheses are invalid and need to be removed. Function Signature ```python def find_min_removals(s: str) -> tuple: ```","solution":"def find_min_removals(s: str) -> tuple: Given a string of parentheses, determine the minimum number of parentheses to remove to make it valid and return the resulting valid string. Args: s (str): A string containing only \'(\' and \')\'. Returns: tuple: A tuple containing two elements: - An integer count of removed parentheses. - The resulting valid string. stack = [] indices_to_remove = set() # Determine the indices of invalid parentheses for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: indices_to_remove.add(i) while stack: indices_to_remove.add(stack.pop()) # Build the resulting valid string result = [] for i, char in enumerate(s): if i not in indices_to_remove: result.append(char) return (len(indices_to_remove), \\"\\".join(result))"},{"question":"Question Your task is to implement a function that generates the `n`th row of Pascal\'s Triangle. Pascal\'s Triangle is a triangular array of the binomial coefficients. Given a non-negative index `n`, return the `n`th row of the triangle. # Function Signature ```python def get_pascals_triangle_row(n: int) -> List[int]: Returns the nth row of Pascal\'s Triangle. ``` # Input - `n` (int): The row index (0-based). # Output - Returns `List[int]`: The `n`th row of Pascal\'s Triangle as a list of integers. # Example ```python get_pascals_triangle_row(0) # Expected Output: [1] get_pascals_triangle_row(3) # Expected Output: [1, 3, 3, 1] get_pascals_triangle_row(5) # Expected Output: [1, 5, 10, 10, 5, 1] ``` # Constraints * The function should efficiently compute the result even for larger values of `n`. # Scenario Consider a situation where you are implementing a part of a mathematics educational software that visualizes different mathematical concepts. You need a method to generate specific rows of Pascal\'s Triangle to illustrate binomial expansions and combinatorial properties.","solution":"from typing import List def get_pascals_triangle_row(n: int) -> List[int]: Returns the nth row of Pascal\'s Triangle. row = [1] for i in range(n): row.append(row[-1] * (n - i) // (i + 1)) return row"},{"question":"# Coding Assessment Task: Context: You are working on a logistics software system and need to design a function that can calculate the optimal route for package delivery in a city. The city is modeled as a grid, and you need to find the shortest path from a warehouse to multiple customer locations. Problem Statement: Given a grid representing a city, where 0 indicates an open path and 1 indicates an obstacle, implement a function `shortest_delivery_route` to find the length of the optimal route from the warehouse to each customer location. The function should return the total path length for delivering to all customers from the warehouse in the shortest possible order. Function Signature: ```python def shortest_delivery_route(grid: list, warehouse: tuple, customers: list) -> int: pass ``` Input/Output: * **Input**: - `grid`: A 2D list of integers, where 0 represents open paths and 1 represents obstacles. - `warehouse`: A tuple (x, y) indicating the starting position in the grid. - `customers`: A list of tuples [(x1, y1), (x2, y2), ...] representing customer locations in the grid. * **Output**: An integer representing the shortest total path length to deliver from the warehouse to all customer locations. Constraints: - The grid dimensions are between 1x1 and 50x50. - There is at least one customer. - All positions (warehouse and customers) will be within the grid bounds and on open paths. - You can only move up, down, left, or right. Examples: ```python >>> shortest_delivery_route( ... [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ], ... (0, 0), ... [(2, 3), (3, 2)] ... ) 10 >>> shortest_delivery_route( ... [ ... [0, 1], ... [0, 0] ... ], ... (0, 0), ... [(1, 1)] ... ) 2 >>> shortest_delivery_route( ... [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ], ... (0, 0), ... [(2, 2)] ... ) 4 ``` Notes: 1. The solution should be efficient enough to handle larger grid sizes. 2. Raise an appropriate `ValueError` if any input constraints are violated (though the task ensures valid inputs, this is to adhere to good practice).","solution":"from collections import deque def bfs(grid, start): rows, cols = len(grid), len(grid[0]) distances = [[float(\'inf\')] * cols for _ in range(rows)] distances[start[0]][start[1]] = 0 queue = deque([start]) while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and distances[nx][ny] == float(\'inf\'): distances[nx][ny] = distances[x][y] + 1 queue.append((nx, ny)) return distances def shortest_delivery_route(grid, warehouse, customers): # Edge case if there are no customers if not customers: return 0 rows, cols = len(grid), len(grid[0]) # Check if warehouse or any customer positions are invalid if not (0 <= warehouse[0] < rows and 0 <= warehouse[1] < cols and grid[warehouse[0]][warehouse[1]] == 0): raise ValueError(\\"Warehouse position is invalid or obstructed.\\") for customer in customers: if not (0 <= customer[0] < rows and 0 <= customer[1] < cols and grid[customer[0]][customer[1]] == 0): raise ValueError(f\\"Customer position {customer} is invalid or obstructed.\\") # Calculate shortest paths from warehouse to all points warehouse_distances = bfs(grid, warehouse) # Accumulate total length by finding the shortest paths to each customer total_length = 0 current_pos = warehouse for customer in customers: total_length += warehouse_distances[customer[0]][customer[1]] return total_length"},{"question":"# Problem Statement You are tasked with implementing a `Stack` class that supports typical stack operations with additional functionality to get the current minimum element in the stack in constant time. The goal is to practice developing a stack data structure with an enhanced feature for minimum value retrieval. Implement methods in the `Stack` class to handle: 1. Pushing one or multiple values onto the stack. 2. Popping the topmost value off the stack. 3. Retrieving the top value without removing it. 4. Getting the current minimum value of the stack. # Function Specifications 1. **Push Function** ```python def push(self, *values) -> None: ``` - **Input**: A sequence of integers representing values to be added to the stack. - **Output**: None. 2. **Pop Function** ```python def pop(self) -> int: ``` - **Input**: None. - **Output**: The value that is popped off the stack. - **Constraints**: Raises an IndexError if the stack is empty. 3. **Top Function** ```python def top(self) -> int: ``` - **Input**: None. - **Output**: The top value of the stack. - **Constraints**: Raises an IndexError if the stack is empty. 4. **Get Min Function** ```python def get_min(self) -> int: ``` - **Input**: None. - **Output**: The minimum value currently in the stack. - **Constraints**: Raises an IndexError if the stack is empty. # Examples ```python s = Stack() s.push(5, 2, 10, 1, 3) assert s.top() == 3 assert s.get_min() == 1 s.pop() assert s.get_min() == 1 s.pop() assert s.get_min() == 2 s.pop() assert s.get_min() == 2 s.pop() assert s.get_min() == 5 ``` # Notes - Ensure the stack operations (pushing, popping, and getting the top value) have an average time complexity of O(1). - The `get_min` function must also operate in O(1) time. - Consider maintaining an auxiliary stack to help with retrieving the minimum value in constant time.","solution":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, *values) -> None: for value in values: self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") popped_value = self.stack.pop() if popped_value == self.min_stack[-1]: self.min_stack.pop() return popped_value def top(self) -> int: if not self.stack: raise IndexError(\\"stack is empty\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"stack is empty\\") return self.min_stack[-1]"},{"question":"# Threaded Binary Tree Traversal A threaded binary tree is a binary tree variant where null pointers are replaced with pointers (threads) to in-order predecessors or successors, ensuring lesser space complexity and enabling faster traversal. Create a function to perform an in-order traversal on a given threaded binary tree. The tree\'s nodes contain an extra boolean field, `isThreaded`, which indicates if the right pointer of a node is a threaded pointer rather than pointing to a right child. **Task**: Implement a function that accepts the root node of a threaded binary tree and returns the in-order traversal of the tree as a list of node values. Function Signature ```python class TreeNode: def __init__(self, value: int, left=None, right=None, isThreaded=False): self.value = value self.left = left self.right = right self.isThreaded = isThreaded def inorder_traversal(root: TreeNode) -> list: pass ``` Implementation Requirements: 1. Traverse the tree in in-order fashion. 2. Use the `isThreaded` field to follow threaded pointers where applicable. 3. Collect and return the values encountered during traversal in a list. Input - root: A TreeNode object representing the root of a threaded binary tree. Output - A list of integers representing the in-order traversal of the tree. Example ```python # Example threaded binary tree # 4 # / # 2 6 # / / # 1 3 5 (4\'s right points to 5 via threading) root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6, isThreaded=True) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) >>> inorder_traversal(root) [1, 2, 3, 4, 5, 6] ``` Constraints - The number of nodes in the tree is in the range [1, 1000]. - Node values are distinct integers. - Ensure the function efficiently processes the traversal using threading where applicable. Note - The function should be capable of recognizing and correctly navigating both child pointers and threaded pointers during traversal. - This task tests your understanding of advanced tree structures and traversal techniques. --- By addressing the unique aspects of a threaded binary tree, this task complements the existing questions by exploring tree traversal in an advanced binary tree variant, maintaining the focus on efficient algorithms and data structures.","solution":"class TreeNode: def __init__(self, value: int, left=None, right=None, isThreaded=False): self.value = value self.left = left self.right = right self.isThreaded = isThreaded def inorder_traversal(root: TreeNode) -> list: result = [] current = root while current is not None: if current.left is None: result.append(current.value) current = current.right else: # Find the rightmost node in the left subtree or threaded link pre = current.left while pre.right is not None and pre.right != current: pre = pre.right # Make current as the right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None result.append(current.value) current = current.right return result"},{"question":"# Distance Calculation Coding Challenge Context Calculating distances between points is a fundamental concept in many areas, including computer graphics, navigation, and machine learning. You are required to implement a function that computes the Euclidean distance between points on a 2D plane. Task Write a function `euclidean_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float` that calculates the Euclidean distance between two points on a 2D plane. Each point is represented as a tuple of two floating-point numbers (x, y). Input/Output Formats * **Input**: Two tuples `point1` and `point2`, each containing two floating-point numbers representing the coordinates of a point. * Example: `point1 = (3.0, 4.0)`, `point2 = (0.0, 0.0)` * **Output**: A floating-point number representing the Euclidean distance between the two points. * Example: `5.0` Constraints * The coordinates can be any floating-point number, including negative numbers. * The coordinates will not exceed 10^6 in magnitude. Performance Requirements * The function should run efficiently with a constant time complexity of O(1). Example Code ```python import math def euclidean_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Test Cases print(euclidean_distance((3.0, 4.0), (0.0, 0.0))) # Output: 5.0 print(euclidean_distance((1.5, -1.5), (-1.5, 1.5))) # Output: 4.242640687119285 print(euclidean_distance((0.0, 0.0), (0.0, 0.0))) # Output: 0.0 print(euclidean_distance((10**6, 10**6), (-10**6, -10**6))) # Output: 2828427.12474619 ``` Note * Make sure the function handles edge cases such as when both points are the same. * Inputs that do not conform to the expected format should raise a TypeError.","solution":"import math def euclidean_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: Calculate the Euclidean distance between two points in a 2D plane. :param point1: Tuple containing two floats representing the x and y coordinates of the first point. :param point2: Tuple containing two floats representing the x and y coordinates of the second point. :return: A float representing the Euclidean distance between the two points. if not isinstance(point1, tuple) or not isinstance(point2, tuple): raise TypeError(\\"Both points must be of type tuple.\\") if len(point1) != 2 or len(point2) != 2: raise ValueError(\\"Both points must contain exactly two elements.\\") x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"Implement a function `invert_matrix(matrix: List[List[int]]) -> Tuple[bool, Optional[List[List[int]]]]` that determines if a given square matrix is invertible. If it is, return the inverse of the matrix. If the matrix is not invertible, return `False` and `None`. Assume the usage of standard Python list of lists to represent matrices. # Function Signature ```python def invert_matrix(matrix: List[List[int]]) -> Tuple[bool, Optional[List[List[int]]]]: ``` # Input * `matrix` (List[List[int]]): A 2D list representing a square matrix of integers. # Output * A tuple where the first element is a boolean indicating if the matrix is invertible, and the second element is an optional list of lists representing the inverse matrix if it is invertible. # Constraints * The input matrix will always be a square matrix with dimensions n x n where 1 ≤ n ≤ 100. # Examples ```python >>> matrix = [ [4, 7], [2, 6] ] >>> invert_matrix(matrix) (True, [ [0.6, -0.7], [-0.2, 0.4] ]) >>> matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] >>> invert_matrix(matrix) (True, [ [-24, 18, 5], [20, -15, -4], [-5, 4, 1] ]) >>> matrix = [ [1, 0], [0, 0] ] >>> invert_matrix(matrix) (False, None) ``` # Notes * Ensure the result matrix is expressed as standard lists of lists without utilizing libraries like NumPy for the final output. * Return `False` and `None` if the matrix is not invertible. * The inverse can be computed using Gaussian Elimination, the Adjoint method, or any other process that correctly determines the inverse of a matrix. * Do not assume that the matrix elements are integers in the result; they may need to be represented as floating-point numbers. This question ensures understanding of advanced matrix manipulations and aligns well with the problem of LU decomposition, providing a complementary skill assessment.","solution":"from typing import List, Tuple, Optional def invert_matrix(matrix: List[List[int]]) -> Tuple[bool, Optional[List[List[int]]]]: def determinant(m: List[List[float]], n: int) -> float: if n == 1: return m[0][0] if n == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] det = 0 for c in range(n): det += ((-1) ** c) * m[0][c] * determinant([row[:c] + row[c+1:] for row in (m[1:])], n - 1) return det def get_cofactor(m: List[List[float]], temp: List[List[float]], p: int, q: int, n: int) -> None: i = j = 0 for row in range(n): for col in range(n): if row != p and col != q: temp[i][j] = m[row][col] j += 1 if j == n - 1: j = 0 i += 1 def adjoint(m: List[List[float]]) -> List[List[float]]: n = len(m) adj = [[0 for _ in range(n)] for _ in range(n)] if n == 1: adj[0][0] = 1 return adj temp = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): get_cofactor(m, temp, i, j, n) sign = 1 if (i + j) % 2 == 0 else -1 adj[j][i] = sign * determinant(temp, n - 1) return adj def inverse(m: List[List[float]], det: float) -> List[List[float]]: n = len(m) adj = adjoint(m) inv = [[adj[i][j] / det for j in range(n)] for i in range(n)] return inv n = len(matrix) m = [[float(matrix[i][j]) for j in range(n)] for i in range(n)] det = determinant(m, n) if det == 0: return (False, None) inv = inverse(m, det) return (True, inv)"},{"question":"# Temperature Conversion for Scientific Use Scenario In scientific computations, it is often required to convert temperature readings from Celsius to Fahrenheit or Kelvin. Accurate conversions are essential in various research and experimental observations. Your task is to implement a function that converts a given temperature in Celsius to both Fahrenheit and Kelvin. Problem Statement Implement a function `convert_temperature(celsius: float) -> Tuple[float, float]` that takes a temperature in Celsius and returns a tuple containing the equivalent temperatures in Fahrenheit and Kelvin. Input Format: * `celsius` - a float representing the temperature in Celsius. Output Format: * A tuple `(fahrenheit, kelvin)`, where: * `fahrenheit` - a float representing the temperature in Fahrenheit. * `kelvin` - a float representing the temperature in Kelvin. Constraints: * The function must properly handle the mathematical conversions as per the following formulas: - Fahrenheit: ( F = frac{9}{5}C + 32 ) - Kelvin: ( K = C + 273.15 ) * There is no need to handle unrealistic temperature inputs specially; assume the given temperature in Celsius can be any valid float value. Examples: ```python >>> convert_temperature(0) (32.0, 273.15) >>> convert_temperature(-40) (-40.0, 233.15) >>> convert_temperature(25) (77.0, 298.15) ``` Notes: * Ensure result accuracy up to at least 2 decimal places for both Fahrenheit and Kelvin.","solution":"def convert_temperature(celsius: float) -> tuple: Convert temperature from Celsius to Fahrenheit and Kelvin. Parameters: celsius (float): Temperature in Celsius Returns: tuple: A tuple containing temperature in Fahrenheit and Kelvin fahrenheit = (celsius * 9/5) + 32 kelvin = celsius + 273.15 return round(fahrenheit, 2), round(kelvin, 2)"},{"question":"Coding Assessment Question # Objective Create a function that simulates a simple file system\'s commands, focusing on directory creation and navigation. This will evaluate your ability to work with data structures such as trees and strings. # Problem Statement You are tasked with implementing a simple in-memory file system simulation. The file system supports basic directory manipulation commands. Your goal is to write a function `process_commands` that processes a series of file system commands. # Requirements 1. **Function Signature**: ```python def process_commands(commands: list[str]) -> list[str]: ``` 2. **Input Format**: - `commands` (list of str): A list of file system commands as strings. Each command will be one of the following: - `\\"mkdir <path>\\"`: Creates a directory at the specified path. - `\\"cd <path>\\"`: Changes the current directory to the specified path. - `\\"pwd\\"`: Returns the current directory path as a string. 3. **Output Format**: - Returns a list of strings representing the output of each `pwd` command in the order they were executed. 4. **Constraints**: - All commands are valid and follow a logical order such that directories do not cause errors by being created or navigated in invalid ways. - Paths use Unix-style forward slashes (`/`) and are absolute, starting from the root directory `/`. 5. **Node**: - The commands work on directories only, not files. - There are no commands to delete directories in this problem. # Example ```python commands = [ \\"mkdir /a\\", \\"mkdir /a/b\\", \\"cd /a/b\\", \\"pwd\\", \\"cd /\\", \\"pwd\\" ] output = process_commands(commands) print(output) # [\'/a/b\', \'/\'] ``` In the provided example, the function `process_commands` processes each command, maintains the state of the current directory, and records the output of each `pwd` command.","solution":"def process_commands(commands: list[str]) -> list[str]: Processes a series of file system commands and returns the results of \'pwd\' commands. :param commands: a list of file system commands :return: a list of output strings from \'pwd\' commands # Initialize the file system state current_path = \'/\' directories = {\'/\'} output = [] for command in commands: parts = command.split() # Handle \'mkdir\' command if parts[0] == \'mkdir\': path = parts[1] directories.add(path) # Handle \'cd\' command elif parts[0] == \'cd\': path = parts[1] if path in directories: current_path = path # Handle \'pwd\' command elif parts[0] == \'pwd\': output.append(current_path) return output"},{"question":"Additive Persistence Additive persistence is a property of a number that relates to how many times you have to sum the digits of a number until you get a single-digit number. For example, the number 2718 has an additive persistence of 2 because: 1. 2 + 7 + 1 + 8 = 18 (sum of digits, first iteration) 2. 1 + 8 = 9 (sum of digits, second iteration, which is a single-digit number) Your task is to write a function to calculate the additive persistence of a given number. # Function Signature ```python def additive_persistence(n: int) -> int: pass ``` # Input and Output * **Input**: - `n` (type: `int`): A non-negative integer. * **Output**: - (type: `int`): The additive persistence of the number `n`. # Constraints * `n` will be a non-negative integer. * Handle the input such that `0 <= n <= 10^12`. # Example ```python # Test case 1: n = 2718 # Expected output: 2 print(additive_persistence(n)) # Test case 2: n = 39 # Expected output: 2 print(additive_persistence(n)) # Test case 3: n = 4 # Expected output: 0 (as 4 is already a single digit) print(additive_persistence(n)) ``` # Note - Your function needs to sum the digits of the number repetitively until a single-digit number is obtained, and count the number of iterations (additive persistence) it took to reach that single-digit number.","solution":"def additive_persistence(n: int) -> int: def sum_of_digits(x): return sum(int(digit) for digit in str(x)) count = 0 while n >= 10: n = sum_of_digits(n) count += 1 return count"},{"question":"# Matrix Transposer You are assigned the task of creating a method in the `MatrixOperations` class to transpose a given 2D numpy array. **Task**: Add the following method to the `MatrixOperations` class: ```python def transpose_matrix(self): Transpose the given matrix. :return: Transposed matrix return self.matrix.T ``` **Objective**: You need to define this method such that it operates on the class\'s internal attribute `matrix`. The method should return the transpose of the `matrix`. **Input/Output**: * **Input**: The method will use the existing attribute (`self.matrix`), which is a 2D numpy array. * **Output**: A numpy array representing the transposed matrix. **Constraints**: * `matrix` is a numpy array of arbitrary shape `[m, n]`. **Performance**: Ensure your implementation handles large matrices efficiently. **Scenario**: You have a dataset represented as a matrix, and you need to transpose it for further analysis or to align with another dataset format. Transposing the matrix should swap its rows and columns. Example: ```python # Given input matrix matrix = np.array([[1, 2, 3], [4, 5, 6]]) # Expected Output # Transposed matrix np.array([[1, 4], [2, 5], [3, 6]]) ``` Add your method definition to the `MatrixOperations` class and verify its correctness based on the provided example.","solution":"import numpy as np class MatrixOperations: def __init__(self, matrix): self.matrix = matrix def transpose_matrix(self): Transpose the given matrix. :return: Transposed matrix return self.matrix.T"},{"question":"# Coding Challenge: Demarcate Range of Target Elements in a Sorted Array Problem Statement You are given a sorted array of integers `arr` and a target integer `target`. Your goal is to find the starting and ending positions of a given target value in the array. If the target is not found in the array, return `[-1, -1]`. Write a function `find_target_range` to identify the start and end indices of the target element using an efficient approach. Function Signature ```python def find_target_range(arr: List[int], target: int) -> List[int]: pass ``` Input Parameters * `arr` (List[int]): A list of integers sorted in non-decreasing order. (0 ≤ len(arr) ≤ 10^5, -10^5 ≤ arr[i] ≤ 10^5) * `target` (int): The target integer to find in the array. (-10^5 ≤ target ≤ 10^5) Output * Return a list of two integers `[start, end]` where `start` and `end` are the starting and ending indices of the `target` in the array respectively. Return `[-1, -1]` if the target is not present. Constraints * Optimize the function to handle the maximum input sizes effectively. * Aim for a solution with `O(log n)` time complexity. Example ```python print(find_target_range([5, 7, 7, 8, 8, 10], 8)) # Expected Output: [3, 4] print(find_target_range([5, 7, 7, 8, 8, 10], 6)) # Expected Output: [-1, -1] print(find_target_range([], 0)) # Expected Output: [-1, -1] print(find_target_range([1], 1)) # Expected Output: [0, 0] ``` Requirements * Implement the function `find_target_range` efficiently. * Ensure that your solution returns the correct indices for all edge cases including empty arrays and missing targets. * Your solution should handle both the upper and lower bounds of the input size effectively. This additional question maintains the complexity, style, presentation, and cognitive challenge similar to the provided sample question.","solution":"from typing import List def find_target_range(arr: List[int], target: int) -> List[int]: def binary_search_left(arr, target): low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 else: high = mid return low def binary_search_right(arr, target): low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] > target: high = mid else: low = mid + 1 return low left_index = binary_search_left(arr, target) # Check if the target is not in the array if left_index == len(arr) or arr[left_index] != target: return [-1, -1] right_index = binary_search_right(arr, target) - 1 return [left_index, right_index]"},{"question":"# Question You are required to implement a function that finds the longest streak of consecutive prime numbers that add up to a prime number less than or equal to a given integer. # Objective Write a function `longest_prime_sum(n: int) -> int` that returns the length of the longest streak of consecutive prime numbers whose sum is also a prime and less than or equal to `n`. # Specifications - **Input**: - `n` (int): A positive integer where 2 ≤ n ≤ 10^5. - **Output**: - An integer representing the length of the longest streak of consecutive primes whose sum is also a prime and less than or equal to `n`. # Constraints - Your solution should be efficient in terms of time and space complexity, considering the input constraints. - Handle edge cases appropriately. # Example ```python >>> longest_prime_sum(20) 4 >>> longest_prime_sum(1000) 21 >>> longest_prime_sum(41) 6 ``` # Notes The function should consider edge cases such as n being a small prime number and n having no consecutive prime sums that are also prime. Implement a helper function for checking if a number is prime: ```python def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True ```","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sieve_of_eratosthenes(n): primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p] == True: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]] def longest_prime_sum(n): primes = sieve_of_eratosthenes(n) max_length = 0 prime_sum = [] for i in range(len(primes)): sum_ = 0 for j in range(i, len(primes)): sum_ += primes[j] if sum_ > n: break if is_prime(sum_): current_length = j - i + 1 if current_length > max_length: max_length = current_length prime_sum = sum_ return max_length"},{"question":"# Objective You are given a class structure to represent points in 2D space and geometric shapes. Your task is to extend the functionality by implementing a specific shape class and a set of functions to perform geometric calculations. # Task 1. Implement a class `Circle` that has methods to calculate the circumference and area. 2. Write a function to determine if a given point is inside the circle. 3. Write a function to find the intersection points between two circles. # Instructions 1. **Implement Circle class**: Create a class `Circle` with a constructor that takes the center (as a tuple of x, y coordinates) and the radius (as a float). Implement methods to calculate the circumference and area of the circle. 2. **Function to Check Point Inside Circle**: The function should take an instance of `Circle` and a point (as a tuple of x, y coordinates) and return `True` if the point is inside the circle, `False` otherwise. 3. **Function to Find Intersection Points Between Two Circles**: The function should take two instances of `Circle` and return a list of tuples representing the intersection points. If there are no intersection points, return an empty list. # Input and Output Formats Function 1: `Circle` * **Input**: - `center` (tuple): The (x, y) coordinates of the circle\'s center. - `radius` (float): The radius of the circle. * **Output**: - None. Function 2: `point_inside_circle` * **Input**: - `circle` (Circle): Instance of the circle. - `point` (tuple): The (x, y) coordinates of the point. * **Output**: - Boolean indicating whether the point is inside the circle. Function 3: `intersecting_points` * **Input**: - `circle1` (Circle): First instance of the circle. - `circle2` (Circle): Second instance of the circle. * **Output**: - List of tuples representing the intersection points. # Example ```python class Circle: def __init__(self, center: tuple, radius: float): self.center = center self.radius = radius def circumference(self) -> float: return 2 * 3.14159 * self.radius def area(self) -> float: return 3.14159 * self.radius ** 2 def point_inside_circle(circle: Circle, point: tuple) -> bool: x, y = circle.center px, py = point return (px - x)**2 + (py - y)**2 <= circle.radius ** 2 def intersecting_points(circle1: Circle, circle2: Circle) -> list: x1, y1 = circle1.center r1 = circle1.radius x2, y2 = circle2.center r2 = circle2.radius dx = x2 - x1 dy = y2 - y1 d = (dx**2 + dy**2)**0.5 if d > r1 + r2 or d < abs(r1 - r2): return [] a = (r1**2 - r2**2 + d**2) / (2 * d) h = (r1**2 - a**2)**0.5 xm = x1 + a * (x2 - x1) / d ym = y1 + a (y2 - y1) / d xs1 = xm + h * (y2 - y1) / d ys1 = ym - h * (x2 - x1) / d xs2 = xm - h * (y2 - y1) / d ys2 = ym + h * (x2 - x1) / d return [(xs1, ys1), (xs2, ys2)] if xs1 != xs2 or ys1 != ys2 else [(xs1, ys1)] # Usage examples circle1 = Circle((0, 0), 5) circle2 = Circle((8, 0), 5) print(circle1.circumference()) # Should print: 31.4159 print(circle1.area()) # Should print: 78.53975 print(point_inside_circle(circle1, (3, 4))) # Should print: True print(intersecting_points(circle1, circle2)) # Should print: [] ``` In the example, you create instances of `Circle` and use the implemented functions to perform geometric calculations.","solution":"import math class Circle: def __init__(self, center: tuple, radius: float): self.center = center self.radius = radius def circumference(self) -> float: return 2 * math.pi * self.radius def area(self) -> float: return math.pi * self.radius ** 2 def point_inside_circle(circle: Circle, point: tuple) -> bool: x, y = circle.center px, py = point return (px - x)**2 + (py - y)**2 <= circle.radius ** 2 def intersecting_points(circle1: Circle, circle2: Circle) -> list: x1, y1 = circle1.center r1 = circle1.radius x2, y2 = circle2.center r2 = circle2.radius dx = x2 - x1 dy = y2 - y1 d = math.sqrt(dx**2 + dy**2) if d > r1 + r2 or d < abs(r1 - r2) or d == 0: return [] a = (r1**2 - r2**2 + d**2) / (2 * d) h = math.sqrt(r1**2 - a**2) xm = x1 + a * (x2 - x1) / d ym = y1 + a * (y2 - y1) / d xs1 = xm + h * (y2 - y1) / d ys1 = ym - h * (x2 - x1) / d xs2 = xm - h * (y2 - y1) / d ys2 = ym + h * (x2 - x1) / d if xs1 == xs2 and ys1 == ys2: return [(xs1, ys1)] return [(xs1, ys1), (xs2, ys2)]"},{"question":"# Question: Smallest Positive Number Missing from an Unsorted Array Context Finding missing or duplicate numbers in an unsorted array has significant applications in data analysis, error detection, and cryptography. Identifying the smallest positive integer missing from an array is a problem that tests understanding of array manipulation and optimization techniques. Task Implement a function that takes an unsorted list of integers and returns the smallest positive integer that is missing from the list. # Function Signature ```python def smallest_missing_positive(nums: list[int]) -> int: ``` # Input - **nums:** A list of integers with a length between 1 and 100,000. - The integers can be both positive and negative. # Output - Returns the smallest positive integer missing from the list. # Constraints - Aim for a solution with O(n) time complexity. - Avoid using extra space beyond a constant amount. # Example ```python >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> smallest_missing_positive([1]) 2 ``` # Notes - Consider avoiding sorting the array, as it incurs O(n log n) time complexity. - Utilize in-place array manipulation techniques to keep constant space usage and linear time complexity. Performance Expectations - The solution should efficiently handle both large arrays and those with a wide range of integer values.","solution":"def smallest_missing_positive(nums: list[int]) -> int: Returns the smallest positive integer that is missing from the list. n = len(nums) # Step 1: Remove non-positive numbers by setting them out of range (> n, assuming n+1) or greater for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark numbers present in the array for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first index which is not marked for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"Question # Problem Statement: You are given two non-negative integers. Your task is to write a function `decimal_add(a: int, b: int) -> str` that adds these two integers and returns the result as a decimal string representing the sum. # Function Signature: ```python def decimal_add(a: int, b: int) -> str: pass ``` # Input: - Two non-negative integer inputs `a` and `b` (0 <= a, b <= 10^9). # Output: - A decimal string representing the sum of the two input integers. # Constraints: - Both integers are non-negative. - The function should handle edge cases such as zero inputs and large values effectively. # Examples: ```python assert decimal_add(25, 32) == \'57\' assert decimal_add(37, 50) == \'87\' assert decimal_add(21, 30) == \'51\' assert decimal_add(58, 73) == \'131\' assert decimal_add(0, 255) == \'255\' assert decimal_add(256, 256) == \'512\' assert decimal_add(0, 0) == \'0\' ``` # Additional Instructions: - Consider edge cases mentioned in the analysis. - Ensure the function raises appropriate errors for any invalid inputs.","solution":"def decimal_add(a: int, b: int) -> str: Adds two non-negative integers and returns the result as a decimal string. Parameters: a (int): The first non-negative integer. b (int): The second non-negative integer. Returns: str: The sum of the two integers as a string. # Ensure the inputs are non-negative integers if not (isinstance(a, int) and isinstance(b, int)): raise ValueError(\\"Both inputs must be integers.\\") if a < 0 or b < 0: raise ValueError(\\"Both inputs must be non-negative integers.\\") # Calculate the sum result = a + b # Return the result as a string return str(result)"},{"question":"# Problem Statement You are tasked with developing a function to optimize the allocation of resources for a large-scale computational task. The resources are given as a list of integers where each integer represents the capacity of that resource. The challenge is to allocate these resources to two different tasks in such a way that the difference in the total capacities of the resources assigned to each task is minimized. # Requirements: 1. The function should return two lists, each containing the resources allocated to the respective tasks. 2. The difference in the total capacity between the two lists should be as small as possible. 3. It must handle edge cases, such as when the input list is empty. # Function Signature: ```python def allocate_resources(resources: List[int]) -> Tuple[List[int], List[int]]: pass ``` # Expected Input and Output: 1. **Input**: A list of integers `resources` representing the capacities of the resources. 2. **Output**: A tuple of two lists, where the first list contains the resources allocated to task 1 and the second list contains the resources allocated to task 2. **Example**: ```python allocate_resources([10, 20, 15, 5]) # Output: ([10, 15], [20, 5]) # Explanation: Sum of capacities for both lists is 25. allocate_resources([1, 2, 3, 4, 5]) # Output: ([1, 4, 5], [2, 3]) # Explanation: Sum of capacities for both lists is 10. allocate_resources([]) # Output: ([], []) # Explanation: Both lists are empty since there are no resources. ``` # Constraints: 1. The input list may contain positive integers only. 2. Optimal allocation should consider both time and space complexities. **Note**: - Focus on achieving an efficient algorithm that ensures minimal difference between the total capacities of the allocated resources for performance optimization.","solution":"from typing import List, Tuple def allocate_resources(resources: List[int]) -> Tuple[List[int], List[int]]: Allocates resources into two tasks such that the difference between their total capacities is minimized. resources.sort(reverse=True) # Sort resources in descending order. task1, task2 = [], [] sum1, sum2 = 0, 0 for resource in resources: if sum1 <= sum2: task1.append(resource) sum1 += resource else: task2.append(resource) sum2 += resource return task1, task2"},{"question":"# Scenario: You work as a software engineer developing a medical application for managing patients\' health metrics. One of the features in this application is to calculate the Body Mass Index (BMI) for patients based on their weight and height. Your task is to implement a function that calculates the BMI and categorizes it. # Task: Implement a function `calculate_bmi(weight: float, height: float) -> str` that calculates the BMI based on the given weight and height using the formula: [ text{BMI} = frac{text{weight} (kg)}{(text{height} (m))^2} ] The function should return a string indicating the BMI category: - \\"Underweight\\" for BMI < 18.5 - \\"Normal weight\\" for 18.5 ≤ BMI < 25 - \\"Overweight\\" for 25 ≤ BMI < 30 - \\"Obese\\" for BMI ≥ 30 # Requirements: * **Inputs**: * `weight`: The weight of the patient in kilograms (float). It must be a positive value. * `height`: The height of the patient in meters (float). It must be a positive value. * **Output**: * The function should return a string that categorizes the BMI. # Constraints: * If the `weight` is less than or equal to zero, the function should raise a `ValueError` with the message `\\"Weight must be a positive value\\"`. * If the `height` is less than or equal to zero, the function should raise a `ValueError` with the message `\\"Height must be a positive value\\"`. # Function Signature: ```python def calculate_bmi(weight: float, height: float) -> str: ``` # Examples: ```python >>> calculate_bmi(70, 1.75) \'Normal weight\' >>> calculate_bmi(50, 1.60) \'Underweight\' >>> calculate_bmi(85, 1.80) \'Overweight\' >>> calculate_bmi(50, 1.50) \'Obese\' >>> calculate_bmi(90, 1.95) \'Overweight\' ``` # Additional Challenge: Ensure thorough testing of your implementation, including edge cases with various weights and heights.","solution":"def calculate_bmi(weight: float, height: float) -> str: Calculate Body Mass Index (BMI) and return the category. Parameters: weight (float): Weight in kilograms height (float): Height in meters Returns: str: BMI category Raises: ValueError: If weight or height is less than or equal to zero if weight <= 0: raise ValueError(\\"Weight must be a positive value\\") if height <= 0: raise ValueError(\\"Height must be a positive value\\") bmi = weight / (height ** 2) if bmi < 18.5: return \\"Underweight\\" elif 18.5 <= bmi < 25: return \\"Normal weight\\" elif 25 <= bmi < 30: return \\"Overweight\\" else: return \\"Obese\\""},{"question":"# Question: Implement a Balanced BST for Efficient Interval Overlaps You are tasked with constructing a balanced binary search tree (BST) to manage intervals and efficiently query for overlapping intervals. Enhance the given BST class with a new method to find all intervals that overlap with a given query interval. **Function Signature:** ```python def find_overlapping(self, interval: Tuple[int, int]) -> List[Tuple[int, int]]: # Your code here ``` # Input Format The `find_overlapping` function should accept a single tuple `interval` of two integers, representing the start and end of the interval to query. # Output Format The function should return a list of tuples, where each tuple represents an interval from the BST that overlaps with the given query interval. # Constraints - The intervals are inclusive, meaning `interval = (start, end)` where `start <= end`. - Ensure the BST remains balanced after insertions and deletions (e.g., using AVL tree, Red-Black tree, or similar). - Efficiently handle interval overlaps with logarithmic time complexity search. # Example ```python bst = IntervalBST() bst.insert((1, 3)) bst.insert((5, 8)) bst.insert((4, 6)) bst.insert((10, 15)) # Querying for overlapping intervals with (7, 12) assert bst.find_overlapping((7, 12)) == [(5, 8), (10, 15)] ``` In the example, the intervals (5, 8) and (10, 15) overlap with (7, 12), and they are correctly returned by the function. # Notes - Ensure the `insert` and `delete` methods exist and maintain the balance of the BST. - Efficient interval overlap detection is crucial, so consider augmenting nodes with additional data if necessary. - For full tree functionality, assume methods `insert` and `delete` are defined in the `IntervalBST` class.","solution":"class TreeNode: def __init__(self, interval): self.interval = interval # interval represented by this node self.max_end = interval[1] # maximum ending value of any interval in the subtree rooted by this node self.left = None # left child self.right = None # right child class IntervalBST: def __init__(self): self.root = None def insert(self, root, interval): if not root: return TreeNode(interval) if interval[0] < root.interval[0]: root.left = self.insert(root.left, interval) else: root.right = self.insert(root.right, interval) root.max_end = max(root.max_end, interval[1]) return root def insert_interval(self, interval): if self.root is None: self.root = TreeNode(interval) else: self.root = self.insert(self.root, interval) def do_overlap(self, interval1, interval2): return interval1[0] <= interval2[1] and interval2[0] <= interval1[1] def find_overlapping(self, interval): return self._find_overlapping(self.root, interval) def _find_overlapping(self, root, interval): result = [] if not root: return result if self.do_overlap(root.interval, interval): result.append(root.interval) if root.left and root.left.max_end >= interval[0]: result += self._find_overlapping(root.left, interval) if root.right and root.interval[0] <= interval[1]: result += self._find_overlapping(root.right, interval) return result"},{"question":"# Binary Search Tree (BST) Operations You are assigned to implement a `BinarySearchTree` (BST) class to manage a collection of integers. The BST should support basic operations including insertion, searching, deletion, and inorder traversal. Function Specifications 1. **Initialization**: Define an initializer that sets up an empty BST. 2. **Insert**: Implement an `insert(data)` method to add an element to the BST. The data should be placed in the correct position adhering to BST properties. 3. **Search**: Implement a `search(data)` method that returns `True` if the element is found in the BST and `False` otherwise. 4. **Delete**: Implement a `delete(data)` method to remove an element from the BST. Raise an exception if the element is not found. 5. **Inorder Traversal**: Implement an `inorder()` method that returns a list of BST elements in ascending order. Input and Output Specifications **Input**: - `BinarySearchTree()` constructor for creating an empty BST. - `insert(data)` where `data` is the integer to be added. - `search(data)` where `data` is the integer to search for. - `delete(data)` where `data` is the integer to delete. - `inorder()` method without additional inputs. **Output**: - `insert(data)` should not return anything. - `search(data)` should return a boolean indicating if the data is found. - `delete(data)` should not return anything. - `inorder()` should return a list of integers representing the inorder traversal of the BST. # Example Test Cases ```python bst = BinarySearchTree() assert bst.inorder() == [] bst.insert(5) assert bst.inorder() == [5] bst.insert(3) bst.insert(7) assert bst.search(3) == True assert bst.search(6) == False bst.insert(6) assert bst.inorder() == [3, 5, 6, 7] bst.delete(3) assert bst.inorder() == [5, 6, 7] try: bst.delete(10) except Exception as e: assert str(e) == \\"NOT FOUND\\" assert bst.search(5) == True bst.delete(5) assert bst.inorder() == [6, 7] ``` Implement the `BinarySearchTree` class according to these specifications and ensure your implementation passes all the given example test cases.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if node.data == data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: raise Exception(\\"NOT FOUND\\") if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: # Node with only one child or no child if node.left is None: temp = node.right node = None return temp elif node.right is None: temp = node.left node = None return temp # Node with two children: Get the inorder successor temp = self._min_value_node(node.right) node.data = temp.data node.right = self._delete(node.right, temp.data) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.data) self._inorder(node.right, result)"},{"question":"# Problem Statement You are asked to write a function that calculates the number of valid shuffle sequences for given strings `X` and `Y`. A shuffle sequence is defined as a string that contains all characters of `X` and `Y` in their respective order but may interleave. For instance, if `X = \\"abc\\"` and `Y = \\"def\\"`, then \\"adbcef\\" and \\"abcdef\\" are valid shuffle sequences but \\"abdfce\\" is not because the order of `X` and `Y` is not preserved. # Function Signature ```python def count_shuffle_sequences(X: str, Y: str) -> int: ``` # Input 1. `X` (str): A non-empty string consisting of lowercase letters. 2. `Y` (str): A non-empty string consisting of lowercase letters. # Output * Returns an integer representing the number of valid shuffle sequences that can be formed using the characters of strings `X` and `Y`. # Rules and Constraints 1. The function should compute the number of interleavings of `X` and `Y` that preserve the relative order of characters in both strings. 2. The lengths of `X` and `Y` will not exceed 20 characters. # Example ```python count_shuffle_sequences(\\"ab\\", \\"cd\\") # Should return 6 count_shuffle_sequences(\\"abc\\", \\"def\\") # Should return 20 ``` # Explanation of the Example 1. For `X = \\"ab\\"` and `Y = \\"cd\\"`, the valid sequences are: \\"abcd\\", \\"acbd\\", \\"acdb\\", \\"cabd\\", \\"cadb\\", \\"cdab\\". Therefore, the function returns 6. 2. For `X = \\"abc\\"` and `Y = \\"def\\"`, the number of valid sequences preserving the order will be 20. # Performance Requirements Your algorithm should efficiently handle the given constraints using dynamic programming or recursion with memoization to avoid unnecessary recomputation. # Hints 1. Think about how to use a 2D array to keep track of the counts of interleavings. 2. Utilize properties of combinatorics to derive the number of valid shuffles.","solution":"def count_shuffle_sequences(X: str, Y: str) -> int: # Utilize dynamic programming to count valid shuffles m = len(X) n = len(Y) # dp[i][j] stands for the number of valid shuffles using first i characters of X and first j characters of Y dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case: There\'s one way to shuffle 0 characters of X and 0 characters of Y dp[0][0] = 1 # Fill the dp table for i in range(m + 1): for j in range(n + 1): if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m][n]"},{"question":"**Problem Statement: Area of Intersection between Two Rectangles** You are required to write a function that calculates the area of the intersection between two rectangles on a 2D plane. Each rectangle is defined by its bottom-left and top-right corners. # Function Signature ```python def intersection_area(rect1: tuple, rect2: tuple) -> int: pass ``` # Input: - `rect1` (tuple): A tuple of four integers representing the bottom-left and top-right corners of the first rectangle (x1, y1, x2, y2). - `rect2` (tuple): A tuple of four integers representing the bottom-left and top-right corners of the second rectangle (x1, y1, x2, y2). # Output: - An integer value representing the area of the intersection between the two rectangles. If they do not intersect, return 0. # Constraints: - The coordinates are integers between -10^5 and 10^5. - The bottom-left corner coordinates (x1, y1) for both rectangles are always less than the top-right corner coordinates (x2, y2). # Example: ```python >>> intersection_area((0, 0, 3, 3), (1, 1, 4, 4)) 4 >>> intersection_area((0, 0, 1, 1), (2, 2, 3, 3)) 0 ``` # Performance Requirements: - The function should operate in constant time, O(1). # Edge Cases: - Handle cases where the rectangles do not intersect at all. - Handle cases where the intersection area is just a line or a single point. # Implementation: 1. Validate the inputs. 2. Calculate the overlap along the x and y axes. 3. Compute the intersection area. 4. Return the computed area or 0 if there is no intersection. Implement the function `intersection_area` accordingly.","solution":"def intersection_area(rect1, rect2): Calculate the area of intersection between two rectangles on a 2D plane. Each rectangle is defined by its bottom-left and top-right corners. Args: rect1 (tuple): Bottom-left and top-right corners of the first rectangle (x1, y1, x2, y2). rect2 (tuple): Bottom-left and top-right corners of the second rectangle (x1, y1, x2, y2). Returns: int: The area of the intersection between the two rectangles. Return 0 if they do not intersect. # Unpack the rectangle coordinates x1_min, y1_min, x1_max, y1_max = rect1 x2_min, y2_min, x2_max, y2_max = rect2 # Compute intersection rectangle coordinates x_overlap_min = max(x1_min, x2_min) y_overlap_min = max(y1_min, y2_min) x_overlap_max = min(x1_max, x2_max) y_overlap_max = min(y1_max, y2_max) # Compute overlap dimensions overlap_width = x_overlap_max - x_overlap_min overlap_height = y_overlap_max - y_overlap_min # If overlap width and height are positive, return the area, otherwise return 0 if overlap_width > 0 and overlap_height > 0: return overlap_width * overlap_height else: return 0"},{"question":"# Data Analysis with Pandas You are required to analyze a dataset using Pandas, focusing on data cleaning, summary statistics, and group-based operations. The dataset is a CSV file containing information about a company\'s sales over the last year. Specific Requirements 1. **Input**: A CSV file with the following columns: `Date`, `Product`, `Region`, `Units Sold`, `Unit Price`. 2. **Output**: * A cleaned version of the dataframe where all missing values in the `Units Sold` and `Unit Price` columns are replaced with the median value of their respective columns. * Summary statistics including the total sales (units sold * unit price) per product. * The region with the highest average unit price for each product. Constraints * The `Date` column should be parsed as a datetime object. * The `Units Sold` and `Unit Price` columns must be numeric; convert types if necessary. * Use the median value of the column to fill missing values. Performance Requirements * The solution should efficiently handle datasets with up to 100,000 rows. * Ensure the code is readable and well-documented. Scenario The sales department of your organization is conducting a thorough analysis of last year\'s sales data to identify trends and performance metrics per product and region. They plan to use this information to strategize the upcoming year\'s sales plan. You are tasked with implementing the following function: ```python import pandas as pd def analyze_sales_data(file_path: str) -> dict: Given the path to a CSV file, analyze the sales data and return the cleaned dataframe and summary statistics. Parameters: file_path (str): The file path to the CSV sales data. Returns: dict: A dictionary containing: - \'cleaned_data_frame\': pd.DataFrame: The cleaned sales data - \'summary_statistics\': pd.DataFrame: The total sales per product - \'highest_avg_price_per_product\': pd.DataFrame: The region with the highest average unit price for each product pass ``` **Example Usage:** ```python results = analyze_sales_data(\\"sales_data.csv\\") print(results[\'cleaned_data_frame\'].head()) print(results[\'summary_statistics\']) print(results[\'highest_avg_price_per_product\']) ``` Ensure your solution correctly handles data cleaning, generates summary statistics, and identifies the regions with the highest average unit prices per product.","solution":"import pandas as pd def analyze_sales_data(file_path: str) -> dict: Given the path to a CSV file, analyze the sales data and return the cleaned dataframe and summary statistics. Parameters: file_path (str): The file path to the CSV sales data. Returns: dict: A dictionary containing: - \'cleaned_data_frame\': pd.DataFrame: The cleaned sales data - \'summary_statistics\': pd.DataFrame: The total sales per product - \'highest_avg_price_per_product\': pd.DataFrame: The region with the highest average unit price for each product # Load data df = pd.read_csv(file_path, parse_dates=[\'Date\']) # Ensure Units Sold and Unit Price are numeric df[\'Units Sold\'] = pd.to_numeric(df[\'Units Sold\'], errors=\'coerce\') df[\'Unit Price\'] = pd.to_numeric(df[\'Unit Price\'], errors=\'coerce\') # Fill missing values with median df[\'Units Sold\'].fillna(df[\'Units Sold\'].median(), inplace=True) df[\'Unit Price\'].fillna(df[\'Unit Price\'].median(), inplace=True) # Calculate total sales df[\'Total Sales\'] = df[\'Units Sold\'] * df[\'Unit Price\'] # Summary statistics: Total sales per product summary_statistics = df.groupby(\'Product\')[\'Total Sales\'].sum().reset_index() # Region with highest average unit price per product highest_avg_price_per_product = df.groupby([\'Product\', \'Region\'])[\'Unit Price\'].mean().reset_index() highest_avg_price_per_product = highest_avg_price_per_product.loc[highest_avg_price_per_product.groupby(\'Product\')[\'Unit Price\'].idxmax()].reset_index(drop=True) return { \'cleaned_data_frame\': df, \'summary_statistics\': summary_statistics, \'highest_avg_price_per_product\': highest_avg_price_per_product }"},{"question":"# Problem Statement You are given two strings, `s1` and `s2`. Your task is to write a function `is_permutation(s1: str, s2: str) -> bool` which determines if one string is a permutation of the other. Two strings are considered permutations of each other if they contain the same characters with the same frequencies. # Expected Input and Output * **Input**: * `s1` (str): A non-empty string containing any printable ASCII characters. * `s2` (str): A non-empty string containing any printable ASCII characters. * **Output**: * Return `True` if `s1` is a permutation of `s2`, otherwise return `False`. # Constraints * The length of the strings will be in the range [1, 1000]. # Example Input & Output *Example 1*: ```python s1 = \\"abc\\" s2 = \\"cab\\" is_permutation(s1, s2) ``` *Output*: ```python True ``` *Example 2*: ```python s1 = \\"hello\\" s2 = \\"billion\\" is_permutation(s1, s2) ``` *Output*: ```python False ``` *Example 3*: ```python s1 = \\"aabbcc\\" s2 = \\"abcabc\\" is_permutation(s1, s2) ``` *Output*: ```python True ``` # Performance Requirements * The solution should efficiently determine if the two strings are permutations, considering the constraint limits. * Optimize for both time and space complexity while ensuring readability and maintainability of the code. # Scenario for Consideration You are developing features for a secure login system and need to verify if two passwords (potentially entered differently due to keyboard layouts) are actually permutations of each other to prevent mistyped but similar password entries from causing login issues. Use the above function to implement such functionality.","solution":"from collections import Counter def is_permutation(s1: str, s2: str) -> bool: Determines if s1 is a permutation of s2. Args: s1 (str): First string to compare. s2 (str): Second string to compare. Returns: bool: True if s1 is a permutation of s2, False otherwise. return Counter(s1) == Counter(s2)"},{"question":"# Question: Consecutive Number Sum Targets Scenario Given a target integer, determine how many ways it can be expressed as a sum of two or more consecutive positive integers. # Task Write a function: ```python def count_consecutive_sum_ways(target: int) -> int: Determine the number of ways the given target integer can be expressed as a sum of two or more consecutive positive integers. ``` # Input - `target` (int): The integer to be expressed as a sum of consecutive positive integers. # Output - The function should return a single integer, which is the number of different ways the target can be expressed as a sum of consecutive positive integers. # Constraints - 1 ≤ `target` ≤ 10^9 # Performance Requirements - Ensure the solution can handle the upper limit within a reasonable time frame. - Consider mathematical properties and efficient iteration to find the solution. # Examples - `>>> count_consecutive_sum_ways(15)` - Output: 3 - Explanation: 15 can be expressed as: - 1 + 2 + 3 + 4 + 5 - 4 + 5 + 6 - 7 + 8 - `>>> count_consecutive_sum_ways(9)` - Output: 2 - Explanation: 9 can be expressed as: - 2 + 3 + 4 - 4 + 5 # Notes - Consider edge cases where no such consecutive sequence exists. - Utilize properties of arithmetic progressions to determine the number of valid sequences efficiently. - Avoid unnecessary calculations by leveraging mathematical insights. # Hints - Use the formula for the sum of an arithmetic series to derive potential sequences efficiently. - Consider the relationship between the target, the number of terms, and the smallest term in the sequence.","solution":"def count_consecutive_sum_ways(target: int) -> int: Determine the number of ways the given target integer can be expressed as a sum of two or more consecutive positive integers. count = 0 k = 1 # Starting with sequences of length 1 while k * (k + 1) < 2 * target: numerator = target - (k * (k + 1)) // 2 if numerator % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"# Coding Assessment Question Context You are working on a data processing pipeline where you need to track the count of unique words in a document. Each word is defined as a contiguous sequence of alphabets separated by non-alphabetic characters. Ignore case during counting. Task Write a function `count_unique_words(text: str) -> dict` that takes a string `text` as input and returns a dictionary where the keys are the unique words (in lowercase) and the values are their respective counts. Implementation * Your function should: - Ensure `text` is a string. - Convert all words to lowercase. - Count each unique word in the text. - Return a dictionary with the words as keys and their counts as values. Constraints - The length of `text` will not exceed `10^6` characters. - The words in `text` can contain only alphabetic characters (a-z, A-Z). Input/Output Format - Input: A string `text`. - Output: A dictionary where the keys are unique words in lowercase and the values are their counts. Example ```python def count_unique_words(text: str) -> dict: # Your implementation here # Example usage: print(count_unique_words(\\"Hello, hello! How are you?\\")) # Output: {\'hello\': 2, \'how\': 1, \'are\': 1, \'you\': 1} print(count_unique_words(\\"Data processing: processing data. Data!\\")) # Output: {\'data\': 3, \'processing\': 2} print(count_unique_words(\\"Test! Testing... tested, tester. Tests\\")) # Output: {\'test\': 1, \'testing\': 1, \'tested\': 1, \'tester\': 1, \'tests\': 1} ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"import re from collections import defaultdict def count_unique_words(text: str) -> dict: Counts the unique words in the given text and returns a dictionary with words as keys and their counts as values. :param text: Input text containing words separated by non-alphabetic characters :type text: str :return: Dictionary with unique words (in lowercase) as keys and their counts as values :rtype: dict # Use regular expressions to find all words composed of alphabetic characters words = re.findall(r\'[a-zA-Z]+\', text.lower()) word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Binary Tree from Preorder and Inorder Traversal You need to construct a binary tree from given preorder and inorder traversals of the tree. The tree must be reconstructed such that it matches the given preorder and inorder traversals. Input - `preorder`: A list of integers representing the preorder traversal of the tree. - `inorder`: A list of integers representing the inorder traversal of the tree. Output - Return the root node of the reconstructed binary tree. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: list[int], inorder: list[int]) -> TreeNode: # Your implementation here preorder = [3, 9, 20, 15, 7] inorder = [9, 3, 15, 20, 7] root = buildTree(preorder, inorder) def printInorder(node): if node is not None: printInorder(node.left) print(node.val, end=\' \') printInorder(node.right) printInorder(root) # Output would be: 9 3 15 20 7 ``` # Constraints - The number of nodes in the tree is at most 2000. - The values of nodes are unique. # Performance Requirement - The algorithm should be optimized for time complexity to handle up to 2000 nodes accurately. # Detailed Requirements - The function `buildTree` should leverage indices and recursive calls to efficiently build the tree. - Ensure the function handles edge cases such as empty lists (both `preorder` and `inorder`). - Highlight the partitioning strategy that uses the root from `preorder` to split `inorder` into left and right subtrees. - Avoid redundant computations and ensure minimal traversal over the lists. Using the given example, demonstrate the correct construction of the binary tree by validating the inorder traversal of the tree built from the given traversals.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: list[int], inorder: list[int]) -> TreeNode: if not preorder or not inorder: return None # Create a map for quick lookup of indices in inorder traversal inorder_index_map = {val: idx for idx, val in enumerate(inorder)} def arrayToTree(left, right): if left > right: return None root_value = preorder.pop(0) root = TreeNode(root_value) root.left = arrayToTree(left, inorder_index_map[root_value] - 1) root.right = arrayToTree(inorder_index_map[root_value] + 1, right) return root return arrayToTree(0, len(inorder) - 1)"},{"question":"# Question: Design a Custom Sort Function for a List of Dictionary Objects You are tasked with implementing a custom sort function for a list of dictionary objects. The dictionaries may have varied keys, and you are required to sort the list based on a specified key and order. Requirements: - Implement the `custom_sort` method that sorts a list of dictionaries by a given key in either ascending or descending order. - Ensure that the sorting function handles cases where the key might be missing in some dictionaries gracefully. Input: - `dicts`: A list of dictionaries. - `sort_key` (str): The key by which the list should be sorted. - `order` (str): The order of sorting, either \\"ascending\\" or \\"descending\\". Output: - `sorted_dicts`: List of dictionaries sorted based on the specified key and order. Constraints: - If a dictionary does not have the specified sort key, it should be treated as having a value of `None` for that key. - Comparison with `None` should always place `None` values last in ascending order and first in descending order. Example: ```python # Example input: dicts = [ {\\"name\\": \\"John\\", \\"age\\": 25}, {\\"name\\": \\"Anna\\", \\"age\\": None}, {\\"name\\": \\"Mike\\", \\"age\\": 30}, {\\"name\\": \\"Josh\\", \\"age\\": 20}, {\\"name\\": \\"Michelle\\", \\"undefined_key\\": \\"test\\"} ] sort_key = \'age\' order = \'ascending\' # Expected output: # sorted_dicts = [ # {\\"name\\": \\"Josh\\", \\"age\\": 20}, # {\\"name\\": \\"John\\", \\"age\\": 25}, # {\\"name\\": \\"Mike\\", \\"age\\": 30}, # {\\"name\\": \\"Anna\\", \\"age\\": None}, # {\\"name\\": \\"Michelle\\", \\"undefined_key\\": \\"test\\"} # ] ``` Function signature: ```python def custom_sort(dicts: List[Dict[str, Any]], sort_key: str, order: str) -> List[Dict[str, Any]]: pass ``` Implement the function `custom_sort` that sorts the list of dictionaries according to the specified key and order.","solution":"from typing import List, Dict, Any def custom_sort(dicts: List[Dict[str, Any]], sort_key: str, order: str) -> List[Dict[str, Any]]: Sorts a list of dictionaries based on a specified key and order. Parameters: dicts (List[Dict[str, Any]]): The list of dictionaries to be sorted. sort_key (str): The key based on which the sorting should be done. order (str): The order of sorting, either \\"ascending\\" or \\"descending\\". Returns: List[Dict[str, Any]]: Sorted list of dictionaries. # Determine the reverse parameter for sorted() based on order reverse = order == \\"descending\\" def get_key(item): # Return the value of the sort key or None if the key is missing return item.get(sort_key, None) # Sort the dictionaries using the desired order sorted_dicts = sorted(dicts, key=lambda x: (get_key(x) is None, get_key(x)), reverse=reverse) return sorted_dicts"},{"question":"# Problem Statement Implement the **Merge Sort** algorithm in a function `merge_sort(arr: list[int]) -> list[int]`, which takes a list of integers `arr` and returns a sorted list. # Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: ``` # Input * A list of integers `arr` (1 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6). # Output * A list of integers `arr` sorted in ascending order. # Constraints * The function should use the Merge Sort algorithm. * Handle large arrays efficiently by ensuring that the merge operation is optimized. # Example ```python print(merge_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(merge_sort([])) # Output: [] print(merge_sort([3])) # Output: [3] print(merge_sort([10, -3, 25, 1, 0, -5, 7])) # Output: [-5, -3, 0, 1, 7, 10, 25] ``` # Guidelines * Test your implementation thoroughly with various inputs, including edge cases. * Make sure your code handles the specified constraints effectively, particularly with respect to recursion depth and memory usage. This question complements the existing set by continuing the focus on sorting algorithms but in a different context, thus providing a unique challenge and ensuring a comprehensive assessment of the candidate\'s ability to implement and understand diverse sorting techniques.","solution":"def merge_sort(arr): if len(arr) <= 1: return arr def merge(left, right): sorted_list = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: sorted_list.append(left[left_idx]) left_idx += 1 else: sorted_list.append(right[right_idx]) right_idx += 1 sorted_list.extend(left[left_idx:]) sorted_list.extend(right[right_idx:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"**Merged Sorted Lists** You are given two functions that merge two sorted lists into a single sorted list and find the kth smallest element in a sorted list, respectively. Your task is to write a function `merged_kth_element` that takes three arguments: two sorted lists and an integer k, and returns the kth smallest element from the merged sorted list. The function, `merged_kth_element`, should: 1. Merge the two sorted lists using the provided `merge_sorted_lists` function. 2. Find the kth smallest element in the merged list using the provided `find_kth_element` function. # Function Signature ```python def merged_kth_element(list1: list[int], list2: list[int], k: int) -> int: ``` # Input - `list1`: A sorted list of integers (e.g., `[1, 3, 5]`). - `list2`: Another sorted list of integers (e.g., `[2, 4, 6]`). - `k`: An integer indicating the position (1-based index) of the desired element in the merged sorted list. # Output - Returns an integer representing the k-th smallest element in the merged sorted list. # Constraints - Both `list1` and `list2` are sorted in non-decreasing order. - The input lists will contain no duplicate elements. - 1 ≤ `k` ≤ len(`list1`) + len(`list2`) # Example ```python >>> merged_kth_element([1, 3, 5], [2, 4, 6], 4) 4 >>> merged_kth_element([1, 1, 1, 1], [10, 20, 30], 5) 10 ``` # Notes - Ensure to validate input and handle potential errors gracefully. - You can use the provided `merge_sorted_lists` function to merge the lists. - Use the provided `find_kth_element` function to find the k-th smallest element in the merged list. # Provided Functions ```python def merge_sorted_lists(list1, list2): merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list def find_kth_element(sorted_list, k): return sorted_list[k-1] ``` # Implementation ```python def merged_kth_element(list1, list2, k): merged_list = merge_sorted_lists(list1, list2) return find_kth_element(merged_list, k) ```","solution":"def merged_kth_element(list1, list2, k): Merges two sorted lists and returns the k-th smallest element. Parameters: list1 (List[int]): The first sorted list. list2 (List[int]): The second sorted list. k (int): The 1-based index of the desired element in the merged sorted list. Returns: int: The k-th smallest element in the merged sorted list. merged_list = merge_sorted_lists(list1, list2) return find_kth_element(merged_list, k) def merge_sorted_lists(list1, list2): merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list def find_kth_element(sorted_list, k): return sorted_list[k-1]"},{"question":"# Coding Question: Find and Verify Palindromic Prime Numbers Context Palindromic primes are primes that remain the same when their digits are reversed. This exercise requires understanding of prime number algorithms and string manipulation to efficiently verify palindromic primes and find them within specified limits. Problem Statement You are tasked with writing two functions: 1. **is_palindromic_prime(n: int) -> bool**: Verifies whether a given positive integer `n` is a palindromic prime. 2. **find_palindromic_primes(limit: int) -> List[int]**: Finds all palindromic primes up to a specified limit. Input/Output Formats - **Function 1: `is_palindromic_prime(n: int) -> bool`** - **Input**: A single integer `n`. - **Output**: `True` if `n` is a palindromic prime, `False` otherwise. - **Constraints**: `2 ≤ n ≤ 10^5` - **Function 2: `find_palindromic_primes(limit: int) -> List[int]** - **Input**: A single integer `limit`. - **Output**: A list of integers representing all palindromic primes up to `limit`. - **Constraints**: `2 ≤ limit ≤ 10^5` Detailed Requirements - **Edge Cases**: - Handle non-integer and out-of-boundary inputs appropriately in `is_palindromic_prime` by raising a `ValueError`. - Ensure performance efficiency for `find_palindromic_primes` with a large limit. - **Error Handling**: Additionally provide meaningful error messages for invalid inputs. Example ```python >>> is_palindromic_prime(101) True >>> is_palindromic_prime(131) True >>> is_palindromic_prime(10) False >>> find_palindromic_primes(200) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191] ``` Performance Goal - Efficient performance, leveraging optimized prime-checking algorithms and string manipulation techniques. - Handle large inputs within reasonable time and space limits.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindromic_prime(n): if not isinstance(n, int) or n < 2: raise ValueError(\\"Input must be an integer greater than or equal to 2.\\") return str(n) == str(n)[::-1] and is_prime(n) def find_palindromic_primes(limit): if not isinstance(limit, int) or limit < 2: raise ValueError(\\"Limit must be an integer greater than or equal to 2.\\") palindromic_primes = [] for num in range(2, limit + 1): if is_palindromic_prime(num): palindromic_primes.append(num) return palindromic_primes"},{"question":"# Question: You are given an array of integers and an integer k. Write a function `k_largest_elements` that returns the k largest elements in the array in descending order. Ensure that the function handles various edge cases, such as arrays with duplicate values, negative numbers, and different sizes. Function Signature: ```python def k_largest_elements(arr: list[int], k: int) -> list[int]: Find the k largest elements in the array in descending order. Args: arr (list of int): Input array of integers. k (int): Number of largest elements to return. Returns: list of int: List containing the k largest elements in descending order. Raises: ValueError: If input is not valid (e.g., arr is not a list of integers, k is not an integer, k is greater than the length of the array, or k is non-positive). ``` Sample Input/Output: ```python assert k_largest_elements([3, 1, 5, 12, 2, 11], 3) == [12, 11, 5] assert k_largest_elements([3, 3, 3, 3, 3], 2) == [3, 3] assert k_largest_elements([-1, -5, -3, -2], 2) == [-1, -2] assert k_largest_elements([10, 3, 15, 7, 8, 23, 74, 18], 4) == [74, 23, 18, 15] ``` Constraints: * The input `arr` will always be a valid list of integers. * The input array `arr` may contain duplicate elements. * The value of `k` will be a positive integer and not greater than the length of the array. Notes: * Invalid inputs must raise a `ValueError` with appropriate messages as provided in the example code. * The function should handle the input efficiently, especially for larger arrays. * Do not use any third-party libraries; rely solely on Python\'s standard library.","solution":"def k_largest_elements(arr: list[int], k: int) -> list[int]: Find the k largest elements in the array in descending order. Args: arr (list of int): Input array of integers. k (int): Number of largest elements to return. Returns: list of int: List containing the k largest elements in descending order. Raises: ValueError: If input is not valid (e.g., arr is not a list of integers, k is not an integer, k is greater than the length of the array, or k is non-positive). if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"arr must be a list of integers\\") if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") if k <= 0: raise ValueError(\\"k must be a positive integer\\") if k > len(arr): raise ValueError(\\"k must not be greater than the length of the array\\") # Sorting the array in descending order sorted_arr = sorted(arr, reverse=True) # Returning the first k elements return sorted_arr[:k]"},{"question":"# DNA Sequence Analysis **Scenario**: You are working at a biotech firm that analyzes DNA sequences for genetic research. Each DNA sequence is composed of four nucleotides denoted by the characters: \'A\', \'C\', \'G\', and \'T\'. Your task is to create a utility that can find the most frequent subsequence of length `k` in a given DNA sequence. This will help biologists identify repetitive patterns that might be of interest for further study. **Task**: Write a function `most_frequent_subsequence` that takes in a DNA string and an integer `k`, and returns the most frequent subsequence of length `k`. If there are multiple subsequences with the same maximum frequency, return the one that appears first in the DNA sequence. # Function Signature ```python def most_frequent_subsequence(dna: str, k: int) -> str: pass ``` # Input - A string `dna` (0 <= len(dna) <= 10^6) consisting only of the characters \'A\', \'C\', \'G\', \'T\'. - An integer `k` (1 <= k <= len(dna)). # Output - A string representing the most frequent subsequence of length `k`. # Constraints 1. The DNA sequence can be as long as 1,000,000 characters. 2. The function should handle edge cases such as an empty DNA sequence or minimum subsequence length (`k = 1`). # Example ```python print(most_frequent_subsequence(\\"ACGTACGTACGT\\", 3)) # Output: \\"ACG\\" print(most_frequent_subsequence(\\"AAAAAA\\", 2)) # Output: \\"AA\\" print(most_frequent_subsequence(\\"GATTACA\\", 3)) # Output: \\"GAT\\" print(most_frequent_subsequence(\\"\\", 1)) # Output: \\"\\" ``` # Evaluation Criteria 1. **Accuracy**: Correctly identifies the most frequent subsequence of length `k`. 2. **Efficiency**: Handles large DNA sequences efficiently. 3. **Robustness**: Manages different edge cases seamlessly. 4. **Clarity**: Code is well-structured and easily understandable. **Note**: While not mandatory, adding internal comments to clarify your approach and explain any significant choices made during implementation might be helpful for evaluation.","solution":"def most_frequent_subsequence(dna: str, k: int) -> str: Returns the most frequent subsequence of length k in the given DNA sequence. If multiple subsequences have the same frequency, the first one in the sequence is returned. if k == 0 or len(dna) == 0 or k > len(dna): return \\"\\" from collections import defaultdict # Dictionary to store frequency of each subsequence subseq_frequency = defaultdict(int) # Iterate through the DNA sequence for i in range(len(dna) - k + 1): subseq = dna[i:i + k] subseq_frequency[subseq] += 1 # Determine the most frequent subsequence most_frequent = \\"\\" max_freq = 0 for subseq, freq in subseq_frequency.items(): if freq > max_freq or (freq == max_freq and len(most_frequent)==0): most_frequent = subseq max_freq = freq return most_frequent"},{"question":"# Coding Question: You are given a list of non-negative integers representing the amount of money in each house, arranged in a circle. Your task is to determine the maximum amount of money you can rob tonight without alerting the police. Since the houses are arranged in a circle, the first house is the neighbor of the last one, which means you cannot rob both the first and the last house. * **Input Format**: - You will be provided with a variable, `nums`, which is a list of non-negative integers representing the amount of money in each house. * **Output Format**: - Return a single integer which is the maximum amount of money you can rob. * **Constraints**: - The length of `nums` will be between 1 and 100. - Each integer in `nums` will be between 0 and 1000. * **Performance requirements**: - The algorithm should be able to handle lists with up to 100 elements efficiently. # Example: Given the following list: ``` [2, 3, 2] ``` The maximum amount of money you can rob is 3, since you cannot rob both the first and the last house. # Function Signature: ```python def rob_circle(nums: List[int]) -> int: # Your code here ``` # Example Usage: ```python nums = [2, 3, 2] assert rob_circle(nums) == 3 nums = [1, 2, 3, 1] assert rob_circle(nums) == 4 ```","solution":"from typing import List def rob_circle(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums) def rob_linear(nums: List[int]) -> int: prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"# Context You\'re working on a module for a health and fitness application that tracks users\' daily steps. The application needs to identify the longest streak of consecutive days where the user met their step goal. # Task Write a function `longest_streak(daily_steps: list[int], goal: int) -> int` that finds the length of the longest streak of consecutive days the user met or exceeded their step goal. # Function Signature ```python def longest_streak(daily_steps: list[int], goal: int) -> int: Finds the longest streak of consecutive days the user met or exceeded their step goal. :param daily_steps: A list of integers representing the number of steps taken each day. :param goal: An integer step goal that the user is aiming to meet or exceed each day. :return: The length of the longest streak of days where the user met or exceeded their step goal. ``` # Input * `daily_steps`: A list of integers, where each integer represents the number of steps taken on a given day. Example: `[1000, 12000, 13000, 8000, 11000, 15000, 4000]` * `goal`: A non-negative integer representing the daily step goal. Example: `10000` # Output * The length of the longest streak of consecutive days where the user met or exceeded their step goal as an integer. # Constraints * 0 ≤ len(daily_steps) ≤ 10^3 * 0 ≤ min(daily_steps) ≤ max(daily_steps) ≤ 10^5 * 0 ≤ goal ≤ 10^5 # Examples 1. Input: `daily_steps = [10000, 12000, 13000, 8000, 11000, 15000, 4000], goal = 10000` Output: `3` 2. Input: `daily_steps = [5000, 7000, 9000, 10000, 20000, 15000, 21000], goal = 15000` Output: `2` 3. Input: `daily_steps = [15000, 15000, 15000, 15000, 15000], goal = 10000` Output: `5` # Notes Consider edge cases such as when the list of daily steps is empty or when the goal is never met. Ensure your function handles these appropriately.","solution":"def longest_streak(daily_steps: list[int], goal: int) -> int: Finds the longest streak of consecutive days the user met or exceeded their step goal. :param daily_steps: A list of integers representing the number of steps taken each day. :param goal: An integer step goal that the user is aiming to meet or exceed each day. :return: The length of the longest streak of days where the user met or exceeded their step goal. max_streak = 0 current_streak = 0 for steps in daily_steps: if steps >= goal: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"# Problem Description You have been hired to help develop a simplified URL shortening service. Your task is to implement functions to shorten and restore URLs using a custom mapping system. Each shortened URL will be represented by a unique 6-character string. # Function Requirements 1. **Function Name**: `shorten_url` - **Input**: - `url` (str): The input long URL that needs to be shortened. - **Output**: - `shortened_url` (str): The shortened version of the input URL. 2. **Function Name**: `restore_url` - **Input**: - `shortened_url` (str): The shortened URL that needs to be restored. - **Output**: - `original_url` (str): The original long URL corresponding to the shortened URL. # Constraints - The `shorten_url` function should return a unique 6-character string for each new URL. - The `restore_url` function should accurately return the original URL when provided with a valid shortened URL. - Assume no two input URLs will be identical. - The solution should store the mapping between original URLs and shortened URLs internally. - It should handle at least 10,000 unique URLs efficiently. # Performance Requirements - Both functions should have O(1) time complexity for shorten and restore operations. # Example ```python url = \\"https://www.example.com/page\\" shortened_url = shorten_url(url) print(shortened_url) # Output: A unique 6-character string, e.g., \\"1a2B3c\\" original_url = restore_url(shortened_url) print(original_url) # Output: \\"https://www.example.com/page\\" ``` # Task Write the `shorten_url` and `restore_url` functions to achieve the above requirements. You can use a dictionary or any suitable data structure to store the mappings. The functions need to ensure that the same long URL always maps to the same shortened URL, and vice-versa. ```python import random import string # Initialize storage for URL mappings url_to_short = {} short_to_url = {} def shorten_url(url): if url in url_to_short: return url_to_short[url] characters = string.ascii_letters + string.digits while True: shortened = \'\'.join(random.choice(characters) for _ in range(6)) if shortened not in short_to_url: break url_to_short[url] = shortened short_to_url[shortened] = url return shortened def restore_url(shortened_url): return short_to_url.get(shortened_url, \\"\\") ``` # Note Ensure that your implementation of the `shorten_url` function generates truly unique 6-character strings to prevent collisions.","solution":"import random import string # Initialize storage for URL mappings url_to_short = {} short_to_url = {} def shorten_url(url): Shorten a long URL to a 6-character unique string. if url in url_to_short: return url_to_short[url] characters = string.ascii_letters + string.digits while True: shortened = \'\'.join(random.choice(characters) for _ in range(6)) if shortened not in short_to_url: break url_to_short[url] = shortened short_to_url[shortened] = url return shortened def restore_url(shortened_url): Restore the original URL from a shortened URL. return short_to_url.get(shortened_url, \\"\\")"},{"question":"# Problem Statement You are given a list of `n` integers representing the heights of buildings aligned in a row. Implement a function `trap_rainwater` to determine how much rainwater can be trapped between the buildings when it rains. The width of each building is 1. # Function Signature ```python def trap_rainwater(heights: list[int]) -> int: pass ``` # Input - `heights`: A list of `n` non-negative integers where `1 <= n <= 10^5`. # Output - Returns an integer representing the total units of rainwater that can be trapped. # Example ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_rainwater(heights)) # Output: 6 heights2 = [4, 2, 0, 3, 2, 5] print(trap_rainwater(heights2)) # Output: 9 ``` # Constraints - The function should efficiently handle large lists of heights. - Optimize the performance to ensure the solution runs within reasonable time limits for large inputs. - Handle edge cases where no rainwater can be trapped, such as when there are fewer than 3 buildings. # Requirements - Write clean and efficient code to address the problem. - Account for all edge cases and large inputs to ensure the solution is robust and scalable.","solution":"def trap_rainwater(heights: list[int]) -> int: Calculate the total amount of trapped rainwater between buildings represented by a list of heights. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"Prime Sum Checker You are tasked with writing a function that checks whether there exist two distinct prime numbers that add up to a given integer `n`. If there are multiple such pairs, return any one of them. To solve this: * Iterate through all prime numbers less than `n`. * Check if the difference between `n` and the prime number is also a prime number. Task: Implement the function `find_prime_pair(n: int) -> Optional[Tuple[int, int]]` that: * Takes an integer `n` (2 < n ≤ 10^6). * Returns a tuple of two integers that are prime numbers whose sum is equal to `n`, or `None` if no such pair exists. # Input: * An integer `n`, the sum to check for prime pairs. # Output: * A tuple of two prime numbes whose sum equals `n`, or `None`. # Examples: ```python assert find_prime_pair(10) == (3, 7) or find_prime_pair(10) == (5, 5) assert find_prime_pair(26) == (3, 23) or find_prime_pair(26) == (13, 13) assert find_prime_pair(44) == (3, 41) or find_prime_pair(44) == (17, 27) assert find_prime_pair(17) == (None) ``` # Constraints: * You must efficiently find and check prime numbers within the given limits. * The function should run in a reasonable time frame for the input size ( n ). # Note: * Use a sieve algorithm to generate a list of prime numbers up to `n`. * Ensure the solution is optimized to handle the upper constraint efficiently.","solution":"from typing import Optional, Tuple import math def sieve_of_eratosthenes(max_num: int) -> list: is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for num in range(2, int(math.isqrt(max_num)) + 1): if is_prime[num]: for multiple in range(num * num, max_num + 1, num): is_prime[multiple] = False return is_prime def find_prime_pair(n: int) -> Optional[Tuple[int, int]]: if n <= 2: return None is_prime = sieve_of_eratosthenes(n) for i in range(2, n): if is_prime[i] and is_prime[n - i] and i != (n - i): return (i, n - i) return None"},{"question":"Problem Statement # Count Distinct Primes in Range You are given two positive integers `a` and `b`. Your task is to implement a function `count_distinct_primes(a: int, b: int) -> int` that returns the count of distinct prime numbers between `a` and `b` (inclusive). # Input - **a**: A positive integer such that (1 leq a leq 10^6). - **b**: A positive integer such that (1 leq b leq 10^6) and (a leq b). # Output Return the count of distinct prime numbers between `a` and `b` (inclusive). # Example ```python >>> count_distinct_primes(10, 20) 4 >>> count_distinct_primes(1, 10) 4 ``` # Constraints - The input values `a` and `b` will be positive integers within the range `[1, 1,000,000]`. - You are guaranteed that (a leq b). # Requirements - The implementation should be efficient, leveraging appropriate algorithms to handle the upper constraint. - Consider the use of the Sieve of Eratosthenes for precomputing prime numbers. # Implementation Notes Plan to use efficient prime number generation techniques for large ranges, and ensure that your solution can handle the full input range within a reasonable time frame.","solution":"def count_distinct_primes(a, b): Returns the count of distinct prime numbers between a and b (inclusive). def sieve_of_eratosthenes(limit): sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= limit: if sieve[p]: for i in range(p * p, limit + 1, p): sieve[i] = False p += 1 return sieve # Use Sieve of Eratosthenes to find all primes up to b primes_up_to_b = sieve_of_eratosthenes(b) # Count primes within range [a, b] prime_count = sum(primes_up_to_b[a:b+1]) return prime_count"},{"question":"# Problem Description: Given a binary tree implementation, extend its functionality by implementing the following additional method: **Task**: Implement a method `find_path` which returns the path from the root node to a given target node as a list of node values. ```python def find_path(self, target: Any) -> List[Any]: Finds the path from the root of the binary tree to the given target node. Time complexity: O(n) @param target: The value of the target node to find the path for. @returns: A list of node values representing the path from the root to the target node. Example: >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.right.right = Node(6) >>> bt = BinaryTree(root) >>> bt.find_path(5) [1, 2, 5] >>> bt.find_path(6) [1, 3, 6] >>> bt.find_path(10) [] ``` **Input**: - A value `target` (any type that matches the node values in the binary tree). **Output**: - A list of node values representing the path from the root to the `target` node. If the target node does not exist, return an empty list. # Constraints: - The basic operations of the binary tree (insert, search, etc.) must work properly. - The `find_path` method must handle both large and small trees. - Null tree (empty) should be handled gracefully, returning an empty list. # Example Consider a sample binary tree with the following structure: ``` 1 / 2 3 / 4 5 6 ``` The usage of find_path could be as follows: ```python # Binary Tree initialization root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) bt = BinaryTree(root) # Finding paths print(bt.find_path(5)) # Output: [1, 2, 5] print(bt.find_path(6)) # Output: [1, 3, 6] print(bt.find_path(10)) # Output: [] ``` **Notes**: - Ensure proper traversal of the binary tree to find the path. - Consider edge cases including non-existent target nodes and empty trees. - The method should return an empty list when the target node does not exist.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self, root=None): self.root = root def find_path(self, target): Finds the path from the root of the binary tree to the given target node. @param target: The value of the target node to find the path for. @returns: A list of node values representing the path from the root to the target node. path = [] if self._find_path_helper(self.root, target, path): return path else: return [] def _find_path_helper(self, node, target, path): # Base case: if the node is None, return False if node is None: return False # Include the current node\'s value in the path path.append(node.value) # Check if the current node is the target node if node.value == target: return True # Otherwise, check both subtrees if self._find_path_helper(node.left, target, path) or self._find_path_helper(node.right, target, path): return True # If the target is not present in either subtree, # remove the current node\'s value from the path and return False. path.pop() return False"},{"question":"# Sales Data Analysis for Inventory Management You are provided with a class `SalesAnalyzer` that partially implements functionality to analyze sales data for a retail store. The goal is to provide insights on inventory management by identifying products with varying sales patterns that may need stock adjustments. Your tasks are to: 1. **Implement the `detect_trending_products` method** to identify products that are showing a consistent increase in sales over the past `n` days. 2. **Implement the `detect_underperforming_products` method** to find products with sales below a specified threshold over the past `m` days. # Implementation Details: 1. **`detect_trending_products` method** should: - Accept a product ID and a time range (last `n` days). - Calculate the sales trend by comparing daily sales data for the specified range. - Return True if the product shows a consistent increase in sales, otherwise False. 2. **`detect_underperforming_products` method** should: - Accept a sales threshold and a time range. - Iterate through all products and determine which ones fall below the sales threshold over the specified range. - Return a list of product IDs that are underperforming. # Input/Output: - **Input**: - For `detect_trending_products` method: ```python def detect_trending_products(self, product_id, n): # product_id: ID of the product to analyze # n: Number of past days to analyze sales trend ``` - For `detect_underperforming_products` method: ```python def detect_underperforming_products(self, sales_threshold, m): # sales_threshold: Minimum sales to consider a product performing well # m: Number of past days to analyze ``` - **Output**: - For `detect_trending_products` method: - Return True if the product\'s sales trend is increasing over the last `n` days, otherwise False. - For `detect_underperforming_products` method: - Return a list of product IDs that have sales below the threshold over the last `m` days. # Constraints: 1. Sales data is stored in a dictionary within `SalesAnalyzer` where the keys are product IDs and values are lists of daily sales numbers. 2. Assume the sales data is preprocessed and consistent (e.g., no missing days). 3. The time range for analysis (n and m days) will not exceed the available data length. # Notes: - Implement efficient data analysis using Python\'s standard libraries (e.g., numpy, pandas). - Consider edge cases where there may be sudden spikes or drops in sales data. - Focus on scalability to handle large datasets efficiently. # Example Scenario: ```python # Example usage of SalesAnalyzer class data = { \'P001\': [10, 12, 15, 20, 25, 30, 35], \'P002\': [8, 7, 6, 5, 4, 4, 3], \'P003\': [20, 21, 22, 23, 24, 25, 26] } analyzer = SalesAnalyzer(data) # Detect trending products print(analyzer.detect_trending_products(\'P001\', 5)) # Should return True print(analyzer.detect_trending_products(\'P002\', 5)) # Should return False # Detect underperforming products print(analyzer.detect_underperforming_products(5, 7)) # Should return [\'P002\'] ```","solution":"class SalesAnalyzer: def __init__(self, sales_data): self.sales_data = sales_data def detect_trending_products(self, product_id, n): sales = self.sales_data.get(product_id) if sales is None or len(sales) < n: return False for i in range(-n, -1): if sales[i] >= sales[i + 1]: return False return True def detect_underperforming_products(self, sales_threshold, m): underperforming_products = [] for product_id, sales in self.sales_data.items(): if len(sales) < m: continue if all(sale < sales_threshold for sale in sales[-m:]): underperforming_products.append(product_id) return underperforming_products"},{"question":"# Coding Assessment Question Write a function to implement a simple neural network for binary classification using NumPy only (no TensorFlow or PyTorch). The neural network should have one hidden layer with ReLU activation and one output layer with sigmoid activation. Initialize weights using small random numbers and include a method for training the model using gradient descent. Function Signature ```python def train_neural_network( X_train: np.ndarray, y_train: np.ndarray, X_val: np.ndarray, y_val: np.ndarray, hidden_layer_size: int = 10, learning_rate: float = 0.01, num_epochs: int = 1000, batch_size: int = 32 ) -> tuple: ``` Input Specifications: - **X_train** (*np.ndarray*): Training data features, 2D array of shape (num_samples, num_features). - **y_train** (*np.ndarray*): Training data labels, 1D array of shape (num_samples,), binary class labels (0 or 1). - **X_val** (*np.ndarray*): Validation data features, 2D array of shape (num_samples, num_features). - **y_val** (*np.ndarray*): Validation data labels, 1D array of shape (num_samples,), binary class labels (0 or 1). - **hidden_layer_size** (*int*): Number of neurons in the hidden layer. - **learning_rate** (*float*): Learning rate for gradient descent. - **num_epochs** (*int*): Number of epochs to train the model. - **batch_size** (*int*): Size of each batch for training. Output Specifications: - **output** (*tuple*): A tuple containing: - **weights_hidden** (*np.ndarray*): Learned weights for the hidden layer. - **biases_hidden** (*np.ndarray*): Learned biases for the hidden layer. - **weights_output** (*np.ndarray*): Learned weights for the output layer. - **biases_output** (*np.ndarray*): Learned biases for the output layer. Example Usage: ```python import numpy as np # Sample Synthetic Data np.random.seed(42) X_train = np.random.randn(100, 20) y_train = np.random.randint(0, 2, 100) X_val = np.random.randn(20, 20) y_val = np.random.randint(0, 2, 20) weights_hidden, biases_hidden, weights_output, biases_output = train_neural_network( X_train, y_train, X_val, y_val ) ``` Constraints: - You may only use NumPy for your implementation. - Implement ReLU activation for the hidden layer. - Implement sigmoid activation for the output layer. - Use cross-entropy loss for training. - Ensure that gradients are computed and applied correctly for both weights and biases. - Implement a mini-batch gradient descent for optimization. - Ensure the validation set is used to compute and print validation accuracy every 100 epochs.","solution":"import numpy as np def sigmoid(x): return 1 / (1 + np.exp(-x)) def relu(x): return np.maximum(0, x) def relu_derivative(x): return np.where(x > 0, 1, 0) def cross_entropy_loss(y_true, y_pred): eps = 1e-12 # to avoid log(0) y_pred = np.clip(y_pred, eps, 1 - eps) loss = - (y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) return np.mean(loss) def accuracy(y_true, y_pred): return np.mean((y_pred > 0.5) == y_true) def train_neural_network( X_train: np.ndarray, y_train: np.ndarray, X_val: np.ndarray, y_val: np.ndarray, hidden_layer_size: int = 10, learning_rate: float = 0.01, num_epochs: int = 1000, batch_size: int = 32 ) -> tuple: np.random.seed(42) num_features = X_train.shape[1] num_samples = X_train.shape[0] # Initialize weights and biases weights_hidden = np.random.randn(num_features, hidden_layer_size) * 0.01 biases_hidden = np.zeros((1, hidden_layer_size)) weights_output = np.random.randn(hidden_layer_size, 1) * 0.01 biases_output = np.zeros((1, 1)) for epoch in range(num_epochs): indices = np.arange(num_samples) np.random.shuffle(indices) for start in range(0, num_samples, batch_size): end = min(start + batch_size, num_samples) batch_indices = indices[start:end] X_batch = X_train[batch_indices] y_batch = y_train[batch_indices].reshape(-1, 1) # Forward pass hidden_layer_input = np.dot(X_batch, weights_hidden) + biases_hidden hidden_layer_output = relu(hidden_layer_input) output_layer_input = np.dot(hidden_layer_output, weights_output) + biases_output predictions = sigmoid(output_layer_input) # Compute loss loss = cross_entropy_loss(y_batch, predictions) # Backward pass output_layer_error = predictions - y_batch output_layer_delta = output_layer_error hidden_layer_error = np.dot(output_layer_delta, weights_output.T) * relu_derivative(hidden_layer_input) # Update weights and biases weights_output -= learning_rate * np.dot(hidden_layer_output.T, output_layer_delta) / batch_size biases_output -= learning_rate * np.sum(output_layer_delta, axis=0, keepdims=True) / batch_size weights_hidden -= learning_rate * np.dot(X_batch.T, hidden_layer_error) / batch_size biases_hidden -= learning_rate * np.sum(hidden_layer_error, axis=0, keepdims=True) / batch_size # Validation accuracy if (epoch + 1) % 100 == 0: hidden_val = relu(np.dot(X_val, weights_hidden) + biases_hidden) output_val = sigmoid(np.dot(hidden_val, weights_output) + biases_output) val_accuracy = accuracy(y_val, output_val) print(f\\"Epoch {epoch + 1}, Validation Accuracy: {val_accuracy * 100:.2f}%\\") return weights_hidden, biases_hidden, weights_output, biases_output"},{"question":"Consider a scenario where you are designing an online shopping website. One important feature is to allow users to search for available products quickly, based on certain keywords. To help with this, you want to implement a search functionality that matches products based on provided prefixes efficiently. You are given a list of product names and a list of query prefixes. Your goal is to find all products that start with each query prefix and return them along with their counts. # Task Complete the functions `build_trie` and `search_prefix` to construct a Trie data structure for the given product names and efficiently search for products starting with given prefixes. Function Signature ```python def build_trie(products: List[str]) -> Dict: # Existing implementation should be here def search_prefix(trie: Dict, prefix: str) -> List[str]: # Existing implementation should be here ``` Input Format * A list `products` of size `p`, where each element is a string representing a product name. * A list `prefixes` of size `q`, where each element is a string representing a query prefix. Output Format * A dictionary where each key is a prefix from the input list `prefixes` and the value is a list of products starting with that prefix along with their counts. Constraints * 1 ≤ p ≤ 10^5 * 1 ≤ q ≤ 10^3 * Each product name and prefix will consist of only lowercase English letters. * 1 ≤ length of each product name, each prefix ≤ 100 # Additional Problem Given multiple query prefixes, find all products starting with each prefix and return the results. Additional Function Signature ```python def search_multiple_prefixes(products: List[str], prefixes: List[str]) -> Dict[str, List[Tuple[str, int]]]: # Implement this function ``` Additional Input Format * A list `products` of size `p`, where each element is a string representing a product name. * A list `prefixes` of size `q`, where each element is a string representing a query prefix. Additional Output Format * Return a dictionary where each key is a prefix from the input list `prefixes` and the value is a list of tuples. Each tuple contains a product name that starts with that prefix and the count of its occurrences. Example ```python products = [\\"apple\\", \\"appetizer\\", \\"banana\\", \\"bandana\\", \\"band\\"] prefixes = [\\"ap\\", \\"ban\\"] print(search_multiple_prefixes(products, prefixes)) # Output: {\'ap\': [(\'apple\', 1), (\'appetizer\', 1)], \'ban\': [(\'banana\', 1), (\'bandana\', 1), (\'band\', 1)]} ``` Constraints * The total length of all product names combined will not exceed 10^5. # Notes * Use a Trie data structure to minimize the time complexity for prefix searches. * Optimize your code to handle large lists of products and prefixes efficiently.","solution":"from typing import List, Dict, Tuple from collections import defaultdict def build_trie(products: List[str]) -> Dict: trie = {} for product in products: node = trie for char in product: if char not in node: node[char] = {} node = node[char] node[\'#\'] = node.get(\'#\', 0) + 1 # End of word marker (store counts) return trie def search_prefix(trie: Dict, prefix: str) -> List[Tuple[str, int]]: node = trie for char in prefix: if char not in node: return [] node = node[char] def collect_all_words(node: Dict, prefix: str) -> List[Tuple[str, int]]: results = [] for char, next_node in node.items(): if char == \'#\': results.append((prefix, next_node)) else: results.extend(collect_all_words(next_node, prefix + char)) return results return collect_all_words(node, prefix) def search_multiple_prefixes(products: List[str], prefixes: List[str]) -> Dict[str, List[Tuple[str, int]]]: trie = build_trie(products) results = {} for prefix in prefixes: results[prefix] = search_prefix(trie, prefix) return results"},{"question":"# Sort Log Files **Context**: You are tasked with sorting a list of log files. Each log file is represented as a string that starts with a unique identifier followed by either letters or digits. Letter-logs should be sorted lexicographically, excluding the identifier (with ties resolved by the identifier). Digit-logs should retain their order. **Task**: Implement a function that sorts the given list of logs, prioritizing letter-logs over digit-logs. **Function Signature**: ```python def reorder_log_files(logs: List[str]) -> List[str]: Reorder log files so that all the letter-logs come before any digit-log. Letter-logs are ordered lexicographically, ignoring identifier, except in case of ties, where the identifier is used. Digit-logs should maintain their relative ordering. :param logs: A list of log file strings. :return: A list of log file strings sorted according to the specified order. ``` **Input**: * `logs` (List[str]): A list of log file strings. **Output**: * Returns a list of log file strings sorted with letter-logs before digit-logs, each sorted as specified. **Constraints**: * The number of log files in the list will not exceed 1000. * Each log can be assumed to have at least one identifier and one additional part. * Identifiers are alphanumeric substrings. **Performance Requirements**: * The function should run in O(N log N) time complexity due to sorting. * The memory usage should primarily be constrained by the input size. **Example**: ```python # Example usage: logs = [ \\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\" ] reordered_logs = reorder_log_files(logs) # Expected output: [\'g1 act car\', \'a8 act zoo\', \'ab1 off key dog\', \'a1 9 2 3 1\', \'zo4 4 7\'] print(reordered_logs) ``` Ensure you handle edge cases effectively and optimize for performance where possible.","solution":"from typing import List def reorder_log_files(logs: List[str]) -> List[str]: def get_key(log): identifier, rest = log.split(\\" \\", 1) is_digit = rest[0].isdigit() return (1, ) if is_digit else (0, rest, identifier) return sorted(logs, key=get_key) # Example usage: # logs = [ # \\"a1 9 2 3 1\\", # \\"g1 act car\\", # \\"zo4 4 7\\", # \\"ab1 off key dog\\", # \\"a8 act zoo\\" # ] # reordered_logs = reorder_log_files(logs) # Expected output: [\'g1 act car\', \'a8 act zoo\', \'ab1 off key dog\', \'a1 9 2 3 1\', \'zo4 4 7\'] # print(reordered_logs)"},{"question":"# Scenario You are working on a graphics application that draws various shapes on a canvas. One essential operation for rendering polygons is calculating the interior angle at each vertex. A specific requirement is to calculate the sum of the interior angles for a given convex polygon. # Task Write a function to calculate the sum of the interior angles of a convex polygon given its number of sides. # Function Signature ```python def sum_of_interior_angles(sides: int) -> int: Calculate the sum of the interior angles of a convex polygon. :param sides: The number of sides (and vertices) in the polygon. :return: The sum of the interior angles in degrees. :raises ValueError: If the number of sides is less than 3. ``` # Input * `sides`: an integer representing the number of sides in the polygon. # Output Returns the sum of the interior angles in degrees as an integer. # Constraints * The polygon must have at least 3 sides. * If the number of sides is less than 3, the function should raise a `ValueError`. # Example ```python >>> sum_of_interior_angles(3) 180 >>> sum_of_interior_angles(4) 360 >>> sum_of_interior_angles(5) 540 >>> sum_of_interior_angles(6) 720 >>> sum_of_interior_angles(2) Traceback (most recent call last): ... ValueError: A polygon must have at least 3 sides ``` # Notes * Recall that the formula for the sum of the interior angles of a polygon is `(n - 2) * 180`, where `n` is the number of sides. * Ensure your implementation runs efficiently with a time complexity of O(1). * Proper validation should be performed to ensure the input constraints are met.","solution":"def sum_of_interior_angles(sides: int) -> int: Calculate the sum of the interior angles of a convex polygon. :param sides: The number of sides (and vertices) in the polygon. :return: The sum of the interior angles in degrees. :raises ValueError: If the number of sides is less than 3. if sides < 3: raise ValueError(\\"A polygon must have at least 3 sides\\") return (sides - 2) * 180"},{"question":"# Context: In combinatorial mathematics, set partitions denote ways to divide a set into non-overlapping subsets. Each subset is called a part. Given a set of n elements, the Bell number B(n) gives the number of ways to partition this set. # Task: Write a function `calculate_bell_number` that computes the Bell number B(n) for a given integer `n`. The function should optimize for both time and space complexity, making it feasible to compute for larger n values. # Function Signature: ```python def calculate_bell_number(n: int) -> int: pass ``` # Input: * `n` (int): an integer representing the set size. # Output: * Returns the Bell number B(n). # Example: ```python assert calculate_bell_number(0) == 1 assert calculate_bell_number(1) == 1 assert calculate_bell_number(2) == 2 assert calculate_bell_number(3) == 5 assert calculate_bell_number(4) == 15 ``` # Constraints: * The function should handle at least n up to 20 efficiently. * Consider the properties and symmetries of the Bell triangle for optimized computation. # Notes: * Bell numbers can be calculated using Bell\'s triangle, also known as the Aitken array. * For a given integer `n`, B(0) is 1, and B(n) can be derived based on the previously calculated Bell numbers. # Guidelines: * Utilize efficient combinatorial techniques and precomputed values where applicable. * Ensure your function is capable of handling edge cases and larger values of `n`. ```python def calculate_bell_number(n: int) -> int: Returns the Bell number B(n). bell = [[0 for _ in range(n+1)] for _ in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): # Explicitly set the value for the start of each row bell[i][0] = bell[i-1][i-1] # Fill the rest of the entries for the current row for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0] ```","solution":"def calculate_bell_number(n: int) -> int: Returns the Bell number B(n). Bell numbers are calculated using Bell\'s triangle (Aitken\'s array). bell = [[0 for _ in range(n+1)] for _ in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): # Start of each row in Bell triangle bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0]"},{"question":"# Zigzag Conversion You are given a string `s` and an integer `numRows`. Write a function that converts the string `s` to a zigzag pattern on a given number of rows and then reads the pattern line by line. The conversion should work vertically and diagonally like a zigzag: For example, the string `\\"PAYPALISHIRING\\"` with `numRows` equal to 3 would be written as: ``` P A H N A P L S I I G Y I R ``` And thus, the string representation would be `\\"PAHNAPLSIIGYIR\\"`. **Function Signature**: `def convert(s: str, numRows: int) -> str` **Inputs**: 1. `s` (str): A string consisting of alphanumeric characters and punctuation. 2. `numRows` (int): An integer indicating the number of rows. **Outputs**: - A string representing the zigzag conversion. **Constraints**: - `1 <= len(s) <= 1000` - `1 <= numRows <= 1000` **Examples**: 1. `convert(\\"PAYPALISHIRING\\", 3)` should return `\\"PAHNAPLSIIGYIR\\"` 2. `convert(\\"HELLO\\", 2)` should return `\\"HLOEL\\"` Implement the function `convert`.","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"# Sorting a List of Dictionaries by a Nested Key Context You need to sort a list of dictionaries based on a nested key. This problem often arises in data processing where records are stored as dictionaries within a list, and you need to sort them by one of the nested keys. Function Definition Implement the `sort_by_nested_key(records: list, key_path: str) -> list` function. **Input**: - `records` (list): A list of dictionaries to be sorted. - `key_path` (str): A string representing the path to the nested key, using dots (.) as separators. **Output**: - A list of dictionaries sorted by the specified nested key. Constraints: - Each dictionary in `records` contains the nested key specified by `key_path`. - The `key_path` will be a valid path in all given dictionaries. - The list `records` will contain between 0 and 10^3 dictionaries. - The nested values are assumed to be sortable (e.g., integers, strings). Example: ```python records = [ {\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}} ] assert sort_by_nested_key(records, \\"info.age\\") == [ {\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}} ] assert sort_by_nested_key(records, \\"info.name\\") == [ {\\"id\\": 1, \\"info\\": {\\"age\\": 30, \\"name\\": \\"Alice\\"}}, {\\"id\\": 2, \\"info\\": {\\"age\\": 25, \\"name\\": \\"Bob\\"}}, {\\"id\\": 3, \\"info\\": {\\"age\\": 35, \\"name\\": \\"Charlie\\"}} ] ``` Requirements: 1. The function should correctly handle sorting by any valid nested key specified in the `key_path`. 2. The solution should be efficient, utilizing Python\'s built-in sorting functionality in combination with extracting nested keys dynamically.","solution":"def sort_by_nested_key(records, key_path): Sorts a list of dictionaries by a nested key specified in key_path. Args: records (list): A list of dictionaries to be sorted. key_path (str): A string representing the path to the nested key, using dots (.) as separators. Returns: list: A sorted list of dictionaries based on the nested key. def get_nested_value(d, key_path): keys = key_path.split(\'.\') for key in keys: d = d[key] return d return sorted(records, key=lambda x: get_nested_value(x, key_path))"},{"question":"# Question: Managing Employee Hierarchies In a company, employees are arranged in a hierarchy. Each employee reports to exactly one manager, and the hierarchy forms a tree structure with the CEO at the root. The goal is to write a function that computes the total number of direct and indirect reports for each employee. Task Write a function `compute_employee_reports(employee_hierarchy: List[Tuple[int, int]]) -> Dict[int, int]` that takes a list of tuples representing the employee-manager relationships and returns a dictionary where the keys are employee IDs and the values are the total number of employees (direct and indirect) that report to them. Function Signature ```python def compute_employee_reports(employee_hierarchy: List[Tuple[int, int]]) -> Dict[int, int]: ``` Input - `employee_hierarchy`: A list of tuples `(employee, manager)` where each item represents the relationship between an employee and their direct manager. Output - A dictionary where the keys are employee IDs and the values are the total number of direct and indirect reports for each. Constraints - Employee IDs are positive integers starting from 1. - The list of employee-manager relationships forms a valid hierarchy (tree structure) with exactly one CEO (who reports to no one). - The input list contains at least one relationship. Example ```python compute_employee_reports([(2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]) # Output: {1: 5, 2: 2, 3: 1, 4: 0, 5: 0, 6: 0} ``` Explanation - Employee 1 (CEO) has 5 reports: employees [2, 3, 4, 5, 6] - Employee 2 has 2 reports: employees [4, 5] - Employee 3 has 1 report: employee [6] - Employees 4, 5, and 6 have 0 reports each. Performance Requirements The solution should be efficient enough to handle up to `10^5` employee-manager relationships within reasonable time and space constraints. Notes - Use appropriate data structures to traverse the hierarchy and compute the reports efficiently. - Ensure to handle edge cases such as employees with no reports accurately.","solution":"from typing import List, Tuple, Dict from collections import defaultdict def compute_employee_reports(employee_hierarchy: List[Tuple[int, int]]) -> Dict[int, int]: # Build the graph adjacency list and a dictionary to hold the counts graph = defaultdict(list) report_counts = defaultdict(int) for employee, manager in employee_hierarchy: graph[manager].append(employee) # Initialize all employees in the hierarchy report_counts[employee] report_counts[manager] # Function to count reports using DFS def dfs(employee): count = 0 for report in graph[employee]: count += 1 + dfs(report) report_counts[employee] = count return count # Find the CEO (the one who is not anybody\'s report) all_employees = set(report_counts.keys()) non_ceos = set(employee for employee, _ in employee_hierarchy) ceo = (all_employees - non_ceos).pop() # Start DFS from the CEO dfs(ceo) return report_counts"},{"question":"# Scenario Image processing often necessitates manipulating pixels based on their intensity values. One common requirement is altering the brightness of an image, which involves increasing or decreasing the intensity values of the image’s pixels uniformly. In this task, you will emulate a basic image brightness adjustment process. # Task Write a Python function `adjust_brightness(image: List[List[int]], adjustment: int) -> List[List[int]]` that takes an image represented as a 2D list of integers and an adjustment value. The function should increase each pixel\'s intensity value by the adjustment value, making sure that the resulting intensity values are clamped between 0 and 255. # Input Specifications * `image`: A 2D list of integers where each integer represents the intensity value of a pixel (ranging from 0 to 255). * `adjustment`: An integer that should be added to each pixel\'s intensity value. # Output Specifications * Returns a new 2D list of integers representing the adjusted image. # Constraints * The number of pixels in the image will not exceed 10^6. * Each intensity value will initially be between 0 and 255, inclusive. # Example ```python >>> image = [ [100, 150, 200], [50, 75, 125], [0, 25, 255] ] >>> adjust_brightness(image, 10) [ [110, 160, 210], [60, 85, 135], [10, 35, 255] ] >>> adjust_brightness(image, -20) [ [80, 130, 180], [30, 55, 105], [0, 5, 235] ] ``` # Requirements * Ensure that the intensity values remain within the 0-255 range after adjustment. * Performance should be efficient enough to handle the maximum input size.","solution":"from typing import List def adjust_brightness(image: List[List[int]], adjustment: int) -> List[List[int]]: def clamp(value: int) -> int: return max(0, min(255, value)) adjusted_image = [] for row in image: adjusted_row = [clamp(pixel + adjustment) for pixel in row] adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"Question # Problem Statement: You are working on a special encoding system and need to implement a function that reverses the binary representation of non-negative integers. Your task is to write a function `reverse_binary(n: int) -> str` that takes an integer `n`, converts it to its binary representation, reverses the binary digits, and returns the resulting string as a binary number prefixed with \'0b\'. # Function Signature: ```python def reverse_binary(n: int) -> str: pass ``` # Input: - A single non-negative integer input `n` (0 <= n <= 10^9). # Output: - A binary string prefixed with \\"0b\\" representing the binary digits of `n` reversed. # Constraints: - The input integer is non-negative. - Handle edge cases such as zero inputs effectively. # Examples: ```python assert reverse_binary(13) == \'0b1011\' # Binary of 13 is \'1101\', reverse is \'1011\' assert reverse_binary(8) == \'0b1\' # Binary of 8 is \'1000\', reverse is \'0001\' which is \'1\' assert reverse_binary(5) == \'0b101\' # Binary of 5 is \'101\', reverse is \'101\' assert reverse_binary(256) == \'0b1\' # Binary of 256 is \'100000000\', reverse is \'000000001\' which is \'1\' assert reverse_binary(0) == \'0b0\' # Binary of 0 is \'0\', reverse is \'0\' ``` # Additional Instructions: - Consider the edge case where the input number is zero. - No need to handle negative inputs as the constraint already specifies non-negative integers.","solution":"def reverse_binary(n: int) -> str: This function takes an integer `n`, converts it to its binary representation, reverses the binary digits and returns the resulting string as a binary number prefixed with \\"0b\\". # Convert to binary and strip off the \'0b\' prefix binary_rep = bin(n)[2:] # Reverse the binary representation reversed_binary_rep = binary_rep[::-1] # Convert back to integer to remove leading zeros and convert to binary string with prefix \'0b\' return \'0b\' + bin(int(reversed_binary_rep, 2))[2:]"},{"question":"# Problem Statement Problem Description You are given a list of strings. Your task is to determine the number of unique strings that can be obtained by rotating each string any number of times. Two strings are considered the same if one can be obtained from the other by rotating the string. For example, \\"abc\\" can be transformed into \\"bca\\" and \\"cab\\" by rotating. Function Signature ```python def count_unique_rotations(strings: list) -> int: Returns the number of unique strings after considering all rotations of each string. Parameters: strings (list): A list of strings. Returns: int: The number of unique strings after considering rotations. Example: >>> count_unique_rotations([\\"abc\\", \\"bca\\", \\"cab\\", \\"aaa\\", \\"aab\\"]) 3 ``` Input Constraints - 1 <= len(strings) <= 1,000 - 1 <= len(each string) <= 100 Output - An integer representing the number of unique strings considering all rotations. Example ```python >>> count_unique_rotations([\\"abc\\", \\"bca\\", \\"cab\\", \\"aaa\\", \\"aab\\"]) 3 # Explanation: \\"abc\\", \\"bca\\", and \\"cab\\" are rotations of each other, and they all represent one unique string. # \\"aaa\\" is already unique in its rotations form. \\"aab\\" does not have any other string in the list which is its rotation. ``` Requirements - The solution should efficiently compare rotated versions to avoid unnecessary computations. - Consider hashing or string manipulation techniques to manage comparisons. Hints - To determine if two strings are rotations of each other, concatenate one of the strings with itself and see if the other string is a substring of this concatenated string. - Use sets or other data structures to store and efficiently check for unique strings after normalization (considering all rotations).","solution":"def count_unique_rotations(strings: list) -> int: Returns the number of unique strings after considering all rotations of each string. # Function to get the minimal rotation of a string def get_minimal_rotation(s): n = len(s) doubled_s = s + s min_rotation = min(doubled_s[i:i+n] for i in range(n)) return min_rotation # Use a set to store unique minimal rotations unique_rotations = set() # Process each string to find its minimal rotation for s in strings: minimal_rotation = get_minimal_rotation(s) unique_rotations.add(minimal_rotation) return len(unique_rotations)"},{"question":"Task Write a function that takes a square matrix and rotates it 90 degrees clockwise with O(1) space complexity. # Function Signature ```python def rotate_matrix_clockwise(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input - A 2D list `matrix` representing a square matrix of integers, where (1 leq text{len(matrix)} leq 1000). # Output - The 2D list `matrix` after rotating it 90 degrees clockwise. # Constraints - Your implementation should run in O(n^2) time complexity, where n is the number of rows (or columns) of the matrix. - You must perform the rotation in place using O(1) additional space. - Avoid using Python\'s high-level rotation utilities. # Example ```python assert rotate_matrix_clockwise([[1,2,3],[4,5,6],[7,8,9]]) == [[7,4,1],[8,5,2],[9,6,3]] assert rotate_matrix_clockwise([[1,2],[3,4]]) == [[3,1],[4,2]] assert rotate_matrix_clockwise([[1]]) == [[1]] ``` # Note - Ensure that your function modifies the input matrix in place and returns the modified matrix. - Pay special attention to efficiently implementing the in-place rotation.","solution":"def rotate_matrix_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotates the given square matrix 90 degrees clockwise in place. Args: matrix: A 2D list representing a square matrix of integers Returns: The same matrix after rotating it 90 degrees clockwise. n = len(matrix) # First transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"Largest Region in a Binary Matrix You are given a binary matrix representing a grid of `0`s and `1`s. Cells with `1` are connected if they are adjacent (horizontally, vertically, or diagonally). Implement a function to find the size of the largest connected region of `1`s in the matrix. Function Signature ```python def largest_region(matrix: List[List[int]]) -> int: pass ``` # Input - `matrix` (List[List[int]]): A 2D list of integers where each element is either `0` or `1`, and 1 <= len(matrix), len(matrix[0]) <= 100. # Output - `int`: An integer representing the size of the largest connected region of `1`s. # Example ```python matrix = [[0, 0, 1, 0], [1, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]] largest_region(matrix) # Output: 6 ``` # Constraints - You cannot modify the input matrix. - The function should handle edge cases such as matrices full of `0`s or `1`s. Performance Requirements - The algorithm should run within O(m * n) time complexity, where m is the number of rows and n is the number of columns. - The space complexity outside the input matrix should be minimized. # Notes - You may use Depth-First Search (DFS) or Breadth-First Search (BFS) approaches to explore the regions. - Consider using a visited matrix to keep track of the cells that have already been checked. - Think about how to handle matrices where the entire grid is filled with `1`s or `0`s efficiently.","solution":"from typing import List def largest_region(matrix: List[List[int]]) -> int: def dfs(r, c): if r < 0 or r >= len(matrix) or c < 0 or c >= len(matrix[0]): return 0 if matrix[r][c] != 1: return 0 matrix[r][c] = -1 # mark as visited size = 1 # check all 8 directions: horizontal, vertical, and diagonal for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: size += dfs(r + dr, c + dc) return size largest = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if matrix[row][col] == 1: region_size = dfs(row, col) largest = max(largest, region_size) return largest"},{"question":"# Question: Fibonacci Sequence Last Digit You are required to implement a function that computes the last digit of the `n`-th Fibonacci number. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n - 1) + F(n - 2) for n >= 2 Function Specifications: 1. **Function Name: `fibonacci_last_digit`** 2. **Functionality**: Computes the last digit of the `n`-th Fibonacci number. 3. **Input**: - `n` (int): The position in the Fibonacci sequence (0 ≤ n ≤ 10^7). 4. **Output**: Returns the last digit (int) of the `n`-th Fibonacci number. Example: ```python # Fibonacci sequence positions: # F(0) = 0 # F(1) = 1 # F(2) = 1 # F(3) = 2 # F(4) = 3 # F(5) = 5 # F(6) = 8 # F(7) = 13 # F(8) = 21 # F(9) = 34 # F(10) = 55 # Example calculations: print(fibonacci_last_digit(0)) # Output: 0 print(fibonacci_last_digit(1)) # Output: 1 print(fibonacci_last_digit(10)) # Output: 5 print(fibonacci_last_digit(100)) # Output: 5 print(fibonacci_last_digit(1000)) # Output: 5 ``` Detailed Requirements: - Optimize the function to handle very large `n` efficiently. - Avoid calculating large Fibonacci numbers entirely, focus only on the last digit computation. - Implement adequate tests to validate your implementation, including edge cases, zero and very large `n`. Hint: Use properties of Fibonacci numbers modulo 10 (cycle every 60 numbers) to simplify calculations.","solution":"def fibonacci_last_digit(n): Returns the last digit of the nth Fibonacci number if n <= 1: return n previous, current = 0, 1 for _ in range(n - 1): previous, current = current, (previous + current) % 10 return current"},{"question":"# Problem Statement You are working on an application that needs to generate suggestions for usernames based on a given first name and last name. The goal is to create unique usernames that are easy to remember and follow a specific style. You will generate usernames by combining the first name, the last name, and a numeric suffix if necessary to ensure uniqueness. The rules for generating usernames are as follows: 1. Combine the first name and last name directly to form the base username. 2. If the base username is already taken, add a numeric suffix starting from 1, and increment it until the username is unique. 3. Usernames are case-insensitive (e.g., \\"JohnDoe\\" is the same as \\"johndoe\\"). 4. If multiple usernames are requested at once, ensure all generated usernames are unique within that batch as well. # Function Signature Write a function: ```python def generate_usernames(first_name: str, last_name: str, existing_usernames: list[str], num: int) -> list[str]: # Your implementation here ``` # Input and Output Input: * `first_name`: A string representing the first name. It will only contain alphabetical characters. * `last_name`: A string representing the last name. It will only contain alphabetical characters. * `existing_usernames`: A list of strings representing the usernames that are already taken in the system. All strings are alphanumeric and case-insensitive. * `num`: An integer representing the number of unique usernames to generate. Output: * A list of `num` unique strings representing the generated usernames. # Constraints - `first_name` and `last_name` will each have a length between 1 and 20. - The length of `existing_usernames` list will be between 0 and 1000. - `num` will be a positive integer between 1 and 100. - The combined length of `first_name` and `last_name` (plus possible numeric suffix) will not exceed 40 characters. # Examples ```python assert generate_usernames(\\"John\\", \\"Doe\\", [\\"JohnDoe\\", \\"johnDoe1\\", \\"JohnDoe2\\"], 3) == [\\"johnDoe3\\", \\"johnDoe4\\", \\"johnDoe5\\"] assert generate_usernames(\\"Jane\\", \\"Smith\\", [\\"janesmith\\", \\"janesmith1\\"], 2) == [\\"janesmith2\\", \\"janesmith3\\"] assert generate_usernames(\\"Emily\\", \\"Brown\\", [], 1) == [\\"emilybrown\\"] assert generate_usernames(\\"Alice\\", \\"Johnson\\", [\\"alicejohnson\\"], 1) == [\\"alicejohnson1\\"] assert generate_usernames(\\"Alice\\", \\"Johnson\\", [\\"AliceJohnson\\", \\"aliceJohnson1\\"], 1) == [\\"aliceJohnson2\\"] ``` # Notes Ensure the generated usernames follow the case-insensitivity rule and handle edge cases such as no existing usernames. Validity of input is to be assumed, no need for input validation checks.","solution":"def generate_usernames(first_name: str, last_name: str, existing_usernames: list[str], num: int) -> list[str]: generated_usernames = [] base_username = first_name.lower() + last_name.lower() existing_usernames_set = set(user.lower() for user in existing_usernames) suffix = 0 while len(generated_usernames) < num: username = base_username if suffix == 0 else f\\"{base_username}{suffix}\\" if username not in existing_usernames_set and username not in generated_usernames: generated_usernames.append(username) suffix += 1 return generated_usernames"},{"question":"Coding Assessment Question Context: Merge sort is a classic divide-and-conquer algorithm that efficiently sorts an array by recursively dividing it into two halves, sorting each half, and then merging the sorted halves. Your task is to implement the merge sort algorithm to sort an array of integers. Problem Statement: Implement the merge sort algorithm in Python. Your function should take an array of integers as input and return the array sorted in non-decreasing order. The algorithm should handle both positive and negative integers and ensure optimal performance. Function Signature: ```python def merge_sort(arr: list[int]) -> list[int]: pass ``` Input: - An array `arr` of integers where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9` for all `0 <= i < len(arr)`. Output: - A sorted array of integers in non-decreasing order. Constraints: - Ensure your solution is efficient and leverages the merge sort algorithm principles. - Handle edge cases such as an empty array or an array with a single element. Examples: ```python assert merge_sort([3, 6, 2, 7, 1, 5]) == [1, 2, 3, 5, 6, 7] assert merge_sort([-3, -1, -2, -7, -5, -6]) == [-7, -6, -5, -3, -2, -1] assert merge_sort([1]) == [1] assert merge_sort([]) == [] assert merge_sort([9, 9, 9, 9]) == [9, 9, 9, 9] assert merge_sort([-10, 0, 5, -3]) == [-10, -3, 0, 5] ``` Performance Requirements: - The implemented algorithm should have a time complexity of (O(n log n)).","solution":"def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: list[int], right: list[int]) -> list[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Problem Statement You are tasked with writing a function that processes log entries from a web server. The log file contains entries in a specified format, and the goal is to extract useful statistics from the logs. Your task: 1. **Implement parsing of log entries** to extract necessary components like IP address, timestamp, request method, URL, status code, and user agent. 2. **Calculate and return statistics** including: - Total number of requests - Number of successful requests (status code 200) - Number of client and server errors (status codes 4xx and 5xx) - Most common user agents Function Signature: ```python def process_web_server_logs( log_entries: list[str] ) -> dict: log_entries : list of str : List of log entries, each log is a string in a specific format ``` Guidelines: 1. **Log Entry Format**: Each log entry is a string in the following format: ``` [IP_ADDRESS] - - [TIMESTAMP] \\"REQUEST_METHOD URL HTTP_VERSION\\" STATUS_CODE BYTES_SENT \\"REFERRER\\" \\"USER_AGENT\\" ``` Example of a log entry: ``` 127.0.0.1 - - [12/Dec/2023:19:56:45 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 \\"-\\" \\"Mozilla/5.0\\" ``` 2. **Statistics Calculation**: - Total number of requests: Simply the count of log entries. - Successful requests: The count of entries where the status code is 200. - Client errors: The count of entries where the status code is in the 4xx range (400-499). - Server errors: The count of entries where the status code is in the 5xx range (500-599). - Most common user agents: A dictionary with user agents as keys and their occurrence counts as values. 3. **Return Format**: Return a dictionary containing the calculated statistics. ``` { \\"total_requests\\": int, \\"successful_requests\\": int, \\"client_errors\\": int, \\"server_errors\\": int, \\"most_common_user_agents\\": dict } ``` 4. **Edge Cases**: - Handle empty log entries gracefully. - Handle malformed log entries by skipping them. Example: ```python # Sample invocation logs = [ \'127.0.0.1 - - [12/Dec/2023:19:56:45 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 \\"-\\" \\"Mozilla/5.0\\"\', \'127.0.0.1 - - [12/Dec/2023:19:57:45 +0000] \\"POST /login HTTP/1.1\\" 404 512 \\"-\\" \\"Mozilla/5.0\\"\', \'127.0.0.1 - - [12/Dec/2023:19:58:45 +0000] \\"GET /dashboard HTTP/1.1\\" 500 2048 \\"-\\" \\"Mozilla/5.0\\"\', # More logs... ] result = process_web_server_logs(logs) # Expected output { \\"total_requests\\": 3, \\"successful_requests\\": 1, \\"client_errors\\": 1, \\"server_errors\\": 1, \\"most_common_user_agents\\": { \\"Mozilla/5.0\\": 3 } } ```","solution":"import re from collections import defaultdict def process_web_server_logs(log_entries): statistics = { \\"total_requests\\": 0, \\"successful_requests\\": 0, \\"client_errors\\": 0, \\"server_errors\\": 0, \\"most_common_user_agents\\": {} } user_agent_counts = defaultdict(int) log_pattern = re.compile( r\'(?P<ip>[d.]+) - - [(?P<timestamp>[^]]+)] \\"(?P<method>w+) (?P<url>[^ ]+) HTTP/[^\\"]+\\" (?P<status>d+) d+ \\"(?P<referrer>[^\\"]*)\\" \\"(?P<user_agent>[^\\"]*)\\"\' ) for entry in log_entries: match = log_pattern.match(entry) if not match: continue # Skip malformed entries statistics[\\"total_requests\\"] += 1 status_code = int(match.group(\'status\')) user_agent = match.group(\'user_agent\') user_agent_counts[user_agent] += 1 if status_code == 200: statistics[\\"successful_requests\\"] += 1 elif 400 <= status_code < 500: statistics[\\"client_errors\\"] += 1 elif 500 <= status_code < 600: statistics[\\"server_errors\\"] += 1 statistics[\\"most_common_user_agents\\"] = dict(user_agent_counts) return statistics"},{"question":"# Coding Assessment Question Question: You are building a function that determines if one string is a rotated version of another string. Two strings are considered rotated versions if they have the same characters in the same order but starting from a different index. Function Details: * **Function Name**: `is_rotated_version` * **Input**: * `s1`: A string * `s2`: A string * **Output**: A boolean value. It returns `True` if `s2` is a rotated version of `s1`, otherwise returns `False`. * **Constraints**: * Both input strings will always be non-empty and have lengths less than or equal to 100. * Both strings will only consist of lowercase alphabetic characters. Example: ```python >>> print(is_rotated_version(\\"abcde\\", \\"cdeab\\")) True >>> print(is_rotated_version(\\"abcde\\", \\"abced\\")) False >>> print(is_rotated_version(\\"aaaaa\\", \\"aaaaa\\")) True >>> print(is_rotated_version(\\"rotation\\", \\"tationro\\")) True >>> print(is_rotated_version(\\"rotation\\", \\"ationtor\\")) False ``` Consider edge cases such as identical strings and ensure your function can handle them correctly. Your solution should be efficient and avoid unnecessary computations.","solution":"def is_rotated_version(s1, s2): Determine if s2 is a rotated version of s1. :param s1: The original string. :param s2: The string to check if it is a rotated version of s1. :return: True if s2 is a rotated version of s1, False otherwise. # Strings must be the same length to be rotations of each other if len(s1) != len(s2): return False # Concatenate s1 with itself concatenated = s1 + s1 # Check if s2 is a substring of the concatenated result return s2 in concatenated"},{"question":"# Coding Assessment Question Scenario Graph traversals are fundamental in computer science for searching nodes in a graph and solving various problems like finding connected components, detecting cycles, and solving maze problems. Task Implement a Depth-First Search (DFS) algorithm in Python. Your implementation should include both recursive and iterative approaches. You will also need to handle edge cases such as disconnected graphs and cyclic graphs. Requirements 1. Implement a class `GraphDFS` that: - Initializes properties to represent the graph using an adjacency list. - Contains necessary methods for adding edges, performing recursive DFS, and performing iterative DFS using an explicit stack. 2. Ensure your implementation handles the following: - Correctly traverses connected components in disconnected graphs. - Detects cycles in the graph and identifies back edges. - Traverses all nodes starting from a given source node. 3. Demonstrate your implementation with the following cases: - Perform DFS on a graph with nodes `A`, `B`, `C`, `D` and edges `A-B`, `A-C`, `B-D`, `C-D`. - Detect a cycle in a graph with nodes `1`, `2`, `3`, `4` and edges `1-2`, `2-3`, `3-4`, `4-2`. Function Signature ```python class GraphDFS: def __init__(self): # Initialize the graph as an empty dictionary def add_edge(self, node1: str, node2: str): # Add an edge to the graph (both directions, as it\'s an undirected graph) def dfs_recursive(self, start: str) -> list: # Perform recursive DFS and return the order of visited nodes def dfs_iterative(self, start: str) -> list: # Perform iterative DFS with an explicit stack and return the order of visited nodes def detect_cycle(self, start: str) -> bool: # Detect if there is a cycle in the graph using back edge detection logic # Example usage graph = GraphDFS() graph.add_edge(\'A\', \'B\') graph.add_edge(\'A\', \'C\') graph.add_edge(\'B\', \'D\') graph.add_edge(\'C\', \'D\') print(graph.dfs_recursive(\'A\')) # Expected output: Order of nodes visited print(graph.dfs_iterative(\'A\')) # Expected output: Order of nodes visited cycle_graph = GraphDFS() cycle_graph.add_edge(\'1\', \'2\') cycle_graph.add_edge(\'2\', \'3\') cycle_graph.add_edge(\'3\', \'4\') cycle_graph.add_edge(\'4\', \'2\') print(cycle_graph.detect_cycle(\'1\')) # Expected output: True if there is a cycle ``` Input Format - Nodes and edges defined by the `add_edge` method. - Starting node for DFS operations and cycle detection. Output Format - List of nodes in the order they were visited for DFS operations. - Boolean value indicating presence of a cycle for cycle detection. Constraints - You may assume that the graph does not contain self-loops or multiple edges between the same pair of nodes. - The graph may contain up to `10^3` nodes and `10^4` edges. Performance Requirements - The implementation should efficiently handle graphs with multiple connected components and cycles.","solution":"class GraphDFS: def __init__(self): self.graph = {} def add_edge(self, node1: str, node2: str): if node1 not in self.graph: self.graph[node1] = [] if node2 not in self.graph: self.graph[node2] = [] self.graph[node1].append(node2) self.graph[node2].append(node1) def dfs_recursive(self, start: str, visited=None) -> list: if visited is None: visited = set() visited.add(start) result = [start] for neighbor in self.graph[start]: if neighbor not in visited: result.extend(self.dfs_recursive(neighbor, visited)) return result def dfs_iterative(self, start: str) -> list: visited = set() stack = [start] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) for neighbor in reversed(self.graph[node]): if neighbor not in visited: stack.append(neighbor) return result def detect_cycle(self, start: str) -> bool: def cycle_util(v, visited, parent): visited.add(v) for neighbor in self.graph[v]: if neighbor not in visited: if cycle_util(neighbor, visited, v): return True elif parent != neighbor: return True return False visited = set() for node in self.graph: if node not in visited: if cycle_util(node, visited, None): return True return False"},{"question":"# UniqueName Identifier You are tasked with implementing a function that generates unique user identifiers for a system. The unique identifier should consist of the user\'s name stripped of any spaces and converted to lowercase, followed by a sequence number to ensure uniqueness in cases where the name is the same. Function Signature ```python def generate_unique_name(names: List[str]) -> List[str]: ``` Expected Input and Output * **Input**: * `names` (List[str]): A list of full names in \\"First Last\\" format. * **Output**: * A list of unique user identifiers in the format \'nameN\' where \'name\' is the input name stripped of spaces and converted to lowercase, and \'N\' is a number to ensure uniqueness. Constraints * The length of the input list should be between 1 and 1000. * Each name in the input list will be a string of 1 to 50 characters long containing only alphabetical characters and a single space separating the first name and last name. Examples ```python assert generate_unique_name([\\"John Doe\\", \\"Jane Doe\\", \\"John Doe\\"]) == [\\"johndoe1\\", \\"janedoe1\\", \\"johndoe2\\"] assert generate_unique_name([\\"Alice Smith\\", \\"Bob Brown\\", \\"Alice Smith\\", \\"Charlie Clark\\", \\"Alice Smith\\"]) == [\\"alicesmith1\\", \\"bobbrown1\\", \\"alicesmith2\\", \\"charlieclark1\\", \\"alicesmith3\\"] assert generate_unique_name([\\"Ana Marie\\", \\"Ben Anne\\", \\"Ana Marie\\", \\"Ben Anne\\", \\"Ben Anne\\"]) == [\\"anamarie1\\", \\"benanne1\\", \\"anamarie2\\", \\"benanne2\\", \\"benanne3\\"] ``` Instructions 1. **Implement the function**: Implement the `generate_unique_name` function to generate unique identifiers as described. 2. **Uniqueness**: Ensure that identifiers are unique even with repeating names. 3. **String handling**: Properly handle string manipulations ensuring names are stripped of spaces and converted to lowercase before appending the sequence number. 4. **Validation**: Ensure that input constraints are validated and handled appropriately.","solution":"from typing import List from collections import defaultdict def generate_unique_name(names: List[str]) -> List[str]: name_count = defaultdict(int) unique_names = [] for name in names: clean_name = \'\'.join(name.lower().split()) name_count[clean_name] += 1 unique_name = f\\"{clean_name}{name_count[clean_name]}\\" unique_names.append(unique_name) return unique_names"},{"question":"# Coding Assessment Question Scenario You have been tasked with creating a solution to generate unique IDs for various entities within a system. The unique ID must be generated using a combination of alphanumeric characters and must adhere to certain rules based on an input pattern. Task Write a function that takes an input pattern composed of \'a\', \'d\', and \'#\', where \'a\' represents a random alphabetic character (either lowercase or uppercase), \'d\' represents a random digit (0-9), and \'#\' represents a random alphanumeric character (either a digit or an alphabetic character). Your function should generate a unique ID matching the input pattern. Function Signature ```python import random def generate_unique_id(pattern: str) -> str: ``` Input * A string `pattern` (1 ≤ len(pattern) ≤ 100) consisting of the characters \'a\', \'d\', and \'#\'. Output * A string representing the generated unique ID that matches the input pattern. Constraints * Each \'a\' in the pattern should be replaced with a random alphabetic character. * Each \'d\' in the pattern should be replaced with a random digit. * Each \'#\' in the pattern should be replaced with a random alphanumeric character. * Generated characters for \'a\', \'d\', and \'#\' must be chosen randomly. Example ```python assert len(generate_unique_id(\'a\')) == 1 and generate_unique_id(\'a\').isalpha() assert len(generate_unique_id(\'d\')) == 1 and generate_unique_id(\'d\').isdigit() assert (len(generate_unique_id(\'#\')) == 1 and generate_unique_id(\'#\').isalnum()) assert len(generate_unique_id(\'a#d\')) == 3 assert len(generate_unique_id(\'aaad#d\')) == 6 ``` Notes * Ensure your solution handles various patterns robustly and generates truly random characters as specified. * Utilize appropriate Python libraries and functions to generate random characters. * Consider performance implications when generating IDs for longer patterns.","solution":"import random import string def generate_unique_id(pattern: str) -> str: Generates a unique ID based on the input pattern. Parameters: pattern (str): The input pattern consisting of \'a\', \'d\', and \'#\'. Returns: str: A unique ID that matches the input pattern. result = [] for char in pattern: if char == \'a\': result.append(random.choice(string.ascii_letters)) elif char == \'d\': result.append(random.choice(string.digits)) elif char == \'#\': result.append(random.choice(string.ascii_letters + string.digits)) return \'\'.join(result)"},{"question":"# Coding Question: Implement a Simple Library System Context: You have been contracted by a local library that wishes to keep track of its books and their availability. Your task is to write a program that manages the inventory of books and process checkouts and returns. Objective: - Write a class `Library` that supports the following functionalities: - Adding a book with a title and author. - Checking out a book by title. - Returning a book by title. - Checking the availability of a book by title. Your class should handle cases where a book being checked out or returned does not exist in the library. Class Definition: You need to implement the following methods: - `add_book(title: str, author: str) -> None`: Adds a book with the given title and author to the library. - `check_out_book(title: str) -> str`: If the book is available, marks it as checked out and returns a success message. If the book is not available or does not exist, returns an appropriate error message. - `return_book(title: str) -> str`: If the book is in the system and checked out, marks it as available and returns a success message. If the book is not checked out or does not exist, returns an appropriate error message. - `is_book_available(title: str) -> bool`: Checks if the book is available for checkout. Input and Output: - **Input**: Function calls with appropriate parameters as specified. - **Output**: Strings representing success or error messages for checkouts and returns; Boolean value for availability status check. Constraints and Limitations: - Titles and authors will be non-empty strings. - The library system should only track each unique title once. If the same book title is added multiple times, it should not create duplicates. Examples: ```python >>> lib = Library() >>> lib.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") >>> lib.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") >>> lib.is_book_available(\\"The Great Gatsby\\") True >>> lib.check_out_book(\\"The Great Gatsby\\") \'The Great Gatsby checked out successfully.\' >>> lib.is_book_available(\\"The Great Gatsby\\") False >>> lib.check_out_book(\\"The Great Gatsby\\") \'The Great Gatsby is not available for checkout.\' >>> lib.return_book(\\"The Great Gatsby\\") \'The Great Gatsby returned successfully.\' >>> lib.is_book_available(\\"The Great Gatsby\\") True >>> lib.return_book(\\"The Catcher in the Rye\\") \'The Catcher in the Rye does not exist in the library.\' ``` Class Definition: ```python class Library: def __init__(self): pass def add_book(self, title: str, author: str) -> None: pass def check_out_book(self, title: str) -> str: pass def return_book(self, title: str) -> str: pass def is_book_available(self, title: str) -> bool: pass ```","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str, author: str) -> None: if title not in self.books: self.books[title] = {\'author\': author, \'available\': True} def check_out_book(self, title: str) -> str: if title not in self.books: return f\\"{title} does not exist in the library.\\" if not self.books[title][\'available\']: return f\\"{title} is not available for checkout.\\" self.books[title][\'available\'] = False return f\\"{title} checked out successfully.\\" def return_book(self, title: str) -> str: if title not in self.books: return f\\"{title} does not exist in the library.\\" if self.books[title][\'available\']: return f\\"{title} was not checked out.\\" self.books[title][\'available\'] = True return f\\"{title} returned successfully.\\" def is_book_available(self, title: str) -> bool: if title not in self.books: return False return self.books[title][\'available\']"},{"question":"# Graph Shortest Path - Dijkstra\'s Algorithm Background: Dijkstra\'s Algorithm is a well-known algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. Given a graph with weighted edges, the task is to implement Dijkstra\'s Algorithm to compute the shortest path from a source node to all other nodes in the graph. Task: 1. **Graph Representation**: Represent the graph using an adjacency list. 2. **Implement Dijkstra\'s Algorithm**: Write a function that takes the graph, a source node, and finds the shortest path from that source node to all other nodes in the graph. Function Signature: 1. `dijkstra(graph: dict[int, list[tuple[int, float]]], start_node: int) -> dict[int, float]` * **Input**: * `graph` - A dictionary representing the adjacency list of the graph. The keys are node identifiers (integers), and the values are lists of tuples, where each tuple represents a neighboring node and the edge weight to that neighbor. * `start_node` - The source node from which to calculate the shortest paths. * **Output**: * A dictionary where the keys are node identifiers and the values are the shortest path distances from the `start_node` to that node. Constraints: * The graph is assumed to have non-negative edge weights. * The number of nodes `n` in the graph is moderately large (e.g., n < 10^5). * The number of edges `e` is such that `e` < 2 * 10^5. Example: ```python # Example graph represented as an adjacency list graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start_node = 0 shortest_paths = dijkstra(graph, start_node) print(shortest_paths) # Output should be {0: 0, 1: 3, 2: 1, 3: 4} ``` Notes: * You are required to implement the `dijkstra` function. * Ensure that your algorithm properly handles graphs with no edges and disconnected components. * Maintain clarity and efficiency in your implementation, considering the constraints on the number of nodes and edges.","solution":"import heapq def dijkstra(graph, start_node): Implements Dijkstra\'s algorithm to find the shortest path from start_node to all other nodes in the graph. :param graph: dict, representing the adjacency list, where keys are node identifiers, and values are lists of tuples (neighbor, weight). :param start_node: int, the source node to calculate shortest paths from. :return: dict, where keys are nodes and values are the shortest path distances from start_node to that node. # Initialize distances with infinity distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to hold nodes to visit priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance in the priority queue is greater than the currently known distance, skip it if current_distance > distances[current_node]: continue # Iterate over neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question: Median Finder for Streaming Integers Design a class `MedianFinder` to compute the median of a streaming sequence of integers. The class should support the following methods: - `addNum(num: int) -> None`: Adds a number to the data structure. - `findMedian() -> float`: Returns the median of all elements so far. The class should efficiently handle adding large number of integers and fetching the median in constant time. Constraints: - All integers are in the range `[-10^5, 10^5]`. - There will be at least one element before calling `findMedian`. - The number of `addNum` operations will not exceed (10^6). Example: ```python >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2.0 ``` Implementation: Provide the implementation for managing the insertion and median calculation efficiently. Ensure the solution handles large volumes of data within acceptable performance limits. ```python import heapq class MedianFinder: def __init__(self): self.small = [] # max heap (implemented as min heap with negative values) self.large = [] # min heap def addNum(self, num: int) -> None: heapq.heappush(self.small, -num) if self.small and self.large and (-self.small[0] > self.large[0]): val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.small) > len(self.large) + 1: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.large) > len(self.small): val = heapq.heappop(self.large) heapq.heappush(self.small, -val) def findMedian(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2 # Example use mf = MedianFinder() mf.addNum(1) mf.addNum(2) print(mf.findMedian()) # Output: 1.5 mf.addNum(3) print(mf.findMedian()) # Output: 2.0 ```","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # max heap (implemented as min heap with negative values) self.large = [] # min heap def addNum(self, num: int) -> None: heapq.heappush(self.small, -num) if self.small and self.large and (-self.small[0] > self.large[0]): val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.small) > len(self.large) + 1: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.large) > len(self.small): val = heapq.heappop(self.large) heapq.heappush(self.small, -val) def findMedian(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2"},{"question":"# Problem Statement Write a function `matrix_diagonal_sum` that calculates the sum of the diagonals in a square matrix. The function should take one argument, a list of lists representing the matrix, and return the sum of the elements on both the primary and secondary diagonals. If an element is on both diagonals (i.e., in the center of an odd-length matrix), it should not be counted twice. # Requirements * The function should raise a ValueError with the message \\"Input must be a square matrix\\" if the input is not a square matrix. * The function should raise a ValueError with the message \\"Matrix must not be empty\\" if the input matrix is empty or has no rows. * The function must handle matrices of various sizes efficiently. # Input * A list of lists representing a square matrix `matrix` where each nested list is a row of the matrix. # Output * An integer value representing the sum of the elements on both the primary and secondary diagonals. # Function Signature ```python def matrix_diagonal_sum(matrix: list[list[int]]) -> int: pass ``` # Example ```python >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 # 1 + 5 + 9 + 3 + 7 >>> matrix_diagonal_sum([[1, 2], [3, 4]]) 10 # 1 + 4 + 2 + 3 >>> matrix_diagonal_sum([[1]]) 1 # 1 >>> matrix_diagonal_sum([[]]) Traceback (most recent call last): ... ValueError: Matrix must not be empty >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Input must be a square matrix ``` # Constraints * The matrix will have dimensions at most 1000 x 1000. * Each element in the matrix is an integer, and the sum of the diagonals will fit within standard integer limits.","solution":"def matrix_diagonal_sum(matrix): Calculate the sum of the diagonals in a square matrix. If an element is on both diagonals, it is not counted twice. if not matrix or not matrix[0]: raise ValueError(\\"Matrix must not be empty\\") n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Input must be a square matrix\\") diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] # primary diagonal diagonal_sum += matrix[i][n - 1 - i] # secondary diagonal # If the matrix has an odd length, subtract the center element once if n % 2 == 1: center = n // 2 diagonal_sum -= matrix[center][center] return diagonal_sum"},{"question":"Problem Statement Design a function that, given multiple machines with various available intervals and a list of jobs with specific start and end times, determines if all the jobs can be scheduled within the given intervals of the machines. Each job can be scheduled on any machine, but a machine can only handle one job at a time. # Function Signature ```python def can_schedule_jobs(machine_intervals: list, job_intervals: list) -> bool: Determine if all jobs can be scheduled within the given machine intervals. Parameters: - machine_intervals (list): List of tuples, where each tuple contains two integers representing the start and end time of a machine\'s available interval. - job_intervals (list): List of tuples, where each tuple contains two integers representing the start and end time of a job\'s required interval. Returns: - bool: True if all jobs can be scheduled, False otherwise. ``` # Input 1. `machine_intervals`: List of tuples of integers, where each tuple `(a, b)` represents the start and end time of a machine\'s available interval. 2. `job_intervals`: List of tuples of integers, where each tuple `(c, d)` represents the start and end time of a job\'s required interval. # Output - A boolean value: - `True` if all jobs can be scheduled within the machine intervals. - `False` otherwise. # Constraints - The length of `machine_intervals` and `job_intervals` will be between 1 and 1000. - The start and end times are non-negative integers. - The job intervals are guaranteed to fit within the machine intervals\' outer bounds. # Examples ```python >>> can_schedule_jobs([(1, 4), (2, 5), (6, 10)], [(1, 3), (2, 3), (6, 8)]) True >>> can_schedule_jobs([(1, 3), (2, 5)], [(3, 5), (4, 6)]) False >>> can_schedule_jobs([(0, 10)], [(2, 3), (5, 8)]) True ``` # Note - Your implementation should consider the constraints and efficiently process the intervals to determine if a feasible schedule exists. - Ensure that the intervals are handled correctly without overlapping on the same machine beyond its capacity. # Evaluation Your submission will be evaluated based on: - Correctness of determining whether all jobs can be scheduled. - Efficiency of the algorithm, considering the given constraints. - Robustness in handling edge cases and different configurations of intervals. - Code readability and adherence to the specified function signature.","solution":"def can_schedule_jobs(machine_intervals, job_intervals): Determine if all jobs can be scheduled within the given machine intervals. Parameters: - machine_intervals (list): List of tuples, where each tuple contains two integers representing the start and end time of a machine\'s available interval. - job_intervals (list): List of tuples, where each tuple contains two integers representing the start and end time of a job\'s required interval. Returns: - bool: True if all jobs can be scheduled, False otherwise. # Sort the machine intervals and job intervals by their start times for easier scheduling machine_intervals.sort() job_intervals.sort() # Index to keep track of which machine interval we are trying to place jobs into machine_index = 0 for job in job_intervals: job_start, job_end = job job_scheduled = False while machine_index < len(machine_intervals): machine_start, machine_end = machine_intervals[machine_index] # Check if the current machine can accommodate this job if machine_start <= job_start and job_end <= machine_end: # Move to the next machine for the next job machine_intervals[machine_index] = (job_end, machine_end) job_scheduled = True break else: # Move to the next machine machine_index += 1 if not job_scheduled: return False return True"},{"question":"# Scenario You are tasked to design a system for processing and transforming sequences of numbers, which is a common requirement in data analysis and signal processing contexts. This function will help you practice your skills in manipulating lists and implementing algorithms. # Problem Statement Create a function `smooth_sequence(arr: List[int]) -> List[float]` that computes the moving average of a given list of integers `arr`. The moving average for an element at index `i` is defined by the average of the elements from `arr[i-1]`, `arr[i]`, and `arr[i+1]`. For the first and last elements, consider only two elements for the average. # Function Signature ```python def smooth_sequence(arr: List[int]) -> List[float]: pass ``` # Input Constraints - `1 <= len(arr) <= 100000` - `-1000 <= arr[i] <= 1000` for any `i` # Output - A list of floating-point numbers representing the moving average of the input list. # Example ```python assert smooth_sequence([1, 3, 5, 7, 9]) == [2.0, 3.0, 5.0, 7.0, 8.0] assert smooth_sequence([10, 20, 30]) == [15.0, 20.0, 25.0] assert smooth_sequence([1]) == [1.0] ``` # Notes - **Edge Cases**: - Lists with a single element. - Lists with very large numbers of elements. - Handling integer calculations and float division correctly to ensure precise outputs. # Performance Requirements The solution should efficiently handle the given constraints, especially for the upper limit of the list size.","solution":"from typing import List def smooth_sequence(arr: List[int]) -> List[float]: Computes the moving average of the input list of integers. if len(arr) == 1: return [float(arr[0])] result = [] for i in range(len(arr)): if i == 0: avg = (arr[i] + arr[i + 1]) / 2 elif i == len(arr) - 1: avg = (arr[i] + arr[i - 1]) / 2 else: avg = (arr[i - 1] + arr[i] + arr[i + 1]) / 3 result.append(avg) return result"},{"question":"# **Coding Challenge: Find the Missing Number in Duplicate Array** Context You have been given two arrays of integers. The first array `arr1` contains `n` unique integers ranging from 1 to `n`. The second array `arr2` is derived from the first array but is missing exactly one integer. Your task is to identify the missing integer in the second array. Task Implement a function that finds and returns the missing number in the second array. Input and Output Formats **Input**: 1. Two lists of integers, `arr1` and `arr2`. ``` Example: arr1 = [4, 3, 2, 7, 8, 1, 6, 5] arr2 = [4, 3, 2, 7, 8, 1, 6] ``` **Output**: 1. A single integer which is the missing number from `arr2`. Requirements 1. **Function Signature**: ```python def find_missing_number(arr1: List[int], arr2: List[int]) -> int: # find and return the missing number pass ``` 2. **Constraints**: * The length of `arr1` will be `n` where `1 <= n <= 10^5`. * The length of `arr2` will be `n-1`. * All integers in the input arrays are unique and within the range `[1, n]`. Example ```python # Input arr1 = [4, 3, 2, 7, 8, 1, 6, 5] arr2 = [4, 3, 2, 7, 8, 1, 6] # Output 5 ``` **Note:** Your solution should efficiently handle large input sizes, adhering to the constraints provided.","solution":"def find_missing_number(arr1, arr2): Finds the missing number in arr2 which is derived from arr1 but with one number missing. :param arr1: List[int] - The original array of unique integers ranging from 1 to n. :param arr2: List[int] - The array derived from arr1 but with one integer missing. :return: int - The missing integer. return sum(arr1) - sum(arr2)"},{"question":"# Isotope Half-Life Calculation You are tasked with calculating the remaining quantity of a radioactive isotope after a certain time period, given its half-life. The decay of the radioactive isotope follows an exponential decay formula: [ N(t) = N_0 cdot e^{-lambda t} ] Where: - ( N(t) ) is the remaining quantity of the isotope after time ( t ). - ( N_0 ) is the initial quantity of the isotope. - ( lambda ) is the decay constant, which is related to the half-life (( T_{1/2} )) by the formula (lambda = frac{ln(2)}{T_{1/2}}). - ( t ) is the time period over which the decay is observed. Write a function `remaining_isotope_quantity` that computes the remaining quantity of the isotope. The function should raise a `ValueError` if any of the input parameters are not positive. Function Signature ```python def remaining_isotope_quantity( initial_quantity: float, half_life: float, time_period: float, ) -> float: ... ``` Input - `initial_quantity` (float): The initial quantity of the isotope. - `half_life` (float): The half-life of the isotope. - `time_period` (float): The time period over which the decay is observed. Output - `float`: The remaining quantity of the isotope after the specified time period. Constraints - All input parameters must be positive. Example ```python >>> remaining_isotope_quantity(1000, 5730, 5730) 500.0 >>> remaining_isotope_quantity(1000, 5730, 11460) 250.0 >>> remaining_isotope_quantity(1000, 5730, 2865) 707.1067811865476 ``` Error Handling ```python >>> remaining_isotope_quantity(1000, -5730, 5730) Traceback (most recent call last): ... ValueError: All parameters must be positive. ```","solution":"import math def remaining_isotope_quantity(initial_quantity: float, half_life: float, time_period: float) -> float: Calculates the remaining quantity of a radioactive isotope after a given time period. :param initial_quantity: Initial quantity of the isotope :param half_life: Half-life of the isotope :param time_period: Time period over which the decay is observed :return: Remaining quantity of the isotope :raises ValueError: If any of the input parameters are not positive if initial_quantity <= 0 or half_life <= 0 or time_period <= 0: raise ValueError(\\"All parameters must be positive.\\") # Decay constant decay_constant = math.log(2) / half_life # Remaining quantity remaining_quantity = initial_quantity * math.exp(-decay_constant * time_period) return remaining_quantity"},{"question":"# Odd Characters Removal Context Handling strings and manipulating text data is a fundamental programming skill. In this task, you will develop functions to manipulate strings by removing certain characters based on their positions. You are required to implement functions that: 1. Remove characters from odd positions in a string (considering the first character is at position 0). 2. Remove characters from even positions in a string. 3. Validate that the input is a string and handle invalid inputs appropriately. Tasks 1. **Implement the `remove_odd_positions` function**: - **Input**: A string. - **Output**: A string with all characters at odd positions removed. 2. **Implement the `remove_even_positions` function**: - **Input**: A string. - **Output**: A string with all characters at even positions removed. 3. **Implement the `validate_string` function**: - **Input**: An input value. - **Output**: The input value as a string if it\'s a valid string. Raise a ValueError if the input is not a string. Example ```python # remove_odd_positions examples print(remove_odd_positions(\\"hello\\")) # should return \\"hlo\\" print(remove_odd_positions(\\"123456\\")) # should return \\"135\\" # remove_even_positions examples print(remove_even_positions(\\"hello\\")) # should return \\"el\\" print(remove_even_positions(\\"123456\\")) # should return \\"246\\" # validate_string examples print(validate_string(\\"test\\")) # should return \\"test\\" print(validate_string(123)) # should raise ValueError print(validate_string([\\"a\\", \\"b\\"])) # should raise ValueError ``` **Constraints**: 1. The input string should handle Unicode characters appropriately. 2. Ensure that the implementation can handle edge cases like empty strings or very short strings. 3. The input validation function should strictly check the data type. **Performance Requirement**: Your solution should be efficient with typical string lengths. Performance optimization for extremely large strings is not essential given typical use cases.","solution":"def remove_odd_positions(s): Remove characters from odd positions in the string. Args: s (str): Input string. Returns: str: String with characters at odd positions removed. return s[::2] def remove_even_positions(s): Remove characters from even positions in the string. Args: s (str): Input string. Returns: str: String with characters at even positions removed. return s[1::2] def validate_string(input): Validate that the input is a string. Args: input: The input to be validated. Returns: str: The input if it is a string. Raises: ValueError: If the input is not a string. if not isinstance(input, str): raise ValueError(\\"Input must be a string\\") return input"},{"question":"# Objective You have to implement a function that converts a given integer into its Roman numeral representation. # Problem Statement Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | For example, `2` is written as `II` in Roman numeral, just two one\'s added together. `12` is written as `XII`, which is simply `X` + `II`. The number `27` is written as `XXVII`, which is `XX` + `V` + `II`. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five, we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used: - `I` can be placed before `V` (5) and `X` (10) to make `4` and `9`. - `X` can be placed before `L` (50) and `C` (100) to make `40` and `90`. - `C` can be placed before `D` (500) and `M` (1000) to make `400` and `900`. Given an integer, convert it to a Roman numeral. # Function Signature ```python def int_to_roman(num: int) -> str: pass ``` # Input * `num` (int): An integer between 1 and 3999 inclusive. # Output * Return the Roman numeral representation of the integer as a string. # Constraints * `1 <= num <= 3999` # Example Example 1: * **Input**: `num = 3` * **Output**: `\\"III\\"` Example 2: * **Input**: `num = 4` * **Output**: `\\"IV\\"` Example 3: * **Input**: `num = 9` * **Output**: `\\"IX\\"` Example 4: * **Input**: `num = 58` * **Explanation**: `L = 50`, `VIII = 8` * **Output**: `\\"LVIII\\"` Example 5: * **Input**: `num = 1994` * **Explanation**: `M = 1000`, `CM = 900`, `XC = 90`, `IV = 4` * **Output**: `\\"MCMXCIV\\"` # Additional Notes * Efficiently handle the conversion by implementing a direct lookup or fixed logic for Roman numeral rules. * Ensure the function handles edge cases like the smallest (1) and largest number (3999). * Include validation for the input range to guarantee correct outputs within the specified constraints.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. value_map = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman = [] for value, symbol in value_map: while num >= value: roman.append(symbol) num -= value return \\"\\".join(roman)"},{"question":"# Matrix Rotation by 90 Degrees Given an `n x n` 2D matrix representing an image, write a **function** `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` to rotate the image by 90 degrees (clockwise). # Input and Output Format - **Input**: - `matrix`: A list of `n` lists, each containing `n` integers. - **Output**: A list of `n` lists, representing the 90-degree clockwise rotated matrix. # Constraints - The matrix is guaranteed to be square (`n x n`). # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix)) ``` **Expected Output:** ```plaintext [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Additional Information - Consider the most optimal approach in terms of both time and space complexity. - Ensure the function handles edge cases, such as a matrix with only one element.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise. # Get the size of the matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Problem Statement You are tasked with implementing a simple spell checker that identifies and suggests corrections to misspelled words in a given sentence, using a provided list of valid words. The suggestions should be words from the list that are closest to the misspelled word, with \\"closeness\\" defined by the minimum Levenshtein distance. # Function Signatures - Implement the function `check_spelling(sentence: str, dictionary: List[str]) -> Dict[str, List[str]]`. This function will: - Take a string `sentence` and a list of strings `dictionary` as input. - Return a dictionary where: - The keys are the misspelled words in the given sentence. - The values are lists containing the closest valid words from the dictionary. ```python def check_spelling(sentence: str, dictionary: List[str]) -> Dict[str, List[str]]: pass ``` # Input and Output Input 1. `sentence` (str): A sentence containing words separated by spaces. Constraints: `1 ≤ len(sentence) ≤ 1000`. 2. `dictionary` (List[str]): A list of valid words. Constraints: `1 ≤ len(dictionary) ≤ 1000`, each word `1 ≤ len(word) ≤ 100`. Output 1. A dictionary where: - Keys are misspelled words identified in the input sentence. - Values are lists containing the closest valid words from the dictionary in terms of Levenshtein distance. # Example 1. `check_spelling(\\"Ths is a simpl sentence\\", [\\"This\\", \\"is\\", \\"a\\", \\"simple\\", \\"sentence\\"])` - Returns: `{\'Ths\': [\'This\'], \'simpl\': [\'simple\']}` 2. `check_spelling(\\"I hav a dreem\\", [\\"I\\", \\"have\\", \\"a\\", \\"dream\\"])` - Returns: `{\'hav\': [\'have\'], \'dreem\': [\'dream\']}` # Constraints - Words in the `sentence` should be considered case insensitive, but suggestions should preserve the original case of the valid words from the dictionary. - You must handle edge cases, such as punctuation marks and multiple spaces between words, appropriately. - Ensure your solution is efficient and handles the input constraints effectively. # Notes - Practice optimizing the calculation of Levenshtein distance for this problem. - Pay careful attention to punctuation marks and handle them correctly while analyzing the sentence.","solution":"from typing import List, Dict import re def levenshtein_distance(s1: str, s2: str) -> int: Compute the Levenshtein distance between two strings s1 and s2. if len(s1) < len(s2): return levenshtein_distance(s2, s1) if len(s2) == 0: return len(s1) previous_row = range(len(s2) + 1) for i, c1 in enumerate(s1): current_row = [i + 1] for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def check_spelling(sentence: str, dictionary: List[str]) -> Dict[str, List[str]]: Identifies and suggests corrections to misspelled words in a given sentence. words = re.findall(r\'bw+b\', sentence) cleaned_words = [word.lower() for word in words] dictionary_lower = [word.lower() for word in dictionary] corrections = {} for i, word in enumerate(cleaned_words): if word not in dictionary_lower: distances = {dict_word: levenshtein_distance(word, dict_word.lower()) for dict_word in dictionary} min_distance = min(distances.values()) closest_words = [w for w, d in distances.items() if d == min_distance] corrections[words[i]] = closest_words return corrections"},{"question":"# Sum of Prime Digits **Problem Statement**: Write a function `sum_prime_digits` that takes an integer and returns the sum of its digits that are prime numbers. **Input**: * An integer `n` which may be positive or negative. **Output**: * An integer representing the sum of the digits of `n` that are prime numbers. **Constraints**: * The integer `n` can be any 32-bit signed integer. * Only the digits 2, 3, 5, and 7 are considered prime. **Function Signature**: ```python def sum_prime_digits(n: int) -> int: ``` **Example**: ```python # The digits of the number 2371 are 2, 3, 7, and 1. # Prime digits among them are 2, 3, and 7. # The sum of prime digits is 2 + 3 + 7 = 12 print(sum_prime_digits(2371)) # Output: 12 # The digits of the number -34952 are 3, 4, 9, 5, and 2. # Prime digits among them are 3, 5, and 2. # The sum of prime digits is 3 + 5 + 2 = 10 print(sum_prime_digits(-34952)) # Output: 10 # The digits of the number 466 are 4, 6, and 6. # There are no prime digits. # The sum of prime digits is 0 print(sum_prime_digits(466)) # Output: 0 ``` # Solution Requirements: 1. Implement a helper function to determine if a digit is prime. 2. Use a loop to iterate through each digit of the input number. 3. Accumulate the sum of digits that pass the prime check. 4. Ensure correct handling of negative integers by considering only the absolute value of the digits.","solution":"def sum_prime_digits(n: int) -> int: Returns the sum of the digits of n that are prime. def is_prime_digit(digit: int) -> bool: # Define prime digits return digit in [2, 3, 5, 7] # Convert number to string to handle digits digits = str(abs(n)) prime_sum = 0 for digit in digits: if is_prime_digit(int(digit)): prime_sum += int(digit) return prime_sum"},{"question":"# Determinant Calculation in a Matrix Scenario Matrices are a fundamental aspect of linear algebra and have numerous applications in computer graphics, cryptography, and more. One crucial operation in matrix mathematics is the calculation of the determinant. Your task is to implement a function that computes the determinant of a square matrix. Function Signature ```python def matrix_determinant(matrix: list[list[float]]) -> float: matrix is a two-dimensional list (n x n) where matrix[i][j] represents the element at the ith row and jth column. ``` Input * **matrix**: A two-dimensional list of floats, representing a square matrix (n x n) where each element matrix[i][j] corresponds to an element in the ith row and jth column of the matrix. Output * A float representing the determinant of the matrix. Constraints 1. The size of the matrix (n) will not exceed 10. 2. Elements of the matrix can be positive, negative, or zero. 3. You must handle edge cases, such as matrices with zero rows/elements and invalid inputs. Example ```python >>> matrix_determinant([[1, 2], [3, 4]]) -2.0 >>> matrix_determinant([[1, 0, 2], [0, 1, 0], [-1, 0, 1]]) 3.0 ``` Requirements 1. Validate the input to ensure it is a square matrix. 2. Utilize an efficient algorithm, such as Gaussian Elimination or Laplace expansion, to compute the determinant. 3. Ensure numerical stability and precision in the calculations. 4. Make sure to handle special cases like singular matrices (determinant equals zero) and edge cases like empty matrices appropriately.","solution":"def matrix_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a square matrix. # Validate input: make sure the matrix is not empty and is square if not matrix: raise ValueError(\\"The matrix should not be empty.\\") num_rows = len(matrix) if not all(len(row) == num_rows for row in matrix): raise ValueError(\\"The matrix must be square (n x n).\\") # Base case: Single element matrix if num_rows == 1: return matrix[0][0] # Base case: 2x2 matrix if num_rows == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 # Recursive case: Expand along the first row for col in range(num_rows): sub_matrix = [row[:col] + row[col+1:] for row in matrix[1:]] sign = (-1) ** col sub_determinant = matrix_determinant(sub_matrix) determinant += sign * matrix[0][col] * sub_determinant return determinant"},{"question":"# Coding Assessment Question Tree Node Depth Calculation You are provided with the structure of a binary tree and a task to calculate the depth (or height) of the tree. Each node in the tree can have left and right children, which can either be another node or exclude further branches by being `None`. # Problem Statement Function: `calculate_tree_depth` Write a function `calculate_tree_depth` that: - Takes as input a binary tree node. - Returns an integer representing the depth of the binary tree. - The depth of an empty tree (represented by `None`) is 0, while the depth of a tree with only one node (a root node) is 1. Constraints: 1. The input tree node will be of a class `TreeNode` with the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` 2. The depth is defined as the number of nodes along the longest path from the root node to the farthest leaf node. Specifications: - Input: An instance of `TreeNode` representing the root of a binary tree. - Output: An integer representing the depth of the binary tree. Example Scenario Given the binary tree: ``` 3 / 9 20 / 15 7 ``` The tree is represented as follows: ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) ``` The depth of the tree given above is 3. Example function call: ```python depth = calculate_tree_depth(root) print(depth) # Output should be 3 ``` Note: Consider edge cases where: - The tree is empty. - The tree is a straight line (like a linked list). The function `calculate_tree_depth` should correctly calculate the depth regardless of the binary tree\'s specific structure. Write your implementation in a function `calculate_tree_depth` using either a recursive or iterative approach.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def calculate_tree_depth(root): Calculate the depth of a binary tree. :param root: TreeNode or None :return: int if root is None: return 0 else: left_depth = calculate_tree_depth(root.left) right_depth = calculate_tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Coding Assessment Question **Scenario**: As a data scientist, you often work with raw datasets, which include numerous numeric values. These values can frequently be unstructured, and you need a way to easily categorize them based on certain criteria. One common categorization is to determine if a number is considered \\"small\\", \\"medium\\", or \\"large\\". **Task**: Write a function `categorize_number` that: - Takes a single argument, `num`, which is a numeric value (either an integer or a float). If `num` is not an integer or float, a `TypeError` should be raised. - Returns a string based on the value of `num`: - Returns `\'small\'` if `num` is less than 10. - Returns `\'medium\'` if `num` is between 10 and 100 (inclusive). - Returns `\'large\'` if `num` is greater than 100. **Input**: - A single value, `num`, which can be an integer or a float. **Output**: - A string, `\'small\'`, `\'medium\'`, or `\'large\'`, depending on the value of `num`. **Constraints**: - You should not use any external libraries. - Your function should have a time complexity of O(1). - Handle edge cases such as very large or very small floating-point numbers. **Function Signature**: ```python def categorize_number(num: float) -> str: ``` **Examples**: ```python categorize_number(5) # Expected output: \'small\' categorize_number(10) # Expected output: \'medium\' categorize_number(50) # Expected output: \'medium\' categorize_number(100) # Expected output: \'medium\' categorize_number(150) # Expected output: \'large\' categorize_number(-5) # Expected output: \'small\' categorize_number(1e-6) # Expected output: \'small\' categorize_number(1e3) # Expected output: \'large\' categorize_number(\\"Test\\") # Expected output: TypeError categorize_number([1, 2, 3]) # Expected output: TypeError ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring correct categorization and appropriate error handling.","solution":"def categorize_number(num): Categorizes a numeric value. Parameters: num (int, float): The numeric value to categorize. Returns: str: A string representing the category of the number (\'small\', \'medium\', or \'large\'). Raises: TypeError: If num is not an int or float. if not isinstance(num, (int, float)): raise TypeError(\\"num must be an int or float\\") if num < 10: return \'small\' elif 10 <= num <= 100: return \'medium\' else: return \'large\'"},{"question":"# Problem Statement You are developing an application that handles the management of students\' scores in various subjects. One of the tasks is to compute the average scores for students across all subjects and determine their overall performance category based on the average score. Your task is to implement a function that takes a list of students\' names, a list of subjects, and a dictionary where each key is a student\'s name and the corresponding value is another dictionary containing subjects as keys and the scores as values. The function should return a dictionary where each key is a student\'s name and the corresponding value is their average score and performance category. The performance categories are as follows: - \\"Excellent\\" for an average score of 90 and above. - \\"Good\\" for an average score between 75 and 89. - \\"Average\\" for an average score between 50 and 74. - \\"Poor\\" for an average score below 50. # Function Signature ```python def calculate_performance( students: List[str], subjects: List[str], scores: Dict[str, Dict[str, int]] ) -> Dict[str, Tuple[float, str]]: pass ``` # Input * A list of strings `students` — names of the students. * A list of strings `subjects` — names of the subjects. * A dictionary `scores` — mapping students\' names to dictionaries, which map subjects to scores. # Output * A dictionary where the keys are students\' names and values are tuples of the average score (float) and performance category (str). # Constraints * All student names and subject names are unique. * Each student has exactly one score per subject. * Scores are integers between 0 and 100, inclusive. * The length of `students` and `subjects` is at most 1000. # Examples ```python >>> students = [\\"Alice\\", \\"Bob\\"] >>> subjects = [\\"Math\\", \\"Science\\"] >>> scores = { ... \\"Alice\\": {\\"Math\\": 95, \\"Science\\": 85}, ... \\"Bob\\": {\\"Math\\": 70, \\"Science\\": 75} ... } >>> calculate_performance(students, subjects, scores) { \\"Alice\\": (90.0, \\"Excellent\\"), \\"Bob\\": (72.5, \\"Average\\") } >>> students = [\\"Carol\\"] >>> subjects = [\\"History\\", \\"Geography\\"] >>> scores = { ... \\"Carol\\": {\\"History\\": 100, \\"Geography\\": 90} ... } >>> calculate_performance(students, subjects, scores) { \\"Carol\\": (95.0, \\"Excellent\\") } >>> students = [\\"Dave\\"] >>> subjects = [\\"Physics\\"] >>> scores = {\\"Dave\\": {\\"Physics\\": 45}} >>> calculate_performance(students, subjects, scores) { \\"Dave\\": (45.0, \\"Poor\\") } ``` # Notes 1. Each student will have scores for all subjects listed in the `subjects` list. 2. You can assume that there are no missing or additional subjects for any student in the `scores` dictionary. 3. Focus on the clarity and efficiency of your solution.","solution":"from typing import List, Dict, Tuple def calculate_performance( students: List[str], subjects: List[str], scores: Dict[str, Dict[str, int]] ) -> Dict[str, Tuple[float, str]]: def get_category(avg_score): if avg_score >= 90: return \\"Excellent\\" elif avg_score >= 75: return \\"Good\\" elif avg_score >= 50: return \\"Average\\" else: return \\"Poor\\" performance = {} for student in students: total_score = sum(scores[student][subject] for subject in subjects) avg_score = total_score / len(subjects) category = get_category(avg_score) performance[student] = (avg_score, category) return performance"},{"question":"# Problem Statement You are given a list of `n` integers representing an array. Your task is to process `q` range sum queries using a Segment Tree. Each query specifies a range `[l, r]`, and you need to return the sum of the elements in that range from the array, inclusive. Input Format 1. An integer `n` representing the number of elements in the array. 2. A list of `n` integers representing the elements of the array. 3. An integer `q` representing the number of range sum queries. 4. `q` pairs of integers `(l, r)` representing the range (0-based) for which the sum needs to be found. Output Format Print `q` integers, each representing the sum of the elements in the corresponding range `(l, r)`. Constraints - (1 leq n leq 10^5) - (1 leq q leq 10^5) - (-10^9 leq text{array}[i] leq 10^9) - (0 leq l leq r < n) Example **Input** ``` 5 1 2 3 4 5 3 0 2 1 3 2 4 ``` **Output** ``` 6 9 12 ``` Task Implement the following function: ```python def range_sums(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: # Your implementation here ``` In this function, `n` is the number of elements in the array, `arr` is the list of `n` elements, and `queries` is the list of `q` range sum queries. **Performance Notes**: - Ensure that the Segment Tree construction is efficient. - Ensure that each query is answered in logarithmic time.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the tree self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize the rest of the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def query(self, l, r): l += self.n r += self.n + 1 result = 0 while l < r: if l & 1: result += self.tree[l] l += 1 if r & 1: r -= 1 result += self.tree[r] l >>= 1 r >>= 1 return result def range_sums(n, arr, queries): seg_tree = SegmentTree(arr) return [seg_tree.query(l, r) for l, r in queries]"},{"question":"# Problem Statement You need to implement the Quick Sort algorithm to sort a list of integers in non-decreasing order. Quick Sort is an efficient sorting algorithm that uses the \\"Divide and Conquer\\" approach. It works by selecting a \'pivot\' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. Create a function `quick_sort(array: list) -> list` that takes a list of integers as input and returns a new list with the integers sorted in non-decreasing order. Function Signature: ```python def quick_sort(array: list) -> list: ``` # Input * A list of integers `array` where: * `0 <= len(array) <= 10^5` * `-10^9 <= array[i] <= 10^9` Output * Return a list of integers sorted in non-decreasing order. # Example ```python print(quick_sort([3, -2, 0, 99, 11, -1, 5])) # Output: [-2, -1, 0, 3, 5, 11, 99] print(quick_sort([10, 7, 8, 9, 1, 5])) # Output: [1, 5, 7, 8, 9, 10] ``` # Constraints * You must use the Quick Sort algorithm to solve this problem. * Ensure that the implementation handles large inputs efficiently. * Pay attention to choosing an optimal pivot to avoid worst-case performance. Additional Notes * Consider different pivot selection strategies (first element, last element, random element, median, etc.) to minimize the chance of worst-case time complexity. * Handle the edge cases such as empty arrays and single-element arrays gracefully. * Be mindful of recursion depth and stack overflow issues for very large arrays. Testing * Your solution will be tested for correctness and performance using various test cases, including large datasets to ensure it meets the average O(n log n) time complexity. # Implementation Guide * Implement a helper function `partition(array: list, low: int, high: int) -> int` that partitions the array and returns the index of the pivot element. * Use the helper function within your `quick_sort` function to recursively partition and sort the subarrays. Happy coding!","solution":"def quick_sort(array: list) -> list: if len(array) <= 1: return array def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 def _quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) _quick_sort(arr, low, pi-1) _quick_sort(arr, pi+1, high) _quick_sort(array, 0, len(array) - 1) return array # Example usage: # print(quick_sort([3, -2, 0, 99, 11, -1, 5])) # print(quick_sort([10, 7, 8, 9, 1, 5]))"},{"question":"# Coding Assessment Question Scenario You are developing a system to analyze online reviews for a product. One of the key features is to detect and label sentences based on their sentiment. For simplicity, we will focus on identifying sentences that contain positive sentiment keywords. Objective Write a function `label_positive_sentiments` that takes a list of reviews and returns a list where each original review is annotated with `[POSITIVE]` at the end if it contains any positive sentiment keywords. Function Signature ```python def label_positive_sentiments(reviews: list[str], positive_keywords: list[str]) -> list[str]: Given a list of reviews and a list of positive sentiment keywords, annotate reviews with positive sentiment. Parameters: reviews (list[str]): A list of review strings, where each review contains multiple sentences. positive_keywords (list[str]): A list of positive sentiment keywords. Returns: list[str]: The annotated list of review strings. ``` Input 1. `reviews` (list of str): A list of review strings, where each review may contain multiple sentences. For simplicity, each review is a single string without inner punctuation. 2. `positive_keywords` (list of str): A list of keywords representing positive sentiment. Output * A list of strings where each original review is annotated with `[POSITIVE]` at the end if it contains any word that matches a positive sentiment keyword. If none of the positive keywords are found, the review is returned unchanged. Constraints * The size of each review string and the total number of reviews combined is not more than 10^4 characters. * Words in the reviews and keywords are case-insensitive, but the review should be labeled in the original case. * The list of positive sentiment keywords contains at least 1 and at most 100 keywords. Example ```python label_positive_sentiments( [\\"The product is exceptional and amazing\\", \\"This is just average\\", \\"Remarkably well done\\"], [\\"EXCEPTIONAL\\", \\"AMAZING\\", \\"REMARKABLY\\"] ) # Output: [\\"The product is exceptional and amazing [POSITIVE]\\", \\"This is just average\\", \\"Remarkably well done [POSITIVE]\\"] label_positive_sentiments( [\\"Good quality but not perfect\\", \\"Satisfactory experience overall\\"], [\\"GOOD\\", \\"SATISFACTORY\\", \\"FANTASTIC\\"] ) # Output: [\\"Good quality but not perfect [POSITIVE]\\", \\"Satisfactory experience overall [POSITIVE]\\"] ``` Requirements * The function must handle case-insensitive matching of keywords. * Annotate the string with `[POSITIVE]` exactly once if any positive keyword is found.","solution":"def label_positive_sentiments(reviews, positive_keywords): Given a list of reviews and a list of positive sentiment keywords, annotate reviews with positive sentiment. Parameters: reviews (list[str]): A list of review strings, where each review contains multiple sentences. positive_keywords (list[str]): A list of positive sentiment keywords. Returns: list[str]: The annotated list of review strings. positive_keywords_set = set(word.lower() for word in positive_keywords) def annotate_review(review): review_words = review.split() for word in review_words: if word.lower() in positive_keywords_set: return review + \\" [POSITIVE]\\" return review return [annotate_review(review) for review in reviews]"},{"question":"# Palindrome Substring Removal Background Given a string, you are to remove the minimum number of characters such that the resulting string is a palindrome. A palindrome is a string that reads the same backward as forward. Task Write a function `min_deletions_to_palindrome` that calculates the minimum number of deletions required to transform the given string into a palindrome. Implementation Details * **Function Signature**: `def min_deletions_to_palindrome(s: str) -> int` * **Input**: A string `s` (with length 1 ≤ |s| ≤ 10^3). * **Output**: An integer representing the minimum number of deletions required. Function Specifics 1. You need to find the longest palindromic subsequence (LPS) within the given string. 2. The minimum number of deletions is calculated by subtracting the length of the LPS from the length of the input string. 3. Utilize dynamic programming to optimize the calculation of the LPS. Example ```python def min_deletions_to_palindrome(s: str) -> int: n = len(s) # Create a DP table to store the length of LPS dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the DP table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # Length of the longest palindromic subsequence lps_length = dp[0][n - 1] # Minimum deletions to achieve a palindrome return n - lps_length # Example Usage print(min_deletions_to_palindrome(\'abkbc\')) # Output: 2 print(min_deletions_to_palindrome(\'racecar\')) # Output: 0 ``` **Constraints**: * Time Complexity: O(n^2), where n is the length of the input string. * Space Complexity: O(n^2). Note This algorithm ensures that the approach is efficient and feasible for strings up to the defined length constraint.","solution":"def min_deletions_to_palindrome(s: str) -> int: n = len(s) # Create a DP table to store the length of LPS dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the DP table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # Length of the longest palindromic subsequence lps_length = dp[0][n - 1] # Minimum deletions to achieve a palindrome return n - lps_length"},{"question":"# Problem Statement Create a function that finds the longest common prefix among an array of strings and returns it. If there is no common prefix, return an empty string instead. Additionally, implement a function that verifies the result by comparing the output of the first function against the direct comparison of the array with the result appended. # Function 1: `longest_common_prefix(strs: List[str]) -> str` * **Input Parameters**: - `strs` (List of strings): An array of strings. * **Output**: - Returns a string representing the longest common prefix. * **Constraints**: - 1 <= `len(strs)` <= 200. - 0 <= `len(strs[i])` <= 200. - `strs[i]` consists of only lower-case English letters. # Function 2: `verify_common_prefix(strs: List[str], prefix: str) -> bool` * **Input Parameters**: - `strs` (List of strings): An array of strings. - `prefix` (str): A string representing the common prefix. * **Output**: - Returns a boolean indicating whether `prefix` is indeed the longest common prefix. * **Constraints**: - 1 <= `len(strs)` <= 200. - 0 <= `len(strs[i])` <= 200. - `strs[i]` consists of only lower-case English letters. # Requirements: 1. Implement `longest_common_prefix(strs: List[str]) -> str`. 2. Implement `verify_common_prefix(strs: List[str], prefix: str) -> bool`. 3. The `verify_common_prefix` function must utilize string comparison on elements of `strs`. # Examples: Example 1 ```python >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" ``` Example 2 ```python >>> verify_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"], \\"fl\\") True ``` Example 3 ```python >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" ``` Example 4 ```python >>> verify_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"], \\"\\") True ``` # Explanation: 1. `longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])` returns \\"fl\\" because \\"fl\\" is the longest common prefix in all given strings. 2. `verify_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"], \\"fl\\")` returns True because \\"fl\\" is the correct common prefix. 3. `longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])` returns an empty string because there is no common prefix. 4. `verify_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"], \\"\\")` returns True because the empty string is considered the correct common prefix when no characters match.","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Start with the prefix as the first string prefix = strs[0] for s in strs[1:]: # Gradually reduce the prefix to the common part of each pair while not s.startswith(prefix): prefix = prefix[:-1] # remove the last character if not prefix: return \\"\\" return prefix def verify_common_prefix(strs: List[str], prefix: str) -> bool: for s in strs: if not s.startswith(prefix): return False return True"},{"question":"# Euclidean Algorithm for GCD You are required to implement the Euclidean Algorithm to compute the Greatest Common Divisor (GCD) of two given integers. This algorithm relies on the principle that the GCD of two numbers also divides their difference. **Function Signature:** ```python def gcd(a: int, b: int) -> int: ``` **Input:** * `a` - A non-zero integer. * `b` - A non-zero integer. **Output:** * An integer representing the greatest common divisor of `a` and `b`. **Constraints:** * You must use the Euclidean Algorithm to find the GCD. * You should handle cases where one argument is a negative integer. * Ensure that the solution remains efficient in terms of time complexity. **Scenario:** Imagine you are developing a system that requires finding the GCD of large integer values to optimize storage usage or encryption algorithms. Implementing the Euclidean Algorithm efficiently can significantly enhance the performance for such operations. **Example:** ```python >>> gcd(48, 18) 6 >>> gcd(101, 10) 1 >>> gcd(-81, 27) 27 ``` You can use the following code snippet to build your solution: ```python def gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return abs(a) ``` **Note:** Be sure to test with different pairs of integers, including negative values, to ensure the accuracy and reliability of your implementation.","solution":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean Algorithm. Parameters: a (int): First non-zero integer. b (int): Second non-zero integer. Returns: int: The greatest common divisor of a and b. while b != 0: a, b = b, a % b return abs(a)"},{"question":"String Compression using Run-Length Encoding # Context: Run-Length Encoding (RLE) is a simple technique used to compress strings by reducing the number of repeated characters. For example, the string `\\"aaabccc\\"` can be compressed to `\\"a3b1c3\\"`, where each character is followed by the count of its consecutive occurrences. # Task: Implement a function `compress_string(s: str) -> str`. This function should take a string `s` as input and return its compressed version using Run-Length Encoding. # Function Signature: ```python def compress_string(s: str) -> str: ``` # Input: * **s (str)**: A string of lowercase English letters, (1 le |s| le 10^5) # Output: * **str**: The compressed version of the string using Run-Length Encoding. # Example: ```python assert compress_string(\\"aaabccc\\") == \\"a3b1c3\\" assert compress_string(\\"abcd\\") == \\"a1b1c1d1\\" assert compress_string(\\"aaabbbaaa\\") == \\"a3b3a3\\" ``` # Notes: - If the compressed string is not shorter than the original string, return the original string. - Use a loop to traverse the string and count consecutive characters effectively. - Ensure that your solution is efficient for strings as long as (10^5) characters.","solution":"def compress_string(s: str) -> str: Compresses the input string s using Run-Length Encoding (RLE). If the compressed string is not shorter than the original string, return the original string. Parameters: s (str): The input string. Returns: str: The compressed string or the original string if compression is not beneficial. if not s: return \\"\\" n = len(s) compressed = [] count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Add the last character and its count compressed.append(s[-1]) compressed.append(str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Problem Statement You are writing a module to help organize online educational sessions. Each session has a start and end time, which are represented in 24-hour format. Your task is to create a function `max_non_overlapping_sessions` that selects the maximum number of non-overlapping sessions that can be attended. # Input * A list of tuples `sessions`, where each tuple contains two integers: - The first integer represents the start time of the session. - The second integer represents the end time of the session. * Each session is guaranteed to have a start time that is less than its end time. There are no duplicate sessions. # Output * An integer representing the maximum number of non-overlapping sessions that can be attended. # Constraints * 1 ≤ len(sessions) ≤ 1000 * 0 ≤ start, end ≤ 2359 * The end time is always greater than the start time for each session. # Example ```python def max_non_overlapping_sessions(sessions: list[tuple[int, int]]) -> int: Returns the maximum number of non-overlapping sessions that can be attended. >>> max_non_overlapping_sessions([(900, 1030), (1000, 1130), (1100, 1200), (1230, 1300)]) Returns 2 # Your code here. pass ``` * `sessions = [(900, 1030), (1000, 1130), (1100, 1200), (1230, 1300)]` - The selected sessions could be [(900, 1030), (1100, 1200), (1230, 1300)]. - Return `2` because [(900, 1030), (1230, 1300)] and [(1100, 1200), (1230, 1300)] are non-overlapping and max_non_overlapping_sessions is `2`. # Explanation To solve this problem, you should: 1. Sort the sessions based on their end times. 2. Iterate through the sorted sessions and select those that do not overlap with already selected ones. 3. Return the count of these sessions. This approach ensures that the maximum number of non-overlapping sessions is selected.","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Args: sessions (list of tuples): A list of tuples where each tuple contains two integers representing the start and end times of a session. Returns: int: The maximum number of non-overlapping sessions that can be attended. # Sort sessions based on their end times sorted_sessions = sorted(sessions, key=lambda x: x[1]) count = 0 last_end_time = 0 for session in sorted_sessions: if session[0] >= last_end_time: count += 1 last_end_time = session[1] return count"},{"question":"# Problem Statement Sorting algorithms are fundamental concepts in computer science, with various types having different performance characteristics. The challenge here requires implementing the QuickSort algorithm, a widely used and efficient sorting algorithm based on the divide-and-conquer approach. Task Write a function `quick_sort(arr: List[int]) -> List[int]` that sorts a given list of integers using the QuickSort algorithm. Input * `arr` (List[int]): A list of integers to be sorted. (0 ≤ length of arr ≤ 10^5) and (-10^9 ≤ arr[i] ≤ 10^9 for each element arr[i]). Output * Returns a list of integers sorted in ascending order. Constraints * Your implementation should use the QuickSort algorithm. * The function should handle large inputs efficiently within reasonable runtime. * Consider edge cases such as an empty list or a list with repetitive elements. # Example ```python assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort([1, 4, 2, 8, 5, 7]) == [1, 2, 4, 5, 7, 8] assert quick_sort([1]) == [1] assert quick_sort([]) == [] assert quick_sort([10, -10, 0]) == [-10, 0, 10] assert quick_sort([3, 3, 3, 3]) == [3, 3, 3, 3] ``` Additional Notes QuickSort typically performs better with randomized pivot choices to avoid the worst-case complexity scenarios. Consider using a randomized pivot selection method for improved performance.","solution":"import random from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts a given list of integers using the QuickSort algorithm. if len(arr) <= 1: return arr pivot_index = random.randint(0, len(arr) - 1) pivot = arr[pivot_index] less_than_pivot = [x for x in arr if x < pivot] equal_to_pivot = [x for x in arr if x == pivot] greater_than_pivot = [x for x in arr if x > pivot] return quick_sort(less_than_pivot) + equal_to_pivot + quick_sort(greater_than_pivot)"},{"question":"# Problem Description You are given a list of integers and an integer `k`. Your task is to find the number of unique pairs of integers in the list that sum up to `k`. # Function Signature ```python def count_pairs_with_sum(arr: List[int], k: int) -> int: ``` # Input * `arr`: A list of integers of length `n` (1 <= n <= 10^5). * `k`: An integer (-10^9 <= k <= 10^9). # Output * Returns the number of unique pairs (i, j) where i < j and arr[i] + arr[j] == k. # Constraints * Each element in the list `arr` is an integer (-10^9 <= arr[i] <= 10^9). * Ensure the function performs efficiently for large inputs. # Example Example 1 ```python arr = [1, 5, 7, -1, 5] k = 6 count_pairs_with_sum(arr, k) -> 3 ``` Explanation: The pairs are (1, 5), (7, -1), and (1, 5). Example 2 ```python arr = [1, 1, 1, 1] k = 2 count_pairs_with_sum(arr, k) -> 6 ``` Explanation: The pairs are (1, 1), (1, 1), (1, 1), (1, 1), (1, 1), and (1, 1). Example 3 ```python arr = [1, 2, 3, 4, 5] k = 9 count_pairs_with_sum(arr, k) -> 1 ``` Explanation: The pair is (4, 5). # Constraints * Input list `arr` must contain integers within the specified range. * The length of `arr` and the absolute value of `k` can be large. # Special Cases * If `arr` is empty or contains less than two elements, the function should return `0`. * If no pairs sum up to `k`, the function should return `0`. # Notes * Consider using a hash map or two-pointer technique to achieve optimal performance. * Ensure the implementation can handle varying input sizes and edge cases efficiently.","solution":"from typing import List def count_pairs_with_sum(arr: List[int], k: int) -> int: Returns the number of unique pairs (i, j) where i < j and arr[i] + arr[j] == k. count_map = {} count = 0 for number in arr: target = k - number if target in count_map: count += count_map[target] if number in count_map: count_map[number] += 1 else: count_map[number] = 1 return count"},{"question":"# Question Scenario: You are developing a library management system. One of the features required is the ability to determine the overdue fines based on the number of days a book is overdue. The system should account for different fine rates depending on how late the book is returned. Task: Implement a function `calculate_fine(days_overdue: int, rate_schedule: List[int]) -> int` that computes the fine amount based on the number of days a book is overdue and a rate schedule where each element represents the fine rate for each day overdue. Input: - `days_overdue`: An integer representing the number of days the book is overdue. - `rate_schedule`: A list of integers where each element represents the daily fine rate in a structured manner: - The first element is the fine rate for the first day overdue, - The second element is the rate for the second day overdue, and so on. - If the list is shorter than `days_overdue`, the last rate in the list applies for the remaining days. Output: - An integer representing the total overdue fine. Constraints: - `days_overdue` will be a non-negative integer. - `rate_schedule` will contain at least one positive integer. - If `days_overdue` is 0, return 0. Performance Requirements: - Ensure the solution is efficient with respect to both time and space complexity. Example: ```python from typing import List def calculate_fine(days_overdue: int, rate_schedule: List[int]) -> int: Example usage: >>> calculate_fine(5, [1, 2, 3]) 12 >>> calculate_fine(10, [1, 2, 3]) 27 >>> calculate_fine(0, [1, 2, 3]) 0 >>> calculate_fine(1, [3]) 3 >>> calculate_fine(7, [4, 3, 2]) 20 # Your implementation here # Driver Code (Optional) if __name__ == \\"__main__\\": days_overdue = 5 rate_schedule = [1, 2, 3] print(calculate_fine(days_overdue, rate_schedule)) ``` Make sure you handle edge cases effectively and test your code thoroughly before submission.","solution":"from typing import List def calculate_fine(days_overdue: int, rate_schedule: List[int]) -> int: Calculate the total fine based on the days overdue and the rate schedule. Parameters: days_overdue (int): Number of days the book is overdue. rate_schedule (List[int]): List of daily fine rates. Returns: int: Total overdue fine. if days_overdue == 0: return 0 total_fine = 0 for day in range(1, days_overdue + 1): if day <= len(rate_schedule): total_fine += rate_schedule[day - 1] else: total_fine += rate_schedule[-1] return total_fine"},{"question":"```markdown You are working for a company that tracks the performance of various market products. They need a program that can analyze the sales records and summarize the sales performance. The company uses a list of sales records where each record represents a sale entry containing the product name and the amount sold in dollars. # Task: Write a function `summarize_sales` that takes a list of sales records and returns a summary of the sales performance. The summary should include the total amount sold for each product and the overall total sales. Function Signature: ```python def summarize_sales(sales_records: List[Tuple[str, float]]) -> Dict[str, Union[float, Dict[str, float]]]: pass ``` # Input: 1. `sales_records` (List[Tuple[str, float]]): A list of tuples where each tuple contains a product name (str) and a sale amount (float). (1 ≤ |sales_records| ≤ 1000). # Output: - A dictionary with two keys: - `\\"total_sales\\"`: A float representing the overall total sales amount. - `\\"product_sales\\"`: A dictionary where each key is a product name, and each value is the total sales amount for that product. # Examples: ```python # Example 1: sales_records = [(\\"apple\\", 150.0), (\\"banana\\", 50.0), (\\"apple\\", 200.0), (\\"orange\\", 75.0)] # Expected output: {\\"total_sales\\": 475.0, \\"product_sales\\": {\\"apple\\": 350.0, \\"banana\\": 50.0, \\"orange\\": 75.0}} # Example 2: sales_records = [(\\"widgetA\\", 1000.0), (\\"widgetB\\", 500.0), (\\"widgetA\\", 2000.0)] # Expected output: {\\"total_sales\\": 3500.0, \\"product_sales\\": {\\"widgetA\\": 3000.0, \\"widgetB\\": 500.0}} ``` # Constraints: - The product names in `sales_records` will only contain uppercase and/or lowercase English letters and will not be an empty string. - Sale amounts will be non-negative floats. # Notes: - Your program should handle the aggregation of sales correctly, ensuring each product\'s total sales are accounted for accurately. - The order of products in the `\\"product_sales\\"` dictionary does not matter. - Ensure to handle cases with duplicate product names in the sales records list. Good luck! ```","solution":"from typing import List, Tuple, Dict, Union def summarize_sales(sales_records: List[Tuple[str, float]]) -> Dict[str, Union[float, Dict[str, float]]]: product_sales = {} total_sales = 0.0 for product, amount in sales_records: if product in product_sales: product_sales[product] += amount else: product_sales[product] = amount total_sales += amount return { \\"total_sales\\": total_sales, \\"product_sales\\": product_sales }"},{"question":"# Coding Assessment Question You are a software engineer tasked with developing a recommendation system for an online bookstore. To optimize purchase recommendations, you need to implement a function that calculates the cosine similarity between two users\' purchase history vectors. The cosine similarity is a measure of similarity between two non-zero vectors of an inner product space that measures the cosine of the angle between them. The formula for cosine similarity is: [ text{cosine_similarity}(A, B) = frac{A cdot B}{||A|| , ||B||} ] Where: - ( A cdot B ) is the dot product of vectors ( A ) and ( B ) - ( ||A|| ) is the norm of vector ( A ) (i.e., its length) - ( ||B|| ) is the norm of vector ( B ) Task Write a Python function `cosine_similarity` that calculates the cosine similarity between two input arrays of floating-point numbers representing the purchase history vectors of two users. Your implementation must compute the cosine similarity using vectorized operations for efficiency. Example ```python import numpy as np def cosine_similarity(vector1, vector2): # Implement cosine similarity function here pass # Example usage: user1_history = np.array([3.5, 0, 2.0, 7.1]) user2_history = np.array([2.5, 1.0, 2.0, 5.1]) similarity_score = cosine_similarity(user1_history, user2_history) print(similarity_score) # Expected: 0.9885854816715481 ``` Constraints - Use `numpy` for vectorized operations. - Both input arrays are guaranteed to be of the same length and non-zero. - Input array size can be up to 10^6 elements. Performance Requirement - The function should execute in linear time relative to the size of the input arrays.","solution":"import numpy as np def cosine_similarity(vector1, vector2): Calculate the cosine similarity between two vectors. Parameters: vector1 (numpy array): First user\'s purchase history vector. vector2 (numpy array): Second user\'s purchase history vector. Returns: float: cosine similarity between vector1 and vector2 dot_product = np.dot(vector1, vector2) norm_a = np.linalg.norm(vector1) norm_b = np.linalg.norm(vector2) similarity = dot_product / (norm_a * norm_b) return similarity"},{"question":"# Question Problem Statement: You are required to implement a function to find the most frequently occurring character in a given string. If there is a tie, the function should return the first occurring character in the string. Write a Python function `most_frequent_char(s: str) -> str` that determines the character that appears most frequently in the input string `s`. Requirements: * **Input Format**: - A single string `s` consisting of lowercase and uppercase letters. * **Output Format**: - A single character representing the most frequently occurring character in the string. Example: ```python Input: \\"hello\\" Output: \\"l\\" Input: \\"test\\" Output: \\"t\\" Input: \\"aabbcc\\" Output: \\"a\\" ``` Constraints: * 1 ≤ `len(s)` ≤ 10^5 * The input string contains only English alphabet characters (both lowercase and uppercase). Additional Notes: 1. The function should be case-sensitive, meaning \'a\' and \'A\' are considered different characters. 2. Solve the problem with minimal time complexity. Testing: 1. Test your implementation with a string where a single character is clearly the most frequent. - `s = \\"aabb\\"` should return `\\"a\\"` as \'a\' occurs 2 times. 2. Add edge cases for strings containing only one type of character repeated. - `s = \\"aaaaa\\"` should return `\\"a\\"`. 3. Ensure the function handles ties correctly. - `s = \\"abcabc\\"` should return `\\"a\\"` as \'a\' is the first to appear even though \'a\', \'b\', and \'c\' have the same frequency.","solution":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the string s. In case of a tie, returns the first occurring character. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the most frequently occurring character max_char = None max_freq = 0 for char in s: if char_count[char] > max_freq: max_char = char max_freq = char_count[char] return max_char"},{"question":"# Context In financial institutions and e-commerce platforms, it is common to analyze spending trends for users within a specific time frame. These analyses help in identifying key metrics like average spending, total spending, and high-value transactions. # Problem Statement You are provided with a class `Transaction` to represent individual transactions of users, and a class `UserTransactions` to maintain and operate on these transactions. You need to implement the functionality to compute certain key metrics based on user transactions. # Task Extend the given `UserTransactions` class to include the following additional operations: 1. **Total Spending**: * Implement a method `total_spending(user_id: int) -> float` that returns the total amount spent by the specified user. 2. **Average Spending**: * Implement a method `average_spending(user_id: int) -> float` that returns the average amount spent per transaction by the specified user. 3. **High-Value Transactions**: * Implement a method `high_value_transactions(user_id: int, threshold: float) -> List[Transaction]` that returns a list of `Transaction` objects where the transaction amount is greater than or equal to the given threshold for the specified user. # Function Signature ```python class Transaction: def __init__(self, user_id: int, amount: float): self.user_id = user_id self.amount = amount class UserTransactions: def __init__(self): self.transactions = [] def add_transaction(self, transaction: Transaction) -> None: self.transactions.append(transaction) def total_spending(self, user_id: int) -> float: # Returns the total amount spent by the specified user pass def average_spending(self, user_id: int) -> float: # Returns the average amount spent per transaction by the specified user pass def high_value_transactions(self, user_id: int, threshold: float) -> List[Transaction]: # Returns a list of high-value transactions for the specified user pass ``` # Input - A series of `Transaction` objects that may be added to the `UserTransactions` data structure. - Method calls to retrieve total spending, average spending, and high-value transactions for specified users. # Output - **total_spending**: A float representing the total amount spent by the specified user. - **average_spending**: A float representing the average amount spent per transaction by the specified user. - **high_value_transactions**: A list of `Transaction` objects where the transaction amount is greater than or equal to the given threshold for the specified user. # Example Usage ```python # Example usage user_transactions = UserTransactions() transactions = [ Transaction(1, 100.0), Transaction(1, 200.0), Transaction(2, 150.0), Transaction(1, 50.0), Transaction(2, 400.0), Transaction(2, 100.0) ] for transaction in transactions: user_transactions.add_transaction(transaction) print(user_transactions.total_spending(1)) # Should output 350.0 print(user_transactions.average_spending(1)) # Should output ~116.67 print(user_transactions.high_value_transactions(2, 200)) # Should output [Transaction(2, 400.0)] ``` # Constraints 1. Assume all user IDs are unique integers. 2. The amount for a transaction is a positive float. 3. The total number of transactions will be less than or equal to 10000. 4. The methods should efficiently handle the operations even when the data structure is near its capacity.","solution":"from typing import List class Transaction: def __init__(self, user_id: int, amount: float): self.user_id = user_id self.amount = amount class UserTransactions: def __init__(self): self.transactions = [] def add_transaction(self, transaction: Transaction) -> None: self.transactions.append(transaction) def total_spending(self, user_id: int) -> float: return sum(t.amount for t in self.transactions if t.user_id == user_id) def average_spending(self, user_id: int) -> float: user_transactions = [t.amount for t in self.transactions if t.user_id == user_id] if not user_transactions: return 0.0 return sum(user_transactions) / len(user_transactions) def high_value_transactions(self, user_id: int, threshold: float) -> List[Transaction]: return [t for t in self.transactions if t.user_id == user_id and t.amount >= threshold]"},{"question":"# Problem Statement You are given the task of creating a function that calculates the nth Fibonacci number using two different techniques: dynamic programming and matrix exponentiation. Examine the strengths and weaknesses of each approach based on time and space complexity. # Requirements 1. **Dynamic Programming Implementation**: - Function Name: `dp_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. 2. **Matrix Exponentiation Implementation**: - Function Name: `matrix_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. # Example For example, the implementation should yield the following outputs: ```python assert dp_fibonacci(5) == 5 assert matrix_fibonacci(5) == 5 assert dp_fibonacci(0) == 0 assert matrix_fibonacci(0) == 0 assert dp_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" assert matrix_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" ``` # Function Definitions **Dynamic Programming Implementation** ```python def dp_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 fib = [0, 1] for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) return fib[n] ``` **Matrix Exponentiation Implementation** ```python def matrix_mult(A, B): return [[A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]] def matrix_pow(M, power): res = [[1, 0], [0, 1]] while power: if power % 2 == 1: res = matrix_mult(res, M) M = matrix_mult(M, M) power //= 2 return res def matrix_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n-1) return result[0][0] ``` Implement these functions and ensure they pass the provided example cases.","solution":"def dp_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 fib = [0, 1] for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) return fib[n] def matrix_mult(A, B): return [[A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]] def matrix_pow(M, power): res = [[1, 0], [0, 1]] while power: if power % 2 == 1: res = matrix_mult(res, M) M = matrix_mult(M, M) power //= 2 return res def matrix_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n-1) return result[0][0]"},{"question":"# Coding Question: Unique Element Finder in a Partially Rotated Array Context: You\'re given a sorted array that has been rotated at some unknown pivot. A rotated array is an array that is of the form `[sorted_array[k:], sorted_array[:k]]`, where `sorted_array` is sorted in ascending order. Your task is to find the unique element in this array. The array is guaranteed to have all elements except one that appears exactly twice. Task: 1. Implement the `find_unique_element` function as defined below. 2. Ensure your implementation efficiently finds and returns the unique element. Function Signature: ```python def find_unique_element(nums: list) -> int: Finds the unique element in a rotated sorted list where all other elements appear twice. Parameters: nums (list): A list of integers where all elements except one appear twice, and the array is rotated. Returns: int: The unique element in the list. ``` Example: ```python # Example input input_data = [4, 4, 5, 6, 7, 7, 1, 1, 2, 2, 3, 3] # Expected output 5 ``` Constraints: * The input list is non-empty and contains integers. * The list is sorted but rotated. * All integers except one appear exactly twice. * The input list can contain negative and positive integers and will fit in memory. Objective: Ensure your implementation correctly identifies the unique element with optimal time complexity.","solution":"def find_unique_element(nums): Finds the unique element in a rotated sorted list where all other elements appear twice. Parameters: nums (list): A list of integers where all elements except one appear twice, and the array is rotated. Returns: int: The unique element in the list. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Unique Character Counter Background Efficient analysis of text data often requires identifying patterns or specific attributes within the text. One such attribute is the number of unique characters. This task focuses on developing a function to count the unique characters in a string, which could be useful in various analytical contexts, such as data preprocessing or feature extraction. Problem Statement Write a function `count_unique_chars` that takes a single string as its input and returns the count of unique characters in that string. The function should be case-sensitive and include all printable characters, including spaces and punctuation. ```python def count_unique_chars(string: str) -> int: Counts the number of unique characters in the given string. The function should be case-sensitive and include all printable characters. Examples: >>> count_unique_chars(\\"apple\\") 4 >>> count_unique_chars(\\"Hello, World!\\") 10 >>> count_unique_chars(\\"1234567890\\") 10 >>> count_unique_chars(\\"AaBbCc\\") 6 >>> count_unique_chars(\\"\\") 0 pass ``` # Input - `string` (str): The input string for which the unique characters need to be counted. # Output - `int`: The number of unique characters in the input string. # Constraints - The input string may contain any printable character. - The function should handle empty strings gracefully. - The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. # Requirements - Implement the function to efficiently count unique characters. - Handle edge cases such as empty strings and strings with repeated characters. - Ensure the function performs well with long strings. # Testing You may assume the presence of a testing framework similar to `doctest`. Comprehensive tests covering all mentioned scenarios will be appreciated. Good luck, and happy coding!","solution":"def count_unique_chars(string: str) -> int: Counts the number of unique characters in the given string. The function should be case-sensitive and include all printable characters. Examples: >>> count_unique_chars(\\"apple\\") 4 >>> count_unique_chars(\\"Hello, World!\\") 10 >>> count_unique_chars(\\"1234567890\\") 10 >>> count_unique_chars(\\"AaBbCc\\") 6 >>> count_unique_chars(\\"\\") 0 return len(set(string))"},{"question":"**Context**: Searching is another fundamental operation in computer science essential for efficient data retrieval. The Binary Search algorithm is a widely-used technique that leverages the sorted nature of data to achieve fast lookup times. # Problem Statement Implement a modified version of the Binary Search algorithm to locate the position of a target value within a list of integers. If the target value is not present, return the index where it could be inserted to maintain the sorted order. # Requirements * **Function Name**: `binary_search_insert` * **Input**: A list of integers `collection` and a target integer `target` * **Output**: An integer representing the index position of the target, or where it could be inserted in sorted order. # Constraints - The input list `collection` is sorted in ascending order. - Ensure the implementation has a time complexity of O(log n). # Example ```python def binary_search_insert(collection: list, target: int) -> int: # Your code here # Examples: print(binary_search_insert([1, 3, 5, 6], 5)) # Output: 2 print(binary_search_insert([1, 3, 5, 6], 2)) # Output: 1 print(binary_search_insert([1, 3, 5, 6], 7)) # Output: 4 print(binary_search_insert([1, 3, 5, 6], 0)) # Output: 0 print(binary_search_insert([1, 1, 1, 1], 1)) # Output: 0 ``` # Special Considerations - Ensure to handle cases where the list is empty. - Consider scenarios with repeated elements. - Handle all edge cases gracefully including when `target` is less than all elements or greater than all elements in the list. # Testing Create a comprehensive suite of tests to verify the correctness of your implementation across various cases, including edge cases, general scenarios, and special situations involving empty lists and duplicates.","solution":"def binary_search_insert(collection: list, target: int) -> int: Perform binary search to find the position of target in sorted list collection. If target is not present, return the index where it could be inserted to maintain the sorted order. :param collection: List of integers sorted in ascending order :param target: Integer target to find :return: Index of target or where it could be inserted in sorted order left, right = 0, len(collection) while left < right: mid = (left + right) // 2 if collection[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Coding Task: Write a function that takes a list of integers and a target integer, and returns a boolean indicating whether there are two distinct numbers in the list that add up to the target. Function Signature: ```python def has_pair_with_sum(arr: List[int], target: int) -> bool: ``` Input: - A list of integers `arr` (1 <= len(arr) <= 10^5). - An integer `target` (1 <= target <= 10^9). Output: - A boolean value, `True` if there are two distinct numbers in the list that add up to the target, `False` otherwise. Constraints: 1. Any number in the list can be negative, zero, or positive. 2. The list can contain duplicate numbers. Example: ```python >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([1, 5, 7, -1], 6) True ``` Requirements: - Implement an efficient algorithm with a time complexity better than O(n^2). - Use appropriate data structures to optimize the search for pairs. Hint: - Consider using a set to store elements and check for the complementary number that would sum up to the target.","solution":"def has_pair_with_sum(arr, target): Returns True if there are two distinct numbers in arr that add up to target, False otherwise. seen_numbers = set() for number in arr: complement = target - number if complement in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"**You are given a set of integers. Implement a function that determines the length of the longest subset where the integers can be rearranged to form consecutive elements.** # Objective Your task is to write a function `longest_consecutive_subsequence` that takes a list of integers as input and returns the length of the longest subsequence of consecutive integers that can be formed from elements in the list. # Function Signature ```python def longest_consecutive_subsequence(nums: List[int]) -> int: ``` # Input The function `longest_consecutive_subsequence` should take a single argument: - `nums`: A list of integers (`List[int]`). The list can be empty. # Output The function should return an integer: - The length of the longest consecutive subsequence. # Constraints - The list can contain between 0 and 10^5 integers. - Each integer value ranges from -10^5 to 10^5. # Example Consider the input list: ```python nums = [100, 4, 200, 1, 3, 2] ``` Calling `longest_consecutive_subsequence(nums)` should return `4` because: - The longest consecutive subsequence is `[1, 2, 3, 4]`. # Edge Cases 1. An empty list should return `0`. 2. A list with a single integer should return `1`. 3. Lists with repeated non-consecutive elements test the function\'s ability to identify unique sequences. # Notes - The function should handle large inputs efficiently. - Ensure proper handling of edge cases such as empty lists or lists with negative and positive integers. # Additional Examples ```python nums = [10, 9, 8, 7] # longest_consecutive_subsequence(nums) should return 4 because the longest subsequence is [7, 8, 9, 10] nums = [1, 2, 0, 1] # longest_consecutive_subsequence(nums) should return 3 because the longest subsequence is [0, 1, 2] nums = [5, 5, 5] # longest_consecutive_subsequence(nums) should return 1 because the longest subsequence is [5] ```","solution":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers that can be formed from elements in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # If it\'s the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"**Problem Statement**: You are required to implement a function that performs a bitwise AND operation on an arbitrary number of boolean (0 or 1) inputs and outputs the result. Additionally, create a function that generates a formatted truth table for four boolean inputs demonstrating the result of applying the bitwise AND operation. **Function Specifications**: 1. **bitwise_and**: - **Input**: `*inputs: List[int]` - A variable number of boolean (0 or 1) inputs. - **Output**: `int` - The result of applying a bitwise AND operation on all the inputs. 2. **generate_truth_table**: - **Input**: `func: Callable[..., int]` - A function like `bitwise_and` which computes the AND result of multiple inputs. - **Output**: `str` - A string representation of the truth table for four inputs. When calling `bitwise_and`, the function should apply the bitwise AND operation across all the provided inputs. Ensure to handle edge cases for varying lengths of inputs. **Details**: The truth table should be formatted as follows for four inputs: ``` | Input 1 | Input 2 | Input 3 | Input 4 | Output | | 0 | 0 | 0 | 0 | 0 | | 0 | 0 | 0 | 1 | 0 | ... | 1 | 1 | 1 | 1 | 1 | ``` **Constraints**: - Inputs to `bitwise_and` will always be integers `0` or `1`. - The truth table should be generated for all combinations of four boolean inputs. # Implementation You need to implement the following functions: ```python def bitwise_and(*inputs: int) -> int: # Implement the bitwise AND operation pass def generate_truth_table(func: Callable[..., int]) -> str: # Implement the truth table generation for the given AND function pass ``` **Example**: ```python # Example usage: print(bitwise_and(0, 1, 1, 1)) # Expected Output: 0 print(bitwise_and(1, 1, 1, 1)) # Expected Output: 1 print(generate_truth_table(bitwise_and)) ``` **Expected Truth Table Output**: ``` | Input 1 | Input 2 | Input 3 | Input 4 | Output | | 0 | 0 | 0 | 0 | 0 | | 0 | 0 | 0 | 1 | 0 | ... | 1 | 1 | 1 | 1 | 1 | ```","solution":"def bitwise_and(*inputs: int) -> int: Perform bitwise AND operation on all input booleans (0 or 1). result = 1 for i in inputs: result &= i return result def generate_truth_table(func) -> str: Generate a formatted truth table for four boolean inputs. truth_table = \\"| Input 1 | Input 2 | Input 3 | Input 4 | Output |n\\" truth_table += \\"|---------|---------|---------|---------|----------|n\\" for i in range(2): for j in range(2): for k in range(2): for l in range(2): result = func(i, j, k, l) truth_table += f\\"| {i} | {j} | {k} | {l} | {result} |n\\" return truth_table"},{"question":"**Title**: Detecting Cycles in a Directed Graph **Context**: You are given a directed graph represented as an adjacency list with `N` vertices. The task is to detect if there are any cycles in this graph. **Problem Statement**: Implement the function `has_cycle(graph: Dict[int, List[int]]) -> bool` that reads an adjacency list representation of a directed graph and returns `True` if there are one or more cycles in the graph, and `False` otherwise. **Input Format**: * `graph`: A dictionary where the key is a vertex and the value is a list of vertices to which there are directed edges from the key vertex. **Output Format**: * Returns a boolean value `True` if a cycle is present in the graph, and `False` otherwise. **Constraints**: 1. `1 <= N <= 50` (Number of vertices) 2. Each vertex key and adjacent vertices in the list are integers. **Example**: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } assert has_cycle(graph) == True ``` **Explanation**: In this example, the graph contains a cycle: 0 -> 2 -> 0 and 3 -> 3 (self-loop). In another case, consider the graph: ```python graph = { 0: [1], 1: [2], 2: [3], 3: [] } assert has_cycle(graph) == False ``` In this example, the graph does not contain any cycles. **Note**: You can assume that the input graph does not contain parallel edges.","solution":"def has_cycle(graph): Detects if there are any cycles in a given directed graph. Args: graph: A dictionary representing the adjacency list of the graph. Returns: bool: True if there is a cycle, False otherwise. def visit(vertex): if vertex in visiting: return True if vertex in visited: return False visiting.add(vertex) for neighbor in graph.get(vertex, []): if visit(neighbor): return True visiting.remove(vertex) visited.add(vertex) return False visited = set() visiting = set() for v in graph: if visit(v): return True return False"},{"question":"# Coding Assessment Question Context You are developing a system for a library to manage and track the borrowing of its books. Each book has a unique International Standard Book Number (ISBN), and the library needs functions to manipulate and validate these ISBNs. # Objective Implement the required functions to extract information from an ISBN, validate it, and format it correctly for display, ensuring they adhere to the appropriate conventions and include proper error handling. # Problem Statement 1. **Function: `extract_group_identifier(isbn)`** - **Description**: Extract the group identifier from a given 13-digit ISBN. - **Input**: A string representation of a 13-digit ISBN. - **Output**: A string representing the group identifier (which appears as the first digit of the ISBN). - **Constraints**: Ensure the ISBN is valid (13 digits). 2. **Function: `validate_isbn(isbn)`** - **Description**: Validate an ISBN (including its check digit) to see if it is valid. - **Input**: A string representation of an ISBN (either 10 or 13 digits long). - **Output**: A boolean indicating whether the ISBN is valid. - **Constraints**: Ensure the ISBN length is appropriate (10 or 13 digits). 3. **Function: `format_isbn(isbn)`** - **Description**: Format a string representation of an ISBN for standardized display by inserting hyphens. - **Input**: A string representation of an ISBN (either 10 or 13 digits long). - **Output**: A formatted string with hyphens appropriately placed. - **Error Handling**: Handle inputs that don\'t match the expected ISBN patterns and raise appropriate errors. # Example ```python def extract_group_identifier(isbn): # [Write your code here] def validate_isbn(isbn): # [Write your code here] def format_isbn(isbn): # [Write your code here] # Example Usage: assert extract_group_identifier(\\"9781234567890\\") == \\"978\\" assert validate_isbn(\\"9781234567897\\") == True assert validate_isbn(\\"123456789X\\") == True assert validate_isbn(\\"9781234567890\\") == False assert format_isbn(\\"9781234567890\\") == \\"978-1-2345-6789-0\\" assert format_isbn(\\"123456789X\\") == \\"1-234-56789-X\\" try: format_isbn(\\"abcdefghijk\\") except ValueError: pass # Expected ```","solution":"def extract_group_identifier(isbn): Extract the group identifier from a given 13-digit ISBN. Parameters: isbn (str): A string representation of a 13-digit ISBN. Returns: str: The group identifier (first digit of the ISBN). if len(isbn) != 13 or not isbn.isdigit(): raise ValueError(\\"ISBN must be a 13-digit number\\") return isbn[:3] def validate_isbn(isbn): Validate an ISBN (including its check digit) to see if it is valid. Parameters: isbn (str): A string representation of an ISBN (either 10 or 13 digits long). Returns: bool: True if the ISBN is valid, False otherwise. if len(isbn) == 10: return validate_isbn_10(isbn) elif len(isbn) == 13: return validate_isbn_13(isbn) else: return False def validate_isbn_10(isbn): Validate a 10-digit ISBN. Parameters: isbn (str): A string representation of a 10-digit ISBN. Returns: bool: True if the ISBN-10 is valid, False otherwise. if not isbn[:9].isdigit() or (isbn[-1] not in \'0123456789X\'): return False total = 0 for i in range(9): total += int(isbn[i]) * (10 - i) check_digit = isbn[-1] if check_digit == \'X\': total += 10 else: total += int(check_digit) return total % 11 == 0 def validate_isbn_13(isbn): Validate a 13-digit ISBN. Parameters: isbn (str): A string representation of a 13-digit ISBN. Returns: bool: True if the ISBN-13 is valid, False otherwise. if not isbn.isdigit(): return False total = 0 for i in range(12): if i % 2 == 0: total += int(isbn[i]) else: total += int(isbn[i]) * 3 check_digit = (10 - (total % 10)) % 10 return check_digit == int(isbn[-1]) def format_isbn(isbn): Format a string representation of an ISBN for standardized display by inserting hyphens. Parameters: isbn (str): A string representation of an ISBN (either 10 or 13 digits long). Returns: str: A formatted string with hyphens appropriately placed. if len(isbn) == 10: return format_isbn_10(isbn) elif len(isbn) == 13: return format_isbn_13(isbn) else: raise ValueError(\\"ISBN must be either 10 or 13 digits long\\") def format_isbn_10(isbn): Format a 10-digit ISBN with hyphens. Parameters: isbn (str): A string representation of a 10-digit ISBN. Returns: str: A formatted string with hyphens appropriately placed. if len(isbn) != 10 or not (isbn[:9].isdigit() and (isbn[-1] in \'0123456789X\')): raise ValueError(\\"Invalid ISBN-10 format\\") return f\\"{isbn[0]}-{isbn[1:4]}-{isbn[4:9]}-{isbn[9]}\\" def format_isbn_13(isbn): Format a 13-digit ISBN with hyphens. Parameters: isbn (str): A string representation of a 13-digit ISBN. Returns: str: A formatted string with hyphens appropriately placed. if len(isbn) != 13 or not isbn.isdigit(): raise ValueError(\\"Invalid ISBN-13 format\\") return f\\"{isbn[:3]}-{isbn[3]}-{isbn[4:8]}-{isbn[8:12]}-{isbn[12]}\\""},{"question":"# Problem Statement You are required to write a Python function that generates all possible valid combinations of `k` pairs of parentheses. # Function Signature Your task is to implement the following function: ```python def generate_parentheses(k: int) -> list: This function returns a list of all valid combinations of k pairs of parentheses. :param k: The number of pairs of parentheses :type k: int :return: List containing all valid combinations of k pairs of parentheses :rtype: list of str Example: >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(1) [\\"()\\"] pass ``` # Input * A single integer `k` representing the number of pairs of parentheses (where 0 <= k <= 12). # Output * A list of strings, each representing a valid combination of `k` pairs of parentheses. # Constraints * The input `k` will always be a non-negative integer up to 12. # Example ```python >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(0) [\\"\\"] ``` # Additional Information * Consider using a recursive approach to explore all possible combinations while ensuring the resulting strings are valid by tracking the count of open and close parentheses.","solution":"def generate_parentheses(k: int) -> list: This function returns a list of all valid combinations of k pairs of parentheses. :param k: The number of pairs of parentheses :type k: int :return: List containing all valid combinations of k pairs of parentheses :rtype: list of str def backtrack(current: str, open_count: int, close_count: int, result: list): if len(current) == 2 * k: result.append(current) return if open_count < k: backtrack(current + \'(\', open_count + 1, close_count, result) if close_count < open_count: backtrack(current + \')\', open_count, close_count + 1, result) result = [] backtrack(\\"\\", 0, 0, result) return result"},{"question":"Question # Robot Paths in a Grid with Obstacles Given a grid-based environment where a robot can either move up, down, left, or right, implement the functionalities to navigate and find the shortest path avoiding obstacles. # Function Specifications Your task is to implement a class `RobotGrid` which contains the following methods: - `__init__(self, grid: List[List[int]])`: Initializes the grid where `grid[i][j]` can be 0 (free space) or 1 (obstacle). The robot can move in cells which are 0 and cannot move in cells which are 1. - `find_shortest_path(self, start: Tuple[int, int], end: Tuple[int, int]) -> int`: Returns the length of the shortest path from the start cell to the end cell. If the path does not exist, raise a `ValueError`. # Constraints * The input grid will be a rectangular matrix with dimensions between 1x1 and 100x100. * The robot can only move to adjacent cells in the grid (up, down, left, right). * The cell values will either be 0 (free space) or 1 (obstacle). * The start and end coordinates are guaranteed to be within the bounds of the grid. * There will not be any duplicates in the cells\' coordinates provided. # Example ```python # Creating a grid with free spaces and obstacles grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] rg = RobotGrid(grid) # Finding shortest path from cell (3, 0) to (0, 0) assert rg.find_shortest_path((3, 0), (0, 0)) == 7 # Finding shortest path from cell (0, 0) to (3, 3) assert rg.find_shortest_path((0, 0), (3, 3)) == 6 # Trying to find path from cell (3, 0) to (1, 3) will raise a ValueError try: rg.find_shortest_path((3, 0), (1, 3)) except ValueError as e: print(e) # No path from start to end found. # Creating a grid where start and end cells are the same and free grid_same_point = [[0]] rg2 = RobotGrid(grid_same_point) assert rg2.find_shortest_path((0, 0), (0, 0)) == 0 ``` # Notes * Ensure your implementation handles grid boundaries and obstacles efficiently. * Aim for an optimal pathfinding algorithm such as BFS which guarantees the shortest path in an unweighted grid. * Handle edge cases such as start cell equals end cell, and grids filled with obstacles.","solution":"from typing import List, Tuple from collections import deque class RobotGrid: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def find_shortest_path(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: if self.grid[start[0]][start[1]] == 1 or self.grid[end[0]][end[1]] == 1: raise ValueError(\\"No path from start to end found.\\") if start == end: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() for dr, dc in self.directions: nr, nc = r + dr, c + dc if 0 <= nr < self.rows and 0 <= nc < self.cols and (nr, nc) not in visited and self.grid[nr][nc] == 0: if (nr, nc) == end: return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) raise ValueError(\\"No path from start to end found.\\")"},{"question":"# Context: A common task in data analysis and machine learning is to construct a balanced binary search tree from a sorted array. This is particularly useful for ensuring that search operations can be performed efficiently. # Problem Statement: Write a function `sorted_array_to_bst` that takes a sorted array of integers and constructs a balanced binary search tree (BST). The function should return the root node of the BST. # Specifications: - **Input**: - `nums`: List of integers sorted in ascending order. - **Output**: - Root node of the constructed balanced BST. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode | None: pass ``` # Constraints: - The length of `nums` will be between 0 and (10^4). - The input list may be empty. # Example: ```python nums = [-10, -3, 0, 5, 9] result = sorted_array_to_bst(nums) # Expected Output: # The BST can be represented as: # 0 # / # -3 9 # / / # -10 5 # To validate, performing an in-order traversal of the resulting BST should yield the original sorted array. def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] print(inorder_traversal(result)) # Expected Output: [-10, -3, 0, 5, 9] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode | None: if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else []"},{"question":"# Coding Challenge: Implement a Memoized Fibonacci Function **Scenario**: You are helping to optimize a financial application that frequently calculates Fibonacci numbers for various inputs. To improve performance, you have decided to implement a memoized version of the Fibonacci calculation. **Objective**: Implement the `Fibonacci` class to calculate Fibonacci numbers using memoization to cache previously computed values. **Requirements**: 1. Implement the `Fibonacci` class. 2. Implement the `fib` method that calculates the Fibonacci number at a given position using memoization. 3. Ensure that subsequent calls to `fib` for the same input return the result instantly by using the cached value. **Function Signature**: ```python class Fibonacci: def __init__(self): ... def fib(self, n: int) -> int: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes any necessary data structures for memoization. - `fib(self, n: int) -> int`: Returns the ( n )-th Fibonacci number. **Constraints**: - The input ( n ) will be in the range [0, 100]. - Fibonacci numbers can be computed using the formula: [ F(n) = begin{cases} 0 & text{if } n = 0 1 & text{if } n = 1 F(n-1) + F(n-2) & text{if } n > 1 end{cases} ] **Performance Requirements**: - The first call to compute ( F(n) ) should be ( O(n) ). - Subsequent calls for previously computed ( F(n) ) should be ( O(1) ). **Testing**: Your implementation should be verified by the following tests: 1. Calculating ( F(n) ) for a variety of input values. 2. Verifying the memoization by ensuring that subsequent calls to `fib` for the same ( n ) use the cached value. 3. Edge cases like ( F(0) ) and ( F(1) ). Implement the `Fibonacci` class and `fib` method based on the initial provided code and ensure your solution passes the described tests.","solution":"class Fibonacci: def __init__(self): self.memo = {} def fib(self, n: int) -> int: if n in self.memo: return self.memo[n] if n == 0: self.memo[n] = 0 elif n == 1: self.memo[n] = 1 else: self.memo[n] = self.fib(n - 1) + self.fib(n - 2) return self.memo[n]"},{"question":"# Coding Assessment Question **Scenario**: You are working for a tech company that provides analytics services. As part of their offering, they analyze the purchase history of customers to identify frequent buying patterns. Your task is to extend the provided data analysis function to include additional functionality: identifying the most frequently purchased product per customer and storing the results in a well-structured format. **Objective**: Modify the provided function `analyze_purchases` to: 1. Identify the most frequently purchased product for each customer. 2. Store the results in a dictionary where the keys are customer IDs and the values are the most frequently purchased product. **Function Signature**: ```python def find_frequent_purchases(data: list[tuple[str, str]]) -> dict[str, str]: Identify the most frequently purchased product per customer. Args: - data (list[tuple[str, str]]): A list of tuples where each tuple contains a customer ID and a product ID representing a purchase. Returns: - dict[str, str]: A dictionary where keys are customer IDs and the values are the most frequently purchased product IDs. ``` **Constraints**: - **Input**: - `data`: A non-empty list of tuples where each tuple represents a purchase, with the first element being the customer ID (string) and the second element being the product ID (string). - **Output**: - A dictionary where each key is a customer ID from the input data. - The value for each key is the product ID that was purchased most frequently by that customer. **Example**: ```python data = [ (\\"cust1\\", \\"prod1\\"), (\\"cust1\\", \\"prod2\\"), (\\"cust1\\", \\"prod1\\"), (\\"cust2\\", \\"prod3\\"), (\\"cust2\\", \\"prod3\\"), (\\"cust2\\", \\"prod2\\"), (\\"cust3\\", \\"prod1\\") ] result = find_frequent_purchases(data) Expected Output (example): { \\"cust1\\": \\"prod1\\", \\"cust2\\": \\"prod3\\", \\"cust3\\": \\"prod1\\" } ``` **Guidelines for Implementation**: 1. **Data Processing**: Ensure the function can handle large datasets efficiently. 2. **Handling Ties**: If there is a tie (i.e., multiple products have the same highest purchase count for a customer), return any one of the most frequently purchased products. 3. **Edge Cases**: Consider cases with single purchases, all unique purchases, or multiple customers with varying purchase patterns. 4. **Memory Usage**: Be mindful of memory consumption when dealing with a large quantity of customer records. 5. **Function Efficiency**: Implement an efficient solution to avoid performance issues with large input sizes.","solution":"def find_frequent_purchases(data): Identify the most frequently purchased product per customer. Args: - data (list[tuple[str, str]]): A list of tuples where each tuple contains a customer ID and a product ID representing a purchase. Returns: - dict[str, str]: A dictionary where keys are customer IDs and the values are the most frequently purchased product IDs. from collections import defaultdict purchase_data = defaultdict(lambda: defaultdict(int)) # Collect purchase frequencies for customer_id, product_id in data: purchase_data[customer_id][product_id] += 1 most_frequent_purchases = {} # Determine the most frequent product for each customer for customer_id, products in purchase_data.items(): most_frequent_product = max(products, key=products.get) most_frequent_purchases[customer_id] = most_frequent_product return most_frequent_purchases"},{"question":"# Coding Assessment Question You have been given a Python dictionary representing students and their grades. Your task is to write a function that normalizes the grades, scales them to a standard range of 0 to 100, and returns a new dictionary with the normalized grades. If a student\'s grade is already within the 0-100 range, it should remain unchanged. # Task Write a Python function that: 1. Takes a dictionary where the keys are student names (strings) and the values are their grades (integers or floats). 2. Adjusts the grades that fall outside the 0-100 range to fit within this range. 3. Returns a new dictionary with the same student names and their normalized grades. # Normalization Logic - For grades less than 0, set them to 0. - For grades greater than 100, set them to 100. # Requirements 1. **Input**: A dictionary with student names as keys and grades as values. 2. **Output**: A new dictionary with normalized grades. 3. **Constraints**: * The number of students can be up to 1,000,000. * Grades can be any integer or floating-point number. # Performance: * The function must handle large dictionaries efficiently, utilizing both space and time constraints appropriately. Examples: ```python # Example 1: grades_dict = { \'Alice\': 95, \'Bob\': 105, \'Charlie\': 80, \'David\': -5 } normalize_grades(grades_dict) # Output: {\'Alice\': 95, \'Bob\': 100, \'Charlie\': 80, \'David\': 0} # Example 2: grades_dict = { \'Eve\': 100, \'Frank\': -100, \'Grace\': 102.5, \'Heidi\': 50 } normalize_grades(grades_dict) # Output: {\'Eve\': 100, \'Frank\': 0, \'Grace\': 100, \'Heidi\': 50} ``` # Notes - The input dictionary should remain unmodified. - The new dictionary should maintain the same keys and values, but with grades normalized to the 0-100 range.","solution":"def normalize_grades(grades_dict): This function takes a dictionary with student names and their grades, and returns a new dictionary where grades are normalized to the range 0-100. :param grades_dict: dict, keys as student names (str) and values as grades (int or float) :return: dict, same keys with normalized grades normalized_dict = {} for student, grade in grades_dict.items(): if grade < 0: normalized_dict[student] = 0 elif grade > 100: normalized_dict[student] = 100 else: normalized_dict[student] = grade return normalized_dict"},{"question":"# Problem: Optimizing a List Reversal Function You are tasked with implementing an optimized function to reverse elements of a list, but with a twist: instead of directly reversing the list in-place or using built-in functions, you must accomplish this by swapping elements, simulating an in-place reversal manually. Your implementation should efficiently handle various sizes of lists and should pay particular attention to edge cases. Function Specification: - **Function Name**: `reverse_list` - **Input**: - `arr`: A list of integers. - **Output**: - A new list with elements of `arr` in reverse order. Constraints: 1. The input list, `arr`, can be empty or contain up to (10^7) elements. 2. Do not use Python\'s built-in `reverse()` method or slicing feature (`[::-1]`) for reversing the list. 3. Ensure the function works efficiently for very large lists within reasonable time limits. # Task Description: Implement the function `reverse_list` which manually swaps elements to reverse the list without using any high-level list operations provided by Python. Example: ```python def reverse_list(arr: list) -> list: # Implementation here ``` Examples of how the function should behave: ```python assert reverse_list([1, 2, 3]) == [3, 2, 1] # A simple case assert reverse_list([]) == [] # Edge case: empty list assert reverse_list([42]) == [42] # Edge case: single-element list assert reverse_list([1, 2, 3, 4, 5, 6]) == [6, 5, 4, 3, 2, 1] # Even number of elements assert reverse_list([7, 8, 9, 10, 11]) == [11, 10, 9, 8, 7] # Odd number of elements ``` # Requirements - Avoid using Python built-ins that directly perform the reversal. - Optimize the solution for large inputs ensuring it runs efficiently. - Develop thorough testing covering both standard and edge cases. Good luck and happy coding!","solution":"def reverse_list(arr): Reverse elements of a list by swapping elements manually. Parameters: arr (list): List of integers to be reversed. Returns: list: A new list with elements in reverse order. n = len(arr) result = arr.copy() # Make a copy to avoid modifying the original list left = 0 right = n - 1 while left < right: result[left], result[right] = result[right], result[left] left += 1 right -= 1 return result"},{"question":"# Problem: Identify the Celebrity In a group of `n` people, a celebrity is defined as someone who everyone knows but who knows no one. You are given a function `knows(a, b)` which returns `True` if person `a` knows person `b`, otherwise it returns `False`. Your task is to identify the celebrity in the group using as few calls to the `knows` function as possible. **Function Signature:** ```python def find_celebrity(n: int, knows: Callable[[int, int], bool]) -> int: ``` # Input 1. `n`: An integer representing the number of people. 2. `knows`: A function that takes two integers `a` and `b` and returns a boolean value indicating whether `a` knows `b`. # Output An integer representing the index of the celebrity, or -1 if there is no celebrity. # Constraints * 1 <= n <= 1000 * It is guaranteed that `knows(a, b)` returns `True` or `False`. # Examples ```python n = 3 def knows(a, b): MATRIX = [[False, True, True], [False, False, True], [False, False, False]] return MATRIX[a][b] find_celebrity(n, knows) # Output: # 2 ``` # Scenario Given the `knows` function which can tell you if one person knows another, efficiently identify the celebrity in the group by minimizing the number of calls to `knows`. A celebrity does not know anyone but is known by everyone else. If there isn\'t a celebrity in the group, return -1.","solution":"from typing import Callable def find_celebrity(n: int, knows: Callable[[int, int], bool]) -> int: candidate = 0 # Step 1: Find a candidate who might be a celebrity for i in range(1, n): if knows(candidate, i): candidate = i # Step 2: Verify the candidate for i in range(n): if i != candidate: if knows(candidate, i) or not knows(i, candidate): return -1 return candidate"},{"question":"# Coding Assessment Question Scenario: As a software engineer at a retail company, you are responsible for developing a system that processes customer orders. Each order contains items with varying quantities, and the goal is to determine the minimum number of boxes required to pack the items without exceeding a given maximum box capacity. Task: Implement a function `min_boxes_required(items, max_capacity)` that determines the minimum number of boxes required to pack all items. Each item in the input `items` is represented by its weight. Each box can hold items up to `max_capacity`. Function Signature: ```python def min_boxes_required(items: List[int], max_capacity: int) -> int: ``` Input: - `items`: A list of integers where each integer represents the weight of an item. - `max_capacity`: An integer representing the maximum capacity of a single box. Output: - Returns an integer representing the minimum number of boxes required to pack all items. Constraints: - The length of the `items` list is between 1 and 50. - Each item weight is between 1 and the `max_capacity`. - The `max_capacity` is between 1 and 100. Example: ```python items = [5, 5, 5, 5, 5] max_capacity = 10 print(min_boxes_required(items, max_capacity)) # Expected Output: 3 items = [2, 3, 5, 7, 1, 4, 4] max_capacity = 10 print(min_boxes_required(items, max_capacity)) # Expected Output: 3 ``` Notes: - Ensure the implementation efficiently uses the box space to minimize the number of boxes used. - Assume that items must be fully packed and cannot be split across boxes. - Optimize your implementation for performance within the constraints provided.","solution":"from typing import List def min_boxes_required(items: List[int], max_capacity: int) -> int: Calculates the minimum number of boxes required to pack all items without exceeding the maximum box capacity. items.sort(reverse=True) # Sort items in descending order to optimize packing boxes = 0 while items: current_capacity = max_capacity i = 0 while i < len(items): if items[i] <= current_capacity: current_capacity -= items[i] items.pop(i) else: i += 1 boxes += 1 return boxes"},{"question":"# Question: Calculate Impedance in an AC Circuit In electrical engineering, impedance (Z) in an AC circuit consists of resistance (R) and reactance (X). The impedance can be represented in rectangular form as ( Z = R + jX ), where R is the resistance, X is the reactance, and ( j ) is the imaginary unit. You are tasked with implementing two functions to calculate the magnitude of the impedance and the phase angle given the resistance and the reactance of the circuit. Function 1: `impedance_magnitude` ```python def impedance_magnitude(resistance: float, reactance: float) -> float: Calculate the magnitude of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The magnitude of the impedance (|Z|). ``` Function 2: `impedance_phase_angle` ```python def impedance_phase_angle(resistance: float, reactance: float) -> float: Calculate the phase angle of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The phase angle of the impedance in degrees (θ). ``` # Constraints: 1. The `resistance` and `reactance` will be floats. 2. The functions should handle zero and negative values for both `resistance` and `reactance`. # Example: ```python >>> impedance_magnitude(3, 4) # Expected output 5.0 >>> impedance_phase_angle(3, 4) # Expected output 53.13010235415599 >>> impedance_magnitude(0, 4) # Expected output 4.0 >>> impedance_phase_angle(0, 4) # Expected output 90.0 >>> impedance_magnitude(3, 0) # Expected output 3.0 >>> impedance_phase_angle(3, 0) # Expected output 0.0 >>> impedance_magnitude(-3, 4) # Expected output 5.0 >>> impedance_phase_angle(-3, 4) # Expected output 126.86989764584402 ``` # Additional Requirements: 1. Ensure the functions handle edge cases effectively, such as when resistance or reactance is zero. 2. Use appropriate mathematical libraries to calculate the results accurately. 3. Adhere to O(1) time and space complexity constraints.","solution":"import math def impedance_magnitude(resistance: float, reactance: float) -> float: Calculate the magnitude of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The magnitude of the impedance (|Z|). return math.sqrt(resistance**2 + reactance**2) def impedance_phase_angle(resistance: float, reactance: float) -> float: Calculate the phase angle of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The phase angle of the impedance in degrees (θ). return math.degrees(math.atan2(reactance, resistance))"},{"question":"# Question: Box Volume Calculator Problem Statement: You are required to implement a Python function that calculates the volume of a rectangular box using its length, width, and height. The volume of a box is given by the formula `V = lwh`, where `l` is the length, `w` is the width, and `h` is the height of the box. Function Signature: ```python def box_volume(length: float, width: float, height: float) -> float: ``` Input: - **length** (float): The length of the box in meters (m). (1 ≤ length ≤ 1000) - **width** (float): The width of the box in meters (m). (1 ≤ width ≤ 1000) - **height** (float): The height of the box in meters (m). (1 ≤ height ≤ 1000) Output: - Returns the volume of the box (float) in cubic meters (m³). Constraints: - If any of the dimensions (length, width, or height) are zero or negative, raise a `ValueError` with the respective messages: - \\"The length of the box cannot be zero or negative\\" for length. - \\"The width of the box cannot be zero or negative\\" for width. - \\"The height of the box cannot be zero or negative\\" for height. Examples: ```python >>> box_volume(2, 3, 5) 30.0 >>> box_volume(10, 10, 10) 1000.0 >>> box_volume(1.5, 2.5, 3.5) 13.125 >>> box_volume(100, 200, 300) 6000000.0 >>> box_volume(0, 2, 3) ValueError: The length of the box cannot be zero or negative >>> box_volume(-1, 2, 3) ValueError: The length of the box cannot be zero or negative ``` Implementation: Use Python to write your function. Ensure that your function handles all edge cases such as when any of the dimensions are zero or negative, and properly calculates the volume for valid dimensions. # Solution ```python def box_volume(length: float, width: float, height: float) -> float: if length <= 0: raise ValueError(\\"The length of the box cannot be zero or negative\\") if width <= 0: raise ValueError(\\"The width of the box cannot be zero or negative\\") if height <= 0: raise ValueError(\\"The height of the box cannot be zero or negative\\") return length * width * height ```","solution":"def box_volume(length: float, width: float, height: float) -> float: if length <= 0: raise ValueError(\\"The length of the box cannot be zero or negative\\") if width <= 0: raise ValueError(\\"The width of the box cannot be zero or negative\\") if height <= 0: raise ValueError(\\"The height of the box cannot be zero or negative\\") return length * width * height"},{"question":"# Question: Implement Dynamic Programming Solution to Maximize Sales from Stock Inventory Context: You are working on an inventory management system for a retail store, where each product can be stocked in multiple units and sold to maximize profits. Each product has a specific profit value associated with it, and there is a limit on the total number of units that can be stocked due to storage constraints. Task: Implement a function that uses dynamic programming to determine the maximum profit achievable without exceeding the storage limit. Specifically, you need to develop the following: 1. A method to parse and process the profit values and unit weights for each product. 2. A dynamic programming algorithm to compute the maximum profit within the given storage capacity. Specifications: 1. **Input**: - `product_infos` : A list of tuples where each tuple contains two integers. The first integer is the profit (`profit`) for each unit of the product, and the second integer is the weight (`weight`) of each unit of the product. - `max_units` : An integer representing the maximum number of units that can be stocked. 2. **Output**: - `max_profit` : The maximum achievable profit without exceeding the storage limit. 3. **Constraints**: - Each product can be stocked in multiple units, but the total units stored cannot exceed `max_units`. - The algorithm should be efficient and well-structured to handle a medium-sized product list. - Ensure that the solution runs within a reasonable time limit for large inputs. Example Input: ```python product_infos = [(10, 2), (5, 1), (15, 3), (7, 2)] max_units = 5 ``` Example Output: ```python max_profit = 25 ``` This output indicates that the maximum profit achievable within the given storage capacity of 5 units is 25. Instructions: 1. **Parse Product Information**: Write a function to parse and process the list of product profit and weight values. 2. **Dynamic Programming Algorithm**: Develop the dynamic programming algorithm to maximize the profit within the allowed storage units. 3. **Result Calculation**: Ensure the final result is computed and returned accurately. 4. **Testing**: Write at least 3 test cases to verify your implementation. Example Implementation: ```python def maximize_sales(product_infos, max_units): n = len(product_infos) dp = [0] * (max_units + 1) for profit, weight in product_infos: for i in range(max_units, weight - 1, -1): dp[i] = max(dp[i], dp[i - weight] + profit) return dp[max_units] # Example Test Case product_infos = [(10, 2), (5, 1), (15, 3), (7, 2)] max_units = 5 print(maximize_sales(product_infos, max_units)) # Output: 25 ``` This code uses dynamic programming to solve the problem by constructing a table (`dp`) to store the maximum profit for each possible storage unit capacity up to `max_units`.","solution":"def maximize_sales(product_infos, max_units): Determine the maximum profit achievable without exceeding the storage limit using dynamic programming. :param product_infos: List of tuples (profit, weight) for each product. :param max_units: Maximum number of units that can be stocked. :return: Maximum profit. n = len(product_infos) # Initialize the DP array with 0s dp = [0] * (max_units + 1) # Iterate over each product\'s profit and weight for profit, weight in product_infos: # Traverse the dp array backwards to avoid recomputation for i in range(max_units, weight - 1, -1): dp[i] = max(dp[i], dp[i - weight] + profit) return dp[max_units]"},{"question":"Scenario String permutations and pattern matching are critical aspects of solving many combinatorial problems. You are tasked with creating a sophisticated solution that leverages permutations and efficient search techniques to solve a common problem in text analysis. Problem Statement Given two strings `s1` and `s2`, implement the function `check_permutation_inclusion(s1: str, s2: str) -> bool`, which determines if a permutation of `s1` is a substring of `s2`. Input - `s1` (string): The first string, for which permutations are to be considered. - `s2` (string): The second string, in which to check for any permutation of the first string. Output - Returns a boolean value - `True` if any permutation of `s1` is a substring of `s2`, otherwise `False`. Function Signature ```python def check_permutation_inclusion(s1: str, s2: str) -> bool: pass ``` Example ```python >>> check_permutation_inclusion(\\"ab\\", \\"eidbaooo\\") True >>> check_permutation_inclusion(\\"ab\\", \\"eidboaoo\\") False ``` Constraints - The length of both strings `s1` and `s2` will not exceed 10^4. - All characters in strings are lowercase letters. - The solution should efficiently handle permutations and substring checking to avoid unnecessary computational overhead. Note An optimized approach that leverages sliding windows or hashing to minimize time complexity would be highly beneficial.","solution":"def check_permutation_inclusion(s1: str, s2: str) -> bool: from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) if s1_count == window_count: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] end_char = s2[i] window_count[end_char] += 1 window_count[start_char] -= 1 if window_count[start_char] == 0: del window_count[start_char] if window_count == s1_count: return True return False"},{"question":"# Coding Assessment Question: Rotating Matrix You are given an n x n 2D matrix that represents an image. Rotate the image by 90 degrees (clockwise). Write a Python function `rotate_matrix` to achieve this rotation in-place. Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` Input - `matrix`: A 2D list of integers, where (1 <= n <= 20, -1000 <= matrix[i][j] <= 1000) Output - The function should modify the matrix in-place. Do not return anything. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # matrix should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) # matrix should now be: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` Constraints 1. The matrix is guaranteed to be n x n. 2. The function must operate in-place with O(1) extra space. 3. Consider edge cases where the matrix might be 1x1. Scenario Suppose you are working on an image editing software where rotating images frequently is a necessary feature. By implementing an efficient in-place rotation, you can optimize memory usage and performance especially on devices with limited resources.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question Creation for Coding Assessment To ensure we follow the guidelines and emulate the style, complexity, and scope of the given sample question, here is the additional question: [**Question 2**]: **Permutation Generator** You need to implement a function `generate_permutations` that takes a list of distinct integers called `nums`. Your task is to return all possible permutations of `nums`. # Function Signature ```python def generate_permutations(nums: list[int]) -> list[list[int]]: ``` # Parameters * `nums` (List[int]): A list of distinct integers (1 <= len(nums) <= 10, -10 <= nums[i] <= 10). # Output * List[List[int]]: A list of all possible permutations of `nums`. Each permutation should be represented by a list. # Constraints * All elements of `nums` are distinct. * If `nums` is empty, return a list containing an empty list. # Examples ```python >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([0, -1, 1]) [[0, -1, 1], [0, 1, -1], [-1, 0, 1], [-1, 1, 0], [1, 0, -1], [1, -1, 0]] >>> generate_permutations([5]) [[5]] >>> generate_permutations([]) [[]] ``` # Requirements 1. You must implement the function without using any global variables. 2. You should handle invalid inputs gracefully by returning an empty list. 3. Use a depth-first search approach or any other appropriate algorithm to generate all permutations. # Tips 1. Ensure that the elements in each permutation list are unique and arranged in all possible orders before returning. 2. Consider edge cases such as an empty list or invalid input types beyond the given constraints. 3. Optimize for performance within the provided constraints. This question maintains the style, complexity, and scope of the given sample question, asking for a function that generates all possible permutations of a list of integers, much like how the provided sample question asks for finding all unique combinations summing to a target value.","solution":"from itertools import permutations def generate_permutations(nums): Generates all possible permutations of a list of distinct integers. Args: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list of all possible permutations of the nums list. if not isinstance(nums, list) or any(not isinstance(i, int) for i in nums): return [] return [list(p) for p in permutations(nums)]"},{"question":"# Memory Allocation in a Dynamic System Scenario You are developing a dynamic memory allocation system similar to the buddy system. The system should handle multiple memory allocation and deallocation requests, ensuring efficient memory usage and minimal fragmentation. Each memory request needs to be allocated the smallest available block that fits the request size. Problem Description Create a class `MemoryAllocator` that manages memory allocation and deallocation requests. The system uses a single contiguous block of memory that can be divided into smaller blocks using the buddy system. Input * `max_size` (int): The total size of the available memory. * `request_size` (int): The size of the memory to be allocated. Output * `allocate` (int): Allocate the smallest available block that fits the request size and return the starting index of the allocated block. Return `-1` if no suitable block is available. * `deallocate` (int, int): Deallocate the block starting at the given index and of the given size. Return `True` if the block was successfully deallocated, otherwise `False`. Constraints * The total memory size (`max_size`) is a power of 2 (e.g., 1, 2, 4, 8, 16, ...). * Requests and deallocations sizes are also powers of 2. * Assume the smallest block size is 1 unit. Example ```python class MemoryAllocator: def __init__(self, max_size: int): self.max_size = max_size self.memory = [0] * max_size # 0 means free, 1 means allocated self.allocations = {} def allocate(self, request_size: int) -> int: # Your implementation here pass def deallocate(self, start_index: int, size: int) -> bool: # Your implementation here pass # Example usage: allocator = MemoryAllocator(16) print(allocator.allocate(4)) # Expected: 0 or another valid index print(allocator.allocate(8)) # Expected: 4 or another valid index print(allocator.deallocate(0, 4)) # Expected: True print(allocator.allocate(2)) # Expected: 0 or another valid index print(allocator.allocate(1)) # Expected: 2 or another valid index print(allocator.deallocate(4, 8)) # Expected: True print(allocator.allocate(16)) # Expected: 0 (if the entire memory is free) ``` Ensure that your methods handle different scenarios, such as fragmentation and combining free blocks during deallocation.","solution":"class MemoryAllocator: def __init__(self, max_size: int): self.max_size = max_size self.memory = [0] * max_size # 0 means free, 1 means allocated self.allocations = {} def allocate(self, request_size: int) -> int: if request_size > self.max_size: return -1 for i in range(self.max_size - request_size + 1): if all(self.memory[i + j] == 0 for j in range(request_size)): for j in range(request_size): self.memory[i + j] = 1 self.allocations[i] = request_size return i return -1 def deallocate(self, start_index: int, size: int) -> bool: if start_index in self.allocations and self.allocations[start_index] == size: for i in range(start_index, start_index + size): self.memory[i] = 0 del self.allocations[start_index] return True return False"},{"question":"# Binary Search Implementation You are tasked with implementing a binary search algorithm. Given a sorted list of integers and a target integer, your goal is to determine if the target is present in the list. If the target is found, return its index. If not, return -1. Function Signature: ```python def binary_search(arr: list[int], target: int) -> int: ``` Input: - **arr**: A list of integers sorted in non-decreasing order. - **target**: An integer representing the target value to search for in the list. Output: - An integer representing the index of the target in the list if found, otherwise -1. Constraints: - The function should have a logarithmic time complexity, i.e., O(log n). Examples: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 5 assert binary_search(arr, target) == 4 arr = [1, 3, 5, 7, 9, 11, 13, 15] target = 2 assert binary_search(arr, target) == -1 ``` Scenario: Imagine you are looking up a word in a dictionary. The words are listed in alphabetical order. Instead of checking each word sequentially, you can quickly narrow down your search using the binary search algorithm to determine whether the word is in the dictionary and, if so, find its exact position. **Note**: The list is guaranteed to be sorted.","solution":"def binary_search(arr: list[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem: Substring Palindrome Check Given a desire to identify palindromic substrings in a given string, you are tasked with creating a function that verifies if a given substring is a palindrome. A string is considered a palindrome if it reads the same backward as forward, ignoring spaces, punctuation, and case differences. # Task Write a function `is_palindrome(s: str, start: int, end: int) -> bool` that takes a string `s`, and two indices `start` and `end`, and returns a boolean indicating whether the substring `s[start:end+1]` is a palindrome. # Input * `s` (str): The input string which can contain alphabetic characters, digits, punctuation, and whitespaces. * `start` (int): The starting index of the substring (0-indexed). * `end` (int): The ending index of the substring (0-indexed). # Output * (bool): `True` if the specified substring is a palindrome, `False` otherwise. # Constraints * The input string\'s length will not exceed 1000 characters. * You may assume all characters in the string are ASCII. * `0 <= start <= end < len(s)` # Example ```python def is_palindrome(s: str, start: int, end: int) -> bool: # Implement this function pass # Example Usage print(is_palindrome(\\"A man, a plan, a canal, Panama\\", 0, 6)) # Output: True print(is_palindrome(\\"racecar\\", 0, 6)) # Output: True print(is_palindrome(\\"hello\\", 0, 4)) # Output: False print(is_palindrome(\\"No \'x\' in Nixon\\", 0, 14)) # Output: True print(is_palindrome(\\"abccba\\", 0, 5)) # Output: True print(is_palindrome(\\"abccba\\", 0, 4)) # Output: False ``` # Additional Information 1. The function should ignore all non-alphanumeric characters while checking for the palindrome. 2. The check should be case-insensitive. 3. Leading or trailing spaces in the output debug statements should be preserved, but they should not affect the palindrome checking logic.","solution":"def is_palindrome(s: str, start: int, end: int) -> bool: Checks if the substring s[start:end+1] is a palindrome. import re # Extract the substring substring = s[start:end+1] # Remove non-alphanumeric characters and convert to lower case cleaned_substring = re.sub(r\'[^a-zA-Z0-9]\', \'\', substring).lower() # Check if the cleaned substring is a palindrome return cleaned_substring == cleaned_substring[::-1]"},{"question":"# Question: Implement a Median Finder Scenario You are tasked with implementing a data structure that efficiently tracks a dynamically expanding dataset and can return the median of the data at any given time. This functionality is useful in applications that require real-time median calculations, such as financial analytics. Task Implement a class `MedianFinder` with the following methods: 1. **`__init__(self):`** * Initializes the data structure. 2. **`addNum(self, num: int) -> None:`** * Adds a number to the data structure. 3. **`findMedian(self) -> float:`** * Returns the median of all elements added so far. The median is: * The middle element if the number of elements is odd. * The average of the two middle elements if the number of elements is even. Constraints * The median finding should aim for optimal performance with respect to the number of elements. * All methods must run in O(log n) time complexity for `addNum` and O(1) time complexity for `findMedian`. * The methods will be called as follows: * `obj = MedianFinder()` * `obj.addNum(num)` * `param_2 = obj.findMedian()` Example ```python obj = MedianFinder() obj.addNum(1) obj.addNum(2) print(obj.findMedian()) # returns 1.5 obj.addNum(3) print(obj.findMedian()) # returns 2 ```","solution":"import heapq class MedianFinder: def __init__(self): Initialize the data structure. self.small = [] # max-heap (inverted min-heap) for the lower half of the numbers self.large = [] # min-heap for the upper half of the numbers def addNum(self, num: int) -> None: Adds a number to the data structure. heapq.heappush(self.small, -num) # Balance the largest element of the small heap to the large heap heapq.heappush(self.large, -heapq.heappop(self.small)) # If the large heap size is greater than the small heap size, balance it back if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: Returns the median of all elements. if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Problem Statement You are tasked with writing a function `min_steps_to_equal_elements` that determines the minimum number of decrement operations needed to make all elements in an array equal. Each decrement operation involves subtracting 1 from any one of the elements in the array. # Input - An integer `n` (1 ≤ n ≤ 100) representing the number of elements in the array. - A list of integers `arr` of length `n` where each integer `arr[i]` (1 ≤ arr[i] ≤ 1000) represents the value of the i-th element in the array. # Output - An integer representing the minimum number of decrement operations required to make all elements in `arr` equal. # Constraints - The input will be such that it is always possible to make all elements in the array equal by only performing decrement operations. # Example ```python def min_steps_to_equal_elements(n: int, arr: List[int]) -> int: # Your implementation here # Example Usage n = 5 arr = [2, 3, 4, 5, 6] print(min_steps_to_equal_elements(n, arr)) # Output: 10 ``` # Note - In the above example, to make all elements equal to 2, you need to perform 1 decrement on 3, 2 decrements on 4, 3 decrements on 5, and 4 decrements on 6, leading to a total of 1 + 2 + 3 + 4 = 10 operations.","solution":"def min_steps_to_equal_elements(n, arr): Determines the minimum number of decrement operations needed to make all elements in an array equal. :param n: int - Number of elements in the array :param arr: List[int] - List of integers representing the array elements :return: int - Minimum number of decrement operations min_value = min(arr) steps = sum(x - min_value for x in arr) return steps"},{"question":"# Binary Search Tree Operations **Context**: Binary Search Trees (BSTs) are fundamental data structures used in many applications such as database management systems and searching operations. They maintain sorted data and allow for efficient insertion, deletion, and lookup operations. **Problem Statement**: Design and implement a program to perform insertion, deletion, and search operations on a Binary Search Tree. **Function to Implement**: ```python class BSTNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def search(self, key: int) -> bool: pass # Example usage: # bst = BinarySearchTree() # bst.insert(5) # bst.insert(3) # bst.insert(7) # bst.delete(3) # print(bst.search(3)) # Output: False # print(bst.search(7)) # Output: True ``` # Requirements: 1. **Input/Output**: * The `insert` method should accept an integer key and insert it into the BST. * The `delete` method should accept an integer key and delete it from the BST. * The `search` method should accept an integer key and return `True` if the key is found in the BST, otherwise `False`. 2. **Constraints**: * Keys are integers and unique in the tree. * Handle empty tree scenarios gracefully. * The operations should maintain the properties of the BST after their execution. 3. **Performance**: * Aim for optimal performance in insertion, deletion, and search operations, ideally achieving logarithmic time complexity for balanced trees. * Use efficient algorithms to maintain the BST properties during deletions, particularly when deleting nodes with two children. 4. **Edge Cases**: * Inserting into an empty tree. * Deleting the root node. * Searching for keys not present in the tree. * Ensure the node pointers are updated correctly after deletions to avoid memory leaks or invalid references. 5. **Coding Guidelines**: * Structure the code with clear class definitions and method implementations. * Include comments to explain non-trivial logic, especially in the deletion function. * Ensure robustness through careful handling of edge cases and exceptions. 6. **Assumptions**: * No duplicate keys are present in the BST. * The maximum number of nodes will not exceed 10^6. **Example**: ```python # Initializing a Binary Search Tree bst = BinarySearchTree() # Inserting nodes into the BST bst.insert(15) bst.insert(10) bst.insert(20) bst.insert(8) bst.insert(12) # Searching for keys print(bst.search(10)) # Output: True print(bst.search(5)) # Output: False # Deleting a node bst.delete(10) print(bst.search(10)) # Output: False print(bst.search(12)) # Output: True ``` Ensure to test the BST implementation for various cases such as inserting multiple nodes, deleting nodes with zero, one, or two children, and searching for keys. Good luck!","solution":"class BSTNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = BSTNode(key) else: self._insert(self.root, key) def _insert(self, node: BSTNode, key: int) -> None: if key < node.key: if node.left is None: node.left = BSTNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = BSTNode(key) else: self._insert(node.right, key) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node: BSTNode, key: int) -> BSTNode: if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.key = min_larger_node.key node.right = self._delete(node.right, min_larger_node.key) return node def _find_min(self, node: BSTNode) -> BSTNode: while node.left is not None: node = node.left return node def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node: BSTNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key)"},{"question":"# Coding Assessment Question Problem Statement You are given an array of integers where every integer appears twice except for one integer that appears only once. Write a function that finds the integer which appears only once in the array. Your solution should have a linear runtime complexity and use constant space. Function Signature ```python def find_unique_number(nums: list[int]) -> int: ``` Input - `nums`: A list of integers where every integer appears exactly twice except for one integer which appears only once. Constraints: - 1 <= length of nums <= 1000 - Each integer in nums can be between -1000 and 1000 inclusive. Output - The function should return a single integer which is the unique number that appears only once. Examples ```python >>> find_unique_number([4, 1, 2, 1, 2]) 4 >>> find_unique_number([2, 2, 1]) 1 >>> find_unique_number([1]) 1 >>> find_unique_number([0, 0, 1, 2, 1]) 2 ``` Constraints & Considerations - The function should handle edge cases such as lists with only one element. - Use bitwise operations to achieve the desired linear runtime complexity and constant space constraint. - Ensure the function behaves correctly with both positive and negative integers. Detailed Explanation 1. **Use XOR Operation**: - XOR all the elements in the array together. - Since XOR of two same numbers is zero and XOR of any number with zero is the number itself, all the paired numbers will cancel each other out, leaving the unique number. 2. **Implement Iteration**: - Iterate through the array and XOR each element with an accumulator initialized to zero. - By the end of the iteration, the accumulator will hold the unique number. ```python def find_unique_number(nums: list[int]) -> int: unique = 0 for num in nums: unique ^= num return unique ```","solution":"def find_unique_number(nums: list[int]) -> int: Finds the unique number in the list where every other number appears exactly twice. :param nums: List of integers where each integer appears exactly twice except for one unique integer. :return: The unique integer that appears only once. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Problem Statement: You are given a list of integers and your goal is to sort this list using the Merge Sort algorithm. Merge Sort is a divide-and-conquer algorithm that recursively splits the list into halves, sorts each half, and then merges the sorted halves back together. Implement the `merge_sort` function which takes as input an unsorted list of integers and returns the list sorted in ascending order. # Functions to Implement: 1. `merge_sort(arr) -> list` **Parameters**: - `arr` (list): A list of integers to be sorted. **Returns**: - `sorted_arr` (list): The input list sorted in ascending order. # Constraints: - The length of the list will be between 1 and 1000. - All integers in the list will be between -10^6 and 10^6. # Example: ```python arr = [34, 7, 23, 32, 5, 62] print(merge_sort(arr)) # Output should be [5, 7, 23, 32, 34, 62] arr = [-1, -20, 100, 0, 56, 12] print(merge_sort(arr)) # Output should be [-20, -1, 0, 12, 56, 100] ``` # Hints: - Implement the recursive decomposition of the list into smaller halves. - Carefully merge the two halves while maintaining order between elements. - Ensure the base case of the recursion is correctly implemented to avoid infinite loops.","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 while left_index < len(left): sorted_list.append(left[left_index]) left_index += 1 while right_index < len(right): sorted_list.append(right[right_index]) right_index += 1 return sorted_list"},{"question":"# Question: String Manipulation and Pattern Matching **Context:** You are developing a string manipulation library and need to include functionality that addresses common text processing tasks. This library will handle operations involving word patterns, character sequences, and special conditions in text data. **Objective:** Implement the following functions, ensuring they handle edge cases, optimize performance, and work with various input types: 1. **Longest Palindromic Substring**: Find the longest substring of a given string that is a palindrome. 2. **Word Pattern Matching**: Determine if a string follows a given word pattern. 3. **Character Frequency**: Return a dictionary with characters as keys and their frequencies as values. **Function Signatures:** ```python def longest_palindromic_substring(s: str) -> str: pass def word_pattern(pattern: str, s: str) -> bool: pass def character_frequency(s: str) -> dict: pass ``` **Expected Input and Output**: ```python assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert character_frequency(\\"hello\\") == {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} ``` **Constraints:** - The input string for all functions will be non-empty and contain only alphanumeric characters and spaces. - Performance should be optimized for input strings up to 10^5 characters in length. **Detailed Requirements:** 1. **Longest Palindromic Substring**: - **Input:** A single string `s`. - **Output:** The longest substring of `s` that reads the same backward. - Use dynamic programming or an efficient algorithm to ensure optimal performance. 2. **Word Pattern Matching**: - **Input:** Two strings: `pattern` and `s`. - **Output:** A boolean indicating whether `s` follows the specified `pattern`. - The `pattern` consists of lowercase letters, and `s` consists of words separated by spaces. - Establish a bijection (one-to-one mapping) between letters in `pattern` and words in `s`. 3. **Character Frequency**: - **Input:** A single string `s`. - **Output:** A dictionary mapping each character to its frequency in `s`. - Implement an efficient method to count characters. **Edge Cases to Consider**: - Minimal Input: Test with the smallest properly formed strings. - Long Strings: Ensure performance with strings at the upper limit of the constraints. - Pattern Matching: Handle cases where the pattern or `s` contains repetitions or unique differences. Use these functions to extend the string manipulation capabilities and ensure they work harmoniously with previous utilities in the library.","solution":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in s. if len(s) == 0: return \\"\\" start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the given word pattern. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, w in zip(pattern, words): if c in char_to_word and char_to_word[c] != w: return False if w in word_to_char and word_to_char[w] != c: return False char_to_word[c] = w word_to_char[w] = c return True def character_frequency(s: str) -> dict: Return a dictionary with characters as keys and their frequencies as values. freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"# Context You are given a `ParkingLot` class that simulates a parking lot with limited spaces. This class currently maintains a list of parked vehicles. To improve efficiency, especially for large parking lots, you need to optimize the parking space allocation using a more suitable data structure. # Task Refactor the provided `ParkingLot` class to use a data structure that allows efficient allocation and release of parking spaces. # Requirements 1. Implement the methods – `park(vehicle)`, `leave(slot_number)`, `get_next_available_slot()`, and `get_occupied_slots()`. 2. The `park(vehicle)` method should find and allocate the next available parking slot in constant time O(1). 3. The `leave(slot_number)` method should release a given parking slot in constant time O(1). 4. The `get_next_available_slot()` method should return the next available slot in constant time O(1). 5. The `get_occupied_slots()` method should return a list of currently occupied slots. # Input/Output - The `park(vehicle)` method takes any vehicle object and allocates the next available slot. Assumption: there will always be a free slot when park is called. - The `leave(slot_number)` method releases the parking slot specified by slot_number. - The `get_next_available_slot()` method returns the next available parking slot. - The `get_occupied_slots()` method returns a list of currently occupied slot numbers. # Example ```python parking_lot = ParkingLot(10) print(parking_lot.get_next_available_slot()) # Output: 1 parking_lot.park(\'Vehicle1\') print(parking_lot.get_next_available_slot()) # Output: 2 print(parking_lot.get_occupied_slots()) # Output: [1] parking_lot.leave(1) print(parking_lot.get_next_available_slot()) # Output: 1 print(parking_lot.get_occupied_slots()) # Output: [] ``` # Notes * Focus on selecting a suitable data structure that supports efficient allocation and release of parking slots. * Ensure that parking and leaving operations are optimized to handle large volumes of vehicles efficiently.","solution":"import heapq class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.available_slots = list(range(1, capacity + 1)) heapq.heapify(self.available_slots) self.occupied_slots = {} def park(self, vehicle): slot = heapq.heappop(self.available_slots) self.occupied_slots[slot] = vehicle return slot def leave(self, slot_number): if slot_number in self.occupied_slots: del self.occupied_slots[slot_number] heapq.heappush(self.available_slots, slot_number) def get_next_available_slot(self): if self.available_slots: return self.available_slots[0] return None def get_occupied_slots(self): return sorted(self.occupied_slots.keys())"},{"question":"# Inventory Management System Simulation You are tasked with extending an `InventorySystem` class to simulate a basic inventory management system for a retail store. The `InventorySystem` is partially implemented and requires two additional methods: 1. **`add_product` method** to add new products to the inventory. 2. **`process_sale` method** to handle the sales process. # Implementation Details: 1. **`add_product` method** should: - Accept a product name, quantity, and price. - Add the new product to the inventory or update the existing product\'s details (i.e., increment the quantity and potentially update the price). - Return the current quantity of the product in the inventory. 2. **`process_sale` method** should: - Accept a product name and quantity. - Verify if the product is available in sufficient quantity. - Deduct the sold quantity from the inventory. - Calculate and return the total sale value (quantity * price) for the processed sale. - If the product is not available in sufficient quantity, return an appropriate message indicating the shortfall. # Input/Output: - **Input**: - For `add_product` method: ```python def add_product(self, product_name, quantity, price): # product_name: Name of the product (string) # quantity: Quantity to add (integer) # price: Price per unit (float) ``` - For `process_sale` method: ```python def process_sale(self, product_name, quantity): # product_name: Name of the product (string) # quantity: Quantity to sell (integer) ``` - **Output**: - For `add_product` method: Return the updated quantity of the product in the inventory (integer). - For `process_sale` method: If the sale is successful, return the total sale value (float). If unsuccessful, return an error message string. # Constraints: 1. Product names are unique strings. 2. Quantity and price are positive values. 3. Assume that the price of a product can change, and the most recent price is used for calculations. # Example Scenario: ```python inventory = InventorySystem() # Adding products inventory.add_product(\\"Laptop\\", 10, 999.99) inventory.add_product(\\"Smartphone\\", 20, 499.99) # Processing a sale sale1 = inventory.process_sale(\\"Laptop\\", 2) print(f\\"Sale value: {sale1}\\") # Trying to process an invalid sale sale2 = inventory.process_sale(\\"Smartphone\\", 30) print(sale2) # Outputs: \\"Not enough stock for Smartphone\\" # Checking the updated inventory after sales print(inventory.add_product(\\"Laptop\\", 0, 999.99)) ``` # Additional Notes: - Make sure to handle edge cases such as adding products with zero quantity, attempting to process sales with zero or negative quantities, and enforcing stock availability for sales. - Your implementation should emphasize clarity and efficiency, especially in inventory updates and sale processing.","solution":"class InventorySystem: def __init__(self): # Initialize inventory as an empty dictionary self.inventory = {} def add_product(self, product_name, quantity, price): Adds a product to the inventory or updates the existing product\'s details. if product_name in self.inventory: # Update existing product self.inventory[product_name][\'quantity\'] += quantity self.inventory[product_name][\'price\'] = price # latest price update else: # Add new product self.inventory[product_name] = {\'quantity\': quantity, \'price\': price} return self.inventory[product_name][\'quantity\'] def process_sale(self, product_name, quantity): Processes the sale of a product and return the total sale value. if product_name not in self.inventory: return f\\"Product {product_name} not found in inventory\\" if self.inventory[product_name][\'quantity\'] < quantity: return f\\"Not enough stock for {product_name}\\" self.inventory[product_name][\'quantity\'] -= quantity total_sale_value = quantity * self.inventory[product_name][\'price\'] return total_sale_value"},{"question":"# Coding Assessment Question Context In this exercise, you are going to work with strings and analyze their character frequencies to determine specific properties about them. String manipulation and character frequency analysis are common tasks in programming, often used in parsing and processing text data. Problem Statement Write a function `nth_most_frequent_char(s: str, n: int) -> str` that returns the nth most frequent character in the string `s`. If multiple characters have the same frequency, return the lexicographically smallest one. If the string does not have enough distinct characters, return an empty string. Constraints * The function parameter `s` is a non-empty string containing only lowercase alphabetic characters (\'a\' to \'z\'). * The function parameter `n` is a positive integer. Input * A string `s`. * An integer `n`. Output * The nth most frequent character in `s` as a string, or an empty string if there are not enough distinct characters. Examples * `nth_most_frequent_char(\\"banana\\", 1)` should return `\\"a\\"`. * `nth_most_frequent_char(\\"banana\\", 2)` should return `\\"n\\"`. * `nth_most_frequent_char(\\"aabbbcc\\", 3)` should return `\\"c\\"`. * `nth_most_frequent_char(\\"abcd\\", 5)` should return \\"\\". Function Signature ```python def nth_most_frequent_char(s: str, n: int) -> str: pass ``` Requirements * Ensure the code handles edge cases like strings with identical frequency characters properly. * Optimize where possible to reduce runtime and space complexity. * Include appropriate test cases to verify the correctness of your implementation.","solution":"from collections import Counter def nth_most_frequent_char(s: str, n: int) -> str: # Count the frequency of each character frequency = Counter(s) # Convert the frequency dictionary to a list of (char, frequency) pairs frequency_list = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Check if n is within the range of distinct characters if n > len(frequency_list): return \\"\\" # Return the nth most frequent character return frequency_list[n-1][0]"},{"question":"# Problem Statement You are given a string containing only lowercase alphabetical characters. Your task is to determine if this string can become a palindrome after deleting at most one character from it. A palindrome is a string that reads the same forward and backward. # Function to Implement Implement the function `can_form_palindrome(s: str) -> bool` in Python, where: * `s` is a string containing only lowercase alphabetical characters. # Input and Output * **Input**: A string `s` of lowercase alphabetical characters. * **Output**: Return `True` if the string can become a palindrome after deleting at most one character; otherwise, return `False`. # Constraints 1. The length of the string will be between `1` and `10^5` characters. # Examples ```python assert can_form_palindrome(\\"abca\\") == True assert can_form_palindrome(\\"racecar\\") == True assert can_form_palindrome(\\"abcdef\\") == False assert can_form_palindrome(\\"deeee\\") == True assert can_form_palindrome(\\"a\\") == True ``` # Performance Requirements * Your solution should efficiently handle strings up to the maximum length constraint, ensuring that the time complexity remains O(n). # Additional Notes Consider edge cases such as: * Single character strings. * Strings that are already palindromes. * Strings where the deletion of one specific character can result in a palindrome. * Handling strings with different levels of complexity properly within the constraints.","solution":"def can_form_palindrome(s: str) -> bool: Returns True if the string can become a palindrome by removing at most one character, otherwise False. def is_palindrome_range(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: # Check by skipping one character either from the start or the end return is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) start += 1 end -= 1 return True"},{"question":"# Coding Assessment Question You are given a list of strings and need to determine if a transformation is possible where each string can be made identical by rotating the characters. Objective: Write a function `can_become_identical(words: List[str]) -> bool` that takes a list of strings `words` and returns a boolean indicating whether all strings in the list can be made identical by rotating their characters. Input: - `words` (1 ≤ len(words) ≤ 10^4, 1 ≤ len(words[i]) ≤ 100): a list of strings of equal length. Output: - Returns `True` if all strings can be made identical by rotations, otherwise `False`. Example: ```python assert can_become_identical([\\"abc\\", \\"bca\\", \\"cab\\"]) == True assert can_become_identical([\\"abc\\", \\"def\\", \\"ghi\\"]) == False assert can_become_identical([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == True ``` Constraints: - All strings will have the same length. - The function should efficiently handle large inputs. Performance Requirements: - Ensure the solution has a time complexity of O(n * m) where n is the number of strings and m is the length of each string. - Avoid unnecessary computations and optimize for time and space. Hints: - Consider concatenating a string with itself and check for substrings. - Efficiently compare all strings to a base string to determine rotations.","solution":"from typing import List def can_become_identical(words: List[str]) -> bool: if not words: return True base = words[0] doubled_base = base + base for word in words[1:]: if word not in doubled_base: return False return True"},{"question":"# Summing Lists of Integers You are requested to sum multiple lists of integers, each containing several numbers. Design a function `sum_lists(lists: List[List[int]]) -> List[int]` that processes a list of lists of integers and returns a list of sums corresponding to each list. Input - `lists`: A list of lists where each inner list contains integers. Output - A single list containing the sum of integers for each inner list. Constraints - The input `lists` is assumed to be a non-empty list of lists. - Each inner list contains at least one integer. - The integers are within the range (-10^9) to (10^9). # Examples ```python >>> sum_lists([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) [6, 9, 30] >>> sum_lists([[10, 20, 30], [100, 200, 300], [1000]]) [60, 600, 1000] >>> sum_lists([[0, 0, 0], [1, -1], [5, 5, -10]]) [0, 0, 0] ``` Notes - Ensure that your function correctly handles empty inner lists by treating them as 0 sum. - You may use built-in functions like `sum` for simplicity.","solution":"from typing import List def sum_lists(lists: List[List[int]]) -> List[int]: Computes the sum of each inner list and returns a list of sums. Args: lists (List[List[int]]): A list of lists of integers. Returns: List[int]: A list containing the sum of integers in each inner list. return [sum(inner_list) for inner_list in lists]"},{"question":"**Check if List Contains Consecutive Integers** In this task, you are required to implement a function to determine if a given list of integers consists of a set of consecutive numbers, regardless of their order. # Function Signature ```python def is_consecutive(lst: list) -> bool: pass ``` # Input * `lst` (list): A list of integers which may or may not be consecutive. # Output * **Returns** (bool): `True` if the list contains consecutive integers, `False` otherwise. * **Raises**: `TypeError` if the list contains non-integer elements. # Constraints * The function should handle lists up to at least `10^5` elements. * The integers in the list can be both positive and negative. * Duplicate integers should not be present in the valid consecutive sequence. # Examples ```python >>> is_consecutive([5, 3, 4, 2, 1]) True >>> is_consecutive([10, 11, 13, 12, 14]) True >>> is_consecutive([3, 2, 1, 2]) False >>> is_consecutive([1, 2.5, 3]) Traceback (most recent call last): ... TypeError: List should only contain integers. >>> is_consecutive([3, 5, 6, 7]) False ``` # Guidelines 1. **Check Integers**: Ensure all elements in the list are integers. 2. **Determine Consecutiveness**: Verify if the elements in the list constitute a consecutive sequence. This can be done efficiently by checking if the difference between the maximum and minimum value plus one equals the length of the list and that all elements are unique. 3. **Performance**: The function should be optimized for performance to handle large lists within a reasonable timeframe. **Tasks**: 1. Implement the `is_consecutive` function based on the provided specifications. 2. Ensure your implementation handles edge cases gracefully and efficiently. 3. Include error handling to raise appropriate exceptions for invalid inputs.","solution":"def is_consecutive(lst: list) -> bool: Determine if the given list contains a set of consecutive integers. Parameters: lst (list): A list of integers. Returns: bool: True if lst contains consecutive integers, False otherwise. Raises: TypeError: If the list contains non-integer elements if not all(isinstance(x, int) for x in lst): raise TypeError(\'List should only contain integers.\') if len(lst) == 0: return False min_val = min(lst) max_val = max(lst) if max_val - min_val + 1 == len(lst) and len(set(lst)) == len(lst): return True return False"},{"question":"# Problem Scenario You are asked to design an inventory management system for a bookstore. The system needs to track the stock levels of various books and ensure no book goes out of stock without triggering a restocking alert. Each time a sale is made, the stock level should be updated accordingly, and if the stock level falls to or below a pre-defined threshold, the system should signal an alert for restocking. Write a class `BookInventory` to manage the inventory with the following methods: - `__init__(self, initial_stock: dict, restock_threshold: int)`: Initializes the inventory with a dictionary of book titles as keys and their stock levels as values, and sets the restock threshold. - `sell_book(self, book_title: str, quantity: int) -> bool`: Decreases the stock level of the specified book by the given quantity. Returns `True` if the stock level after sale is at or above zero, and `False` otherwise. - `check_restock_alert(self) -> List[str]`: Returns a list of book titles that need to be restocked (i.e., their stock levels are at or below the restock threshold). Function Signature ```python class BookInventory: def __init__(self, initial_stock: dict, restock_threshold: int): pass def sell_book(self, book_title: str, quantity: int) -> bool: pass def check_restock_alert(self) -> List[str]: pass ``` Input - `initial_stock` (dict): A dictionary where keys are book titles (str) and values are stock levels (int, ≥ 0). - `restock_threshold` (int): The stock level threshold for restocking alerts (0 ≤ `restock_threshold` ≤ 10^4). Output - The `sell_book` method returns: - `True` if the book stock level remains at or above zero after the sale. - `False` if the sale would result in negative stock levels. - The `check_restock_alert` method returns a list of book titles (List[str]) with stock levels at or below the restock threshold. Constraints - Assume all book titles in `initial_stock` are unique. - Stock level should never be negative; any sale attempt that would result in negative stock should not be processed. Examples ```python # Example Usage inventory = BookInventory({\\"Book A\\": 50, \\"Book B\\": 20, \\"Book C\\": 5}, restock_threshold=10) assert inventory.sell_book(\\"Book A\\", 5) == True assert inventory.sell_book(\\"Book B\\", 25) == False assert inventory.check_restock_alert() == [\\"Book B\\", \\"Book C\\"] inventory.sell_book(\\"Book C\\", 3) assert inventory.check_restock_alert() == [\\"Book B\\", \\"Book C\\"] ``` In this problem, you need to manage book inventory levels and issue alerts when the stock of any book falls to or below the specified threshold.","solution":"from typing import Dict, List class BookInventory: def __init__(self, initial_stock: Dict[str, int], restock_threshold: int): self.stock = initial_stock self.restock_threshold = restock_threshold def sell_book(self, book_title: str, quantity: int) -> bool: if book_title not in self.stock: return False if self.stock[book_title] < quantity: return False self.stock[book_title] -= quantity return True def check_restock_alert(self) -> List[str]: return [book for book, qty in self.stock.items() if qty <= self.restock_threshold]"},{"question":"# Data Compression Ratio Calculation Context In computer science, data compression techniques are employed to reduce the size of data for efficient storage and transmission. Compression ratio is an important metric that compares the size of the compressed data to the original data size. Problem Statement Create a function `calculate_compression_ratio` that takes in the size of the original data and the size of the compressed data, then returns the compression ratio and a classification based on the ratio. Function Signature ```python def calculate_compression_ratio( original_size: float, compressed_size: float ) -> tuple[str, float]: ``` Input - `original_size`: (float) The size of the original data in bytes. - `compressed_size`: (float) The size of the compressed data in bytes. Output - Returns a tuple containing: - A string with the classification of the compression: `\\"High Efficiency\\"`, `\\"Moderate Efficiency\\"`, or `\\"Low Efficiency\\"`. - The computed compression ratio (float). Constraints - `original_size` and `compressed_size` should both be positive non-zero values. Error Handling Raise a `ValueError` in case of: - Any parameter being zero or negative. Examples ```python >>> calculate_compression_ratio(original_size=1000, compressed_size=250) (\'High Efficiency\', 0.25) >>> calculate_compression_ratio(original_size=1000, compressed_size=750) (\'Moderate Efficiency\', 0.75) >>> calculate_compression_ratio(original_size=1000, compressed_size=950) (\'Low Efficiency\', 0.95) >>> calculate_compression_ratio(original_size=0, compressed_size=200) ValueError: Sizes must be positive and non-zero >>> calculate_compression_ratio(original_size=-100, compressed_size=300) ValueError: Sizes must be positive and non-zero ``` Classification: - **High Efficiency**: Compression ratio less than or equal to 0.3. - **Moderate Efficiency**: Compression ratio greater than 0.3 but less than or equal to 0.7. - **Low Efficiency**: Compression ratio greater than 0.7. Explanation: 1. **Calculate the compression ratio**: `compression_ratio = compressed_size / original_size`. 2. **Classify the efficiency** based on the pre-defined thresholds. 3. **Raise an error** if the input sizes are not positive and non-zero.","solution":"def calculate_compression_ratio(original_size: float, compressed_size: float) -> tuple[str, float]: Calculates the compression ratio based on the original and compressed sizes. Classifies the efficiency of compression. Args: - original_size (float): The size of the original data. - compressed_size (float): The size of the compressed data. Returns: - tuple[str, float]: A tuple containing the classification and compression ratio. Raises: - ValueError: If any of the sizes are not positive and non-zero. if original_size <= 0 or compressed_size <= 0: raise ValueError(\\"Sizes must be positive and non-zero\\") compression_ratio = compressed_size / original_size if compression_ratio <= 0.3: return (\\"High Efficiency\\", compression_ratio) elif compression_ratio <= 0.7: return (\\"Moderate Efficiency\\", compression_ratio) else: return (\\"Low Efficiency\\", compression_ratio)"},{"question":"# Data Structure Optimization Task Scenario You have been tasked with optimizing the performance of a frequently used data structure in your company\'s software application. The current implementation involves a sequence of operations on a list to manage items, specifically adding, removing, and retrieving the maximum element. Your goal is to replace the list with a more efficient data structure to improve the overall performance of these operations. Requirements Implement a class `OptimizedDataStructure` that supports the following methods: 1. `add(item: int) -> None`: Adds an integer item to the data structure. 2. `remove(item: int) -> None`: Removes an integer item from the data structure. 3. `get_max() -> int`: Retrieves the maximum integer present in the data structure. 4. `contains(item: int) -> bool`: Checks if the integer item is in the data structure. Constraints * Assume all items are unique integers. * The operations should be optimized for performance; specifically, `add`, `remove`, `get_max`, and `contains` should ideally have an average-case time complexity better than linear time, if possible. Function Signature ```python class OptimizedDataStructure: def __init__(self): self.data = [] def add(self, item: int) -> None: pass def remove(self, item: int) -> None: pass def get_max(self) -> int: pass def contains(self, item: int) -> bool: pass ``` Example ```python # Create an instance of the optimized data structure ods = OptimizedDataStructure() # Add elements to the data structure ods.add(3) ods.add(5) ods.add(1) # Retrieve the maximum element print(ods.get_max()) # Expected output: 5 # Check if certain elements are contained print(ods.contains(3)) # Expected output: True print(ods.contains(4)) # Expected output: False # Remove an element ods.remove(5) # Retrieve the maximum element again print(ods.get_max()) # Expected output: 3 ```","solution":"import heapq class OptimizedDataStructure: def __init__(self): self.data = [] self.max_heap = [] self.entry_finder = {} def add(self, item: int) -> None: if item not in self.entry_finder: heapq.heappush(self.data, item) heapq.heappush(self.max_heap, -item) self.entry_finder[item] = True def remove(self, item: int) -> None: if item in self.entry_finder: self.entry_finder.pop(item) def get_max(self) -> int: while self.max_heap and -self.max_heap[0] not in self.entry_finder: heapq.heappop(self.max_heap) return -self.max_heap[0] if self.max_heap else None def contains(self, item: int) -> bool: return item in self.entry_finder"},{"question":"# Coding Assessment Question **Context**: As part of building an efficient e-commerce platform, you need to keep track of product prices and frequently provide statistics over different time periods. You\'ll create a data structure that supports efficient updates and queries on product price changes. **Objective**: Write a class `PriceTracker` that utilizes a Fenwick Tree (Binary Indexed Tree) to manage product price changes. This class should support the following operations: 1. **Initialize**: `__init__(self, prices: List[int])` - Initializes the tracker with the list of product prices. 2. **Update**: `update(self, index: int, price: int)` - Updates the price of the product at a specified index. 3. **Range Sum Query**: `sum_query(self, left: int, right: int) -> int` - Returns the sum of prices in the range `[left, right]`. 4. **Range Min Query**: `min_query(self, left: int, right: int) -> int` - Returns the minimum price in the range `[left, right]`. **Input/Output Formats**: * **Input**: * Initialization: `__init__(self, prices: List[int]) - prices` (List of integers representing the initial product prices). * Update: `update(self, index: int, price: int) - index` (integer, 0-based), `price` (integer). * Queries: `sum_query(self, left: int, right: int)`, `min_query(self, left: int, right: int)` - `left` and `right` (integers representing the 0-based range). * **Output**: * Sum of prices in range [left, right] (integer). * Minimum price in range [left, right] (integer). **Performance Requirements**: * All operations should run in **O(log N)** time complexity, where N is the number of elements in the array. **Constraints**: * The initial list of prices will contain between 1 and 10^5 elements. * Price values will be in the range [1, 10^4]. * The number of update and query operations will be less than or equal to 10^5. **Example**: ```python # Initialize the price tracker prices = [100, 200, 300, 400, 500] tracker = PriceTracker(prices) # Perform update tracker.update(3, 350) # Update price at index 3 # Perform queries assert tracker.sum_query(1, 3) == 850 # 200 + 300 + 350 assert tracker.min_query(1, 4) == 200 ```","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ class PriceTracker: def __init__(self, prices): self.n = len(prices) self.prices = prices[:] self.fenwick_tree = FenwickTree(self.n) for i in range(self.n): self.fenwick_tree.update(i + 1, prices[i]) def update(self, index, price): delta = price - self.prices[index] self.prices[index] = price self.fenwick_tree.update(index + 1, delta) def sum_query(self, left, right): return self._prefix_sum(right) - self._prefix_sum(left - 1) def _prefix_sum(self, index): return self.fenwick_tree.query(index + 1) def min_query(self, left, right): return min(self.prices[left:right + 1])"},{"question":"# Pathfinding in a Grid with Obstacles You are implementing a robot\'s navigation system to find the shortest path from a starting position to a destination within a grid environment. The grid consists of `0`s (walkable cells) and `1`s (obstacles). The robot can move up, down, left, or right but cannot move diagonally. **Task**: 1. Implement a function to find the shortest path in the grid using the Breadth-First Search (BFS) algorithm. 2. Ensure that the function returns the path as a list of tuples representing the coordinates the robot needs to take to reach the destination. 3. If there is no valid path, the function should return an empty list. **Function Signature**: ```python def shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: pass ``` **Input Format**: - `grid`: A 2D list of integers where `0` represents a walkable cell and `1` represents an obstacle. - `start`: A tuple representing the starting cell coordinates `(x_start, y_start)`. - `end`: A tuple representing the destination cell coordinates `(x_end, y_end)`. **Output Format**: - A list of tuples where each tuple is a coordinate `(x, y)` indicating the path from start to end. - If no valid path exists, return an empty list. **Constraints**: - The dimensions of the grid can range from `1x1` to `100x100`. - The start and end positions will always be within the grid\'s bounds and will always be on walkable cells (`0`). **Example**: ```python grid = [ [0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0], ] start = (0, 0) end = (4, 4) # Expected Output path = shortest_path(grid, start, end) # path: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)] ``` Implement the `shortest_path` function to find the optimal path considering the above criteria.","solution":"from collections import deque def shortest_path(grid, start, end): if not grid or start == end: return [start] if start == end and grid[start[0]][start[1]] == 0 else [] rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (x, y), path = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == end: return path + [(nx, ny)] queue.append(((nx, ny), path + [(nx, ny)])) visited.add((nx, ny)) return []"},{"question":"Problem Statement You are tasked with implementing a function that takes a string representing a hexadecimal number (including optional leading/trailing whitespaces and an optional prefix \\"0x\\") and converts it into its corresponding decimal integer. # Function signature ```python def hex_to_decimal(hex_string: str) -> int: pass ``` # Input * A string `hex_string` (0 <= len(hex_string) <= 100) which may have leading and trailing whitespaces and may include the prefix \\"0x\\". # Output * Returns the corresponding decimal integer equivalent of the hexadecimal input string. # Constraints * If the input string is empty or contains characters that are not valid hexadecimal digits (ignoring leading \\"0x\\" prefix and whitespaces), raise a `ValueError` with an appropriate message as described below. # Error Messages * For empty input string, raise `ValueError` with the message: `\\"Empty string was passed to the function\\"` * For any non-hexadecimal values present in the string, raise `ValueError` with the message: `\\"Non-hexadecimal value was passed to the function\\"` # Example ```python assert hex_to_decimal(\\"1A\\") == 26 assert hex_to_decimal(\\" 0xFF \\") == 255 assert hex_to_decimal(\\"0x1A3\\") == 419 assert hex_to_decimal(\\"0\\") == 0 try: hex_to_decimal(\\"g\\") except ValueError as e: assert str(e) == \\"Non-hexadecimal value was passed to the function\\" try: hex_to_decimal(\\"\\") except ValueError as e: assert str(e) == \\"Empty string was passed to the function\\" try: hex_to_decimal(\\"0xG3\\") except ValueError as e: assert str(e) == \\"Non-hexadecimal value was passed to the function\\" ``` # Notes * Carefully handle leading and trailing whitespaces. * Consider the possibility of \\"0x\\" prefix. * Provide validation for non-hexadecimal and empty string inputs by raising the appropriate `ValueError`.","solution":"def hex_to_decimal(hex_string: str) -> int: Converts a hexadecimal string (with optional leading/trailing whitespaces and optional \\"0x\\" prefix) to its corresponding decimal integer. Args: hex_string (str): Hexadecimal string to convert to decimal. Returns: int: Decimal integer equivalent of hexadecimal string. Raises: ValueError: If the input string is empty or contains non-hexadecimal characters. if hex_string.strip() == \\"\\": raise ValueError(\\"Empty string was passed to the function\\") hex_string = hex_string.strip().lower() if hex_string.startswith(\\"0x\\"): hex_string = hex_string[2:] if any(c not in \\"0123456789abcdef\\" for c in hex_string): raise ValueError(\\"Non-hexadecimal value was passed to the function\\") return int(hex_string, 16)"},{"question":"# Binary Search Tree Balancing Context: A Binary Search Tree (BST) is a node-based binary tree data structure that has the following properties: the left subtree of a node contains only nodes with values less than the node\'s key, the right subtree of a node contains only nodes with values greater than the node\'s key, and both the left and right subtrees must also be binary search trees. However, a BST can become unbalanced and inefficient for operations if new nodes are inserted in a sorted order. Task: You need to write a function `balance_bst(root: TreeNode) -> TreeNode` that takes the root of a Binary Search Tree and balances it. You should create a balanced BST where the depth of the two subtrees of every node never differ by more than one. Requirements: 1. You must define a `TreeNode` class with `val`, `left`, and `right` attributes. 2. The function should correctly balance any valid Binary Search Tree it receives. 3. You may assume that no duplicate values exist in the tree. Input: * A `TreeNode` instance `root`, representing the root of the Binary Search Tree. The number of nodes in the tree can be between ( 1 ) and ( 10^4 ). Output: * A `TreeNode` instance representing the root of the balanced Binary Search Tree. Constraints: * Do not use Python\'s in-built balancing libraries or functions. * Your solution should handle large inputs efficiently. Examples: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: # Implementation will go here # Example 1: root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) new_root = balance_bst(root) # The tree must be balanced, and one possible balanced tree is: # 2 # / # 1 3 # Example 2: root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.right.right = TreeNode(20) new_root = balance_bst(root) # The tree must be balanced, and one possible balanced tree is: # 10 # / # 5 15 # # 20 ``` This question requires you to understand the Binary Search Tree properties, implement a balancing mechanism, and deal with tree data structures effectively. The task is comparable in complexity to the provided example, focusing both on algorithm design and data structure manipulation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Helper function for in-order traversal of BST and returns elements in sorted order. return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def sorted_array_to_bst(nums): Helper function that converts a sorted array to a balanced BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def balance_bst(root: TreeNode) -> TreeNode: Converts an unbalanced BST to a balanced BST by using in-order traversal and re-constructing the tree. sorted_values = inorder_traversal(root) return sorted_array_to_bst(sorted_values)"},{"question":"# Problem Statement You are given a class called `LinearRegression` that implements the basic functionality for a simple linear regression model. This class has a method `fit` which takes the training data as input and computes the parameters of the linear regression line. Additionally, the class has a method `predict` which takes a list of new feature values and returns the corresponding predictions based on the learned model. Your task is to implement a function `calculate_rmse` that computes the Root Mean Squared Error (RMSE) for the model\'s predictions on a given test dataset. The RMSE is a standard way to measure the error of a model in predicting quantitative data. # Function Specifications Function Signature ```python def calculate_rmse(model: LinearRegression, test_data: List[Tuple[float, float]]) -> float: ``` Input: - `model (LinearRegression)`: An instance of the `LinearRegression` class that has been trained using the `fit` method. - `test_data (List[Tuple[float, float]])`: A list of tuples where each tuple contains a feature value and the corresponding true label (i.e., `[(x1, y1), (x2, y2), ..., (xn, yn)]`). Output: - `float`: The RMSE value computed over the test dataset. # Constraints: - The LinearRegression model has already been trained (i.e., the `fit` method has been called). - The function should accurately compute the RMSE based on the model\'s predictions and the true labels. # Example ```python # Assuming you have a trained LinearRegression model as: train_data = [(1, 2), (2, 2.8), (3, 3.6)] model = LinearRegression() model.fit(train_data) test_data = [(4, 4.2), (5, 5.1), (6, 6.05)] rmse = calculate_rmse(model, test_data) print(rmse) # Output: some float value representing the RMSE ``` # Notes - You should leverage the properties and methods of the provided `LinearRegression` class without changing its internal implementation. - Consider readability and efficiency in your implementation. - Remember to handle edge cases such as empty test data lists or zero variance in test data.","solution":"import math from typing import List, Tuple class LinearRegression: def __init__(self): self.slope = 0 self.intercept = 0 def fit(self, data: List[Tuple[float, float]]): x_vals, y_vals = zip(*data) n = len(x_vals) x_mean = sum(x_vals) / n y_mean = sum(y_vals) / n numerator = sum((x - x_mean) * (y - y_mean) for x, y in data) denominator = sum((x - x_mean) ** 2 for x in x_vals) self.slope = numerator / denominator self.intercept = y_mean - self.slope * x_mean def predict(self, x_vals: List[float]) -> List[float]: return [self.slope * x + self.intercept for x in x_vals] def calculate_rmse(model: LinearRegression, test_data: List[Tuple[float, float]]) -> float: if not test_data: return 0.0 x_vals, y_true = zip(*test_data) y_pred = model.predict(list(x_vals)) mse = sum((y_t - y_p) ** 2 for y_t, y_p in zip(y_true, y_pred)) / len(test_data) rmse = math.sqrt(mse) return rmse"},{"question":"# Anagram Finder with Permutations **Context**: An anagram is a word or phrase that is formed by rearranging the letters of another word or phrase, typically using all the original letters exactly once. The challenge is to find all possible anagrams for a given word within a list of candidate words. **Task**: Write a program that finds all the anagrams of a given word from a list of candidate words. Your implementation should handle the following scenarios: 1. Check the word against each candidate to verify if it is an anagram. 2. Return a list of all matching anagrams in lexicographical order. 3. Ignore case while matching the anagrams. # Input: 1. A string ( word ) representing the word for which you need to find anagrams. 2. A list of strings ( candidates ) containing potential anagrams. # Output: - A list of strings, each string being an anagram of ( word ) found in ( candidates ). # Example: ```python Input: word = \\"Listen\\" candidates = [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"Silent\\"] Output: [\'inlets\', \'Silent\'] Input: word = \\"actor\\" candidates = [\\"cat\\", \\"toca\\", \\"ratoc\\", \\"Jazzz\\", \\"dalan\\"] Output: [\'toca\', \'ratoc\'] ``` **Constraints**: - All words and candidates contain only alphabetic characters. - Matching should be case-insensitive. - The output list should be sorted in lexicographical order. **Note**: - Ensure your solution handles cases where no anagrams are found by returning an empty list. - Consider performance aspects for cases where the length of the candidates list is very large.","solution":"def find_anagrams(word, candidates): Finds all anagrams of the given word from the list of candidate words. Args: - word (str): The word to find anagrams for. - candidates (list): List of candidate words. Returns: - list: A list of anagrams of the word found in candidates, sorted lexicographically. # Normalize the word by converting to lowercase and sorting the characters normalized_word = sorted(word.lower()) # List to store the anagrams found anagrams = [] for candidate in candidates: # Normalize the candidate word in the same way if sorted(candidate.lower()) == normalized_word: anagrams.append(candidate) # Return the list of anagrams, sorted lexicographically return sorted(anagrams)"},{"question":"# Task: First Missing Positive Integer in an Array Scenario: You are tasked with finding the first missing positive integer in an unsorted array of integers. The challenge is to implement it with a time complexity of O(n) and additional space complexity of O(1), i.e., without using extra space for another array. Problem Statement: Write a function `first_missing_positive(nums: List[int]) -> int` that, given an array of integers `nums`, returns the smallest missing positive integer. Input Format: - A list of integers `nums` which can include both positive and negative numbers. Output Format: - An integer representing the smallest missing positive integer. Constraints: - The length of the list `nums` is in the range [0, 10^5]. - The elements in `nums` are in the range [-10^6, 10^6]. Example: ```python first_missing_positive([1, 2, 0]) # returns 3 first_missing_positive([3, 4, -1, 1]) # returns 2 first_missing_positive([7, 8, 9, 11, 12]) # returns 1 ``` # Implementation Details: - You need to rearrange the elements in the array so that `nums[i]` contains `i+1` if possible. - Iterate through the list and place each number in its corresponding index (e.g., `num = 1` should go to index 0). Handle duplicates and negative numbers separately. - After rearranging, iterate through the list again to find the first index where `nums[i] != i+1`. - Return the missing positive integer based on this index position. Note: Detailed handling of index and value placement needs to be managed to adhere to O(1) additional space complexity.","solution":"def first_missing_positive(nums): Returns the smallest missing positive integer from the list nums. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_index = nums[i] - 1 nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Course Average Calculation You have been tasked with developing a function to calculate the average grades of students in a course. Each student has grades in different subjects, and some students may be missing grades for some subjects. **Problem Statement** Write a function `calculate_course_average` that computes the average grade for each student in a course, as well as the overall course average. The interface of the function is specified as follows: ```python def calculate_course_average(grades: dict) -> dict: Calculate the average grades for students and the overall course average. :param grades: dict, where keys are student names and values are dictionaries, with subject names as keys and grades as values (all values are floats). :return: dict, a dictionary with student names as keys and their average grades as values. Additionally, it should contain an \'overall_avg\' key representing the course average. pass ``` # Compute Averages 1. **Input Parameters**: - `grades`: A dictionary where each key is a student\'s name (string), and each value is another dictionary. This nested dictionary has subject names (strings) as keys and grades (floats) as values. 2. **Output**: - The function should return a dictionary where: - Each key is a student\'s name, and the corresponding value is their average grade (float). - There is an additional key `\'overall_avg\'` with the course average (float). # Requirements - Exclude subjects from average calculation for students missing grades in those subjects. - Compute each student\'s average grade by considering only the subjects they have grades for. - The overall course average should be the average of all individual student averages. # Example ```python >>> grades = { ... \'Alice\': {\'Math\': 90, \'Science\': 80, \'History\': 70}, ... \'Bob\': {\'Math\': 85, \'Science\': 95}, ... \'Charlie\': {\'Math\': 78, \'History\': 88} ... } >>> calculate_course_average(grades) {\'Alice\': 80.0, \'Bob\': 90.0, \'Charlie\': 83.0, \'overall_avg\': 84.33} ``` # Considerations - Edge cases where some students have no grades. - Ensure the overall average is rounded to two decimal places. Good luck and feel free to ask questions for clarification!","solution":"def calculate_course_average(grades): Calculate the average grades for students and the overall course average. :param grades: dict, where keys are student names and values are dictionaries, with subject names as keys and grades as values (all values are floats). :return: dict, a dictionary with student names as keys and their average grades as values. Additionally, it should contain an \'overall_avg\' key representing the course average. student_averages = {} for student, subjects in grades.items(): if subjects: average = sum(subjects.values()) / len(subjects) student_averages[student] = average if student_averages: overall_avg = sum(student_averages.values()) / len(student_averages) student_averages[\'overall_avg\'] = round(overall_avg, 2) else: student_averages[\'overall_avg\'] = 0.0 return student_averages"},{"question":"# Task Write a function that returns the first unique character in a given string using an efficient algorithm. # Requirements Create a function `first_unique_character` that takes a string as input and returns the index of the first non-repeating character. # Inputs: * `s` (string): A string of lowercase English letters. # Outputs: * The index of the first unique character in the string, or `-1` if there is no unique character. # Constraints: 1. The input string will contain only lowercase English letters. 2. The length of the string `s` will be enough to fit within typical interview constraints (1 <= len(s) <= 10^5). # Example ```python def first_unique_character(s: str) -> int: Find the first unique character in a string. Parameters: s (str): Input string Returns: int: The index of the first unique character or -1 if none exists Examples: >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 >>> first_unique_character(\\"solo\\") 0 >>> first_unique_character(\\"aabbccddeef\\") 10 pass # Test cases assert first_unique_character(\\"leetcode\\") == 0, \\"Test case 1 failed\\" assert first_unique_character(\\"loveleetcode\\") == 2, \\"Test case 2 failed\\" assert first_unique_character(\\"aabb\\") == -1, \\"Test case 3 failed\\" assert first_unique_character(\\"solo\\") == 0, \\"Test case 4 failed\\" assert first_unique_character(\\"aabbccddeef\\") == 10, \\"Test case 5 failed\\" print(\\"All test cases pass\\") ``` Implement the function `first_unique_character` according to the description and verify it against the provided test cases.","solution":"def first_unique_character(s: str) -> int: Find the first unique character in a string. Parameters: s (str): Input string Returns: int: The index of the first unique character or -1 if none exists from collections import Counter # Create a counter object to count occurrences of each character char_count = Counter(s) # Iterate over the string and return the index of the first unique character for idx, char in enumerate(s): if char_count[char] == 1: return idx # If no unique character is found, return -1 return -1"},{"question":"# Problem: Finding Unique Triplets Summing to Zero Task Write a function `find_triplets(nums: list) -> list` that identifies all unique triplets in the input list that sum up to zero. The triplets must be provided in ascending order, and the overall list of triplets must be sorted based on the first element of each triplet, followed by the second and third elements if the first elements are equal. Input - `nums` (list): A list of integers, which can contain both positive and negative numbers. Output - Returns a list of unique triplets (each represented as a list of three integers) that sum to zero. Constraints - The input list will have a maximum length of (10^4). - Each integer in the list will be between (-10^3) and (10^3). Function Signature ```python def find_triplets(nums: list) -> list: pass ``` Examples ```python >>> find_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([0, 0, 0]) [[0, 0, 0]] >>> find_triplets([1, 2, -2, -1]) [] ``` **Note**: Ensure your function handles edge cases like empty lists, lists with fewer than three elements, and lists with no valid triplets. Avoid using excessive nested loops to ensure the solution is efficient. Use appropriate data structures to manage and identify unique triplets.","solution":"def find_triplets(nums): Finds all unique triplets in the list which sum to zero. nums.sort() results = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip same element to avoid duplicate triplets left, right = i + 1, length - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: results.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return results"},{"question":"# Coding Assessment Question In a software application, you might need to process a list of integers to segregate the prime numbers from the non-prime ones, performing this task efficiently given the potential size of the data. Function Definition ```python def segregate_primes(arr: List[int]) -> Tuple[List[int], List[int]]: Given a list of integers, segregate them into two lists: one containing the prime numbers, and the other containing the non-prime numbers. Args: arr : List[int] : a list containing integer values. Returns: Tuple[List[int], List[int]] : a tuple containing two lists - the first list with prime numbers, and the second list with non-prime numbers from the input list. Constraints: - The input list may contain up to 10^6 elements. - Each integer in the list is within the range of 0 to 10^9. Example: >>> segregate_primes([10, 29, 15, 23, 8, 1]) ([29, 23], [10, 15, 8, 1]) >>> segregate_primes([2, 3, 4, 5, 6]) ([2, 3, 5], [4, 6]) ``` Detailed Requirements * Implement a helper function (e.g., `is_prime`) to check if a given integer is a prime number. * The function should implement a **Sieve of Eratosthenes** logic or a similar efficient algorithm for checking primality, ensuring it handles the large upper bounds of input values. * The primary function `segregate_primes` should iterate over the input list, use the helper function to determine if each integer is prime or non-prime, and accordingly segregate them into two lists. * Handle edge cases, such as zero, one, and very large numbers close to the upper constraint. * Ensure the function\'s performance is optimized for the upper limit of input list size and value range by properly managing the complexity of prime checking. By solving this problem, students will demonstrate their ability to work with prime number algorithms, efficient data processing techniques, and conditional logic implementations.","solution":"import math from typing import List, Tuple def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def segregate_primes(arr: List[int]) -> Tuple[List[int], List[int]]: Given a list of integers, segregate them into two lists: one containing the prime numbers, and the other containing the non-prime numbers. primes = [] non_primes = [] for num in arr: if is_prime(num): primes.append(num) else: non_primes.append(num) return primes, non_primes"},{"question":"# Sum of Unique Values in a List You are given a list of integers and your task is to write a Python function that will calculate the sum of all unique values in the list. A value is considered unique if it appears exactly once in the list. Function Signature ```python def sum_of_unique_values(numbers: List[int]) -> int: ``` Input - `numbers`: A list of integers. The length of the list will be between 1 and 1000, inclusive. Output - Return an integer representing the sum of all unique values in the input list. Constraints - The list can contain positive and negative integers, as well as zero. - Each integer in the list is in the range from `-1000` to `1000`. Example ```python >>> sum_of_unique_values([1, 2, 3, 2, 3, 4]) 4 >>> sum_of_unique_values([10, -10, 20, 20, 10]) -10 >>> sum_of_unique_values([5, 5, 5, 5]) 0 >>> sum_of_unique_values([1, 2, 3, 4, 5]) 15 ``` Explanation - In the first example, the unique values are `[1, 4]`. Their sum is `1 + 4 = 5`. - In the second example, the unique value is `-10`. - In the third example, all values appear more than once, so the sum is `0`. - In the fourth example, all values are unique and the sum is `1 + 2 + 3 + 4 + 5 = 15`. This function can use dictionary or collections module to count the occurrences of each integer and then sum up those which occur exactly once.","solution":"from typing import List def sum_of_unique_values(numbers: List[int]) -> int: from collections import Counter # Count occurrences of each number in the list counts = Counter(numbers) # Sum the values that appear exactly once unique_sum = sum(key for key, value in counts.items() if value == 1) return unique_sum"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental to computer science and are widely used in various applications. One of the common problems is sorting an array of integers. Each sorting algorithm has its own strengths and weaknesses in terms of time complexity and space complexity. Problem Write a Python function `custom_sort(arr)` that sorts an array of integers using a custom sorting algorithm. The custom sorting algorithm should sort the array in ascending order but maintain the position of any zero in the array. Expected Input and Output * **Input**: - `arr` (List[int]): A list of integers, which can include zeroes. The length of the list `1 <= len(arr) <= 10000` * **Output**: - Returns the sorted list of integers (List[int]) with zeros in their original positions. Constraints * Do not use any built-in sorting functions like `sorted()` or `sort()`. * The function should handle large lists efficiently. Performance Requirements * The solution should have a time complexity of O(n log n) in most cases. * The zeroes in the array must remain in their original positions. Example ```python def custom_sort(arr: List[int]) -> List[int]: Return the list sorted in ascending order while maintaining the position of zeros. :param arr: List[int]: The list of integers to be sorted. :return: List[int]: The sorted list with zeroes in their original positions. >>> custom_sort([0, 3, 1, 0, 2, 5, 4, 0]) [0, 1, 2, 0, 3, 4, 5, 0] >>> custom_sort([4, 0, 7, 0, 2, 5]) [2, 0, 4, 0, 5, 7] >>> custom_sort([0, 0, 1]) [0, 0, 1] # TODO: Implement this function pass # Test the function with various inputs print(custom_sort([0, 3, 1, 0, 2, 5, 4, 0])) # Output should be [0, 1, 2, 0, 3, 4, 5, 0] print(custom_sort([4, 0, 7, 0, 2, 5])) # Output should be [2, 0, 4, 0, 5, 7] print(custom_sort([0, 0, 1])) # Output should be [0, 0, 1] ``` Your solution should demonstrate: * Implementation of a custom sorting algorithm. * Accurate preservation of zero positions while sorting other elements. * Efficient handling of large lists.","solution":"def custom_sort(arr): Return the list sorted in ascending order while maintaining the position of zeros. :param arr: List[int]: The list of integers to be sorted. :return: List[int]: The sorted list with zeroes in their original positions. # Store the original positions of all zeroes zero_positions = [i for i, x in enumerate(arr) if x == 0] # Filter out the zeroes and sort the remaining elements non_zero_elements = [x for x in arr if x != 0] sorted_non_zero_elements = merge_sort(non_zero_elements) # Using merge sort for an O(n log n) complexity # Rebuild the list with sorted elements and zeros at original positions result = [] sorted_index = 0 for i in range(len(arr)): if i in zero_positions: result.append(0) else: result.append(sorted_non_zero_elements[sorted_index]) sorted_index += 1 return result def merge_sort(arr): Helper function to perform merge sort on the list. :param arr: List[int]: The list of integers to be sorted. :return: List[int]: The sorted list. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Helper function to merge two sorted lists. :param left: List[int]: The left half of the list. :param right: List[int]: The right half of the list. :return: List[int]: The merged sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Longest Path in a Binary Tree Objective: Implement a function that calculates the longest path, in terms of the number of edges, between any two nodes in a binary tree. Context: In the analysis of network structures or hierarchies, finding the longest path between any two connected points helps determine the diameter of the structure. This can be crucial in developing efficient communication protocols and understanding data traversal in hierarchical storage systems. Problem Statement: Given a binary tree, the task is to determine the longest path in terms of the number of edges between two nodes. You need to write a function `longest_path` which takes the root of the binary tree and returns the length of this path in terms of edges. Function Signature: ```python def longest_path(root: TreeNode | None) -> int: ``` Input: - `root`: A TreeNode representing the root of the binary tree. Each TreeNode has `val`, `left`, and `right` attributes. Output: - An integer representing the length of the longest path in terms of the number of edges. Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - -10^4 <= Node.val <= 10^4. Example: ```python # Example binary tree # 1 # / # 2 3 # / # 4 5 t1 = TreeNode(1) t1.left = TreeNode(2) t1.right = TreeNode(3) t1.left.left = TreeNode(4) t1.left.right = TreeNode(5) print(longest_path(t1)) # Output should be 3 (path: 4 -> 2 -> 1 -> 3 or 5 -> 2 -> 1 -> 3) t2 = TreeNode(1) print(longest_path(t2)) # Output should be 0 (since there is no path beyond one node) t3 = TreeNode(1) t3.left = TreeNode(2) t3.right = TreeNode(3) t3.left.left = TreeNode(4) t3.right.right = TreeNode(5) print(longest_path(t3)) # Output should be 3 (path: 4 -> 2 -> 1 -> 3 or 1 -> 3 -> 5) ``` Note: - Do not assume limited tree heights. - Ensure to cover multiple edge cases including skewed trees and singular node trees in your implementation. The solution should efficiently handle trees with a large number of nodes and return the correct longest path length within allowable computational limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path(root: TreeNode | None) -> int: Calculate the longest path in terms of number of edges between any two nodes in a binary tree. :param root: TreeNode | None: The root of the binary tree. :return: int: The length of the longest path in terms of edges. def dfs(node): nonlocal max_diameter if not node: return 0 left = dfs(node.left) right = dfs(node.right) # Update the maximum diameter if necessary max_diameter = max(max_diameter, left + right) # Return the height of the current node return max(left, right) + 1 max_diameter = 0 dfs(root) return max_diameter"},{"question":"# Problem Statement Occasionally, devices logging data may experience sudden power failures, leading to partial or corrupted entries. Given a log file containing entries of device readings, you need to extract only the valid entries by identifying and removing corrupted data, essentially cleaning the log. An entry is considered valid if it adheres to the format: - It contains exactly three comma-separated values. - The first value is a non-negative integer that represents the timestamp. - The second value is a float that represents the sensor reading. - The third value is a string with a length between 1 and 5 characters that represents the status. Partial or malformed entries occur due to power failures or erroneous data write cycles, and should be ignored. Task Write a function `clean_log` that takes a string of log entries separated by newlines and returns a string of cleaned entries, also separated by newlines. Function Signature ```python def clean_log(log: str) -> str: ``` Input * `log` (str): A string containing multiple log entries separated by newlines. Output * Returns a string with valid entries, each separated by a newline. Constraints * Each line in the log either adheres to the valid entry format or is corrupted. * The returned clean log should preserve the order of the valid entries as they appeared in the original log. Example Usage ```python >>> log_data = \\"123,45.6,ABn789,23.4,Aninvalid entryn456,78.9,Xn123.45,67.8,ABCDn905,12.3,ERRORn100,200.1\\" >>> clean_log(log_data) \'123,45.6,ABn789,23.4,An456,78.9,Xn905,12.3,ERROR\' >>> log_data = \\"10,20.5,OKn20.5,20.5,OKn30,40.1,SUSPENDEDn5,15.0,Fn100,98.76,R\\" >>> clean_log(log_data) \'10,20.5,OKn30,40.1,SUSPENDEDn5,15.0,Fn100,98.76,R\' >>> log_data = \\"12,invalid,entryn34,56.7,ABnbad,entry,checkn78,56.4,ACn67,89.1,ERR\\" >>> clean_log(log_data) \'34,56.7,ABn78,56.4,ACn67,89.1,ERR\' ``` Notes - Ensure your function accurately filters out only valid entries according to the specified format. - Assume that the log entries can be in any valid string format and may include a mixture of valid and invalid lines. - The function should be efficient while processing potentially large logs.","solution":"def clean_log(log: str) -> str: Takes a string of log entries separated by newlines and returns a string of cleaned entries, also separated by newlines, by removing invalid entries. cleaned_entries = [] for line in log.split(\\"n\\"): parts = line.split(\\",\\") if len(parts) != 3: continue timestamp, reading, status = parts if not timestamp.isdigit(): continue try: float(reading) except ValueError: continue if not (1 <= len(status) <= 5): continue cleaned_entries.append(line) return \\"n\\".join(cleaned_entries)"},{"question":"# Problem Statement: Unique Character Count in a Rotated String You are required to implement a function that determines the number of unique characters present in any rotation of a given string. Two rotations of a string `s` are defined as two strings obtained by rotating `s` to the left or right any number of times. Function Specification **Function Name**: `count_unique_chars_in_rotations` **Parameters**: - `s` (str): The input string. **Returns**: - An integer representing the number of unique characters that appear in any rotation of the string. **Constraints**: - The input string `s` can contain both uppercase and lowercase English letters and digits. - The length of the string `s` will be between 1 and 1000 inclusive. **Example Usage**: ```python count_unique_chars_in_rotations(\'abcd\') # Expected Output: 4 count_unique_chars_in_rotations(\'aabb\') # Expected Output: 2 count_unique_chars_in_rotations(\'a\') # Expected Output: 1 count_unique_chars_in_rotations(\'AaBb\') # Expected Output: 4 ``` # Explanation: - For the input `\'abcd\'`, any rotation will have the same characters, which are \'a\', \'b\', \'c\', and \'d\', so the unique character count is 4. - For the input `\'aabb\'`, all rotations will include the characters \'a\' and \'b\' only, so the unique character count remains 2. - For the input `\'a\'`, any rotation will simply be \'a\', making the unique character count 1. - For the input `\'AaBb\'`, the characters \'A\', \'a\', \'B\', \'b\' are unique and distinct in any rotation, hence the count is 4. Write a function to solve this problem, ensuring that you handle edge cases, such as strings with varying character cases and strings consisting solely of repeated characters.","solution":"def count_unique_chars_in_rotations(s): Returns the number of unique characters in any rotation of the given string. return len(set(s))"},{"question":"Binary Tree Depth Calculation Objective You are given the partial implementation of a Binary Tree. Your task is to complete the implementation by providing code for the `calculate_depth` method that computes the maximum depth (height) of the binary tree. Problem Statement A `BinaryTree` is a tree data structure in which each node has at most two children referred to as the left child and the right child. You need to implement an additional method: 1. **`calculate_depth(self)`** * **Description**: This method computes the maximum depth (height) of the binary tree from the root node to the farthest leaf node. * **Input**: None * **Output**: An integer representing the maximum depth of the binary tree. Constraints: 1. The tree may contain duplicate integer values. 2. The tree may be empty (with no nodes). 3. The depth of an empty tree is defined as 0. Performance Requirements: The calculate_depth operation should take (O(n)) time complexity, where (n) is the number of nodes in the tree. Below is the scaffold of the `BinaryTree` class. You need to complete the `calculate_depth` method as described above. ```python class BinaryTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def calculate_depth(self) -> int: def _depth(node: BinaryTreeNode) -> int: if not node: return 0 left_depth = _depth(node.left) right_depth = _depth(node.right) return max(left_depth, right_depth) + 1 return _depth(self.root) ``` # Example Usage ```python # Create a BinaryTree and insert values tree = BinaryTree() tree.root = BinaryTreeNode(1) tree.root.left = BinaryTreeNode(2) tree.root.right = BinaryTreeNode(3) tree.root.left.left = BinaryTreeNode(4) tree.root.left.right = BinaryTreeNode(5) # Calculate the depth of the tree depth = tree.calculate_depth() print(depth) # Should print 3, as the maximum depth is 3 ``` # Additional Notes - The `BinaryTreeNode` class represents individual nodes within the binary tree. - The `BinaryTree` class facilitates tree-wide operations, such as calculating depth. - This problem tests the understanding of tree traversal techniques and recursive algorithms.","solution":"class BinaryTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def calculate_depth(self) -> int: def _depth(node: BinaryTreeNode) -> int: if not node: return 0 left_depth = _depth(node.left) right_depth = _depth(node.right) return max(left_depth, right_depth) + 1 return _depth(self.root)"},{"question":"# Graph Cycle Detection You need to implement an algorithm to detect cycles in a directed graph. Concretely, your task is to determine whether a given directed graph contains any cycles. Scenario: Consider a project management application where tasks are represented as nodes and dependencies between tasks are represented as directed edges. Your goal is to identify cycles in the dependency graph which would imply a circular dependency and thus render the project plan invalid. Requirements: 1. **Class Definition**: Define a class `Graph` with appropriate methods. 2. **Initialization**: * The graph should be initialized with an empty adjacency list. 3. **Add Edge Method**: * Implement an `add_edge` method to add a directed edge from one node to another (from `node1` to `node2`). 4. **Cycle Detection**: * Implement a `has_cycle` method to determine if the graph contains any cycles. 5. **Performance**: Optimize the solution to achieve the best possible time complexity for cycle detection. Input and Output Formats: * **Input**: * `add_edge` method: Takes two arguments `node1` and `node2`. * `has_cycle` method: Takes no arguments. * **Output**: * `has_cycle` method: Returns `True` if a cycle is detected, otherwise `False`. Constraints: * Node values can be any hashable data type supported by Python. * Assume that there are no duplicate edges or self-loops in the initial inputs. Example Usage: ```python graph = Graph() graph.add_edge(\'A\', \'B\') graph.add_edge(\'B\', \'C\') graph.add_edge(\'C\', \'D\') print(graph.has_cycle()) # Output: False graph.add_edge(\'D\', \'B\') print(graph.has_cycle()) # Output: True ``` Implementation Hint: Consider using Depth-First Search (DFS) for cycle detection in a directed graph. Use color-coding or recursion stack approaches to keep track of visited nodes and detect back edges.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, node1, node2): if node1 not in self.adjacency_list: self.adjacency_list[node1] = [] self.adjacency_list[node1].append(node2) def has_cycle(self): visited = set() recursion_stack = set() def dfs(node): if node in recursion_stack: return True if node in visited: return False visited.add(node) recursion_stack.add(node) for neighbor in self.adjacency_list.get(node, []): if dfs(neighbor): return True recursion_stack.remove(node) return False for node in self.adjacency_list: if dfs(node): return True return False"},{"question":"# Coding Assessment Question: **Scenario**: You are developing a program that involves processing numerical data from an environmental sensor network. One of the requirements is to analyze temperatures recorded at multiple locations and determine specific metrics. **Problem Statement**: Write two functions to compute required metric values from the recorded temperature readings. 1. **Function 1: `temperature_extremes`** Input: - `temperatures` (list of float): A list of temperature readings from various locations in degrees Celsius. Output: - `tuple`: A tuple containing two floats — the smallest (minimum) and the highest (maximum) temperatures from the input list. Constraints: - The input list should contain at least one temperature reading, otherwise raise a `ValueError`. 2. **Function 2: `average_temperature_above`** Input: - `temperatures` (list of float): A list of temperature readings from various locations in degrees Celsius. - `threshold` (float): A temperature threshold in degrees Celsius. Output: - `float`: The average temperature of all readings above the given threshold. Constraints: - The input list should contain at least one temperature reading, otherwise raise a `ValueError`. - If no temperatures are above the threshold, return 0.0 as the average. **Example:** ```python # Example of temperature_extremes print(temperature_extremes([16.4, 21.6, 25.0, 19.8])) # Output: (16.4, 25.0) print(temperature_extremes([-5.5, 0.0, 10.0, 5.5])) # Output: (-5.5, 10.0) # Example of average_temperature_above print(average_temperature_above([16.4, 21.6, 25.0, 19.8], 20.0)) # Output: 23.3 print(average_temperature_above([5.0, -3.0, 12.3, 9.8], 10.0)) # Output: 12.3 ``` **Performance Requirements**: - The `temperature_extremes` function should run in linear time with respect to the length of the input list, with time complexity O(n) and space complexity O(1). - Similarly, the `average_temperature_above` function should also run in linear time with respect to the length of the input list, with time complexity O(n) and space complexity O(1). **Note**: Ensure that the input list is validated to have at least one element, and proper exceptions are raised for any invalid inputs.","solution":"def temperature_extremes(temperatures): Returns the smallest and highest temperature from the input list. Raises a ValueError if the input list is empty. if not temperatures: raise ValueError(\\"Temperature list must contain at least one reading.\\") return min(temperatures), max(temperatures) def average_temperature_above(temperatures, threshold): Returns the average temperature of all readings above the given threshold. Returns 0.0 if no reading is above the threshold. Raises a ValueError if the input list is empty. if not temperatures: raise ValueError(\\"Temperature list must contain at least one reading.\\") above_threshold = [temp for temp in temperatures if temp > threshold] if not above_threshold: return 0.0 return sum(above_threshold) / len(above_threshold)"},{"question":"# Boolean Expression Validator You need to implement a Boolean expression validator that checks whether a given string is a valid Boolean expression. A valid Boolean expression consists of the characters \'T\' (true), \'F\' (false), \'&\' (AND), \'|\' (OR), \'!\' (NOT), and parentheses. The expression should adhere to the correct usage of parentheses and operators. Function: `validate_boolean_expression` Write a function to validate whether the given Boolean expression string is well-formed. ```python def validate_boolean_expression(expression: str) -> bool: Validate if the given string is a well-formed Boolean expression. Parameters: expression (str): The Boolean expression string. Returns: bool: True if the expression is valid, False otherwise. Raises: TypeError: If the input expression is not a string. pass ``` # Constraints * The input `expression` will be a string of length between 1 and 1000. * The expression will only contain the characters \'T\', \'F\', \'&\', \'|\', \'!\', \'(\', and \')\'. * Ensure the expression follows valid Boolean logic syntax, including correct usage of parentheses and operators. * An empty expression is considered invalid. # Performance Requirements * The function should operate with reasonable time and space complexity relevant to the constraints. Valid Boolean Expressions * \\"T\\" * \\"F\\" * \\"!T\\" * \\"T&F\\" * \\"T|F\\" * \\"(T)\\" * \\"(T&F)\\" * \\"!(T|F)\\" * \\"((T&F)|(T|!F))\\" Invalid Boolean Expressions * \\"TF\\" * \\"T&\\" * \\"&T\\" * \\"|F\\" * \\"T|F&\\" * \\"(T&F\\" * \\"T&F)\\" * \\"(!T&F\\" Example Usage ```python assert validate_boolean_expression(\\"T\\") == True assert validate_boolean_expression(\\"F\\") == True assert validate_boolean_expression(\\"!(T|F)\\") == True assert validate_boolean_expression(\\"T&F)\\") == False assert validate_boolean_expression(\\"T&|F\\") == False assert validate_boolean_expression(\\"T&F|\\") == False assert validate_boolean_expression(\\"\\") == False ```","solution":"def validate_boolean_expression(expression: str) -> bool: Validate if the given string is a well-formed Boolean expression. Parameters: expression (str): The Boolean expression string. Returns: bool: True if the expression is valid, False otherwise. Raises: TypeError: If the input expression is not a string. if not isinstance(expression, str): raise TypeError(\\"The input expression must be a string.\\") if len(expression) == 0: return False valid_chars = {\'T\', \'F\', \'&\', \'|\', \'!\', \'(\', \')\'} # Check for invalid characters if any(char not in valid_chars for char in expression): return False # Stack to track parentheses stack = [] # Variables to track previous and current characters prev_char = \\"\\" for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() elif char in {\'T\', \'F\'}: if prev_char and prev_char in {\'T\', \'F\', \')\'}: return False elif char in {\'&\', \'|\'}: if prev_char in {\'&\', \'|\', \'\', \'(\', \'!\'}: return False elif char == \'!\': if prev_char and prev_char in {\'T\', \'F\', \')\'}: return False prev_char = char if stack: return False if prev_char in {\'&\', \'|\', \'!\', \'(\'}: return False return True"},{"question":"# Weather Data Aggregation In this task, you are required to implement a function that aggregates weather data from multiple sources, ensuring the data is current and accurately represents the latest weather update. Each source provides weather data in a different format, and the task involves normalizing and combining this data. Requirements: - Implement a function to fetch weather data from multiple sources, each returning data in a specific format. - Aggregate the data to provide a consolidated view, showing the average temperature, humidity, and weather condition. - Handle errors gracefully by falling back to the next available source if one service is down or returns invalid data. - Use a caching mechanism to store the most recent valid data for a duration of 10 minutes to avoid excessive API calls. Function Signature: ```python def aggregate_weather_data(sources: list, cache: dict) -> dict: Aggregate weather data from multiple sources. Parameters: sources (list): A list of source APIs providing weather data. cache (dict): A dictionary to store the cached weather data with a timestamp. Returns: dict: A dictionary with the aggregated weather data or an error message. ``` Constraints: - Each source function in the `sources` list takes no arguments and returns a dictionary with keys: `temperature`, `humidity`, `condition`. - Each weather attribute (temperature, humidity) should be averaged across available sources. - If all sources fail, return a dictionary with an error message. - Ensure the cache is utilized efficiently to minimize API calls within the 10-minute window. Example Usage: ```python import time cache = {} def source_one(): return {\\"temperature\\": 72, \\"humidity\\": 55, \\"condition\\": \\"Sunny\\"} def source_two(): return {\\"temperature\\": 75, \\"humidity\\": 50, \\"condition\\": \\"Partly Cloudy\\"} sources = [source_one, source_two] # First call should fetch from both sources print(aggregate_weather_data(sources, cache)) # Subsequent call within 10 minutes should use cache time.sleep(300) print(aggregate_weather_data(sources, cache)) ``` Performance Requirements: - The function should efficiently handle memory used for caching weather data. - Ensure that the function can handle concurrent requests gracefully, maintaining accurate cache updates.","solution":"import time def aggregate_weather_data(sources, cache): Aggregate weather data from multiple sources. Parameters: sources (list): A list of source APIs providing weather data. cache (dict): A dictionary to store the cached weather data with a timestamp. Returns: dict: A dictionary with the aggregated weather data or an error message. current_time = time.time() if cache and (current_time - cache.get(\'timestamp\', 0)) < 600: return cache[\'data\'] temperature_sum = 0 humidity_sum = 0 conditions = [] valid_source_count = 0 for source in sources: try: data = source() temperature_sum += data[\'temperature\'] humidity_sum += data[\'humidity\'] conditions.append(data[\'condition\']) valid_source_count += 1 except Exception as e: continue if valid_source_count == 0: return {\'error\': \'All sources failed.\'} aggregated_data = { \'temperature\': temperature_sum / valid_source_count, \'humidity\': humidity_sum / valid_source_count, \'condition\': \' & \'.join(conditions) } cache[\'data\'] = aggregated_data cache[\'timestamp\'] = current_time return aggregated_data"},{"question":"# Implement a Circular Buffer Create a `CircularBuffer` class that implements a fixed-size circular buffer. The buffer should support inserting and retrieving elements in a First-In-First-Out (FIFO) manner. Once the buffer is full, new insertions should overwrite the oldest data. # Class Definition ```python class CircularBuffer: def __init__(self, capacity: int): pass def write(self, value: int) -> None: pass def read(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass ``` # Methods Description - `__init__(self, capacity: int)`: Initialize the buffer with the specified capacity. - `write(self, value: int) -> None`: Insert an integer `value` into the buffer. If the buffer is full, overwrite the oldest element. - `read(self) -> int`: Remove and return the oldest element in the buffer. If the buffer is empty, raise an exception or return a specific error value. - `is_empty(self) -> bool`: Return `True` if the buffer is empty, `False` otherwise. - `is_full(self) -> bool`: Return `True` if the buffer is full, `False` otherwise. # Example ```python cb = CircularBuffer(3) assert cb.is_empty() == True assert cb.is_full() == False cb.write(1) cb.write(2) cb.write(3) assert cb.is_full() == True assert cb.read() == 1 assert cb.read() == 2 assert cb.is_empty() == False assert cb.is_full() == False cb.write(4) cb.write(5) assert cb.read() == 3 assert cb.read() == 4 assert cb.read() == 5 assert cb.is_empty() == True try: cb.read() except Exception as e: assert str(e) == \\"Buffer is empty\\" ``` # Additional Notes - The circular buffer should efficiently handle wrap-around behavior. - Ensure all methods run in constant time, O(1).","solution":"class CircularBuffer: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def write(self, value: int) -> None: if self.is_full(): self.head = (self.head + 1) % self.capacity else: self.size += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.capacity def read(self) -> int: if self.is_empty(): raise Exception(\\"Buffer is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.size -= 1 return value def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Problem Statement You are given a 2D grid of dimensions `n x m`, consisting of binary values (0s and 1s). A binary cell is considered \\"active\\" if it contains a 1, and \\"inactive\\" if it contains a 0. Your task is to determine the number of distinct \\"islands\\" in the grid. An island is considered a group of connected active cells (1s) connected horizontally or vertically but not diagonally. **Function Signature**: ```python def count_islands(grid: List[List[int]]) -> int: ``` # Input: - `grid`: A list of lists of integers where each element is either 0 or 1 representing the 2D grid. # Output: - Returns an integer representing the number of distinct islands in the given grid. # Constraints: - `1 <= n, m <= 50` (The grid size is fairly small but not trivial) # Example: ```python assert count_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 1, 1, 0, 0] ]) == 3 assert count_islands([ [1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 1, 0], [1, 1, 0, 0] ]) == 4 ``` # Additional Information: - An island consists of a group of connected \\"1s\\" and is surrounded by \\"0s\\" or the grid boundary. - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the grid. - The grid may contain multiple separate islands, of varying shapes and sizes. - Ensure your solution is efficient and handles edge cases appropriately. # Note: - The concept of \\"distinct islands\\" implies no overlap between groups of connected cells. - Focus on the correct traversal and marking of visited cells to avoid counting the same island multiple times.","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Mark as visited # Explore neighboring cells (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) if not grid: return 0 island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_count += 1 dfs(i, j) return island_count"},{"question":"Array Intersection Task # Objective You are required to implement a function to compute the intersection of two lists of integers. The resulting list of the intersection should contain unique elements that are present in both input lists. # Problem Statement Write a function `intersection(arr1: list[int], arr2: list[int]) -> list[int]` that finds the intersection of two lists and returns a list of unique integers that exist in both lists. # Implementation Details 1. **Input**: Two lists of integers, `arr1` and `arr2`. 2. **Output**: A sorted list of unique integers that are present in both input lists. # Function Signature ```python def intersection(arr1: list[int], arr2: list[int]) -> list[int]: pass ``` # Constraints 1. Both input lists can contain both positive and negative integers. 2. Input lists may not be sorted. 3. Ensure the function operates efficiently, particularly for large inputs. # Example ```python example1 = ([4, 9, 5], [9, 4, 9, 8, 4]) example2 = ([1, 2, 2, 1], [2, 2]) assert intersection(example1[0], example1[1]) == [4, 9] assert intersection(example2[0], example2[1]) == [2] ``` # Description The function `intersection` should: 1. Convert each list to a set to facilitate O(1) average time complexity for membership checks. 2. Use set intersection to find common elements between both sets. 3. Convert the resulting set to a sorted list before returning it. Follow these steps: 1. Convert both input lists to sets, `set1` and `set2`. 2. Find the intersection of `set1` and `set2`. 3. Convert the resulting set to a list and sort it. 4. Return the sorted list of the intersection result. # Notes - The function should handle edge cases such as empty input lists, lists with no common elements, and lists with all elements in common. - Efficiently handle large lists by leveraging set operations. Ensure that your implementation passes all given test cases and performs efficiently even for larger input sizes.","solution":"def intersection(arr1, arr2): Returns the sorted list of unique integers that are present in both input lists. set1 = set(arr1) set2 = set(arr2) intersection_set = set1.intersection(set2) return sorted(intersection_set)"},{"question":"**Context**: Binary search is a fundamental algorithm in computer science, known for its efficiency in searching sorted arrays. It achieves logarithmic time complexity, making it suitable for large datasets. # Problem Statement Implement an iterative version of the binary search algorithm that finds the position of a target element within a sorted list of integers. If the target does not exist in the list, the function should return -1. # Requirements * **Function Name**: `binary_search_iterative` * **Input**: A sorted list of integers `arr` and an integer `target` * **Output**: An integer representing the index of `target` in `arr`, or -1 if `target` is not found # Constraints - Implement the algorithm iteratively. - The function should return -1 if the `target` is not present in the array. # Performance - Time complexity should be O(log n). - Space complexity should be O(1). # Example ```python def binary_search_iterative(arr: list, target: int) -> int: # Your code here # Examples: print(binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 6)) # Output: 5 print(binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)) # Output: -1 print(binary_search_iterative([], 4)) # Output: -1 ``` # Special Considerations - Ensure the function handles cases where the list is empty. - Make sure to handle cases where the array contains a single element. - Validate that the input list is sorted before performing the binary search. If the list is not sorted, the function should return -1. # Testing Create a series of unit tests to validate your function under different scenarios including edge cases such as empty lists, single-element lists, and lists where the target exists at different positions within the list.","solution":"def binary_search_iterative(arr: list, target: int) -> int: Perform an iterative binary search to find the index of the target element in a sorted list. :param arr: List of sorted integers. :param target: Integer target value to search for. :return: Index of the target element if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement You need to create a function that determines the minimum number of operations required to convert a given string `s` into another string `t`, where both strings consist of only lowercase letters. The allowed operations are: 1. Inserting a character 2. Deleting a character 3. Replacing a character This is a classic problem known as \\"Edit Distance\\" or \\"Levenshtein Distance.\\" # Function Signature ```python def edit_distance(s: str, t: str) -> int: ``` # Input * `s` (str): A string consisting of lowercase English letters (1 ≤ len(s) ≤ 1000). * `t` (str): A string consisting of lowercase English letters (1 ≤ len(t) ≤ 1000). # Output * An integer representing the minimum number of operations required to transform `s` into `t`. # Constraints - Both `s` and `t` will be non-empty strings consisting of lowercase English letters. - The length of `s` and `t` will be at most 1000. # Example ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"intention\\", \\"execution\\") == 5 ``` # Hints 1. Consider using dynamic programming to store the results of subproblems. 2. Create a 2D list `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `s` and the first `j` characters of `t`. 3. The value of `dp[i][j]` can be determined by considering the operations needed to transform the first `i-1` characters of `s` into the first `j-1` characters of `t`.","solution":"def edit_distance(s: str, t: str) -> int: Compute the minimum number of operations required to convert string s into string t. Operations allowed: Insert, Delete, Replace. :param s: Source string. :param t: Target string. :return: Minimum number of operations required to convert s to t. m, n = len(s), len(t) # Create a 2D dp array to store the result of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Problem Statement: You are assigned the task of designing a robust and efficient system to track the stock prices of multiple companies over time. Your system must support the following functionalities: 1. **Add Stock Price**: Insert a stock price at a given time. 2. **Get Latest Price**: Retrieve the latest stock price added for a specific company. 3. **Get Maximum Price**: Retrieve the highest stock price for a specific company during a specified period. 4. **Get Minimum Price**: Retrieve the lowest stock price for a specific company during a specified period. # Data Structure Design: Implement the following classes with the specified functionalities: 1. **StockSystem**: - `add_stock_price(company_name: str, time: int, price: int) -> None`: Adds a stock price for the given company at the specified time. - `get_latest_price(company_name: str) -> int`: Returns the latest stock price for the specified company. If no data is present, return `-1`. - `get_maximum_price(company_name: str, start_time: int, end_time: int) -> int`: Returns the highest stock price for the specified company within the given time range [start_time, end_time]. If no data is present, return `-1`. - `get_minimum_price(company_name: str, start_time: int, end_time: int) -> int`: Returns the lowest stock price for the specified company within the given time range [start_time, end_time]. If no data is present, return `-1`. # Function Signature: ```python class StockSystem: def __init__(self): pass def add_stock_price(self, company_name: str, time: int, price: int) -> None: pass def get_latest_price(self, company_name: str) -> int: pass def get_maximum_price(self, company_name: str, start_time: int, end_time: int) -> int: pass def get_minimum_price(self, company_name: str, start_time: int, end_time: int) -> int: pass ``` # Input: * `company_name`: A string representing the company\'s name. * `time`: An integer representing the time the stock price was recorded. (1 <= time <= 10^9) * `price`: An integer representing the stock price at the given time. (1 <= price <= 10^9) * `start_time`: Integer representing the start of the time range. * `end_time`: Integer representing the end of the time range. # Output: * For `get_latest_price`, return the latest stock price for the company. * For `get_maximum_price`, return the highest stock price within the specified period for the company. * For `get_minimum_price`, return the lowest stock price within the specified period for the company. # Constraints: * Ensure the solution handles large inputs efficiently within a feasible runtime. * Optimize space usage to minimize memory overhead. * Manage multiple companies and stock records efficiently and independently. # Example: ```python # Initialize the stock system stock_system = StockSystem() # Add stock prices stock_system.add_stock_price(\\"ABC\\", 10, 100) stock_system.add_stock_price(\\"ABC\\", 15, 200) stock_system.add_stock_price(\\"ABC\\", 20, 150) stock_system.add_stock_price(\\"XYZ\\", 5, 300) # Get latest prices assert stock_system.get_latest_price(\\"ABC\\") == 150 assert stock_system.get_latest_price(\\"XYZ\\") == 300 # Get maximum prices within a range assert stock_system.get_maximum_price(\\"ABC\\", 10, 20) == 200 assert stock_system.get_maximum_price(\\"XYZ\\", 1, 10) == 300 assert stock_system.get_maximum_price(\\"XYZ\\", 6, 10) == -1 # Get minimum prices within a range assert stock_system.get_minimum_price(\\"ABC\\", 10, 20) == 100 assert stock_system.get_minimum_price(\\"ABC\\", 16, 20) == 150 assert stock_system.get_minimum_price(\\"XYZ\\", 6, 10) == -1 ``` # Note: Implement the functionalities efficiently to ensure the system can handle large datasets and multiple queries. Consider edge cases and potential performance bottlenecks.","solution":"from collections import defaultdict class StockSystem: def __init__(self): self.stocks = defaultdict(list) def add_stock_price(self, company_name: str, time: int, price: int) -> None: self.stocks[company_name].append((time, price)) def get_latest_price(self, company_name: str) -> int: if company_name in self.stocks and self.stocks[company_name]: return self.stocks[company_name][-1][1] return -1 def get_maximum_price(self, company_name: str, start_time: int, end_time: int) -> int: if company_name not in self.stocks: return -1 max_price = -1 for time, price in self.stocks[company_name]: if start_time <= time <= end_time: max_price = max(max_price, price) return max_price def get_minimum_price(self, company_name: str, start_time: int, end_time: int) -> int: if company_name not in self.stocks: return -1 filtered_prices = [price for time, price in self.stocks[company_name] if start_time <= time <= end_time] if not filtered_prices: return -1 return min(filtered_prices)"},{"question":"# Coding Assessment Question Context In many software applications, the task of finding the first unique character in a string is common. The challenge is to identify the character that appears only once in the string and has the earliest position. Task Write a Python function that takes a string as input and returns the index of the first non-repeating character. If there is no such character, return -1. Function Signature ```python def first_unique_char(s: str) -> int: pass ``` Input * A string `s` of length `n` (1 ≤ n ≤ 10^5) consisting of lowercase English letters. Output * An integer representing the index of the first non-repeating character in the string. If no such character exists, return -1. Example ```python print(first_unique_char(\\"leetcode\\")) # Output: 0 print(first_unique_char(\\"loveleetcode\\")) # Output: 2 print(first_unique_char(\\"aabb\\")) # Output: -1 ``` Constraints * The function should be efficient in both time and space. * Assume the string `s` only contains lowercase English letters. * Handle edge cases such as strings with all repeating characters, single-character strings, and empty strings. Notes * Use a dictionary or a counter to keep track of character frequencies. * Traverse the string to identify the first character that occurs only once.","solution":"def first_unique_char(s: str) -> int: This function finds the index of the first non-repeating character in a string. If there is no such character, it returns -1. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the first character with a frequency of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Palindrome Permutation Checker # Objective: Determine if any permutation of the input string can form a palindrome. # Problem Statement: Write a function `can_form_palindrome` that checks if any permutation of the given string can form a palindrome. # Function Signature: ```python def can_form_palindrome(s: str) -> bool: pass ``` # Input: - `s`: A string consisting of lowercase letters (a-z). # Output: - A boolean value: `True` if any permutation of the string can form a palindrome, `False` otherwise. # Constraints: - The input string length is between 1 to 10^5 characters. # Performance Requirements: - The solution should ideally have a linear time complexity O(n) where n is the length of the string. - Space complexity should be O(1) in terms of the additional space used (considering the fixed size of the character set). # Example Scenario: Applications in text processing and validation often require verification of palindrome properties, such as in checking the validity of certain identifiers or simplifying patterns in data storage. # Example: ```python s = \\"code\\" print(can_form_palindrome(s)) # False s = \\"aab\\" print(can_form_palindrome(s)) # True s = \\"carerac\\" print(can_form_palindrome(s)) # True ``` # Key Points to Consider: - A string can be permuted into a palindrome if at most one character has an odd frequency (since the middle character in an odd-length palindrome does not need to be paired). - Handle large inputs efficiently and ensure the solution works within the provided constraints.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Counter the frequencies of each character in the string freq = Counter(s) # Calculate the number of characters that appear an odd number of times odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For a string to be able to form a palindrome, there can be at most one character with an odd count return odd_count <= 1"},{"question":"# Problem Statement You are given a list of integers organized in a non-decreasing order. Your task is to write a function that finds the first occurrence of a target value in the list and returns its index. If the target value is not present in the list, the function should return -1. Your function should be implemented in a way that optimizes for performance, utilizing a logarithmic time complexity approach. # Enhanced Requirements 1. Implement a binary search algorithm to achieve the desired time complexity. 2. Ensure that the solution handles large input sizes efficiently. 3. The function should return the index of the first occurrence of the target value if it exists. # Function Signature ```python def find_first_occurrence(nums: list[int], target: int) -> int: pass ``` # Expected Input and Output * **Input**: * A list of integers `nums` of length `n` (`1 <= n <= 10^6`), where `nums` is sorted in non-decreasing order. * An integer `target` (`-10^6 <= target <= 10^6`). * **Output**: * An integer representing the index of the first occurrence of `target` in `nums`, or -1 if `target` is not present in `nums`. * **Constraints**: * The function must achieve a time complexity of O(log n). * The input list is guaranteed to be sorted in non-decreasing order. # Example Usage ```python assert find_first_occurrence([1, 2, 2, 3, 4, 5], 2) == 1 assert find_first_occurrence([1, 2, 2, 3, 4, 5], 3) == 3 assert find_first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_first_occurrence([], 3) == -1 ``` # Hints 1. Utilize a binary search to repeatedly divide the search space in half. 2. Adjust the binary search to continue searching in the left half even after finding the target to locate the first occurrence. 3. Pay special attention to edge cases such as empty lists or target values not present in the list.","solution":"def find_first_occurrence(nums: list[int], target: int) -> int: Finds the first occurrence of the target in the sorted list nums. Parameters: nums (list[int]): A list of integers sorted in non-decreasing order. target (int): The target integer to search for. Returns: int: The index of the first occurrence of target, or -1 if target is not present. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: result = mid right = mid - 1 # Look in the left half elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Problem Statement You have been asked to help enhance a software system by optimizing its algorithm for finding the shortest path in a weighted graph. The current implementation uses Dijkstra\'s algorithm, but it has limitations when dealing with graphs that contain negative weight edges. Your task is to implement the Bellman-Ford algorithm to find the shortest path in a graph with potentially negative weight edges. Write a function `bellman_ford` that calculates the shortest path from a given source vertex to all other vertices in a directed weighted graph. # Function Signature ```python def bellman_ford(vertices: int, edges: list[tuple[int, int, int]], source: int) -> list[int]: ``` # Input - `vertices` (int): The number of vertices in the graph, labeled from 0 to `vertices - 1`. - `edges` (list of tuples): A list where each tuple (u, v, w) represents an edge from vertex `u` to vertex `v` with weight `w`. - `source` (int): The starting vertex for calculating the shortest paths. # Output - Returns a list of integers where the value at index `i` is the shortest distance from the source vertex to vertex `i`. # Constraints - 1 ≤ `vertices` ≤ 500 - 0 ≤ `u`, `v` < `vertices` - -10^4 ≤ `w` ≤ 10^4 - The edge list may contain up to 10^4 edges. - The graph may contain negative weight edges. - If there is a negative weight cycle reachable from the source, the function should raise a `ValueError`. # Examples ```python >>> vertices = 5 >>> edges = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)] >>> source = 0 >>> bellman_ford(vertices, edges, source) [0, -1, 2, -2, 1] >>> vertices = 3 >>> edges = [(0, 1, 4), (1, 2, -10), (2, 0, 3)] >>> source = 0 >>> bellman_ford(vertices, edges, source) ValueError >>> vertices = 4 >>> edges = [(0, 1, 1), (1, 2, 3), (2, 3, 2), (3, 1, -8)] >>> source = 0 >>> bellman_ford(vertices, edges, source) ValueError ``` # Requirements - Implement the function `bellman_ford` to calculate shortest paths using the Bellman-Ford algorithm. - Detect and handle negative weight cycles. If a negative cycle is detected that is reachable from the source, raise a `ValueError`. - Handle edge cases effectively, such as graphs with no vertices or edges. # Hints - The Bellman-Ford algorithm repeatedly relaxes all edges. Use this to calculate minimum distances. - Use a distances array initialized to infinity for all vertices except the source, which should be zero. - After `vertices - 1` iterations, one additional iteration can help detect negative weight cycles.","solution":"def bellman_ford(vertices: int, edges: list[tuple[int, int, int]], source: int) -> list[int]: # Initialize the distance to all vertices as infinity except the source distance = [float(\'inf\')] * vertices distance[source] = 0 # Relax edges repeatedly for _ in range(vertices - 1): for u, v, w in edges: if distance[u] != float(\'inf\') and distance[u] + w < distance[v]: distance[v] = distance[u] + w # Check for negative-weight cycles for u, v, w in edges: if distance[u] != float(\'inf\') and distance[u] + w < distance[v]: raise ValueError(\\"Graph contains a negative weight cycle\\") return distance"},{"question":"# Sorting a List of Dictionaries **Scenario**: You are working as a software developer and you need to handle and manipulate a collection of data stored as a list of dictionaries. Each dictionary contains information about an item including its `id`, `name`, and `price`. Your task is to write a function that will sort the list based on the `price` of the items in ascending order. If two items have the same `price`, they should be sorted by their `id` in ascending order. **Task**: Implement a function that takes in a list of dictionaries representing items and returns the list sorted by the specified criteria. **Function Signature**: ```python def sort_items(items: list) -> list: Sort the list of item dictionaries by price and then by id. Args: items (list): a list of dictionaries where each dictionary has keys \'id\', \'name\', and \'price\'. Returns: list: the sorted list of dictionaries. ``` **Input**: - `items`: a list of dictionaries where each dictionary contains: - `id` (int): unique identifier of the item. - `name` (str): name of the item. - `price` (float): price of the item. **Output**: - The function should return the list of dictionaries sorted first by the `price` in ascending order, and then by the `id` in ascending order if two prices are the same. **Constraints**: - The list may contain from `0` to `10^5` items. - Each dictionary will have the keys `id`, `name`, and `price`. **Examples**: ```python # Sample Input/Output 1 >>> items = [{\'id\': 1, \'name\': \'item1\', \'price\': 20.5}, {\'id\': 2, \'name\': \'item2\', \'price\': 15.0}, {\'id\': 3, \'name\': \'item3\', \'price\': 20.5}] >>> sort_items(items) [{\'id\': 2, \'name\': \'item2\', \'price\': 15.0}, {\'id\': 1, \'name\': \'item1\', \'price\': 20.5}, {\'id\': 3, \'name\': \'item3\', \'price\': 20.5}] # Sample Input/Output 2 >>> items = [{\'id\': 1, \'name\': \'item1\', \'price\': 10.0}] >>> sort_items(items) [{\'id\': 1, \'name\': \'item1\', \'price\': 10.0}] # Sample Input/Output 3 >>> items = [] >>> sort_items(items) [] # Sample Input/Output 4 >>> items = [{\'id\': 1, \'name\': \'item1\', \'price\': 50.0}, {\'id\': 2, \'name\': \'item2\', \'price\': 50.0}, {\'id\': 3, \'name\': \'item3\', \'price\': 40.0}] >>> sort_items(items) [{\'id\': 3, \'name\': \'item3\', \'price\': 40.0}, {\'id\': 1, \'name\': \'item1\', \'price\': 50.0}, {\'id\': 2, \'name\': \'item2\', \'price\': 50.0}] ``` **Requirements**: - The implementation should make use of efficient sorting techniques. - Edge cases such as empty lists and lists with identical prices should be handled gracefully. - Include test cases for validation.","solution":"def sort_items(items: list) -> list: Sort the list of item dictionaries by price and then by id. Args: items (list): a list of dictionaries where each dictionary has keys \'id\', \'name\', and \'price\'. Returns: list: the sorted list of dictionaries. return sorted(items, key=lambda x: (x[\'price\'], x[\'id\']))"},{"question":"# Coding Assignment: Implement a Real-Time Stock Price Calculator Scenario You have been hired by a financial services firm to develop a real-time stock price calculator. The firm\'s aim is to keep track of the moving average of stock prices. The main objective is to ensure that the system can update the moving average efficiently as new trades occur. This will help the firm provide instantaneous stock price monitoring and analysis. Problem Statement Implement a class `StockPriceCalculator` that can efficiently calculate the moving average of stock prices. Your implementation should be designed to handle continuous updates with new trade prices being added in real-time. Requirements 1. **Class Signature**: Define a class named `StockPriceCalculator` with the following methods: - `__init__(self, window_size: int) -> None`: Initializes the calculator with a specified window size for the moving average. - `add_trade(self, price: float) -> None`: Adds a new trade price to the data. - `get_moving_average(self) -> float`: Returns the current moving average of the stock prices within the defined window size. 2. **Input Format**: - `window_size`: An integer representing the number of recent trades to consider for the moving average. - `price`: A floating-point number representing the latest trade\'s stock price. 3. **Output Format**: - The method `get_moving_average` should return a floating-point number representing the moving average of the recent trades. 4. **Constraints**: - The system should handle frequent updates and ensure that each `add_trade` operation is efficient. - The window size will be at least 1. - Prices can be between 0.01 and 10,000.00. - Aim to optimize for both time and space complexity. 5. **Performance Requirements**: - Ensure that the `add_trade` and `get_moving_average` methods run in constant time O(1). Example ```python calculator = StockPriceCalculator(window_size=3) calculator.add_trade(100.0) calculator.add_trade(105.0) print(calculator.get_moving_average()) # Output: 102.5 calculator.add_trade(110.0) print(calculator.get_moving_average()) # Output: 105.0 calculator.add_trade(115.0) print(calculator.get_moving_average()) # Output: 110.0 ``` Notes 1. Implement the class `StockPriceCalculator`. 2. Utilize an appropriate data structure to maintain the most recent trades for efficient moving average computation. 3. Ensure robustness to handle high-frequency trading data without significant performance degradation.","solution":"from collections import deque class StockPriceCalculator: def __init__(self, window_size: int) -> None: self.window_size = window_size self.prices = deque() self.current_sum = 0.0 def add_trade(self, price: float) -> None: if len(self.prices) == self.window_size: self.current_sum -= self.prices.popleft() self.prices.append(price) self.current_sum += price def get_moving_average(self) -> float: if len(self.prices) == 0: return 0.0 return self.current_sum / len(self.prices)"},{"question":"# Matrix Chain Multiplication Matrix chain multiplication is a classic optimization problem in which the goal is to find the most efficient way to multiply a chain of matrices. The problem can be solved using dynamic programming to minimize the number of scalar multiplications required. Task Write a function `matrix_chain_order` that computes the minimum number of multiplications needed to multiply a chain of matrices. The function should take the following parameter: * `dimensions`: A list of integers where the i-th matrix has dimensions `dimensions[i-1] x dimensions[i]`. The function should return an integer representing the minimum number of multiplications needed to multiply the matrices. Constraints * The list `dimensions` should have at least two elements. * The implementation should handle edge cases such as incorrect dimensions or empty lists. * Optimize the function for both performance and memory usage. Input Format The input parameter is: 1. `dimensions` (List[int]): A list of dimensions of the matrices. Output Format The function should return an integer representing the minimum number of multiplications needed. Example ```python dimensions = [1, 2, 3, 4] result = matrix_chain_order(dimensions) print(result) # Output: 18 ``` Explanation For the input `[1, 2, 3, 4]`, the minimum number of multiplications needed is 18. The matrix multiplication order that results in the fewest multiplications is ((A1*A2)*A3), where A1 is 1x2, A2 is 2x3, and A3 is 3x4. Your implementation should include necessary error handling for invalid input parameters, ensuring the list of dimensions has the correct properties for matrix chain multiplication.","solution":"def matrix_chain_order(dimensions): Returns the minimum number of multiplications needed to multiply the chain of matrices. Parameters: dimensions (List[int]): A list of integers representing the dimensions of the matrices. Returns: int: The minimum number of scalar multiplications needed to multiply the chain of matrices. # Number of matrices n = len(dimensions) - 1 # m[i][j] will hold the minimum number of scalar multiplications needed # to compute the matrix A[i]A[i+1]...A[j] = A[i..j] m = [[0 for _ in range(n)] for _ in range(n)] # L is chain length for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): # q = cost/scalar multiplications q = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1] if q < m[i][j]: m[i][j] = q return m[0][n-1]"},{"question":"**Palindrome Prime Problem** Problem Statement: You are asked to find all prime numbers within a specified range that are also palindromes. A number is considered a palindrome if it reads the same forwards as it does backwards. Your function should iterate through the specified range, check for prime numbers, and then verify if they are palindromes. Requirements: - Implement a function `is_prime` to determine if a given number is a prime. - Implement a function `is_palindrome` to determine if a given number is a palindrome. - Implement a function `find_palindrome_primes` to identify all numbers in the range [10, 10000] that are both prime and palindromes. - Return a list of all such numbers. Input: - None (The range 10 to 10000 is fixed). Output: - `List[int]`: List of all prime numbers within the given range that are palindromes. Constraints: - The solution should efficiently check for prime numbers and palindromes within the specified range. - Functions should be adequately tested for correctness. # Function Signatures: ```python def is_prime(number: int) -> bool: # Checks if a given number is a prime. pass def is_palindrome(number: int) -> bool: # Checks if a given number is a palindrome. pass def find_palindrome_primes() -> List[int]: # Finds and returns a list of all numbers that are both primes and palindromes. pass ``` Example: ```python assert is_prime(11) == True assert is_prime(15) == False assert is_palindrome(121) == True assert is_palindrome(123) == False assert find_palindrome_primes() == [11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929] ```","solution":"def is_prime(number: int) -> bool: Returns True if the number is a prime, else False. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def is_palindrome(number: int) -> bool: Returns True if the number is a palindrome, else False. num_str = str(number) return num_str == num_str[::-1] def find_palindrome_primes() -> list[int]: Returns a list of all numbers that are both primes and palindromes in the range [10, 10000]. palindrome_primes = [] for num in range(10, 10001): if is_prime(num) and is_palindrome(num): palindrome_primes.append(num) return palindrome_primes"},{"question":"# Scenario: As a software developer for a logistics company, you are tasked with optimizing the route for delivering packages. The company maintains records of delivery points as a series of geographical coordinates. To facilitate the planning, you need to implement a function that calculates the shortest path to visit all given delivery points exactly once, that starts and ends at a specified depot. The depot is represented as the first point in the list of coordinates, and you may assume all coordinates are unique. # Task: Implement the function `shortest_route` that takes a list of coordinates as input and returns the sequence of coordinates representing the shortest path starting and ending at the depot. # Function Signature: ```python def shortest_route(coordinates: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` # Input/Output: * **Input**: * `coordinates` (List[Tuple[int, int]]): The list of coordinates representing delivery points, where each coordinate is a tuple of integers (x, y). The first element in the list is the depot. * (1 ≤ len(coordinates) ≤ 10) * **Output**: * List[Tuple[int, int]]: The sequence of coordinates that represents the shortest path starting and ending at the depot. # Constraints: * You may assume the list of coordinates is unique. * The function should handle up to 10 coordinates efficiently. * The resulting route must start and end at the depot and visit each point exactly once. # Performance Requirements: - Ensure your solution is optimal given the constraints. # Example: ```python >>> shortest_route([(0, 0), (1, 2), (3, 4), (6, 1)]) [(0, 0), (1, 2), (3, 4), (6, 1), (0, 0)] >>> shortest_route([(0, 0), (2, 5), (5, 2), (7, 3), (1, 4)]) [(0, 0), (1, 4), (2, 5), (5, 2), (7, 3), (0, 0)] >>> shortest_route([(10, 10), (11, 15)]) [(10, 10), (11, 15), (10, 10)] ``` # Notes: - The function should focus on correctness and running within acceptable time limits for the input size. - Make sure to handle edge cases such as minimal input sizes. - Output the route in the sequence of coordinates that yields the shortest path, starting and ending at the depot.","solution":"from typing import List, Tuple import itertools def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Helper function to calculate the Euclidean distance between two points. return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 def total_route_distance(route: List[Tuple[int, int]]) -> float: Helper function to calculate the total distance of a given route. distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) return distance def shortest_route(coordinates: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the sequence of coordinates representing the shortest path starting and ending at the depot. depot = coordinates[0] delivery_points = coordinates[1:] shortest_path = None min_distance = float(\'inf\') for perm in itertools.permutations(delivery_points): current_path = [depot] + list(perm) + [depot] current_distance = total_route_distance(current_path) if current_distance < min_distance: min_distance = current_distance shortest_path = current_path return shortest_path"},{"question":"# Coding Assessment Question Scenario/Context Analyzing strings and their properties is a fundamental skill in computer science. This problem will test your ability to detect specific patterns within a string and count the occurrences of certain substrings, an essential task in many text processing and data mining applications. Problem Statement Write a function `count_repeated_substrings(s: str, k: int) -> int` that counts how many times any substring of length `k` appears more than once in the given string `s`. # Function Signature `def count_repeated_substrings(s: str, k: int) -> int:` # Input * `s` (str): A string containing only lowercase alphabetical characters. * `k` (int): A positive integer representing the length of the substrings to be considered. # Output * Returns an integer, the number of substrings of length `k` that appear more than once in the string `s`. # Constraints * `1 <= len(s) <= 1000` * `1 <= k <= len(s)` # Example ```python >>> count_repeated_substrings(\\"banana\\", 2) 2 >>> count_repeated_substrings(\\"abcabcabc\\", 3) 3 >>> count_repeated_substrings(\\"abcd\\", 2) 0 ``` # Explanation 1. For the input s = \\"banana\\" and k = 2; The substrings of length 2 are \\"ba\\", \\"an\\", \\"na\\", \\"an\\", \\"na\\". The substrings \\"an\\" and \\"na\\" are repeated more than once, so the result is 2. 2. For the input s = \\"abcabcabc\\" and k = 3; The substrings of length 3 are \\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\". The substrings \\"abc\\", \\"bca\\" and \\"cab\\" are repeated, so the result is 3. 3. For the input s = \\"abcd\\" and k = 2; The substrings of length 2 are \\"ab\\", \\"bc\\", \\"cd\\". There are no repeated substrings, so the result is 0. # Additional Points - Consider edge cases like when `k` is equal to the length of the string, which means the whole string itself is the only substring. - Handle efficiently to avoid excessive computational complexity for longer strings.","solution":"def count_repeated_substrings(s: str, k: int) -> int: Counts how many times any substring of length `k` appears more than once in the given string `s`. if k > len(s): return 0 substring_count = {} for i in range(len(s) - k + 1): substring = s[i:i + k] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return sum(1 for count in substring_count.values() if count > 1)"},{"question":"# Array Permutation Checker In this challenge, you will implement a function that determines if two given arrays are permutations of each other. Two arrays are permutations of each other if they contain the same elements with the same frequency. # Requirements 1. Implement a function `are_permutations(arr1: list, arr2: list) -> bool` that returns `True` if the two arrays are permutations of each other and `False` otherwise. 2. The comparison should be performed in an efficient manner, ensuring minimal computational overhead. # Function Signature ```python def are_permutations(arr1: list, arr2: list) -> bool: pass ``` # Input * `arr1`: A list of integers representing the first array. * `arr2`: A list of integers representing the second array. # Output * Returns a boolean value `True` if the two arrays are permutations of each other, `False` otherwise. # Constraints * The arrays contain non-nullable integers. * The length of each array ((|N|)) is in the range of (0 leq |N| leq 1000). * The integers in the arrays range from (-1000) to (1000). # Example ```python arr1 = [1, 2, 3, 4, 5] arr2 = [5, 4, 3, 2, 1] print(are_permutations(arr1, arr2)) # Output: True arr1 = [1, 2, 2, 3, 4] arr2 = [1, 2, 3, 4, 4] print(are_permutations(arr1, arr2)) # Output: False ``` # Explanation In the first example, the arrays `[1, 2, 3, 4, 5]` and `[5, 4, 3, 2, 1]` are permutations of each other since they contain the same elements with identical frequencies. Thus, the function returns `True`. In the second example, while both arrays are similar, `arr1` contains two `2`s while `arr2` contains two `4`s. Hence, they are not permutations of each other, and the function returns `False`.","solution":"from collections import Counter def are_permutations(arr1: list, arr2: list) -> bool: Determines if two arrays are permutations of each other. Args: arr1 (list): First array of integers. arr2 (list): Second array of integers. Returns: bool: True if arr1 and arr2 are permutations of each other, False otherwise. return Counter(arr1) == Counter(arr2)"},{"question":"# Context As part of a larger system for monitoring temperature in an industrial setting, you need to process data received from a series of temperature sensors. The temperature data is transmitted in degrees Celsius, and for certain calculations, it needs to be converted to degrees Fahrenheit. # Task Implement a Python function called `convert_to_fahrenheit` that converts a given temperature from Celsius to Fahrenheit. Your function should adhere to the following requirements: # Requirements * Define the function as `convert_to_fahrenheit(celsius: float) -> float`. * The function should return the converted temperature using the formula ( F = frac{9}{5}C + 32 ). * Your function should raise a `ValueError` if the given temperature is below absolute zero (-273.15 degrees Celsius), with an appropriate error message. * Assume that inputs will be of type `float`. # Example Usage ```python >>> convert_to_fahrenheit(0) 32.0 >>> convert_to_fahrenheit(100) 212.0 >>> convert_to_fahrenheit(-300) Traceback (most recent call last): ... ValueError: Temperature below absolute zero is not possible ``` # Constraints * The input temperature will be a floating-point number. * Focus on the accuracy of the temperature conversion and correct error handling. * Keep code clear, concise, and maintainable. # Performance Requirements * The function must run in constant time, O(1), given the simplicity of operations involved. * Error messages should be self-explanatory to assist with debugging and validation.","solution":"def convert_to_fahrenheit(celsius: float) -> float: Converts a given temperature from Celsius to Fahrenheit. Args: celsius (float): Temperature in degrees Celsius. Returns: float: Temperature in degrees Fahrenheit. Raises: ValueError: If the temperature is below absolute zero (-273.15 degrees Celsius). if celsius < -273.15: raise ValueError(\\"Temperature below absolute zero is not possible\\") fahrenheit = (celsius * 9/5) + 32 return fahrenheit"},{"question":"# Algorithm Question: Finding the Longest Mountain in an Array A mountain is defined as a subarray that satisfies the following conditions: 1. It has at least 3 elements. 2. There exists some index (i) with (0 < i < k - 1) such that: - `arr[0] < arr[1] < ... < arr[i]` - `arr[i] > arr[i+1] > ... > arr[k-1]` Given an array of integers, your task is to find the length of the longest mountain. **Function Signature**: `def longest_mountain(arr: List[int]) -> int:` # Input: - A list of integers `arr` of length `n` where (0 leq n leq 10^5). # Output: - An integer: The length of the longest subarray that forms a mountain. If no such subarray exists, return 0. # Example: ```python >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([0, 2, 2, 2, 0, 2, 2, 3, 4, 2]) 4 ``` # Constraints: - The algorithm should run in (O(n)) time complexity. - Utilize a single pass approach with extra space for auxiliary arrays or variables if necessary.","solution":"from typing import List def longest_mountain(arr: List[int]) -> int: n = len(arr) if n < 3: return 0 max_len = 0 i = 1 while i < n - 1: if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right + 1] < arr[right]: right += 1 current_len = right - left + 1 max_len = max(max_len, current_len) i = right else: i += 1 return max_len"},{"question":"# Coding Assessment Question You are given a list of non-negative integers representing the amount of gold in each stack. Your task is to determine whether it is possible to divide the gold stacks into two groups such that the sum of gold in both groups is equal. Write a function `can_divide_gold_stacks(stacks: List[int]) -> bool` that returns `True` if you can divide the stacks as described, otherwise, return `False`. Input - `stacks`: A list of non-negative integers (1 <= len(stacks) <= 100, 1 <= stacks[i] <= 1000) Output - Return `True` if the stacks can be divided into two groups with equal gold sum, otherwise return `False`. Constraints - Use Dynamic Programming to solve this problem. Example ```python def can_divide_gold_stacks(stacks: List[int]) -> bool: total_gold = sum(stacks) if total_gold % 2 != 0: return False target = total_gold // 2 n = len(stacks) dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): if dp[i-1][j]: dp[i][j] = True if j >= stacks[i-1] and dp[i-1][j-stacks[i-1]]: dp[i][j] = True return dp[n][target] # Examples print(can_divide_gold_stacks([1, 5, 11, 5])) # Output: True print(can_divide_gold_stacks([1, 2, 3, 5])) # Output: False print(can_divide_gold_stacks([2, 2, 2, 2])) # Output: True print(can_divide_gold_stacks([10, 10, 10, 5, 5])) # Output: True print(can_divide_gold_stacks([3, 3, 3, 4, 5])) # Output: True ```","solution":"from typing import List def can_divide_gold_stacks(stacks: List[int]) -> bool: total_gold = sum(stacks) if total_gold % 2 != 0: return False target = total_gold // 2 n = len(stacks) dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): if dp[i-1][j]: dp[i][j] = True if j >= stacks[i-1] and dp[i-1][j-stacks[i-1]]: dp[i][j] = True return dp[n][target]"},{"question":"# Question: **Online Shopping Cart System** Background You are tasked with creating a functional module for an online shopping cart system. This module should include the ability to add, remove, and display items in a cart, and provide the total price of all items in the cart. # Requirements: 1. **Class: `Item`** - **Attributes**: - `name` (str): The name of the item. - `price` (float): The price of a single unit of the item. - `quantity` (int): The quantity of the item available in the cart. - **Methods**: - `__init__(self, name: str, price: float, quantity: int = 1)` 2. **Class: `ShoppingCart`** - **Attributes**: - `items` (list[Item]): A list to store the items in the cart. - **Methods**: - `__init__(self)` - `add_item(self, item: Item) -> None` - **Input**: An instance of `Item`. - **Task**: Add the item to the cart. If the item is already in the cart, update the quantity. - `remove_item(self, item_name: str) -> bool` - **Input**: The name of the item to remove. - **Output**: A boolean indicating whether the item was successfully removed. - **Task**: Remove the item from the cart by name. Return `True` if the item was removed, otherwise return `False`. - `total_price(self) -> float` - **Output**: The total price of all items in the cart. - **Task**: Calculate and return the total price. - `display_cart(self) -> None` - **Task**: Display each item in the cart including name, price, quantity, and total cost for that item. Also display the cart total price. # Constraints: - Ensure the `add_item` method handles cases where the item is already present or a new item needs to be added. - Ensure the cart correctly calculates the total price, considering both item price and quantity. - Handle special cases such as adding an item with a negative quantity or price (which should not be allowed). - Ensure the `remove_item` method correctly identifies and removes the specified item. - Ensure the `display_cart` method formats the output in a clear and organized manner. # Example: ```python >>> cart = ShoppingCart() >>> item1 = Item(\\"Laptop\\", 999.99) >>> item2 = Item(\\"Mouse\\", 19.99, 2) >>> cart.add_item(item1) >>> cart.add_item(item2) >>> cart.display_cart() Item: Laptop, Price: 999.99, Quantity: 1, Total: 999.99 Item: Mouse, Price: 19.99, Quantity: 2, Total: 39.98 Cart Total: 1039.97 >>> cart.remove_item(\\"Laptop\\") True >>> cart.display_cart() Item: Mouse, Price: 19.99, Quantity: 2, Total: 39.98 Cart Total: 39.98 >>> cart.remove_item(\\"Keyboard\\") False >>> cart.total_price() 39.98 ``` Develop the `Item` and `ShoppingCart` classes fulfilling these requirements. Ensure to test them against various scenarios to validate the functionality.","solution":"class Item: def __init__(self, name: str, price: float, quantity: int = 1): if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be non-negative.\\") self.name = name self.price = price self.quantity = quantity class ShoppingCart: def __init__(self): self.items = [] def add_item(self, item: Item) -> None: for existing_item in self.items: if existing_item.name == item.name: existing_item.quantity += item.quantity return self.items.append(item) def remove_item(self, item_name: str) -> bool: for i, item in enumerate(self.items): if item.name == item_name: del self.items[i] return True return False def total_price(self) -> float: return sum(item.price * item.quantity for item in self.items) def display_cart(self) -> None: for item in self.items: total_item_price = item.price * item.quantity print(f\\"Item: {item.name}, Price: {item.price:.2f}, Quantity: {item.quantity}, Total: {total_item_price:.2f}\\") print(f\\"Cart Total: {self.total_price():.2f}\\")"},{"question":"# Coding Challenge **Scenario**: A city has a number of vertical and horizontal roads forming a grid. Each intersection between a vertical road and a horizontal road is represented by a point in a 2D grid. Some intersections are blocked and cannot be accessed. Given the grid dimensions and a list of blocked intersections, your task is to count the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) of the grid, while avoiding the blocked intersections. **Function Signature**: ```python def count_paths(n: int, m: int, blocked: list[tuple[int, int]]) -> int: pass ``` # Input * `n` (int): The number of rows in the grid. * `m` (int): The number of columns in the grid. * `blocked` (list[tuple[int, int]]): A list of tuples indicating the blocked intersections. # Output * (int): The number of unique paths from (0, 0) to (n-1, m-1). # Constraints * (1 leq text{n}, text{m} leq 100) * (0 leq x < text{n}, 0 leq y < text{m}) for each ((x, y)) in `blocked`. # Examples **Example 1** * Input: ```python n = 3, m = 3 blocked = [(1, 1)] ``` * Output: `2` **Example 2** * Input: ```python n = 2, m = 2 blocked = [(0, 1)] ``` * Output: `1` # Guidelines: * Construct a dynamic programming table to keep track of the number of unique paths to each point in the grid. * Initialize the table with paths from the starting point (0, 0), taking blocked intersections into account. * Use the relation: paths[i][j] = paths[i-1][j] + paths[i][j-1] if (i, j) is not blocked. * Optimize time and space complexity to handle the upper constraints efficiently. * Ensure the function correctly handles edge cases such as a fully blocked grid or paths around multiple blocks.","solution":"def count_paths(n: int, m: int, blocked: list[tuple[int, int]]) -> int: # Initialize grid with all zeros grid = [[0] * m for _ in range(n)] # Set of blocked intersections blocked_set = set(blocked) # If the start or end is blocked, immediately return 0 if (0, 0) in blocked_set or (n - 1, m - 1) in blocked_set: return 0 # Starting point grid[0][0] = 1 # Fill the grid for i in range(n): for j in range(m): if (i, j) in blocked_set: grid[i][j] = 0 else: if i > 0: grid[i][j] += grid[i - 1][j] if j > 0: grid[i][j] += grid[i][j - 1] return grid[n - 1][m - 1]"},{"question":"# Context You are a software developer at a logistics company. Your team is working on a system to manage the delivery routes of trucks. One of the essential components is to calculate the shortest path between delivery points. # Problem Statement Write a function `shortest_path(graph: dict, start_node: str, end_node: str) -> list` that takes in a graph represented as a dictionary, a starting node, and an ending node, and returns the shortest path between the start and end nodes. The graph dictionary keys represent the nodes, and the values are dictionaries of adjacent nodes and their associated distances. Function Signature ```python def shortest_path(graph: dict, start_node: str, end_node: str) -> list: pass ``` Input - `graph` (dict): The graph representing the nodes and edges. Example of input: ```python { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1} } ``` - `start_node` (str): The starting node in the graph. - `end_node` (str): The target node to find the shortest path to. Output - (list): The shortest path from `start_node` to `end_node` as a list of nodes. If no path exists, return an empty list. # Requirements 1. Handle graphs with different node configurations and distances. 2. Use Dijkstra\'s algorithm or another efficient shortest path algorithm. 3. Provide clear error messages for invalid inputs (e.g., node not found). Example ```python graph = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"A\\": 1, \\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 1}, \\"D\\": {\\"B\\": 5, \\"C\\": 1} } print(shortest_path(graph, \\"A\\", \\"D\\")) # Expected output: [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] ``` # Constraints - The graph may have up to 1000 nodes. - Node names are strings with a maximum length of 20 characters. - Edge weights are positive integers. # Notes 1. Ensure your solution is efficient and can handle the upper limits of the constraints. 2. If nodes are not connected, the function should return an empty list. 3. Consider edge cases such as graphs with only one node, or where the start node is the same as the end node.","solution":"import heapq def shortest_path(graph: dict, start_node: str, end_node: str) -> list: Computes the shortest path between start_node and end_node in a graph using Dijkstra\'s algorithm. :param graph: Dictionary representing the graph where keys are nodes and values are dictionaries of adjacent nodes with distances. :param start_node: The starting node. :param end_node: The target node. :return: List of nodes representing the shortest path from start_node to end_node. Return empty list if no path exists. if start_node not in graph or end_node not in graph: raise ValueError(\\"Start or end node not found in the graph.\\") # Priority queue to store (distance, node, path) pq = [(0, start_node, [start_node])] visited = set() while pq: (cost, current, path) = heapq.heappop(pq) if current in visited: continue if current == end_node: return path visited.add(current) for neighbor, weight in graph[current].items(): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path + [neighbor])) return []"},{"question":"# Problem Statement You are given an array of integers where some elements appear twice and others appear once. Your task is to implement a function `find_single_number(nums: List[int]) -> int` which returns the element that appears exactly once. Your solution should have a linear runtime complexity and use constant extra space. # Function Signature ```python def find_single_number(nums: List[int]) -> int: ``` # Input * `nums` (List[int]): a list of integers where exactly one element appears once and all others appear twice. # Output * Return the integer that appears exactly once. # Constraints * `1 <= len(nums) <= 3 * 10^4` * Each integer in `nums` will be between `-3 * 10^4` and `3 * 10^4`. * All but one of the integers in `nums` will appear exactly twice. # Examples ```python find_single_number([2, 2, 1]) # Output: 1 find_single_number([4, 1, 2, 1, 2]) # Output: 4 find_single_number([1]) # Output: 1 ``` # Guidelines 1. You must use a solution that runs in O(n) time complexity. 2. You must use a solution that uses only O(1) extra space. 3. You cannot use any built-in functions directly related to finding unique elements.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the element that appears exactly once in an array where all other elements appear twice. result = 0 for num in nums: result ^= num return result"},{"question":"# String Pattern Matching using KMP Algorithm You are tasked with implementing a solution to perform string pattern matching using the Knuth-Morris-Pratt (KMP) algorithm. This algorithm finds the occurrences of a pattern string within a text string efficiently by preprocessing the pattern string to build a partial match table (also known as the \\"prefix\\" table). Task Write a function `kmp_search` that takes in the following parameters: * `text`: A string representing the text in which we want to find the pattern. * `pattern`: A string representing the pattern that we want to find within the text. The function should return a list of starting indices where the pattern is found within the text. If the pattern is not found, it should return an empty list. Constraints * The function should handle edge cases where the text or pattern is an empty string. * The function should implement the KMP algorithm to ensure efficient pattern matching with time complexity O(n + m), where n is the length of the text and m is the length of the pattern. * Extra attention should be given to the construction of the prefix table to ensure correctness. Input Format The input parameters are: 1. `text` (str): String where the pattern is to be searched. 2. `pattern` (str): String pattern to be searched within the text. Output Format The function should return a list of integers indicating the starting indices of each match of the pattern in the text. Example ```python def kmp_search(text, pattern): def build_prefix_table(pattern): m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: if j != 0: j = prefix_table[j - 1] i -= 1 else: prefix_table[i] = 0 return prefix_table def search(text, pattern): n = len(text) m = len(pattern) prefix_table = build_prefix_table(pattern) indices = [] i = j = 0 while i < n: if text[i] == pattern[j]: i += 1 j += 1 if j == m: indices.append(i - j) j = prefix_table[j - 1] elif i < n and text[i] != pattern[j]: if j != 0: j = prefix_table[j - 1] else: i += 1 return indices if not text or not pattern: return [] return search(text, pattern) # Example usage indices = kmp_search(\'ababcabcabababd\', \'ababd\') print(indices) # Output: [10] ``` Your implementation should include comprehensive error handling and edge-case management to ensure robustness and correctness. Ensure the `kmp_search` function is optimized and adheres to the expected performance characteristics of the KMP algorithm.","solution":"def kmp_search(text, pattern): def build_prefix_table(pattern): m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j return prefix_table def search(text, pattern): n = len(text) m = len(pattern) prefix_table = build_prefix_table(pattern) indices = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: indices.append(i - m + 1) j = prefix_table[j - 1] return indices if not text or not pattern: return [] return search(text, pattern)"},{"question":"# Sum of Unique Elements Problem Statement: You are tasked with creating a function that calculates the sum of all unique elements in a given list of integers. An element is considered unique if it appears exactly once in the list. If there are no unique elements, the sum should be zero. Function Signature: ```python def sum_of_unique_elements(numbers: list) -> int: Given a list of integers, returns the sum of all unique elements. :param numbers: A list of integers. :return: An integer representing the sum of all unique elements in the list. ``` Input: - A list `numbers` of length `n` (0 ≤ n ≤ 10^6), containing integers where -10^6 ≤ numbers[i] ≤ 10^6. Output: - An integer representing the sum of all unique elements in the list. Example: ```python assert sum_of_unique_elements([1, 2, 3, 2, 4, 5]) == 13 assert sum_of_unique_elements([-1, -1, 2, 3]) == 5 assert sum_of_unique_elements([5, 5, 5, 5]) == 0 assert sum_of_unique_elements([]) == 0 ``` Explanation: - For the input `[1, 2, 3, 2, 4, 5]`, the function returns `13` since: - The unique elements are `1, 3, 4, 5`. - The sum is `1 + 3 + 4 + 5 = 13`. - For the input `[-1, -1, 2, 3]`, the function returns `5` since: - The unique elements are `2, 3`. - The sum is `2 + 3 = 5`. - For the input `[5, 5, 5, 5]`, the function returns `0` since: - There are no unique elements. - For an empty list `[]`, the function returns `0` because there are no elements to sum.","solution":"def sum_of_unique_elements(numbers: list) -> int: Given a list of integers, returns the sum of all unique elements. :param numbers: A list of integers. :return: An integer representing the sum of all unique elements in the list. from collections import Counter count = Counter(numbers) return sum(num for num, freq in count.items() if freq == 1)"},{"question":"# Implementation Question: Validate and Normalize Email Addresses **Problem Statement**: You need to create a function that validates and normalizes email addresses. The function should ensure that the provided email address is in a correct format and converts it to a standardized format: 1. The email\'s local part (the part before the \'@\') should be treated as case-sensitive. 2. The domain part (the part after the \'@\') should be converted to lowercase. 3. The function should strip any leading or trailing whitespace. 4. The function should ensure that the email contains exactly one \'@\' symbol, at least one character in the local part, and at least one dot in the domain part after the \'@\' symbol. 5. If the email is invalid, the function should raise a `ValueError`. **Function Signature**: ```python def validate_and_normalize_email(email: str) -> str: Validates and normalizes the provided email address. Parameters: email (str): The email address to be validated and normalized. Returns: str: The normalized email address. Raises: ValueError: If the email address is invalid. pass ``` **Input/Output Examples**: ```python >>> validate_and_normalize_email(\\" John.Doe@Example.COM \\") \'John.Doe@example.com\' >>> validate_and_normalize_email(\\"JaneDoe@sub.example.com\\") \'JaneDoe@sub.example.com\' >>> validate_and_normalize_email(\\" user@domain.co.uk \\") \'user@domain.co.uk\' >>> validate_and_normalize_email(\\"invalid-email@\\") Traceback (most recent call last): ... ValueError: Invalid email address: must contain one \'@\', characters before \'@\' and a domain after \'@\'. >>> validate_and_normalize_email(\\"noat_symbol.com\\") Traceback (most recent call last): ... ValueError: Invalid email address: must contain one \'@\', characters before \'@\' and a domain after \'@\'. >>> validate_and_normalize_email(\\"123\\") Traceback (most recent call last): ... ValueError: Invalid email address: must contain one \'@\', characters before \'@\' and a domain after \'@\'. ``` **Constraints**: * The input must be a string. * The length of the input string must be between 5 and 254 characters. # Hints: 1. Use string manipulation methods like `strip()`, `lower()`, and checks for the presence of characters. 2. Regular expressions can be helpful for validating the format of the email.","solution":"def validate_and_normalize_email(email: str) -> str: Validates and normalizes the provided email address. Parameters: email (str): The email address to be validated and normalized. Returns: str: The normalized email address. Raises: ValueError: If the email address is invalid. email = email.strip() # Remove leading and trailing whitespace if not isinstance(email, str) or len(email) < 5 or len(email) > 254: raise ValueError(\\"Invalid email address: must be a string between 5 and 254 characters.\\") if email.count(\'@\') != 1: raise ValueError(\\"Invalid email address: must contain exactly one \'@\' symbol.\\") local_part, domain_part = email.split(\'@\') if len(local_part) == 0 or len(domain_part) == 0: raise ValueError(\\"Invalid email address: must contain characters before \'@\' and a domain after \'@\'.\\") if \'.\' not in domain_part: raise ValueError(\\"Invalid email address: domain must contain at least one dot.\\") normalized_email = f\\"{local_part}@{domain_part.lower()}\\" return normalized_email"},{"question":"# Problem Statement You have to design a class representing a system that manages gym memberships. Each member can have one or more memberships, each with a start and end date. Your task is to implement a class `GymMembership` that allows you to add, check, and list memberships for a given member. # Class Signature: ```python class GymMembership: def __init__(self): # Initialize the system with an empty dictionary to store memberships. def add_membership(self, member_id: int, start_date: str, end_date: str) -> None: # Add a new membership for the member. def is_active(self, member_id: int, query_date: str) -> bool: # Check if the member has an active membership on the given date. def list_memberships(self, member_id: int) -> List[Tuple[str, str]]: # List all memberships for the member. ``` # Methods: - `def __init__(self):` The constructor initializes the system with an empty dictionary to store each member\'s memberships. - `def add_membership(self, member_id: int, start_date: str, end_date: str) -> None:` Adds a new membership to the system for the given member, specified by their `member_id`, with a membership period from `start_date` to `end_date`. - `def is_active(self, member_id: int, query_date: str) -> bool:` Checks if the member with the given `member_id` has an active membership on the `query_date`. Returns `True` if there is at least one active membership on this date, otherwise returns `False`. - `def list_memberships(self, member_id: int) -> List[Tuple[str, str]]:` Lists all membership periods for the member with the given `member_id`. Returns a list of tuples, where each tuple contains the start and end dates of a membership. # Input: * `member_id` (int): Unique identifier for a member. * `start_date`, `end_date`, `query_date` (str): Dates in the format \'YYYY-MM-DD\'. # Output: * `add_membership` returns `None`. * `is_active` returns `True` or `False`. * `list_memberships` returns a list of tuples containing membership periods. # Example: ```python gm = GymMembership() gm.add_membership(1, \'2023-01-01\', \'2023-06-30\') gm.add_membership(1, \'2023-07-01\', \'2023-12-31\') gm.add_membership(2, \'2023-02-15\', \'2023-05-15\') print(gm.is_active(1, \'2023-05-01\')) # Output: True print(gm.is_active(1, \'2024-01-01\')) # Output: False print(gm.list_memberships(1)) # Output: [(\'2023-01-01\', \'2023-06-30\'), (\'2023-07-01\', \'2023-12-31\')] print(gm.list_memberships(2)) # Output: [(\'2023-02-15\', \'2023-05-15\')] ``` # Constraints: * Dates will always be valid strings in the format \'YYYY-MM-DD\'. * The number of members will not exceed 1000. * Each member will not have more than 100 memberships. * Membership dates will be non-overlapping for each member. # Notes: - Ensure your class handles edge cases such as adding memberships for the same member with different periods. - Keep your implementation efficient for adding, querying, and listing memberships.","solution":"from typing import List, Tuple from datetime import datetime class GymMembership: def __init__(self): self.memberships = {} def add_membership(self, member_id: int, start_date: str, end_date: str) -> None: if member_id not in self.memberships: self.memberships[member_id] = [] self.memberships[member_id].append((start_date, end_date)) def is_active(self, member_id: int, query_date: str) -> bool: if member_id not in self.memberships: return False query_date_obj = datetime.strptime(query_date, \'%Y-%m-%d\').date() for start_date, end_date in self.memberships[member_id]: start_date_obj = datetime.strptime(start_date, \'%Y-%m-%d\').date() end_date_obj = datetime.strptime(end_date, \'%Y-%m-%d\').date() if start_date_obj <= query_date_obj <= end_date_obj: return True return False def list_memberships(self, member_id: int) -> List[Tuple[str, str]]: return self.memberships.get(member_id, [])"},{"question":"# Problem Description You are given a task to implement a new function for the existing binary tree class. The new function, named `average_of_levels`, should compute the average value of the nodes at each level in the binary tree and return these averages in the form of a list. # Function Signature ```python def average_of_levels(self) -> List[float]: Compute the average value of the nodes at each level of the binary tree. Example: Given binary tree: 3 / 9 20 / 15 7 Output: [3.0, 14.5, 11.0] pass ``` # Constraints * The tree nodes contain only integer values (positive, negative, or zero). * The tree is not necessarily a binary search tree. * The binary tree can be empty (return an empty list in this case). # Requirements - Your solution should correctly compute the averages of all levels. - Implement the function efficiently in terms of both time and space complexity. # Input & Output Examples 1. **Example:** - Input Tree: ``` 3 / 9 20 / 15 7 ``` - Output List: `[3.0, 14.5, 11.0]` 2. **Example:** - Input Tree: ``` 1 / 2 3 / 4 5 ``` - Output List: `[1.0, 2.5, 4.5]` # Additional Information - Assume the existing binary tree class is available with required methods. - Focus on implementing the `average_of_levels` method. - Your solution will be evaluated based on correctness and efficiency.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: Optional[TreeNode] = None): self.root = root def average_of_levels(self) -> List[float]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_sum = 0 level_count = len(queue) for _ in range(level_count): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_count) return result"},{"question":"# Objective: Develop a function to evaluate the number of ways to choose **k** items from **n** items, which is called a combination and represented as C(n, k). The function should handle large values efficiently using modular arithmetic within the constraints of a 32-bit integer. # Instructions: Write a function `compute_combination(n: int, k: int) -> int` that computes the number of combinations (also known as binomial coefficient) C(n, k). The function should return the result under modulo (10^9 + 7). # Expected Input & Output Formats: - **Input**: Two integers `n` and `k`. - Constraints: ( 0 leq k leq n leq 10^6 ) - The function should handle invalid inputs gracefully, raising a `ValueError` if either input is negative or if `k` is greater than `n`. - **Output**: An integer which is the value of C(n, k) mod (10^9 + 7). # Performance Requirements: The solution must be efficient to handle large values up to (10^6), leveraging properties of modular arithmetic and precomputation for factorial values to ensure performance scalability. # Example Usage: ```python def compute_combination(n: int, k: int) -> int: Computes C(n, k) under modulo 10^9 + 7. >>> compute_combination(5, 2) 10 >>> compute_combination(10, 4) 210 >>> compute_combination(100, 1) 100 >>> compute_combination(1000, 500) 159835829 >>> compute_combination(0, 0) 1 >>> compute_combination(-1, 2) Traceback (most recent call last): ... ValueError: Invalid input >>> compute_combination(5, 7) Traceback (most recent call last): ... ValueError: Invalid input if not isinstance(n, int) or not isinstance(k, int) or n < 0 or k < 0 or k > n: raise ValueError(\\"Invalid input\\") MOD = 10**9 + 7 # Compute factorials and inverse factorials under modulo. fact = [1] * (n + 1) for i in range(2, n + 1): fact[i] = fact[i - 1] * i % MOD inv_fact = [1] * (n + 1) inv_fact[n] = pow(fact[n], MOD - 2, MOD) for i in range(n - 1, 0, -1): inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD if __name__ == \\"__main__\\": from doctest import testmod testmod() print(f\\"{compute_combination(1000, 500) = }\\") ```","solution":"def compute_combination(n: int, k: int) -> int: Computes C(n, k) under modulo 10^9 + 7. if not isinstance(n, int) or not isinstance(k, int) or n < 0 or k < 0 or k > n: raise ValueError(\\"Invalid input\\") MOD = 10**9 + 7 # Compute factorials and inverse factorials under modulo. fact = [1] * (n + 1) for i in range(2, n + 1): fact[i] = fact[i - 1] * i % MOD inv_fact = [1] * (n + 1) inv_fact[n] = pow(fact[n], MOD - 2, MOD) for i in range(n - 1, 0, -1): inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD"},{"question":"# Coding Question Context In a database system, you are responsible for optimizing the query execution performance. As part of the optimization, you need to implement a caching mechanism that stores the results of frequently executed queries to minimize redundant computations and reduce latency. Task Write a class `QueryCacheManager` that implements a simple caching mechanism for database query results. The cache should have a maximum size and use the Least Recently Used (LRU) eviction policy. Class Signature ```python class QueryCacheManager: def __init__(self, max_size: int): pass def execute_query(self, query: str) -> str: pass def get_cache(self) -> dict: pass ``` Requirements 1. **Input**: * `max_size` (int): Maximum number of query results the cache can hold. * `query` (str): The database query string to be executed. 2. **Output**: * `execute_query` returns the result of the query, either from the cache or by executing the query. * `get_cache` returns a dictionary representing the current state of the cache. 3. **Constraints**: * Use a dictionary to store query results, with the query string as the key. * Implement LRU eviction for cache entries when the maximum size is exceeded. * Simulate a query execution by returning a fixed string as the result for the simplicity of testing. 4. **Performance**: * Aim for efficient cache operations with minimal overhead. * Ensure that the cache handles frequent updates without significant performance degradation. Example: ```python # Example usage cache_manager = QueryCacheManager(max_size=3) print(cache_manager.execute_query(\\"SELECT * FROM users\\")) print(cache_manager.execute_query(\\"SELECT * FROM orders\\")) print(cache_manager.execute_query(\\"SELECT * FROM products\\")) # Add another query to exceed cache size, oldest entry will be evicted print(cache_manager.execute_query(\\"SELECT * FROM customers\\")) print(cache_manager.get_cache()) ``` Notes: * For testing purposes, simulate query execution by returning a fixed string such as `\\"Result for: <query>\\"`. * Include logging to track cache hits, misses, and evictions. * Write clean and readable code with adequate comments.","solution":"from collections import OrderedDict class QueryCacheManager: def __init__(self, max_size: int): self.max_size = max_size self.cache = OrderedDict() def execute_query(self, query: str) -> str: if query in self.cache: # Move the query to the end to mark it as recently used self.cache.move_to_end(query) return self.cache[query] else: result = f\\"Result for: {query}\\" if len(self.cache) >= self.max_size: # Remove the oldest (least recently used) item self.cache.popitem(last=False) self.cache[query] = result return result def get_cache(self) -> dict: # Return a copy of the cache as a dictionary return dict(self.cache)"},{"question":"# Task Implement a function in Python that removes nodes from a Binary Search Tree (BST) such that all nodes\' values are within a specified range [low, high], inclusive. The function should modify the tree in-place and return the root of the modified tree. # Function Signature ```python def trimBST(root: TreeNode, low: int, high: int) -> TreeNode: ... ``` # Input - `root` (TreeNode): The root node of the BST. - `low` (int): The lower bound of the values to keep in the tree. - `high` (int): The upper bound of the values to keep in the tree. # Output - `root` (TreeNode): The root node of the modified BST with nodes only in the range [low, high]. # Constraints - The BST node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The BST property must be maintained after removing nodes. - Assume there are no duplicate values in the BST. # Example ```python >>> def build_tree(values): ... if not values: ... return None ... mid_idx = len(values) // 2 ... root = TreeNode(values[mid_idx]) ... root.left = build_tree(values[:mid_idx]) ... root.right = build_tree(values[mid_idx+1:]) ... return root >>> def inorder_traversal(root): ... if root is None: ... return [] ... return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) >>> root = build_tree([1, 2, 3, 4, 5, 6, 7]) >>> root = trimBST(root, 3, 6) >>> inorder_traversal(root) [3, 4, 5, 6] >>> root = build_tree([1, 2, 3, 4, 5, 6, 7]) >>> root = trimBST(root, 2, 4) >>> inorder_traversal(root) [2, 3, 4] ``` # Considerations - Ensure the BST properties are preserved after pruning nodes. - Consider edge cases such as the entire tree being out of range, or the whole tree falling within the range.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def trimBST(root, low, high): if not root: return None # If the current node\'s value is less than low, we only need to consider the right subtree if root.val < low: return trimBST(root.right, low, high) # If the current node\'s value is greater than high, we only need to consider the left subtree if root.val > high: return trimBST(root.left, low, high) # Otherwise, recursively trim the left and right subtrees root.left = trimBST(root.left, low, high) root.right = trimBST(root.right, low, high) return root"},{"question":"# Problem Description You are tasked with implementing a function that identifies the shortest path between two vertices in an undirected, weighted graph. The graph is represented as an adjacency list where each key-value pair maps a vertex to a list of tuples. Each tuple consists of an adjacent vertex and the weight of the edge connecting them. # Function Signature ```python def shortest_path(graph: dict, start: int, end: int) -> list: Find the shortest path between two vertices in an undirected, weighted graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of adjacent vertices with edge weights. start (int): The starting vertex. end (int): The ending vertex. Returns: list: A list of vertices representing the shortest path from start to end. If no path exists, return an empty list. ``` # Input - `graph`: A dictionary representing an undirected, weighted graph. Each key is a vertex, and the corresponding value is a list of tuples (adjacent_vertex, weight). - `start`: An integer representing the starting vertex. - `end`: An integer representing the ending vertex. # Output - A list of integers that represents the vertices in the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints - The graph will have at most 1000 vertices. - Vertex numbers are non-negative integers. - There will always be non-negative weights. - The graph might be sparse or dense. - The input graph is guaranteed to be connected. # Examples ```python test_graph_1 = { 0: [(1, 2), (2, 4)], 1: [(0, 2), (3, 1)], 2: [(0, 4), (3, 2)], 3: [(1, 1), (2, 2)] } test_graph_2 = { 0: [(1, 1)], 1: [(0, 1), (2, 5)], 2: [(1, 5)] } assert shortest_path(test_graph_1, 0, 3) == [0, 1, 3] assert shortest_path(test_graph_2, 0, 2) == [0, 1, 2] assert shortest_path(test_graph_2, 0, 3) == [] ``` # Requirements - Your solution should efficiently handle both sparse and dense graphs. - Utilize an appropriate algorithm to ensure optimal pathfinding. - Consider edge cases such as graphs with no path between the start and end vertices. - Ensure your solution passes basic functionality and edge cases testing. # Note - The order of vertices in the output list matters (it should represent the path from start to end). - If there are multiple shortest paths, any of them is acceptable as output.","solution":"import heapq def shortest_path(graph, start, end): Find the shortest path between two vertices in an undirected, weighted graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of adjacent vertices with edge weights. start (int): The starting vertex. end (int): The ending vertex. Returns: list: A list of vertices representing the shortest path from start to end. If no path exists, return an empty list. # Priority queue to store (cost, node, path) queue = [(0, start, [])] # Distances dictionary to store the minimum distance to each vertex distances = {vertex: float(\'infinity\') for vertex in graph} distances[start] = 0 # While there are vertices to process while queue: (current_cost, current_vertex, path) = heapq.heappop(queue) # Current path path = path + [current_vertex] # If we reached the end vertex, return the path if current_vertex == end: return path # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_cost + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor, path)) # If no path found return []"},{"question":"Task Write a Python function that analyzes the sentiment of customer reviews using a given sentiment analysis API. Input * A base URL for the sentiment analysis API. * A dictionary of parameters that includes the API key, the review text, and the language. Output * A string representing the sentiment of the review, either \\"positive\\", \\"neutral\\", or \\"negative\\". Constraints * The function should handle network errors gracefully and retry a specified number of times before failing. * Maximum allowed retries: 3. * Implement proper exception handling for various potential failures (HTTP errors, parsing errors, etc.) * Ensure the API key is kept secure and not exposed in logs or error messages. Performance * Aim to minimize network calls when possible, with efficient JSON parsing and error handling. Function Signature ```python def analyze_sentiment(api_url: str, params: dict) -> str: ``` Example ```python params = { \\"api_key\\": \\"your_api_key_here\\", \\"review_text\\": \\"The product quality is outstanding and exceeded my expectations.\\", \\"language\\": \\"en\\", } result = analyze_sentiment(\\"https://api.sentimentanalysis.com/analyze\\", params=params) print(result) # Expected output: \\"positive\\" (or similar sentiment) ``` Hint Use `try-except` blocks to handle exceptions, and consider using a retry strategy with a `for` loop or a helper function. Make use of the `requests` library to perform the API call and handle JSON responses.","solution":"import requests from requests.exceptions import HTTPError, ConnectionError, Timeout def analyze_sentiment(api_url: str, params: dict) -> str: retries = 3 for attempt in range(retries): try: response = requests.post(api_url, json=params) response.raise_for_status() # Raise HTTPError for bad responses data = response.json() # Parse JSON response # Ensure JSON contains expected structure if \'sentiment\' in data: return data[\'sentiment\'] else: raise ValueError(\\"Response JSON does not contain \'sentiment\' field\\") except (HTTPError, ConnectionError, Timeout) as e: # Log error without exposing API key print(f\\"Attempt {attempt + 1} failed: {str(e)}\\") except ValueError as ve: # Log error without exposing sensitive data print(f\\"Attempt {attempt + 1} failed: {str(ve)}\\") break return \\"Error analyzing sentiment\\""},{"question":"# Graph Coloring Problem Problem Statement: You are given an undirected graph represented by an adjacency matrix `graph` and an integer `m`. Your task is to determine if the graph can be colored with at most `m` colors such that no two adjacent vertices have the same color. Task: Implement a function `graph_coloring` to determine if it is possible to color the given graph with at most `m` colors. If it is possible, return a list representing one such coloring. If it is not possible, return an empty list. Function Signature: ```python def graph_coloring(graph: list[list[int]], m: int) -> list[int]: ``` Input: * `graph`: A 2D list representing an adjacency matrix of an undirected graph (N x N grid where `graph[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, otherwise `0`). * `m`: An integer representing the maximum number of colors that can be used. Output: * A list of integers where the `i-th` element represents the color assigned to vertex `i` using colors labeled from `0` to `m-1`. Return an empty list if the graph cannot be colored with `m` colors. Constraints: * `1 <= N <= 10`, where `N` is the number of vertices in the graph. * `1 <= m <= N` Example: ```python graph = [ [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0] ] m = 3 print(graph_coloring(graph, m)) # Output: [0, 1, 2, 1] (or any other valid coloring) graph = [ [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0] ] m = 2 print(graph_coloring(graph, m)) # Output: [] ``` Hints: To implement the algorithm, you may: 1. Use a helper function to check the validity of assigning a color to a vertex. 2. Employ backtracking to explore all possible colorings systematically.","solution":"def graph_coloring(graph, m): def is_valid(vertex, colors, c): for i in range(len(graph)): if graph[vertex][i] == 1 and colors[i] == c: return False return True def solve(vertex, colors): if vertex == len(graph): return True for c in range(m): if is_valid(vertex, colors, c): colors[vertex] = c if solve(vertex + 1, colors): return True colors[vertex] = -1 return False colors = [-1] * len(graph) if solve(0, colors): return colors else: return [] # Examples: # graph = [ # [0, 1, 1, 1], # [1, 0, 1, 0], # [1, 1, 0, 1], # [1, 0, 1, 0] # ] # m = 3 # print(graph_coloring(graph, m)) # Output: [0, 1, 2, 1]"},{"question":"# Coding Question: Implement Depth-First Search (DFS) to Find All Possible Paths in a Maze Given a grid (a 2D list) representing a maze, write a function `find_all_paths` that uses the Depth-First Search algorithm to find all possible paths from the start position (top-left corner) to the goal position (bottom-right corner). Each cell in the grid can either be free (`0`) or an obstacle (`1`). **Function Signature**: ```python def find_all_paths(grid: list[list[int]]) -> list[list[tuple[int, int]]]: ``` **Input**: - A 2D list `grid` representing the maze. - `0` represents a free path. - `1` represents an obstacle. - The grid is guaranteed to have at least one row and one column. - The start position is always `(0, 0)`. - The goal position is always `(len(grid)-1, len(grid[0])-1)`. **Output**: - A list of lists, where each inner list is a sequence of tuples representing a valid path from the start position to the goal position (inclusive), in order. - If no path is found, return an empty list. **Constraints**: - The grid will have dimensions not exceeding 20x20. - Moving directions are limited to up, down, left, right (no diagonal moves). **Example**: ```python grid = [ [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 1, 0], [0, 1, 0, 0] ] print(find_all_paths(grid)) ``` Expected output: ```python [ [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (3, 2), (3, 3)], [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (3, 2), (3, 3)] ] ``` **Considerations**: - Handle edge cases like no path available, grid with all obstacles, very small grid sizes, or already at the goal. - Ensure that the function can handle multiple paths and outputs them all.","solution":"def find_all_paths(grid): def dfs(x, y, path): if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or grid[x][y] == 1: return if (x, y) in path: return path.append((x, y)) if (x, y) == (len(grid) - 1, len(grid[0]) - 1): result.append(list(path)) else: for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, path) path.pop() result = [] dfs(0, 0, []) return result"},{"question":"# Problem: Moving Average from Data Stream You are developing a component in a real-time analytics system, where one of the tasks is to compute a moving average of a continuously updating data stream. Function Signature ```python class MovingAverage: def __init__(self, size: int): # initialize your data structure here ... def next(self, val: int) -> float: # add the next value and return the moving average ... ``` Input * The class `MovingAverage` should have its constructor which takes: * `size` (int): An integer, representing the size of the window for which the moving average will be calculated. * The method `next` takes a single integer argument: * `val` (int): The next value in the data stream. Output * The `next` method should return a floating point number, which is the moving average of all integers in the sliding window. Constraints * The number of calls to the `next` method will not exceed 10000. * Ensure that the complexity of each call to the `next` method is O(1). * The return values should be accurate within 0.000001 of the true value. * 1 ≤ size ≤ 1000 * -10^5 ≤ val ≤ 10^5 # Example ```python ma = MovingAverage(3) assert ma.next(1) == 1.0 # [1] assert ma.next(10) == 5.5 # [1, 10] assert ma.next(3) == 4.666666666666667 # [1, 10, 3] assert ma.next(5) == 6.0 # [10, 3, 5] ``` Explanation: * `ma.next(1)` returns `1.0` as the average of `[1]`. * `ma.next(10)` returns `5.5` as the average of `[1, 10]`. * `ma.next(3)` returns `4.666666666666667` as the average of `[1, 10, 3]`. * `ma.next(5)` returns `6.0` as the average of `[10, 3, 5]`. The window only keeps the last 3 values.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"# Scenario You are developing a word-processing application and need to implement a feature to find and replace a specified word in a given text with another word. This involves creating a function that efficiently processes the text to handle multiple occurrences of the target word and replaces them correctly. Additionally, the function should be capable of handling both case-sensitive and case-insensitive replacements. # Requirements 1. **Implementation of a Word Replace Function** - Write a function `replace_word` that takes a text string and replaces all occurrences of a target word with a specified replacement word. - Your function should also take a boolean parameter that indicates whether the replacement should be case-sensitive or not. # Input - `text` (str): The input text in which words need to be replaced. - `target` (str): The word to be replaced. - `replacement` (str): The word to replace the target word with. - `case_sensitive` (bool): A flag to indicate if the replacement should be case-sensitive. # Output - str: The modified text with all occurrences of the target word replaced by the replacement word. # Constraints - The length of `text` will not exceed 5000 characters. - The length of both `target` and `replacement` will not exceed 100 characters. - The input text may contain punctuation and special characters. # Function Signature ```python def replace_word(text: str, target: str, replacement: str, case_sensitive: bool) -> str: pass ``` # Sample Input and Output ```python >>> replace_word(\\"Hello World! Hello everyone.\\", \\"Hello\\", \\"Hi\\", True) \\"Hi World! Hi everyone.\\" >>> replace_word(\\"Hello World! Hello everyone.\\", \\"hello\\", \\"Hi\\", False) \\"Hi World! Hi everyone.\\" >>> replace_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox is quick.\\", \\"quick\\", \\"fast\\", True) \\"The fast brown fox jumps over the lazy dog. The fast brown fox is fast.\\" >>> replace_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox is quick.\\", \\"FOX\\", \\"wolf\\", False) \\"The quick brown wolf jumps over the lazy dog. The quick brown wolf is quick.\\" ``` # Instructions 1. **Replacement Behavior**: Ensure that all occurrences of the target word are replaced correctly. 2. **Case Sensitivity**: Handle both case-sensitive and case-insensitive replacements based on the input flag.","solution":"def replace_word(text: str, target: str, replacement: str, case_sensitive: bool) -> str: Replaces all occurrences of the target word in the input text with the replacement word. Args: - text (str): The input text where replacements should be made. - target (str): The word to be replaced. - replacement (str): The word to replace the target word with. - case_sensitive (bool): Flag to determine if replacement should be case-sensitive. Returns: - str: The modified text with words replaced. if case_sensitive: return text.replace(target, replacement) # Case-insensitive replacement import re text = re.sub(re.escape(target), replacement, text, flags=re.IGNORECASE) return text"},{"question":"# Finding the Majority Element in an Array **Scenario**: Given an array of integers, a majority element is defined as an element that appears more than n/2 times, where n is the number of elements in the array. Your task is to find the majority element if it exists. If no majority element exists, return -1. Task: Implement the function `find_majority_element(nums: List[int]) -> int`. Given a list of integers `nums`, the function should return the majority element if it exists, otherwise return -1. Input: - `nums`: A list of integers. Output: - An integer representing the majority element if it exists, otherwise -1. Constraints: - The length of `nums` will be in the range `[1, 10^5]`. - Elements of `nums` will be integers in the range `[-10^9, 10^9]`. Examples: - When `nums` is `[3, 3, 4, 2, 3, 3, 5, 3]`, the function should return `3`. - When `nums` is `[1, 1, 2, 2, 2]`, the function should return `2`. - When `nums` is `[1, 2, 3]`, the function should return `-1`. # Performance requirements: - The function must efficiently determine the majority element, ideally in linear time complexity O(n). # Notes: - Consider using an algorithm like Boyer-Moore Voting Algorithm for optimal performance in determining the majority element. - Ensure edge cases are handled, such as arrays with single elements or where no majority element exists. Example code snippet to be implemented: ```python from typing import List def find_majority_element(nums: List[int]) -> int: Return the majority element of the array if it exists, otherwise -1. count = 0 candidate = None # Phase 1: Find a candidate for the majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify that the candidate is a majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return -1 ```","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Return the majority element of the array if it exists, otherwise -1. count = 0 candidate = None # Phase 1: Find a candidate for the majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify that the candidate is a majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return -1"},{"question":"# Assessment Question **Q2**: Write a function `count_infections` that takes a list of tuples representing a series of log entries. Each log entry tuple contains three elements: - an integer `time` - a string `event` which could either be `\\"infection\\"` or `\\"recovery\\"` - and an integer `person_id` (unique identifier for a person). The function should return an integer representing the number of people who are currently infected after processing all log entries. ```python def count_infections(logs: list[tuple[int, str, int]]) -> int: Count the number of people currently infected based on the log entries. Each log entry has a timestamp, an event type (either \\"infection\\" or \\"recovery\\"), and a unique person identifier. If a person is infected, they should have exactly one \\"infection\\" event without a subsequent \\"recovery\\" event. If they have a \\"recovery\\" event after an \\"infection\\" event, they should no longer be counted as infected. Args: logs (list[tuple[int, str, int]]): List of log entries representing infections and recoveries. Returns: int: Number of currently infected people. Example: >>> count_infections([(1, \\"infection\\", 101), (2, \\"recovery\\", 101), (3, \\"infection\\", 102)]) 1 >>> count_infections([(1, \\"infection\\", 101), (2, \\"infection\\", 102), (4, \\"recovery\\", 102)]) 1 >>> count_infections([(1, \\"infection\\", 101), (2, \\"infection\\", 102), (3, \\"infection\\", 103)]) 3 pass ``` **Constraints and Notes**: - Assume the log entries are ordered by time in ascending order. - A person cannot have two consecutive \\"infection\\" or \\"recovery\\" events without the other type between them. - If there are no log entries, the count of infections should be 0. **Expected Input and Output**: ```python assert count_infections([(1, \\"infection\\", 101), (2, \\"recovery\\", 101), (3, \\"infection\\", 102)]) == 1 assert count_infections([(1, \\"infection\\", 101), (2, \\"infection\\", 102), (4, \\"recovery\\", 102)]) == 1 assert count_infections([(1, \\"infection\\", 101), (2, \\"infection\\", 102), (3, \\"infection\\", 103)]) == 3 assert count_infections([]) == 0 ```","solution":"def count_infections(logs): Count the number of people currently infected based on the log entries. Each log entry has a timestamp, an event type (either \\"infection\\" or \\"recovery\\"), and a unique person identifier. If a person is infected, they should have exactly one \\"infection\\" event without a subsequent \\"recovery\\" event. If they have a \\"recovery\\" event after an \\"infection\\" event, they should no longer be counted as infected. Args: logs (list[tuple[int, str, int]]): List of log entries representing infections and recoveries. Returns: int: Number of currently infected people. infected_people = set() for log in logs: time, event, person_id = log if event == \\"infection\\": infected_people.add(person_id) elif event == \\"recovery\\": if person_id in infected_people: infected_people.remove(person_id) return len(infected_people)"},{"question":"# Problem Description: Given the existing implementation of a binary search tree (BST), extend its functionality by implementing the following additional method: **Task**: Implement a method `find_level` which finds the level of a given value in the BST. ```python def find_level(self, val: int) -> int: Finds the level of the given value val in the binary search tree. The root node is considered to be at level 0. Time complexity: O(h) where h is the height of the tree. @param val: The value for which to find the level. @returns: The level of the node with value val in the tree if it exists, else -1. Example: >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(13) >>> bst.insert(18) >>> bst.find_level(15) 1 >>> bst.find_level(7) 2 >>> bst.find_level(10) 0 >>> bst.find_level(9) -1 ``` **Input**: - A value `val` (integer) **Output**: - An integer representing the level of the node with value `val` in the BST if it exists, else -1. # Constraints: - The BST must support typical operations such as `insert`, `delete`, `find`, etc. - The `find_level` method must only traverse the tree as necessary to find the level. - Proper handling of edge cases (e.g., empty tree, non-existent elements). # Example Consider a sample usage below: ```python # BST initialization and insertion bst = BinarySearchTree() bst.insert(8) bst.insert(3) bst.insert(10) bst.insert(1) bst.insert(6) bst.insert(14) bst.insert(4) bst.insert(7) # Finding levels print(bst.find_level(10)) # Output: 1 print(bst.find_level(6)) # Output: 2 print(bst.find_level(8)) # Output: 0 print(bst.find_level(17)) # Output: -1 ``` **Notes**: - Ensure the method correctly calculates levels, with the root at level 0. - Handle both typical and edge cases effectively. - Test for various configurations of the BST to ensure reliability.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, root, key): if key < root.val: if root.left: self._insert_rec(root.left, key) else: root.left = Node(key) else: if root.right: self._insert_rec(root.right, key) else: root.right = Node(key) def find_level(self, val): Finds the level of the given value val in the binary search tree. The root node is considered to be at level 0. @param val: The value for which to find the level. @returns: The level of the node with value val in the tree if it exists, else -1. return self._find_level_rec(self.root, val, 0) def _find_level_rec(self, node, val, level): if node is None: return -1 if node.val == val: return level elif val < node.val: return self._find_level_rec(node.left, val, level + 1) else: return self._find_level_rec(node.right, val, level + 1)"},{"question":"# Coding Assessment Question: Implementing a Custom Sorting Algorithm Problem Statement You are required to implement a custom sorting algorithm similar to QuickSort. This sorting algorithm will sort an array of integers in non-descending order. For this task, you will implement a version of the sorting algorithm that handles sorting based on the middle element as the pivot. # Requirements 1. **Function Signature**: Write a function `custom_quick_sort(arr: List[int]) -> List[int>` in Python. 2. **Input**: * A list of integers (`arr`) of length ranging from **0 to 10^6**. 3. **Output**: * A list of integers sorted in non-descending order. 4. **Constraints**: * The input list can be empty. * You must implement the algorithm manually without using any built-in sorting functions. # Steps to Implement 1. **Select Pivot**: * Choose the middle element of the array as the pivot. 2. **Partition the Array**: * Reorder the elements in such a way that all elements less than or equal to the pivot come before all elements greater than the pivot. * The pivot should be in its final sorted position. 3. **Recursively Sort Subarrays**: * Apply the same process recursively to the subarray of elements with smaller values and the subarray of elements with larger values. 4. **Combine**: * Merge the sorted subarrays along with the pivot. # Example ```python def custom_quick_sort(arr: List[int]) -> List[int]: # Implement the required algorithm here pass # Example Usage print(custom_quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(custom_quick_sort([])) # Output: [] print(custom_quick_sort([42])) # Output: [42] ``` # Performance Requirements: * Attempt to achieve a time complexity of O(N log N) on average, where N is the number of elements in the array. * Ensure the algorithm handles edge cases such as an empty array or an array with duplicate elements efficiently.","solution":"from typing import List def custom_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid_index = len(arr) // 2 pivot = arr[mid_index] less_than_pivot = [x for x in arr if x < pivot] equal_to_pivot = [x for x in arr if x == pivot] greater_than_pivot = [x for x in arr if x > pivot] return custom_quick_sort(less_than_pivot) + equal_to_pivot + custom_quick_sort(greater_than_pivot)"},{"question":"# Sequence Validator and Corrector Implement a function `validate_sequence(seq: List[int], replacements: int) -> bool` that determines whether a given sequence of integers can be transformed into a non-decreasing sequence by replacing at most a certain number of elements. Inputs: * `seq`: A list of integers where 1 ≤ n ≤ 10^5. * `replacements`: An integer representing the maximum number of elements that can be replaced. Outputs: * A boolean value: `True` if it\'s possible to transform the sequence into a non-decreasing sequence by replacing at most `replacements` elements, otherwise `False`. Constraints: * The list will always contain at least one element. * Replacements (replacements) can be any non-negative integer. Example Usage: ```python assert validate_sequence([4, 2, 3], 1) == True # Replace \'4\' with \'1\' => [1, 2, 3] assert validate_sequence([4, 2, 1], 1) == False # Cannot fix with only 1 replacement assert validate_sequence([3, 4, 2, 3], 1) == False # Need at least 2 replacements assert validate_sequence([5, 1, 2, 3], 2) == True # Replace \'5\' with \'0\' and continue => [0, 1, 2, 3] assert validate_sequence([1, 3, 2, 4], 1) == True # Replace \'3\' with \'2\' => [1, 2, 2, 4] ``` # Requirements: * Your function should ensure an (O(n)) time complexity. * Ensure to cover edge cases and verify your solution using multiple test scenarios. * Consider the impact of consecutive elements and the total number of replacements allowed to devise an efficient approach.","solution":"def validate_sequence(seq, replacements): n = len(seq) count = 0 for i in range(n - 1): if seq[i] > seq[i + 1]: count += 1 if count > replacements: return False if i > 0 and seq[i - 1] > seq[i + 1]: seq[i + 1] = seq[i] else: seq[i] = seq[i + 1] return True"},{"question":"# Context You are designing an application that processes and manipulates various types of sequences. One of the functionalities of the application is to handle and analyze string sequences. # Problem Statement Write a Python class `StringAnalyzer` that supports the following functionalities: 1. **Initialization**: Should initialize with a string. 2. **Palindrome Check**: Implement a method to check if the string is a palindrome. 3. **Anagram Check**: Implement a method to check if the string is an anagram of another string. 4. **Find Substrings**: Implement a method to find all unique substrings of the string. 5. **Character Frequency**: Implement a method to return a dictionary with the frequency of each character. 6. **Longest Common Subsequence**: Implement a method to find the longest common subsequence between the initialized string and another provided string. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases, error handling, and proper string manipulation considerations. # Implementation Details 1. **Initialization**: ```python class StringAnalyzer: def __init__(self, text: str) -> None: ... ``` 2. **Palindrome Check**: ```python def is_palindrome(self) -> bool: ... ``` 3. **Anagram Check**: ```python def is_anagram(self, other: str) -> bool: ... ``` 4. **Find Substrings**: ```python def find_substrings(self) -> List[str]: ... ``` 5. **Character Frequency**: ```python def char_frequency(self) -> Dict[str, int]: ... ``` 6. **Longest Common Subsequence**: ```python def longest_common_subsequence(self, other: str) -> str: ... ``` # Constraints - The provided string and the string to compare are guaranteed to be non-empty. - Consider upper and lower case letters as distinct characters. # Unit Tests Create a test class `TestStringAnalyzer` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios. # Example ```python text1 = \\"level\\" text2 = \\"llveee\\" analyzer1 = StringAnalyzer(text1) analyzer2 = StringAnalyzer(text2) # Test Palindrome Check print(analyzer1.is_palindrome()) # Should return True print(analyzer2.is_palindrome()) # Should return False # Test Anagram Check print(analyzer1.is_anagram(\\"leevl\\")) # Should return True print(analyzer1.is_anagram(text2)) # Should return False # Test Find Substrings print(analyzer1.find_substrings()) # Should return list of unique substrings # Test Character Frequency print(analyzer1.char_frequency()) # Should return {\'l\': 2, \'e\': 2, \'v\': 1} # Test Longest Common Subsequence print(analyzer1.longest_common_subsequence(\\"vole\\")) # Should return \\"le\\" ```","solution":"from typing import List, Dict class StringAnalyzer: def __init__(self, text: str) -> None: self.text = text def is_palindrome(self) -> bool: return self.text == self.text[::-1] def is_anagram(self, other: str) -> bool: return sorted(self.text) == sorted(other) def find_substrings(self) -> List[str]: substrings = set() for i in range(len(self.text)): for j in range(i + 1, len(self.text) + 1): substrings.add(self.text[i:j]) return list(substrings) def char_frequency(self) -> Dict[str, int]: char_freq = {} for char in self.text: if char in char_freq: char_freq[char] += 1 else: char_freq[char] = 1 return char_freq def longest_common_subsequence(self, other: str) -> str: m, n = len(self.text), len(other) dp = [[\\"\\" for j in range(n + 1)] for i in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if self.text[i - 1] == other[j - 1]: dp[i][j] = dp[i - 1][j - 1] + self.text[i - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len) return dp[m][n]"},{"question":"# Palindrome Permutation Check You are tasked with implementing a function in Python that checks if any permutation of a given string is a palindrome. # Objective Write a function `can_form_palindrome` that determines if any permutation of the input string can form a palindrome. # Function Signature ```python def can_form_palindrome(input_str: str) -> bool: pass ``` # Input - `input_str` (str): The string to check, consisting of lower-case alphabetic characters. # Output - The function should return `True` if any permutation of the given string can form a palindrome. Otherwise, it should return `False`. # Constraints - The length of `input_str` will be between 1 and 100, inclusive. - The string will contain only lower-case alphabetic characters. # Performance - The function should efficiently handle checking permutations without explicitly generating them. # Instructions 1. A string can be permuted to form a palindrome if at most one character has an odd frequency. # Example Scenarios Given: ```python input_str = \\"civic\\" ``` Expected output: ```python True ``` Given: ```python input_str = \\"ivicc\\" ``` Expected output: ```python True ``` Given: ```python input_str = \\"hello\\" ``` Expected output: ```python False ``` # Notes - Consider using a dictionary or a counter to keep track of character frequencies. - This problem focuses on string manipulation and understanding palindrome properties, making it related to fundamental programming concepts.","solution":"from collections import Counter def can_form_palindrome(input_str: str) -> bool: Determines if any permutation of the input string can form a palindrome. Args: input_str (str): The string to check, consisting of lower-case alphabetic characters. Returns: bool: True if any permutation of the given string can form a palindrome, otherwise False. # Get the frequency count of each character in the string char_count = Counter(input_str) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count return odd_count <= 1"},{"question":"# Problem Statement You are in charge of developing a financial analytics module for a trading platform. A crucial feature involves calculating the maximum profit that can be achieved from at most two non-overlapping transactions on a given list of daily stock prices. A transaction consists of a buy and a sell operation, and a trader must sell stocks before buying again. Your task is to write a function that determines the maximum profit possible from at most two such transactions. Function Signature ```python def max_profit_with_two_transactions(prices: list[int]) -> int: Calculate the maximum profit from at most two non-overlapping transactions with the given list of daily stock prices. Args: prices (list[int]): A list of integers representing daily stock prices. Returns: int: The maximum possible profit from at most two transactions. Example: >>> max_profit_with_two_transactions([3,3,5,0,0,3,1,4]) 6 >>> max_profit_with_two_transactions([1,2,3,4,5]) 4 >>> max_profit_with_two_transactions([7,6,4,3,1]) 0 pass ``` # Constraints: * The input list `prices` will have at least 1 and at most 10^5 elements. * Each element in `prices` will be a non-negative integer. # Requirements: * The function should return an integer representing the maximum profit that can be achieved from at most two non-overlapping transactions. * Ensure to handle edge cases where no profit is possible (e.g., prices in decreasing order). * Aim for an optimal and efficient solution to handle the upper limit of input size. # Example: ```python >>> max_profit_with_two_transactions([3,3,5,0,0,3,1,4]) 6 >>> max_profit_with_two_transactions([1,2,3,4,5]) 4 >>> max_profit_with_two_transactions([7,6,4,3,1]) 0 ``` # Performance: * The solution should be efficient in both time and space complexity, ideally achieving a time complexity of O(n).","solution":"def max_profit_with_two_transactions(prices): Calculate the maximum profit from at most two non-overlapping transactions with the given list of daily stock prices. Args: prices (list[int]): A list of integers representing daily stock prices. Returns: int: The maximum possible profit from at most two transactions. if not prices: return 0 n = len(prices) # Initialize arrays for holding the maximum profit up to each day profit1 = [0] * n profit2 = [0] * n # Forward pass to calculate max profit from single transaction up to day i min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i-1], prices[i] - min_price) # Backward pass to calculate max profit from single transaction after day i max_price = prices[-1] for j in range(n-2, -1, -1): max_price = max(max_price, prices[j]) profit2[j] = max(profit2[j+1], max_price - prices[j]) # Combine the two profits to get the max profit with at most two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"**Question**: Design and implement a function to calculate the prime factors of a given integer efficiently. Your function should return a dictionary where the keys are the prime factors and the values are the respective powers of those factors. Write a function `prime_factors` that takes a positive integer `n` as input and returns a dictionary representing the prime factorization of `n`. # Function Signature ```python def prime_factors(n: int) -> dict: ``` # Input * `n` : A positive integer (1 ≤ n ≤ 10^12). # Output * Returns a dictionary where the keys are prime factors of `n` and the values are the powers of those factors. # Example ```python >>> prime_factors(60) {2: 2, 3: 1, 5: 1} >>> prime_factors(130) {2: 1, 5: 1, 13: 1} >>> prime_factors(37) {37: 1} >>> prime_factors(1) {} ``` # Notes * Your function should handle large values of `n` efficiently. * The dictionary keys should be in ascending order of the prime factors. * Edge case: If `n` is 1, the function should return an empty dictionary as 1 has no prime factors.","solution":"def prime_factors(n: int) -> dict: if n < 2: return {} factors = {} # Check for number of 2s that divide n while n % 2 == 0: if 2 in factors: factors[2] += 1 else: factors[2] = 1 n = n // 2 # n must be odd at this point so we can skip 2 for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n = n // i # This condition is to check if n is a prime number # greater than 2 at the end if n > 2: factors[n] = 1 return factors"},{"question":"# Question: String Formatting Enhancement You have been tasked with enhancing a function that formats a given string according to a specified pattern. The function you need to enhance should support additional string manipulation features, such as reversing strings, padding strings to a certain length, and converting strings to alternating case. **Objective**: Enhance the given `string_formatting` function by: 1. **Extending** its capabilities to support new format types. 2. **Including** input validation to ensure correctness. 3. **Ensuring** the solution remains efficient and easy to understand. **Function Signature**: ```python def enhanced_string_formatting(s: str, format_type: str, **kwargs) -> str: pass ``` # Input: - `s` (str): The input string that needs to be formatted. - `format_type` (str): A string specifying the type of formatting to be applied. The allowed values are: \\"reverse\\", \\"pad\\", \\"alternate_case\\". - `**kwargs` (dict): Additional keyword arguments that might be needed for specific format types: - For \\"pad\\": `length` (int) - The desired length of the string after padding. - For \\"pad\\": `pad_char` (str) - The character to use for padding. Defaults to a space. # Output: - Returns a formatted string based on the specified format type or raises appropriate errors for invalid inputs. # Constraints: - The input string `s` may contain any characters. - The `format_type` will always be one of the specified options. - For \\"pad\\", `length` will be a non-negative integer, and `pad_char` will be a single character. - For \\"alternate_case\\", the function should start with the first character in lower case. # Performance Requirements: - The function should run efficiently and ensure minimal overhead. # Detailed Requirements: 1. **Support New Format Types**: Enhance the function to include support for \\"reverse\\", \\"pad\\", and \\"alternate_case\\". 2. **Validation**: - Ensure `format_type` is valid. - For \\"pad\\", validate that `length` is a non-negative integer and `pad_char` is a single character. 3. **Formatting Precision**: Ensure the formatted string adheres to the specified format accurately. # Example Scenarios 1. Reversing a string: ```python assert enhanced_string_formatting(\\"hello\\", \\"reverse\\") == \\"olleh\\" ``` 2. Padding a string: ```python assert enhanced_string_formatting(\\"hello\\", \\"pad\\", length=10, pad_char=\'*\') == \\"hello*****\\" ``` 3. Converting to alternating case: ```python assert enhanced_string_formatting(\\"string\\", \\"alternate_case\\") == \\"sTrInG\\" ``` 4. Handling unsupported format types: ```python try: enhanced_string_formatting(\\"test\\", \\"unknown\\") except ValueError as e: print(e) # Expected output: \\"Invalid \'format_type\' value: \'unknown\'. Supported values are \'reverse\', \'pad\', \'alternate_case\'.\\" ``` # Specific Challenge: You need to handle varying input scenarios and ensure the function is robust and efficient. For instance: ```python # Reversing a string assert enhanced_string_formatting(\\"Python\\", \\"reverse\\") == \\"nohtyP\\" # Padding a string assert enhanced_string_formatting(\\"Data\\", \\"pad\\", length=8, pad_char=\'_\') == \\"Data____\\" # Converting to alternating case assert enhanced_string_formatting(\\"code\\", \\"alternate_case\\") == \\"cOdE\\" ``` Implement the `enhanced_string_formatting` function to cover these examples and any other valid scenarios.","solution":"def enhanced_string_formatting(s: str, format_type: str, **kwargs) -> str: def reverse_string(s: str) -> str: return s[::-1] def pad_string(s: str, length: int, pad_char: str = \' \') -> str: if not isinstance(length, int) or length < 0: raise ValueError(\\"length must be a non-negative integer\\") if not isinstance(pad_char, str) or len(pad_char) != 1: raise ValueError(\\"pad_char must be a single character\\") return s.ljust(length, pad_char) def alternate_case_string(s: str) -> str: result = [] for i, char in enumerate(s): if i % 2 == 0: result.append(char.lower()) else: result.append(char.upper()) return \'\'.join(result) if format_type == \'reverse\': return reverse_string(s) elif format_type == \'pad\': length = kwargs.get(\'length\', 0) pad_char = kwargs.get(\'pad_char\', \' \') return pad_string(s, length, pad_char) elif format_type == \'alternate_case\': return alternate_case_string(s) else: raise ValueError(f\\"Invalid \'format_type\' value: \'{format_type}\'. Supported values are \'reverse\', \'pad\', \'alternate_case\'.\\")"},{"question":"# Problem Description Design an algorithm that takes a list of integers and returns a new list containing only the even numbers from the original list, sorted in ascending order. The function must validate the input to ensure that it is a list of integers. If the input is not a list or contains non-integer elements, the function should raise a `TypeError`. # Function Signature ```python def filter_and_sort_evens(input_list: list) -> list: pass ``` # Input * **input_list** (list): A list of integers. # Output * **result_list** (list): A list of even integers sorted in ascending order. # Constraints * The input must be a list of integers. * If the input is not a list or contains non-integer elements, the function should raise a `TypeError`. # Examples ```python >>> filter_and_sort_evens([4, 7, 2, 9, 10, 3, 6]) [2, 4, 6, 10] >>> filter_and_sort_evens([1, 3, 5, 7, 9]) [] >>> filter_and_sort_evens([10, 20, 30, 40]) [10, 20, 30, 40] >>> filter_and_sort_evens(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers. >>> filter_and_sort_evens([1, 2, \'three\', 4]) Traceback (most recent call last): ... TypeError: Input must be a list of integers. ``` # Note - The function should ensure the input is strictly a list of integers through appropriate type checking. - The return value should be an empty list if there are no even numbers in the input list. - Implement proper error handling to manage inappropriate inputs as illustrated in the examples.","solution":"def filter_and_sort_evens(input_list: list) -> list: Returns a new list containing only the even numbers from the original list, sorted in ascending order. Raises a TypeError if the input is not a list or contains non-integer elements. if not isinstance(input_list, list): raise TypeError(\\"Input must be a list of integers.\\") for item in input_list: if not isinstance(item, int): raise TypeError(\\"Input must be a list of integers.\\") even_numbers = [num for num in input_list if num % 2 == 0] return sorted(even_numbers)"},{"question":"# Question: Write a Python function that determines the validity and area of a triangle given the lengths of its three sides. Your function should first validate if the three sides can actually form a triangle using the triangle inequality theorem. If they do, compute the area using Heron\'s formula. Your function should handle potential error scenarios and edge cases adeptly. Function Signature ```python def triangle_area(sides: tuple) -> float: pass ``` Input - `sides` (tuple): A tuple containing exactly three positive float values representing the lengths of the triangle\'s sides. Output - `float`: The area of the triangle if the sides form a valid triangle. If not, return or raise an appropriate exception/message. Constraints - The sides will be positive floats. Example Input: ```python sides = (3.0, 4.0, 5.0) ``` Output: ```python 6.0 ``` Input: ```python sides = (1.0, 1.0, 2.0) ``` Output: ```python ValueError: The provided sides do not form a valid triangle. ``` Notes - Make sure to handle the validation of the sides according to the triangle inequality theorem. - Raise appropriate exceptions for invalid cases. - Use Heron\'s formula for calculating the area of the triangle: - ( s = frac{a + b + c}{2} ) - Area = ( sqrt{s cdot (s-a) cdot (s-b) cdot (s-c)} )","solution":"import math def triangle_area(sides: tuple) -> float: Returns the area of the triangle if the sides form a valid triangle. Raises a ValueError if the sides do not form a valid triangle. sides: A tuple containing exactly three positive float values representing the lengths of the triangle\'s sides. a, b, c = sides # Validate the sides using the triangle inequality theorem if not (a + b > c and a + c > b and b + c > a): raise ValueError(\\"The provided sides do not form a valid triangle.\\") # Calculate the semi-perimeter s = (a + b + c) / 2 # Calculate the area using Heron\'s formula area = math.sqrt(s * (s - a) * (s - b) * (s - c)) return area"},{"question":"# Coding Assessment Question **Context**: You are given a binary tree and you need to determine whether the binary tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. **Function Specification**: **Function Name**: is_balanced **Parameters**: * `root: TreeNode`: The root node of the binary tree. **Return**: * `bool`: Return True if the binary tree is height-balanced, otherwise return False. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are in the range [-10^5, 10^5]. **Example**: ```python # Example 1: # Input: [3, 9, 20, None, None, 15, 7] # Output: True # Explanation: The input represents the following binary tree: # 3 # / # 9 20 # / # 15 7 # The above binary tree is balanced because the depth difference of the left and right subtrees of every node is not more than 1. # Example 2: # Input: [1, 2, 2, 3, 3, None, None, 4, 4] # Output: False # Explanation: The input represents the following binary tree: # 1 # / # 2 2 # / # 3 3 # / # 4 4 # The depth difference between the left and right subtrees of node 1 is 2, which is more than 1, hence this binary tree is not balanced. # Example 3: # Input: [] # Output: True # Explanation: An empty tree is considered balanced. ``` # Instructions: 1. Implement the function `is_balanced` that determines whether a given binary tree is height-balanced. 2. Use the `TreeNode` class definition provided below to construct the binary tree for testing. 3. Make sure to handle edge cases, such as an empty tree or a tree with a single node. ```python # TreeNode class definition class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"# TreeNode class definition class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines whether a given binary tree is height-balanced. :param TreeNode root: The root node of the binary tree. :return: True if the binary tree is height-balanced, otherwise False. :rtype: bool def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_height(root) return balanced"},{"question":"# Problem Statement A logistic company uses a unique way to manage its delivery trucks. Each truck can only carry a certain number of packages based on the truck\'s capacity, preferred weather conditions, and distance constraints. Write a program to determine which trucks can be utilized for a given set of packages, considering each truck\'s limitations. # Function Signature ```python def can_use_truck(truck_capacity: int, preferred_weather: str, max_distance: int, packages: list[dict], current_weather: str, delivery_distance: int) -> bool: pass def assign_trucks(trucks: list[dict], packages: list[dict], current_weather: str, delivery_distance: int) -> list[int]: pass ``` # Detailed Requirements `can_use_truck` Function 1. **Input**: - `truck_capacity` (int): Maximum number of packages a truck can carry. - `preferred_weather` (str): The preferred weather conditions for the truck (e.g., \\"Sunny\\", \\"Rainy\\"). - `max_distance` (int): The maximum distance the truck can travel in kilometers. - `packages` (list[dict]): A list of packages, each represented as a dictionary with the following keys: - `\'weight\'` (float): The weight of the package. - `current_weather` (str): The current weather condition. - `delivery_distance` (int): The distance to the delivery destination in kilometers. 2. **Output**: - Returns `True` if the truck can be used for the packages under current conditions, otherwise returns `False`. 3. **Examples**: ```python >>> packages = [{\'weight\': 10.5}, {\'weight\': 5.2}, {\'weight\': 8.8}] >>> can_use_truck(3, \'Sunny\', 100, packages, \'Sunny\', 80) True >>> can_use_truck(2, \'Rainy\', 50, packages, \'Sunny\', 80) False ``` `assign_trucks` Function 1. **Input**: - `trucks` (list[dict]): A list of trucks, each represented as a dictionary with the following keys: - `\'capacity\'` (int): The maximum capacity of the truck. - `\'weather\'` (str): The preferred weather of the truck. - `\'distance\'` (int): The maximum distance the truck can travel. - `packages` (list[dict]): A list of packages, each represented as a dictionary with the following keys: - `\'weight\'` (float): The weight of the package. - `current_weather` (str): The current weather condition. - `delivery_distance` (int): The distance to the delivery destination in kilometers. 2. **Output**: - Returns a list of indices representing the trucks that can be used for the packages under the current conditions. 3. **Examples**: ```python >>> trucks = [ ... {\'capacity\': 3, \'weather\': \'Sunny\', \'distance\': 100}, ... {\'capacity\': 2, \'weather\': \'Rainy\', \'distance\': 50}, ... {\'capacity\': 4, \'weather\': \'Sunny\', \'distance\': 120} ... ] >>> packages = [{\'weight\': 10.5}, {\'weight\': 5.2}, {\'weight\': 8.8}] >>> assign_trucks(trucks, packages, \'Sunny\', 80) [0, 2] ``` # Constraints 1. The number of trucks and packages will each be between 1 and 100, inclusive. 2. Each package\'s weight will be a float between 0.1 and 50.0, inclusive. 3. Truck capacity will be an integer between 1 and 10, inclusive. 4. Maximum distance will be an integer between 10 and 300, inclusive. 5. Weather conditions are strings and can be any of these values: \\"Sunny\\", \\"Rainy\\", \\"Snowy\\", \\"Windy\\". # Notes - Ensure that the implementation handles all edge cases gracefully. - Assume the weight of the packages is cumulative and the total weight should not affect the truck choice beyond the package count.","solution":"def can_use_truck(truck_capacity, preferred_weather, max_distance, packages, current_weather, delivery_distance): Determines if a truck can be used for the given packages under the current conditions. if current_weather != preferred_weather: return False if delivery_distance > max_distance: return False if len(packages) > truck_capacity: return False return True def assign_trucks(trucks, packages, current_weather, delivery_distance): Assign trucks that can be used for the given packages under the current conditions. suitable_trucks = [] for index, truck in enumerate(trucks): if can_use_truck(truck[\'capacity\'], truck[\'weather\'], truck[\'distance\'], packages, current_weather, delivery_distance): suitable_trucks.append(index) return suitable_trucks"},{"question":"# Scenario A software development firm often organizes coding competitions and they want to automate the process of checking if a given string is a valid palindrome after performing a series of character replacements. They want a solution that determines whether it is possible to convert the given string to a palindrome by replacing at most one character. # Problem Statement Implement the function `can_form_palindrome(s: str) -> bool` which returns a boolean value indicating whether the input string can be transformed into a palindrome by replacing at most one character. # Function Signature ```python def can_form_palindrome(s: str) -> bool: ``` # Input - `s` (str): The input string consisting of lowercase alphabetic characters. # Output - `bool`: A boolean value indicating whether it’s possible to convert the input string into a palindrome by replacing at most one character. # Constraints - The input string `s` will be non-empty and its length will not exceed 1000. # Examples ```python can_form_palindrome(\\"abca\\") -> True can_form_palindrome(\\"abc\\") -> False can_form_palindrome(\\"radar\\") -> True ``` # Guidelines 1. A palindrome reads the same forward and backward, so the function checks the input string against this property. 2. Use two pointers (one starting from the beginning and the other from the end) to compare characters and identify if up to one replacement can make the string a palindrome. 3. Consider edge cases such as single-character strings and already palindromic strings. # Hints - If the string is already a palindrome, the function should return `True`. - The function should allow for exactly one character replacement to still return `True`. - Efficiently navigate the string using two pointers to minimize the number of comparisons and operations. ```python def can_form_palindrome(s: str) -> bool: def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True ``` Note: The provided function checks the palindrome property by allowing one mismatch and then validating the substring to test if it would turn into a palindrome after that single allowed change.","solution":"def can_form_palindrome(s: str) -> bool: Determine if the input string can be transformed into a palindrome by replacing at most one character. Parameters: s (str): Input string Returns: bool: True if string can be converted to a palindrome by replacing at most one character, otherwise False. def is_palindrome_range(i, j): Check if the substring s[i:j+1] is a palindrome. Parameters: i (int): Start index j (int): End index Returns: bool: True if the substring is a palindrome, otherwise False. while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"# Question You are tasked with devising a strategy to balance a binary search tree (BST) using a list of integers as input. The objective is to ensure that the BST is height-balanced, meaning the depth of the left and right subtrees of every node differ by at most 1. Given the following requirements: - Implement a Python function `balance_bst()` that accepts a list of integers and constructs a balanced BST. - The function should return the root of the BST, represented as a node object, maintaining the properties of a binary search tree. # Function Signature ```python def balance_bst(nums: List[int]) -> Optional[TreeNode]: pass ``` # Parameters - `nums`: A list of integers which may contain duplicates, representing the values to be inserted into the BST. # Returns - The root node of the balanced BST. # Constraints - The input list is guaranteed to have at least one integer. - The BST nodes should be created using the provided `TreeNode` class. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None nums = [3, 1, 4, 2, 2] root = balance_bst(nums) print_bst(root) # Example function to display the BST structure # Example Output: # A possible balanced BST for the above input could be: # 2 # / # 1 3 # # 2 4 ``` # Additional Note - Ensure the function constructs a balanced BST with minimal height. - Consider the average-case complexity for common input sizes and handle edge cases effectively. - You may assume that the print_bst function is a utility to display the structure of the BST in a human-readable form. The provided `TreeNode` class is as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid + 1:]) return root def balance_bst(nums: List[int]) -> Optional[TreeNode]: nums.sort() return sorted_array_to_bst(nums)"},{"question":"# Longest Subsequence Without Repeating Characters **Context:** In a string, a subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. For example, \\"abc\\", \\"ace\\", and \\"bde\\" are subsequences of \\"abcde\\". We are concerned with finding the length of the longest subsequence without repeating characters. **Task:** Write a function that returns the length of the longest subsequence without repeating characters. The function should work efficiently and handle edge cases well. **Function Signature:** ```python def longest_unique_subsequence(s: str) -> int: ``` **Input:** - `s` (string): The input string for which the calculation is to be made. **Output:** - `int` : The length of the longest subsequence with all unique characters. **Constraints:** - 0 <= len(s) <= 1000 (This ensures the function operates within reasonable time limits) **Example:** ```python >>> longest_unique_subsequence(\\"abcabcbb\\") 3 >>> longest_unique_subsequence(\\"bbbbb\\") 1 >>> longest_unique_subsequence(\\"pwwkew\\") 3 ``` **Explanation:** The function `longest_unique_subsequence` should compute the length of the longest subsequence of characters in the input string `s` that does not contain any repeated characters. For instance, in the example \\"abcabcbb\\", the answer is 3 because the longest subsequence with all unique characters is \\"abc\\". The function should use efficient algorithms to ensure it performs well within the given constraints.","solution":"def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence without repeating characters. # Dictionary to store the last occurrence index of every character. last_occurrence = {} start = 0 # Starting index of current window max_length = 0 for i, char in enumerate(s): # If character is already in the dictionary and the index is within the current window if char in last_occurrence and last_occurrence[char] >= start: # Move the start to one past the last occurrence of the current character start = last_occurrence[char] + 1 # Update the last occurrence of the character last_occurrence[char] = i # Calculate the length of the current window max_length = max(max_length, i - start + 1) return max_length"},{"question":"# Coding Assessment Question Context You are tasked with developing a new feature for a text processing library that includes a variety of string manipulation functions. One such function that needs implementation is reversing the vowels in a given string while leaving other characters in their original positions. Task Implement a function that reverses the vowels in a given string. Vowels are considered to be \'a\', \'e\', \'i\', \'o\', \'u\', both uppercase and lowercase. Requirements 1. **Function Definition**: Implement a function named `reverse_vowels` which takes a string as input and returns a new string with the vowels reversed. 2. **Input**: A string `s` consisting of printable ASCII characters. 3. **Output**: A new string where the vowels are reversed in order, and all other characters remain in their original positions. 4. **Constraints**: * You must handle both uppercase and lowercase vowels. * You should consider edge cases such as an empty string, a string with no vowels, and a string with all vowels. 5. **Performance**: The implementation should have a linear time complexity of O(n), where n is the length of the string. Function Signature ```python def reverse_vowels(s: str) -> str: pass ``` Example 1. Input: `\\"hello\\"` Output: `\\"holle\\"` 2. Input: `\\"leetcode\\"` Output: `\\"leotcede\\"` 3. Input: `\\"aA\\"` Output: `\\"Aa\\"` 4. Input: `\\"bcdfgh\\"` Output: `\\"bcdfgh\\"` Testing * Ensure to test your `reverse_vowels` implementation with various test cases, including edge cases like strings with no vowels, and performance with large strings. * Compare your results with manual calculations to verify correctness.","solution":"def reverse_vowels(s: str) -> str: Returns a new string where the vowels in the input string are reversed. vowels = set(\'aeiouAEIOU\') s_list = list(s) i, j = 0, len(s) - 1 while i < j: if s_list[i] not in vowels: i += 1 elif s_list[j] not in vowels: j -= 1 else: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return \'\'.join(s_list)"},{"question":"# Logarithmic Transformation for Linear Model **Scenario**: You are analyzing data where the relationship between the independent variables and the dependent variable is multiplicative rather than additive. To linearize the data and hence apply a linear model, you decide to use a logarithmic transformation. Then, you will fit a simple linear regression model to the transformed data. **Task**: Implement a class in Python that performs logarithmic transformation on the input data and fits a linear regression model on the transformed data using Ordinary Least Squares (OLS) estimation. The class should perform the following tasks: 1. Transform the input data using a logarithmic transformation. 2. Fit the linear model parameters on the logarithmically transformed data. 3. Predict the target values for new data points using the fitted model. **Function Signature**: ```python class LogTransformLinearRegression: def __init__(self) -> None: pass def log_transform(self, data: np.ndarray) -> np.ndarray: pass def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None: pass def predict(self, data: np.ndarray) -> np.ndarray: pass ``` # Constraints: 1. **Inputs**: - `x_train`: 1-D numpy array of shape (N,) with predictor values. - `y_train`: 1-D numpy array of shape (N,) with response values. - Predictor values for prediction should be given as a 1-D numpy array. 2. **Outputs**: - Fitted model parameters as a 1-D numpy array. - Predicted response values for a given set of predictor values (in the original scale). **Example**: ```python # Examples of fitting and prediction: import numpy as np x_train = np.array([1, 2, 3, 4, 5]) y_train = np.array([2.5, 6.2, 12.5, 23.7, 40.5]) log_reg = LogTransformLinearRegression() log_reg.fit(x_train, y_train) # Check fitted parameters print(log_reg.params) # Output might be close to [-0.35, 1.5] # Predict x_predict = np.array([6, 7, 8]) predictions = log_reg.predict(x_predict) print(predictions) # Expected output close to [61.5, 90.8, 129.5] # Ensure raising errors for invalid cases try: log_reg.fit(np.array([-1, 0, 2]), np.array([1, 1, 1])) except ValueError as e: print(e) # Expected: \\"Log transformation only applies to positive values\\" ``` # Performance Requirements: 1. Ensure the implementation handles numerical stability during logarithmic transformations and OLS estimation. 2. Optimize the computation to handle large input arrays efficiently by leveraging efficient numpy operations and avoiding redundant calculations.","solution":"import numpy as np class LogTransformLinearRegression: def __init__(self) -> None: self.params = None def log_transform(self, data: np.ndarray) -> np.ndarray: if not np.all(data > 0): raise ValueError(\\"Log transformation only applies to positive values\\") return np.log(data) def fit(self, x_train: np.ndarray, y_train: np.ndarray) -> None: x_log = self.log_transform(x_train) y_log = self.log_transform(y_train) # Add a column of ones to include the intercept in the model X = np.vstack([np.ones_like(x_log), x_log]).T # Ordinary least squares estimation: beta = (X^T X)^(-1) X^T y XtX = X.T @ X XtX_inv = np.linalg.inv(XtX) XtY = X.T @ y_log self.params = XtX_inv @ XtY def predict(self, x_pred: np.ndarray) -> np.ndarray: if self.params is None: raise ValueError(\\"The model is not fitted yet. Please call the \'fit\' method first.\\") x_log_pred = self.log_transform(x_pred) X_pred = np.vstack([np.ones_like(x_log_pred), x_log_pred]).T y_log_pred = X_pred @ self.params return np.exp(y_log_pred) # Example usage: # log_reg = LogTransformLinearRegression() # log_reg.fit(np.array([1,2,3,4,5]), np.array([2.5, 6.2, 12.5, 23.7, 40.5])) # predictions = log_reg.predict(np.array([6,7,8]))"},{"question":"# Coding Question You are required to modernize a basic text-based calculator with additional functionalities for various mathematical operations. The provided skeleton script includes functions for basic arithmetic operations (addition, subtraction, multiplication, division) and a simple calculator interface. Objective Enhance the existing functionalities to support additional operations and ensure robustness in handling various cases. 1. **Enhance Existing Functions**: - Modify the arithmetic functions to handle an arbitrary number of arguments (i.e., support operations on more than two numbers). - Update the division function to handle division by zero gracefully, returning an error message instead of raising an exception. 2. **Add New Functionalities**: - Implement a `power` function to compute the result of raising one number to the power of another. - Implement a `factorial` function that calculates the factorial of a non-negative integer. - Update the `main` function’s interface to allow the user to select which operation to perform and input the required numbers. Function Implementations - **add(*args: float) -> float**: - Input: Arbitrary number of numeric arguments. - Output: Sum of all arguments. - **subtract(*args: float) -> float**: - Input: Arbitrary number of numeric arguments. - Output: Result of subtracting all subsequent arguments from the first one. - **multiply(*args: float) -> float**: - Input: Arbitrary number of numeric arguments. - Output: Product of all arguments. - **divide(*args: float) -> Union[float, str]**: - Input: Arbitrary number of numeric arguments. - Output: Result of sequential division or an error message if division by zero is attempted. - **power(base: float, exponent: float) -> float**: - Input: Two numbers, `base` and `exponent`. - Output: Result of raising `base` to the power of `exponent`. - **factorial(n: int) -> Union[int, str]**: - Input: A non-negative integer `n`. - Output: Factorial of the number `n` or an error message if `n` is negative. - **main()**: - Prompt the user to select an operation and input the required numbers. - Handle invalid inputs and re-prompt the user until valid data is provided. Example ```python >>> add(1, 2, 3, 4) 10 >>> subtract(10, 2, 1) 7 >>> multiply(2, 3, 4) 24 >>> divide(100, 2, 5) 10.0 >>> divide(10, 0) \\"Error: Division by zero is undefined.\\" >>> power(2, 3) 8 >>> factorial(5) 120 >>> factorial(-2) \\"Error: Factorial of a negative number is undefined.\\" ``` Ensure to handle edge cases and validate user inputs thoroughly.","solution":"def add(*args): Returns the sum of all arguments. return sum(args) def subtract(*args): Returns the result of subtracting all subsequent arguments from the first one. if not args: return 0 result = args[0] for num in args[1:]: result -= num return result def multiply(*args): Returns the product of all arguments. result = 1 for num in args: result *= num return result def divide(*args): Returns the result of sequential division or an error message if division by zero is attempted. if not args: return \\"Error: No numbers provided.\\" result = args[0] try: for num in args[1:]: result /= num except ZeroDivisionError: return \\"Error: Division by zero is undefined.\\" return result def power(base, exponent): Computes the result of raising base to the power of exponent. return base ** exponent def factorial(n): Calculates the factorial of a non-negative integer. if n < 0: return \\"Error: Factorial of a negative number is undefined.\\" if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Assessment Question: Interval Overlap Detection Context You are developing software to manage time schedules. A critical functionality involves determining if two given time intervals overlap. Each interval is represented by a start time and an end time, where the end time is always greater than the start time. Time intervals are given as integers representing minutes from the start of the day (0 to 1440). Task Write a function `do_intervals_overlap(start1, end1, start2, end2)` that takes four integers: * `start1` (start time of the first interval) * `end1` (end time of the first interval) * `start2` (start time of the second interval) * `end2` (end time of the second interval) The function should return: * `True` if the intervals overlap. * `False` otherwise. Constraints 1. `0 <= start1 < end1 <= 1440` 2. `0 <= start2 < end2 <= 1440` Example ```python def do_intervals_overlap(start1, end1, start2, end2): # your implementation here # Example usage print(do_intervals_overlap(120, 180, 150, 210)) # Output: True print(do_intervals_overlap(300, 400, 500, 600)) # Output: False print(do_intervals_overlap(700, 800, 750, 850)) # Output: True ``` Implementation Considerations * An overlap occurs if the start of one interval is before the end of the other interval and the end of one interval is after the start of the other interval. * Handle boundary cases where intervals just touch each other at endpoints (e.g., `(100, 200)` and `(200, 300)`) by returning `False`.","solution":"def do_intervals_overlap(start1, end1, start2, end2): Determines if two given intervals overlap. :param start1: Start time of the first interval. :param end1: End time of the first interval. :param start2: Start time of the second interval. :param end2: End time of the second interval. :return: True if intervals overlap, False otherwise. return start1 < end2 and start2 < end1"},{"question":"# Coding Assessment Question Scenario You are designing an online reservation system for a conference hall where multiple events occur. To manage the bookings, you need to ensure there\'s no double-booking and handle overlapping reservations efficiently. Implement a QTree (a custom data structure similar to a segment tree or interval tree) to keep track of reservations and quickly check for availability in a particular time range. Task Implement the `add_reservation` and `is_available` functions to manage the conference hall reservations using the QTree to efficiently manage and query time intervals. Function Definitions 1. **add_reservation**: * **Input**: - An instance of QTree. - Two integers (`start_time`, `end_time`) representing the time interval for the reservation. * **Output**: A boolean value indicating if the reservation was added (`True` if successfully added, `False` otherwise). * **Constraints**: - Ensure the interval is valid (i.e., `start_time` < `end_time`). 2. **is_available**: * **Input**: - An instance of QTree. - Two integers (`start_time`, `end_time`) representing the desired time range to check for availability. * **Output**: A boolean value indicating if the specified time interval is available (`True` if available, `False` otherwise). * **Constraints**: - Ensure the interval is valid (i.e., `start_time` < `end_time`). Sample Usage ```python qtree = QTree() assert qtree.add_reservation(10, 20) == True assert qtree.is_available(15, 25) == False assert qtree.is_available(20, 25) == True assert qtree.add_reservation(20, 30) == True assert qtree.is_available(15, 18) == False assert qtree.is_available(30, 40) == True assert qtree.add_reservation(5, 15) == False # Overlaps with existing reservation ``` # Requirements * Design the QTree class and its methods to efficiently manage and query intervals. * Validate inputs to ensure robustness against invalid intervals. * Optimize the operations to handle frequent and possibly overlapping reservations. Constraints * Time intervals are represented in integers. * Maximum number of reservations ( n leq 10^5 ). * Each `start_time` and `end_time` can range from 0 to ( 10^9 ). * Ensure your implementation is efficient with constraints and handles both small and large inputs seamlessly. # QTree Example Implementation (Optional) To give a concrete example, a simplified implementation of the QTree might be as follows: ```python class QTree: def __init__(self): self.intervals = [] def add_reservation(self, start_time, end_time): for start, end in self.intervals: if not (end_time <= start or start_time >= end): return False self.intervals.append((start_time, end_time)) return True def is_available(self, start_time, end_time): for start, end in self.intervals: if not (end_time <= start or start_time >= end): return False return True ``` **Note:** The provided sample implementation can be used as a starting point, but for the assessment, applicants should enhance it to handle the constraints and ensure optimized performance.","solution":"class QTree: def __init__(self): self.intervals = [] def add_reservation(self, start_time, end_time): if start_time >= end_time: return False for start, end in self.intervals: if not (end_time <= start or start_time >= end): return False self.intervals.append((start_time, end_time)) return True def is_available(self, start_time, end_time): if start_time >= end_time: return False for start, end in self.intervals: if not (end_time <= start or start_time >= end): return False return True"},{"question":"**Context**: You are given a class that represents a simple `Stack` data structure supporting basic operations like push, pop, and peek. However, the current implementation does not have a feature to get the minimum element quickly while maintaining the other operations\' efficiency. **Objective:** Implement the `get_min` method in the given `Stack` class that returns the smallest element in the stack. This method must efficiently return the minimum element in constant time. **Function Signature:** ```python def get_min(self) -> int: Return the minimum element in the stack. Returns: int: The minimum element in the stack. Examples: >>> stack = Stack() >>> stack.push(3) >>> stack.push(5) >>> stack.push(2) >>> stack.push(1) >>> stack.push(1) >>> stack.push(-1) >>> stack.get_min() -1 >>> stack.pop() >>> stack.get_min() 1 ``` **Constraints:** - The `get_min` method should run in O(1) time complexity. - Do not alter the existing stack structure significantly, and the solution must support all other standard stack operations efficiently. - Ensure the stack operations (push, pop) remain at the same time complexity. **Hints:** - Consider using an additional stack to keep track of the minimum elements. **Examples:** 1. Finding minimum in a stack with multiple elements: ```python stack = Stack() stack.push(3) stack.push(5) stack.push(2) stack.push(1) stack.push(1) stack.push(-1) assert stack.get_min() == -1 stack.pop() assert stack.get_min() == 1 stack.pop() assert stack.get_min() == 1 stack.pop() assert stack.get_min() == 2 ``` 2. Finding minimum in an empty stack: ```python stack = Stack() try: stack.get_min() except IndexError: pass # Correctly raises an error or whatever is desired behavior for this edge case. ``` 3. Finding minimum in a stack with a single element: ```python stack = Stack() stack.push(42) assert stack.get_min() == 42 stack.pop() try: stack.get_min() except IndexError: pass # Correctly raises an error or whatever is desired behavior for this edge case. ```","solution":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def get_min(self): if not self.min_stack: raise IndexError(\\"get_min from an empty stack\\") return self.min_stack[-1]"},{"question":"# Find Pair with Given Sum in Rotated Sorted Array You are given a sorted array that has been rotated at an unknown pivot. Your task is to find if there exists a pair of elements in the array whose sum equals the given target value. Rotated sorted array means a sorted array is rotated by an unknown number of positions. For example, [4, 5, 6, 7, 0, 1, 2] is a rotated array from sorted array [0, 1, 2, 4, 5, 6, 7]. # Requirements: 1. Write a function `has_pair_with_sum(arr: List[int], target: int) -> bool` which takes a rotated sorted array and a target integer as input. 2. The function should return `True` if there exists a pair of elements in the array whose sum equals the target value, otherwise, return `False`. 3. You should aim to achieve a time complexity better than O(n^2). # Input: - `arr`: A list of integers representing the rotated sorted array. - `target`: An integer representing the target sum. # Output: - A boolean value indicating whether a pair exists with the sum equal to the target value. # Constraints: - The array will have a length between 1 and (10^5). - The array elements and the target integer will range between (-10^4) and (10^4). # Example: ```python # Example Usage: has_pair_with_sum([4, 5, 6, 7, 0, 1, 2], 9) # -> True (4 + 5 = 9) has_pair_with_sum([4, 5, 6, 7, 0, 1, 2], 10) # -> True (4 + 6 = 10) has_pair_with_sum([4, 5, 6, 7, 0, 1, 2], 3) # -> True (1 + 2 = 3) has_pair_with_sum([4, 5, 6, 7, 0, 1, 2], 14) # -> False # Note: The actual output may vary depending on the provided inputs. ``` # Additional Information: - A rotated sorted array retains the properties of a sorted array but has two subarrays that are sorted individually. - Consider using techniques such as binary search to find the pivot or leveraging two-pointer strategy to solve the problem efficiently.","solution":"def has_pair_with_sum(arr, target): # Helper function to find the index of the smallest element (pivot) def find_pivot(arr): low, high = 0, len(arr) - 1 while low < high: mid = (low + high) // 2 if arr[mid] > arr[high]: low = mid + 1 else: high = mid return low n = len(arr) if n == 0: return False pivot = find_pivot(arr) # Now we use two pointers to find the pair left = pivot right = (pivot - 1 + n) % n while left != right: current_sum = arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left = (left + 1) % n else: right = (right - 1 + n) % n return False"},{"question":"# Problem Statement Given a string composed of digits ranging from \'2\' to \'9\', return all possible letter combinations that the number could represent. This mapping follows the same rules as found on a traditional telephone touchpad (where 2 maps to \\"abc\\", 3 maps to \\"def\\", and so on). # Objective Write a function `letter_combinations(digits: str) -> list[str]` that takes a string of digits and returns all possible letter combinations as a list of strings. # Description - Your function should use a recursive backtracking approach to explore all possible combinations. - Ensure that the output only includes valid combinations where each digit has been mapped to its corresponding letters. # Input Format - A string `digits` composed of digits between \'2\' and \'9\'. # Output Format - A list of strings, each string representing a possible letter combination. # Constraints - The input string `digits` will have a length between 0 and 4. - An empty input string should return an empty list. # Performance Requirements - The time complexity should ideally be O(4^n) or better, where n is the length of the input string. - The space complexity should ideally be O(n) due to recursion stack limitations. # Examples Example 1: ```python letter_combinations(\\"23\\") ``` **Output:** ```python [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` Example 2: ```python letter_combinations(\\"9\\") ``` **Output:** ```python [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] ``` Example 3: ```python letter_combinations(\\"\\") ``` **Output:** ```python [] ``` # Scenario or Context Consider you\'re working at a telecommunications company, and you need to generate potential mnemonic phrases for telephone numbers to help customers remember their phone numbers better. Implementing the above function can help generate all possible mnemonic combinations for a given set of digits based on the traditional phone keypad mappings, making it easier for customers to choose memorable phone numbers.","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } result = [] def backtrack(index, path): if index == len(digits): result.append(path) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) backtrack(0, \\"\\") return result"},{"question":"# Problem Statement Given a list of integers `arr` representing the heights of buildings, write a function `max_skyline_area(arr)` that returns the maximum possible area of a rectangle formed by the buildings\' heights in a continuous subarray. # Function Signature ```python def max_skyline_area(arr: List[int]) -> int: ``` # Input - `arr`: A list of integers where `1 <= len(arr) <= 10000` and all elements are non-negative integers representing building heights. # Output - An integer representing the maximum possible area of a rectangle that can be formed by the building heights in a continuous subarray. # Constraints - Building heights are always non-negative integers. - If `arr` is empty, return `0`. # Example ```python print(max_skyline_area([2, 1, 5, 6, 2, 3])) # Outputs: 10 print(max_skyline_area([0,3,5,0,0,5,6,0,4])) # Outputs: 10 ``` # Explanation - In the first example, the maximum possible area is formed by the height of `5` and `6`, which spans two buildings, resulting in an area of `5 * 2 = 10`. - In the second example, the maximum possible area is formed by the height of `5` and `6`, resulting in an area of `5 * 2 = 10`. # Scenario You are tasked with analyzing a city\'s skyline for urban planning purposes. This function will help in determining the largest contiguous area that can be occupied by a set of buildings in the skyline, which is crucial for planning large public spaces, parks, or commercial zones. # Notes - Ensure edge cases like an empty array or all zero heights are considered. - Aim for an efficient solution that handles the input size within acceptable limits.","solution":"from typing import List def max_skyline_area(arr: List[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() if stack: area = arr[top_of_stack] * (index - stack[-1] - 1) else: area = arr[top_of_stack] * index max_area = max(max_area, area) while stack: top_of_stack = stack.pop() if stack: area = arr[top_of_stack] * (index - stack[-1] - 1) else: area = arr[top_of_stack] * index max_area = max(max_area, area) return max_area"},{"question":"# Coding Assessment Question You are tasked with writing a function to analyze student scores in a provided dataset. The function should be able to compute the average score for a class, determine the top scorer, and list students who scored above a specified threshold. Write a function named `analyze_scores` that takes in a list of dictionaries where each dictionary represents a student with their \'name\' and \'score\'. Additionally, the function should take a threshold score as an argument. The function should return a dictionary containing the following: 1. `average_score`: The average score of the class. 2. `top_scorer`: The name of the student with the highest score. 3. `above_threshold`: A list of names of students whose scores are above the given threshold. Function Signature: ```python def analyze_scores(students: list[dict[str, str|float]], threshold: float) -> dict[str, float|str|list[str]]: pass ``` # Requirements - **Parameters**: - `students`: A list of dictionaries where each dictionary has: - `\'name\'`: A string representing the student\'s name. - `\'score\'`: A float representing the student\'s score. - `threshold`: A float value representing the score threshold. - **Returns**: - A dictionary containing the `average_score` (float), `top_scorer` (string), and `above_threshold` (list of strings). - **Constraints**: - The list `students` is non-empty. - Each student has a unique name. - Scores are non-negative values. # Examples 1. ```python analyze_scores([{\'name\': \'Alice\', \'score\': 88.5}, {\'name\': \'Bob\', \'score\': 91.0}, {\'name\': \'Charlie\', \'score\': 78.0}], 80.0) ``` Should return: ```python {\'average_score\': 85.83333333333333, \'top_scorer\': \'Bob\', \'above_threshold\': [\'Alice\', \'Bob\']} ``` 2. ```python analyze_scores([{\'name\': \'David\', \'score\': 69.0}, {\'name\': \'Eve\', \'score\': 85.2}, {\'name\': \'Frank\', \'score\': 72.5}], 75.0) ``` Should return: ```python {\'average_score\': 75.56666666666666, \'top_scorer\': \'Eve\', \'above_threshold\': [\'Eve\']} ```","solution":"def analyze_scores(students, threshold): Analyzes student scores to compute the average score, top scorer, and those who scored above the threshold. Parameters: - students (list of dict): List where each dict contains \'name\' (str) and \'score\' (float). - threshold (float): The threshold score to consider. Returns: - dict: A dictionary containing \'average_score\', \'top_scorer\', and \'above_threshold\'. total_score = 0 top_scorer = None top_score = float(\'-inf\') above_threshold = [] for student in students: total_score += student[\'score\'] if student[\'score\'] > top_score: top_score = student[\'score\'] top_scorer = student[\'name\'] if student[\'score\'] > threshold: above_threshold.append(student[\'name\']) average_score = total_score / len(students) return { \'average_score\': average_score, \'top_scorer\': top_scorer, \'above_threshold\': above_threshold }"},{"question":"# Coding Assessment Question: Evaluation of Balanced Binary Numbers Context A binary number is considered balanced if it has an equal number of \'0\'s and \'1\'s. You are tasked with generating all possible balanced binary numbers of a given even length. Objective Implement a function `generate_balanced_binaries(length: int) -> List[str]` that returns a list of all balanced binary numbers of the specified length in lexicographical order. Input/Output Formats - **Input**: * An even integer `length` (2 ≤ length ≤ 20). - **Output**: * A list of strings representing all balanced binary numbers of the specified length, sorted in lexicographical order. Constraints - The length will always be an even number. - A balanced binary number will have exactly `length // 2` \'0\'s and `length // 2` \'1\'s. - Efficiently generate the binary numbers without redundant computations. Performance Requirements - Ensure that the generation process is optimal and avoids combinatorial explosion. Example ```python def generate_balanced_binaries(length: int) -> List[str]: # Implementation here print(generate_balanced_binaries(4)) # Expected Output: [\'0011\', \'0101\', \'0110\', \'1001\', \'1010\', \'1100\'] print(generate_balanced_binaries(6)) # Expected Output: [\'000111\', \'001011\', \'001101\', \'001110\', \'010011\', \'010101\', \'010110\', \'011001\', \'011010\', \'011100\', \'100011\', \'100101\', \'100110\', \'101001\', \'101010\', \'101100\', \'110001\', \'110010\', \'110100\', \'111000\'] ``` Create the function using efficient combinatorial techniques to ensure all balanced binary sequences can be produced and returned within the constraints.","solution":"from itertools import permutations def generate_balanced_binaries(length: int): Generates all balanced binary numbers of a given even length. half_length = length // 2 base_sequence = \'0\' * half_length + \'1\' * half_length unique_permutations = set(permutations(base_sequence)) result = sorted(\'\'.join(p) for p in unique_permutations) return result"},{"question":"# Question: Expense Tracking and Reporting You have been assigned the task of developing a simple expense tracker that records expenses under different categories and generates summary reports. Implement required functionalities to add new expenses and generate a report showing total expenses per category. Function Specifications: 1. **Function Name: `ExpenseTracker`** 2. **Functionality**: - Initialize an empty tracker with no expenses. - Add an expense under a specific category. - Generate a summary report showing the total expense for each category. 3. **Methods**: - `add_expense(category: str, amount: float) -> None`: Adds an expense amount under the specified category. - `generate_report() -> Dict[str, float]`: Returns a dictionary with categories as keys and total expenses for each category as values. 4. **Constraints**: - Categories are case-insensitive. \'Grocery\' and \'grocery\' should be treated the same. - Amounts must be positive floats. Raise `ValueError` for non-positive amounts. Example: ```python tracker = ExpenseTracker() tracker.add_expense(\'Grocery\', 100.0) tracker.add_expense(\'Grocery\', 50.0) tracker.add_expense(\'EntErTainMeNT\', 75.0) tracker.add_expense(\'entertainment\', 25.0) # Generate report print(tracker.generate_report()) # Output: {\'grocery\': 150.0, \'entertainment\': 100.0} # Invalid example tracker.add_expense(\'Travel\', -50.0) # Raises ValueError: Amount must be a positive number. ``` Detailed Requirements: - Ensure the `add_expense` method raises a `ValueError` for non-positive expenses. - Treat categories in a case-insensitive manner when adding expenses and generating reports. - Use dictionaries to manage the categories and their respective expenses. - Write sufficient tests to validate your implementation, including edge cases and error handling. Implementation ```python class ExpenseTracker: def __init__(self): self.expenses = {} def add_expense(self, category, amount): if amount <= 0: raise ValueError(\\"Amount must be a positive number.\\") category = category.lower() if category in self.expenses: self.expenses[category] += amount else: self.expenses[category] = amount def generate_report(self): return self.expenses ``` This question provides a comprehensive scenario involving expense tracking, focusing on dictionary operations, string manipulation, input validation, and error handling, which align well with the topics and complexity of the initial question set.","solution":"class ExpenseTracker: def __init__(self): self.expenses = {} # Initialize an empty dictionary to track expenses def add_expense(self, category, amount): Adds an expense to the given category. Categories are case-insensitive. Parameters: category (str): The category under which the expense is added. amount (float): The amount of the expense. Must be a positive number. Raises: ValueError: If the amount is not a positive number. if amount <= 0: raise ValueError(\\"Amount must be a positive number.\\") category = category.lower() if category in self.expenses: self.expenses[category] += amount else: self.expenses[category] = amount def generate_report(self): Generates a summary report showing the total expenses for each category. Returns: Dict[str, float]: A dictionary with categories as keys and total expenses as values. return self.expenses"},{"question":"# Phonebook CRUD Application Scenario: You are required to write a simple phonebook application that supports basic CRUD (Create, Read, Update, Delete) operations. This phonebook will store information about contacts, including their name, phone number, and email address. The data will be stored in a JSON file to persist between program runs. Task: Write a Python class `Phonebook` that: 1. Initializes and loads data from an existing JSON file if available, otherwise creates a new phonebook. 2. Provides methods to add a new contact, retrieve a contact by name, update a contact\'s information, and delete a contact. 3. Saves the phonebook data back to the JSON file after any modification. Requirements: * Use the `json` module to read from and write to a JSON file. * Include error handling for file operations and ensure data integrity. * Ensure the class methods operate on the internal data structure without directly interacting with the file on every operation; the file should only be accessed when loading or saving data. Class Methods: 1. `add_contact(name: str, phone: str, email: str) -> None`: Adds a new contact. If the contact already exists (based on the name), raise a ValueError. 2. `get_contact(name: str) -> dict`: Retrieves the contact information by name. If the contact does not exist, return `None`. 3. `update_contact(name: str, phone: Optional[str] = None, email: Optional[str] = None) -> None`: Updates the contact\'s phone number, email, or both. If the contact does not exist, raise a ValueError. 4. `delete_contact(name: str) -> None`: Deletes the contact by name. If the contact does not exist, raise a ValueError. 5. `save_to_file() -> None`: Saves the current state of the phonebook to the JSON file. Input: * Only the methods will receive input according to their parameters. Output: * The methods do not return any value except `get_contact`, which returns a dictionary with contact information if found, or `None` otherwise. Constraints: * Assume that contact names are unique. * The JSON file should be named \\"phonebook.json\\". * Properly handle the creation of the file if it doesn\'t exist initially. Example Usage: ```python pb = Phonebook() # Adding a contact pb.add_contact(\\"John Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") # Retrieving a contact print(pb.get_contact(\\"John Doe\\")) # Output: {\'name\': \'John Doe\', \'phone\': \'123-456-7890\', \'email\': \'john.doe@example.com\'} # Updating a contact pb.update_contact(\\"John Doe\\", phone=\\"098-765-4321\\") # Deleting a contact pb.delete_contact(\\"John Doe\\") # Saving phonebook to file pb.save_to_file() ``` This class should seamlessly manage basic CRUD operations on a phonebook stored in a JSON file.","solution":"import json import os class Phonebook: def __init__(self, filename=\'phonebook.json\'): Initializes the phonebook by loading data from a JSON file. If the file does not exist, it initializes an empty phonebook. self.filename = filename self.contacts = self.load_from_file() def load_from_file(self): Loads data from the JSON file. if os.path.exists(self.filename): with open(self.filename, \'r\') as file: return json.load(file) else: return {} def save_to_file(self): Saves the current state of the phonebook to the JSON file with open(self.filename, \'w\') as file: json.dump(self.contacts, file, indent=4) def add_contact(self, name, phone, email): Adds a new contact. If the contact already exists, raises a ValueError. if name in self.contacts: raise ValueError(f\\"Contact with name \'{name}\' already exists.\\") self.contacts[name] = {\'phone\': phone, \'email\': email} self.save_to_file() def get_contact(self, name): Retrieves the contact information by name. If not found, returns None. return self.contacts.get(name) def update_contact(self, name, phone=None, email=None): Updates a contact\'s phone number, email, or both. If the contact does not exist, raises a ValueError. if name not in self.contacts: raise ValueError(f\\"Contact with name \'{name}\' does not exist.\\") if phone: self.contacts[name][\'phone\'] = phone if email: self.contacts[name][\'email\'] = email self.save_to_file() def delete_contact(self, name): Deletes a contact by name. If the contact does not exist, raises a ValueError. if name not in self.contacts: raise ValueError(f\\"Contact with name \'{name}\' does not exist.\\") del self.contacts[name] self.save_to_file()"},{"question":"# Coding Assessment Question Scenario Imagine you are developing a management system for a bakery to help them manage customer orders efficiently. Orders need to be tracked, sorted and processed based on customer priorities and specific constraints. Task 1. **Function Implementation**: Implement a function `process_orders` that takes a list of orders and processes them in a specified manner. Each order is an object with properties: `order_id`, `customer_name`, `priority`, and `order_time`. 2. **Detailed Steps**: - Define the function `process_orders(orders: List[Order]) -> List[Order]`. 3. **Requirements**: * The list `orders` contains instances of the `Order` class. * The function should sort the orders based on the following criteria in descending order of importance: 1. Priority (higher priority first) 2. Order time (earlier orders first) * Return the sorted list of orders. 4. **Example**: ```python class Order: def __init__(self, order_id, customer_name, priority, order_time): self.order_id = order_id self.customer_name = customer_name self.priority = priority self.order_time = order_time def __repr__(self): return f\\"Order({self.order_id}, {self.customer_name}, {self.priority}, {self.order_time})\\" order1 = Order(101, \\"Alice\\", 3, \\"10:00\\") order2 = Order(102, \\"Bob\\", 2, \\"09:45\\") order3 = Order(103, \\"Charlie\\", 3, \\"09:30\\") orders = [order1, order2, order3] sorted_orders = process_orders(orders) print(sorted_orders) # Output should be: # [Order(103, Charlie, 3, 09:30), Order(101, Alice, 3, 10:00), Order(102, Bob, 2, 09:45)] ``` Constraints * **Input**: - The input list might contain up to 1000 orders. - The `priority` is an integer where a higher number indicates higher priority. - `order_time` is formatted as `HH:MM` in 24-hour time. * **Expected Output**: - A sorted list of orders based on the given criteria. Performance Requirements * The sorting operation should run in O(n log n) time complexity. * Ensure that the function handles edge cases such as identical priorities and order times gracefully.","solution":"from typing import List, NamedTuple class Order(NamedTuple): order_id: int customer_name: str priority: int order_time: str def process_orders(orders: List[Order]) -> List[Order]: Process and sort orders based on priority and order time. return sorted(orders, key=lambda x: (-x.priority, x.order_time))"},{"question":"# Context You are developing a monitoring system that tracks resource requests in a distributed computing environment. Each request has an associated process and a timestamp. You need to implement a function that can determine the maximum number of concurrent requests at any given time. # Task Implement a function `max_concurrent_requests(requests: List[Tuple[int, int]]) -> int` that returns the maximum number of concurrent requests. Each request is represented as a tuple `(start_time, end_time)` indicating when the request began and ended. # Input and Output * **Input**: * `requests` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a request. * **Output**: * An integer representing the maximum number of concurrent requests. # Constraints * The `requests` list will contain between 1 and 10,000 requests. * Start and end times will be positive integers. # Example ```python example_requests = [ (1, 4), (2, 5), (7, 9), (3, 6) ] print(max_concurrent_requests(example_requests)) # Expected Output: 3 example_requests = [ (1, 3), (5, 8), (4, 6), (7, 9) ] print(max_concurrent_requests(example_requests)) # Expected Output: 2 ``` # Performance Requirements The function should be efficient with a time complexity of O(N log N) due to the sorting of the times, and it should handle up to 10,000 requests smoothly. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def max_concurrent_requests(requests): Returns the maximum number of concurrent requests. events = [] for start, end in requests: events.append((start, \'start\')) events.append((end, \'end\')) events.sort() concurrent_requests = 0 max_requests = 0 for time, event in events: if event == \'start\': concurrent_requests += 1 max_requests = max(max_requests, concurrent_requests) else: concurrent_requests -= 1 return max_requests"},{"question":"# Coding Assessment Question **Context:** You are required to manipulate strings in a way that embeds repeating substrings efficiently. Given a string, the task is to determine the length of the shortest string that can be formed by repeating one of its substrings some number of times. **Problem Statement:** Write a function `shortest_repeating_string_length(s: str) -> int` that takes in a string `s` and returns the length of the shortest string that can be formed by repeatedly concatenating one of the substrings of `s`. **Input:** - A string `s` composed of lowercase alphabets where `1 ≤ length of s ≤ 1000`. **Output:** - An integer representing the length of the shortest repeating string. If the given string itself is the shortest repeating string, return its length. **Constraints:** - The input string will always contain only lowercase alphabets. - The function should be efficient to handle the maximum input size. # Function Signature ```python def shortest_repeating_string_length(s: str) -> int: pass ``` # Examples ```python # Example 1: print(shortest_repeating_string_length(\\"ababab\\")) # Output: 2 # Example 2: print(shortest_repeating_string_length(\\"aaaa\\")) # Output: 1 # Example 3: print(shortest_repeating_string_length(\\"abcabcabc\\")) # Output: 3 # Example 4: print(shortest_repeating_string_length(\\"abcdef\\")) # Output: 6 ```","solution":"def shortest_repeating_string_length(s: str) -> int: Returns the length of the shortest substring of s that can be repeated to form the entire string. n = len(s) # Check for every possible substring length from 1 to n/2 for i in range(1, n // 2 + 1): if n % i == 0: # Only consider lengths that evenly divide n if s[:i] * (n // i) == s: return i return n # If no such substring exists, return the length of the string itself"},{"question":"Additional Coding Assessment: Implementing K-Nearest Neighbors (KNN) **Objective**: Implement the K-Nearest Neighbors (KNN) algorithm to classify a set of instances. You will use the provided KNN model and utility functions as a reference to create new components to demonstrate your understanding. # Problem Statement Given a series of steps and predefined functions for KNN, implement additional functionality to classify unknown instances using the trained KNN model. Your task is to complete the KNN process, follow a given standard, and handle edge cases appropriately. # Scenario A retailer wants to use KNN to classify products into different categories based on their features. They have historical data with known classifications. Your role is to implement the classification model and use it to predict new product categories given their features. # Requirements 1. **Function to Fit KNN Model**: * Input: `features` (2D list of feature values), `labels` (list of corresponding labels), `k` (number of neighbors). * Output: Trained model represented as a tuple containing `features`, `labels`, and `k`. 2. **Function to Predict Instances**: * Input: `unknown_features` (2D list of feature values of unknown instances), `model` (Trained model tuple from step 1). * Output: List of predicted classes for the unknown instances. 3. **Utility Function to Calculate Accuracy**: * Input: `actual_labels` (list of actual classes), `predicted_labels` (list of predicted classes). * Output: Accuracy percentage. # Input and Output Format **Function 1: fit_knn_model** ```python def fit_knn_model(features: list[list[float]], labels: list[int], k: int) -> tuple: pass ``` **Function 2: predict_instances** ```python def predict_instances(unknown_features: list[list[float]], model: tuple) -> list[int]: pass ``` **Function 3: calculate_accuracy** ```python def calculate_accuracy(actual_labels: list[int], predicted_labels: list[int]) -> float: pass ``` # Constraints * Assume that `k` will be a positive integer less than the number of training instances. * Resolve ties in predictions by choosing the class that appears first among the tied neighbors. # Example ```python # Example data features = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], ] labels = [0, 0, 1, 1] k = 3 # Fit the KNN model model = fit_knn_model(features, labels, k) # New instances unknown_features = [ [1.2, 2.1], [6.0, 7.5], ] # Predict using the model predicted = predict_instances(unknown_features, model) print(predicted) # Expected output: [0, 1] # Calculate accuracy (assuming actual labels are provided for testing) actual_labels = [0, 1] accuracy = calculate_accuracy(actual_labels, predicted) print(accuracy) # Expected output: 100.0 ``` * **Edge Cases**: * Handle cases where there are insufficient data points to locate `k` neighbors. * Ensure the algorithm can handle multiple points with the same closest distance. # Submission Complete the missing functions to fit the KNN model, predict classes for unknown instances, and calculate the accuracy of predictions. Ensure your solution passes provided examples and edge cases effectively.","solution":"import math from collections import Counter def fit_knn_model(features, labels, k): Fits the KNN model given features, labels, and the number of neighbors (k). Returns a tuple representing the model. return (features, labels, k) def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def predict_instances(unknown_features, model): Predicts the classes for unknown instances using the trained model. Returns a list of predicted labels. features, labels, k = model def predict(unknown_feature): distances = [(euclidean_distance(unknown_feature, feature), label) for feature, label in zip(features, labels)] distances.sort(key=lambda x: x[0]) k_nearest_labels = [label for _, label in distances[:k]] most_common = Counter(k_nearest_labels).most_common() predicted_label = most_common[0][0] return predicted_label return [predict(unknown_feature) for unknown_feature in unknown_features] def calculate_accuracy(actual_labels, predicted_labels): Calculates the accuracy given the actual and predicted labels. Returns accuracy as a percentage. correct_predictions = sum(1 for actual, predicted in zip(actual_labels, predicted_labels) if actual == predicted) return (correct_predictions / len(actual_labels)) * 100"},{"question":"# Linear Interpolation Calculation Linear interpolation is a method of estimating an unknown value that falls between two known values. Given two points `p0` and `p1` on a plane (each with an x and y coordinate), the linear interpolation for a given x value can be calculated as follows: [ y = y0 + left(frac{(y1 - y0)}{(x1 - x0)}right) cdot (x - x0) ] **Problem Statement:** Implement a function that performs linear interpolation given two points and a new x value. The function should calculate the corresponding y value using the provided formula. **Function Signature:** ```python def linear_interpolation(p0: tuple, p1: tuple, x: float) -> float: Calculate the y value at the given x using linear interpolation. :param p0: A tuple representing the first point (x0, y0). :param p1: A tuple representing the second point (x1, y1). :param x: The x value at which to interpolate the y value. :return: The interpolated y value. :raises ValueError: If x0 is equal to x1, as division by zero is not possible. ``` **Requirements:** 1. Ensure that `p0` and `p1` are valid points (tuples) with exactly two elements each. 2. If `x0` is equal to `x1`, raise a `ValueError` as linear interpolation wouldn\'t be possible. 3. Calculate the corresponding y value at the specified x using linear interpolation formula. 4. Return the calculated y value. **Examples:** ```python >>> linear_interpolation((1, 2), (3, 4), 2) 3.0 >>> linear_interpolation((0, 0), (4, 8), 2) 4.0 >>> linear_interpolation((1, 1), (1, 2), 1) Traceback (most recent call last): ... ValueError: x0 and x1 cannot be equal >>> linear_interpolation((1.5, 2.5), (3.5, 3.5), 2.5) 3.0 >> linear_interpolation((1, 1), (3, 3), 4) 4.0 ``` Ensure that your implementation correctly handles edge cases and provides appropriate error messages where necessary.","solution":"def linear_interpolation(p0: tuple, p1: tuple, x: float) -> float: Calculate the y value at the given x using linear interpolation. :param p0: A tuple representing the first point (x0, y0). :param p1: A tuple representing the second point (x1, y1). :param x: The x value at which to interpolate the y value. :return: The interpolated y value. :raises ValueError: If x0 is equal to x1, as division by zero is not possible. x0, y0 = p0 x1, y1 = p1 if x0 == x1: raise ValueError(\\"x0 and x1 cannot be equal\\") # Linear interpolation formula y = y0 + ((y1 - y0) / (x1 - x0)) * (x - x0) return y"},{"question":"# Question: You are required to implement a function that reads a CSV file containing user data, processes the data, and writes the processed results into a new CSV file. The user data includes user ID, name, and email. The processing steps include: 1. Filtering out any rows where the email format is invalid. 2. Removing any trailing and leading whitespace from the name field for all remaining rows. 3. Converting the name to title case (where the first letter of each word is uppercase). 4. Generating a new CSV file that includes only the valid, cleaned entries. Your function should handle common I/O errors, such as file not found. Assume the input CSV file has a header with columns \\"user_id\\", \\"name\\", and \\"email\\". Specifications: * **Function Name**: `process_user_data` * **Inputs**: - `input_csv_path`: A string representing the file path of the input CSV file. - `output_csv_path`: A string representing the file path for the output CSV file. * **Outputs**: - A string message indicating the success or failure of the operation. * **Constraints**: - The function must handle I/O errors gracefully. - Consider an email valid if it matches the pattern `username@domain`. - Ensure all leading/trailing whitespaces are removed and the name is in title case. - Assume the input CSV file is well-formed but might contain invalid email formats. Example: ```python input_csv_path = \\"user_data.csv\\" output_csv_path = \\"cleaned_user_data.csv\\" print(process_user_data(input_csv_path, output_csv_path)) # Possible output: \\"Data processed and saved in the file cleaned_user_data.csv\\" # or appropriate error messages if the operation fails. ``` **Note**: Ensure your function is self-contained and does not depend on global variables.","solution":"import csv import re def process_user_data(input_csv_path, output_csv_path): Processes user data from an input CSV file and writes cleaned data to an output CSV file. Parameters: input_csv_path (str): The file path of the input CSV file. output_csv_path (str): The file path for the output CSV file. Returns: str: A message indicating the success or failure of the operation. valid_email_pattern = r\'^[w.-]+@[w.-]+\' try: with open(input_csv_path, mode=\'r\', newline=\'\', encoding=\'utf-8\') as infile: reader = csv.DictReader(infile) # Prepare the output file with open(output_csv_path, mode=\'w\', newline=\'\', encoding=\'utf-8\') as outfile: fieldnames = reader.fieldnames writer = csv.DictWriter(outfile, fieldnames=fieldnames) writer.writeheader() for row in reader: name = row[\'name\'].strip().title() email = row[\'email\'] # Validate email format if re.match(valid_email_pattern, email): # Write the cleaned row to the output file writer.writerow({\'user_id\': row[\'user_id\'], \'name\': name, \'email\': email}) return f\\"Data processed and saved in the file {output_csv_path}\\" except FileNotFoundError: return \\"Error: The input file was not found.\\" except Exception as e: return f\\"An error occurred: {e}\\""},{"question":"# Coding Assessment Question You are provided with a set representing the velocity-time relationship of a moving object in physics. The goal is to write a function that calculates one missing value (initial velocity, final velocity, acceleration, or time) given the other three. Function Specification Function Name: `motion_parameters` Parameters: - `initial_velocity` (float): Initial velocity of the object. - `final_velocity` (float): Final velocity of the object. - `acceleration` (float): Acceleration of the object. - `time` (float): Time duration during which the object is moving. Returns: - A tuple `(str, float)` where the string indicates which value was computed (`\'initial_velocity\'`, `\'final_velocity\'`, `\'acceleration\'`, or `\'time\'`) and the float is the computed value. Constraints - Exactly one of `initial_velocity`, `final_velocity`, `acceleration`, or `time` must be zero. - Non-zero values must be positive. - Input values must be of type float. Exception Handling - Raise a `ValueError` if criteria for inputs are not met. Examples ```python >>> motion_parameters(initial_velocity=0, final_velocity=30, acceleration=5, time=0) (\'time\', 6.0) >>> motion_parameters(initial_velocity=0, final_velocity=0, acceleration=10, time=2) (\'final_velocity\', 20.0) >>> motion_parameters(initial_velocity=20, final_velocity=0, acceleration=0, time=4) (\'acceleration\', -5.0) >>> motion_parameters(initial_velocity=0, final_velocity=16, acceleration=8, time=0) (\'time\', 2.0) ``` Write the function `motion_parameters` to solve the problem using the constraints and requirements provided.","solution":"def motion_parameters(initial_velocity: float, final_velocity: float, acceleration: float, time: float): Calculates the missing motion parameter given three out of four parameters (initial_velocity, final_velocity, acceleration, and time). Parameters: initial_velocity (float): Initial velocity of the object. final_velocity (float): Final velocity of the object. acceleration (float): Acceleration of the object. time (float): Time duration during which the object is moving. Returns: tuple: A tuple where the first element is the name of the computed parameter and the second element is the computed value. Raises: ValueError: If exactly one of the parameters is not zero. # Validate input zero_count = sum(1 for param in [initial_velocity, final_velocity, acceleration, time] if param == 0) if zero_count != 1: raise ValueError(\\"Exactly one of the parameters must be zero\\") # Calculate the missing parameter if initial_velocity == 0: initial_velocity = final_velocity - acceleration * time return (\'initial_velocity\', initial_velocity) elif final_velocity == 0: final_velocity = initial_velocity + acceleration * time return (\'final_velocity\', final_velocity) elif acceleration == 0: acceleration = (final_velocity - initial_velocity) / time return (\'acceleration\', acceleration) elif time == 0: time = (final_velocity - initial_velocity) / acceleration return (\'time\', time) raise ValueError(\\"Unexpected error\\")"},{"question":"# Context Bob is developing a compression algorithm for his software, and he needs a way to identify the longest common prefix in a given list of strings. To proceed with his development, he must equip his algorithm with a function that determines the longest common prefix shared among all strings in the list. # Task Write a function `longest_common_prefix` that accepts a list of strings and returns the longest common prefix. If there is no common prefix, the function should return an empty string. # Input - The input is a list of strings, where each string consists of lowercase English letters only. - The length of the list does not exceed 2000, and the length of each individual string does not exceed 1000. # Output - A string representing the longest common prefix among the input list of strings. # Example ```python strings = [\\"flower\\", \\"flow\\", \\"flight\\"] longest_common_prefix(strings) ``` Expected Output: ``` \\"fl\\" ``` # Constraints - The list contains up to 2000 strings. - Each string has a length up to 1000 characters. - The list and strings are non-empty. # Performance Requirements - Ensure the function handles the maximum length efficiently, avoiding quadratic time complexity where possible.","solution":"def longest_common_prefix(strs): Returns the longest common prefix in the list of input strings. :param strs: List[str] :return: str if not strs: return \\"\\" # Start by assuming the longest common prefix is the first string prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and len(prefix) > 0: # Reduce the prefix by one character from the end prefix = prefix[:len(prefix)-1] # If at any point, the prefix is empty, we can return immediately if not prefix: return \\"\\" return prefix"},{"question":"# Problem Statement Implement a function that simulates a dashboard display system incorporating battery-saving measures by dimming the display when the data is unchanged over a period. Your solution should focus on efficient memory usage and minimal computational overhead, especially when handling high-frequency data updates. # Objectives 1. **Function `update_dashboard(data: dict, threshold: int) -> str`:** - **Input**: - A `data`: a dictionary containing keys as sensor names and values as current sensor readings (integers). - A `threshold`: an integer specifying the number of consecutive updates a sensor\'s value must remain unchanged before the display is considered for dimming. - **Output**: A string indicating the actions taken: - \\"display updated\\" if any sensor value has changed. - \\"display dimmed\\" if no sensor values have changed and the threshold is reached. - \\"no change\\" if no sensor values have changed but the threshold is not yet reached. - **Constraints**: Assume there could be up to 100,000 sensor readings updated per second. - **Requirements**: - Track the number of consecutive updates with unchanged values for each sensor. - Efficiently update the dashboard without unnecessary computations. # Examples ```python class Dashboard: def __init__(self, threshold: int): self.threshold = threshold self.previous_data = {} self.unchanged_count = {} def update_dashboard(self, data: dict) -> str: display_updated = False for sensor, value in data.items(): if sensor not in self.previous_data or self.previous_data[sensor] != value: self.previous_data[sensor] = value self.unchanged_count[sensor] = 0 display_updated = True else: self.unchanged_count[sensor] += 1 if display_updated: return \\"display updated\\" elif any(count >= self.threshold for count in self.unchanged_count.values()): return \\"display dimmed\\" else: return \\"no change\\" # Example usage: dashboard = Dashboard(threshold=3) assert dashboard.update_dashboard({\'temp\': 25, \'pressure\': 1013}) == \\"display updated\\" assert dashboard.update_dashboard({\'temp\': 25, \'pressure\': 1013}) == \\"no change\\" assert dashboard.update_dashboard({\'temp\': 25, \'pressure\': 1013}) == \\"no change\\" assert dashboard.update_dashboard({\'temp\': 25, \'pressure\': 1013}) == \\"display dimmed\\" assert dashboard.update_dashboard({\'temp\': 26, \'pressure\': 1015}) == \\"display updated\\" ``` Write your function to accurately simulate the dashboard\'s behavior under the given constraints and requirements. Ensure to test it with various scenarios to cover different edge cases and data frequencies.","solution":"class Dashboard: def __init__(self, threshold: int): self.threshold = threshold self.previous_data = {} self.unchanged_count = {} def update_dashboard(self, data: dict) -> str: display_updated = False for sensor, value in data.items(): if sensor not in self.previous_data or self.previous_data[sensor] != value: self.previous_data[sensor] = value self.unchanged_count[sensor] = 0 display_updated = True else: self.unchanged_count[sensor] += 1 if display_updated: return \\"display updated\\" elif all(count >= self.threshold for count in self.unchanged_count.values()): return \\"display dimmed\\" else: return \\"no change\\""},{"question":"# Problem Statement You are tasked with creating an efficient inventory management system for a bookstore. The bookstore needs to catalog its vast collection of books, and perform operations such as adding new books, searching for books by title, and listing all books in alphabetical order. # Requirements 1. **Book Class**: Implement a `Book` class with attributes for the title (`title`), author (`author`), and ISBN (`isbn`). Ensure the class has appropriate methods for comparison and string representation. 2. **Inventory Management**: Create an `Inventory` class that: - Maintains a collection of `Book` objects. - Can add new books to the inventory. - Can search for books by title. - Can list all books in alphabetical order by title. # Constraints - Use standard Python libraries. - Assume the internal inventory system should allow for a maximum of 10,000 books. # Function Signatures ```python class Book: def __init__(self, title: str, author: str, isbn: str): # Implement this def __str__(self) -> str: # Implement this def __lt__(self, other) -> bool: # Implement this class Inventory: def __init__(self): # Implement this def add_book(self, book: Book): # Implement this def search_book_by_title(self, title: str) -> list[Book]: # Implement this def list_books_alphabetically(self) -> list[Book]: # Implement this ``` # Expected Behavior 1. **Adding Books**: The `add_book` method will add a `Book` object to the inventory. 2. **Searching Books**: The `search_book_by_title` method will search for books in the inventory with titles containing the specified string (case-insensitive). 3. **Listing Alphabetically**: The `list_books_alphabetically` method will return a list of all books in the inventory, ordered alphabetically by title. # Example ```python # Create book objects book1 = Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") book2 = Book(\\"1984\\", \\"George Orwell\\", \\"0123456789\\") book3 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"5432109876\\") # Create inventory object inventory = Inventory() # Add books to the inventory inventory.add_book(book1) inventory.add_book(book2) inventory.add_book(book3) # Search for a book by title search_result = inventory.search_book_by_title(\\"the\\") print([str(book) for book in search_result]) # Expected: [\\"The Great Gatsby\\", ...] # List all books alphabetically all_books = inventory.list_books_alphabetically() print([str(book) for book in all_books]) # Expected: [\\"1984\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] ``` # Note Make sure to test your implementation thoroughly to handle cases such as: - Adding duplicate books (same title and author but different ISBN). - Searching for books with partial matches in their titles. - Sorting edge cases with titles having identical prefixes. This question aims to assess your ability to design and implement an object-oriented solution in Python, handle basic string manipulation, and ensure efficient searching and sorting of data.","solution":"class Book: def __init__(self, title: str, author: str, isbn: str): self.title = title self.author = author self.isbn = isbn def __str__(self) -> str: return f\'{self.title} by {self.author} (ISBN: {self.isbn})\' def __lt__(self, other) -> bool: return self.title < other.title class Inventory: def __init__(self): self.books = [] def add_book(self, book: Book): self.books.append(book) def search_book_by_title(self, title: str) -> list: return [book for book in self.books if title.lower() in book.title.lower()] def list_books_alphabetically(self) -> list: return sorted(self.books)"},{"question":"# Problem: Calculate the Initial Velocity of a Projectile A projectile is launched from the ground at an angle θ with an initial velocity ( V_0 ). The initial vertical and horizontal components of the velocity are determined by the formulas: [ V_{0_y} = V_0 times sin(theta) ] [ V_{0_x} = V_0 times cos(theta) ] Your task is to write a function `initial_velocity` that calculates and returns these initial velocity components given the launch angle and the initial velocity. Ensure that the function properly handles input validation and rounds the results to two decimal places. Function Signature ```python def initial_velocity(velocity: float, angle: float) -> Tuple[float, float]: ``` Input * **velocity**: A positive float representing the initial velocity ( V_0 ) in meters per second. * **angle**: A float representing the launch angle θ in degrees. Output * **returns**: A tuple containing two floats—the vertical and horizontal components of the initial velocity, respectively, rounded to two decimal places. Constraints * The input for `velocity` must be positive. * If `velocity` is non-positive, the function should raise a `ValueError` with an appropriate error message. Examples ```python >>> initial_velocity(30.0, 45) (21.21, 21.21) >>> initial_velocity(20.0, 30) (10.00, 17.32) >>> initial_velocity(25.0, 60) (21.65, 12.50) >>> initial_velocity(50.0, 90) (50.00, 0.00) >>> initial_velocity(30.0, 0) Traceback (most recent call last): ... ValueError: Initial velocity must be positive. >>> initial_velocity(0, 45) Traceback (most recent call last): ... ValueError: Initial velocity must be positive. ```","solution":"import math from typing import Tuple def initial_velocity(velocity: float, angle: float) -> Tuple[float, float]: if velocity <= 0: raise ValueError(\\"Initial velocity must be positive.\\") angle_radians = math.radians(angle) v0_y = round(velocity * math.sin(angle_radians), 2) v0_x = round(velocity * math.cos(angle_radians), 2) return v0_y, v0_x"},{"question":"# Coding Question: Implement a Heap-Based Median Finder Design and implement a data structure that efficiently maintains a collection of integers and allows for finding the median value dynamically. **Instructions**: 1. Implement the `MedianFinder` class that supports the following methods: - `add_num(num: int) -> None`: Adds a number to the data structure. - `find_median() -> float`: Returns the median of all elements added so far. The median is the middle element in an odd-sized list and the average of the two middle elements in an even-sized list. 2. Optimize the implementation using two heaps (a max-heap for the lower half of the numbers and a min-heap for the upper half). 3. Write appropriate test cases to cover a variety of scenarios including: - Adding numbers in ascending, descending, and random order. - Finding the median at different stages of the number additions. - Edge cases with minimal or maximal possible number of elements. ```python import heapq class MedianFinder: def __init__(self): # Initialize two heaps: a max-heap for the lower half and a min-heap for the upper half self.max_heap = [] # max-heap (as a negative min-heap) self.min_heap = [] # min-heap def add_num(self, num: int) -> None: # Your implementation goes here pass def find_median(self) -> float: # Your implementation goes here pass def test_median_finder() -> None: mf = MedianFinder() # Test cases are provided to validate the implementation mf.add_num(1) assert mf.find_median() == 1.0 mf.add_num(2) assert mf.find_median() == 1.5 mf.add_num(3) assert mf.find_median() == 2.0 mf.add_num(4) mf.add_num(5) assert mf.find_median() == 3.0 mf.add_num(6) mf.add_num(7) assert mf.find_median() == 4.0 if __name__ == \\"__main__\\": test_median_finder() ``` **Function Specification**: - **Class Methods**: - `add_num(num: int) -> None`: Adds a number to the internal data structure. - `find_median() -> float`: Returns the median of all added numbers. **Constraints**: - Handle up to `10^5` number additions efficiently. - Maintain O(log n) time complexity for the `add_num` method. - Ensure O(1) time complexity for the `find_median` method after each addition. **Performance Requirements**: - The `add_num` method should efficiently balance the two heaps to ensure quick retrieval of the median. - The `find_median` method should accurately calculate and return the median with minimal overhead. - Handle edge cases including very small or very large numbers, as well as diverse input patterns. Develop your solution iteratively and test thoroughly. Best of luck!","solution":"import heapq class MedianFinder: def __init__(self): # Initialize two heaps: a max-heap for the lower half and a min-heap for the upper half self.max_heap = [] # max-heap (as a negative min-heap) self.min_heap = [] # min-heap def add_num(self, num: int) -> None: # Add to max heap (invert num for max heap behavior in python) heapq.heappush(self.max_heap, -num) # Balance the heaps: ensure every element in min_heap is greater than any element in max_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): value = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) # Balance the sizes of the heaps if len(self.max_heap) > len(self.min_heap) + 1: value = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) elif len(self.min_heap) > len(self.max_heap): value = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -value) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"# String Manipulation and Pattern Matching In this exercise, you\'ll work with string manipulation and pattern matching to decipher and extract information from formatted text logs. You are given a log file from a server where each log entry is a single line following the format: \\"TIMESTAMP - LEVEL - SOURCE - MESSAGE\\" Here, the segments of the log entries are defined as: - **TIMESTAMP**: A date-time string in the ISO 8601 format. - **LEVEL**: The log level, one of `INFO`, `WARN`, `ERROR`, `DEBUG`. - **SOURCE**: The source module name, which is a string without spaces. - **MESSAGE**: The actual log message text. Your task is to implement the following functions: 1. **`parse_log_entry(log_entry: str) -> dict[str, str]`**: This function should parse a single log entry into its components and return a dictionary with keys `timestamp`, `level`, `source`, and `message` mapping to the respective components. 2. **`extract_errors(log_entries: list[str]) -> list[str]`**: This function should filter and return all log entries that have the log level `ERROR`. 3. **`extract_sources(log_entries: list[str]) -> set[str]`**: This function should extract and return a set of all unique source module names from a list of log entries. # Requirements - **Input Format**: - `log_entry`: A single string representing a log entry. - `log_entries`: A list of strings, each representing a log entry. - **Output Format**: - For `parse_log_entry`: A dictionary with keys `timestamp`, `level`, `source`, `message`. - For `extract_errors`: A list of strings representing log entries with log level `ERROR`. - For `extract_sources`: A set of strings representing unique source module names. - **Constraints**: - The log entry strings will always follow the specified format. - The input list of log entries will have at most 10,000 entries. # Example ```python log_entry = \\"2023-10-01T12:00:00Z - ERROR - auth_module - User login failed\\" log_entries = [ \\"2023-10-01T12:00:00Z - ERROR - auth_module - User login failed\\", \\"2023-10-01T12:05:00Z - INFO - web_server - Connection established\\", \\"2023-10-01T12:10:00Z - WARN - db_server - High memory usage detected\\", \\"2023-10-01T12:15:00Z - ERROR - db_server - Database connection lost\\" ] # Expected output for parse_log_entry { \\"timestamp\\": \\"2023-10-01T12:00:00Z\\", \\"level\\": \\"ERROR\\", \\"source\\": \\"auth_module\\", \\"message\\": \\"User login failed\\" } # Expected output for extract_errors [ \\"2023-10-01T12:00:00Z - ERROR - auth_module - User login failed\\", \\"2023-10-01T12:15:00Z - ERROR - db_server - Database connection lost\\" ] # Expected output for extract_sources {\\"auth_module\\", \\"web_server\\", \\"db_server\\"} ``` Implement these functions to correctly parse and analyze the log file entries. Ensure efficiency for the given constraints.","solution":"def parse_log_entry(log_entry: str) -> dict[str, str]: Parse a single log entry into its components. Args: log_entry (str): A log entry string in the format \\"TIMESTAMP - LEVEL - SOURCE - MESSAGE\\". Returns: dict: A dictionary with keys \'timestamp\', \'level\', \'source\', and \'message\' mapping to respective components. parts = log_entry.split(\\" - \\") return { \\"timestamp\\": parts[0], \\"level\\": parts[1], \\"source\\": parts[2], \\"message\\": parts[3] } def extract_errors(log_entries: list[str]) -> list[str]: Filter and return all log entries that have the log level \'ERROR\'. Args: log_entries (list): A list of log entry strings. Returns: list: A list of log entry strings that have the log level \'ERROR\'. return [entry for entry in log_entries if \\" - ERROR - \\" in entry] def extract_sources(log_entries: list[str]) -> set[str]: Extract and return a set of all unique source module names from a list of log entries. Args: log_entries (list): A list of log entry strings. Returns: set: A set of unique source module names. return {entry.split(\\" - \\")[2] for entry in log_entries}"},{"question":"# Generate Prime Numbers in a Range You are tasked with writing a function to generate all prime numbers within a specified range. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your function needs to be efficient and handle possible edge cases correctly. # Function Signature ```python def generate_primes(start: int, end: int) -> List[int]: pass ``` # Input * `start` (int): A non-negative integer representing the beginning of the range (inclusive). * `end` (int): A non-negative integer representing the end of the range (inclusive). # Output * `result` (List[int]): A list of all prime numbers within the given range, sorted in ascending order. # Constraints 1. The `start` will be less than or equal to `end`. 2. Both `start` and `end` will be non-negative integers. 3. The range [start, end] can be large; ensure the function is optimized for performance. # Example ```python print(generate_primes(10, 50)) # Output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] print(generate_primes(0, 10)) # Output: [2, 3, 5, 7] ``` # Additional Info 1. **Prime Number**: A prime number is a number that is only divisible by 1 and itself. 2. You may use helper functions if necessary but ensure they are included within the same code block. 3. Consider using the Sieve of Eratosthenes or any other efficient algorithm to handle large ranges. Implement the function `generate_primes` to achieve this functionality, leveraging an efficient algorithm to ensure optimal performance for large input ranges.","solution":"from typing import List def generate_primes(start: int, end: int) -> List[int]: Generates all prime numbers within a specified range [start, end]. Parameters: start (int): The beginning of the range (inclusive). end (int): The end of the range (inclusive). Returns: List[int]: A list of all prime numbers within the given range. def sieve_of_eratosthenes(n: int) -> List[int]: Helper function to compute prime numbers up to n using Sieve of Eratosthenes. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p] == True: prime_numbers.append(p) return prime_numbers if start > end: return [] if end < 2: return [] primes_up_to_end = sieve_of_eratosthenes(end) primes_in_range = [num for num in primes_up_to_end if num >= start] return primes_in_range"},{"question":"# Question: Calculate the Total Resistance in a Series Circuit Design a function `total_series_resistance` that calculates the total resistance of resistors connected in series. The formula for calculating the total resistance in a series circuit is the sum of individual resistances: [ R_{total} = R_1 + R_2 + ldots + R_n ] where: - ( R_{total} ) is the total resistance. - ( R_i ) is the resistance of the ( i )-th resistor in Ohms ((Omega)). # Function Signature ```python def total_series_resistance(resistances: list) -> float: ``` # Input Parameters - `resistances` (list of float): A list containing the resistance values (in Ohms) of all resistors in the series. All values must be non-negative. # Output - Returns a float representing the total resistance of the series circuit in Ohms. # Constraints - Each resistance value in `resistances` should be a non-negative float or integer. - The length of `resistances` should be at least 1. # Example ```python >>> total_series_resistance([3.0, 4.5, 6.2]) 13.7 >>> total_series_resistance([10.0]) 10.0 >>> total_series_resistance([1.1, 2.2, 3.3, 4.4]) 11.0 ``` # Notes - If the `resistances` list contains non-numeric elements or negative values, the function should raise a `ValueError`. - Provide adequate test cases to validate your implementation.","solution":"def total_series_resistance(resistances: list) -> float: Calculates the total resistance of resistors connected in series. Parameters: resistances (list of float): List of resistances in Ohms Returns: float: Total resistance in Ohms for resistance in resistances: if not isinstance(resistance, (int, float)) or resistance < 0: raise ValueError(\\"All resistances should be non-negative numbers\\") return sum(resistances)"},{"question":"# Coding Assessment Question **Problem Statement**: You are tasked with designing a function that performs matrix multiplication on two given matrices `A` and `B`. Matrix `A` has dimensions `n x m` and matrix `B` has dimensions `m x p`. Your goal is to implement the function to calculate the resulting matrix `C` which will have dimensions `n x p`. **Function Signature**: ```python def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: ``` **Input**: - `A`: A list of lists of integers representing matrix `A` of dimensions `n x m` where `1 <= n, m <= 100`. - `B`: A list of lists of integers representing matrix `B` of dimensions `m x p` where `1 <= m, p <= 100`. **Output**: - Returns a list of lists of integers representing the resulting matrix `C` of dimensions `n x p` after performing the multiplication of matrix `A` and matrix `B`. **Example**: ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] Output: [[58, 64], [139, 154]] ``` **Constraints**: - Both `A` and `B` will have non-zero dimensions and their dimensions will be compatible for multiplication (`m` in `A` and `B` are the same). **Hints**: 1. Ensure you correctly retrieve and sum the products of the corresponding row elements of matrix `A` and the column elements of matrix `B`. 2. Use nested loops to iterate over rows of `A` and columns of `B` for calculation. 3. The resulting element at position `[i][j]` in matrix `C` is obtained by multiplying the `i`-th row of `A` with the `j`-th column of `B` and summing up the results. **Performance Requirements**: - The solution should have a time complexity of O(n * m * p). - The space complexity should be no more than O(n * p). Write the function `matrix_multiplication` that accurately implements the above requirements, considering all edge cases and constraints.","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Get the dimensions of A and B n = len(A) m = len(A[0]) p = len(B[0]) # Initialize the result matrix C with zeros C = [[0] * p for _ in range(n)] # Perform the multiplication for i in range(n): for j in range(p): sum = 0 for k in range(m): sum += A[i][k] * B[k][j] C[i][j] = sum return C"},{"question":"# Problem Statement Implement a function that evaluates a postfix (Reverse Polish Notation) expression. Postfix expressions are a different way of writing mathematical expressions where the operator follows the operands. For example, \\"3 4 +\\" is equivalent to \\"3 + 4\\" in infix notation. # Instructions 1. Write a function `evaluate_postfix_expression` that takes a string representing a postfix expression. 2. Parse the string and evaluate the postfix expression. 3. The function should return the result as a float. 4. Operators supported: `+`, `-`, `*`, `/`. 5. Assume that the input string is always valid. # Function Signature ```python def evaluate_postfix_expression(expression: str) -> float: pass ``` # Input * `expression`: A string representing a postfix expression with space-separated tokens. # Output * The result of evaluating the expression (float). # Example ```python >>> evaluate_postfix_expression(\\"3 4 +\\") 7.0 >>> evaluate_postfix_expression(\\"2 3 1 * + 9 -\\") -4.0 >>> evaluate_postfix_expression(\\"5 1 2 + 4 * + 3 -\\") 14.0 ``` # Constraints * The input string will not contain invalid characters. * The input string will have valid spacing (one space between each token, no leading or trailing spaces).","solution":"def evaluate_postfix_expression(expression: str) -> float: Evaluates a postfix expression and returns the result as a float. :param expression: A postfix expression string :return: The result of the expression (float) stack = [] operators = {\'+\', \'-\', \'*\', \'/\'} for token in expression.split(): if token not in operators: stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = a / b stack.append(result) return stack[0]"},{"question":"# Task: Validate ISBN-10 Number **Objective**: Implement a function that verifies if a given string is a valid ISBN-10 number. **Function Signature**: `def is_valid_isbn10(isbn: str) -> bool:` # Input: - `isbn` (str): A string representing the ISBN-10 number, which may include hyphens. # Output: - Returns `True` if the input string is a valid ISBN-10 number, otherwise returns `False`. # Constraints: - The ISBN-10 number is a 10-digit code. - The first 9 characters could be numeric digits or hyphens. - The 10th character could be a numeric digit or \'X\' which represents the value 10. - Any hyphens in the input string should be ignored for validation purposes. - The function should handle strings with varying lengths and invalid characters gracefully. # Examples: 1. `is_valid_isbn10(\\"0-306-40615-2\\")` should return `True`. 2. `is_valid_isbn10(\\"0306406152\\")` should return `True`. 3. `is_valid_isbn10(\\"123456789X\\")` should return `True`. 4. `is_valid_isbn10(\\"0306406153\\")` should return `False`. 5. `is_valid_isbn10(\\"0-306-40615A\\")` should return `False`. # Notes: - The ISBN-10 validation process includes: 1. Removing any hyphens. 2. Ensuring the remaining length of the string is exactly 10 characters. 3. Calculating the checksum using the formula: [ S = 1 times d_1 + 2 times d_2 + ... + 10 times d_{10} ] where ( d_{10} ) is 10 if the last character is \'X\'. 4. The checksum should be divisible by 11 to be valid. # Hints: - Use string manipulation techniques to strip out hyphens. - Verify each character according to its position and ISBN rules. - Python\'s `str.isdigit()` method or equivalent could be useful for validation.","solution":"def is_valid_isbn10(isbn: str) -> bool: Verifies if a given string is a valid ISBN-10 number. :param isbn: A string representing the ISBN-10 number. :return: True if the input string is a valid ISBN-10 number, otherwise False. # Remove hyphens isbn = isbn.replace(\'-\', \'\') # ISBN-10 must be exactly 10 characters long if len(isbn) != 10: return False # Checksum calculation checksum = 0 for i in range(10): if isbn[i] == \'X\' and i == 9: checksum += 10 * (i + 1) elif isbn[i].isdigit(): checksum += int(isbn[i]) * (i + 1) else: return False return checksum % 11 == 0"},{"question":"# Dijkstra\'s Shortest Path Algorithm You are given the task of implementing Dijkstra\'s algorithm to find the shortest paths from a given source node to all other nodes in a weighted graph with non-negative edge weights. # Function Signature ```python def dijkstra(graph: List[List[Tuple[int, int]]], start_node: int) -> List[float]: pass ``` # Input * `graph`: A list of lists where each sublist represents the adjacency list of the corresponding node. Each element in the sublist is a tuple of the form `(neighbor, weight)`, where `neighbor` is the adjacent node and `weight` is the edge weight between the nodes. * `start_node`: An integer representing the starting node from which shortest paths are calculated. # Output * A list of floats where the value at index `i` represents the shortest distance from the `start_node` to node `i`. If a node is not reachable from `start_node`, the distance should be represented as float(\'inf\'). # Constraints * The graph contains no negative weight edges. * The number of nodes in the graph will be between 1 and 1000. * The start_node will always be a valid node within the graph. # Example ```python graph = [ [(1, 4), (2, 1)], # neighbors of node 0 are nodes 1 and 2 with edge weights 4 and 1 [(3, 1)], # neighbors of node 1 [(1, 2), (3, 5)], # neighbors of node 2 [] # node 3 has no neighbors ] start_node = 0 ``` When calling the function: ```python result = dijkstra(graph, start_node) ``` The `result` should be: ``` [0, 3, 1, 4] ``` indicating that the shortest path from node 0 to nodes [0, 1, 2, 3] are [0, 3, 1, 4] respectively. # Constraints & Edge Cases * Handling cases where some nodes are unreachable from the start_node. * Graphs with multiple paths to the same nodes should choose the smallest weight. # Performance * Your solution should efficiently handle large graphs up to the specified limit. * Consider using a min-heap or priority queue to optimize the search process. Write your implementation of the Dijkstra function:","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start_node: int) -> List[float]: Implements Dijkstra\'s algorithm to find the shortest paths from start_node to all other nodes in a graph. # Number of nodes in the graph n = len(graph) # Distance array, initialized to infinity for all nodes except the start_node distances = [float(\'inf\')] * n distances[start_node] = 0 # Priority Queue (Min-Heap) min_heap = [(0, start_node)] while min_heap: current_distance, current_node = heapq.heappop(min_heap) # If we find a larger distance in the heap than the current known distance, skip processing if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"# Problem Statement Create a function that sorts a list of tuples based on multiple criteria. The primary criterion is the first element of each tuple (sorted in ascending order), and the secondary criterion is the second element of each tuple (sorted in descending order). Ensure the function is efficient and leverages Python\'s sorting capabilities. # Function Signature ```python def custom_sort(data): Sorts a list of tuples (x, y) by first element x in ascending order and by second element y in descending order. Parameters: data -- list of tuples, where each tuple consists of two elements (x, y). Output: A list of tuples sorted based on the described criteria. pass ``` # Example Usage ```python >>> data = [(4, 1), (2, 9), (4, 6), (2, 2)] >>> custom_sort(data) [(2, 9), (2, 2), (4, 6), (4, 1)] ``` # Requirements 1. **Input Constraints**: - The input list contains tuples with exactly two elements, where each element is an integer (positive or negative). 2. **Output**: - The function returns a list of tuples, sorted as specified. 3. **Performance Consideration**: - The function should be able to handle large lists efficiently. - Utilize Python’s built-in sorting features to ensure minimal overhead. # Background Context Sorting is a fundamental operation in many algorithms and applications, from organizing data to improving search efficiencies. Complex sorting criteria are often required in practical scenarios, where multiple attributes of each item dictate the order. This task mimics real-world sorting challenges often encountered in data handling and manipulation.","solution":"def custom_sort(data): Sorts a list of tuples (x, y) by first element x in ascending order and by second element y in descending order. Parameters: data -- list of tuples, where each tuple consists of two elements (x, y). Output: A list of tuples sorted based on the described criteria. return sorted(data, key=lambda x: (x[0], -x[1]))"},{"question":"# Sorting Custom Objects You are provided with a class `Student` which contains details about students like name, age, and grade. Your task is to implement sorting functionality for a list of `Student` objects based on different criteria (e.g., by name, age, and grade). # Problem Statement Imagine you are working with a system that maintains a list of students and you need to sort the students based on certain attributes. Implement the required functionality to sort students based on name, age, and grade. # Task 1. **Class Definition**: - You are provided with a `Student` class. This class has three attributes: `name`, `age`, and `grade`. 2. **Function Implementation**: Implement three functions `sort_by_name`, `sort_by_age`, and `sort_by_grade` which will sort a list of `Student` objects by their respective attributes. - Each function should: - **Input**: A list of `Student` objects. - **Output**: The input list sorted in-place by the specified attribute. 3. Implement the comparison functions using the built-in sorting methods and lambda functions to achieve the desired order. ```python class Student: def __init__(self, name: str, age: int, grade: float): self.name = name self.age = age self.grade = grade def sort_by_name(students: List[Student]) -> None: Sort the students list in-place by name (ascending alphabetic order). students.sort(key=lambda student: student.name) def sort_by_age(students: List[Student]) -> None: Sort the students list in-place by age (ascending numeric order). students.sort(key=lambda student: student.age) def sort_by_grade(students: List[Student]) -> None: Sort the students list in-place by grade (descending numeric order). students.sort(key=lambda student: student.grade, reverse=True) ``` # Example ```python students = [ Student(\\"Alice\\", 20, 85.5), Student(\\"Bob\\", 22, 91.0), Student(\\"Charlie\\", 20, 79.0) ] sort_by_name(students) print([(student.name, student.age, student.grade) for student in students]) # Output: [(\'Alice\', 20, 85.5), (\'Bob\', 22, 91.0), (\'Charlie\', 20, 79.0)] sort_by_age(students) print([(student.name, student.age, student.grade) for student in students]) # Output: [(\'Alice\', 20, 85.5), (\'Charlie\', 20, 79.0), (\'Bob\', 22, 91.0)] sort_by_grade(students) print([(student.name, student.age, student.grade) for student in students]) # Output: [(\'Bob\', 22, 91.0), (\'Alice\', 20, 85.5), (\'Charlie\', 20, 79.0)] ``` # Constraints - The `name` attribute will be a string of alphanumeric characters. - The `age` attribute will be a positive integer. - The `grade` attribute will be a floating-point number between 0.0 and 100.0. - The number of `Student` objects will not exceed 10,000. Ensure the implementation handles the input size within acceptable limits and achieves sorting efficiently using appropriate algorithms.","solution":"from typing import List class Student: def __init__(self, name: str, age: int, grade: float): self.name = name self.age = age self.grade = grade def sort_by_name(students: List[Student]) -> None: Sort the students list in-place by name (ascending alphabetic order). students.sort(key=lambda student: student.name) def sort_by_age(students: List[Student]) -> None: Sort the students list in-place by age (ascending numeric order). students.sort(key=lambda student: student.age) def sort_by_grade(students: List[Student]) -> None: Sort the students list in-place by grade (descending numeric order). students.sort(key=lambda student: student.grade, reverse=True)"},{"question":"# Problem Statement In this exercise, you will create a function that manages and updates a list of tasks in a simple to-do application. Users can add new tasks, mark tasks as completed, delete tasks, and view all tasks. Your task is to ensure these operations are efficiently handled, keeping the data integrity intact. Implement the following function: ```python def manage_tasks(commands: List[Dict[str, Any]]) -> List[str]: Processes a series of commands to manage a to-do list and returns the final state of the task list. The commands list is composed of dictionaries, where each dictionary represents a command. Possible commands are: - \\"add\\": Adds a new task to the list. - \\"complete\\": Marks a task as completed. - \\"delete\\": Deletes a task from the list. - \\"view\\": View all tasks in the list. Each command dictionary has the following structure: - \\"command\\": A string indicating the command type (\\"add\\", \\"complete\\", \\"delete\\", \\"view\\"). - \\"task\\": A string describing the task for \\"add\\", \\"complete\\", and \\"delete\\" commands. The \\"task\\" field is not required for the \\"view\\" command. The function should return a list of strings representing the final state of the task list. Each task should be prefixed with \\"[ ]\\" if incomplete and \\"[x]\\" if completed. Example usage: commands = [ {\\"command\\": \\"add\\", \\"task\\": \\"Buy groceries\\"}, {\\"command\\": \\"add\\", \\"task\\": \\"Pay bills\\"}, {\\"command\\": \\"complete\\", \\"task\\": \\"Buy groceries\\"}, {\\"command\\": \\"view\\"}, {\\"command\\": \\"delete\\", \\"task\\": \\"Pay bills\\"} ] manage_tasks(commands) -> [\\"[x] Buy groceries\\"] pass ``` # Input/Output Format - **Input**: A list of dictionaries where each dictionary represents a command to manage the to-do list. Each dictionary can contain: - `\\"command\\"`: A string indicating the command type (`\\"add\\"`, `\\"complete\\"`, `\\"delete\\"`, `\\"view\\"`). - `\\"task\\"`: A string describing the task, if applicable. - **Output**: A list of strings representing the final state of tasks in the to-do list, formatted as follows: - Incomplete tasks are prefixed with `[ ]` - Completed tasks are prefixed with `[x]` # Constraints - Ensure that the function handles cases where tasks to be completed or deleted do not exist in the list. - Manage the tasks efficiently to support rapid updates and queries. - The \\"view\\" command should not alter the state of the task list. # Performance Requirements - Efficiently update and query the task list, maintaining a balance between ease of reading the current state and updating it. - The solution should handle a reasonable number of tasks, typically expected in a to-do application.","solution":"def manage_tasks(commands): Processes a series of commands to manage a to-do list and returns the final state of the task list. tasks = [] for command in commands: if command[\\"command\\"] == \\"add\\": tasks.append({\\"task\\": command[\\"task\\"], \\"completed\\": False}) elif command[\\"command\\"] == \\"complete\\": for task in tasks: if task[\\"task\\"] == command[\\"task\\"]: task[\\"completed\\"] = True break elif command[\\"command\\"] == \\"delete\\": tasks = [task for task in tasks if task[\\"task\\"] != command[\\"task\\"]] elif command[\\"command\\"] == \\"view\\": view_tasks = [] # Not necessary to modify tasks, just to follow the structure result = [] for task in tasks: status = \\"[x]\\" if task[\\"completed\\"] else \\"[ ]\\" result.append(f\\"{status} {task[\'task\']}\\") return result"},{"question":"# Prime Number Analyzer: Efficient Identification of Primes In this task, you are required to develop a function that efficiently determines whether a given number is a prime or not and also returns a list of primes up to a given number. Scenario: You are developing an analytical tool for a mathematics research application that requires the identification of prime numbers for various computations. To optimize this process, you need efficient algorithms to check for primes and generate lists of primes. Objective: Implement a function `is_prime` that checks if a number is prime and a function `generate_primes_up_to` that generates all prime numbers up to a given number. # Specifications: 1. Functions: * `is_prime` - This function takes an integer and returns a boolean indicating whether the number is prime. * `generate_primes_up_to` - This function takes an integer `n` and returns a list of all prime numbers less than or equal to `n`. 2. Input/Output Formats: * **Input**: * For `is_prime`: * `number`: an integer to check for primality. * For `generate_primes_up_to`: * `n`: an integer up to which primes need to be generated. * **Output**: * For `is_prime`: A boolean value (`True` if the number is prime, `False` otherwise). * For `generate_primes_up_to`: A list of prime numbers that are less than or equal to `n`. Function Signatures: ```python def is_prime(number: int) -> bool: pass def generate_primes_up_to(n: int) -> list: pass ``` Example Usage: ```python assert is_prime(2) == True assert is_prime(4) == False assert is_prime(17) == True assert generate_primes_up_to(10) == [2, 3, 5, 7] assert generate_primes_up_to(20) == [2, 3, 5, 7, 11, 13, 17, 19] ``` Constraints: * The functions should handle a wide range of integers efficiently. * The prime-checking function (`is_prime`) should be optimized for speed. * The prime generation function (`generate_primes_up_to`) should use an efficient algorithm such as the Sieve of Eratosthenes for better performance with larger values of `n`. This question measures your ability to implement efficient algorithms for prime number identification and generation, a fundamental topic in computer science and mathematics.","solution":"def is_prime(number: int) -> bool: Check if a given number is prime. :param number: Integer to check for primality. :return: True if the number is prime, otherwise False. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True def generate_primes_up_to(n: int) -> list: Generate a list of all prime numbers up to and including n. :param n: Integer up to which primes need to be generated. :return: List of prime numbers less than or equal to n. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i*i, n + 1, i): is_prime[j] = False return [i for i in range(2, n + 1) if is_prime[i]]"},{"question":"# Write a File Merger Script You are tasked with creating a file merger script that can combine the contents of multiple text files into a single output file. The merged file should maintain the order of the input files and ensure there are no duplicate lines in the final file. Requirements: 1. **Function Definition**: ```python def merge_files(file_paths: list, output_file: str) -> None: ``` 2. **Input**: * `file_paths` (list): List of strings, where each string is a valid file path to a text file that needs to be merged. * `output_file` (str): String representing the path to the output file where the merged contents should be saved. 3. **Output**: * The function should not return anything. It should create or overwrite `output_file` with the merged contents. 4. **Constraints**: * Ignore empty input files. * Avoid duplicate lines in the output file. * Maintain input file order in the merged file. * Gracefully handle errors, such as file not found, and continue processing remaining files. * Ensure the output file is created in a thread-safe manner. 5. **Performance Requirements**: * The function should handle up to 100 input files efficiently. * Optimize I/O operations to ensure minimal performance overhead. Example: ```python file_paths = [ \\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\" ] output_file = \\"merged_output.txt\\" merge_files(file_paths, output_file) # Given file1.txt contains: # ``` # Line 1 # Line 2 # Line 3 # ``` # # Given file2.txt contains: # ``` # Line 3 # Line 4 # ``` # # Given file3.txt contains: # ``` # Line 5 # Line 1 # ``` # The merged_output.txt might look like: # ``` # Line 1 # Line 2 # Line 3 # Line 4 # Line 5 # ``` ``` Implementation Tips: * Utilize a set to track unique lines. * Use a context manager (`with` statement) for file operations to ensure proper resource management. * Implement robust error handling for file operations. * Consider performance implications of reading and writing files if they are large.","solution":"def merge_files(file_paths: list, output_file: str) -> None: seen_lines = set() with open(output_file, \'w\') as output: for file_path in file_paths: try: with open(file_path, \'r\') as file: for line in file: if line not in seen_lines: seen_lines.add(line) output.write(line) except FileNotFoundError: print(f\\"File not found: {file_path}\\")"},{"question":"# Unique Element Finder Write a function that takes a list of integers and returns a new list that contains only the elements that appear exactly once in the input list, maintaining their original order. This means that if an element appears more than once in the input list, it should not be included in the output list. Function Signature ```python def find_unique_elements(lst: List[int]) -> List[int]: Finds elements that appear exactly once in the input list. Args: lst (List[int]): The input list of integers. Returns: List[int]: A list of integers where each element appears exactly once in the original input list. Raises: ValueError: If the input is not a list. pass ``` # Example ```python assert find_unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] assert find_unique_elements([4, 5, 4, 5, 6, 7, 8, 8]) == [6, 7] assert find_unique_elements([1]) == [1] assert find_unique_elements([]) == [] try: find_unique_elements(5) except ValueError as ve: assert str(ve) == \\"Input must be a list\\" except Exception as e: assert False, f\\"Unexpected exception {e}\\" ``` # Constraints 1. The input list may contain any integer values. 2. If the input is not a list, raise a `ValueError` with the message \\"Input must be a list\\". 3. The solution should maintain the order of elements as they appeared in the input list. # Performance Requirements The solution should aim to execute within a reasonable time frame for input lists with up to 10,000 elements.","solution":"from typing import List def find_unique_elements(lst: List[int]) -> List[int]: Finds elements that appear exactly once in the input list. Args: lst (List[int]): The input list of integers. Returns: List[int]: A list of integers where each element appears exactly once in the original input list. Raises: ValueError: If the input is not a list. if not isinstance(lst, list): raise ValueError(\\"Input must be a list\\") element_count = {} for num in lst: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 unique_elements = [num for num in lst if element_count[num] == 1] return unique_elements"},{"question":"# Scenario You are working on an inventory management system for a library. One important feature is to keep track of borrowed books and update the status when books are returned. For this task, you decide to use a binary search tree (BST) to manage the inventory efficiently. # Task Implement a `LibraryInventory` class that supports adding new books, borrowing books, and returning books using a binary search tree. # Detailed Requirements 1. **Class**: `LibraryInventory` 2. **Constructor**: `__init__(self)` - Initializes an empty inventory. 3. **Method**: `add_book(self, book_id: int) -> None` - Input: An integer `book_id` representing the unique identifier for the new book. - Adds the book to the inventory. 4. **Method**: `borrow_book(self, book_id: int) -> bool` - Input: An integer `book_id` to borrow. - Output: Returns `True` if the book was successfully borrowed (i.e., the book exists and is available in the inventory), `False` otherwise. - Marks the book as borrowed. 5. **Method**: `return_book(self, book_id: int) -> bool` - Input: An integer `book_id` to return. - Output: Returns `True` if the book was successfully returned (i.e., the book was borrowed and is now available), `False` otherwise. - Marks the book as available. 6. **Method**: `is_available(self, book_id: int) -> bool` - Input: An integer `book_id` to check. - Output: Returns `True` if the book is available in the inventory, `False` otherwise. # Constraints 1. The `book_id` will be a non-negative integer. 2. Operations should aim for efficient performance with average-case log(n) time complexity for search, add, borrow, and return operations. # Example Usage ```python # Initialize the inventory library_inventory = LibraryInventory() # Add books to the inventory library_inventory.add_book(1001) library_inventory.add_book(1002) # Borrow a book - should return True assert library_inventory.borrow_book(1001) == True # Check availability - should return False (book is borrowed) assert library_inventory.is_available(1001) == False # Return the book - should return True assert library_inventory.return_book(1001) == True # Check availability again - should return True (book is available) assert library_inventory.is_available(1001) == True # Borrow a non-existent book - should return False assert library_inventory.borrow_book(2001) == False # Return a non-borrowed book - should return False assert library_inventory.return_book(1002) == False ``` Provide a class implementation adhering to the above requirements. Ensure thorough error checking and include sufficient unittests to validate the correctness of your implementation.","solution":"class TreeNode: def __init__(self, book_id): self.book_id = book_id self.is_borrowed = False self.left = None self.right = None class LibraryInventory: def __init__(self): self.root = None def _add_book_recursive(self, node, book_id): if not node: return TreeNode(book_id) if book_id < node.book_id: node.left = self._add_book_recursive(node.left, book_id) elif book_id > node.book_id: node.right = self._add_book_recursive(node.right, book_id) return node def add_book(self, book_id): if self.root is None: self.root = TreeNode(book_id) else: self._add_book_recursive(self.root, book_id) def _find_book(self, node, book_id): if not node: return None if book_id == node.book_id: return node elif book_id < node.book_id: return self._find_book(node.left, book_id) else: return self._find_book(node.right, book_id) def borrow_book(self, book_id): book_node = self._find_book(self.root, book_id) if book_node and not book_node.is_borrowed: book_node.is_borrowed = True return True return False def return_book(self, book_id): book_node = self._find_book(self.root, book_id) if book_node and book_node.is_borrowed: book_node.is_borrowed = False return True return False def is_available(self, book_id): book_node = self._find_book(self.root, book_id) return book_node is not None and not book_node.is_borrowed"},{"question":"# Problem Statement In the world of space exploration, calculation of the total distance covered by rovers on other planets is crucial for research and analysis. You are assigned to create a function that calculates the cumulative distance traversed by a rover based on a series of waypoint coordinates it has visited. # Function Signature ```python def calculate_distance(waypoints: List[Tuple[float, float]]) -> float: Args: waypoints: A list of tuples, where each tuple contains two float values representing the x and y coordinates of each waypoint visited by the rover. Returns: The total distance the rover has traveled. ``` # Input Format * `waypoints` (List[Tuple[float, float]]): A list of tuples, each containing two float values representing x and y coordinates (both must be valid float numbers). # Output Format * A float representing the total distance traveled by the rover. # Constraints * `2 <= len(waypoints) <= 1e5` (the rover must visit at least 2 waypoints to calculate distance and can visit up to 100,000 waypoints) * Coordinates of waypoints are valid float numbers, within the planetary boundary range that can be reasonably defined by `-1e4 <= x, y <= 1e4`. # Examples ```python >>> calculate_distance([(0, 0), (3, 4)]) 5.0 >>> calculate_distance([(1, 1), (4, 5), (9, 9)]) 12.806248474865697 >>> calculate_distance([(0, 0), (0, 0)]) 0.0 >>> calculate_distance([(0, 0)]) Traceback (most recent call last): ... ValueError: The rover must visit at least 2 waypoints ``` # Requirements * Use the Euclidean distance formula to calculate the distance between each consecutive pair of waypoints. * Take care of edge cases such as providing less than two waypoints. * Ensure to validate the input and raise appropriate exceptions for invalid input. # Euclidean Distance Formula between two points ( (x1, y1) ) and ( (x2, y2) ): [ text{distance} = sqrt{(x2 - x1)^2 + (y2 - y1)^2} ]","solution":"import math from typing import List, Tuple def calculate_distance(waypoints: List[Tuple[float, float]]) -> float: Calculates the total distance traveled by a rover given a series of waypoints. Args: waypoints: A list of tuples, where each tuple contains two float values representing the x and y coordinates of each waypoint visited by the rover. Returns: The total distance the rover has traveled. if len(waypoints) < 2: raise ValueError(\\"The rover must visit at least 2 waypoints\\") total_distance = 0.0 for i in range(1, len(waypoints)): x1, y1 = waypoints[i - 1] x2, y2 = waypoints[i] total_distance += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return total_distance"},{"question":"# Prime Factors Calculation **Context**: As a software developer, you need to implement utilities for numerical processing tasks. One common task is to determine the prime factors of an integer, which is useful in various fields such as cryptography, number theory, and computer science. **Task**: Implement a function `prime_factors` that finds and returns the prime factors of a given positive integer. **Function Signature**: ```python def prime_factors(n: int) -> list[int]: pass ``` **Input**: - `n` (int): The positive integer for which you need to determine the prime factors. **Output**: - Returns a list of integers representing the prime factors of `n`. **Constraints**: - `n` is a positive integer (1 ≤ `n` ≤ 10^6). **Example**: ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(45) == [3, 3, 5] assert prime_factors(17) == [17] ``` **Notes**: * Ensure the implementation efficiently handles the prime factorization of `n`, even for the upper limit. * The returned list should include prime factors in ascending order and include duplicates to accurately reflect the factorization (e.g., for `n = 28`, 2 should appear twice). * Consider edge cases such as when `n` is a prime number itself, which should return a list containing only `n`. This question evaluates your understanding of prime factorization, efficiency in handling large numbers, and ability to implement mathematical algorithms effectively.","solution":"def prime_factors(n: int) -> list[int]: Returns the prime factors of the given positive integer. Parameters: n (int): The positive integer to find the prime factors for. Returns: list[int]: A list containing the prime factors of n in ascending order. factors = [] # Check for the number of 2s that divide n while n % 2 == 0: factors.append(2) n //= 2 # n must be odd at this point, so a skip of 2 is made (i.e., 3, 5, 7, 9, ...) for i in range(3, int(n**0.5) + 1, 2): # While i divides n, add i and divide n while n % i == 0: factors.append(i) n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Quadratic Root Finder Problem Statement: You need to implement a function that finds the real roots of a quadratic equation given its coefficients. The quadratic equation is in the form `ax^2 + bx + c = 0`. Function Signature: ```python def find_roots(a: int, b: int, c: int) -> list[float]: pass ``` Input: - `a` (int): The coefficient of `x^2`. - `b` (int): The coefficient of `x`. - `c` (int): The constant term. Output: - A list of roots (float) if they exist. Return roots as a list of floats sorted in ascending order. - If the equation has no real roots, return an empty list. Constraints: - The coefficients `a`, `b`, and `c` must be integers. - If any of the coefficients are not integers, raise a `ValueError` with the message \\"Coefficients must be integers\\". - If `a` is zero, raise a `ValueError` with the message \\"Coefficient \'a\' must not be zero\\". Examples: ```python assert find_roots(1, -3, 2) == [1.0, 2.0] assert find_roots(1, 2, 1) == [-1.0] assert find_roots(1, 0, -4) == [-2.0, 2.0] assert find_roots(1, 0, 4) == [] assert find_roots(0, 1, 2) == ValueError(\\"Coefficient \'a\' must not be zero\\") assert find_roots(1, 1, \\"c\\") == ValueError(\\"Coefficients must be integers\\") ``` Edge Cases: - Equations with one real root, two real roots, or no real roots should all be appropriately handled. - Invalid coefficients should be appropriately managed as per the criteria above. # Instructions: 1. Implement the function `find_roots` following the given signature. 2. Ensure all edge cases are handled appropriately. 3. Perform necessary validations as per the constraints. 4. Maintain the output format as specified.","solution":"import math from typing import List def find_roots(a: int, b: int, c: int) -> List[float]: Returns the real roots of the quadratic equation ax^2 + bx + c = 0. Parameters: a (int): Coefficient of x^2 b (int): Coefficient of x c (int): Constant term Returns: List[float]: A list of real roots sorted in ascending order. If no real roots, return an empty list. # Validate input types if not all(isinstance(coef, int) for coef in [a, b, c]): raise ValueError(\\"Coefficients must be integers\\") # Check that a is not zero if a == 0: raise ValueError(\\"Coefficient \'a\' must not be zero\\") # Calculate the discriminant discriminant = b ** 2 - 4 * a * c # Determine the number of real roots based on the discriminant if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2 * a) root2 = (-b - math.sqrt(discriminant)) / (2 * a) return sorted([root1, root2]) elif discriminant == 0: root = -b / (2 * a) return [root] else: return []"},{"question":"# Binary Tree Vertical Order Traversal Given a binary tree, implement the following functionalities: 1. Insert nodes into the binary tree. 2. Perform a vertical order traversal of the tree. # Function Specifications Your task is to implement a class `BinaryTree` which contains the following methods: - `__init__(self)`: Initializes the binary tree with a root node set to None. - `insert(self, parent_val: int, child_val: int, direction: str)`: Inserts a node with value `child_val` either to the `\'left\'` or `\'right\'` of the node with value `parent_val`. The `direction` will either be `\'left\'` or `\'right\'`. - `vertical_order_traversal(self) -> List[List[int]]`: Returns a list of lists, where each sublist represents a vertical order traversal of the tree from left to right. # Constraints * Values of the nodes are unique and between 1 and 1000. * The number of nodes in the tree will be between 1 and 1000. # Example ```python # Creating a binary tree bt = BinaryTree() # Inserting nodes bt.insert(1, 2, \'left\') bt.insert(1, 3, \'right\') bt.insert(2, 4, \'left\') bt.insert(2, 5, \'right\') bt.insert(3, 6, \'left\') bt.insert(3, 7, \'right\') # Performing vertical order traversal assert bt.vertical_order_traversal() == [[4], [2], [1, 5, 6], [3], [7]] ``` # Notes - The `insert` function assumes the root node with `parent_val` always exists before inserting the child nodes. - The vertical order traversal means considering columns of nodes, where the column of the root is considered as 0, the left child’s column is -1, the right child\'s column is +1, and so on recursively.","solution":"from collections import defaultdict, deque from typing import List, Tuple, Dict class Node: def __init__(self, val: int): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, parent_val: int, child_val: int, direction: str): if self.root is None: # Create the root node if it doesn\'t exist self.root = Node(parent_val) if direction == \'left\': self.root.left = Node(child_val) else: self.root.right = Node(child_val) return # Find the parent node using BFS queue = deque([self.root]) while queue: node = queue.popleft() if node.val == parent_val: if direction == \'left\': node.left = Node(child_val) else: node.right = Node(child_val) return if node.left: queue.append(node.left) if node.right: queue.append(node.right) def vertical_order_traversal(self) -> List[List[int]]: if not self.root: return [] # Dictionary to store the nodes against their horizontal distances col_table: Dict[int, List[int]] = defaultdict(list) min_col = max_col = 0 # BFS with storing horizontal distance from root queue = deque([(self.root, 0)]) while queue: node, col = queue.popleft() col_table[col].append(node.val) min_col = min(min_col, col) max_col = max(max_col, col) if node.left: queue.append((node.left, col - 1)) if node.right: queue.append((node.right, col + 1)) return [col_table[x] for x in range(min_col, max_col + 1)]"},{"question":"# Coding Assessment Question Context Imagine you are developing a feature for a calendar application that helps users find free time slots for a group of people. Each person has their own set of busy times, and you need to find the common free time slots where they can schedule a meeting. Task Implement a function `find_common_free_slots(schedules: list, start: int, end: int) -> list` that takes: - `schedules`: a list of lists where each sublist represents the busy intervals (as 2-item lists) for a person, sorted by start time. - `start`: an integer representing the start of the day in minutes from midnight (0 <= start < end). - `end`: an integer representing the end of the day in minutes from midnight (start < end <= 1440). Your function should return a list of 2-item lists representing the common free time slots available to all persons within the provided day range. Implementation * Your function should: - Ensure `schedules` is a non-empty list of lists. Each sublist contains busy time intervals for a person. - Ensure `start` and `end` are valid integers within a single day (0 to 1440). - Compare each person\'s busy intervals to find common free slots. - Return the free time slots where all persons are available. Constraints - The size of schedules can go up to `10^3`. - The total number of intervals across all schedules can go up to `10^4`. - Each interval is `[start_time, end_time]` where 0 <= start_time < end_time <= 1440. Input/Output Format - Input: A list of lists (`schedules`), and two integers (`start`, `end`). - Output: A list of lists representing the common free time slots. Example ```python def find_common_free_slots(schedules: list, start: int, end: int) -> list: # Your implementation here # Example usage: print(find_common_free_slots([[[540, 600], [660, 720]], [[555, 615], [700, 750]]], 480, 780)) # Output: [[480, 540], [750, 780]] print(find_common_free_slots([[[230, 240], [300, 330]], [[200, 240], [310, 340]]], 200, 400)) # Output: [[240, 300], [340, 400]] ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"def find_common_free_slots(schedules, start, end): Finds common free time slots for a group of people based on their busy schedules. :param schedules: List of lists where each sublist represents the busy intervals for a person. :param start: Integer representing the start of the day in minutes from midnight. :param end: Integer representing the end of the day in minutes from midnight. :return: List of common free time slots. if not schedules: return [[start, end]] # Merge all busy times into a single list and sort it all_busy_times = [interval for person in schedules for interval in person] all_busy_times.sort(key=lambda x: x[0]) merged_busy_times = [] for interval in all_busy_times: if not merged_busy_times or merged_busy_times[-1][1] < interval[0]: merged_busy_times.append(interval) else: merged_busy_times[-1][1] = max(merged_busy_times[-1][1], interval[1]) free_times = [] current_start = start for busy_start, busy_end in merged_busy_times: if current_start < busy_start: free_times.append([current_start, busy_start]) current_start = max(current_start, busy_end) if current_start < end: free_times.append([current_start, end]) return free_times"},{"question":"Problem Statement Write a function `highest_peak` that, given an array of elevation readings representing a landscape, determines the height of the highest peak in the landscape. The landscape is defined such that an elevation is only considered a peak if it is higher than its neighboring readings on both sides. # Function Signature ```python def highest_peak(elevations: list[int]) -> int: pass ``` # Input * **elevations**: A list of integers representing the elevation readings. * The list will have a length between 1 and 10^6. * The elevation values can be any integer within the range of -10^6 to 10^6. # Output * Return the height of the highest peak found. * If there are no peaks, return -1. # Constraints * 1 <= len(elevations) <= 10^6 * -10^6 <= elevations[i] <= 10^6 # Example Usage ```python elevations = [0, 2, 4, 2, 3, 5, 1, 0] print(highest_peak(elevations)) # Expected output: 5 (peak at index 5) elevations = [1, 3, 3, 2, 1, 4, 4] print(highest_peak(elevations)) # Expected output: -1 (no peaks) elevations = [5] print(highest_peak(elevations)) # Expected output: -1 (no peaks) ``` # Additional Information Testing for edge cases like: * List with only one element * List with all elements the same * High volatility in elevation readings Your solution should efficiently handle large datasets and return the correct results for varying types of landscapes.","solution":"def highest_peak(elevations: list[int]) -> int: Returns the height of the highest peak in the given list of elevation readings. If there are no peaks, return -1. if len(elevations) < 3: return -1 highest = -1 # Initialize the highest peak variable with -1 for i in range(1, len(elevations) - 1): if elevations[i] > elevations[i - 1] and elevations[i] > elevations[i + 1]: highest = max(highest, elevations[i]) return highest"},{"question":"# Problem Statement You need to implement a function that finds the kth smallest element in a given unsorted array. Your algorithm should run in O(n) average time complexity. # Function Signature ```python def kth_smallest(arr: List[int], k: int) -> int: ``` # Input * **arr**: A list of integers (1 ≤ len(arr) ≤ 10^5), where each element of the list is an integer (-10^9 ≤ arr[i] ≤ 10^9). * **k**: An integer `k` (1 ≤ k ≤ len(arr)) representing the position of the smallest element to find. # Output * An integer representing the kth smallest element in the list. # Constraints * You should not use built-in sorting functions. * The algorithm should be efficient and preferably use methods like Quickselect. # Example ```python assert kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 assert kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest([1, 10, 4, 3, 9, 8], 6) == 10 ``` # Notes * You may choose to implement the Quickselect algorithm which is related to the QuickSort algorithm. * Carefully handle edge cases such as arrays with duplicate elements. * Ensure your function works efficiently even for the largest allowed input sizes. * Review the working of partitioning schemes and the concept of average-case time complexity in the context of Quickselect. # Testing Besides the provided assertions, consider adding tests with large input sizes and arrays with negative values or duplicates to verify the robustness and performance of your implementation.","solution":"from typing import List def kth_smallest(arr: List[int], k: int) -> int: Returns the kth smallest element in the unsorted array using the Quickselect algorithm. import random def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k_smallest): if left == right: # If the list contains only one element return arr[left] # Select a random pivot_index between left and right pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"Problem Statement You have been asked to implement a function to simulate the behavior of a basic text editor. The editor supports the following operations: 1. Insert a character at the current position. 2. Delete the character at the current position. 3. Move the cursor left. 4. Move the cursor right. In this problem, you need to implement the `TextEditor` class with the following methods: - `insert(c: str) -> None`: Inserts character `c` at the current cursor position. - `delete() -> None`: Deletes the character at the current cursor position if there is one. - `move_left() -> None`: Moves the cursor one position to the left. - `move_right() -> None`: Moves the cursor one position to the right. - `get_text() -> str`: Returns the current state of the string in the editor. The cursor is initially at position 0. Assume all operations are valid and will not perform actions outside the bounds of the current string. # Input The input will be a sequence of operations on the `TextEditor` object. There will not be any invalid operations. You will be provided with a list of actions to execute from the following: - (\\"insert\\", c) - (\\"delete\\", ) - (\\"move_left\\", ) - (\\"move_right\\", ) - (\\"get_text\\", ) # Output The output is the result of the `\\"get_text\\"` operations as a list of strings. # Example ```python # The sequence of operations actions = [(\\"insert\\", \\"a\\"), (\\"insert\\", \\"b\\"), (\\"insert\\", \\"c\\"), (\\"move_left\\", ), (\\"delete\\", ), (\\"get_text\\", )] ``` Output: ```python [\\"ab\\"] ``` Explanation: 1. Insert \\"a\\", text: \\"a\\", cursor position: 1 2. Insert \\"b\\", text: \\"ab\\", cursor position: 2 3. Insert \\"c\\", text: \\"abc\\", cursor position: 3 4. Move left, text: \\"abc\\", cursor position: 2 5. Delete, text: \\"ac\\", cursor position: 2 6. Get text, result: [\\"ab\\"] # Implementation ```python class TextEditor: def __init__(self): self.text = [] self.cursor = 0 def insert(self, c: str) -> None: self.text.insert(self.cursor, c) self.cursor += 1 def delete(self) -> None: if self.cursor < len(self.text): self.text.pop(self.cursor) def move_left(self) -> None: if self.cursor > 0: self.cursor -= 1 def move_right(self) -> None: if self.cursor < len(self.text): self.cursor += 1 def get_text(self) -> str: return \\"\\".join(self.text) ``` # Additional Requirements * Implement the operations with O(n) time complexity where n is the length of the text. All operations `insert`, `delete`, `move_left`, `move_right` should aim for O(1) complexity. * Ensure the solution works efficiently for a large number of operations, up to 10^5.","solution":"class TextEditor: def __init__(self): self.left = [] self.right = [] def insert(self, c: str) -> None: self.left.append(c) def delete(self) -> None: if self.right: self.right.pop(0) def move_left(self) -> None: if self.left: self.right.insert(0, self.left.pop()) def move_right(self) -> None: if self.right: self.left.append(self.right.pop(0)) def get_text(self) -> str: return \\"\\".join(self.left) + \\"\\".join(self.right)"},{"question":"# Question: Implement a Function to Flatten a Nested List You are given a nested list of integers, which may contain other nested lists. Your task is to implement a function that flattens the nested list into a single-level list containing all the integers in the original order they appeared. **Input**: 1. A nested list of integers, `nested_list`. **Output**: - A single-level list containing all the integers from the nested list. **Function Signature**: ```python def flatten_nested_list(nested_list: list) -> list[int]: pass ``` # Constraints: 1. Each element in `nested_list` is either an integer or another nested list. 2. The depth of nested lists will not exceed 100 levels. 3. The number of integers in the flattened list will not exceed 10^6. # Example: ```python >>> flatten_nested_list([1, [2, [3, 4], 5], 6, [[7], 8]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_list([[[1]], 2, [[3, 4], [5, 6]], 7, [8, [9, 10]]]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> flatten_nested_list([]) [] >>> flatten_nested_list([1, 2, 3]) [1, 2, 3] >>> flatten_nested_list([[1, 2], [[3, 4]], [[5, [6, 7]]]]) [1, 2, 3, 4, 5, 6, 7] ``` # Explanation: - The first example returns `[1, 2, 3, 4, 5, 6, 7, 8]` by flattening the nested structure. - The second example returns `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` by flattening all nested levels. - The third example returns an empty list because the input is empty. - The fourth example returns `[1, 2, 3]` because the input list is already flat. - The fifth example correctly flattens various levels of nesting in the input list. Your implementation should be optimized for both time and space complexity. Ensure to test your function with various edge cases to validate its correctness.","solution":"def flatten_nested_list(nested_list: list) -> list[int]: Flattens a nested list of integers into a single-level list containing all the integers in the original order they appeared. result = [] def flatten_helper(sublist): for element in sublist: if isinstance(element, list): flatten_helper(element) else: result.append(element) flatten_helper(nested_list) return result"},{"question":"# Document Index Search Challenge **Problem Statement**: You are tasked with writing a function that searches for a target string within a list of document entries and returns the indices of the documents that contain the target string. The search should be case-insensitive, and the function should ignore any punctuation and whitespace differences. **Function Definition**: ```python def document_search(documents: list, target: str) -> list: Searches for the target string within a list of documents and returns the indices of documents that contain the target string. Args: - documents (list): A list of strings where each string represents a document. - target (str): The target string to search for within the documents. Returns: - list: A list of indices (0-based) of documents that contain the target string. pass ``` **Input/Output Specifications**: * **Input**: - A list of strings, each representing a document. - A target string to be searched within the documents. * **Output**: - A list of indices representing the position of documents that contain the target string. **Constraints**: * Ignore any punctuation and whitespace in both documents and the target string. * The search should be case-insensitive. **Example**: ```python documents = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"Pack my box with five dozen liquor jugs!\\", \\"This is a simple test document.\\" ] assert document_search(documents, \\"quick brown\\") == [0] assert document_search(documents, \\" LIQUOR JUGS \\") == [1] assert document_search(documents, \\"simPLe TEST\\") == [2] assert document_search(documents, \\"not in documents\\") == [] assert document_search(documents, \\"quick\\") == [0] ``` **Hints**: 1. You can use regular expressions to remove punctuation and whitespace. 2. Convert both the documents and the target string to a common case (e.g., lower case) for comparison.","solution":"import re def document_search(documents: list, target: str) -> list: Searches for the target string within a list of documents and returns the indices of documents that contain the target string. Args: - documents (list): A list of strings where each string represents a document. - target (str): The target string to search for within the documents. Returns: - list: A list of indices (0-based) of documents that contain the target string. # Helper function to clean up the string by removing punctuation and converting to lower case def clean_string(s): return re.sub(r\'W+\', \'\', s).lower() clean_target = clean_string(target) result_indices = [] for i, doc in enumerate(documents): clean_doc = clean_string(doc) if clean_target in clean_doc: result_indices.append(i) return result_indices"},{"question":"# Coding Assessment Question Scenario You are assigned to develop a utility function for managing inventory in a warehouse. The function should determine the minimum number of bundles required to meet a specified order quantity. Each bundle comes with a specified number of items. Task Implement the following function: ```python def min_bundles(order_quantity: int, bundle_sizes: List[int]) -> int: Determines the minimum number of bundles required to meet the order quantity. Parameters: - order_quantity: An integer representing the total number of items needed (1 <= order_quantity <= 10^6). - bundle_sizes: A list of integers where each integer denotes the number of items in a bundle (1 <= len(bundle_sizes) <= 1000, 1 <= bundle_sizes[i] <= 1000). Returns: - The minimum number of bundles required to meet or exceed the order quantity. ``` Requirements 1. **`min_bundles` Implementation**: The function should find the optimal way to use the least number of bundles to meet or exceed the order. 2. **Input Constraints**: - (1 leq order_quantity leq 10^6) - (1 leq text{len(bundle_sizes)} leq 1000) - (1 leq bundle_sizes[i] leq 1000) 3. **Output**: The minimum number of bundles required. Example ```python from typing import List def min_bundles(order_quantity: int, bundle_sizes: List[int]) -> int: bundle_sizes.sort(reverse=True) count = 0 for size in bundle_sizes: if order_quantity <= 0: break count += order_quantity // size order_quantity %= size return count if order_quantity == 0 else -1 # Test cases assert min_bundles(100, [1, 10, 50]) == 2 # Using 2 bundles of size 50 assert min_bundles(30, [5, 10, 25]) == 2 # Using 1 bundle of size 25 and 1 bundle of size 5 assert min_bundles(12, [3, 6, 9]) == 2 # Using 2 bundles of size 6 ``` Additional Notes - Ensure to handle scenarios where it is impossible to meet the exact order quantity by returning -1 in such cases. - Consider performance aspects, especially when the bundle sizes are numerous.","solution":"from typing import List def min_bundles(order_quantity: int, bundle_sizes: List[int]) -> int: bundle_sizes.sort(reverse=True) count = 0 for size in bundle_sizes: if order_quantity <= 0: break count += order_quantity // size order_quantity %= size return count if order_quantity == 0 else -1"},{"question":"# Problem Statement **Graph Shortest Path with Constraints** Given a weighted, directed graph represented as an adjacency matrix, your objective is to find the shortest path from a given source node to a target node. The graph may have constraints in terms of edge weights and maximum path length, and you must ensure that the path does not exceed a specified maximum weight. # Requirements: 1. **Function Definition**: ```python def constrained_shortest_path(graph: list[list[float]], source: int, target: int, max_weight: float) -> list[int]: Computes the shortest path from a source node to a target node under a weight constraint. Parameters: graph (list): A 2D list representing the adjacency matrix of the graph, where graph[i][j] is the weight of the edge from node i to node j. source (int): The starting node. target (int): The destination node. max_weight (float): The maximum allowed weight for the path. Returns: list: A list of nodes representing the vertices in the shortest path from source to target, or an empty list if no such path exists. ``` 2. **Input Specifications**: * A 2D list representing the adjacency matrix, where `graph[i][j]` is a float indicating the weight of the edge from node `i` to node `j`. If there is no edge, the weight is considered to be `float(\'inf\')`. * Integers `source` and `target`, representing the starting and ending nodes respectively. * A float `max_weight` representing the maximum allowed weight for the path. 3. **Output Specifications**: * A list of node indices representing the shortest path from `source` to `target`, or an empty list if no such path exists within the weight constraint. 4. **Constraints**: * `2 <= number of nodes <= 100` * `0 <= weight of any edge <= 10^3` * `source` and `target` are valid node indices within the graph. * `max_weight` will be a positive float. # Example: **Input**: ```python graph = [ [0, 1.5, float(\'inf\'), float(\'inf\')], [1.5, 0, 1.2, float(\'inf\')], [float(\'inf\'), 1.2, 0, 2.7], [float(\'inf\'), float(\'inf\'), 2.7, 0] ] source = 0 target = 3 max_weight = 5.0 ``` **Output**: ```python [0, 1, 2, 3] ``` # Evaluation Criteria: * Correctness: Ensure the function returns the correct shortest path within the given constraints. * Efficiency: Although the graph is relatively small, aim for a solution that scales well with the input size. * Robustness: Handle cases where no valid path exists within the weight constraint. # Notes: * You may use algorithms such as Dijkstra\'s with some modifications to account for the weight constraints. * Ensure that the approach handles graphs with disconnected components and edges with infinite weights properly. * Document any assumptions or edge cases considered in your solution.","solution":"import heapq def constrained_shortest_path(graph, source, target, max_weight): Computes the shortest path from a source node to a target node under a weight constraint. Parameters: graph (list): A 2D list representing the adjacency matrix of the graph, where graph[i][j] is the weight of the edge from node i to node j. source (int): The starting node. target (int): The destination node. max_weight (float): The maximum allowed weight for the path. Returns: list: A list of nodes representing the vertices in the shortest path from source to target, or an empty list if no such path exists. num_nodes = len(graph) # Priority queue to store (current_path_weight, current_path, current_node) pq = [(0, [source], source)] # Dictionary to store minimum weight to reach each node min_weight_to_node = {i: float(\'inf\') for i in range(num_nodes)} min_weight_to_node[source] = 0 while pq: current_weight, path, node = heapq.heappop(pq) # If we reached the target node, return the path if node == target: return path # Explore neighbours for neighbor in range(num_nodes): edge_weight = graph[node][neighbor] if edge_weight == float(\'inf\'): continue new_weight = current_weight + edge_weight # Check if the new path is within the max_weight and is an improvement if new_weight < min_weight_to_node[neighbor] and new_weight <= max_weight: min_weight_to_node[neighbor] = new_weight new_path = path + [neighbor] heapq.heappush(pq, (new_weight, new_path, neighbor)) # If target node is not reachable within the weight constraint, return an empty list return []"},{"question":"# Problem Statement You are tasked with developing a function to evaluate and process sensor data. The sensor generates a series of readings taken at fixed time intervals. To ensure the accuracy and reliability of the data, one must identify the longest contiguous subarray where the difference between the maximum and minimum readings does not exceed a specified threshold. Write a function that identifies this subarray and returns its length. # Function Signature ```python def longest_valid_subarray(sensor_data: List[int], threshold: int) -> int: This function finds the length of the longest contiguous subarray where the difference between the maximum and minimum readings does not exceed the given threshold. Args: sensor_data: List of integers, sensor readings taken at fixed intervals. threshold: int, the allowable difference between the maximum and minimum readings. Returns: int, the length of the longest valid subarray. ``` # Expected Input and Output - **Input**: - A list of integers representing the sensor data. - An integer threshold specifying the maximum allowable difference between the highest and lowest values in a subarray. - **Output**: - An integer representing the length of the longest valid subarray where the difference between the maximum and minimum values does not exceed the threshold. # Example ```python sensor_data = [1, 3, 6, 8, 10, 15, 16, 17, 18] threshold = 4 result = longest_valid_subarray(sensor_data, threshold) print(result) # 4 (subarray: [15, 16, 17, 18]) sensor_data = [4, 2, 2, 2, 4, 4, 2, 2] threshold = 0 result = longest_valid_subarray(sensor_data, threshold) print(result) # 3 (subarray: [2, 2, 2] or [4, 4, 4]) ``` # Constraints * 1 ≤ len(sensor_data) ≤ 10^5 * 0 ≤ sensor_data[i] ≤ 10^9 * 0 ≤ threshold ≤ 10^9 # Evaluation * **Correctness**: Ensure that your function accurately finds the length of the longest valid subarray. * **Efficiency**: Consider the time and space complexity. The function should efficiently handle sensor data of up to 10^5 readings.","solution":"from collections import deque from typing import List def longest_valid_subarray(sensor_data: List[int], threshold: int) -> int: max_deque = deque() min_deque = deque() l = 0 max_length = 0 for r, value in enumerate(sensor_data): while max_deque and sensor_data[max_deque[-1]] <= value: max_deque.pop() while min_deque and sensor_data[min_deque[-1]] >= value: min_deque.pop() max_deque.append(r) min_deque.append(r) while sensor_data[max_deque[0]] - sensor_data[min_deque[0]] > threshold: l += 1 if max_deque[0] < l: max_deque.popleft() if min_deque[0] < l: min_deque.popleft() max_length = max(max_length, r - l + 1) return max_length"},{"question":"# Problem Statement Implement a function `capitalize_words(sentence: str) -> str` that capitalizes the first letter of every word in a given sentence. A word is defined as a sequence of non-space characters separated by spaces. The rest of the characters in each word should remain unchanged. Input * `sentence` (str): a string containing words separated by spaces. The input contains only printable ASCII characters and spaces. Output * The function should return a string with the first letter of each word capitalized. Example ```python >>> capitalize_words(\\"hello world\\") \\"Hello World\\" >>> capitalize_words(\\"python programming is fun\\") \\"Python Programming Is Fun\\" >>> capitalize_words(\\"the quick brown fox\\") \\"The Quick Brown Fox\\" >>> capitalize_words(\\"capitalize the first letter\\") \\"Capitalize The First Letter\\" ``` # Constraints * The length of the `sentence` will be between 1 and 200 characters. * There will be at least one word in the `sentence`. # Requirements * The function should execute in linear time, i.e., O(n), where n is the length of the input string. * Utilize Python\'s built-in string methods for efficient implementation. * Handle edge cases where there might be multiple spaces between words.","solution":"def capitalize_words(sentence: str) -> str: Capitalizes the first letter of each word in the given sentence. A word is defined as a sequence of non-space characters separated by spaces. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the first letter of each word capitalized. return \' \'.join(word.capitalize() for word in sentence.split())"},{"question":"# Coding Assessment Question Context You are part of a team developing an e-commerce platform with sophisticated search functionalities. One of the features in development allows users to perform keyword searches while ignoring specific keywords deemed irrelevant, known as \\"stop words\\". Your task is to implement a filter that removes these stop words from search queries. Task Write a Python function `filter_search_query` that takes two inputs: a string `query` representing the user\'s search query and a list of strings `stop_words` representing the stop words to be filtered out. The function should return a new string representing the search query with the stop words removed. Function Signature ```python def filter_search_query(query: str, stop_words: list) -> str: ``` Input * `query` (a string): A search query comprised of words separated by spaces. * `stop_words` (a list of strings): A list of words to be excluded from the search query. Each word in the list is unique and contains only printable ASCII characters. Output * A string representing the filtered search query, with the stop words removed and the remaining words combined with a single space separating them. Constraints 1. The input `query` will only contain printable ASCII characters and spaces. 2. The input `stop_words` will have at most 100 unique words. 3. The combined length of all the words in `stop_words` will not exceed 1000 characters. 4. The length of the `query` will not exceed 500 characters. Example ```python # Example query = \\"find the best restaurants near me\\" stop_words = [\\"the\\", \\"near\\"] print(filter_search_query(query, stop_words)) # Output: \\"find best restaurants me\\" query = \\"data analysis and machine learning\\" stop_words = [\\"and\\"] print(filter_search_query(query, stop_words)) # Output: \\"data analysis machine learning\\" query = \\"buy cheap books online\\" stop_words = [\\"cheap\\", \\"online\\"] print(filter_search_query(query, stop_words)) # Output: \\"buy books\\" ``` Notes * The order of words in the filtered search query should be retained as in the original query. * Words are only removed if they match a stop word exactly, so case sensitivity should be considered. * If the resulting query is empty, return an empty string.","solution":"def filter_search_query(query: str, stop_words: list) -> str: Removes stop words from the search query. Parameters: query (str): The user\'s search query. stop_words (list): The list of stop words to be filtered out. Returns: str: The filtered search query with stop words removed. query_words = query.split() filtered_words = [word for word in query_words if word not in stop_words] return \' \'.join(filtered_words)"},{"question":"# Binary Tree Flattening You are given a binary tree, and your task is to flatten the tree into a linked list in-place. The linked list should use the right child pointers to point to the next node in the list and the left child pointers should be set to `None`. The \\"linked list\\" should preserve the same node sequence as a pre-order traversal of the binary tree. # Problem Statement Implement the function `flatten` that transforms the given binary tree into a flattened linked list following the above constraints. # Constraints 1. The number of nodes in the tree ranges from 1 to 2000. 2. The value of each node is a unique integer between -10^4 and 10^4. # Input Format - A binary tree represented by its root node. # Output Format - The flattened tree, with each node\'s right pointer pointing to the next node in order and left pointers set to `None`. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.right = TreeNode(6) flatten(root) # After calling flatten, the tree should look like this: # 1 -> 2 -> 3 -> 4 -> 5 -> 6 # where each \'->\' represents the right pointer and all left pointers are None. ``` # Implementation Complete the `flatten` function in the following manner: 1. Perform a pre-order traversal to process the nodes. 2. Adjust the right and left pointers accordingly in-place. ```python def flatten(root: TreeNode) -> None: Do not return anything, modify root in-place instead. if not root: return # Stack to hold the nodes stack = [root] while stack: current = stack.pop() # If the node has a right child, push it onto the stack if current.right: stack.append(current.right) # If the node has a left child, push it onto the stack if current.left: stack.append(current.left) # Reassign the right to the next node on top of the stack, if any if stack: current.right = stack[-1] # Ensure the left node is null current.left = None ``` # Notes 1. The function should modify the tree in-place without using any extra space for another data structure. 2. Ensure that the resulting structure is a singly linked list with each node linked via the right pointer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root: TreeNode) -> None: Do not return anything, modify root in-place instead. if not root: return stack = [root] while stack: current = stack.pop() if current.right: stack.append(current.right) if current.left: stack.append(current.left) if stack: current.right = stack[-1] current.left = None"},{"question":"# Problem Statement: You are given a string and an integer representing the number of rows in a zigzag pattern. Your task is to convert the string to this zigzag pattern and then read it line by line. # Task: Implement the `convert_to_zigzag` function which takes a string `s` and an integer `num_rows`, and returns the string in its converted zigzag form. The zigzag pattern is formed by writing the characters from top to bottom in the first column, then diagonally up to the top of the next column, and repeating this process. # Function Signature: ```python def convert_to_zigzag(s: str, num_rows: int) -> str: ``` # Input: - A string `s` ((0 leq |s| leq 10^6)) containing alphanumeric characters and symbols. - An integer `num_rows` ((1 leq num_rows leq 1000)) representing the number of rows in the zigzag pattern. # Output: - A string representing the characters of `s` arranged in the zigzag pattern and read line by line. # Example: ```python assert convert_to_zigzag(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" assert convert_to_zigzag(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" assert convert_to_zigzag(\\"AB\\", 1) == \\"AB\\" assert convert_to_zigzag(\\"A\\", 5) == \\"A\\" ``` # Constraints: - The zigzag conversion should only require O(n) space, where n is the length of the string. - The conversion process should have O(n) time complexity. # Implementation Note: Ensure that the process of writing and reading the string follows the zigzag pattern described. The goal is to demonstrate your understanding of string manipulation and pattern generation. Avoid using any additional libraries beyond Python\'s standard library.","solution":"def convert_to_zigzag(s: str, num_rows: int) -> str: if num_rows == 1 or num_rows >= len(s): return s # Create a list of strings for all rows rows = [\'\'] * num_rows current_row = 0 going_down = False # Traverse the entire string for char in s: rows[current_row] += char if current_row == 0 or current_row == num_rows - 1: going_down = not going_down current_row += 1 if going_down else -1 # Join all rows to form the final string return \'\'.join(rows)"},{"question":"# Coding Task: Find the Missing Number You\'re working on a project involving a sequence of numbers, and you need to identify any missing elements in the sequence. The sequence consists of `n` distinct integers, each ranging from 0 to `n`. Your task is to pinpoint the one number that is missing from the sequence. # Problem Description Write a function `find_missing_number` that takes a list of integers representing a sequence that contains every number from 0 to `n` except for one missing number. The function should return the missing number. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: ``` # Input * `nums`: A list of `n` distinct integers taken from the range 0, 1, 2, ..., `n`. # Output * Returns the missing integer from the list. # Constraints * The length of `nums` is `n`, and `0 <= nums[i] <= n` for each `nums[i]`. * Elements in `nums` are distinct. * (1 leq n leq 10^5). # Examples ```python # Example 1 nums = [3, 0, 1] print(find_missing_number(nums)) # Output: 2 # Example 2 nums = [0, 1] print(find_missing_number(nums)) # Output: 2 # Example 3 nums = [9, 6, 4, 2, 3, 5, 7, 0, 1] print(find_missing_number(nums)) # Output: 8 # Example 4 nums = [0] print(find_missing_number(nums)) # Output: 1 ``` # Instructions 1. Carefully read the problem description and examples. 2. Implement the `find_missing_number` function. 3. Ensure your solution is efficient and can handle the upper constraint limits.","solution":"def find_missing_number(nums: list[int]) -> int: n = len(nums) total_sum = n * (n + 1) // 2 nums_sum = sum(nums) return total_sum - nums_sum"},{"question":"You are tasked with implementing a basic calculator that can handle arithmetic expressions involving addition, subtraction, multiplication, and division. The calculator should evaluate the expressions from left to right without considering operator precedence. # Task Implement a function that evaluates arithmetic expressions containing integers and the operators +, -, *, and /. # Function Signature ```python def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing integers and the operators +, -, *, and /. Args: expression (str): The arithmetic expression to be evaluated. Returns: float: The result of the evaluated expression. pass ``` # Input * `expression`: A string containing a valid arithmetic expression. The expression will only contain integers, the operators +, -, *, /, and spaces. # Output * A float representing the result of the evaluated expression. # Constraints * The expression will contain only valid arithmetic operations. * The division operator / should perform floating-point division. * The expression will not contain any parentheses. * The expression will not contain any variables; it will be a straightforward calculation of the provided numbers and operators. # Examples ```python >>> evaluate_expression(\\"3 + 5 * 2\\") 16.0 >>> evaluate_expression(\\"10 / 2 - 3\\") 2.0 >>> evaluate_expression(\\"4 * 3 + 2\\") 14.0 >>> evaluate_expression(\\"12 - 4 / 2\\") 4.0 ``` # Additional Notes * The evaluation should proceed from left to right, ignoring the usual precedence rules of arithmetic operators. * For instance, in the example \\"3 + 5 * 2\\", evaluate \\"3 + 5\\" first to get 8, then multiply the result by 2 to get 16.","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing integers and the operators +, -, *, and / from left to right without considering operator precedence. Args: expression (str): The arithmetic expression to be evaluated. Returns: float: The result of the evaluated expression. tokens = expression.split() current_result = float(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] next_number = float(tokens[i + 1]) if operator == \'+\': current_result += next_number elif operator == \'-\': current_result -= next_number elif operator == \'*\': current_result *= next_number elif operator == \'/\': current_result /= next_number i += 2 return current_result"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},N={class:"card-container"},z={key:0,class:"empty-state"},R=["disabled"],L={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",N,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",L,"See more"))],8,R)):u("",!0)])}const j=h(F,[["render",D],["__scopeId","data-v-4b252420"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/46.md","filePath":"quotes/46.md"}'),Y={name:"quotes/46.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,V as default};
