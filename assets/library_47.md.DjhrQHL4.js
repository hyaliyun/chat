import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-5127469c"]]),S=JSON.parse('[{"question":"# Journal Article Citation Generator In this task, your assignment is to implement a function that automatically formats citations for journal articles based on given details such as author names, article title, journal name, volume number, issue number, and publication year, following a specific citation style (APA format). Task Description: Implement a function `generate_citation` that takes the details of a journal article and returns a properly formatted APA citation string. Function Signature: ```python def generate_citation(authors: list[str], title: str, journal: str, volume: int, issue: int, year: int, pages: str) -> str: ``` Input: * `authors` (List[str]): A list of author names, each as a string in the format \\"Last, First M.\\". * `title` (str): The title of the article. * `journal` (str): The name of the journal. * `volume` (int): The volume number of the journal. * `issue` (int): The issue number of the journal. * `year` (int): The year of publication. * `pages` (str): The page range of the article, e.g., \\"123-145\\". Output: * Returns a string representing the citation in APA format. Constraints: * 1 ≤ len(authors) ≤ 10 * 1 ≤ len(title) ≤ 200 * 1 ≤ len(journal) ≤ 100 * 1 ≤ volume ≤ 1000 * 1 ≤ issue ≤ 1000 * 1000 ≤ year ≤ 9999 * 1 ≤ len(pages) ≤ 10 Example: ```python authors = [\\"Smith, John A.\\", \\"Doe, Jane E.\\"] title = \\"Investigating the Efficacy of Algorithms in Bioinformatics\\" journal = \\"Journal of Computational Biology\\" volume = 25 issue = 4 year = 2020 pages = \\"789-803\\" print(generate_citation(authors, title, journal, volume, issue, year, pages)) # Output: \\"Smith, J. A., & Doe, J. E. (2020). Investigating the efficacy of algorithms in bioinformatics. Journal of Computational Biology, 25(4), 789-803.\\" ``` Key Directions: 1. Follow the APA citation style strictly. 2. Ensure the authors are formatted correctly with initials. 3. Title case the journal name, but use sentence case for the article title. 4. Properly format volume and issue numbers, including the appropriate punctuation, and page range. 5. Handle edge cases where some inputs might be empty, ensuring a robust function. Hints: 1. Pay attention to the handling of multiple authors. 2. Make sure to abbreviate the first names and middle initials correctly. 3. Ensure that punctuation and formatting are consistent with the APA standard.","solution":"def generate_citation(authors: list[str], title: str, journal: str, volume: int, issue: int, year: int, pages: str) -> str: Returns an APA formatted citation for a journal article based on the provided details. def format_author(author): parts = author.split(\\", \\") last_name = parts[0] first_and_middle = parts[1].split(\\" \\") initials = \\" \\".join([name[0] + \\".\\" for name in first_and_middle]) return f\\"{last_name}, {initials}\\" formatted_authors = \\", & \\".join([format_author(author) for author in authors]) formatted_title = title.capitalize() citation = (f\\"{formatted_authors} ({year}). {formatted_title}. \\" f\\"{journal}, {volume}({issue}), {pages}.\\") return citation"},{"question":"# Problem Statement In this coding challenge, you are required to implement a function that parses a boolean expression and computes its result. The expression will include variables, ands (denoted by \'&\'), ors (denoted by \'|\'), and nots (denoted by \'!\'). The variables will be either true (\'1\') or false (\'0\'). Objective Write a `Boolean Expression Evaluator` function `evaluate_expression(expression: str) -> int` to evaluate the given boolean expression. Input * `expression`: A string representing the boolean expression which includes binary values (\'0\' and \'1\'), logical operators (\'&\', \'|\', \'!\'), and parentheses for grouping. Output * An integer `1` if the evaluated result of the expression is true, otherwise `0`. Constraints * The length of `expression` is between 1 and 10^4 inclusive. * The expression will always be valid and properly parenthesized. * Operators symbols are directly adjacent to variables and parentheses, without spaces. * The solution should evaluate the expression efficiently. Requirements 1. Implement `evaluate_expression` to correctly interpret and evaluate the boolean expression. 2. Ensure that the evaluation follows the standard operator precedence: `!` has the highest precedence, followed by `&`, and `|`. # Example ```python evaluate_expression(\\"1&0|1\\") # Output: 1 evaluate_expression(\\"1&(0|0)\\") # Output: 0 evaluate_expression(\\"!(1|0)&1\\") # Output: 0 evaluate_expression(\\"!1|1\\") # Output: 1 ```","solution":"def evaluate_expression(expression: str) -> int: def eval_not(val): return 1 if val == 0 else 0 def eval_and(val1, val2): return val1 & val2 def eval_or(val1, val2): return val1 | val2 def compute(operators, values): operator = operators.pop() if operator == \'!\': value = values.pop() values.append(eval_not(value)) else: right = values.pop() left = values.pop() if operator == \'&\': values.append(eval_and(left, right)) elif operator == \'|\': values.append(eval_or(left, right)) precedence = {\'!\': 3, \'&\': 2, \'|\': 1} operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \'1\': values.append(1) elif expression[i] == \'0\': values.append(0) elif expression[i] in precedence: while (operators and operators[-1] != \'(\' and precedence[operators[-1]] >= precedence[expression[i]]): compute(operators, values) operators.append(expression[i]) elif expression[i] == \'(\': operators.append(\'(\') elif expression[i] == \')\': while operators[-1] != \'(\': compute(operators, values) operators.pop() # popping \'(\' i += 1 while operators: compute(operators, values) return values[0]"},{"question":"# Problem Statement Write a function `find_duplicates` that takes a list of integers and returns a new list containing the duplicates found in the input list, ordered by their first occurrence from the input. Additionally, implement a function `remove_duplicates` that removes any duplicates from the input list while maintaining the order of the first occurrence of each element. # Function Signatures ```python def find_duplicates(nums: list[int]) -> list[int]: pass def remove_duplicates(nums: list[int]) -> list[int]: pass ``` # Input - `nums`: A list of integers that may contain duplicates. # Output - `find_duplicates`: A list containing the first occurrence of each duplicate integer, in the order they first appeared. - `remove_duplicates`: The input list with duplicates removed, maintaining the order of first occurrence. # Constraints - The length of `nums` will be between 0 and 10^5. - The integers in the list will be in the range -10^6 to 10^6. # Example ```python >>> nums = [1, 2, 3, 1, 2, 4, 5] >>> find_duplicates(nums) [1, 2] >>> remove_duplicates(nums) [1, 2, 3, 4, 5] >>> nums = [] >>> find_duplicates(nums) [] >>> remove_duplicates(nums) [] >>> nums = [4, 5, 6, 5, 4, 7, 8, 8] >>> find_duplicates(nums) [5, 4, 8] >>> remove_duplicates(nums) [4, 5, 6, 7, 8] ``` # Hints - Consider using a set or a dictionary to track duplicates efficiently. - Pay attention to the order of elements while identifying duplicates and removing them.","solution":"def find_duplicates(nums: list[int]) -> list[int]: seen = set() duplicates = [] for num in nums: if num in seen: if num not in duplicates: duplicates.append(num) else: seen.add(num) return duplicates def remove_duplicates(nums: list[int]) -> list[int]: seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Data Normalization and Principal Component Analysis Implementation Assessment Context You are tasked with implementing data normalization techniques and enhancing a machine learning pre-processing pipeline with Principal Component Analysis (PCA). This will help ensure comprehension of aspects related to data transformation, feature scaling, and dimensionality reduction. Task 1. **Implement Data Normalization Techniques**: - Add support for Min-Max Normalization and Z-score Standardization techniques. - Ensure data is correctly transformed using these normalization techniques. 2. **Implement Principal Component Analysis (PCA)**: - Modify the `PCA` class to include methods for fitting the model on standardized data and transforming the original data into principal components. Expected Function Implementation 1. **Normalization Techniques (Min-Max, Z-score)**: ```python def min_max_normalize(data: np.ndarray) -> np.ndarray: # Your code here def z_score_standardize(data: np.ndarray) -> np.ndarray: # Your code here ``` 2. **Principal Component Analysis (PCA)**: - Implement the `fit` and `transform` methods in the `PCA` class: ```python class PCA: def __init__(self, n_components: int): self.n_components = n_components self.mean = None self.components = None def fit(self, data: np.ndarray): # Your code here def transform(self, data: np.ndarray) -> np.ndarray: # Your code here ``` 3. **Integration with Normalization**: - Ensure your modifications integrate seamlessly with the normalization and PCA transformation processes. Input and Output **Input**: - Data as a 2D NumPy array (features) - Number of components for PCA (integer) - Normalization technique to use (\'min_max\', \'z_score\') **Output**: - Transformed data as a 2D NumPy array after normalization and PCA. Constraints - Inputs should only be valid NumPy arrays (features). - The number of components should be positive integers and less than the number of features. - Only valid normalization technique strings (\'min_max\', \'z_score\') should be provided. Scenario Implement the required functions and modifications, and then integrate them to preprocess a given dataset. Validate the implementation to ensure correct data normalization and dimensionality reduction using PCA according to the described setup.","solution":"import numpy as np def min_max_normalize(data: np.ndarray) -> np.ndarray: Apply Min-Max normalization to the data. min_val = np.min(data, axis=0) max_val = np.max(data, axis=0) return (data - min_val) / (max_val - min_val) def z_score_standardize(data: np.ndarray) -> np.ndarray: Apply Z-score standardization to the data. mean = np.mean(data, axis=0) std_dev = np.std(data, axis=0) return (data - mean) / std_dev class PCA: def __init__(self, n_components: int): self.n_components = n_components self.mean = None self.components = None def fit(self, data: np.ndarray): Fit the data using PCA, finding the principal components. self.mean = np.mean(data, axis=0) data_centered = data - self.mean covariance_matrix = np.cov(data_centered, rowvar=False) eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix) sorted_indices = np.argsort(eigenvalues)[::-1] self.components = eigenvectors[:, sorted_indices[:self.n_components]] def transform(self, data: np.ndarray) -> np.ndarray: Transform the data to the principal component space. data_centered = data - self.mean return np.dot(data_centered, self.components) def preprocess_data(data: np.ndarray, n_components: int, normalization: str) -> np.ndarray: Integrate normalization and PCA to preprocess the data. if normalization == \'min_max\': normalized_data = min_max_normalize(data) elif normalization == \'z_score\': normalized_data = z_score_standardize(data) else: raise ValueError(\\"Normalization method must be \'min_max\' or \'z_score\'.\\") pca = PCA(n_components) pca.fit(normalized_data) return pca.transform(normalized_data)"},{"question":"# Coding Assessment Question Context In computer graphics, one common task is to reflect an image or shape over a vertical axis centered within a 2D grid. This operation can be used in various applications, including image processing and transformations. Task Implement a function `reflect_matrix` that takes an `n x n` matrix of integers and returns a new matrix that represents the original matrix reflected over its vertical center axis. Function Signature ```python def reflect_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` Input - `matrix` (List[List[int]]): A 2D list (matrix) of integers of size `n x n`. `1 <= n <= 20`. Output - A 2D list (matrix) of size `n x n`, where each element is the mirrored version of the input matrix over its vertical axis. Example - Input: `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - Output: `[[3, 2, 1], [6, 5, 4], [9, 8, 7]]` - Explanation: The original matrix is reflected over its vertical center axis. Constraints - Ensure the reflection is done correctly for any given value of `n`. Requirements * **Edge Cases**: Handle cases where `n = 1` properly (the matrix is already symmetrical). * **Performance**: The function should run efficiently within the given constraints. Write a well-tested function to perform the vertical reflection. Make sure your implementation handles all edge cases and constraints effectively.","solution":"from typing import List def reflect_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns a new matrix that is a reflection of the input matrix over its vertical center axis. reflected = [] for row in matrix: reflected.append(row[::-1]) return reflected"},{"question":"# Graph Data Structure: Implementing and Traversing a Weighted Graph You are required to implement a weighted graph data structure and perform Depth-First Search (DFS) on it. Your task is to write a Python class to represent the graph, including methods to add vertices, add edges with weights, and perform DFS traversal starting from a specified vertex. Class: WeightedGraph Implement the `WeightedGraph` class to manage the graph creation and traversal. **Methods**: 1. `add_vertex(vertex)` Adds a vertex to the graph. **Input**: - `vertex`: The vertex to be added (int or str). **Output**: - None 2. `add_edge(vertex1, vertex2, weight)` Adds a directed edge between two vertices with the specified weight. **Input**: - `vertex1`: The starting vertex (int or str). - `vertex2`: The ending vertex (int or str). - `weight`: The weight of the edge (int or float). **Output**: - None 3. `dfs(start_vertex)` Performs a Depth-First Search (DFS) traversal starting from the given vertex. **Input**: - `start_vertex`: The starting vertex for DFS traversal (int or str). **Output**: - `traversal_order` (list): A list of vertices in the order they were visited. Example: ```python class WeightedGraph: def __init__(self): # Your implementation here pass def add_vertex(self, vertex): # Your implementation here pass def add_edge(self, vertex1, vertex2, weight): # Your implementation here pass def dfs(self, start_vertex): # Your implementation here pass # Example usage graph = WeightedGraph() graph.add_vertex(\'A\') graph.add_vertex(\'B\') graph.add_vertex(\'C\') graph.add_edge(\'A\', \'B\', 4) graph.add_edge(\'A\', \'C\', 2) graph.add_edge(\'B\', \'C\', 5) dfs_order = graph.dfs(\'A\') print(dfs_order) # Should print the DFS traversal starting from vertex \'A\' ``` Ensure that your implementation correctly handles adding vertices, adding edges, and performing the DFS traversal on the weighted graph.","solution":"class WeightedGraph: def __init__(self): self.graph = {} def add_vertex(self, vertex): if vertex not in self.graph: self.graph[vertex] = {} def add_edge(self, vertex1, vertex2, weight): if vertex1 in self.graph and vertex2 in self.graph: self.graph[vertex1][vertex2] = weight def dfs(self, start_vertex): visited = set() traversal_order = [] def dfs_helper(v): if v not in visited: visited.add(v) traversal_order.append(v) for neighbor in self.graph[v]: dfs_helper(neighbor) dfs_helper(start_vertex) return traversal_order"},{"question":"# Question: Longest Common Subsequence Scenario You are developing a plagiarism detection tool that compares text documents. One of the techniques involves finding the longest common subsequence (LCS) between two sequences of words. This can help determine the similarity between documents by identifying the longest sequence of words that appear in the same order in both documents. Task Write a function `longest_common_subsequence` that takes two sequences of words and returns the longest common subsequence as a list of words. The function should use dynamic programming to ensure efficiency. Function Signature ```python def longest_common_subsequence(seq1: List[str], seq2: List[str]) -> List[str]: pass ``` Input * `seq1`: List of words (1 leq |seq1| leq 1000). * `seq2`: List of words (1 leq |seq2| leq 1000). Output * Return the longest common subsequence as a list of words. Example ```python assert longest_common_subsequence([\\"this\\", \\"is\\", \\"a\\", \\"test\\"], [\\"this\\", \\"test\\", \\"is\\", \\"a\\"]) == [\\"this\\", \\"is\\", \\"a\\"] assert longest_common_subsequence([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], [\\"a\\", \\"e\\", \\"c\\", \\"b\\", \\"d\\"]) == [\\"a\\", \\"b\\", \\"d\\"] assert longest_common_subsequence([\\"a\\", \\"b\\", \\"c\\"], [\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] ``` Constraints * The input words will be single lowercase words with no spaces or punctuation. * Ensure the implementation has a time complexity of (O(n cdot m)), where (n) and (m) are the lengths of the two input sequences. Implementation Details * Use a 2D table to store the lengths of LCS for all subproblems. * Backtrack through the table to construct the actual LCS. * Handle edge cases such as when the LCS length is zero.","solution":"from typing import List def longest_common_subsequence(seq1: List[str], seq2: List[str]) -> List[str]: n = len(seq1) m = len(seq2) # Create a 2D DP table with dimensions (n+1) x (m+1) initialized to 0 dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill DP table for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the LCS from the DP table lcs = [] i, j = n, m while i > 0 and j > 0: if seq1[i - 1] == seq2[j - 1]: lcs.append(seq1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] >= dp[i][j - 1]: i -= 1 else: j -= 1 return lcs[::-1]"},{"question":"# Question You are working on a task where you need to generate n-gram sequences from a given text. An n-gram is a contiguous sequence of n items from a given sample of text. The items can be words, characters, or syllables. In this task, you will generate word-level n-grams. Implement a Python function `generate_ngrams` that takes a string and an integer n as input and returns a list of n-grams. Each n-gram should be represented as a tuple of words. The function should handle preprocessing steps such as converting the text to lowercase and removing punctuation. Function Signature: ```python def generate_ngrams(text: str, n: int) -> List[Tuple[str]]: pass ``` Constraints: - The length of the input text is between 1 and 1000 characters. - The value of n is between 1 and 10. - The function should handle edge cases such as text with less than n words seamlessly. Examples: ```python # Example 1: text = \\"The quick brown fox\\" n = 2 print(generate_ngrams(text, n)) # Expected Output: [(\'the\', \'quick\'), (\'quick\', \'brown\'), (\'brown\', \'fox\')] # Example 2: text = \\"Hello\\" n = 2 print(generate_ngrams(text, n)) # Expected Output: [] # Example 3: text = \\"To be or not to be, that is the question.\\" n = 3 print(generate_ngrams(text, n)) # Expected Output: [(\'to\', \'be\', \'or\'), (\'be\', \'or\', \'not\'), (\'or\', \'not\', \'to\'), (\'not\', \'to\', \'be\'), (\'to\', \'be\', \'that\'), (\'be\', \'that\', \'is\'), (\'that\', \'is\', \'the\'), (\'is\', \'the\', \'question\')] ``` **Explanation**: - In Example 1, for the input text \\"The quick brown fox\\" and n=2, the function generates bigrams [(\'the\', \'quick\'), (\'quick\', \'brown\'), (\'brown\', \'fox\')]. - In Example 2, for the input text \\"Hello\\" and n=2, there are not enough words to form a 2-gram, so the function returns an empty list. - In Example 3, for the input text \\"To be or not to be, that is the question.\\" and n=3, the function generates trigrams, ignoring punctuation and converting text to lowercase. Note: Make sure to import the necessary modules and handle the preprocessing steps correctly.","solution":"import re from typing import List, Tuple def generate_ngrams(text: str, n: int) -> List[Tuple[str]]: # Preprocessing: convert text to lowercase and remove punctuation text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Generate n-grams ngrams = [] for i in range(len(words) - n + 1): ngram = tuple(words[i:i+n]) ngrams.append(ngram) return ngrams"},{"question":"# Longest Balanced Substring You are asked to implement an algorithm to find the length of the longest balanced substring in a given string, where a balanced string is defined as a string having equal numbers of \'A\' and \'B\' characters, in any order. Function Signature: ```python def longest_balanced_substring(s: str) -> int: \'\'\' :param s: a string composed of characters \'A\' and \'B\'. :return: an integer representing the length of the longest balanced substring. \'\'\' ``` Input: * `s` (1 <= len(s) <= 10^6): A string composed exclusively of characters \'A\' and \'B\'. Output: * An integer representing the length of the longest balanced substring. Constraints: - The function should efficiently handle strings up to 10^6 characters in length. - Only characters \'A\' and \'B\' are present in the string. Example: ```python # Example 1: # Input: s = \\"ABBA\\" # Output: # 4 (The entire string is balanced) # Example 2: # Input: s = \\"AABBABBA\\" # Output: # 8 (The entire string is balanced) # Example 3: # Input: s = \\"AAABBB\\" # Output: # 6 (The entire string is balanced) # Example 4: # Input: s = \\"AAABBBAA\\" # Output: # 6 (The substring \\"AAABBB\\" or \\"ABBBAA\\" is balanced) # Example 5: # Input: s = \\"A\\" # Output: # 0 (No balanced substring exists) # Example 6: # Input: s = \\"ABBAB\\" # Output: # 4 (The substring \\"ABBA\\" is balanced) ``` Implementation Notes: 1. Iterate through the string while keeping track of the count difference between \'A\' and \'B\'. 2. Use a dictionary to store the first occurrence of each count difference. 3. If the same count difference occurs again, it means there is a balanced substring between the two occurrences. 4. Calculate the length of the balanced substring and update the maximum length found. 5. Return the length of the longest balanced substring found. Implement the function `longest_balanced_substring` according to the above requirements.","solution":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring in a given string where a balanced string contains equal numbers of \'A\' and \'B\' characters. # Map to keep track of the first occurrence of each difference diff_map = {0: -1} max_length = 0 count = 0 for i, char in enumerate(s): if char == \'A\': count += 1 else: count -= 1 if count in diff_map: max_length = max(max_length, i - diff_map[count]) else: diff_map[count] = i return max_length"},{"question":"# Question Write a function named `order_discount` that calculates the total price after discount for a list of items in a shopping order. The function should take three parameters: 1. `items` (a list of tuples, where each tuple contains two elements: (item_price: float, item_quantity: int)), 2. `discount` (a float between 0 and 1 representing the percentage discount to be applied to the total price, where 0 means no discount and 1 means 100% discount), 3. `threshold` (a float representing the minimum total price before discount to qualify for the discount). The function should perform the following steps: 1. Calculate the total price of the order by summing the product of each item\'s price and quantity. 2. If the total price is greater than or equal to the `threshold`, apply the discount. 3. Return the final total price after applying the discount, rounded to 2 decimal places. If the `items` list is empty, the function should return 0.0. If `discount` is less than 0 or greater than 1, or if `threshold` is negative, the function should raise a `ValueError` with a descriptive message. # Required Function Signature ```python def order_discount(items: [(float, int)], discount: float, threshold: float) -> float: pass ``` # Examples ```python >>> order_discount([(20.0, 2), (15.5, 1)], 0.1, 50.0) 49.95 >>> order_discount([(10.0, 5), (5.0, 2)], 0.2, 40.0) 39.60 >>> order_discount([(12.0, 3)], 0.05, 30.0) 34.20 >>> order_discount([], 0.1, 50.0) 0.0 >>> order_discount([(10.0, 2)], 0.2, -10.0) Traceback (most recent call last): ... ValueError: Threshold must be non-negative >>> order_discount([(10.0, 2)], -0.1, 10.0) Traceback (most recent call last): ... ValueError: Discount must be between 0 and 1 >>> order_discount([(10.0, 2)], 1.1, 10.0) Traceback (most recent call last): ... ValueError: Discount must be between 0 and 1 ``` # Notes * Assume all item prices and quantities are non-negative. * Ensure that all edge cases are handled appropriately. * If the total price after discount is a whole number, it should still be returned with two decimal points (e.g., 50.50 instead of 50.5).","solution":"def order_discount(items, discount, threshold): Calculate the total price after discount for a list of items in a shopping order. Args: - items (list of tuples): Each tuple contains (item_price: float, item_quantity: int) - discount (float): A float between 0 and 1 representing the percentage discount. - threshold (float): The minimum total price before discount to qualify for the discount. Returns: - float: The final total price after applying the discount, rounded to 2 decimal places. Raises: - ValueError: If discount is not between 0 and 1 or if threshold is negative. if discount < 0 or discount > 1: raise ValueError(\\"Discount must be between 0 and 1\\") if threshold < 0: raise ValueError(\\"Threshold must be non-negative\\") if not items: return 0.0 total_price = sum(item_price * item_quantity for item_price, item_quantity in items) if total_price >= threshold: total_price -= total_price * discount return round(total_price, 2)"},{"question":"# Problem Statement: You are given an undirected graph represented as an adjacency matrix. The tasks are to implement a function `has_cycle` that determines if the graph contains any cycle. To achieve this, you need to apply Depth First Search (DFS) to detect any back edges that indicate a cycle. A back edge is an edge that connects a vertex to an ancestor in the DFS tree. # Function Signature: ```python def has_cycle(graph: List[List[int]]) -> bool: ``` # Input: * `graph` (1 <= len(graph) <= 100): A 2D list representing the adjacency matrix of the graph. The matrix is `n x n`, where `n` is the number of vertices. * `graph[i][j] == 1` indicates there is an edge between vertex `i` and vertex `j`. * `graph[i][j] == 0` indicates there is no edge between vertex `i` and vertex `j`. # Output: * Returns `True` if the graph contains a cycle, otherwise `False`. # Constraints: * The graph is undirected. * The adjacency matrix is symmetric, i.e., `graph[i][j] == graph[j][i]`. * The graph may be disconnected. # Examples: ```python 1. has_cycle([ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 0] ]) # Returns True Explanation: The graph has a cycle (nodes 1-2-3). 2. has_cycle([ [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0] ]) # Returns False Explanation: The graph has no cycles. 3. has_cycle([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) # Returns False Explanation: The graph is completely disconnected and has no edges. ``` # Performance Requirements: * The solution should effectively handle graphs with up to 100 vertices. * Optimal time complexity: O(n^2), where n is the number of vertices. * Use depth-first search (DFS) to detect cycles.","solution":"from typing import List def has_cycle(graph: List[List[int]]) -> bool: Determines if the given undirected graph represented as an adjacency matrix contains a cycle. :param graph: A 2D list representing the adjacency matrix of the graph :return: True if the graph contains a cycle, otherwise False def dfs(v, parent): visited[v] = True for u in range(len(graph)): if graph[v][u] == 1: # There\'s an edge between `v` and `u` if not visited[u]: if dfs(u, v): return True elif u != parent: return True return False n = len(graph) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"Array Pair Sum to Target You are given an algorithm that identifies pairs of integers within an array that sum up to a specific target value. The solution should be efficient and avoid duplicate pairs. # Task Implement a function `find_pairs_with_sum` that takes an array of integers and a target integer, then returns all unique pairs of integers (as tuples) that sum up to the target value. Each pair should be represented in ascending order. Input - `nums` (list of int): Array of integers. - `target` (int): Target sum value. Output - A list of unique tuples, each containing two integers that sum up to the target value. Each tuple should be sorted in ascending order. - The list should be sorted in ascending order based on the first element of each tuple. Example ```python nums = [1, 2, 3, 4, 3, 5] target = 6 print(find_pairs_with_sum(nums, target)) # Output: [(1, 5), (2, 4), (3, 3)] ``` Constraints - Length of `nums`: (1 leq text{len(nums)} leq 10^4) - Values in `nums`: (-10^4 leq text{num} leq 10^4) - `target`: (-2 times 10^4 leq text{target} leq 2 times 10^4)","solution":"def find_pairs_with_sum(nums, target): Finds all unique pairs of integers within the list `nums` that sum up to the `target` value. Args: nums (list of int): Array of integers. target (int): Target sum value. Returns: list of tuple: A list of unique pairs of integers that sum up to the target value. nums.sort() pairs = set() seen = set() for num in nums: compliment = target - num if compliment in seen: pairs.add((min(num, compliment), max(num, compliment))) seen.add(num) return sorted(pairs)"},{"question":"# Fibonacci Sequence with Memory Optimization The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. The sequence can be defined by the recurrence relation: [ F(0) = 0 ] [ F(1) = 1 ] [ F(n) = F(n-1) + F(n-2) text{ for } n geq 2 ] Your task is to write a Python function that computes the first `n` Fibonacci numbers using a memory-optimized approach that consumes only constant space. Function Signature ```python def optimized_fibonacci_sequence(n: int) -> list[int]: pass ``` Requirements: 1. The function should return the Fibonacci sequence in a list format, up to the nth number. 2. Your implementation should use a memory-efficient technique by avoiding the storage of the entire sequence at once. 3. Handle invalid inputs by raising a ValueError with a clear error message. Constraints: * `0 <= n <= 1000` (Be cautious of time and space complexity) # Example: ```python >>> optimized_fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> optimized_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> optimized_fibonacci_sequence(-1) Traceback (most recent call last): ValueError: Input must be a non-negative integer. ``` Notes: - Ensure the function handles edge cases and invalid inputs as described. - Aim for optimizing both time and space complexity wherever possible. - Testing your function with a range of values up to the upper bound is recommended to ensure efficiency. By adhering to these guidelines, the newly created question fits seamlessly with the original set. It maintains a consistent style, complexity, and scope while introducing a distinct yet related challenge.","solution":"def optimized_fibonacci_sequence(n: int) -> list[int]: Computes the first n Fibonacci numbers using a memory-optimized approach. Parameters: n (int): The number of Fibonacci numbers to generate Returns: list[int]: A list containing the first n Fibonacci numbers Raises: ValueError: If the input is not a non-negative integer if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return [] if n == 1: return [0] result = [0, 1] a, b = 0, 1 for _ in range(2, n): a, b = b, a + b result.append(b) return result"},{"question":"# Coding Assessment Question **Problem Statement**: You are given a list of non-negative integers representing a binary number. Each integer in the list is either 0 or 1. Your task is to determine the decimal equivalent of the binary number formed by the integers in the list. **Function Signature**: ```python def binary_to_decimal(binary_digits: List[int]) -> int: pass ``` **Description**: - Write a function `binary_to_decimal` that takes in a list of non-negative integers (0s and 1s), where each integer represents a digit in a binary number, and returns the decimal equivalent of that binary number. **Input**: - A list of integers `binary_digits` where each integer is either a 0 or a 1 and the list represents a binary number. **Output**: - A single integer which is the decimal representation of the binary number formed by the digits in the list. **Constraints**: - The list `binary_digits` could be empty, representing the binary number 0. - The length of the list will be at most 1000. **Performance Requirements**: - The solution should efficiently handle the conversion from binary to decimal. - Ensure the solution can handle the upper limit constraint on the length of the list. **Example**: ```python assert binary_to_decimal([1, 0, 1, 1]) == 11 assert binary_to_decimal([0]) == 0 assert binary_to_decimal([1, 1, 1, 1]) == 15 assert binary_to_decimal([1, 0, 0, 0, 0, 0]) == 32 ``` **Explanation**: For the list `[1, 0, 1, 1]`, it represents the binary number `1011` which is `11` in decimal. For the list `[0]`, it represents the binary number `0` which is `0` in decimal. For the list `[1, 1, 1, 1]`, it represents the binary number `1111` which is `15` in decimal. For the list `[1, 0, 0, 0, 0, 0]`, it represents the binary number `100000` which is `32` in decimal. **Edge Cases to Consider**: - An empty list should be considered as the binary number `0`. - Lists containing all zeros should correctly return `0`. - Ensure large lists (up to 1000 elements) are handled efficiently. - Consider potential leading zeros and verify the correctness of the conversion.","solution":"from typing import List def binary_to_decimal(binary_digits: List[int]) -> int: Converts a list of binary digits to its decimal equivalent. Args: binary_digits (List[int]): List of binary digits (0s and 1s). Returns: int: Decimal equivalent of the binary number. decimal_value = 0 for digit in binary_digits: decimal_value = decimal_value * 2 + digit return decimal_value"},{"question":"# Question: Implement a Custom Sorting Function for a Given Data Structure You are required to implement a custom sorting function for a list of dictionaries. Each dictionary represents a student with attributes \'name\' (string), \'age\' (integer), and \'grade\' (float). The sorting function should first sort by \'grade\' in descending order, and if there are ties, it should then sort by \'age\' in ascending order. If there are still ties, it should finally sort by \'name\' in alphabetical order. Requirements 1. **Function Name**: custom_sort_students 2. **Input**: A list of dictionaries, where each dictionary represents a student with \'name\', \'age\', and \'grade\'. 3. **Output**: A list of dictionaries sorted based on the criteria mentioned. Constraints 1. The list may contain any number of students, potentially zero. 2. The \'name\' is a non-empty string, \'age\' is a non-negative integer, and \'grade\' is a float between 0.0 and 100.0. Example ```python >>> students = [ ... {\'name\': \'Alice\', \'age\': 24, \'grade\': 88.5}, ... {\'name\': \'Bob\', \'age\': 22, \'grade\': 91.0}, ... {\'name\': \'Charlie\', \'age\': 24, \'grade\': 88.5}, ... {\'name\': \'David\', \'age\': 25, \'grade\': 85.4} ... ] >>> custom_sort_students(students) [ {\'name\': \'Bob\', \'age\': 22, \'grade\': 91.0}, {\'name\': \'Alice\', \'age\': 24, \'grade\': 88.5}, {\'name\': \'Charlie\', \'age\': 24, \'grade\': 88.5}, {\'name\': \'David\', \'age\': 25, \'grade\': 85.4} ] ``` Guidelines - Use Python\'s built-in sorting functionalities. - Ensure the function handles ties properly as described. - The function should not modify the original list; instead, it should return a new list.","solution":"def custom_sort_students(students): Sorts a list of student dictionaries by grade (descending), age (ascending), and then name (alphabetically) if there are ties. Args: students (list): List of dictionaries, each containing \'name\', \'age\', and \'grade\'. Returns: list: Sorted list of student dictionaries. return sorted(students, key=lambda x: (-x[\'grade\'], x[\'age\'], x[\'name\']))"},{"question":"# Question: Multi-Source Shortest Path Algorithm You are tasked with implementing a multi-source shortest path algorithm on an unweighted graph. This algorithm should be able to compute the shortest path from multiple origins to every other vertex in the graph. Your implementation should support the following functions: 1. **Add Edge**: Add an undirected edge between two nodes. 2. **Set Sources**: Set multiple source nodes for the shortest path computation. 3. **Compute Shortest Paths**: Compute and retrieve the shortest paths from all source nodes to every other node. Function Specifications: 1. **Add Edge**: * Function Name: `add_edge` * Input: Two nodes `u` and `v`. * Output: None. 2. **Set Sources**: * Function Name: `set_sources` * Input: A list of source nodes `[s1, s2, ...]`. * Output: None. 3. **Compute Shortest Paths**: * Function Name: `compute_shortest_paths` * Output: A dictionary where the keys are the nodes, and the values are the shortest distances to the nearest source node. Constraints: - Assume the input graph is unweighted and undirected. - The nodes are represented as integers. - If a node is unreachable from all sources, its distance should be `-1`. - Implement your solution using BFS (Breadth-First Search) to ensure the shortest path in an unweighted graph. - The number of nodes and edges will be within reasonable limits for a typical interview question (e.g., up to 1000 nodes). Example Usage: ```python # Initialize the graph graph = Graph() # Add edges graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 3) # Set multiple sources graph.set_sources([0, 3]) # Compute shortest paths shortest_paths = graph.compute_shortest_paths() print(shortest_paths) # Expected Output: {0: 0, 1: 1, 2: 1, 3: 0} (or a similar dictionary depending on source proximity) ``` Make sure to handle edge cases such as disconnected nodes and no sources provided. Ensure all provided and newly added methods align with standard algorithmic practices and data structure usage.","solution":"from collections import deque, defaultdict class Graph: def __init__(self): self.adj_list = defaultdict(list) self.sources = [] def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def set_sources(self, sources): self.sources = sources def compute_shortest_paths(self): if not self.sources: return {} distance = {node: -1 for node in self.adj_list} queue = deque([(source, 0) for source in self.sources]) while queue: current_node, dist = queue.popleft() if distance[current_node] == -1: distance[current_node] = dist for neighbor in self.adj_list[current_node]: if distance[neighbor] == -1: queue.append((neighbor, dist + 1)) return distance"},{"question":"# Context: Optimizing String Processing with Suffix Arrays Given a large dataset of words, your task is to efficiently process and perform queries on these words. Suffix arrays are an effective tool for a range of string-related problems, including substring search, longest common prefix calculations, and lexicographical comparisons. Using the principles of Suffix Arrays discussed above, implement a class that provides the following features: 1. **Suffix Array Construction**: Implement a method `build_suffix_array` that constructs the suffix array for the given word. 2. **LCP Array Calculation**: Implement a method `build_lcp_array` that calculates the longest common prefix (LCP) array based on the constructed suffix array. # Task Requirements - Implement `build_suffix_array` method: This should construct and return the suffix array of the given word. - Implement `build_lcp_array` method: This should construct and return the LCP array using the suffix array. Function Signatures: ```python class SuffixArrayProcessor: def __init__(self, word: str): self.word = word self.suffix_array = [] self.lcp_array = [] def build_suffix_array(self) -> List[int]: pass def build_lcp_array(self) -> List[int]: pass ``` Input/Output Formats: - **build_suffix_array**: - **Input**: No direct inputs as it\'s an instance method initializing on object creation. - **Output**: List of integers representing the suffix array with starting indices of suffixes in sorted order. - **build_lcp_array**: - **Input**: No direct inputs as it\'s an instance method. - **Output**: List of integers representing the LCP array indicating the length of the longest common prefix between consecutive suffixes in the suffix array. Constraints: - Suffix Array and LCP Array assume that the input word consists of lowercase English letters only. - The word length `n` should be such that 1 <= n <= 10^5. For instance: ```python # Example usage: processor = SuffixArrayProcessor(\\"banana\\") suffix_array = processor.build_suffix_array() # possible output: [5, 3, 1, 0, 4, 2] lcp_array = processor.build_lcp_array() # possible output: [1, 3, 0, 0, 2, 4] ```","solution":"from typing import List class SuffixArrayProcessor: def __init__(self, word: str): self.word = word self.suffix_array = [] self.lcp_array = [] def build_suffix_array(self) -> List[int]: n = len(self.word) suffixes = [(self.word[i:], i) for i in range(n)] suffixes.sort() self.suffix_array = [suffix[1] for suffix in suffixes] return self.suffix_array def build_lcp_array(self) -> List[int]: n = len(self.word) rank = [0] * n self.lcp_array = [0] * n for i, suffix_index in enumerate(self.suffix_array): rank[suffix_index] = i h = 0 for i in range(n): if rank[i] > 0: j = self.suffix_array[rank[i] - 1] while (i + h < n) and (j + h < n) and (self.word[i + h] == self.word[j + h]): h += 1 self.lcp_array[rank[i]] = h if h > 0: h -= 1 return self.lcp_array[1:]"},{"question":"# Coding Assessment Question **Title**: Subset Sum Problem Using Dynamic Programming **Objective**: Implement a function that determines if there exists a subset of a given set that sums up to a target value using dynamic programming. **Context**: Given a set of non-negative integers and a target sum, determine if there is a subset of the given set with a sum equal to the target value. **Function Signature**: ```python def can_partition_subset(nums: list[int], target: int) -> bool: pass ``` **Input/Output Format**: * **Input**: A list of integers (`nums`) which represent the set elements, and an integer (`target`) which is the desired subset sum. All integers are non-negative. * **Output**: A boolean value `True` if there exists a subset that sums up to the target, otherwise `False`. **Constraints**: * The input list `nums` will have at most 20 elements. * Each element in the list `nums` is non-negative and does not exceed 1000. * The target sum will be a non-negative integer. **Examples**: Example 1: ```python nums = [1, 2, 3, 7] target = 6 print(can_partition_subset(nums, target)) # Output: True ``` Example 2: ```python nums = [1, 2, 7, 1, 5] target = 10 print(can_partition_subset(nums, target)) # Output: True ``` Example 3: ```python nums = [1, 3, 4, 8] target = 6 print(can_partition_subset(nums, target)) # Output: False ``` **Hints**: 1. Use a dynamic programming approach to solve the subset sum problem. 2. Create a DP table where the state `dp[i][j]` represents whether a subset of the first `i` elements has a sum equal to `j`. 3. Initialize the DP table and iterate through the elements to update the subset sum possibilities systematically. 4. The solution involves both including and excluding each element and evaluating the remaining possible sums. **Implementation Note**: Use the provided approach as a systematic way to evaluate the subset sums, ensuring to manage states efficiently within the DP table. This problem tests your understanding of dynamic programming and subset sum problems.","solution":"def can_partition_subset(nums: list[int], target: int) -> bool: n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: There\'s always a subset with sum 0 (empty subset) for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: # Including or excluding the current number dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: # Excluding the current number dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"# Problem Scenario You have been hired to develop a data analytics module to process large datasets of numerical values. One of the key operations needed is a \\"sliding window\\" average calculation, which will be used to smooth out short-term fluctuations in the dataset values. # Task: Implement a class `SlidingWindowAverage` that can calculate the average of elements within a sliding window of a specified size as new data points are added. # Key Requirements: 1. Initialize the sliding window with a given size. 2. Add new data points to the sliding window. 3. Compute the average of the values within the current window. # Specifications: 1. **Class**: `SlidingWindowAverage` 2. **Methods**: * `__init__(self, size: int)`: Initializes the sliding window with the specified size. * `add(self, value: float)`: Adds a new value to the sliding window. * `average(self) -> float`: Returns the average of the current values in the sliding window. 3. **Input/Output**: * The `__init__` method initializes the window size. * The `add` method takes a single float `value` and adds it to the sliding window. * The `average` method returns a float representing the average of the values currently in the window. If the window has not yet reached its full size, compute the average of the values present. # Constraints: * `size` must be a positive integer. * `value` must be a float. * If no values are added, the `average` method should return `0.0`. # Example: ```python # Example Usage swa = SlidingWindowAverage(3) swa.add(1.0) # window = [1.0] print(swa.average()) # returns 1.0 swa.add(2.0) # window = [1.0, 2.0] print(swa.average()) # returns 1.5 swa.add(3.0) # window = [1.0, 2.0, 3.0] print(swa.average()) # returns 2.0 swa.add(4.0) # window = [2.0, 3.0, 4.0] print(swa.average()) # returns 3.0 ``` # Notes: * Ensure that data older than the current window size is discarded. * Manage the window efficiently to ensure that the average calculation is optimized for large data streams. Consider using a deque or a similar data structure for maintaining the current values in the window.","solution":"from collections import deque class SlidingWindowAverage: def __init__(self, size: int): Initializes the sliding window with the specified size. self.size = size self.window = deque() self.sum = 0.0 def add(self, value: float): Adds a new value to the sliding window. self.window.append(value) self.sum += value if len(self.window) > self.size: self.sum -= self.window.popleft() def average(self) -> float: Returns the average of the current values in the sliding window. if not self.window: return 0.0 return self.sum / len(self.window)"},{"question":"# Problem Statement You are tasked to create a function that determines the length of the shortest path between two given nodes in an undirected, unweighted graph. Function Signature ```python def shortest_path_length(graph: dict, start: int, end: int) -> int: pass ``` # Input: * A dictionary `graph` where keys are node identifiers (integers) and values are lists of integers representing the nodes directly connected to the key node. * Two integers `start` and `end` representing the starting and ending nodes for which the shortest path length needs to be calculated. # Output: * An integer representing the length of the shortest path from `start` to `end`. If no path exists, return -1. # Constraints: 1. The graph does not contain any negative weights or cycles. 2. All `graph` keys and values are integers representing valid node identifiers. 3. `start` and `end` will be integers corresponding to nodes in the graph. 4. There will be at least 2 nodes in the graph. # Examples: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2] } assert shortest_path_length(graph, 0, 3) == 2 assert shortest_path_length(graph, 0, 1) == 1 assert shortest_path_length(graph, 3, 0) == 2 assert shortest_path_length(graph, 1, 2) == 2 graph = { 0: [1], 1: [0, 2], 2: [1] } assert shortest_path_length(graph, 0, 2) == 2 assert shortest_path_length(graph, 2, 0) == 2 assert shortest_path_length(graph, 0, 3) == -1 # Node 3 does not exist in the graph ``` # Explanation Given a graph in the form of an adjacency list, you need to find the shortest path from a given start node to an end node. Use BFS (Breadth-First Search) for finding the shortest path in an unweighted graph. If no path exists, return -1.","solution":"from collections import deque def shortest_path_length(graph, start, end): Returns the length of the shortest path from start to end in an undirected, unweighted graph represented by an adjacency list. if start == end: return 0 visited = set() queue = deque([(start, 0)]) # (current_node, current_distance) while queue: current_node, current_distance = queue.popleft() if current_node == end: return current_distance for neighbor in graph.get(current_node, []): if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) return -1 # If there is no path from start to end"},{"question":"# Minimum Spanning Tree (MST) Detection using Kruskal\'s Algorithm **Background**: A telecommunications company is planning to lay out new fiber optic cables to connect multiple cities. To minimize the cost of the project, the company aims to find the minimum spanning tree (MST) of the city\'s network graph. You are required to implement Kruskal\'s algorithm to achieve this. **Objective**: Using provided data structures, complete the function to find the MST of a given undirected, weighted graph based on Kruskal\'s algorithm. This will help the company identify the optimal connections between cities. **Task**: 1. Implement the `find_parent` and `union` functions to help manage the disjoint sets. 2. Write a function `kruskal_mst(edges: list[tuple[int, int, int]], num_vertices: int) -> list[tuple[int, int, int]]` that: - Accepts a list of edges (each edge represented as a tuple with two vertices and a weight) and the total number of vertices. - Returns a list of edges representing the MST. **Function Signature**: ```python def kruskal_mst(edges: list[tuple[int, int, int]], num_vertices: int) -> list[tuple[int, int, int]]: ``` **Input**: - `edges`: A list of edges, where each edge is represented as a tuple `(u, v, w)` indicating an edge between vertices `u` and `v` with a weight `w`. Example: `[(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]` - `num_vertices`: An integer representing the total number of vertices in the graph. **Output**: - A list of tuples, where each tuple represents an edge that is part of the MST. The tuples should be of the form `(u, v, w)`. **Constraints**: - The number of vertices `v` is such that `1 <= v <= 100`. - The number of edges `e` is such that `1 <= e <= 1000`. - The weight `w` of each edge is a positive integer. **Example**: ```python edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] num_vertices = 4 result = kruskal_mst(edges, num_vertices) print(result) # Output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] (or similar, as long as it is a valid MST) ``` You can utilize the given pseudocode or algorithms to help construct and implement Kruskal\'s MST algorithm.","solution":"def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(edges, num_vertices): edges = sorted(edges, key=lambda edge: edge[2]) parent = [] rank = [] for node in range(num_vertices): parent.append(node) rank.append(0) mst = [] for edge in edges: u, v, w = edge root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: mst.append(edge) union(parent, rank, root_u, root_v) return mst"},{"question":"# Scenario: You are tasked with implementing a simple math calculator that can evaluate basic arithmetic expressions. The expression will be provided as a string and will include only non-negative integers and the four basic arithmetic operators: addition (+), subtraction (-), multiplication (*), and division (/). Ensure to follow the correct order of operations (PEMDAS/BODMAS rules). # Task: Write a function `evaluate_expression` that takes a string representing a mathematical expression and returns the evaluated result as an integer. Assume that the input expression is always valid and contains only non-negative integers. # Expected Function: ```python def evaluate_expression(expression: str) -> int: ``` # Input Format: * A string `expression` of length `n` where `1 <= n <= 10^4`. # Output Format: * An integer representing the result of the evaluated expression. # Constraints: * The expression will only contain non-negative integers and the operators: +, -, *, /. * Division should be performed as integer division (i.e., truncate the decimal part). * The evaluation should respect the order of operations. * The input expression will be valid (no need for error handling for invalid input). # Example: ```python >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 >>> evaluate_expression(\\"10+2*6-9/3\\") 19 ``` # Notes: 1. Your solution should correctly handle operator precedence. 2. Ensure your implementation is efficient and handles expressions of the maximum length promptly. 3. Whitespace in the input string should be properly managed and ignored during evaluation.","solution":"def evaluate_expression(expression: str) -> int: def apply_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left // right) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] in \'0123456789\': num = 0 while i < len(expression) and expression[i] in \'0123456789\': num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] in \'+-*/\': while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, values) return values[-1]"},{"question":"# Array Rotation Challenge Given an array of integers and an integer `k`, write a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates the array to the right by `k` steps. This means that the element at index `i` will be moved to index `(i + k) % len(arr)`. Input - A list of integers `arr` where `0 ≤ len(arr) ≤ 10^5`. - An integer `k` where `0 ≤ k ≤ 10^5`. Output - A list of integers, which is the rotated version of the input array. Constraints - The integer `k` will always be non-negative. - The rotation should be performed in-place with O(1) extra space complexity if possible, or you should provide an efficient solution. Example ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array([1, 2, 3], 0) == [1, 2, 3] assert rotate_array([], 1) == [] ``` # Context Array rotation is a common operation in many algorithms. In this specific case, you need to implement an efficient method to rearrange the given array based on the rotation specified by `k`. This problem helps in understanding the concept of array manipulation and cyclic rotations, which are often encountered in computer science problems. # Notes Consider edge cases such as: - When `k` is zero, the array remains unchanged. - When `k` is greater than the array\'s length. - An empty array should always return an empty array regardless of `k`. Optimize your solution to handle large inputs efficiently within the given constraints.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0: return arr # If the array is empty, return it as it is # Normalize k to avoid unnecessary full rotations k %= n return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You are given an array of integers `arr` of size `n`. Write a function `find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]` that finds all unique pairs of integers in the array that sum up to a given `target` value. A pair `(a, b)` is considered unique if there is no other pair `(c, d)` such that `a == c` and `b == d` or `a == d` and `b == c` in the result set. # Input - `arr`: A list of integers of size `n` (1 <= n <= 10^5) - `target`: An integer value that the pairs of integers should sum up to. # Output - A list of tuples representing unique pairs of integers that sum up to `target`. # Constraints 1. Each pair of integers should be listed in ascending order within the tuple and the output list should be sorted based on the first element of the tuples. 2. A pair `(a, b)` should appear only once and in ascending order, i.e., `a <= b`. 3. The function should have a time complexity of O(n) and space complexity of O(n). # Example ```python # Example 1 arr = [1, 2, 3, 4, 3, 5] target = 6 # Expected Output: [(1, 5), (2, 4), (3, 3)] # Example 2 arr = [1, 1, 2, 2, 3, 3] target = 4 # Expected Output: [(1, 3), (2, 2)] ``` # Guidelines 1. **Function Signature**: Implement the function with the following signature: `def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]:` 2. **Edge Cases**: Handle cases where no pairs can be found or where all elements sum to the target with different pairs. 3. **Optimization**: Use a hash set to track complements and ensure unique pairs are collected efficiently. # Test Cases Write comprehensive test cases to cover: 1. Standard scenarios with a mix of elements. 2. Edge scenarios (no pairs summing to target, duplicates without new unique pairs). 3. Large arrays to ensure performance constraints are met.","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return sorted(list(pairs))"},{"question":"# Topological Sort of a Directed Acyclic Graph (DAG) You are given a directed acyclic graph (DAG) with `n` vertices. Implement the following functionalities: 1. Add directed edges to the graph. 2. Perform a topological sort on the graph. # Function Specifications Your task is to implement a class `DAGraph` which contains the following methods: - `__init__(self, n: int)`: Initializes the graph with `n` vertices (0 to n-1). - `add_edge(self, from_vertex: int, to_vertex: int)`: Adds a directed edge from `from_vertex` to `to_vertex`. - `topological_sort(self) -> List[int]`: Performs a topological sort of the vertices and returns the sorted list of vertices. If the graph contains a cycle, raise a `ValueError`. # Constraints * The indices of the vertices will be within the range [0, n-1] where n is the number of vertices. * The graph will have at least 1 vertex and less than 10000 vertices. * There will not be any duplicate edges. * An edge direction from u to v does not imply an edge from v to u. # Example ```python # Creating a graph with 6 vertices g = DAGraph(6) # Adding edges g.add_edge(5, 2) g.add_edge(5, 0) g.add_edge(4, 0) g.add_edge(4, 1) g.add_edge(2, 3) g.add_edge(3, 1) # Performing topological sort assert g.topological_sort() == [5, 4, 2, 3, 1, 0] # example valid output ``` # Notes Please ensure your implementation efficiently handles the topological sort and properly detects cycles to raise a ValueError where necessary.","solution":"from collections import defaultdict, deque class DAGraph: def __init__(self, n): self.graph = defaultdict(list) self.n = n def add_edge(self, from_vertex, to_vertex): self.graph[from_vertex].append(to_vertex) def topological_sort(self): in_degree = [0] * self.n for node in self.graph: for adjacent in self.graph[node]: in_degree[adjacent] += 1 queue = deque([i for i in range(self.n) if in_degree[i] == 0]) sorted_list = [] while queue: vertex = queue.popleft() sorted_list.append(vertex) for neighbor in self.graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_list) == self.n: return sorted_list else: raise ValueError(\\"The graph contains a cycle.\\") # Example usage # g = DAGraph(6) # g.add_edge(5, 2) # g.add_edge(5, 0) # g.add_edge(4, 0) # g.add_edge(4, 1) # g.add_edge(2, 3) # g.add_edge(3, 1) # print(g.topological_sort()) # Expected valid output: [5, 4, 2, 3, 1, 0]"},{"question":"# Problem: Sum of Factorials of Digits You are tasked with finding all numbers that can be written as the sum of the factorials of their digits. More specifically, the problem is to find all numbers between 10 and 100,000 (inclusive) that can be expressed this way and then calculate their sum. Input: No direct input is required; the ranges are predefined as between 10 and 100,000. Output: Your function should return a single integer representing the sum of all such numbers. Example: For instance, the number 145 is: ``` 145 = 1! + 4! + 5! ``` Since this holds true, 145 should be included in our calculations. Write a function `sum_factorial_digits` that solves the problem. ```python def sum_factorial_digits() -> int: This function calculates the sum of all numbers that can be expressed as the sum of the factorials of their digits within the range [10, 100000]. Returns: int: The sum of all such numbers. from math import factorial DIGITS_FACTORIAL = {str(digit): factorial(digit) for digit in range(10)} def digits_factorial_sum(number: int) -> int: return sum(DIGITS_FACTORIAL[digit] for digit in str(number)) total_sum = sum( number for number in range(10, 100001) if number == digits_factorial_sum(number) ) return total_sum # Example of usage if __name__ == \\"__main__\\": print(sum_factorial_digits()) ``` # Constraints: - The numbers to be checked lie between 10 and 100,000. - You must use precomputed factorials of digits for efficiency. - Your solution should run within a reasonable time frame for the given range.","solution":"def sum_factorial_digits() -> int: This function calculates the sum of all numbers that can be expressed as the sum of the factorials of their digits within the range [10, 100000]. Returns: int: The sum of all such numbers. from math import factorial DIGITS_FACTORIAL = {str(digit): factorial(digit) for digit in range(10)} def digits_factorial_sum(number: int) -> int: return sum(DIGITS_FACTORIAL[digit] for digit in str(number)) total_sum = sum( number for number in range(10, 100001) if number == digits_factorial_sum(number) ) return total_sum"},{"question":"# Problem Statement You are tasked with implementing a function that determines the most frequent word in a given paragraph of text. A word is defined as a contiguous sequence of alphabetic characters. The function should return the word that appears most frequently. If multiple words have the same highest frequency, return the lexicographically smallest one. Words should be treated case-insensitively. # Function Signature ```python def most_frequent_word(paragraph: str) -> str: pass ``` # Input/Output Requirements * **Input**: A single argument: - `paragraph` (str): A string representing a paragraph of text, containing alphabetic characters (both uppercase and lowercase), spaces, and punctuation marks. * **Output**: - Returns the most frequent word in the paragraph. If there are ties, return the lexicographically smallest word among them. # Constraints - The paragraph string will have a length of at most 10^6 characters. - The paragraph will contain at least one word. # Performance Requirements - The function should have a time complexity of O(n) where n is the length of the paragraph. - The space complexity should not exceed O(k) where k is the number of unique words in the paragraph. # Scenario Imagine you are developing a text-analysis tool for summarizing the content of large documents. One of its features is identifying the most frequently used words to give users a quick overview of the main topics or themes in the text data. # Example ```python >>> most_frequent_word(\\"Hello, world! This is a test. Hello again.\\") \'hello\' >>> most_frequent_word(\\"Python is great! Python is awesome. I love Python.\\") \'python\' >>> most_frequent_word(\\"This is a simple example. Example is simple.\\") \'example\' ``` # Solution Requirements - Implement the `most_frequent_word` function following the above specifications. - Ensure the solution handles punctuation properly, treats words case-insensitively, and efficiently handles large input sizes. - Consider using a dictionary or collections.Counter to keep track of word frequencies. Pay attention to edge cases such as empty input or punctuation marks.","solution":"import re from collections import Counter def most_frequent_word(paragraph: str) -> str: # Convert paragraph to lowercase to make the search case insensitive paragraph = paragraph.lower() # Use regex to extract words, considering only alphabetic characters words = re.findall(r\'b[a-z]+b\', paragraph) # Count the frequency of each word word_count = Counter(words) # Find the word with the highest frequency most_frequent = min(word_count, key=lambda word: (-word_count[word], word)) return most_frequent"},{"question":"# Array Manipulation - Challenge You are tasked with implementing a series of array manipulation functions. These functions will simulate common operations on integer arrays and strings, allowing operations to be performed directly in an efficient manner. Functions to Implement: 1. `rotate_array(arr: List[int], k: int) -> List[int]` - **Input**: - `arr` (List[int]): A list of integers to be rotated. - `k` (int): The number of positions to rotate the array to the right. - **Output**: A rotated list of integers where elements have been shifted to the right `k` times. 2. `reverse_array(arr: List[int]) -> List[int]` - **Input**: - `arr` (List[int]): A list of integers to be reversed. - **Output**: A list of integers in reversed order. 3. `find_max_subarray(arr: List[int]) -> int` - **Input**: - `arr` (List[int]): A list of integers where we need to find the maximum sum of any contiguous subarray. - **Output**: An integer representing the maximum sum. 4. `rotate_string(s: str, k: int) -> str` - **Input**: - `s` (str): A string to be rotated. - `k` (int): The number of positions to rotate the string to the right. - **Output**: A rotated string where characters have been shifted to the right `k` times. 5. `is_substring(s1: str, s2: str) -> bool` - **Input**: - `s1` (str): The string to search within. - `s2` (str): The substring to search for. - **Output**: A boolean indicating whether `s2` is a substring of `s1`. Additional Constraints: * For `rotate_array` and `rotate_string`, the number of positions to rotate, `k`, will be non-negative and within the length of the array or string respectively. * For `find_max_subarray`, the array may contain negative numbers. Performance Requirements: * `rotate_array` and `rotate_string` should run in O(n) time where `n` is the length of the array or string. * `reverse_array` should run in O(n) time where `n` is the length of the array. * `find_max_subarray` should run in O(n) time using Kadane\'s algorithm. * `is_substring` should run in O(m + n) time where `m` is the length of `s1` and `n` is the length of `s2`. Examples: ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert reverse_array([1, 2, 3, 4]) == [4, 3, 2, 1] assert find_max_subarray([-2,1,-3,4,-1,2,1,-5,4]) == 6 assert rotate_string(\\"abcdef\\", 2) == \\"efabcd\\" assert is_substring(\\"hello world\\", \\"world\\") == True assert is_substring(\\"hello world\\", \\"worlds\\") == False ``` Implement these functions correctly to handle the given constraints and requirements.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates an array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n return arr[-k:] + arr[:-k] def reverse_array(arr: List[int]) -> List[int]: Reverses the elements of the array. return arr[::-1] def find_max_subarray(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def rotate_string(s: str, k: int) -> str: Rotates a string to the right by k steps. n = len(s) if n == 0: return s k = k % n return s[-k:] + s[:-k] def is_substring(s1: str, s2: str) -> bool: Checks if s2 is a substring of s1. return s2 in s1"},{"question":"# Coding Assessment Question Scenario Consider the challenge of validating passwords based on their complexity. A password is deemed complex if it satisfies several security requirements such as length, the inclusion of uppercase and lowercase letters, digits, and special characters. You need to write a function that checks if a given password meets these complexity requirements. Task Write a function `check_password_complexity` that validates a password according to the following rules: 1. The password must be at least 8 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set: `!@#%^&*()-_=+[]{}|;:\',<.>/?`. Function Signature ```python def check_password_complexity(password: str) -> bool: pass ``` Inputs - `password` (str): The password string to be validated. Output - (bool): `True` if the password meets all the complexity requirements, otherwise `False`. Constraints - The password string will have a length within the range of (1) to (100) characters. Example ```python >>> check_password_complexity(\\"Password123!\\") True >>> check_password_complexity(\\"pass\\") False >>> check_password_complexity(\\"Password!\\") False >>> check_password_complexity(\\"password123!\\") False >>> check_password_complexity(\\"PASSWORD123!\\") False ``` Implement this function and ensure it adheres to all specified complexity requirements accurately.","solution":"import re def check_password_complexity(password: str) -> bool: Validate the complexity of the given password. Args: password (str): The password string to be validated. Returns: bool: True if the password meets the complexity requirements, otherwise False. if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[0-9]\', password): return False if not re.search(r\'[!@#%^&*()-_=+[]{}|;:\'\\",<.>/?]\', password): return False return True"},{"question":"# Problem Statement Given a list of non-negative integers representing an elevation map where the width of each bar is 1, write a function that computes how much water it can trap after raining. You are required to use a two-pointer approach to solve this problem. # Function Signature ```python def trap_rain_water(height: List[int]) -> int: pass ``` # Input * `height`: A list of non-negative integers. # Output * An integer representing the total amount of trapped water. # Constraints * The length of the height list will be at least 1 and no more than 10^5. * Each element in the height list will be a non-negative integer and will not exceed 10^4. # Performance Requirements * Your algorithm should aim for a time complexity of O(n). # Example ```python height = [0,1,0,2,1,0,1,3,2,1,2,1] print(trap_rain_water(height)) # Expected Output: 6 height = [4,2,0,3,2,5] print(trap_rain_water(height)) # Expected Output: 9 ``` # Notes * Ensure the use of a two-pointer approach to achieve the target time complexity. * Handle edge cases where the elevation map does not trap any water, such as when the list is strictly increasing or decreasing.","solution":"from typing import List def trap_rain_water(height: List[int]) -> int: if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"# Problem Statement You are tasked with implementing a function that finds the roots of a quadratic equation. A quadratic equation is of the form: [ ax^2 + bx + c = 0 ] Where: - `a`, `b`, and `c` are coefficients provided as inputs. The roots of the quadratic equation can be found using the quadratic formula: [ x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ] # Requirements 1. **Function Name**: `find_quadratic_roots` 2. **Input**: - A single list `coefficients` containing three integers: `a`, `b`, and `c`. - Example: `[1, -3, 2]` 3. **Output**: - A single tuple of floats: (root1, root2) representing the two roots of the equation. - Example: `(2.0, 1.0)` # Constraints - The coefficient `a` is always non-zero. - If the discriminant (( b^2 - 4ac )) is negative, return the tuple `(\\"No Real Roots\\",)`. # Example ```python Input: [1, -3, 2] Output: (2.0, 1.0) Input: [1, 2, 1] Output: (-1.0, -1.0) Input: [1, 1, 1] Output: (\\"No Real Roots\\",) ``` # Your Task Write the function `find_quadratic_roots` that reads a list with the coefficients of a quadratic equation, calculates the roots using the quadratic formula, and returns the result in the expected format. If the roots are real, return a tuple with both roots; otherwise, return the \\"No Real Roots\\" tuple.","solution":"import math def find_quadratic_roots(coefficients): Returns the roots of the quadratic equation ax^2 + bx + c = 0. If the discriminant is negative, returns (\\"No Real Roots\\",). a, b, c = coefficients discriminant = b**2 - 4*a*c if discriminant < 0: return (\\"No Real Roots\\",) root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (root1, root2)"},{"question":"# Problem Statement You are tasked with enhancing the functionality of a binary search tree (BST) to support a new range-related query. Specifically, you need to implement a method for finding the lowest common ancestor (LCA) of two nodes in the BST. Tasks 1. **Implement `find_lca` function** Add a method `find_lca(self, node1: int, node2: int) -> int` to the BinarySearchTree class. This function should return the value of the lowest common ancestor of the two given nodes node1 and node2. The LCA of two nodes in a BST is defined as the lowest node in T that has both node1 and node2 as descendants (where we allow a node to be a descendant of itself). # Constraints - Both `node1` and `node2` are guaranteed to be present in the BST. - The BST is not necessarily balanced, but it is a proper BST with unique values. # Class Definition ```python class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current: Node, value: int) -> None: if value < current.value: if current.left is None: current.left = Node(value) else: self._insert(current.left, value) else: if current.right is None: current.right = Node(value) else: self._insert(current.right, value) def find_lca(self, node1: int, node2: int) -> int: pass ``` # Example ```python # Create a BST and insert values bst = BinarySearchTree() values = [20, 10, 30, 5, 15, 25, 35, 3, 7, 13, 17, 23, 27, 33, 37] for value in values: bst.insert(value) # Find LCA of node 5 and node 15 (expected LCA is 10) print(bst.find_lca(5, 15)) # Output: 10 # Find LCA of node 3 and node 7 (expected LCA is 5) print(bst.find_lca(3, 7)) # Output: 5 # Find LCA of node 13 and node 17 (expected LCA is 15) print(bst.find_lca(13, 17)) # Output: 15 # Find LCA of node 23 and node 35 (expected LCA is 30) print(bst.find_lca(23, 35)) # Output: 30 ``` # Analysis - The `find_lca` function needs to traverse the BST starting from the root. - If the current node\'s value is greater than both node1 and node2, the LCA lies in the left subtree. - If the current node\'s value is less than both node1 and node2, the LCA lies in the right subtree. - If the current node\'s value is between node1 and node2 or is equal to one of them, then the current node is the LCA.","solution":"class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current: Node, value: int) -> None: if value < current.value: if current.left is None: current.left = Node(value) else: self._insert(current.left, value) else: if current.right is None: current.right = Node(value) else: self._insert(current.right, value) def find_lca(self, node1: int, node2: int) -> int: Find the Lowest Common Ancestor (LCA) of two nodes in the BST. current = self.root while current: if node1 < current.value and node2 < current.value: current = current.left elif node1 > current.value and node2 > current.value: current = current.right else: return current.value"},{"question":"# Nested List Flattener You are given a nested list of integers where each element is either an integer or another nested list. Your goal is to flatten this list into a single list of integers in the same order. Problem Statement Implement a function `flatten_list(nested_list: list) -> list` that takes a nested list of integers and returns a flat list of integers. Input: * `nested_list`: A nested list of integers where each element is either an integer or another nested list. Output: * A single list of integers in the same order they appear in the `nested_list`. Constraints: * The depth of the nested list can be arbitrarily deep. * Each integer is in the range (-10^7 leq text{{integer}} leq 10^7). Example: ```python # Example 1 nested_list = [1, [2, [3, 4], 5], 6] assert flatten_list(nested_list) == [1, 2, 3, 4, 5, 6] # Example 2 nested_list = [[[1], 2], [3, [4, 5]], 6] assert flatten_list(nested_list) == [1, 2, 3, 4, 5, 6] # Example 3 nested_list = [1, [2, 3], [4, [5, [6]]]] assert flatten_list(nested_list) == [1, 2, 3, 4, 5, 6] # Example 4 nested_list = [1, [2, [3, [], [[]]], 4], 5] assert flatten_list(nested_list) == [1, 2, 3, 4, 5] ``` Implementation Details: 1. **flatten_list(nested_list: list) -> list**: * Implement a recursive function to handle arbitrarily nested lists. * Use a helper function if necessary to manage the recursion and flatten the list. * Ensure that the final list contains integers in the same order as they appear in the nested list. # Implementation: ```python def flatten_list(nested_list): def _flatten(nl): for item in nl: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(nested_list)) ```","solution":"def flatten_list(nested_list): def _flatten(nl): for item in nl: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(nested_list))"},{"question":"# Coding Assessment Question # Objective Implement a text processing function that identifies and extracts specific patterns from a large document while ensuring optimal performance and memory usage. # Scenario Your task is to build a feature for a document management system that helps users find specific information quickly. The system should be able to scan through documents and extract patterns such as dates, email addresses, and phone numbers. # Task Implement the function `extract_patterns_from_document` with the following requirements: 1. **Input**: * A string representing the document content. * A list of patterns to search for (each pattern will be a valid regular expression). 2. **Output**: * A dictionary where the keys are the provided patterns and the values are lists of all occurrences of each pattern in the document. If a pattern is not found, its value should be an empty list. 3. **Constraints**: * The function should handle large documents efficiently. * Ensure the search process is optimized and does not consume excessive memory. 4. **Performance Requirements**: * Minimize the use of regular expressions where they are not necessary. * The function should gracefully handle scenarios where the input document exceeds typical lengths. # Constraints: * The document string must not exceed 10 million characters. * The list of patterns is limited to 20 patterns. * Valid patterns will be provided using Python\'s regular expression syntax. # Function Signature ```python def extract_patterns_from_document(document: str, patterns: List[str]) -> Dict[str, List[str]]: ``` # Example ```python document = \\"Call me at +1-234-567-8900 or email me at example@example.com. Meeting on 01/23/2024.\\" patterns = [r\'bd{2}/d{2}/d{4}b\', r\'bw+@w+.w+b\', r\'+1-d{3}-d{3}-d{4}\'] result = extract_patterns_from_document(document, patterns) print(result) # Output: # { # r\'bd{2}/d{2}/d{4}b\': [\'01/23/2024\'], # r\'bw+@w+.w+b\': [\'example@example.com\'], # r\'+1-d{3}-d{3}-d{4}\': [\'+1-234-567-8900\'] # } ``` # Additional Task * Write a test script that verifies your function with at least three different sets of patterns and documents, ensuring it correctly identifies and extracts all specified patterns and efficiently handles large documents.","solution":"import re from typing import List, Dict def extract_patterns_from_document(document: str, patterns: List[str]) -> Dict[str, List[str]]: Extracts all occurrences of each pattern in the document. Args: document (str): The document content as a string. patterns (List[str]): A list of regex patterns to search for. Returns: Dict[str, List[str]]: A dictionary where keys are patterns and values are lists of all occurrences. results = {pattern: [] for pattern in patterns} for pattern in patterns: compiled_pattern = re.compile(pattern) results[pattern] = compiled_pattern.findall(document) return results"},{"question":"# Question Objective Create a function called `normalize_string` that transforms the input string into a \\"normalized\\" string with the following rules: 1. Convert the entire string to lowercase. 2. Remove all characters that are not alphabetic (a-z). 3. Replace spaces with underscores. Scenario String normalization is often required in data cleaning and preparation processes. For example, preparing text data for natural language processing tasks demands consistent data format. Function Signature ```python def normalize_string(s: str) -> str: ``` # Input - `s`: A string containing alphanumeric characters, punctuation marks, and spaces (length up to (10^5)). # Output - Return a normalized string according to the specified rules. # Constraints - The input string can contain any combination of uppercase and lowercase alphabetic characters, numbers, punctuation marks, and spaces. - The length of the string can be up to (10^5) characters. # Examples ```python >>> normalize_string(\\"Hello, World! Welcome to 2023.\\") \'hello_world_welcome_to\' >>> normalize_string(\\"Normalize THIS string, please!\\") \'normalize_this_string_please\' ``` # Detailed Breakdown 1. **Convert to Lowercase**: Use appropriate string methods to change all characters to lowercase. 2. **Remove Non-Alphabetic Characters**: Strip out any characters that are not a-z. 3. **Replace Spaces**: Convert all spaces to underscores to make the input string URL-friendly or suitable for some other specific use cases. Implement the function with efficient string operations suitable for the input size constraints.","solution":"import re def normalize_string(s: str) -> str: Transforms the input string into a normalized string: 1. Converts the entire string to lowercase. 2. Removes all characters that are not alphabetic (a-z). 3. Replaces spaces with underscores. # Convert to lowercase s = s.lower() # Replace non-alphabetic characters with spaces to handle them uniformly s = re.sub(r\'[^a-z ]\', \' \', s) # Replace multiple spaces with a single space s = re.sub(r\'s+\', \' \', s) # Replace spaces with underscores s = s.strip().replace(\' \', \'_\') return s"},{"question":"# Problem Statement Jenny, a concert organizer, needs help with an arrangement problem. She has a guest list containing names and wishes to organize the seating such that no two guests with the same starting letter of their names sit next to each other. Given the guest list, you are to determine if this arrangement is possible and, if so, return one such arrangement. Implement a function `arrange_seating(guests: List[str]) -> List[str]` that arranges the guest list according to the above criteria. Input: * `guests` (1 <= len(guests) <= 10^5): A list of strings representing guest names. Each name consists of alphabetical characters only and has at least one character. Output: * Returns a list of strings representing an arrangement of the guest list where no two adjacent names start with the same letter. If no such arrangement is possible, return an empty list. Example: * `arrange_seating([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Amanda\\", \\"David\\", \\"Eve\\"])` can return `[\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Amanda\\"]`. * `arrange_seating([\\"Alex\\", \\"Amanda\\", \\"Albert\\", \\"Alfred\\"])` should return `[]`. * (Because all names start with \'A\', no arrangement is possible.) Constraints: * Ensure optimal performance for the given constraint (1 <= len(guests) <= 10^5). Notes: * Consider edge cases such as lists where all names start with the same letter. * Consider explaining your choice of algorithm in comments for clarity.","solution":"from collections import Counter, deque from heapq import heappop, heappush from typing import List def arrange_seating(guests: List[str]) -> List[str]: if not guests: return [] # Count the frequency of the first letter of each guest\'s name letter_count = Counter(guest[0] for guest in guests) max_letter_count = max(letter_count.values()) # It\'s impossible to have no two consecutive guests with the same starting letter # if any letter count exceeds (n + 1) // 2 if max_letter_count > (len(guests) + 1) // 2: return [] # Organize guests by first letter and keep the counts in a heap guests_by_letter = {} for guest in guests: first_letter = guest[0] if first_letter not in guests_by_letter: guests_by_letter[first_letter] = deque() guests_by_letter[first_letter].append(guest) max_heap = [] for letter, count in letter_count.items(): heappush(max_heap, (-count, letter)) result = [] prev_letter, prev_letter_count = None, 0 while max_heap: count, letter = heappop(max_heap) count = -count result.append(guests_by_letter[letter].popleft()) if prev_letter_count > 0: heappush(max_heap, (-prev_letter_count, prev_letter)) prev_letter, prev_letter_count = letter, count - 1 return result"},{"question":"# Question You are given a list of unique integers. Your task is to write a function that generates all possible subsets (the power set) of the input list and returns them in a list of lists format. Function Signature ```python def generate_power_set(nums: List[int]) -> List[List[int]]: ``` Input - `nums` (List[int]): A list of unique integers, with length `0 <= len(nums) <= 20`. Output - `List[List[int]]`: A list containing all possible subsets of the input list, including the empty subset. Example ```python assert sorted(generate_power_set([1, 2, 3])) == sorted([[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]) assert sorted(generate_power_set([0])) == sorted([[], [0]]) assert sorted(generate_power_set([])) == sorted([[]]) assert sorted(generate_power_set([-1, 1])) == sorted([[], [-1], [1], [-1, 1]]) ``` In your implementation, consider the following key points: - Use an iterative approach or backtracking to generate all subsets. - Ensure that duplicates are handled correctly so that each subset is unique. - Maintain the order or ensure that the final output is sorted correctly, especially in the test cases for easier comparisons.","solution":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: Generates all possible subsets (the power set) of the input list `nums`. def backtrack(start, path): power_set.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() power_set = [] backtrack(0, []) return power_set"},{"question":"# Question You are tasked with implementing a function that checks if an undirected graph, represented as an adjacency matrix, is bipartite. A graph is bipartite if the node set can be divided into two disjoint sets such that no two graph nodes within the same set are adjacent. Write a function `is_bipartite(graph: List[List[int]]) -> bool` that returns `True` if the graph is bipartite and `False` if it is not. # Input and Output Formats Inputs: - `graph`: A 2D list where `graph[i][j]` is `1` if there is an edge between the `i`-th node and the `j`-th node, or `0` otherwise. It\'s an `N x N` adjacency matrix where `N` is the number of nodes. Output: - A boolean value indicating whether the graph is bipartite. # Constraints - Each input graph will have at least 2 nodes. - Graph nodes are indexed from `0` to `N-1`. - The graph is undirected, so the adjacency matrix is symmetric. # Example ```python # Example 1 graph = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 0] ] # Example Function Call print(is_bipartite(graph)) # Expected Output True # Example 2 graph = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] # Example Function Call print(is_bipartite(graph)) # Expected Output False ``` In the first example, the graph is bipartite as it can be divided into sets `{0, 2}` and `{1, 3}`, where there are no edges within the same set. In the second example, the graph is not bipartite as it contains a triangle (cycle of length 3), which makes partitioning into bipartite sets impossible.","solution":"from collections import deque from typing import List def is_bipartite(graph: List[List[int]]) -> bool: Check if the given graph is bipartite. :param graph: A 2D list representing the adjacency matrix of the graph. :return: True if the graph is bipartite, False otherwise. n = len(graph) colors = [-1] * n # -1 means uncolored, 0 and 1 are the two colors for i in range(n): if colors[i] == -1: # Not yet colored queue = deque([i]) colors[i] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in range(n): if graph[node][neighbor] == 1: # There is an edge if colors[neighbor] == -1: # Not yet colored colors[neighbor] = 1 - colors[node] # Alternate color queue.append(neighbor) elif colors[neighbor] == colors[node]: # Same color as current node return False return True"},{"question":"# Question: Construct a Balanced Binary Search Tree from a Sorted List You are required to design a function that constructs a balanced binary search tree (BST) from a given sorted list of integers. A BST is balanced if the depth of the two subtrees of every node never differs by more than 1. # Requirements: 1. Implement the function `sorted_list_to_bst(nums: List[int]) -> Optional[TreeNode]`: * **`nums` (List[int])**: A sorted list of integers. 2. The function should return the root of the balanced BST. 3. Each node in the BST should be represented by a `TreeNode` class with attributes: * **`val` (int)**: The value of the node. * **`left` (Optional[TreeNode])**: The left child node. * **`right` (Optional[TreeNode])**: The right child node. # Example: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right nums = [-10, -3, 0, 5, 9] root = sorted_list_to_bst(nums) ``` Given the sorted list `[-10, -3, 0, 5, 9]`, the function should construct and return a balanced BST. One possible balanced BST for this list is: ``` 0 / -10 5 -3 9 ``` # Constraints: * The elements in the list are sorted in ascending order. * The length of the list will be between `0` and `10^4`. # Performance Requirements: * The function must run in O(n) time complexity, where n is the number of elements in the list. * The function must handle edge cases such as empty lists and lists with a single element appropriately.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_list_to_bst(nums: List[int]) -> Optional[TreeNode]: Constructs a balanced BST from a sorted list of integers. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_list_to_bst(nums[:mid]) root.right = sorted_list_to_bst(nums[mid + 1:]) return root"},{"question":"# Problem Statement You are tasked with implementing a function that performs matrix rotation by 90 degrees in an anticlockwise direction. This function should be efficient and handle varying sizes of square matrices. Function Description Implement the function `rotate_matrix_90_anticlockwise` which has the following signature: ```python def rotate_matrix_90_anticlockwise(matrix: list[list[int]]) -> list[list[int]]: :param matrix: a square matrix consisting of integers :return: the matrix rotated by 90 degrees in an anticlockwise direction ``` Input - `matrix`: A 2D list of integers representing a square matrix (`1 <= len(matrix) <= 1000`, `-1000 <= matrix[i][j] <= 1000`). Output - Return the new matrix that has been rotated by 90 degrees in an anticlockwise direction. Constraints - Your function must handle edge cases including: - Empty matrices. - Large matrices up to 1000x1000 elements. Examples ```python print(rotate_matrix_90_anticlockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Expected Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] print(rotate_matrix_90_anticlockwise([[1]])) # Expected Output: [[1]] print(rotate_matrix_90_anticlockwise([])) # Expected Output: [] print(rotate_matrix_90_anticlockwise([[1, 2], [3, 4]])) # Expected Output: [[2, 4], [1, 3]] ``` # Notes - Ensure your implementation is optimized for performance given the constraints. - Test your function with various input sizes and values to confirm its correctness and efficiency. - Pay attention to edge cases such as empty matrices.","solution":"def rotate_matrix_90_anticlockwise(matrix: list[list[int]]) -> list[list[int]]: Rotates a given square matrix by 90 degrees in an anticlockwise direction. :param matrix: a square matrix consisting of integers :return: the matrix rotated by 90 degrees in an anticlockwise direction if not matrix: return [] n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"# Count the Unique Words Context: In text processing and analysis, counting unique words is a common task in various applications like search engines, text summarization, and data analysis. Understanding how to efficiently identify and count unique words helps in optimizing performance in these applications. Your task is to implement a function that counts the number of unique words in a given input string. Task: Implement the function `count_unique_words(text: str) -> int`, which returns the count of unique words in the given input string. Words are defined as sequences of characters separated by whitespace. Input: - **text**: A single string input `0 <= len(text) <= 10^6`. Output: - A single integer representing the count of unique words in the input text. Constraints: 1. Characters in the input string will be limited to basic ASCII (character code range 32-126). 2. Words are case-sensitive (e.g., \\"Word\\" and \\"word\\" are considered different words). 3. The input string may contain leading, trailing, or multiple spaces between words. Example: ```python text = \\"hello world\\" print(count_unique_words(text)) # Output: 2 text = \\"The quick brown fox jumps over the lazy dog\\" print(count_unique_words(text)) # Output: 8 text = \\"A good good night\\" print(count_unique_words(text)) # Output: 3 ``` Performance Requirements: - Your implementation should complete within reasonable time limits for input strings up to 1 million characters.","solution":"def count_unique_words(text): Returns the count of unique words in the input text. # Split the text into words using whitespace as the delimiter words = text.split() # Use a set to store unique words unique_words = set(words) # Return the number of unique words return len(unique_words)"},{"question":"# Scenario You are tasked with developing a utility for a library management system. This system needs to keep track of a list of books and be able to perform various operations such as adding a new book, removing an existing book, and searching for a book by title or author. # Task Implement the class `Library` which manages a collection of book objects. Each book is represented as a dictionary with the keys \\"title\\" and \\"author.\\" Your class should be capable of performing all necessary operations efficiently. # Requirements 1. **Class Definition**: ```python class Library: def __init__(self): pass def add_book(self, title: str, author: str) -> None: pass def remove_book(self, title: str) -> bool: pass def search_by_title(self, title: str) -> dict: pass def search_by_author(self, author: str) -> list: pass ``` 2. **Method Descriptions**: - `__init__`: Initializes an empty list to store books. - `add_book`: Adds a new book to the library. Each book is a dictionary with the keys \\"title\\" and \\"author\\". - `remove_book`: Removes a book with the given title from the library. Returns `True` if the book was removed, `False` otherwise. - `search_by_title`: Searches for a book by its title. Returns the book (as a dictionary) if found, or an empty dictionary if not found. - `search_by_author`: Searches for books by a given author. Returns a list of books (each book as a dictionary) written by that author. 3. **Constraints**: - All titles and authors are case-sensitive strings. - No two books have the same title. - If a book to remove does not exist, return `False`. # Examples ```python library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(\\"1984\\", \\"George Orwell\\") # Search by title print(library.search_by_title(\\"1984\\")) # Output: {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"} # Search by author print(library.search_by_author(\\"Harper Lee\\")) # Output: [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}] # Remove a book print(library.remove_book(\\"The Great Gatsby\\")) # Output: True # Try to remove a book that doesn\'t exist print(library.remove_book(\\"Moby Dick\\")) # Output: False # Search by title for a removed book print(library.search_by_title(\\"The Great Gatsby\\")) # Output: {} ``` # Additional Notes Consider edge cases such as: - Adding a book with a title that already exists. - Removing a book that is not in the collection. - Searching for a title or author that does not exist.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str) -> None: self.books.append({\\"title\\": title, \\"author\\": author}) def remove_book(self, title: str) -> bool: for book in self.books: if book[\\"title\\"] == title: self.books.remove(book) return True return False def search_by_title(self, title: str) -> dict: for book in self.books: if book[\\"title\\"] == title: return book return {} def search_by_author(self, author: str) -> list: result = [book for book in self.books if book[\\"author\\"] == author] return result"},{"question":"# Problem Description You are tasked to implement a function that returns the longest contiguous subsequence in an array `arr` with a sum less than or equal to a given integer `S`. # Requirements 1. **Input**: - An array `arr` of integers where (-10^6 ≤ arr[i] ≤ 10^6). - An integer `S` (1 ≤ S ≤ 10^9). 2. **Output**: The length of the longest contiguous subsequence with a sum less than or equal to `S`. # Implementation Implement the function `longest_subsequence(arr: List[int], S: int) -> int`. # Example ```python def longest_subsequence(arr: List[int], S: int) -> int: # Your code here pass # Example Test Case print(longest_subsequence([1, 2, 3, 4, 5], 5)) # Expected Output: 2 (The subsequence [2, 3] or [1, 2]) print(longest_subsequence([5, -2, 1, 2, 3], 3)) # Expected Output: 3 (The subsequence [1, 2]) ``` # Notes * Use an efficient algorithm to handle large inputs. * Ensure your solution considers edge cases where the entire array or no subsequence is within the given sum `S`. * You may use a sliding window or a two-pointer technique to optimize the solution.","solution":"from typing import List def longest_subsequence(arr: List[int], S: int) -> int: n = len(arr) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > S and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Binary Search Tree (BST) Insertion and Search Implementation **Scenario/Context:** You are building a search feature in a large database system that requires efficient data retrieval. One commonly used data structure for efficient search operations is the Binary Search Tree (BST). Your task is to implement a BST with insertion and search functionalities. **Task:** Implement a Binary Search Tree with methods to insert a value and to search for a value within the tree. **Class Definition:** ```python class BSTNode: def __init__(self, value: int): pass class BinarySearchTree: def __init__(self): pass def insert(self, value: int) -> None: pass def search(self, value: int) -> bool: pass ``` # Input 1. **value** (int): An integer value to be inserted or searched in the BST. # Methods - **insert(value)**: Inserts a value into the BST. If the value already exists, it ignores the insertion. - **search(value)**: Searches for a value in the BST. Returns `True` if found, `False` otherwise. # Constraints - Values inserted will always be integers. - Values searched will be integers. - Implement proper handling for cases where the BST is empty. # Performance Requirements - Ensure that both insert and search operations maintain average-case time complexity of O(log n). # Example ```python # Example usage: bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(10) # Duplicate, should be ignored # Expected Output: # True, since 10 is in the BST print(bst.search(10)) # Expected Output: # False, since 20 is not in the BST print(bst.search(20)) ``` # Validation Implement checks for the BST to ensure: - `value` provided to `insert` and `search` methods must be integers. - Handle the insertion of duplicate values by ignoring them. - Ensure the search operation works correctly for existing and non-existing values in the tree.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not isinstance(value, int): raise ValueError(\\"Value must be an integer.\\") if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, current: BSTNode, value: int) -> None: if value < current.value: if current.left is None: current.left = BSTNode(value) else: self._insert_recursive(current.left, value) elif value > current.value: if current.right is None: current.right = BSTNode(value) else: self._insert_recursive(current.right, value) # If value == current.value, ignore the insertion (do nothing) def search(self, value: int) -> bool: if not isinstance(value, int): raise ValueError(\\"Value must be an integer.\\") return self._search_recursive(self.root, value) def _search_recursive(self, current: BSTNode, value: int) -> bool: if current is None: return False if value == current.value: return True elif value < current.value: return self._search_recursive(current.left, value) else: return self._search_recursive(current.right, value)"},{"question":"You are required to implement a function that reverses the nodes of a linked list `k` at a time and returns its modified list. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k`, the remaining nodes at the end should be left as is. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: pass ``` # Input * **head**: The head of a singly linked list. * **k**: An integer representing the number of nodes to reverse at a time. # Output * **Return**: The head of the modified linked list. # Constraints * The number of nodes in the linked list is `n` (1 <= n <= 10^5). * 1 <= k <= n. # Performance Requirement * Your algorithm should perform in linear time with respect to the number of nodes. # Scenario A software developer is working on a system that requires frequent manipulation of linked lists based on specific grouping requirements. Implementing this function will allow them to efficiently reverse nodes in the linked list by the specified group size, facilitating more complex linked list operations downstream. # Examples ```python # Creating the linked list 1->2->3->4->5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) assert ListNode.to_list(reverse_k_group(head, 2)) == [2, 1, 4, 3, 5] # Creating the linked list 1->2->3->4->5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) assert ListNode.to_list(reverse_k_group(head, 3)) == [3, 2, 1, 4, 5] ``` Explanation: * In the first example, the nodes of the linked list are reversed in groups of 2. Therefore, 1->2->3->4->5 is transformed to 2->1->4->3->5. * In the second example, the nodes are reversed in groups of 3. Hence, 1->2->3->4->5 is transformed to 3->2->1->4->5. * Helper function `ListNode.to_list()` is assumed for converting linked list to list for assertion comparison.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next @staticmethod def to_list(head): result = [] while head: result.append(head.val) head = head.next return result def reverse_k_group(head: ListNode, k: int) -> ListNode: def reverse_linked_list(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverse_k_group(ptr, k) return reversed_head return head"},{"question":"# Question: Prime Number Pairs **Background**: A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. **Problem**: Given an integer `n`, find all pairs of prime numbers `(p1, p2)` such that: - `p1` and `p2` are both prime numbers, - `p1 + p2 = n`, - and `p1 <= p2`. Write a function to return the list of such pairs. **Function Signature**: ```python def prime_pairs(n: int) -> List[Tuple[int, int]]: ``` # Input - An integer `n` representing the target sum. # Output - A list of tuples `(p1, p2)`, where `p1` and `p2` are prime numbers such that `p1 + p2 = n`. # Constraints - `2 <= n <= 10^6` # Example ```python >>> prime_pairs(10) [(3, 7), (5, 5)] >>> prime_pairs(14) [(3, 11), (7, 7)] >>> prime_pairs(5) [(2, 3)] ``` # Additional Notes - Consider edge cases such as `n` being small or only having one pair of primes. - Optimize the function to handle upper constraints efficiently using a suitable prime generating algorithm, such as the Sieve of Eratosthenes.","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[bool]: Generates a list of booleans representing primality of numbers up to limit. is_prime = [True] * (limit + 1) is_prime[0], is_prime[1] = False, False # 0 and 1 are not primes p = 2 while (p * p <= limit): if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return is_prime def prime_pairs(n: int) -> List[Tuple[int, int]]: Returns a list of tuples (p1, p2) where p1 and p2 are prime numbers such that p1 + p2 = n and p1 <= p2. if n < 2: return [] is_prime = sieve_of_eratosthenes(n) pairs = [] for p1 in range(2, n // 2 + 1): p2 = n - p1 if is_prime[p1] and is_prime[p2]: pairs.append((p1, p2)) return pairs"},{"question":"# Task You need to implement a function that can efficiently remove a specific element from a given binary search tree (BST) while maintaining the properties of the BST. You are provided with an initial implementation of the BST class. Extend it to include the new method as described. # Deletion Operation: Write a method `delete` in the `BST` class which removes a node with a given value from the binary search tree. # Rules for Removal: - If the node has no children (leaf node), remove it directly. - If the node has one child, remove the node and replace it with its child. - If the node has two children, replace the node with its in-order successor (smallest node in the right subtree) and remove the in-order successor. # Implementation Steps: 1. Add a `delete` method to the `BST` class. 2. Ensure that the resulting tree remains a valid binary search tree after the deletion. 3. Handle all edge cases such as deletion of a non-existing node and empty tree. 4. Ensure that the `delete` method can handle nodes with zero, one, or two children correctly. # Input and Output: Your `delete` method should accept a single integer value to be deleted from the BST. The method should return the root of the BST after the deletion is performed. # Sample Implementation: Below is a partial implementation of the `BST` class. Extend it with the `delete` method. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def delete(self, key): # Implement this method pass def _min_value_node(self, node): current = node while current.left: current = current.left return current def inorder(self, root): if root: self.inorder(root.left) print(root.val, end=\' \') self.inorder(root.right) # Example usage: bst = BST() nodes_to_insert = [50, 30, 20, 40, 70, 60, 80] for node in nodes_to_insert: bst.insert(node) print(\\"Inorder traversal before deletion:\\") bst.inorder(bst.root) print() bst.delete(20) print(\\"Inorder traversal after deletion of 20:\\") bst.inorder(bst.root) print() bst.delete(30) print(\\"Inorder traversal after deletion of 30:\\") bst.inorder(bst.root) print() bst.delete(50) print(\\"Inorder traversal after deletion of 50:\\") bst.inorder(bst.root) print() ``` # Constraints: - You can assume that the input keys are unique. - You can assume the BST will not contain duplicate values. Complete the implementation of the `delete` method and verify it with the provided examples.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def delete(self, key): self.root = self._delete_node(self.root, key) def _delete_node(self, root, key): if root is None: return root if key < root.val: root.left = self._delete_node(root.left, key) elif key > root.val: root.right = self._delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.val = temp.val root.right = self._delete_node(root.right, temp.val) return root def _min_value_node(self, node): current = node while current.left: current = current.left return current def inorder(self, root): result = [] if root: result += self.inorder(root.left) result.append(root.val) result += self.inorder(root.right) return result"},{"question":"You are required to implement the function `convert_camel_to_snake` which transforms a given camelCase string into a snake_case string. CamelCase strings have words joined together without spaces, and each word\'s initial letter (except the first) is capitalized. Snake_case strings use underscores to separate words, and all letters are lowercase. # Requirements: 1. If the input string is empty, return an empty string. 2. Raise a ValueError if the input string contains non-alphabetical characters. 3. Transform the CamelCase string into a snake_case string by: - Inserting underscores before capital letters (except for the first character). - Converting the entire string to lowercase. # Function Signature: ```python def convert_camel_to_snake(camel_case_string: str) -> str: Input Parameters ---------------- camel_case_string : str The input string in camelCase format. Returns ------- result : str The converted string in snake_case format. Raises ------ ValueError If the input string contains non-alphabetical characters. Examples -------- >>> convert_camel_to_snake(\\"camelCaseString\\") \'camel_case_string\' >>> convert_camel_to_snake(\\"CamelCaseString\\") \'camel_case_string\' >>> convert_camel_to_snake(\\"thisIsATest\\") \'this_is_a_test\' >>> convert_camel_to_snake(\\"thisIsATest123\\") Traceback (most recent call last): ... ValueError: Input string contains non-alphabetical characters pass ``` # Constraints: * The input string should contain only alphabetical characters (a-z, A-Z). * The transformed string should be in lowercase with words separated by underscores. * Use regular expressions for detecting capital letters and non-alphabetical characters if needed. * Ensure the function raises appropriate errors as specified in the requirements. Implement this function and ensure it passes the given validation tests.","solution":"import re def convert_camel_to_snake(camel_case_string: str) -> str: Converts a camelCase string into snake_case string. Parameters: camel_case_string (str): The input string in camelCase format. Returns: str: The converted string in snake_case format. Raises: ValueError: If the input string contains non-alphabetical characters. if not camel_case_string: return \\"\\" if not camel_case_string.isalpha(): raise ValueError(\\"Input string contains non-alphabetical characters\\") # Insert an underscore before any capital letters except the first one and convert to lower case snake_case_string = re.sub(r\'(?<!^)(?=[A-Z])\', \'_\', camel_case_string).lower() return snake_case_string"},{"question":"**Problem Statement:** You are tasked with developing a feature to determine the minimum number of steps required to reduce a given positive integer `n` to 1. Each step must follow one of these three operations: 1. Subtract 1 from `n` 2. If `n` is divisible by 2, divide `n` by 2 3. If `n` is divisible by 3, divide `n` by 3 Write a function `min_steps_to_one(n: int) -> int` that: - Receives a positive integer `n`. - Returns the minimum number of steps required to reduce `n` to 1. # Constraints: - 1 ≤ `n` ≤ 10^6 # Input: - `n`: A positive integer representing the initial number. # Output: - An integer denoting the minimum number of steps required to reduce `n` to 1. # Example: Example 1: ``` Input: n = 10 Output: 3 Explanation: 10 -> 9 (subtract 1) 9 -> 3 (divide by 3) 3 -> 1 (divide by 3) ``` Example 2: ``` Input: n = 15 Output: 4 Explanation: 15 -> 5 (divide by 3) 5 -> 4 (subtract 1) 4 -> 2 (divide by 2) 2 -> 1 (divide by 2) ``` Implement an efficient solution using memoization or dynamic programming to handle the upper limits of the constraint.","solution":"def min_steps_to_one(n: int) -> int: Returns the minimum number of steps required to reduce n to 1 using the operations defined: 1. Subtract 1 from n 2. If n is divisible by 2, divide n by 2 3. If n is divisible by 3, divide n by 3 if n <= 0: raise ValueError(\\"Input must be a positive integer\\") # Dynamic programming table to minimize steps dp = [0] * (n + 1) for i in range(2, n + 1): # Initialize minimum steps to 1 more than previous number min_steps = dp[i - 1] + 1 # Check for division by 2 if i % 2 == 0: min_steps = min(min_steps, dp[i // 2] + 1) # Check for division by 3 if i % 3 == 0: min_steps = min(min_steps, dp[i // 3] + 1) dp[i] = min_steps return dp[n]"},{"question":"# Diagonal Traversal of a Matrix Objectives Write a function `diagonal_traversal(matrix: list[list[int]]) -> list[int]:` that takes a 2D matrix as input and returns a list of integers representing the elements of the matrix traversed in a diagonal order starting from the top-left corner. Input - `matrix`: A list of lists of integers, where each list represents a row in the matrix. You can assume that the matrix is properly formatted and non-empty. Output - A list of integers which are the elements of the matrix in diagonal order. Constraints - The function should handle matrices of varying dimensions (e.g., 1x1, 1xN, Mx1, MxN). - The function should be efficient in terms of both time and space complexities. Examples - **Example 1**: ```python >>> diagonal_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` - **Example 2**: ```python >>> diagonal_traversal([[1]]) [1] ``` - **Example 3**: ```python >>> diagonal_traversal([[1, 2], [3, 4]]) [1, 2, 3, 4] ``` Note - You must ensure that your implementation does not modify the original matrix. - Aim for a solution that completes the traversal in O(m * n) time complexity, where m is the number of rows and n is the number of columns. # Testing Use the provided examples and additional test cases to validate your solution, particularly testing matrices of different dimensions and cases like a single row/column.","solution":"def diagonal_traversal(matrix: list[list[int]]) -> list[int]: Returns the elements of the given matrix in diagonal order. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) result = [] r, c, direction = 0, 0, 1 for _ in range(rows * cols): result.append(matrix[r][c]) if direction == 1: # moving up if c == cols - 1: r += 1 direction = -1 elif r == 0: c += 1 direction = -1 else: r -= 1 c += 1 else: # moving down if r == rows - 1: c += 1 direction = 1 elif c == 0: r += 1 direction = 1 else: r += 1 c -= 1 return result"},{"question":"Problem Statement Write a function that simulates the management of an emergency call queue for a hospital. The function will process a list of commands to either add a new call to the queue, process an existing call by removing it from the queue, or retrieve the current state of the queue. # Requirements Function Signature ```python def manage_call_queue(commands: list) -> list: ``` Input * `commands`: A list of tuples where each tuple represents a command. Each command can be one of the following: - `(\\"ADD\\", call_id)`: Add a new call to the queue with the identifier `call_id` (a string). - `(\\"PROCESS\\",)`: Process (i.e., remove) the call that has been in the queue the longest (FIFO order). - `(\\"RETRIEVE\\",)`: Retrieve and return the current state of the queue as a list of `call_id`s in FIFO order. Output * A list of lists. Each inner list is a snapshot of the queue for each `RETRIEVE` command in the order they were processed. Constraints * You may assume that each `call_id` is a unique string. * The commands list will always be well-formed and valid according to the structure specified. * The queue will always have at least one call before a `PROCESS` command is issued. # Examples ```python >>> manage_call_queue([ ... (\\"ADD\\", \\"C123\\"), ... (\\"ADD\\", \\"C124\\"), ... (\\"RETRIEVE\\",), ... (\\"PROCESS\\",), ... (\\"RETRIEVE\\",), ... (\\"ADD\\", \\"C125\\"), ... (\\"RETRIEVE\\",) ... ]) [[\\"C123\\", \\"C124\\"], [\\"C124\\"], [\\"C124\\", \\"C125\\"]] >>> manage_call_queue([ ... (\\"ADD\\", \\"A1\\"), ... (\\"ADD\\", \\"A2\\"), ... (\\"PROCESS\\",), ... (\\"ADD\\", \\"A3\\"), ... (\\"RETRIEVE\\",) ... ]) [[\\"A2\\", \\"A3\\"]] ``` # Notes - Ensure your function efficiently manages the queue operations. - Each `RETRIEVE` command returns the state of the queue immediately after the command is processed. - The commands list can include an arbitrary number of operations, but they should be processed sequentially as they appear.","solution":"def manage_call_queue(commands): Manages an emergency call queue based on the given commands. queue = [] result = [] for command in commands: if command[0] == \\"ADD\\": call_id = command[1] queue.append(call_id) elif command[0] == \\"PROCESS\\": if queue: queue.pop(0) elif command[0] == \\"RETRIEVE\\": result.append(queue.copy()) return result"},{"question":"# Question: Weather Data Analyzer You are tasked with developing a program to analyze weather data from an API. The goal is to retrieve weather statistics for a specified city and date range, and then compute various insights. Requirements 1. Implement the function `weather_data_analysis(api_key: str, city: str, start_date: str, end_date: str) -> dict` 2. The function should: - Fetch weather data from the specified API for the given city and date range. - Parse the JSON response to retrieve necessary information. - Calculate and return a dictionary with the following: - The average temperature over the date range. - The highest and lowest temperatures recorded. - The total amount of precipitation. Input * `api_key`: A string representing the API key for authentication. * `city`: A string representing the city for which weather data is to be retrieved. * `start_date`: A string in the format `YYYY-MM-DD` representing the start date. * `end_date`: A string in the format `YYYY-MM-DD` representing the end date. Output * A dictionary containing: - `average_temperature`: The average temperature over the date range. - `highest_temperature`: The highest temperature recorded in the date range. - `lowest_temperature`: The lowest temperature recorded in the date range. - `total_precipitation`: The total amount of precipitation over the date range. Constraints * Network operations (HTTP requests) might fail; handle these gracefully. * The date range should be correctly formatted and valid; handle any potential errors. * JSON structure may vary slightly; design robust parsing. Example ```python { \\"average_temperature\\": 22.5, \\"highest_temperature\\": 28.3, \\"lowest_temperature\\": 15.4, \\"total_precipitation\\": 12.3 } ``` # Additional Notes * Ensure the function can handle cases where the expected JSON fields are missing or have null values. * Implement error handling for network timeouts and other request-related exceptions. * Optimize the code for both efficiency and accuracy in fetching and processing the data.","solution":"import requests from datetime import datetime def weather_data_analysis(api_key: str, city: str, start_date: str, end_date: str) -> dict: Fetch weather data from the specified API for the given city and date range, and compute various weather statistics. base_url = \\"https://api.weatherapi.com/v1/history.json\\" params = { \\"key\\": api_key, \\"q\\": city, \\"dt\\": start_date, \\"end_dt\\": end_date } try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() temperatures = [] total_precipitation = 0 for day in data[\\"forecast\\"][\\"forecastday\\"]: day_temps = [hour[\\"temp_c\\"] for hour in day[\\"hour\\"]] temperatures.extend(day_temps) total_precipitation += day[\\"day\\"][\\"totalprecip_mm\\"] average_temperature = sum(temperatures) / len(temperatures) if temperatures else None highest_temperature = max(temperatures, default=None) lowest_temperature = min(temperatures, default=None) return { \\"average_temperature\\": average_temperature, \\"highest_temperature\\": highest_temperature, \\"lowest_temperature\\": lowest_temperature, \\"total_precipitation\\": total_precipitation } except requests.exceptions.RequestException as e: print(f\\"Error fetching data from API: {e}\\") return {} except (KeyError, TypeError) as e: print(f\\"Error parsing data: {e}\\") return {}"},{"question":"# Problem Description You have been tasked with developing an efficient algorithm to flatten a list of nested dictionaries into a single-level dictionary. Each key in the flattened dictionary should represent the path through the original nested structure, with elements separated by a delimiter. # Task Implement a function that recursively flattens a nested dictionary. Your function should account for different types of values including integers, strings, lists, and other dictionaries. Only nested dictionaries should be flattened. # Function Signature ```python def flatten_dictionary(input_dict: dict, delimiter: str = \'.\') -> dict: pass ``` # Input - `input_dict` (dict): A dictionary that may contain nested dictionaries. - `delimiter` (str): A string used to separate keys in the flattened dictionary path. # Output - Return a flattened dictionary where keys represent the path from the root to each value. # Constraints - Keys in the input dictionary are strings. - The input dictionary can be deeply nested. - Use a default delimiter of \\".\\", but allow for custom delimiters. # Examples ```python # Sample Input and Output assert flatten_dictionary({\'a\': 1, \'b\': {\'x\': 2, \'y\': {\'z\': 3}}}) == {\'a\': 1, \'b.x\': 2, \'b.y.z\': 3} assert flatten_dictionary({\'a\': 1, \'b\': {\'x\': 2, \'y\': {\'z\': 3}}}, \'-\') == {\'a\': 1, \'b-x\': 2, \'b-y-z\': 3} assert flatten_dictionary({}) == {} assert flatten_dictionary({\'a\': {\'b\': {\'c\': \'d\'}}}) == {\'a.b.c\': \'d\'} assert flatten_dictionary({\'a\': {\'b\': 1}, \'c\': {\'d\': {\'e\': 2}}}, \'_\') == {\'a_b\': 1, \'c_d_e\': 2} assert flatten_dictionary({\'key1\': {\'key2\': {\'key3\': [{\'inner_key\': \'value\'}]}}}) == {\'key1.key2.key3\': [{\'inner_key\': \'value\'}]} ``` # Hints - Ensure that the function can handle deeply nested dictionaries. - You will need to recursively process each section of the dictionary to generate the flattened keys. - Use the `delimiter` parameter to handle different key path separators. This new question maintains the style, complexity, and scope of the existing set, presenting a problem that requires similar levels of recursion and data structure handling.","solution":"def flatten_dictionary(input_dict: dict, delimiter: str = \'.\') -> dict: Flattens a nested dictionary into a single-level dictionary. Arguments: input_dict -- The dictionary to be flattened. delimiter -- The string to be used as a separator for keys. Returns: A flattened dictionary. def _flatten(current_dict, parent_key=\'\'): items = [] for k, v in current_dict.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return _flatten(input_dict)"},{"question":"# Question Write a function named `robust_sorter` that takes a list of mixed data types (integers, floats, and strings which represent nums) and returns a new list sorted in ascending order. The function must: 1. Convert all string representations of numbers to their respective numeric types, 2. Sort the numbers, preserving their original types in the output list. Implement the function to handle any combinations of integers, floats, and strings in the input list. # Required Function Signature ```python def robust_sorter(data: list) -> list: pass ``` # Examples ```python >>> robust_sorter([3, \'4\', 1.5, \'2.3\', 0, \'5.5\']) [0, 1.5, \'2.3\', 3, \'4\', \'5.5\'] >>> robust_sorter([\'1\', 2, \'3.5\', 2.7, 0.6, 5]) [0.6, 2, \'1\', 2.7, \'3.5\', 5] >>> robust_sorter([10, \'5.5\', \'2\', 3, 7.1, \'1.0\']) [\'1.0\', \'2\', 3, \'5.5\', 7.1, 10] ``` # Constraints * Input list will only contain integers, integers as strings, floats, and floats as strings. * Strings that do not represent a valid number should raise a `ValueError` with a descriptive message. * The returned list should maintain the original types of numeric values but ordered numerically. # Notes * You may assume that the strings are always valid numeric representations. * Make sure to validate the type conversion and handle cases where sorting might fail due to invalid input.","solution":"def robust_sorter(data: list) -> list: Sort a list of mixed data types (int, float, str representing numbers) while preserving the original types. Invalid numeric strings should raise a ValueError. Args: - data: A list of mixed data types (int, float, str representing numbers). Returns: - A new list sorted in ascending order preserving original types. numeric_values = [] for item in data: if isinstance(item, int) or isinstance(item, float): numeric_values.append((item, item)) elif isinstance(item, str): try: numeric_value = float(item) if \'.\' in item else int(item) numeric_values.append((numeric_value, item)) except ValueError: raise ValueError(f\\"Invalid numeric string: {item}\\") # Sort list based on numerical representation numeric_values.sort(key=lambda x: x[0]) # Extract sorted items with original types preserved sorted_data = [item[1] for item in numeric_values] return sorted_data"},{"question":"# Problem Description You have been recruited by a tech company to develop a basic memory management simulation for their new operating system. One of the tasks is to create a simple dynamic memory allocation and deallocation system. You need to write two functions: `allocate` and `deallocate` that handle memory blocks in a contiguous array. Objective Write two functions, `allocate` and `deallocate`, that simulate the allocation and deallocation of memory blocks. Function Signatures * `allocate(array: List[int], size: int) -> Optional[int]` * `deallocate(array: List[int], start_index: int, size: int) -> None` # Function Definitions 1. **allocate** This function finds the first continuous block of memory that is free (denoted by `0`) and allocates it. * Input: * `array` (List[int]): The array representing memory, where each index denotes a unit of memory, and `0` signifies free memory while `1` signifies allocated memory. * `size` (int): The size of the block to be allocated. * Output: * Returns the starting index of the allocated memory block if successful. If no suitable block is found, returns `None`. 2. **deallocate** This function deallocates a block of memory starting from a given index. * Input: * `array` (List[int]): The array representing memory. * `start_index` (int): The starting index of the memory block to be deallocated. * `size` (int): The size of the memory block to be deallocated. * Output: * None (Modifies the array in place). # Examples ```python # Example for allocate memory = [0, 0, 0, 1, 1, 0, 0, 0, 0, 1] print(allocate(memory, 3)) # Expected Output: 0 print(allocate(memory, 2)) # Expected Output: 6 print(allocate(memory, 5)) # Expected Output: None # Example for deallocate memory = [1, 1, 1, 1, 1, 0, 0, 0, 0, 1] deallocate(memory, 0, 5) print(memory) # Expected Output: [0, 0, 0, 0, 0, 0, 0, 0, 0, 1] memory = [0, 0, 0, 1, 1, 0, 0, 0, 0, 1] deallocate(memory, 5, 4) print(memory) # Expected Output: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0] ``` # Instructions 1. Efficiently handle edge cases where size might exceed available memory. 2. Ensure the starting and ending index calculations do not go out of bounds. 3. Deallocated memory should only occur within valid bounds. 4. Test your code thoroughly using the provided examples and additional test cases if necessary.","solution":"from typing import List, Optional def allocate(array: List[int], size: int) -> Optional[int]: Finds the first continuous block of memory that is free and allocates it. :param array: List[int] representing the memory where `0` is free and `1` is allocated. :param size: int size of the block to be allocated. :return: int starting index of the allocated memory block if successful, otherwise None. n = len(array) for i in range(n - size + 1): if all(array[j] == 0 for j in range(i, i + size)): for j in range(i, i + size): array[j] = 1 return i return None def deallocate(array: List[int], start_index: int, size: int) -> None: Deallocates a block of memory starting from a given index. :param array: List[int] representing the memory. :param start_index: int starting index of the memory block to be deallocated. :param size: int size of the block to be deallocated. :return: None (modifies the array in place) for i in range(start_index, start_index + size): if i < len(array): array[i] = 0"},{"question":"# Coding Assessment Question Context You are developing a software system for a library that needs to manage its collection of books. One of the critical features is to reorder the books based on their popularity. The popularity metrics are derived from user ratings, and the books need to be sorted accordingly. You are tasked with implementing the sorting mechanism. Problem Statement Given a list of books and their popularity score, write a Python function `sort_books_by_popularity(books: list) -> list` that returns the list of books sorted by their popularity in descending order. Input Format * A list of dictionaries, where each dictionary contains two keys: - `title`: A string representing the title of the book. - `popularity`: An integer representing the popularity score of the book. Output Format * Return a list of dictionaries sorted by the `popularity` key in descending order. Constraints * The list will contain between 1 and 10^5 dictionaries. * Each popularity score will be between 0 and 10^9. * Each title will be a non-empty string with a maximum length of 100 characters. Examples ```python >>> sort_books_by_popularity([{\\"title\\": \\"Book A\\", \\"popularity\\": 500}, {\\"title\\": \\"Book B\\", \\"popularity\\": 1500}, {\\"title\\": \\"Book C\\", \\"popularity\\": 300}]) [{\'title\': \'Book B\', \'popularity\': 1500}, {\'title\': \'Book A\', \'popularity\': 500}, {\'title\': \'Book C\', \'popularity\': 300}] >>> sort_books_by_popularity([{\\"title\\": \\"Book X\\", \\"popularity\\": 700}, {\\"title\\": \\"Book Z\\", \\"popularity\\": 700}, {\\"title\\": \\"Book Y\\", \\"popularity\\": 1000}]) [{\'title\': \'Book Y\', \'popularity\': 1000}, {\'title\': \'Book X\', \'popularity\': 700}, {\'title\': \'Book Z\', \'popularity\': 700}] >>> sort_books_by_popularity([{\\"title\\": \\"Book 1\\", \\"popularity\\": 42}]) [{\'title\': \'Book 1\', \'popularity\': 42}] ``` Performance Requirements * The expected time complexity should be O(N log N), where N is the number of books. * The expected space complexity should be O(N). Implementation Notes * If two books have the same popularity score, their relative order should be the same as in the input list. * You may use the built-in sorting functions provided by Python to achieve the desired outcomes. * Consider edge cases such as an empty list or a list where all books have the same popularity score.","solution":"def sort_books_by_popularity(books): Sorts the books by their popularity in descending order. :param books: List of dictionaries with \\"title\\" and \\"popularity\\" keys :return: List of dictionaries sorted by the \\"popularity\\" key in descending order return sorted(books, key=lambda book: book[\'popularity\'], reverse=True)"},{"question":"# Scenario You are developing a system to automatically generate documentation for a database of known engineering materials. To provide comprehensive details for each material, you need to compute the material\'s Young\'s modulus given its stress and strain data. This information is critical in material science for understanding material stiffness and elasticity under various loading conditions. # Task Description Implement a Python function `compute_youngs_modulus` that calculates the Young\'s modulus of a material given its stress-strain data. The function should be able to handle a list of stress and strain values, returning a corresponding list of computed Young\'s modulus values. # Function Signature ```python def compute_youngs_modulus( stresses: list[float], strains: list[float] ) -> list[float]: ``` # Input - `stresses`: A list of stress values for the material, where each value is a positive float, measured in Pascals (Pa). For a single measurement, this list will have one element. - `strains`: A list of strain values for the material, where each value is a positive float (dimensionless). It must have the same length as `stresses`. # Output - A list of float values, where each value corresponds to the Young\'s modulus for the respective pair of stress and strain. # Constraints - You must handle invalid inputs such as negative or zero values for stress or strain by raising a `ValueError`. - The lengths of `stresses` and `strains` will always be the same. # Performance Requirements - Your solution should maintain O(n) time complexity for iterating through the provided lists. - No extra space beyond the input size should be needed. # Example ```python # Example 1 stresses = [1000000, 2500000] strains = [0.002, 0.005] # Expected: [500000000.0, 500000000.0] print(compute_youngs_modulus(stresses, strains)) # Example 2 stresses = [2000000] strains = [0.004] # Expected: [500000000.0] print(compute_youngs_modulus(stresses, strains)) ``` # Notes - Ensure proper error handling. - Return the computed Young\'s modulus values in the same order as the input pairs. - Young\'s modulus is calculated using the formula: ( E = frac{text{stress}}{text{strain}} )","solution":"def compute_youngs_modulus(stresses, strains): Computes the Young\'s modulus of a material given its stress and strain data. Parameters: - stresses: list of floats representing the stress values in Pascals (Pa). - strains: list of floats representing the strain values (dimensionless). Returns: A list of floats where each value is the Young\'s modulus for the corresponding stress and strain. if len(stresses) != len(strains): raise ValueError(\\"The lengths of stresses and strains must be the same.\\") youngs_modulus_values = [] for stress, strain in zip(stresses, strains): if stress <= 0 or strain <= 0: raise ValueError(\\"Stress and strain values must be positive.\\") youngs_modulus_values.append(stress / strain) return youngs_modulus_values"},{"question":"# Problem Statement You are tasked with writing a function that calculates the number of possible unique lottery ticket combinations given the constraints of a lottery game. In this lottery game: - There are `m` balls, each with a unique number from 1 to `m`. - A player selects `k` balls, and the order of selection does not matter. - A ticket is considered unique if the combination of selected numbers is different from any other previously chosen set, regardless of the order. Your goal is to implement a function that returns the count of such unique combinations. # Function Signature ```python def count_lottery_combinations(m: int, k: int) -> int: pass ``` # Input * `m` (integer): The total number of unique balls in the lottery, where `1 <= m <= 100`. * `k` (integer): The number of balls a player selects, where `1 <= k <= m`. # Output * The function should return an integer indicating the total number of unique lottery combinations. # Example ```python assert count_lottery_combinations(50, 5) == 2118760 assert count_lottery_combinations(30, 10) == 30045015 assert count_lottery_combinations(10, 5) == 252 ``` # Constraints * Assume a high level of computational efficiency. Consider optimizations that may enhance performance given the constraints. You may use the following helper function for binomial coefficient calculation: ```python def choose(n: int, r: int) -> int: ret = 1.0 for i in range(1, r + 1): ret *= (n + 1 - i) / i return round(ret) ``` # Notes * Your implementation should be as efficient and clean as possible, respecting the constraints. * Think about using mathematical principles to solve the combination problem efficiently.","solution":"def count_lottery_combinations(m: int, k: int) -> int: Calculate the number of unique lottery combinations. Parameters: m (int): The total number of unique balls in the lottery. k (int): The number of balls a player selects. Returns: int: The total number of unique lottery combinations. from math import comb return comb(m, k)"},{"question":"# Coding Question: Permutation Shifter **Problem Statement:** You are given an array of distinct positive integers and a number ( k ). Your task is to circularly shift the elements of the array to the right by ( k ) positions. After shifting, return the resulting array. A circular shift means that elements that are shifted beyond the end of the array will reappear at the beginning. **Input:** - An array of distinct positive integers `arr` of length ( n ). - An integer ( k ) where ( k ) could be any integer (positive, negative, or zero). **Output:** - A list representing the array after the circular shift by ( k ) positions. **Constraints:** - ( 1 leq n leq 10^5 ) (length of the array) - ( 1 leq text{arr[i]} leq 10^9 ) (elements of the array are distinct positive integers) - ( -10^9 leq k leq 10^9 ) (shifting positions) **Performance Requirements:** - Achieve the solution in ( O(n) ) time complexity. - Efficiently handle large values of ( k ) in comparison to ( n ). **Example:** Consider the following example: ```python arr = [1, 2, 3, 4, 5] k = 2 ``` The output should be: ``` [4, 5, 1, 2, 3] ``` Because shifting the array to the right by 2 positions results in ( [4, 5, 1, 2, 3] ). **Function Signature:** ```python def circular_shift(arr: List[int], k: int) -> List[int]: pass ``` **Implementation:** Implement the function `circular_shift` which takes the array and the shift count ( k ) as inputs and returns the array after performing the circular shift by ( k ) positions. Remember: - A right circular shift by a positive ( k ) or negative ( k ) should be handled. - The value of ( k ) could be larger than the array length `n`, so handle it using a modular arithmetic approach. **Example Execution:** ```python >>> circular_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_shift([1, 2, 3, 4, 5], -1) [2, 3, 4, 5, 1] >>> circular_shift([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] ``` Good luck! Show your skills in handling circular shifts efficiently using modular arithmetic.","solution":"def circular_shift(arr, k): Circularly shifts the elements of the array to the right by k positions. n = len(arr) k = k % n # Normalize k to be within the bounds of the array length return arr[-k:] + arr[:-k]"},{"question":"# Matrix Element Product You are tasked with implementing a method that computes the element-wise product of two matrices within a class called `MatrixOperations`. **Task**: Add the following method to the `MatrixOperations` class: ```python def elementwise_product(self): Compute the element-wise product of two matrices. :return: A numpy array representing the element-wise product of self.mat1 and self.mat2. return self.mat1 * self.mat2 ``` **Objective**: You need to define this method such that it operates on the class\'s internal attributes (`mat1` and `mat2`). Ensure your implementation correctly updates any internal state and handles the computations as specified. **Input/Output**: * **Input**: The method will use existing attributes (`self.mat1`, `self.mat2`). * **Output**: A numpy array representing the element-wise product of the two matrices. **Constraints**: * Matrices `mat1` and `mat2` are numpy arrays of the same shape. **Performance**: Ensure your implementation handles large matrices efficiently. **Scenario**: You are analyzing the combined effect of different layers of data in a given dataset. The element-wise product will provide an insight into how two layers interact, on a per-element basis. Example: ```python # Given input matrices mat1 = np.array([[1, 2], [3, 4]]) mat2 = np.array([[5, 6], [7, 8]]) # Expected Output # Element-wise product np.array([[5, 12], [21, 32]]) ``` Add your method definition to the `MatrixOperations` class and verify its correctness based on the provided example.","solution":"import numpy as np class MatrixOperations: def __init__(self, mat1, mat2): Initialize with two matrices. self.mat1 = mat1 self.mat2 = mat2 def elementwise_product(self): Compute the element-wise product of self.mat1 and self.mat2. :return: A numpy array representing the element-wise product of self.mat1 and self.mat2. return self.mat1 * self.mat2"},{"question":"# Problem Statement You are given a binary tree, write a function `invert_tree` that inverts the tree. Inverting a binary tree means swapping the left and right children of all nodes in the tree. # Function Specifications Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: ``` Input - `root (TreeNode)`: The root node of the binary tree. Output - `TreeNode`: The root node of the inverted binary tree. # Example Example 1: ```plaintext Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` Example 2: ```plaintext Input: 1 / 2 3 Output: 1 / 3 2 ``` # Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - `-100 <= Node.val <= 100` # Notes - You may implement the function recursively or iteratively, but ensure it handles the tree manipulation without excessive computational overhead. - Focus on maintaining the tree\'s structure and node integrity while inverting the binary tree. - Consider edge cases, such as empty trees (null root), or single-node trees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping its left and right children nodes at every level. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Scenario You are tasked with developing a feature for an online marketplace that allows users to quickly search for products based on specific criteria. To improve search efficiency, you need to implement the Binary Search Algorithm for a pre-sorted list of product prices. This feature will enable rapid searches, making the user experience smoother. # Task Implement the `binary_search` function that searches for a given target price within a sorted list of product prices. # Function Signature ```python def binary_search(prices: list[float], target: float) -> int: pass ``` # Parameters * `prices` (list[float]): A sorted list of floating point numbers representing product prices. * `target` (float): The target price to search for. # Output * Returns an integer representing the index of the target price if it is found in the list. * If the target price is not found, returns -1. # Constraints * All elements in the `prices` list are unique. * The `prices` list is sorted in ascending order. * The length of the `prices` list is at least 1. # Requirements 1. **Input Validation**: * Verify that the `prices` list is sorted and contains unique elements. * Ensure that the `prices` list has at least one element. 2. **Algorithm Implementation**: * Implement the Binary Search algorithm efficiently. 3. **Error Handling**: * Raise appropriate errors for invalid inputs. # Example ```python >>> prices = [5.99, 12.49, 19.99, 29.99, 49.99] >>> target = 19.99 >>> binary_search(prices, target) 2 >>> prices = [5.99, 12.49, 19.99, 29.99, 49.99] >>> target = 25.00 >>> binary_search(prices, target) -1 ``` # Notes Ensure the Binary Search implementation is efficient with a time complexity of O(log n). Test the function thoroughly to handle edge cases, such as the target price being the first or last element in the list, and scenarios where the target price is not present in the list.","solution":"def binary_search(prices: list[float], target: float) -> int: Searches for the target price in a sorted list of prices using binary search. Args: prices (list[float]): A sorted list of product prices. target (float): The target price to search for. Returns: int: The index of the target price if found, otherwise -1. left, right = 0, len(prices) - 1 while left <= right: mid = (left + right) // 2 if prices[mid] == target: return mid elif prices[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement **Scenario**: You are working on an algorithm to help a logistics company optimize their delivery processes. The company operates multiple delivery trucks, each capable of carrying packages of various weights. To balance the load across trucks, they aim to distribute the packages as evenly as possible by weight. **Task**: Implement a function `load_balancer(weights: List[int], k: int) -> int` that determines the minimum possible maximum weight any single truck would have to carry when distributing `weights` among `k` trucks. **Function Signature**: ```python def load_balancer(weights: List[int], k: int) -> int: ``` **Input**: - A list of integers `weights` where each integer represents the weight of a package. The length of `weights` will be between 1 and 1000, inclusive. Each weight will be a positive integer between 1 and 1000. - An integer `k`, representing the number of trucks. `1 <= k <= len(weights)`. **Output**: - An integer representing the minimum possible maximum weight any truck would carry after the optimal distribution of packages. # Constraints: - Each package must be assigned to exactly one truck. - No package can be split or reassigned to more than one truck. # Requirements: - Utilize a binary search algorithm to find the optimal weight distribution efficiently. - Implement necessary utility functions to check if a given maximum load is feasible or not. # Performance: - The function should ideally use binary search combined with a linear verification step to achieve an efficient solution, maximizing feasibility checks. # Example: ```python assert load_balancer([10, 20, 30, 40, 50], 2) == 90 assert load_balancer([1, 2, 3, 4, 5], 2) == 9 ``` **Note**: Ensure that the function accounts for various scenarios such as loads being evenly split or significantly skewed, and it should handle edge cases efficiently.","solution":"from typing import List def can_distribute(weights: List[int], k: int, max_weight: int) -> bool: current_sum = 0 required_trucks = 1 for weight in weights: if current_sum + weight > max_weight: required_trucks += 1 current_sum = weight if required_trucks > k: return False else: current_sum += weight return True def load_balancer(weights: List[int], k: int) -> int: left = max(weights) right = sum(weights) while left < right: mid = (left + right) // 2 if can_distribute(weights, k, mid): right = mid else: left = mid + 1 return left"},{"question":"# Advanced Problem: Optimizing JSON Data Reduction with Multi-threading Scenario You are tasked with enhancing the provided implementation of a JSON data reduction algorithm. Specifically, you need to ensure that it processes the JSON objects more efficiently by leveraging multi-threading to parallelize the parsing and reduction of the JSON data. # Problem Statement Write a Python function `optimized_json_reduction(input_file, output_file, target_fields, num_threads)` that reads a large JSON file containing an array of JSON objects, and writes a new JSON file containing only the specified target fields. Utilize multi-threading to improve the performance of the processing phase. Requirements: 1. **Input**: - `input_file`: a string representing the path to the JSON file to be processed. - `output_file`: a string representing the path to the JSON file where the reduced data will be written. - `target_fields`: a list of strings representing the fields to retain in each JSON object. - `num_threads`: an integer representing the number of threads to use for parallel processing. 2. **Output**: - The function should output a JSON file at `output_file` containing the reduced data. 3. **Constraints**: - The implementation must utilize Python\'s `threading` or `concurrent.futures` modules to parallelize the parsing and reduction of the JSON data. - Ensure that the implementation can handle large JSON files efficiently without excessive memory usage. 4. **Performance**: - Optimize the implementation to minimize processing time and improve throughput using multi-threading. # Example: ```python optimized_json_reduction(\\"large_data.json\\", \\"reduced_data.json\\", [\\"id\\", \\"name\\", \\"email\\"], 4) ``` This call should process `large_data.json`, retain only the \\"id\\", \\"name\\", and \\"email\\" fields in each JSON object, and save the result to `reduced_data.json` using 4 threads for processing. # Additional Notes: - Handle edge cases such as malformed JSON objects or missing target fields. - Ensure proper synchronization and thread-safety during read and write operations. - Provide sufficient error handling for file I/O operations and JSON parsing. --- This question is designed to integrate seamlessly with the style, complexity, and scope of the provided sample question. It requires a deep understanding of multi-threading, file I/O, and JSON processing in Python, aligning it with the advanced nature of the original question.","solution":"import json import threading from concurrent.futures import ThreadPoolExecutor def process_chunk(data_chunk, target_fields): Process a chunk of data by retaining only the target fields. :param data_chunk: List of dictionaries to process. :param target_fields: List of fields to retain. :return: Processed list of dictionaries. reduced_chunk = [] for item in data_chunk: reduced_item = {field: item.get(field) for field in target_fields} reduced_chunk.append(reduced_item) return reduced_chunk def optimized_json_reduction(input_file, output_file, target_fields, num_threads): Reads a large JSON file, processes it with multi-threading to keep only target fields, and writes the processed data to a new JSON file. :param input_file: Path to the input JSON file. :param output_file: Path to the output JSON file. :param target_fields: List of fields to retain in each JSON object. :param num_threads: Number of threads to use for processing. with open(input_file, \'r\') as f: data = json.load(f) chunk_size = len(data) // num_threads chunks = [data[i : i + chunk_size] for i in range(0, len(data), chunk_size)] reduced_data = [] with ThreadPoolExecutor(max_workers=num_threads) as executor: futures = [executor.submit(process_chunk, chunk, target_fields) for chunk in chunks] for future in futures: reduced_data.extend(future.result()) with open(output_file, \'w\') as f: json.dump(reduced_data, f, indent=4)"},{"question":"# Coding Assessment Question **Title**: Implement a Custom Roman Numeral Converter **Objective**: Create a pair of functions to convert integers to Roman numerals and vice versa. Ensure that the implementation handles edge cases and supports up to a specified limit. **Context**: A historical researcher needs to convert various dates and numerals between the standard decimal system and the Roman numeral system for their work. They need a reliable tool to handle this conversion process accurately. **Task**: Write two functions `to_roman` and `from_roman` to convert integers to Roman numerals and Roman numerals to integers, respectively. The functions should adhere to the traditional Roman numeral system conventions and include basic error handling for invalid inputs. # Requirements Function Definitions ```python def to_roman(num: int) -> str: Convert an integer to a Roman numeral. Args: num (int): The integer to be converted to a Roman numeral. Returns: str: The Roman numeral representation of the given integer. pass def from_roman(s: str) -> int: Convert a Roman numeral to an integer. Args: s (str): The Roman numeral to be converted. Returns: int: The integer representation of the given Roman numeral. pass ``` # Constraints and Input: 1. **Integer Range**: The integer values should be between 1 and 3999 (inclusive). 2. **Roman Numeral Rules**: The Roman numeral system should follow the standard rules: - Roman numerals are normally written largest to smallest from left to right. - Only one exception to the rule is: the numeral for four is not IIII. Instead, the number four is written as IV. Similarly, nine is written as IX. - There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. 3. **Invalid Roman Numerals**: The function `from_roman` should handle inputs invalid by these rules gracefully, for instance, escape characters, invalid repeated characters, etc. Examples: **Example 1** ```python num = 1987 roman = to_roman(num) print(roman) # Output should be \'MCMLXXXVII\' print(from_roman(roman)) # Output should be 1987 ``` **Example 2** ```python num = 4 roman = to_roman(num) print(roman) # Output should be \'IV\' print(from_roman(roman)) # Output should be 4 ``` **Example 3** ```python roman = \\"MMXXII\\" integer = from_roman(roman) print(integer) # Output should be 2022 print(to_roman(integer)) # Output should be \'MMXXII\' ``` Performance Requirements: - The solution should handle conversions efficiently for integer values within the specified range. # Assumptions: - You can assume valid input is provided for `to_roman`. - The `from_roman` function needs to handle invalid Roman numerals and return appropriate errors or exceptions as needed.","solution":"def to_roman(num: int) -> str: Convert an integer to a Roman numeral. Args: num (int): The integer to be converted to a Roman numeral. Returns: str: The Roman numeral representation of the given integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syb[i] num -= val[i] i += 1 return roman_numeral def from_roman(s: str) -> int: Convert a Roman numeral to an integer. Args: s (str): The Roman numeral to be converted. Returns: int: The integer representation of the given Roman numeral. roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 num = 0 while i < len(s): if i+1<len(s) and s[i:i+2] in roman_to_int: num += roman_to_int[s[i:i+2]] i += 2 else: num += roman_to_int[s[i]] i += 1 return num"},{"question":"# Objective: Parse a JSON object from a string, traverse its nested structure, and retrieve a specific value by a given key path. # Problem Statement: Write a function `get_value_by_path(data: str, path: List[str]) -> Any` that parses a JSON object given as a string and retrieves the value located at a specified path within the nested structure. The function should: 1. Parse the JSON string into a Python dictionary. 2. Traverse the JSON object according to the provided list of keys. 3. Return the corresponding value if the path exists. # Input: * `data`: A string representing the JSON object. * `path`: A list of strings representing the keys to traverse in the JSON object. # Output: * Returns the value found at the given key path. If the path is invalid or does not exist, return `None`. # Constraints: * The JSON string is well-formed and does not contain syntax errors. * The keys in the path are valid strings. * Handle deeply nested structures and ensure efficient traversal. # Example Usage: ```python data = \'{\\"a\\": {\\"b\\": {\\"c\\": \\"d\\", \\"e\\": [1, 2]}, \\"f\\": 42}, \\"g\\": \\"hello\\"}\' assert get_value_by_path(data, [\\"a\\", \\"b\\", \\"c\\"]) == \\"d\\" assert get_value_by_path(data, [\\"a\\", \\"b\\", \\"e\\"]) == [1, 2] assert get_value_by_path(data, [\\"g\\"]) == \\"hello\\" assert get_value_by_path(data, [\\"a\\", \\"z\\"]) == None ``` # Implementation Note: * Use the `json` module for parsing the JSON string. * Employ a recursive or iterative approach to traverse the nested structure. * Ensure that your solution handles different JSON types such as objects, arrays, strings, numbers, and booleans efficiently.","solution":"import json from typing import Any, List def get_value_by_path(data: str, path: List[str]) -> Any: Parses the JSON string and retrieves the value located at the specified path. :param data: JSON string :param path: List of keys representing the path to traverse :return: The value found at the given key path, or None if the path is invalid try: json_data = json.loads(data) except json.JSONDecodeError: return None current = json_data for key in path: if isinstance(current, dict) and key in current: current = current[key] else: return None return current"},{"question":"Problem Statement You are given an array of integers representing the elevation map where the width of each bar is 1. Imagine that the elevation map is a histogram where each bar\'s height represents the height of the terrain at that point. Your task is to compute how much water it can trap after raining. Write a function `trap_water(heights: List[int]) -> int` that takes a single parameter: - `heights` (a list of integers): The elevation map represented as a list of non-negative integers. The function should return an integer representing the total units of water that can be trapped. # Constraints 1. The length of the array `heights` will be at most `10^4`. 2. The elements of the array `heights` will be non-negative integers and will not exceed `10^5`. # Example ```python def trap_water(heights: List[int]) -> int: # TODO: Write your implementation here ``` Input: ```python trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) ``` Output: ```python 6 ``` Input: ```python trap_water([4,2,0,3,2,5]) ``` Output: ```python 9 ``` # Notes - Your solution should be efficient with a time complexity of O(n) where n is the length of the input array. - Consider edge cases such as an array where no water can be trapped, or an array with all elements of the same height, or arrays with only one or two elements.","solution":"from typing import List def trap_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"# Context You are given a dictionary that maps words to their definitions. Your task is to add functionality that allows merging multiple dictionaries, such that in the case of key collisions, the definition in the result dictionary should be a list containing all the unique definitions from the source dictionaries. # Task Implement a function `merge_dicts(dict_list: List[Dict[str, str]]) -> Dict[str, List[str]]` that merges a list of dictionaries into a single dictionary, where definitions for the same word are stored in a list of unique values. # Function Signature ```python def merge_dicts(dict_list: List[Dict[str, str]]) -> Dict[str, List[str]]: # Your code here ``` # Input * A list of dictionaries, `dict_list`, where each dictionary maps words (strings) to their definitions (strings). # Output * A single dictionary where each key is a word, and each value is a list of unique definitions for that word. # Constraints * 1 <= len(dict_list) <= 100 * Each dictionary contains 0 to 100 key-value pairs. * Word definitions are non-empty strings. # Example ```python >>> dict_list = [ >>> {\\"apple\\": \\"a fruit\\", \\"table\\": \\"a piece of furniture\\"}, >>> {\\"apple\\": \\"a tech company\\", \\"table\\": \\"data arrangement\\", \\"python\\": \\"a programming language\\"}, >>> {\\"table\\": \\"a piece of furniture\\", \\"python\\": \\"a type of snake\\"} >>> ] >>> merge_dicts(dict_list) {\'apple\': [\'a fruit\', \'a tech company\'], \'table\': [\'a piece of furniture\', \'data arrangement\'], \'python\': [\'a programming language\', \'a type of snake\']} ``` # Notes * The order of the definitions in the output lists does not matter. * Ensure that definitions for the same word are unique in the resulting list.","solution":"from typing import List, Dict def merge_dicts(dict_list: List[Dict[str, str]]) -> Dict[str, List[str]]: result = {} for dictionary in dict_list: for word, definition in dictionary.items(): if word not in result: result[word] = [definition] else: if definition not in result[word]: result[word].append(definition) return result"},{"question":"# Objective Write functions to calculate the monthly mortgage payment and the total payment amount for a fixed-rate mortgage. The functions should take into consideration the principal amount, the annual interest rate, and the term of the loan in years. # Question You need to implement two functions: `monthly_mortgage_payment` and `total_payment_amount`. These functions compute the monthly payment and the total payment amount on a fixed-rate mortgage given specific parameters. `monthly_mortgage_payment` This function calculates the monthly mortgage payment using the loan principal, annual interest rate, and the loan term in years. **Function Signature:** ```python def monthly_mortgage_payment(principal: float, annual_interest_rate: float, term_years: float) -> float: ``` **Input:** * `principal` (float): The principal loan amount, greater than 0. * `annual_interest_rate` (float): The annual interest rate as a percentage, non-negative. * `term_years` (float): The term of the loan in years, greater than 0. **Output:** * Returns the calculated monthly mortgage payment as a float. * Raises `ValueError` if principal <= 0, annual_interest_rate < 0, or term_years <= 0. `total_payment_amount` This function computes the total amount paid over the lifetime of the loan. **Function Signature:** ```python def total_payment_amount(principal: float, annual_interest_rate: float, term_years: float) -> float: ``` **Input:** * `principal` (float): The principal loan amount, greater than 0. * `annual_interest_rate` (float): The annual interest rate as a percentage, non-negative. * `term_years` (float): The term of the loan in years, greater than 0. **Output:** * Returns the total payment amount as a float. * Raises `ValueError` if principal <= 0, annual_interest_rate < 0, or term_years <= 0. # Example ```python # Example function calls and expected results: print(monthly_mortgage_payment(200000.0, 5.0, 30)) # Expected output: 1074.204231415352 print(total_payment_amount(200000.0, 5.0, 30)) # Expected output: 386313.5233095264 ``` # Constraints 1. Ensure proper validation of input parameters as described. 2. Implement accurate floating-point arithmetic for loan calculations. 3. Your implementations should be efficient with time complexity of O(1). 4. Use appropriate exception handling for invalid input values. The formula for calculating the monthly payment is: [ M = P times frac{r(1+r)^n}{(1+r)^n - 1} ] where: * ( M ) is the monthly payment, * ( P ) is the principal loan amount, * ( r ) is the monthly interest rate (annual interest rate divided by 12, then divided by 100), * ( n ) is the total number of payments (loan term in years multiplied by 12). And the total payment amount is simply the monthly payment multiplied by the number of payments: [ text{Total Payment} = M times n ]","solution":"def monthly_mortgage_payment(principal: float, annual_interest_rate: float, term_years: float) -> float: This function calculates the monthly mortgage payment given the principal, annual interest rate, and term years. Raises ValueError for invalid inputs. if principal <= 0 or annual_interest_rate < 0 or term_years <= 0: raise ValueError(\\"Invalid input values, ensure principal > 0, annual_interest_rate >= 0, term_years > 0.\\") monthly_interest_rate = annual_interest_rate / 12 / 100 total_payments = term_years * 12 if monthly_interest_rate == 0: # Special case for 0% interest return principal / total_payments monthly_payment = principal * (monthly_interest_rate * (1 + monthly_interest_rate)**total_payments) / ((1 + monthly_interest_rate)**total_payments - 1) return monthly_payment def total_payment_amount(principal: float, annual_interest_rate: float, term_years: float) -> float: This function calculates the total payment amount for the life of the mortgage. Raises ValueError for invalid inputs. if principal <= 0 or annual_interest_rate < 0 or term_years <= 0: raise ValueError(\\"Invalid input values, ensure principal > 0, annual_interest_rate >= 0, term_years > 0.\\") monthly_payment = monthly_mortgage_payment(principal, annual_interest_rate, term_years) total_payments = term_years * 12 total_payment = monthly_payment * total_payments return total_payment"},{"question":"Balanced Parentheses Validation You are designing a syntax checker for a programming language that uses different types of parentheses: `()`, `{}`, and `[]`. Your task is to implement a class `ParenthesesValidator` which will verify whether the parentheses in a given string are balanced. Input and Output Formats * **Initialization**: - Input: N/A (no initialization required for this class). * **Methods**: - Method: `is_balanced(s)` - Input: `s`, a string containing any combination of characters, including `()`, `{}`, and `[]`. - Output: Returns `True` if the parentheses in the string are balanced, and `False` otherwise. - Constraints: `1 <= len(s) <= 10^5` - Example: Given `s = \\"{[()]}\\"`, `is_balanced(s)` should return `True`. - Example: Given `s = \\"[(])\\"`, `is_balanced(s)` should return `False`. Implementation Requirements 1. Use a stack data structure to track the closing parentheses. 2. Ensure the method runs in O(N) time, where N is the length of the string. 3. Handle cases where the string contains characters other than parentheses by ignoring them in the validation. ```python class ParenthesesValidator: def is_balanced(self, s: str) -> bool: stack = [] # Define matching pairs matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses.values(): # If it\'s an opening bracket, push to stack stack.append(char) elif char in matching_parentheses.keys(): # If it\'s a closing bracket, check for unbalanced condition if stack == [] or stack.pop() != matching_parentheses[char]: return False # Return True if stack is empty, which means all opening brackets matched return stack == [] ``` # Explanation 1. **Initialization**: - No attributes required to be initialized for this class. 2. **Methods**: - `is_balanced(s)`: This method is responsible for checking if the parentheses in the string `s` are balanced. It uses a stack to keep track of unmatched opening parentheses and matches them against incoming closing parentheses. 3. **Stack-based Approach**: - When an opening parenthesis is encountered (`({[`), it is pushed onto the stack. - When a closing parenthesis is encountered (`)}]`), it checks if it matches the top of the stack, popping the stack if it does. If it doesn\'t match or if the stack is empty when trying to pop, the string is immediately deemed unbalanced. - At the end, if the stack is empty, all opening parentheses were matched correctly, and the string is considered balanced. This question tests the candidate\'s understanding of stack data structures, their ability to handle different types of parentheses, and the ability to process strings efficiently.","solution":"class ParenthesesValidator: def is_balanced(self, s: str) -> bool: stack = [] # Define matching pairs matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses.values(): # If it\'s an opening bracket, push to stack stack.append(char) elif char in matching_parentheses.keys(): # If it\'s a closing bracket, check for unbalanced condition if stack == [] or stack.pop() != matching_parentheses[char]: return False # Return True if stack is empty, which means all opening brackets matched return stack == []"},{"question":"# Grid Illumination System Context You are tasked with designing a grid illumination system to track the lighting status of grid cells. Each cell in the grid can either be lit or dark, and you can toggle the status of any cell or query its current status. Requirements Write a class `GridIllumination` with the following methods: 1. **`__init__(self, n: int)`**: Initialize your grid as an `n x n` grid where all cells start dark. This method should properly initialize the internal state to represent the grid. 2. **`toggle(self, row: int, col: int)`**: Toggle the status of the cell at the given coordinates (`(row, col)`). If the cell was dark, it should become lit, and if it was lit, it should become dark. 3. **`query(self, row: int, col: int) -> bool`**: Return the current status of the cell at the given coordinates. `True` indicates the cell is lit, and `False` indicates it is dark. 4. **`__len__(self) -> int`**: Return the number of cells that are currently lit in the grid. Input and Output * **Input**: * `__init__` method takes a single integer `n` indicating the size of the grid. * `toggle` method takes two integer coordinates `row` and `col`. * `query` method takes two integer coordinates `row` and `col`. * Grid coordinates are zero-based. * **Output**: * `toggle` method does not return anything. * `query` method returns a boolean value. * `__len__` method returns an integer. * **Constraints**: * (1 leq n leq 1000) * (0 leq row, col < n) Example ```python grid = GridIllumination(5) grid.toggle(2, 3) # Toggle cell (2, 3) to lit assert grid.query(2, 3) == True assert len(grid) == 1 grid.toggle(2, 3) # Toggle cell (2, 3) to dark assert grid.query(2, 3) == False assert len(grid) == 0 grid.toggle(0, 0) # Toggle cell (0, 0) to lit grid.toggle(1, 1) # Toggle cell (1, 1) to lit assert len(grid) == 2 ```","solution":"class GridIllumination: def __init__(self, n: int): self.n = n self.grid = [[False] * n for _ in range(n)] self.lit_count = 0 def toggle(self, row: int, col: int): if self.grid[row][col]: self.grid[row][col] = False self.lit_count -= 1 else: self.grid[row][col] = True self.lit_count += 1 def query(self, row: int, col: int) -> bool: return self.grid[row][col] def __len__(self) -> int: return self.lit_count"},{"question":"# Problem Statement You are given a list of integers `nums` and an integer `k`. Your task is to find the length of the smallest subarray that has a sum greater than or equal to `k`. If no such subarray exists, return `-1`. Implement the function `min_subarray_len(nums: List[int], k: int) -> int` that returns the length of the smallest subarray with sum ≥ `k`, or `-1` if no such subarray exists. # Input - A list of integers `nums` where `1 ≤ len(nums) ≤ 10^5` and `-10^4 ≤ nums[i] ≤ 10^4`. - An integer `k` where `1 ≤ k ≤ 10^9`. # Output - An integer representing the length of the smallest subarray with sum ≥ `k`, or `-1` if no such subarray exists. # Example ```python >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 ``` # Constraints - Assume valid input as per the definitions above. - The implementation should be efficient to handle lengths of `nums` up to `10^5`. # Performance Requirements - The solution should use an efficient algorithm to ensure it can handle the upper limit of inputs within a reasonable time frame. Aim to use algorithms with linear or near-linear complexity where possible. # Notes - Consider the use of sliding window techniques to find the subarray efficiently. - Be cautious of potential cases where no subarray satisfies the condition and handle them appropriately.","solution":"def min_subarray_len(nums, k): Finds the length of the smallest subarray with a sum greater than or equal to k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Length of the smallest subarray with sum >= k, or -1 if no such subarray exists. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Problem Description: The challenge you face involves an inventory management system for a large e-commerce platform. You need to implement a feature that accurately suggests the top k most frequently sold items based on their sales data. Given a list of item IDs where each ID represents a single sale, determine the k most frequent items in descending order of frequency. **Function Specification**: Implement the function `top_k_frequent_items(sales: List[int], k: int) -> List[int]`. This function should take a list of integers `sales` and an integer `k` as input and return a list of the top k most frequently sold items. **Constraints**: * The list `sales` will contain at least one element and at most 10^5 elements. * Each item ID in the `sales` list is a positive integer. * The integer `k` will be a positive integer and at most the number of unique elements in the `sales` list. **Input**: * `sales` - List of integers where each integer represents an item sold. * `k` - A positive integer representing the number of top items to return. **Output**: * A list of integers representing the item IDs of the top k most frequently sold items in descending order of their frequency. **Examples**: ```python top_k_frequent_items([1, 1, 3, 2, 2, 2, 3, 1, 4, 2], 2) == [2, 1] top_k_frequent_items([7, 7, 5, 5, 5, 6, 7], 1) == [7] top_k_frequent_items([5, 5, 5, 6, 6, 7, 7, 7, 7, 8], 3) == [7, 5, 6] top_k_frequent_items([10, 20, 30], 2) == [10, 20] ``` **Function Signature**: ```python from typing import List def top_k_frequent_items(sales: List[int], k: int) -> List[int]: # Implement the function pass ``` **Notes**: * Raise a `ValueError` if k is greater than the number of unique items in the `sales` list. * Ensure to handle cases with ties appropriately. In the event of a tie in frequency, return the items that appear earlier in the sales list. * Aim to optimize the function to handle large inputs efficiently.","solution":"from typing import List from collections import Counter def top_k_frequent_items(sales: List[int], k: int) -> List[int]: if k > len(set(sales)): raise ValueError(\\"k cannot be greater than the number of unique items in sales\\") # Count the frequency of each item frequency = Counter(sales) # Get the top k items based on frequency (using most_common from Counter) top_k_items = frequency.most_common(k) # Extract just the item ids from the most_common results return [item for item, count in top_k_items]"},{"question":"# Coding Assessment: Rainwater Trapping Context The \\"Rainwater Trapping\\" problem is a classic algorithmic challenge that tests your understanding of arrays, two-pointer techniques, and dynamic programming concepts. This problem is frequently encountered in technical coding interviews and closely evaluates your problem-solving and optimization skills. Problem Statement Given an array of non-negative integers representing the elevation map where the width of each bar is 1, compute how much water it can trap after raining. Function Signature ```python def trap(height: list) -> int: ``` Inputs - `height`: A list of non-negative integers where each integer represents the elevation of a bar. Outputs - Return an integer representing the total amount of trapped water. Constraints - The `height` array will have a length between 0 and 100,000. - Each element in `height` is a non-negative integer and does not exceed 100,000. Performance Requirements - The solution should have a time complexity of O(n), where n is the length of the `height` array. - The solution should utilize O(1) extra space, aside from the input array. Example ```python height = [0,1,0,2,1,0,1,3,2,1,2,1] print(trap(height)) # Output should be 6 ``` Hint - Use two-pointer technique: initialize two pointers at the beginning and end of the elevation map to compute trapped water iteratively. - Compare the height at both pointers and compute potential trapped water based on the shorter bar. Notes - Pay close attention to edge cases when the height array is empty or contains only one bar. - Accumulate water trapped above each bar based on the minimum height of the surrounding maximum heights. This problem should be approached with efficiency in mind, ensuring that solutions not only work correctly but do so within the given performance constraints.","solution":"def trap(height: list) -> int: if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"# Unique Single Number You are given an array of integers where every element appears thrice except for one. Find that single one that does not appear thrice. # Function Signature ```python def single_number(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers where every element appears exactly three times except for one element which appears once. * For example, `[2, 2, 3, 2]` means: * The number `2` appears three times. * The number `3` appears only once. # Output * Returns (int): The single number that does not appear thrice. # Constraints * 1 <= len(nums) <= 3 * 10^4 * -2^31 <= nums[i] <= 2^31 - 1 # Example ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Explanation For the provided example, the function should return `3` for the first example and `99` for the second example because `3` and `99` are the numbers that do not appear three times while the others do. # Notes * Optimal solutions with linear runtime complexity and without using extra memory are expected. * Consider bit manipulation techniques to achieve the desired result.","solution":"from typing import List def single_number(nums: List[int]) -> int: Given a list of integers where every element appears exactly three times except for one element that appears only once, return the unique element. ones, twos = 0, 0 for num in nums: twos |= ones & num ones ^= num common_bits = ones & twos ones &= ~common_bits twos &= ~common_bits return ones"},{"question":"# Problem: Sum of Digits in a Number You are given a positive integer and you need to compute the sum of its digits. Implement a function `sum_of_digits` that receives an integer and returns the sum of its digits. Input: * An integer `n` (1 <= n <= 10^18) Output: * An integer representing the sum of the digits in `n`. Requirements: * Your solution should efficiently compute the sum of the digits, even for large values of `n`. * Aim to minimize the complexity and use of auxiliary space. Example: ```python >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876) 30 >>> sum_of_digits(111111) 6 ``` Constraints: * The input integer will be positive and will not contain leading zeros. * Your implementation should handle the largest possible value for `n` efficiently.","solution":"def sum_of_digits(n): Returns the sum of the digits of a given number n. Parameters: n (int): The positive integer whose sum of digits is to be computed. Returns: int: The sum of the digits of n. return sum(int(digit) for digit in str(n))"},{"question":"# Problem Statement You are tasked with creating a function that normalizes a given string based on specific rules to produce a URL-friendly format. The function should ensure that the resulting string is suitable for use in web addresses by replacing spaces with hyphens, removing special characters, and converting all letters to lowercase. # Requirements: 1. The function should accept a string and return a normalized version suitable for URLs. 2. Replace all whitespace characters (spaces, tabs, etc.) with hyphens. 3. Remove all special characters except hyphens and underscores. 4. Convert all letters to lowercase. 5. The function should handle empty strings by returning an empty string. 6. Ensure that multiple consecutive hyphens are reduced to a single hyphen. # Implementation Details: * **Input Format**: A string that may contain uppercase/lowercase letters, digits, spaces, and special characters. * **Output Format**: A normalized string suitable for URL usage. # Constraints: - The input string will have a maximum length of 1000 characters. # Examples: ```python def normalize_string(input_str: str) -> str: Normalize a string for URL usage. Args: input_str: str - Input string Returns: str - Normalized string suitable for URLs Raises: ValueError - If input is not a string Examples: >>> normalize_string(\' Hello World! \') \'hello-world\' >>> normalize_string(\'My Blog _Post \') \'my-blog-_post\' >>> normalize_string(\'Special@Characters#Here\') \'specialcharactershere\' >>> normalize_string(\' \') \'\' >>> normalize_string(\'Normalize---This_string!\') \'normalize-this_string\' # Your code here # Example usage input_string = \'Hello World!\' print(normalize_string(input_string)) # Should return \'hello-world\' ``` Write the `normalize_string` function to meet the outlined requirements and ensure it passes all provided examples and edge cases.","solution":"import re def normalize_string(input_str: str) -> str: Normalize a string for URL usage. Args: input_str: str - Input string Returns: str - Normalized string suitable for URLs Raises: ValueError - If input is not a string if not isinstance(input_str, str): raise ValueError(\\"Input should be a string\\") # Convert to lowercase normalized_str = input_str.lower() # Replace all whitespace characters with hyphens normalized_str = re.sub(r\'s+\', \'-\', normalized_str) # Remove all special characters except hyphens and underscores normalized_str = re.sub(r\'[^w-]\', \'\', normalized_str) # Remove multiple consecutive hyphens normalized_str = re.sub(r\'-+\', \'-\', normalized_str) # Remove leading or trailing hyphens normalized_str = normalized_str.strip(\'-\') return normalized_str"},{"question":"# Pattern Matching in Strings Context Pattern matching is a fundamental aspect of string processing in computer science, with applications in search engines, text processing, and bioinformatics. This challenge involves developing an efficient algorithm to determine whether a given pattern exists within a specified text. Unlike simple substring search, this problem includes supporting wildcard characters. The pattern may contain two special wildcard characters: `?` which matches any single character, and `*` which matches any sequence of characters (including the empty sequence). Task Write a Python function `is_match(text: str, pattern: str) -> bool` that returns `True` if the entire text matches the given pattern according to the rules specified, and `False` otherwise. Input * A string `text` (1 ≤ len(text) ≤ 10^4) * A string `pattern` (1 ≤ len(pattern) ≤ 10^4) Output * A boolean `True` if the text matches the pattern, otherwise `False`. Constraints * The solution should optimize for performance, particularly handling the potential complexity introduced by the wildcard characters. * Consider edge cases, such as empty text or patterns with multiple wildcard characters. # Example ```python >>> is_match(\\"hello\\", \\"h?llo\\") True >>> is_match(\\"hello\\", \\"h*o\\") True >>> is_match(\\"hello\\", \\"he?lo*\\") False >>> is_match(\\"hello\\", \\"*\\") True >>> is_match(\\"hello\\", \\"?*o\\") True >>> is_match(\\"hello\\", \\"he*lo\\") True >>> is_match(\\"hello\\", \\"he?l?\\") True >>> is_match(\\"abcd\\", \\"a*d\\") True ``` Notes Develop an efficient algorithm that correctly handles both `?` and `*` wildcards in the pattern. The function should be able to determine matches within the given time and space constraints for the input sizes specified.","solution":"def is_match(text: str, pattern: str) -> bool: Determines if the given text matches the pattern. The pattern may contain the following wildcard characters: - \'?\' matches any single character. - \'*\' matches any sequence of characters (including the empty sequence). Args: text (str): The text to be matched. pattern (str): The pattern containing wildcards. Returns: bool: True if the text matches the pattern, False otherwise. # Dynamic programming table dp = [[False] * (len(text) + 1) for _ in range(len(pattern) + 1)] dp[0][0] = True # Empty pattern matches empty text # Initialize the first row for patterns that can match empty text for i in range(1, len(pattern) + 1): if pattern[i-1] == \'*\': dp[i][0] = dp[i-1][0] # Fill dp table for i in range(1, len(pattern) + 1): for j in range(1, len(text) + 1): if pattern[i-1] == \'?\' or pattern[i-1] == text[j-1]: dp[i][j] = dp[i-1][j-1] elif pattern[i-1] == \'*\': dp[i][j] = dp[i-1][j] or dp[i][j-1] return dp[len(pattern)][len(text)]"},{"question":"# Coding Assessment Question: Implement a Queue Using Stacks Context Using stack data structures, your task is to implement a queue class that mimics the behavior of a queue (FIFO) using two stacks (LIFO). The class should support standard queue operations: `enqueue`, `dequeue`, and `peek`. Input & Output *Input*: None for the class initialization; individual values for `enqueue`. *Output*: Value for `dequeue` and `peek`. Constraints 1. The functions should handle operations efficiently. 2. The `enqueue`, `dequeue`, and `peek` operations should collectively maintain O(1) amortized time complexity. Function Signature ```python class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Push element x to the back of queue. :type x: int :rtype: void self.stack1.append(x) def dequeue(self) -> int: Removes the element from in front of queue and returns that element. :rtype: int self.transfer_stacks() return self.stack2.pop() def peek(self) -> int: Get the front element. :rtype: int self.transfer_stacks() return self.stack2[-1] def empty(self) -> bool: Returns whether the queue is empty. :rtype: bool return not self.stack1 and not self.stack2 def transfer_stacks(self) -> None: Transfer elements from stack1 to stack2 if stack2 is empty. :rtype: void if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) ``` Scenario Consider the following scenario to further illustrate: ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.peek()) # Expected output: 1 print(queue.dequeue()) # Expected output: 1 print(queue.peek()) # Expected output: 2 ``` In the example above, initially, the queue is `1 -> 2 -> 3` (front to back). The `peek` operation returns the front element `1`, and after `dequeue`, the queue becomes `2 -> 3` with the new front `2`. Complete the implementation so that all the operations conform to the constraints and expected behaviors.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: self._transfer_stacks_if_needed() return self.stack2.pop() def peek(self) -> int: self._transfer_stacks_if_needed() return self.stack2[-1] def empty(self) -> bool: return not self.stack1 and not self.stack2 def _transfer_stacks_if_needed(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop())"},{"question":"# Parallel File Processing for Log Analysis You are required to implement a system to efficiently process large sets of log files stored in a directory. The primary tasks are to read the files, extract useful information (e.g., error messages), and aggregate the extracted data. The system should take advantage of parallel processing to speed up the analysis. # Requirements: 1. **Directory and File Handling**: - Implement functionality to recursively search through a directory for log files with a specific extension (e.g., `.log`). 2. **Parallel Processing**: - Make use of Python\'s multiprocessing library to process multiple files in parallel. 3. **Data Extraction**: - Implement a function to read in each log file and extract lines that contain a specified keyword (e.g., `ERROR`). 4. **Aggregation**: - Aggregate all the extracted lines into a single file (or data structure) that represents a summary of all errors found. 5. **Performance Logging**: - Include logging to track the time taken for processing each file and total time taken. 6. **Documentation**: - Document the entire workflow with comments on each step and functionality. # Specification: - Input: Directory path containing log files. - Output: File or data structure containing all extracted lines. - Constraints: - Log files are text files. - The system should handle a large number of files efficiently. - Keyword for extraction should be configurable. - Performance: Emphasis on efficient processing and usage of system resources through parallel execution. # Deliverables: - Complete the implementation following the outline provided. - Demonstrate the system\'s functionality using a sample dataset of log files. - Provide a brief report, including challenges faced, design decisions for parallel processing, and performance metrics. ```python Parallel Log File Processor for Error Aggregation import os from pathlib import Path import multiprocessing import time class ParallelLogProcessor: def __init__(self, log_dir, keyword, extension=\\".log\\"): self.log_dir = log_dir self.keyword = keyword self.extension = extension def find_log_files(self): # Recursively find log files in the directory log_files = [] for root, dirs, files in os.walk(self.log_dir): for file in files: if file.endswith(self.extension): log_files.append(os.path.join(root, file)) return log_files def extract_errors(self, log_file): # Extract lines containing the keyword errors = [] with open(log_file, \'r\') as file: for line in file: if self.keyword in line: errors.append(line.strip()) return errors def process_file(self, log_file): start_time = time.time() errors = self.extract_errors(log_file) processing_time = time.time() - start_time return errors, log_file, processing_time def aggregate_errors(self, log_files): pool = multiprocessing.Pool(processes=multiprocessing.cpu_count()) result = pool.map(self.process_file, log_files) pool.close() pool.join() return result def save_results(self, results, output_file): with open(output_file, \'w\') as file: for errors, log_file, processing_time in results: for error in errors: file.write(f\\"{log_file}: {error}n\\") def log_performance_metrics(self, results): total_time = sum(result[2] for result in results) print(f\\"Total processing time for {len(results)} files: {total_time} seconds\\") if __name__ == \\"__main__\\": Example demonstrating parallel log processing and error aggregation. log_dir = \\"path_to_logs\\" keyword = \\"ERROR\\" output_file = \\"aggregated_errors.txt\\" log_processor = ParallelLogProcessor(log_dir, keyword) log_files = log_processor.find_log_files() results = log_processor.aggregate_errors(log_files) log_processor.save_results(results, output_file) log_processor.log_performance_metrics(results) ``` Compose a report documenting your implementation, the data extraction procedure, and any optimizations made to enhance parallel processing efficiency.","solution":"Parallel Log File Processor for Error Aggregation import os from pathlib import Path import multiprocessing import time class ParallelLogProcessor: def __init__(self, log_dir, keyword, extension=\\".log\\"): self.log_dir = log_dir self.keyword = keyword self.extension = extension def find_log_files(self): # Recursively find log files in the directory log_files = [] for root, dirs, files in os.walk(self.log_dir): for file in files: if file.endswith(self.extension): log_files.append(os.path.join(root, file)) return log_files def extract_errors(self, log_file): # Extract lines containing the keyword errors = [] with open(log_file, \'r\') as file: for line in file: if self.keyword in line: errors.append(line.strip()) return errors def process_file(self, log_file): start_time = time.time() errors = self.extract_errors(log_file) processing_time = time.time() - start_time return errors, log_file, processing_time def aggregate_errors(self, log_files): pool = multiprocessing.Pool(processes=multiprocessing.cpu_count()) result = pool.map(self.process_file, log_files) pool.close() pool.join() return result def save_results(self, results, output_file): with open(output_file, \'w\') as file: for errors, log_file, processing_time in results: for error in errors: file.write(f\\"{log_file}: {error}n\\") def log_performance_metrics(self, results): total_time = sum(result[2] for result in results) print(f\\"Total processing time for {len(results)} files: {total_time} seconds\\") if __name__ == \\"__main__\\": Example demonstrating parallel log processing and error aggregation. log_dir = \\"path_to_logs\\" keyword = \\"ERROR\\" output_file = \\"aggregated_errors.txt\\" log_processor = ParallelLogProcessor(log_dir, keyword) log_files = log_processor.find_log_files() results = log_processor.aggregate_errors(log_files) log_processor.save_results(results, output_file) log_processor.log_performance_metrics(results)"},{"question":"# Context In a network of nodes representing cities connected by bidirectional roads, we want to ascertain the minimum cost of traveling between two cities. The costs of traveling the roads are given, and we need an efficient way to determine the least costly route between any two specified cities. # Problem Statement Write a function `minimum_travel_cost(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]` that determines the minimum travel cost for each query. The function should use an algorithm efficient enough to handle large inputs. # Function Signature ```python from typing import List, Tuple def minimum_travel_cost(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determines the minimum travel cost for each given pair of cities. :param n: An integer representing the number of cities. :param roads: A list of tuples, each containing three integers (u, v, w) representing a road between cities u and v with a travel cost of w. :param queries: A list of tuples, each containing two integers (a, b) for which the function should find the minimum travel cost between city a and city b. :returns: A list of integers representing the minimum travel cost for each query. ``` # Input - `n`: An integer ( (2 leq n leq 10^5) ), representing the number of cities. - `roads`: A list of tuples ( (1 leq text{len(roads)} leq 2 times 10^5) ), where each tuple ( (u, v, w) ) ( (1 leq u, v leq n, 1 leq w leq 10^4) ) represents a bidirectional road between city `u` and city `v` with a cost of `w`. - `queries`: A list of tuples ( (1 leq text{len(queries)} leq 10^5) ), where each tuple ( (a, b) ) ( (1 leq a, b leq n) ) represents a query asking for the minimum travel cost between city `a` and city `b`. # Output - Returns a list of integers, each representing the minimum travel cost between the corresponding pair of cities specified in the queries. # Example ```python assert minimum_travel_cost(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1)], [(1, 5), (2, 4)]) == [10, 6] ``` # Constraints - Ensure the solution is efficient for large inputs, especially in terms of time complexity. # Notes - Consider using advanced algorithms such as Dijkstra\'s or Floyd-Warshall for shortest path calculations. - Handle edge cases where there might be no path between the query cities (return -1 in such scenarios).","solution":"import heapq from typing import List, Tuple import sys def minimum_travel_cost(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: def dijkstra(start: int, graph: List[List[Tuple[int, int]]]) -> List[int]: min_cost = [sys.maxsize] * (n + 1) min_cost[start] = 0 pq = [(0, start)] # (cost, node) while pq: current_cost, current_node = heapq.heappop(pq) if current_cost > min_cost[current_node]: continue for neighbor, weight in graph[current_node]: cost = current_cost + weight if cost < min_cost[neighbor]: min_cost[neighbor] = cost heapq.heappush(pq, (cost, neighbor)) return min_cost # Building the graph graph = [[] for _ in range(n + 1)] # Graph from 1 to n for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Prepare to answer queries results = [] distance_cache = {} for a, b in queries: if a == b: results.append(0) continue if (a, b) in distance_cache: results.append(distance_cache[(a, b)]) else: min_cost_a = dijkstra(a, graph) distance_a_b = min_cost_a[b] if min_cost_a[b] != sys.maxsize else -1 distance_cache[(a, b)] = distance_a_b distance_cache[(b, a)] = distance_a_b results.append(distance_a_b) return results"},{"question":"# Problem Statement You are tasked with implementing a function `nearestPoints` that finds pairs of points in a 2D coordinate plane and returns the pair with the smallest Euclidean distance between them. # Requirements * Your function should expect a list of points, where each point is represented as a tuple of two integers (x, y). * The result should be a tuple containing two tuples, each representing one of the closest pair of points. # Function Signature ```python def nearestPoints(points: list) -> tuple: ``` # Input * `points` (list): A list of tuples, where each tuple contains two integers representing the coordinates of a point in a 2D plane. (0 <= len(points) <= 10^3) # Output * (tuple): A tuple containing two points (each represented as a tuple of two integers) with the smallest Euclidean distance between them. # Constraints * If the list contains fewer than two points, the function should return an empty tuple. * The input list must only contain tuples of length 2, each consisting of integers. Validate this as part of the function\'s requirements. * Ensure your implementation handles edge cases and optimizes performance where feasible. # Examples ```python >>> nearestPoints([(1, 2), (3, 4), (0, 2)]) ((1, 2), (0, 2)) >>> nearestPoints([(1, 2), (7, 8), (2, 3), (4, 5)]) ((1, 2), (2, 3)) >>> nearestPoints([(1, 1)]) tuple() ``` # Notes * Ensure the function raises an error if the input list contains elements that are not tuples of two integers: * Example: `nearestPoints([(1, 2), (2, 3), [4, 5]])` should raise an assertion error.","solution":"import math def nearestPoints(points): Returns the pair of points with the smallest Euclidean distance between them. Parameters: points (list): A list of tuples, where each tuple contains two integers representing the coordinates of a point in a 2D plane. Returns: tuple: A tuple containing two tuples, each representing one of the closest pair of points. # Ensure input validation for point in points: if not (isinstance(point, tuple) and len(point) == 2 and all(isinstance(coordinate, int) for coordinate in point)): raise ValueError(\\"All elements must be tuples containing exactly two integers\\") # Less than 2 points cannot form a pair if len(points) < 2: return tuple() def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) min_distance = float(\'inf\') closest_pair = (points[0], points[1]) for i in range(len(points)): for j in range(i + 1, len(points)): dist = euclidean_distance(points[i], points[j]) if dist < min_distance: min_distance = dist closest_pair = (points[i], points[j]) return closest_pair"},{"question":"# Coding Assessment Question **Context**: String manipulation and searching are fundamental tasks in text processing and are critical for applications such as search engines, spell checkers, and natural language processing. One common task is to determine if a given pattern exists in a string and if so, return the index of its first occurrence. **Problem Statement**: Implement a function `find_pattern` that searches for the first occurrence of a given pattern in a string. If the pattern is found, the function should return the index of its first occurrence; otherwise, it should return `-1`. # Function Signature: ```python def find_pattern(text: str, pattern: str) -> int: pass ``` # Input: * `text` (str): The text in which to search for the pattern. * `pattern` (str): The pattern to search for within the text. # Output: * Returns an integer indicating the index of the first occurrence of the pattern in the text, or `-1` if the pattern is not found. # Constraints: * `text` and `pattern` are non-empty strings containing only ASCII characters. * The length of `pattern` will be less than or equal to the length of `text`. # Performance Requirements: * Time Complexity should be O(n + m), where n is the length of the text and m is the length of the pattern. * Space Complexity should be O(1). # Example: ```python >>> find_pattern(\\"hello world\\", \\"world\\") 6 >>> find_pattern(\\"abcdefg\\", \\"def\\") 3 >>> find_pattern(\\"test string\\", \\"test\\") 0 >>> find_pattern(\\"example\\", \\"abc\\") -1 >>> find_pattern(\\"abc\\", \\"abc\\") 0 ``` # Additional Requirements: * Ensure the function handles edge cases correctly, such as when the pattern is an empty string or when the text is an empty string. * Implement efficient searching algorithm, such as the Knuth-Morris-Pratt (KMP) or Boyer-Moore algorithm, to meet the performance requirements. # Hints: * Consider preprocessing the pattern to build a partial match table if using the KMP algorithm. * Take care to handle cases where the pattern is longer than the text gracefully.","solution":"def find_pattern(text: str, pattern: str) -> int: Function that searches for the first occurrence of a given pattern in a string. If found, returns the index of its first occurrence; otherwise, returns -1. if not pattern: return 0 # Preprocess the pattern to build the partial match table (lps array) lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 i = j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Longest Palindromic Substring using Manacher\'s Algorithm Context: You are given a string representing a sequence of characters. Your task is to efficiently find the longest palindromic substring within the given sequence. Task: Implement an algorithm using Manacher\'s Algorithm to preprocess and find the longest palindromic substring in the given sequence. Requirements: 1. **Function 1**: `preprocess_string(s: str) -> str` - Input: A string `s` containing lowercase/uppercase letters and numbers. - Output: A new string formatted for Manacher\'s Algorithm. - Additional Information: This function should add delimiters (like `#`) between characters of the original string and at the boundaries. - Constraints: The input string will have at least one character. 2. **Function 2**: `longest_palindromic_substring(s: str) -> str` - Input: A string `s` containing lowercase/uppercase letters and numbers. - Output: The longest palindromic substring. - Performance: The solution should run in linear time, O(n), where n is the length of the processed string. Example: ```python s = \\"babad\\" # The preprocessed string will be \\"#b#a#b#a#d#\\" preprocessed = preprocess_string(s) assert preprocessed == \\"#b#a#b#a#d#\\" # Finding the longest palindromic substring result = longest_palindromic_substring(s) assert result in {\\"bab\\", \\"aba\\"} # Either \\"bab\\" or \\"aba\\" is correct ``` Details for Implementation: - The `preprocess_string` function transforms the input string by interleaving it with a special character (like `#`) to handle even-length palindromes. - The `longest_palindromic_substring` function uses Manacher\'s Algorithm to find the longest palindromic substring in the preprocessed string efficiently.","solution":"def preprocess_string(s: str) -> str: Preprocess the string by adding delimiters (#) between characters and at the boundaries to handle even-length palindromes uniformly. if not s: return \\"^\\" return \\"^#\\" + \\"#\\".join(s) + \\"#\\" def longest_palindromic_substring(s: str) -> str: Use Manacher\'s Algorithm to find the longest palindromic substring. processed_s = preprocess_string(s) n = len(processed_s) P = [0] * n # Array to store the radius of the palindrome centered at each position center = 0 right = 0 for i in range(1, n - 1): mirror = 2 * center - i # Find the corresponding position on the left side of the palindrome centered at \\"center\\" if right > i: P[i] = min(right - i, P[mirror]) # Prevent crossing the right boundary # Expand the palindrome centered at i while processed_s[i + P[i] + 1] == processed_s[i - P[i] - 1]: P[i] += 1 # Adjust the center and right boundary if the palindrome centered at i expands beyond right if i + P[i] > right: center = i right = i + P[i] # Find the maximum length palindrome and its center max_len = 0 max_center = 0 for i in range(1, n - 1): if P[i] > max_len: max_len = P[i] max_center = i # Extract the longest palindromic substring from the original string start = (max_center - max_len) // 2 return s[start: start + max_len]"},{"question":"# Calculate Water Boiling Point Based on Altitude Scenario In a scientific simulation program, you need to accurately determine the boiling point of water at different altitudes. Depending on the altitude, the atmospheric pressure changes, which in turn affects the boiling point of water. Your task is to create a function that computes the boiling point of water based on the given altitude. Problem Statement Implement a function `boiling_point(altitude: float) -> float` that calculates the boiling point of water at a given altitude using the approximate formula: (T = 100 - left(frac{altitude}{300}right)), where the boiling point temperature (T) is in degrees Celsius and the altitude is in meters. Input Format: * `altitude` - a float representing the altitude above sea level in meters. Must be non-negative. Output Format: * A float representing the boiling point of water at the given altitude in degrees Celsius. Constraints: * The `altitude` must be non-negative. Otherwise, raise a `ValueError`. * The function should handle typical float ranges for altitudes. Examples: ```python >>> boiling_point(0) 100.0 >>> boiling_point(300) 99.0 >>> boiling_point(1500) 95.0 ``` Notes: * Ensure proper handling of zero or negative input values. * Maintain accuracy up to at least 2 decimal places for the result. * The formula is a simplification and assumes a linear decrease in boiling point temperature with increasing altitude.","solution":"def boiling_point(altitude: float) -> float: Calculates the boiling point of water at a given altitude based on the formula: T = 100 - (altitude / 300). Parameters: altitude (float): The altitude above sea level in meters. Must be non-negative. Returns: float: The boiling point of water at the given altitude in degrees Celsius. Raises: ValueError: If altitude is negative. if altitude < 0: raise ValueError(\\"Altitude must be non-negative\\") boiling_temp = 100 - (altitude / 300) return round(boiling_temp, 2)"},{"question":"# Implement a Circular Queue with Fixed Size Design and implement a circular queue using a fixed-size array. The circular queue should support the following operations: enqueue, dequeue, is_empty, is_full, and front. # Function Signatures ```python class CircularQueue: def __init__(self, k: int) -> None: # Initialize the queue with a fixed size of `k`. def enqueue(self, value: int) -> bool: # Insert an element into the circular queue. Return True if the operation is successful. def dequeue(self) -> bool: # Delete an element from the circular queue. Return True if the operation is successful. def is_empty(self) -> bool: # Check whether the circular queue is empty. def is_full(self) -> bool: # Check whether the circular queue is full. def front(self) -> int: # Get the front item from the queue. If the queue is empty, return -1. ``` # Parameters and Constraints - The `__init__` method should accept an integer `k`, which represents the fixed capacity of the circular queue. - `enqueue` and `dequeue` return a boolean indicating whether the operation was successful. - `front` returns the element at the front of the queue if the queue is not empty, otherwise, it returns -1. - Elements value will be in the range of integers. # Example ```python cq = CircularQueue(3) # Initialize a circular queue with capacity 3. assert cq.is_empty() == True assert cq.enqueue(1) == True # queue is now [1] assert cq.enqueue(2) == True # queue is now [1, 2] assert cq.enqueue(3) == True # queue is now [1, 2, 3] assert cq.is_full() == True assert cq.enqueue(4) == False # queue is full, insertion fails assert cq.front() == 1 assert cq.dequeue() == True # removes 1, queue is now [2, 3] assert cq.front() == 2 assert cq.enqueue(4) == True # queue is now [2, 3, 4] assert cq.is_full() == True assert cq.dequeue() == True # removes 2, queue is now [3, 4] assert cq.front() == 3 ``` # Additional Notes - Your implementation should handle the wrap around logic using a fixed-size array. - The queue should keep track of the current number of elements and adjust the front and rear pointers accordingly. - Both `enqueue` and `dequeue` operations should be performed in constant O(1) time.","solution":"class CircularQueue: def __init__(self, k: int) -> None: self.size = k self.queue = [None] * k self.front_index = 0 self.rear_index = 0 self.count = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False self.queue[self.rear_index] = value self.rear_index = (self.rear_index + 1) % self.size self.count += 1 return True def dequeue(self) -> bool: if self.is_empty(): return False self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.size self.count -= 1 return True def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size def front(self) -> int: if self.is_empty(): return -1 return self.queue[self.front_index]"},{"question":"# Prefix Trie Construction and Prefix Matching You are given a list of words. Your task is to construct a prefix trie (or prefix tree) for these words and implement efficient prefix matching using this trie. Function Signature: ```python class PrefixTrie: def __init__(self) -> None: # Initializes an empty prefix trie. def insert(self, word: str) -> None: # Inserts a word into the prefix trie. def search_prefix(self, prefix: str) -> bool: # Searches for a prefix in the prefix trie. ``` Input: - The `insert` method takes a single string `word` which is the word to be inserted into the prefix trie. - The `search_prefix` method takes a single string `prefix` which is the prefix to search in the trie. Output: - The `search_prefix` method returns a boolean value `True` if the prefix is found and `False` otherwise. Constraints: - The total number of words does not exceed (10^5). - The length of each word does not exceed (10^4). - The length of the prefix does not exceed (10^4). Example: ```python words = [\\"cat\\", \\"car\\", \\"dog\\", \\"cart\\"] pt = PrefixTrie() for word in words: pt.insert(word) assert pt.search_prefix(\\"car\\") == True assert pt.search_prefix(\\"ca\\") == True assert pt.search_prefix(\\"do\\") == True assert pt.search_prefix(\\"bat\\") == False ```","solution":"class PrefixTrie: def __init__(self) -> None: self.root = {} def insert(self, word: str) -> None: node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # A marker to indicate the end of a word def search_prefix(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node: return False node = node[char] return True"},{"question":"# Coding Challenge Context/Scenario Your task is to add a new functionality to the given Python script that calculates the minimum number of operations required to reduce a given positive integer to 1. You can perform either of the following operations on the number: 1. Subtract 1 from the number. 2. If the number is even, divide it by 2. Function Signature Create a function `min_operations_to_one`: ```python def min_operations_to_one(n: int) -> int: Given a positive integer n, return the minimum number of operations required to reduce the number to 1. ``` Expected Input and Output Formats * **Input**: - `n (int)`: A positive integer [1 <= n <= 10^6]. * **Output**: - `int`: The minimum number of operations required to reduce the number to 1. Constraints and Limitations - Raise an exception with a meaningful error message if the input integer is less than 1. Performance Requirements - The function should handle inputs up to the upper limit efficiently considering the complexity constraints. Example ```python >>> min_operations_to_one(10) 4 >>> min_operations_to_one(15) 6 >>> min_operations_to_one(1) 0 >>> min_operations_to_one(0) # invalid input Traceback (most recent call last): ... Exception: Input number should be a positive integer greater than or equal to 1 ```","solution":"def min_operations_to_one(n: int) -> int: Given a positive integer n, return the minimum number of operations required to reduce the number to 1. if n < 1: raise ValueError(\\"Input number should be a positive integer greater than or equal to 1\\") operations = [0] * (n + 1) for i in range(2, n + 1): # Subtract 1 operation op1 = operations[i - 1] + 1 # Divide by 2 operation, if the number is even if i % 2 == 0: op2 = operations[i // 2] + 1 else: op2 = float(\'inf\') # Compute minimum operations for the current number operations[i] = min(op1, op2) return operations[n]"},{"question":"# Problem Statement You are tasked with creating a simplified contact book. Implement a class `ContactBook` with the following methods: `add_contact(name, phone_number)`, `remove_contact(name)`, `lookup_contact(name)`, and `get_all_contacts()`. # Requirements: - `add_contact(name: str, phone_number: str)`: - Adds a new contact with the given name and phone number to the contact book. - If a contact with the same name already exists, update its phone number. - `remove_contact(name: str)`: - Removes the contact with the given name from the contact book. - If the contact does not exist, do nothing. - `lookup_contact(name: str)`: - Returns the phone number of the contact with the given name. - If the contact does not exist, return `None`. - `get_all_contacts()`: - Returns a list of tuples containing all contacts in the contact book, sorted alphabetically by name. - Each tuple should be in the form of `(name, phone_number)`. # Constraints: - The contact book will have at most 1000 contacts. - The `name` and `phone_number` strings will each have lengths between 1 and 100. ```python class ContactBook: def add_contact(self, name: str, phone_number: str) -> None: ... def remove_contact(self, name: str) -> None: ... def lookup_contact(self, name: str) -> str: ... def get_all_contacts(self) -> List[Tuple[str, str]]: ... ``` # Example ```python # Example usage: contact_book = ContactBook() contact_book.add_contact(\\"John Doe\\", \\"123-456-7890\\") contact_book.add_contact(\\"Jane Smith\\", \\"098-765-4321\\") assert contact_book.lookup_contact(\\"John Doe\\") == \\"123-456-7890\\" contact_book.remove_contact(\\"John Doe\\") assert contact_book.lookup_contact(\\"John Doe\\") == None assert contact_book.get_all_contacts() == [(\\"Jane Smith\\", \\"098-765-4321\\")] contact_book.add_contact(\\"Alice Brown\\", \\"555-123-4567\\") contact_book.add_contact(\\"Bob White\\", \\"555-987-6543\\") assert contact_book.get_all_contacts() == [(\\"Alice Brown\\", \\"555-123-4567\\"), (\\"Bob White\\", \\"555-987-6543\\"), (\\"Jane Smith\\", \\"098-765-4321\\")] ``` # Guidelines: - Ensure that adding, looking up, and removing contacts have efficient time complexity. - Implement appropriate error handling for edge cases such as empty names or phone numbers.","solution":"from typing import List, Tuple, Optional class ContactBook: def __init__(self): self.contacts = {} def add_contact(self, name: str, phone_number: str) -> None: self.contacts[name] = phone_number def remove_contact(self, name: str) -> None: if name in self.contacts: del self.contacts[name] def lookup_contact(self, name: str) -> Optional[str]: return self.contacts.get(name, None) def get_all_contacts(self) -> List[Tuple[str, str]]: return sorted(self.contacts.items())"},{"question":"# Question Description Context Manipulating and transforming data in a structured way often requires processing data series or sequences. One common task is reversing a given list while maintaining the even-indexed elements in their original order. Task You are required to design a function that reverses a list except for elements at even indices. Detailed Instructions * **Function Signature**: ```python def reverse_excluding_evens(lst: list) -> list: Reverse a list excluding elements at even indices. :param lst: A list of elements. :return: A new list with odd-indexed elements reversed and even-indexed elements in original order. ``` * **Expected Input and Output Formats**: * The function accepts a single list `lst`. * The function returns a list with the described transformations applied. * **Constraints**: * Ensure the input is a list. * The input list can contain elements of any data type. * **Performance Requirements**: The function should run efficiently within acceptable limits, preferably linear time, O(n), where n is the length of the list. Examples: ```python >>> reverse_excluding_evens([1, 2, 3, 4, 5]) [1, 4, 3, 2, 5] >>> reverse_excluding_evens([1, 2, 3, 4, 5, 6]) [1, 6, 3, 4, 5, 2] >>> reverse_excluding_evens([\'a\', \'b\', \'c\', \'d\']) [\'a\', \'d\', \'c\', \'b\'] >>> reverse_excluding_evens([]) [] >>> reverse_excluding_evens([1, \'a\', 2, \'b\']) [1, \'b\', 2, \'a\'] ``` Edge Cases: 1. If the input list is empty, the function should return an empty list. 2. If the input list contains only one element, it should return the same list. 3. The function should correctly handle lists with mixed data types.","solution":"def reverse_excluding_evens(lst): Reverse a list excluding elements at even indices. :param lst: A list of elements. :return: A new list with odd-indexed elements reversed and even-indexed elements in original order. if not lst: return [] odd_indices = [i for i in range(len(lst)) if i % 2 != 0] reversed_odd_values = [lst[i] for i in odd_indices][::-1] result = lst.copy() for i, idx in enumerate(odd_indices): result[idx] = reversed_odd_values[i] return result"},{"question":"# **Coding Challenge: Multiplicative Persistence Calculation** Multiplicative persistence is defined as the number of times you must multiply the digits of a number until you reach a single digit. For example, the multiplicative persistence of 39 is 3 because 3 × 9 = 27, 2 × 7 = 14, and 1 × 4 = 4. Therefore, it takes 3 steps to reach a single digit. **Problem Statement**: Write a function `multiplicative_persistence(n: int) -> int` that takes a positive integer `n` and returns its multiplicative persistence. # **Hint** Iterate over the digits of the number, multiply them, and repeat the process until a single digit is obtained. Count the number of iterations required to reach this single digit. # **Input Format** * A single integer, `n`, where (1 leq n leq 10^{12}). # **Output Format** * Returns the multiplicative persistence of the number (integer). # **Constraints** * The input number `n` will be within the range (1 leq n leq 10^{12}). # **Example** * For `n = 39`: ```python print(multiplicative_persistence(39)) # Output: 3 ``` * For `n = 999`: ```python print(multiplicative_persistence(999)) # Output: 4 ``` # **Explanation** - For `n = 39`, the steps to reach a single digit are 3 (3 × 9 = 27), 2 (2 × 7 = 14), 1 (1 × 4 = 4). - For `n = 999`, the steps to reach a single digit are 4 (9 × 9 × 9 = 729), 3 (7 × 2 × 9 = 126), 2 (1 × 2 × 6 = 12), 1 (1 × 2 = 2). Carefully consider large numbers and ensure that calculations are performed efficiently to avoid performance issues.","solution":"def multiplicative_persistence(n: int) -> int: Calculate the multiplicative persistence of a number, which is the count of times digits must be multiplied until a single digit is reached. persistence_count = 0 while n >= 10: product = 1 while n > 0: product *= n % 10 n //= 10 n = product persistence_count += 1 return persistence_count"},{"question":"# Question: Signal Processing - Low Pass Filter As a signal processing engineer, you have to implement a low pass filter to process discrete-time signals. A low pass filter allows signals with a frequency lower than a chosen cutoff frequency to pass and attenuates frequencies higher than the cutoff. Your task is to write a function that applies a simple low pass filter to a given signal: 1. **low_pass_filter(signal, cutoff_frequency, filter_strength)**: - **Input**: - A list `signal` of integers representing the discrete-time signal. - An integer `cutoff_frequency` denoting the frequency threshold. - A float `filter_strength` between 0 and 1 indicating how strongly frequencies above the cutoff should be attenuated. - **Output**: A new list of integers representing the filtered signal. - **Example**: ```python >>> low_pass_filter([1, 2, 3, 4, 5], 3, 0.5) [1, 2, 3, 3, 4] ``` # Implementation Requirements - **The function should raise a `ValueError` if the `cutoff_frequency` is negative or if the `filter_strength` is not between 0 and 1**. - Ensure to handle edge cases, such as an empty signal list. - The filtering process should be optimized for linear time complexity. # Test Cases You should test your function with the following cases: ```python assert low_pass_filter([1, 2, 3, 4, 5], 3, 0.5) == [1, 2, 3, 3, 4] assert low_pass_filter([10, 20, 30, 40], 2, 0.25) == [10, 20, 22, 24] assert low_pass_filter([], 5, 0.7) == [] # Test for invalid cutoff_frequency value try: low_pass_filter([1, 2, 3], -1, 0.5) except ValueError: print(\\"ValueError raised as expected\\") # Test for invalid filter_strength value try: low_pass_filter([1, 2, 3], 3, 1.5) except ValueError: print(\\"ValueError raised as expected\\") ```","solution":"def low_pass_filter(signal, cutoff_frequency, filter_strength): Applies a simple low pass filter to a given signal. Parameters: - signal (list of int): the discrete-time signal to be filtered - cutoff_frequency (int): the frequency threshold - filter_strength (float): how strongly frequencies above the cutoff should be attenuated (0 to 1) Returns: - list of int: the filtered signal if cutoff_frequency < 0: raise ValueError(\\"cutoff_frequency must be non-negative\\") if not (0 <= filter_strength <= 1): raise ValueError(\\"filter_strength must be between 0 and 1\\") filtered_signal = [] for i, value in enumerate(signal): if i < cutoff_frequency: filtered_signal.append(value) else: attenuated_value = value * (1 - filter_strength) filtered_signal.append(int(attenuated_value)) return filtered_signal"},{"question":"# Question: Implement a Recursive Palindrome Checker **Scenario**: You are working on a text analysis tool that identifies various characteristics of strings. One of the tasks is to determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). To do this efficiently, you need to implement a function that uses recursion to check for palindromes. **Function to Implement**: Implement the function `is_palindrome(s: str) -> bool` that takes a string and returns True if it is a palindrome, and False otherwise. The function should handle the following requirements: **Requirements**: 1. Ignore spaces, punctuation, and capitalization. 2. Utilize a recursive approach to solve the problem. **Input**: - A single string, `s`, for which the palindrome check should be performed. **Output**: - A boolean value, `True` if the string is a palindrome, `False` otherwise. **Constraints**: - The string may contain spaces, punctuation, and mixed capitalization. - Use recursion for the palindrome check. **Example Cases**: ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Not a palindrome\\") False ``` **Function Template**: ```python def is_palindrome(s: str) -> bool: Take a string and return True if it is a palindrome, False otherwise :param s: String to check for being a palindrome :return: Boolean indicating if the string is a palindrome or not def clean_string(s: str) -> str: Remove punctuation, spaces and lower the case of the string :param s: String to be cleaned :return: Cleaned and lowered string return \'\'.join(c.lower() for c in s if c.isalnum()) def helper(s: str, start: int, end: int) -> bool: Recursive helper function to check for palindrome :param s: Cleaned string to check :param start: Starting index to check :param end: Ending index to check :return: Boolean indicating if the substring is a palindrome if start >= end: return True if s[start] != s[end]: return False return helper(s, start + 1, end - 1) cleaned_s = clean_string(s) return helper(cleaned_s, 0, len(cleaned_s) - 1) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def is_palindrome(s: str) -> bool: Take a string and return True if it is a palindrome, False otherwise :param s: String to check for being a palindrome :return: Boolean indicating if the string is a palindrome or not def clean_string(s: str) -> str: Remove punctuation, spaces and lower the case of the string :param s: String to be cleaned :return: Cleaned and lowered string return \'\'.join(c.lower() for c in s if c.isalnum()) def helper(s: str, start: int, end: int) -> bool: Recursive helper function to check for palindrome :param s: Cleaned string to check :param start: Starting index to check :param end: Ending index to check :return: Boolean indicating if the substring is a palindrome if start >= end: return True if s[start] != s[end]: return False return helper(s, start + 1, end - 1) cleaned_s = clean_string(s) return helper(cleaned_s, 0, len(cleaned_s) - 1)"},{"question":"# Question Description You are given an unsorted array of integers. Your task is to write a Python function that rearranges the elements in such a way that all negative elements appear at the beginning of the array, followed by all positive elements. Zeroes should be placed in between negative and positive elements, and the relative order among the negative numbers, zeroes, and positive numbers should remain unchanged. Your function should manage input validations and handle edge cases efficiently. # Function Signature ```python def rearrange_array(arr: list[int]) -> list[int]: Rearranges the given array so that all negative numbers come first, followed by zeroes, and then positive numbers, while maintaining the relative order among negative, zero, and positive numbers. Parameters: arr (list[int]): The input array of integers. Returns: list[int]: The rearranged array. ``` # Input - A list of integers `arr` which can include negative numbers, zeroes, and positive numbers. # Output - A list of integers where negative numbers are followed by zeroes and then positive numbers, maintaining their original relative order. # Example ```python >>> rearrange_array([-1, -3, 4, 0, -2, 2, 1, 0]) [-1, -3, -2, 0, 0, 4, 2, 1] >>> rearrange_array([1, 2, -1, -2, 0, 3]) [-1, -2, 0, 1, 2, 3] >>> rearrange_array([0, -1, -2, -3, 4]) [-1, -2, -3, 0, 4] >>> rearrange_array([5, -5, 0, 5, -5]) [-5, -5, 0, 5, 5] ``` # Constraints - Ensure the input list consists only of integers. - Maintain the original order of negative numbers, zeroes, and positive numbers within their respective groups. - Optimize your function to handle the rearrangement in a single traversal of list elements if possible. # Notes You should avoid using built-in sorting functions and aim for an efficient in-place rearrangement approach.","solution":"def rearrange_array(arr): Rearranges the given array so that all negative numbers come first, followed by zeroes, and then positive numbers, while maintaining the relative order among negative, zero, and positive numbers. Parameters: arr (list[int]): The input array of integers. Returns: list[int]: The rearranged array. negatives = [] zeroes = [] positives = [] for num in arr: if num < 0: negatives.append(num) elif num == 0: zeroes.append(num) else: positives.append(num) return negatives + zeroes + positives"},{"question":"**Problem Statement:** Write a function that takes a list of integers and returns the smallest missing positive integer. **Write a function:** ```python def find_smallest_missing_positive(nums: list) -> int: Given a list of integers, find the smallest positive integer that does not appear in the list. :param nums: A list of integers :return: An integer, representing the smallest positive integer not in the list Example: >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 pass ``` # Input - A list `nums` of integers (0 <= len(nums) <= 1000) # Output - An integer representing the smallest positive integer not present in the list. # Constraints - Your solution should run in O(n) time complexity and use constant space, disregarding the input and output space. - The function must handle lists with positive, negative, and zero values. # Scenario This problem is designed to test your ability to handle common interview problems involving arrays and missing values. It\'s intended to assess your problem-solving skills as well as your grasp of time and space complexity considerations. # Hints: - You might consider using an algorithm that leverages the indices of the original list. - A well-known approach to solve this problem efficiently is the in-place hashing. **Testing:** Ensure that your solution passes the given examples and additional edge cases such as: - `find_smallest_missing_positive([]) -> 1` - `find_smallest_missing_positive([-1, -2, -3]) -> 1` - `find_smallest_missing_positive([1, 1, 1, 1]) -> 2`","solution":"def find_smallest_missing_positive(nums: list) -> int: Given a list of integers, find the smallest positive integer that does not appear in the list. :param nums: A list of integers :return: An integer, representing the smallest positive integer not in the list Example: >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 n = len(nums) # First, segregate positive and non-positive numbers for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first index which does not have the correct value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Levenshtein Distance Calculator **Context**: You are working on a text processing application that requires determining how similar two strings are for various purposes like spelling correction, text recognition, or data comparison. One common way to measure this similarity is by calculating the Levenshtein distance, which counts the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other. **Task**: Implement a function `levenshtein_distance` that calculates the Levenshtein distance between two given strings. The function should accept two strings and return the distance as an integer. **Function Signature**: ```python def levenshtein_distance(s1: str, s2: str) -> int: pass ``` **Input**: * `s1`: The first string (1 ≤ len(s1) ≤ 1000). * `s2`: The second string (1 ≤ len(s2) ≤ 1000). **Output**: * The Levenshtein distance between the two strings (as an integer). **Constraints**: * The strings will contain only lowercase English letters (\'a\'-\'z\') without spaces or any special characters. * The time complexity of the algorithm should not exceed O(n * m), where n and m are the lengths of the input strings. **Example**: ```python # Example strings s1 = \\"kitten\\" s2 = \\"sitting\\" # Expected distance print(levenshtein_distance(s1, s2)) # Should output 3, since the edits are kitten -> sitten -> sittin -> sitting s1 = \\"flaw\\" s2 = \\"lawn\\" # Expected distance print(levenshtein_distance(s1, s2)) # Should output 2, since the edits are flaw -> law -> lawn ``` # Guidelines: 1. Use dynamic programming to ensure an efficient solution. 2. Create a matrix to keep track of the edit distances between all prefixes of both strings. 3. Ensure your solution handles all edge cases, such as strings of different lengths and completely dissimilar strings. 4. Optimize your solution to run efficiently for the upper constraint limits.","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Computes the Levenshtein distance between two strings s1 and s2. Arguments: s1 -- first string s2 -- second string Returns: The Levenshtein distance between the two strings. n, m = len(s1), len(s2) # Create a distance matrix and initialize it dp = [[0] * (m + 1) for _ in range(n + 1)] # Initializing the distance of empty strings to prefix deletions for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the distance matrix for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) # The answer is the edit distance between the two full strings return dp[n][m]"},{"question":"# Question You are developing a Python application to process user data from a JSON file. To ensure the correctness of your data processing logic, you need to write unit tests that guarantee your functions perform as expected even when additional fields are introduced in the JSON data. # Task Create a Python function, `test_process_user_data`, to test the processing of JSON data using the `pytest` framework. The test should mock the opening and reading of a JSON file to simulate the system\'s operation without actual file I/O. Requirements: - Create a class `FakeFile` that mimics the real file object. - Mock the `open` function to return a controlled JSON response instead of reading from an actual file. - Ensure the mock function simulates reading a JSON with various user fields, such as {\\"username\\": \\"testuser\\", \\"email\\": \\"testuser@example.com\\"}. - Use the `monkeypatch` fixture to apply the mock. - Verify that the processing function extracts and processes the required fields correctly. - Handle erroneous scenarios such as malformed JSON or missing required fields with appropriate assertions. Input and Output: - You don’t need to worry about the input and output format of the main function as it is a unit test setup. - If the setup is correct, the unit test should pass without actually reading from the file system. Constraints: - Assume the JSON file path is \'user_data.json\'. - The main function to test can be named `process_user_data` which reads and processes the JSON file. - File I/O operations should be fully mocked. # Example: ```python import json def process_user_data(file_path): with open(file_path, \'r\') as file: data = json.load(file) # Processing logic goes here, for example, extract the username and email return data.get(\'username\'), data.get(\'email\') ``` Create the mock unit test function `test_process_user_data` for the above example.","solution":"import json def process_user_data(file_path): with open(file_path, \'r\') as file: data = json.load(file) # Processing logic goes here, for example, extract the username and email username = data.get(\'username\') email = data.get(\'email\') if username and email: return username, email else: raise ValueError(\\"Required fields are missing\\")"},{"question":"# Binary Search Tree Insertion and Search Problem Statement You are provided with a basic implementation of a Binary Search Tree (BST) and your task is to implement both insertion of new values and searching for values within the tree. The Binary Search Tree is a data structure where each node has at most two children, with the left child containing values less than the parent node, and the right child contains values greater than or equal to the parent node. Requirements Implement the following methods in the `BST` class: ```python class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: Insert a new key into the BST. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.root.value 10 >>> bst.root.left.value 5 >>> bst.root.right.value 15 # Your code here def search(self, key: int) -> bool: Search for a specific key within the BST. Returns: bool: True if the key is found, False otherwise. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.search(5) True >>> bst.search(20) False # Your code here ``` Your implementation must: - Use the `insert` method to ensure the new key is placed in the correct position according to BST rules. - Use the `search` method to return `True` if the key exists in the tree, and `False` otherwise. Input and Output - **Input**: No direct input to the class methods. You define and interact with the BST through creating instances and calling methods on those instances. - **Output**: - `insert`: None (modifies the tree in place). - `search`: Boolean value indicating if the key exists in the tree. Constraints - Assume all keys inserted into the BST are integers. - Optimize the insertion and search operations to ensure efficient performance for large numbers of nodes (up to 10^4 nodes). Example ```python >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.search(7) # Output: False >>> bst.search(10) # Output: True >>> bst.insert(7) >>> bst.search(7) # Output: True ``` # Note - Implement and thoroughly test edge cases such as searching for values in an empty BST, inserting duplicate values, and searching for the minimum and maximum values.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: Insert a new key into the BST. if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node: Node, key: int) -> None: if key < node.value: if node.left is None: node.left = Node(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_recursive(node.right, key) def search(self, key: int) -> bool: Search for a specific key within the BST. Returns: bool: True if the key is found, False otherwise. return self._search_recursive(self.root, key) def _search_recursive(self, node: Node, key: int) -> bool: if node is None: return False if key == node.value: return True elif key < node.value: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key)"},{"question":"# Context You are required to implement a text processing system to analyze and sort sentences based on the frequency of their unique words. The goal is to write a solution that can efficiently parse multiple sentences, determine the frequency of each unique word within each sentence, and then sort the sentences by the number of unique words they contain in descending order. # Task 1. Implement a class `SentenceAnalyzer` that parses the sentences and counts the frequency of unique words. 2. Implement a function `sort_sentences` utilizing `SentenceAnalyzer` to output the sorted list of sentences. # Class Definition ```python class SentenceAnalyzer: def __init__(self, sentences: list[str]): Initializes the SentenceAnalyzer with a list of sentences. :param sentences: List of sentences to analyze. self.sentences = sentences self.word_counts = [self._count_unique_words(sentence) for sentence in sentences] def _count_unique_words(self, sentence: str) -> int: Counts the number of unique words in a sentence. :param sentence: The sentence to analyze. :return: The count of unique words in the sentence. words = sentence.split() unique_words = set(words) return len(unique_words) def get_word_counts(self) -> list[int]: Returns the counts of unique words for each sentence. :return: A list of unique word counts corresponding to each sentence. return self.word_counts ``` # Function Definition ```python def sort_sentences(sentences: list[str]) -> list[str]: Sorts a list of sentences based on the number of unique words they contain in descending order. :param sentences: The list of sentences to sort. :return: The list of sentences sorted by unique word count in descending order. analyzer = SentenceAnalyzer(sentences) word_counts = analyzer.get_word_counts() sorted_sentences = sorted(zip(sentences, word_counts), key=lambda x: x[1], reverse=True) return [sentence for sentence, _ in sorted_sentences] ``` # Constraints 1. Each sentence will contain only alphabetic characters and spaces. 2. The length of each sentence will not exceed 1000 characters. 3. The number of sentences, `M`, will not exceed 100. 4. Words within sentences are case-insensitive and should be treated as such (i.e., \\"Word\\" and \\"word\\" are considered the same). # Example ```python sentences = [ \\"This is a test sentence\\", \\"Another test\\", \\"Test test test test\\", \\"A simple example\\" ] result = sort_sentences(sentences) ``` **Expected output:** `[\\"This is a test sentence\\", \\"A simple example\\", \\"Another test\\", \\"Test test test test\\"]` **Note:** The output should be a list of sentences sorted in descending order by the number of unique words they contain.","solution":"class SentenceAnalyzer: def __init__(self, sentences: list[str]): Initializes the SentenceAnalyzer with a list of sentences. :param sentences: List of sentences to analyze. self.sentences = sentences self.word_counts = [self._count_unique_words(sentence) for sentence in sentences] def _count_unique_words(self, sentence: str) -> int: Counts the number of unique words in a sentence. :param sentence: The sentence to analyze. :return: The count of unique words in the sentence. words = sentence.lower().split() unique_words = set(words) return len(unique_words) def get_word_counts(self) -> list[int]: Returns the counts of unique words for each sentence. :return: A list of unique word counts corresponding to each sentence. return self.word_counts def sort_sentences(sentences: list[str]) -> list[str]: Sorts a list of sentences based on the number of unique words they contain in descending order. :param sentences: The list of sentences to sort. :return: The list of sentences sorted by unique word count in descending order. analyzer = SentenceAnalyzer(sentences) word_counts = analyzer.get_word_counts() sorted_sentences = sorted(zip(sentences, word_counts), key=lambda x: x[1], reverse=True) return [sentence for sentence, _ in sorted_sentences]"},{"question":"# Sorting Log Entries **Context**: In many real-world applications, log entries need to be sorted not just by timestamp but also based on their contents for easier debugging and data analysis. You are required to sort a list of log entries according to their timestamps and secondary criteria based on content. **Your Task**: Implement a function to sort log entries. Function Signature ```python def sort_logs(logs: List[str]) -> List[str]: ``` Input - `logs`: A list of strings, where each string represents a log entry. Each log entry is composed of a timestamp and a message separated by a single space. The timestamp is in the format \\"YYYY-MM-DD HH:MM:SS\\". Output - Returns the list of log entries sorted primarily by timestamp (ascending), and secondarily by the log message (lexicographically). Constraints - The list will contain at least 1 entry and at most (10^4) entries. - Each log entry follows the format specified. Example ```python >>> sort_logs([ \\"2023-01-01 08:45:00 A user logged in\\", \\"2023-01-01 08:45:00 Error detected in module 1\\", \\"2022-12-31 23:59:59 System rebooted\\", \\"2023-01-01 08:45:01 User performed an action\\" ]) [ \\"2022-12-31 23:59:59 System rebooted\\", \\"2023-01-01 08:45:00 A user logged in\\", \\"2023-01-01 08:45:00 Error detected in module 1\\", \\"2023-01-01 08:45:01 User performed an action\\" ] ``` Requirements - Ensure your function is optimized for performance given the constraint limits. - You may use Python\'s built-in sorting functions but ensure to split the logs correctly to sort based on both timestamp and message. Hints - Consider leveraging tuple-based sorting where the first element is the timestamp and the second element is the log message.","solution":"from typing import List def sort_logs(logs: List[str]) -> List[str]: Sort a list of log entries primarily by timestamp and secondarily by the log message. return sorted(logs, key=lambda log: (log[:19], log[20:]))"},{"question":"# Fibonacci Sequence Generator You are tasked with implementing a function to generate a list of Fibonacci numbers. Goal Write a function that generates all Fibonacci numbers up to a given limit. Function Signature ```python def generate_fibonacci(limit: int) -> list: pass ``` Input - **limit** (int): A non-negative integer that denotes the upper limit up to which Fibonacci numbers need to be generated. Output - **fibonacci_numbers** (list): A list containing all Fibonacci numbers less than or equal to the given limit. Constraints - **limit** should be a non-negative integer (≥ 0). If it\'s not, the function should raise a `ValueError`. Example ```python >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci(1) [0, 1, 1] >>> generate_fibonacci(0) [0] ``` Performance Requirements - The function should be efficient enough to handle generating Fibonacci sequences for reasonably large limits. # Implementation Notes - Utilize an iterative approach to build the list of Fibonacci numbers. - Ensure the method handles edge cases and invalid inputs correctly.","solution":"def generate_fibonacci(limit: int) -> list: Generates a list of Fibonacci numbers up to the given limit (inclusive). Parameters: limit (int): The upper limit for the Fibonacci numbers. Returns: list: A list of Fibonacci numbers up to the given limit. Raises: ValueError: If the limit is a negative integer. if limit < 0: raise ValueError(\\"The limit should be a non-negative integer.\\") if limit == 0: return [0] fibonacci_numbers = [0, 1] while True: next_fib = fibonacci_numbers[-1] + fibonacci_numbers[-2] if next_fib > limit: break fibonacci_numbers.append(next_fib) return fibonacci_numbers"},{"question":"# Question: Minimum Cost to Equalize Array with Operations You are given an array of integers where you can perform the following operation any number of times: select two elements `x` and `y` (x, y > 0, x != y) and replace both elements with their greatest common divisor (GCD). Write a function to calculate the minimum cost to make all elements of the array equal. The cost of an operation is defined as the sum of the two elements `x` and `y` you chose in that operation. # Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^3, 1 ≤ arr[i] ≤ 10^3). # Output * Return an integer representing the minimum cost to make all elements of the array equal. # Example Input ```python arr = [2, 3, 9] ``` Output ```python 15 ``` Input ```python arr = [4, 4, 4, 4] ``` Output ```python 0 ``` # Function Signature ```python def minimum_cost_to_equalize(arr: list) -> int: pass ``` # Explanation: - In the first example `arr = [2, 3, 9]`, you can first choose 3 and 9 to get GCD(3, 9) = 3 with a cost of 3+9 = 12, and then choose 2 and 3 to get GCD(2, 3) = 1 with a cost of 2+3 = 5, thus total cost is 12 + 3 = 15. - In the second example `arr = [4, 4, 4, 4]`, all elements are already equal, thus no operation is needed, and the cost is 0.","solution":"from math import gcd from functools import reduce def minimum_cost_to_equalize(arr: list) -> int: if len(set(arr)) == 1: return 0 # Find the GCD of the entire array overall_gcd = reduce(gcd, arr) total_cost = 0 for num in arr: if num != overall_gcd: total_cost += num return total_cost"},{"question":"# Coding Assessment Question: Prime Index Fibonacci Number Problem Statement: You are given an integer `n`. The Fibonacci sequence is defined as `F(1) = 1, F(2) = 1, F(n) = F(n-1) + F(n-2)` for `n > 2`. A prime number is a natural number greater than 1 which is not a product of two smaller natural numbers. The prime-indexed Fibonacci number is defined as a Fibonacci number where the index is a prime number. Your task is to find the `n`-th prime-indexed Fibonacci number. Detailed Explanation: - For example, the first few Fibonacci numbers are: - `F(1) = 1` - `F(2) = 1` - `F(3) = 2` - `F(4) = 3` - `F(5) = 5` - `F(6) = 8` - `F(7) = 13` - The first few prime numbers are: - `2, 3, 5, 7, 11, 13, ...` - The first few prime-indexed Fibonacci numbers are: - `F(2) = 1` - `F(3) = 2` - `F(5) = 5` - `F(7) = 13` - `F(11) = 89` - `F(13) = 233` Implement a function that returns the `n`-th prime-indexed Fibonacci number. Function Signature: ```python def nth_prime_index_fibonacci(n: int) -> int: Return the n-th prime-indexed Fibonacci number. ``` Constraints: 1. You may assume that `n` is a positive integer. 2. You need to handle values of `n` up to `10^5`. Example: 1. Input: `n = 1` Output: `1` 2. Input: `n = 4` Output: `13` 3. Input: `n = 6` Output: `233` Notes: - Consider using the Sieve of Eratosthenes to efficiently identify prime numbers. - Use dynamic programming or an iterative approach to handle the large values of Fibonacci numbers effectively. - Ensure your function handles large `n` efficiently to avoid timeouts. Evaluation criteria: - Correctness: The algorithm should correctly output the `n`-th prime-indexed Fibonacci number for given inputs. - Efficiency: Solutions should handle large `n` and corresponding computations efficiently. - Edge Cases: Proper handling of edge cases and invalid inputs.","solution":"def nth_prime_index_fibonacci(n: int) -> int: Return the n-th prime-indexed Fibonacci number. def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, limit + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers def fibonacci_until_index(index): fib_sequence = [0, 1, 1] for i in range(3, index + 1): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence # Estimate upper bound for finding the first n prime numbers if n == 0: return 0 elif n == 1: return 1 upper_bound = 200000 # A sufficiently large number should be set as an upper bound primes = sieve_of_eratosthenes(upper_bound) prime_indices = primes[:n] max_prime_index = prime_indices[-1] fibonacci_numbers = fibonacci_until_index(max_prime_index) return fibonacci_numbers[max_prime_index]"},{"question":"Binary Search Tree (BST) Operations for Inventory Management System Background: A retail company wants to develop an inventory management system using a Binary Search Tree (BST) to track product stock based on their unique IDs. Each product has an integer ID, and the system must support dynamic operations like adding a new product, removing a product, finding a product with a specific ID, and traversing the inventory in ascending order of IDs. Task: Implement the following operations in your BST class: 1. **Insert Product**: Add a new product with a given ID. 2. **Delete Product**: Remove a product with a given ID. 3. **Search Product**: Find and return a product with a specified ID. 4. **In-Order Traversal**: Return the list of product IDs in ascending order. Your BST class must include the following methods to implement the required operations: ```python class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BST: def __init__(self): Initialize an empty BST. self.root = None def insert(self, value: int) -> None: Insert a product with the given ID into the BST. :param value: Integer ID of the product. pass def delete(self, value: int) -> None: Remove the product with the given ID from the BST. :param value: Integer ID of the product. pass def search(self, value: int) -> BSTNode: Search for a product with the specified ID and return the node. :param value: Integer ID of the product. :return: Node with the specified ID, or None if not found. pass def in_order_traversal(self) -> list[int]: Perform in-order traversal of the BST and return a list of product IDs. :return: List of integer IDs in ascending order. pass ``` Input/Output Format: * `insert(value: int)` - Adds a new product with the specified ID. * `delete(value: int)` - Deletes the product with the specified ID. * `search(value: int)` - Returns the node with the specified ID, or None if not found. * `in_order_traversal()` - Returns a sorted list of product IDs in ascending order. Constraints: * All product IDs are integers. * The number of products will not exceed 10^6. Example Usage: ```python # Example initialization and operations bst = BST() bst.insert(25) bst.insert(15) bst.insert(50) bst.insert(10) bst.insert(22) bst.insert(35) bst.insert(70) node = bst.search(22) print(node.value) # Output: 22 bst.delete(15) sorted_ids = bst.in_order_traversal() print(sorted_ids) # Output: [10, 22, 25, 35, 50, 70] ``` Ensure that your implementation efficiently handles the operations and maintains the BST property through all manipulations.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = BSTNode(value) else: self._insert_recursive(node.right, value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.value = min_larger_node.value node.right = self._delete_recursive(node.right, min_larger_node.value) return node def _find_min(self, node): current = node while current.left is not None: current = current.left return current def search(self, value: int) -> BSTNode: return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._search_recursive(node.left, value) return self._search_recursive(node.right, value) def in_order_traversal(self) -> list[int]: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node is not None: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result)"},{"question":"```markdown You are working for a global e-commerce company that needs to support conversions between different weight units for its inventory management system. The system\'s database can contain weights in a variety of units including micrograms, milligrams, grams, kilograms, metric tons, and even carats, pounds, and ounces. You need to extend the existing conversion function to handle this diverse range of weight units. **Task:** Implement a function `extended_weight_conversion` that can convert a given weight measurement between a broader range of units. The function should extend the provided weight conversion for metric units and add support for carats, pounds, and ounces. **Function Signature:** ```python def extended_weight_conversion(value: float, from_unit: str, to_unit: str) -> float: pass ``` **Input and Output:** - **Input**: - `value` (float): The weight value to be converted. - `from_unit` (str): The unit of the given value. - `to_unit` (str): The unit to which conversion is required. - **Output**: - Returns the converted weight value as a float. **Constraints/Requirements**: - The function should handle case-insensitive unit names: e.g., \\"gram\\", \\"Gram\\", \\"GRAM\\" should be treated the same. - Supported units: microgram (µg), milligram (mg), gram (g), kilogram (kg), metric ton (t), carat (ct), pound (lb), ounce (oz). **Properties for New Units**: - 1 microgram (µg) = 1e-6 grams - 1 milligram (mg) = 1e-3 grams - 1 kilogram (kg) = 1e3 grams - 1 metric ton (t) = 1e6 grams - 1 carat (ct) = 0.2 grams - 1 pound (lb) = 453.59237 grams - 1 ounce (oz) = 28.349523125 grams **Example**: ```python print(extended_weight_conversion(1, \\"kilogram\\", \\"gram\\")) # Expected output: 1000.0 print(extended_weight_conversion(5, \\"pound\\", \\"ounce\\")) # Expected output: 80.0 print(extended_weight_conversion(1000, \\"carat\\", \\"gram\\")) # Expected output: 200.0 print(extended_weight_conversion(2, \\"metric ton\\", \\"kilogram\\")) # Expected output: 2000.0 print(extended_weight_conversion(5000000, \\"microgram\\", \\"milligram\\")) # Expected output: 5000.0 ``` Ensure your implementation includes proper error handling for invalid units. ```","solution":"def extended_weight_conversion(value: float, from_unit: str, to_unit: str) -> float: # Conversion factors to grams conversion_factors_to_grams = { \\"microgram\\": 1e-6, \\"milligram\\": 1e-3, \\"gram\\": 1.0, \\"kilogram\\": 1e3, \\"metric ton\\": 1e6, \\"carat\\": 0.2, \\"pound\\": 453.59237, \\"ounce\\": 28.349523125 } # Normalize unit strings to lower case from_unit = from_unit.lower() to_unit = to_unit.lower() # Check for valid units if from_unit not in conversion_factors_to_grams or to_unit not in conversion_factors_to_grams: raise ValueError(\\"Invalid unit provided\\") # Convert the value to grams value_in_grams = value * conversion_factors_to_grams[from_unit] # Convert the value from grams to the target unit converted_value = value_in_grams / conversion_factors_to_grams[to_unit] return converted_value"},{"question":"# Problem Statement You are given a list of strings representing file paths in a Unix-like filesystem. Each path is a string where components are separated by the \'/\' character. Your task is to implement an efficient function to find the longest common prefix of the given file paths. Function Signature ```python def longest_common_prefix(paths: list[str]) -> str: ``` Parameters * **paths**: A list of strings representing file paths. Returns * A single string representing the longest common prefix of the given file paths, including the \'/\' character. * If there is no common prefix, return an empty string. Input Constraints * The list `paths` contains between 1 and 10^4 strings. * Each path string has a length between 1 and 300 characters. * Each path follows a valid Unix-like format. Performance Requirements * The solution should run efficiently for up to 10^4 path strings. Example ```python # Sample Paths paths = [ \\"/home/user/docs\\", \\"/home/user/images\\", \\"/home/user/videos\\", \\"/home/user/docs/reports\\" ] assert longest_common_prefix(paths) == \\"/home/user/\\" paths2 = [ \\"/etc/nginx/nginx.conf\\", \\"/usr/local/bin/python\\", \\"/home/user/docs\\", \\"/var/log/syslog\\" ] assert longest_common_prefix(paths2) == \\"/\\" paths3 = [ \\"/var/log/nginx/error.log\\", \\"/var/log/nginx/access.log\\", \\"/var/log/apache2/error.log\\" ] assert longest_common_prefix(paths3) == \\"/var/log/\\" ```","solution":"def longest_common_prefix(paths: list[str]) -> str: if not paths: return \\"\\" # Find the shortest path in the list (as the longest common prefix can\'t be longer than the shortest path) shortest_path = min(paths, key=len) # Iterate over the characters of the shortest path for i in range(len(shortest_path)): char = shortest_path[i] # Compare this character with the same position in all other paths for path in paths: if path[i] != char: # Return the substring of the shortest path if a mismatch is found return shortest_path[:i].rsplit(\'/\', 1)[0] + \'/\' # If no mismatch was found, the entire shortest_path is the common prefix return shortest_path"},{"question":"# Coding Challenge: The Fibonacci sequence is a classic problem that is frequently used to demonstrate recursive and iterative programming techniques. In this challenge, you will implement an optimized approach to generate the nth Fibonacci number using dynamic programming. # Objective: Write a function `fibonacci_n` that: 1. Takes an integer `n` as an input. 2. Returns the nth Fibonacci number using an efficient method. Expected Input and Output: * **Input**: * An integer `n` (0 ≤ n ≤ 1000). * **Output**: * An integer representing the nth Fibonacci number. Performance Requirements: * The function should have a time complexity of O(n) and a space complexity of O(1). Constraints and Considerations: * Ensure the function handles large inputs up to n = 1000 efficiently. * Consider edge cases such as n = 0 or n = 1. * Avoid using simple recursion due to its exponential time complexity. * Use iteration and dynamic programming techniques for optimal performance. * Ensure the solution does not crash on invalid inputs by raising appropriate exceptions. # Example: ```python def fibonacci_n(n: int) -> int: if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b print(fibonacci_n(10)) # Expected output: 55 print(fibonacci_n(0)) # Expected output: 0 print(fibonacci_n(1)) # Expected output: 1 print(fibonacci_n(100)) # Expected output: 354224848179261915075 ``` # Note: * You are required to provide a detailed explanation of your implementation choices and any assumptions made. # Explanation: The `fibonacci_n` function uses an iterative approach to compute the nth Fibonacci number. Starting from the base cases of 0 and 1, it iteratively updates the variables to compute the subsequent Fibonacci numbers. This approach ensures a linear time complexity O(n) and constant space complexity O(1), making it efficient for large values of n. Exceptions are raised for invalid inputs to ensure robustness.","solution":"def fibonacci_n(n: int) -> int: Returns the nth Fibonacci number using an efficient iterative method. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement The Atbash Cipher is a simple substitution cipher originally used for the Hebrew alphabet but can be used for any known alphabet. In Atbash, each letter in an alphabet is mapped to its reverse, so the first letter becomes the last letter, the second letter becomes the second last letter, and so on. Implement the encryption and decryption functions for the Atbash Cipher. Function Signature ```python def atbash_encrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: def atbash_decrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: ``` # Input - `message`: A string to be encrypted or decrypted. The characters in `message` should all be present in `alphabet`. - `alphabet`(optional): A string containing unique characters used for encoding and decoding. The default alphabet is \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\". # Output - For `atbash_encrypt`: The encrypted string. - For `atbash_decrypt`: The decrypted string. # Constraints - The `alphabet` string must consist of unique characters. - All characters in `message` must be part of the given `alphabet`. # Example ```python # Example 1: original_message = \\"HELLO\\" encrypted = atbash_encrypt(original_message) assert encrypted == \\"SVOOL\\" # Example 2: ciphertext = \\"SVOOL\\" decrypted = atbash_decrypt(ciphertext) assert decrypted == \\"HELLO\\" # Example 3: custom_alphabet = \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" original_message = \\"ZYX\\" encrypted = atbash_encrypt(original_message, custom_alphabet) assert encrypted == \\"ABC\\" decrypted = atbash_decrypt(encrypted, custom_alphabet) assert decrypted == \\"ZYX\\" ``` # Notes 1. Validate the inputs properly before proceeding with encryption or decryption. 2. Use a modular approach to split the tasks into smaller, manageable functions. 3. Handle common edge cases, such as: - Message with spaces or special characters. - Empty message string. - Alphabet with repeated characters. 4. Ensure every character in the message is present within the provided alphabet. [End of Question]","solution":"def atbash_encrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Encrypts the message using the Atbash cipher with the given alphabet. if not message: return \\"\\" if len(set(alphabet)) != len(alphabet): raise ValueError(\\"Alphabet must contain unique characters\\") reverse_alphabet = alphabet[::-1] encryption_dict = {alphabet[i]: reverse_alphabet[i] for i in range(len(alphabet))} encrypted_message = [] for char in message: if char not in alphabet: raise ValueError(f\\"Character \'{char}\' not found in provided alphabet\\") encrypted_message.append(encryption_dict[char]) return \'\'.join(encrypted_message) def atbash_decrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Decrypts the message using the Atbash cipher with the given alphabet. # As the Atbash cipher is symmetric, encryption and decryption are the same. return atbash_encrypt(message, alphabet)"},{"question":"# Integer Spiral Traversal You are tasked with implementing a function to traverse and collect elements in a 2D integer grid according to a spiral order. Problem Statement Implement a function `spiral_traversal` to traverse a given 2D integer grid in a clockwise spiral order, starting from the top-left corner. 1. **spiral_traversal(grid: List[List[int]]) -> List[int]** - **Input**: - `grid`: A 2D list of integers representing the grid. It is guaranteed to be non-empty. - **Output**: Returns a list of integers, representing the grid elements collected in a clockwise spiral order. Constraints * The grid contains at least 1x1 elements. * The grid can have variable dimensions, i.e., not necessarily a square grid (e.g., 3x5, 4x6, etc.). Example ```python assert spiral_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] ``` Function Definition ```python def spiral_traversal(grid: List[List[int]]) -> List[int]: pass ``` # Requirements - Use an efficient algorithm to implement the spiral order traversal. - Ensure your function handles edge cases such as single row or single column grids. - Aim for O(n) time complexity, where `n` is the total number of elements in the grid.","solution":"from typing import List def spiral_traversal(grid: List[List[int]]) -> List[int]: Traverse a 2D list of integers in a spiral order. Args: grid (List[List[int]]): 2D list of integers. Returns: List[int]: List of integers representing spiral order. if not grid: return [] result = [] top, bottom = 0, len(grid) - 1 left, right = 0, len(grid[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right across the top row for i in range(left, right + 1): result.append(grid[top][i]) top += 1 # Traverse from top to bottom down the right column for i in range(top, bottom + 1): result.append(grid[i][right]) right -= 1 if top <= bottom: # Traverse from right to left across the bottom row for i in range(right, left - 1, -1): result.append(grid[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top up the left column for i in range(bottom, top - 1, -1): result.append(grid[i][left]) left += 1 return result"},{"question":"# Context You have been working with various graph traversal algorithms, and now it is time to delve into Depth-First Search (DFS). As part of a complex system, DFS can be used to detect cycles within a directed graph. # Task Implement a new Python function named `has_cycle` within the given Graph class. This function will utilize Depth-First Search (DFS) to determine if there is any cycle present in the directed graph. # Input 1. A Graph object representing a directed graph with vertices and edges. # Output 1. A boolean value: `True` if there is at least one cycle within the graph, otherwise `False`. # Constraints 1. The number of vertices (V) is at most (10^4). 2. The number of edges (E) is at most (5 times 10^4). # Performance Requirements 1. Ensure your solution has a time complexity of O(V + E). # Function Signature ```python class Graph: # (Include necessary methods for graph representation and manipulation) def has_cycle(self) -> bool: # Your implementation here pass ``` # Example ```python g = Graph() g = Graph.build([0, 1, 2, 3], [[0, 1], [1, 2], [2, 0], [2, 3]]) print(g.has_cycle()) # Expected output: True g = Graph() g = Graph.build([0, 1, 2, 3], [[0, 1], [1, 2], [2, 3]]) print(g.has_cycle()) # Expected output: False ``` Ensure your implementation adheres to the guidelines and performance constraints provided.","solution":"class Graph: def __init__(self): self.adjacency_list = {} @classmethod def build(cls, vertices, edges): graph = cls() for vertex in vertices: graph.adjacency_list[vertex] = [] for edge in edges: graph.adjacency_list[edge[0]].append(edge[1]) return graph def has_cycle(self) -> bool: visited = set() rec_stack = set() def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in self.adjacency_list.get(v, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for vertex in self.adjacency_list: if vertex not in visited: if dfs(vertex): return True return False"},{"question":"# Problem: Online Store - Inventory Management You are tasked with developing a function for an online store to manage its inventory. The store\'s inventory is represented as a list of items, where each item is a dictionary containing the item\'s name, current stock level, and price. Your function should perform the following operations based on a given command: 1. **Add Item**: Add a new item to the inventory. 2. **Update Stock**: Update the stock level of an existing item. 3. **Remove Item**: Remove an item from the inventory. 4. **Price Change**: Update the price of an existing item. 5. **Get Item**: Retrieve information of an item. 6. **List Items**: List all items in the inventory. # Input - `inventory` (list): A list of dictionaries representing the current inventory where each dictionary contains: * `name` (string): The name of the item. * `stock` (integer): The current stock level of the item. * `price` (float): The price of the item. - `command` (string): A string representing the operation to be performed: \\"add\\", \\"update_stock\\", \\"remove\\", \\"change_price\\", \\"get\\", or \\"list\\". - `item` (dictionary): A dictionary containing the item details (only used for \\"add\\", \\"update_stock\\", \\"remove\\", \\"change_price\\", and \\"get\\" operations). # Output - The function should return the updated inventory for \\"add\\", \\"update_stock\\", \\"remove\\", and \\"change_price\\" commands. - For \\"get\\" command, return the dictionary of the requested item. - For \\"list\\" command, return the list of all items in the inventory. # Constraints - Ensure the function handles incorrect commands gracefully. - Ensure the function manages empty or non-existing items appropriately. - Names of the items are unique within the inventory. - The function should execute within a reasonable timeframe for standard inventory sizes. # Example Usage ```python inventory = [ {\\"name\\": \\"Laptop\\", \\"stock\\": 10, \\"price\\": 999.99}, {\\"name\\": \\"Mouse\\", \\"stock\\": 50, \\"price\\": 19.99}, {\\"name\\": \\"Keyboard\\", \\"stock\\": 20, \\"price\\": 49.99}, ] add_command = \\"add\\" new_item = {\\"name\\": \\"Monitor\\", \\"stock\\": 15, \\"price\\": 199.99} result = inventory_management(inventory, add_command, new_item) print(result) # Expected output: [ # {\\"name\\": \\"Laptop\\", \\"stock\\": 10, \\"price\\": 999.99}, # {\\"name\\": \\"Mouse\\", \\"stock\\": 50, \\"price\\": 19.99}, # {\\"name\\": \\"Keyboard\\", \\"stock\\": 20, \\"price\\": 49.99}, # {\\"name\\": \\"Monitor\\", \\"stock\\": 15, \\"price\\": 199.99} # ] ``` # Implementation Tips - Use list comprehensions, filtering, or iterations to manage items in the inventory. - Each command should be handled with appropriate error handling. - Ensure each operation modifies or retrieves data appropriately based on its requirements.","solution":"def inventory_management(inventory, command, item=None): Manages the inventory of an online store based on the given command. Parameters: inventory (list): The list of items in the inventory. command (str): The command to execute (\'add\', \'update_stock\', \'remove\', \'change_price\', \'get\', \'list\'). item (dict, optional): The item details (only used for specific commands). Returns: list or dict: The updated inventory, specific item, or list of items based on the command. if command == \\"add\\": inventory.append(item) return inventory elif command == \\"update_stock\\": for idx, inv_item in enumerate(inventory): if inv_item[\'name\'] == item[\'name\']: inventory[idx][\'stock\'] = item[\'stock\'] return inventory elif command == \\"remove\\": inventory = [inv_item for inv_item in inventory if inv_item[\'name\'] != item[\'name\']] return inventory elif command == \\"change_price\\": for idx, inv_item in enumerate(inventory): if inv_item[\'name\'] == item[\'name\']: inventory[idx][\'price\'] = item[\'price\'] return inventory elif command == \\"get\\": for inv_item in inventory: if inv_item[\'name\'] == item[\'name\']: return inv_item elif command == \\"list\\": return inventory else: return \\"Invalid command\\""},{"question":"# Problem Statement You are tasked with implementing a function that evaluates an arithmetic expression represented as a string. The expression contains only non-negative integers, addition (+), and subtraction (-) operators. # Requirements Implement a function `evaluate_expression(expression: str) -> int` that: 1. Parses and evaluates the given arithmetic expression. 2. Handles the operations according to the correct operator precedence and left-to-right associativity. 3. Assumes the input expression is always valid and there are no parentheses or spaces in the string. # Input & Output - **Input**: A single string `expression` representing the arithmetic expression. - **Output**: An integer that is the result of evaluating the expression. # Constraints - The expression will contain at most 1000 characters. - The expression will include only non-negative integers and the \'+\' and \'-\' operators. - Integers in the expression will be between 0 and 1000, inclusive. # Example ```python # Example 1 expression = \\"3+5-2\\" result = evaluate_expression(expression) print(result) # Output: 6 # Example 2 expression = \\"10-3+2\\" result = evaluate_expression(expression) print(result) # Output: 9 # Example 3 expression = \\"7+2-4+1\\" result = evaluate_expression(expression) print(result) # Output: 6 ``` # Note - You do not need to handle any other operators or parentheses in this task. - The function should take into account the standard left-to-right evaluation without any operator precedence beyond `+` and `-`.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing only non-negative integers, addition (+), and subtraction (-) operators. :param expression: A string representing the arithmetic expression. :return: The evaluated result as an integer. # Split the expression into terms separated by + or - terms = [] current_num = \\"\\" current_operator = \\"+\\" for char in expression: if char.isdigit(): current_num += char else: if current_operator == \\"+\\": terms.append(int(current_num)) elif current_operator == \\"-\\": terms.append(-int(current_num)) current_num = \\"\\" current_operator = char # Append the last number if current_operator == \\"+\\": terms.append(int(current_num)) elif current_operator == \\"-\\": terms.append(-int(current_num)) # Calculate the result by summing up the terms result = sum(terms) return result"},{"question":"# Data Analysis with Linear Regression You are to implement a data analysis script that performs linear regression on a given dataset. The dataset consists of two numeric variables, `X` and `Y`, and the objective is to find the best-fit line that explains the relationship between these variables. Specific Requirements 1. **Input**: A dataset (list of tuples) where each tuple contains a pair of values (X, Y). 2. **Output**: The slope and intercept of the best-fit line. 3. **Constraints**: * The dataset can have a minimum of 10 and a maximum of 1000 data points. * Ensure your implementation efficiently computes the regression parameters. * Handle cases where variance of X is zero by returning `(None, None)`. Performance Requirements * The script should minimize computational overhead and make use of efficient data structures. * Ensure numerical stability in the calculations, especially when dealing with floating-point operations. Scenario Your organization needs to analyze the relationship between two variables for predictive modeling. You are tasked with implementing a function that derives the best-fit line using linear regression, allowing further analysis and forecasting. Implement the following function: ```python def linear_regression(data: list) -> tuple: Given a dataset, compute and return the slope and intercept of the best-fit line. Parameters: data (list): A list of tuples with each tuple containing (X, Y). Returns: tuple: A tuple containing the slope and intercept of the best-fit line. pass ``` **Example Usage:** ```python dataset = [(1, 2), (2, 3), (4, 5), (6, 7), (8, 9)] slope, intercept = linear_regression(dataset) print(f\\"Slope: {slope}, Intercept: {intercept}\\") ``` Ensure your solution correctly computes the slope and intercept, handling edge cases as specified.","solution":"def linear_regression(data: list) -> tuple: Given a dataset, compute and return the slope and intercept of the best-fit line. Parameters: data (list): A list of tuples with each tuple containing (X, Y). Returns: tuple: A tuple containing the slope and intercept of the best-fit line. if not 10 <= len(data) <= 1000: raise ValueError(\\"Dataset must have between 10 and 1000 data points\\") n = len(data) sum_x = sum_y = sum_xy = sum_x_squared = 0 for x, y in data: sum_x += x sum_y += y sum_xy += x * y sum_x_squared += x * x # Calculate the means of x and y mean_x = sum_x / n mean_y = sum_y / n # Calculate the terms needed for the numerator and denominator of the slope numerator = sum_xy - n * mean_x * mean_y denominator = sum_x_squared - n * mean_x * mean_x if denominator == 0: return (None, None) slope = numerator / denominator intercept = mean_y - slope * mean_x return slope, intercept"},{"question":"# Coding Challenge: Scheduling Tasks to Minimize Completion Time Scenario: You are a project manager tasked with assigning tasks to workers in a way that minimizes the total completion time of all tasks. Each task can only be assigned to one worker, and each worker can only work on one task at a time. The goal is to distribute the tasks as efficiently as possible to minimize the overall completion time, assuming all workers can start simultaneously and only handle one task at a time. Task: Implement a scheduling algorithm to assign tasks to workers in such a way that the total completion time is minimized. The algorithm should process tasks with varying durations while distributing them evenly among the workers. Input: * An integer `m` representing the number of workers. * A list of integers `tasks`, where each integer represents the duration of a task in hours. Output: A list of lists, where each list represents the tasks assigned to a worker. The assignment should ensure that the maximum time taken by any worker is minimized. Constraints: * (1 leq m leq 100) * (1 leq text{len(tasks)} leq 1000) * (1 leq text{tasks[i]} leq 1000) Example: Input: ``` m = 3 tasks = [2, 3, 5, 7, 1, 4, 3, 6] ``` Output: ``` [[7, 3], [6, 4], [5, 2, 1, 3]] ``` Explanation: In this example, the assignment minimizes the maximum time a single worker spends on tasks. The sums are 10, 10, and 11 hours, respectively, which is the best distribution given the input constraints. Implementation Details: - Define a function `schedule_tasks(m: int, tasks: List[int]) -> List[List[int]]` to perform the task. - Use efficient algorithms and data structures to ensure the solution is optimal within the given constraints. ```python from typing import List def schedule_tasks(m: int, tasks: List[int]) -> List[List[int]]: tasks.sort(reverse=True) workers = [[] for _ in range(m)] load = [0] * m for task in tasks: min_worker = load.index(min(load)) workers[min_worker].append(task) load[min_worker] += task return workers # Example usage: if __name__ == \\"__main__\\": m = 3 tasks = [2, 3, 5, 7, 1, 4, 3, 6] print(schedule_tasks(m, tasks)) ``` Notes: - Ensure that your function `schedule_tasks` adheres to the provided input and output formats. - Consider the edge cases where the number of tasks is less than or greater than the number of workers. This new question matches the style, complexity, and scope of the provided sample, focusing on efficient task distribution to minimize overall task completion time.","solution":"from typing import List def schedule_tasks(m: int, tasks: List[int]) -> List[List[int]]: Distributes tasks to workers such that the maximum time taken by any worker is minimized. Parameters: m (int): Number of workers. tasks (List[int]): List of task durations. Returns: List[List[int]]: List of tasks assigned to each worker. tasks.sort(reverse=True) workers = [[] for _ in range(m)] load = [0] * m for task in tasks: min_worker = load.index(min(load)) workers[min_worker].append(task) load[min_worker] += task return workers"},{"question":"# Problem Statement You are provided with a string consisting of lowercase letters and digits. Your task is to determine if the digits in the string form a **palindromic sequence**. A sequence is considered palindromic if it reads the same backward as forward. For example, in the string `\\"abc12321def\\"`, the digits `12321` form a palindromic sequence. # Input * A string `s` where `0 <= len(s) <= 10^5`. # Output * Return `True` if the digits in the string form a palindromic sequence, otherwise return `False`. # Implementation Implement the following function: ```python def is_palindromic_sequence(s: str) -> bool: Determine if digits in a string form a palindromic sequence. :param s: Input string containing lowercase letters and digits :return: Boolean indicating if the digits form a palindromic sequence >>> is_palindromic_sequence(\\"abc12321def\\") True >>> is_palindromic_sequence(\\"abc12345def\\") False >>> is_palindromic_sequence(\\"abc\\") True >>> is_palindromic_sequence(\\"12321\\") True >>> is_palindromic_sequence(\\"1a2b3c2b1\\") True pass ``` # Constraints * The string can be empty. * The string can contain up to `10^5` characters. # Edge Cases * String with no digits must be considered palindromic. * Single digit strings must be considered palindromic. # Example ```python print(is_palindromic_sequence(\\"abc12321def\\")) # Output: True print(is_palindromic_sequence(\\"abc12345def\\")) # Output: False print(is_palindromic_sequence(\\"abc\\")) # Output: True print(is_palindromic_sequence(\\"12321\\")) # Output: True print(is_palindromic_sequence(\\"1a2b3c2b1\\")) # Output: True ```","solution":"def is_palindromic_sequence(s: str) -> bool: Determine if digits in a string form a palindromic sequence. :param s: Input string containing lowercase letters and digits :return: Boolean indicating if the digits form a palindromic sequence >>> is_palindromic_sequence(\\"abc12321def\\") True >>> is_palindromic_sequence(\\"abc12345def\\") False >>> is_palindromic_sequence(\\"abc\\") True >>> is_palindromic_sequence(\\"12321\\") True >>> is_palindromic_sequence(\\"1a2b3c2b1\\") True # Extract all digits from the string digits = [char for char in s if char.isdigit()] # Check if the sequence of digits is a palindrome return digits == digits[::-1]"},{"question":"# Question: Implement a Pathfinding Algorithm for a Weighted Graph Context You are required to implement a pathfinding algorithm on a weighted graph. The graph is represented as a dictionary where each key is a node, and the value is a list of tuples representing the connected nodes and their respective weights. Objective Write a Python function `dijkstra` that computes the shortest path from a start node to an end node using Dijkstra\'s algorithm. # Requirements 1. **Function Definition**: Implement a function `dijkstra`: ```python def dijkstra(graph: Dict[str, List[Tuple[str, float]]], start: str, end: str) -> Tuple[List[str], float]: ``` Input Format - `graph`: A dictionary where keys are node identifiers (strings) and values are lists of tuples: - Each tuple consists of a connected node identifier (string) and the weight of the edge (float). - `start`: The starting node identifier (string). - `end`: The ending node identifier (string). Output Format - A tuple containing: - A list of node identifiers representing the shortest path from `start` to `end`. - The total weight (sum of edge weights) of this path. Constraints - All nodes and edges in the graph have unique identifiers and positive weights. - The graph may contain cycles. - The input nodes `start` and `end` will always be present in the graph. - Ensure robustness and efficiency in computation. Example Usage ```python def dijkstra(graph: Dict[str, List[Tuple[str, float]]], start: str, end: str) -> Tuple[List[str], float]: pass # Example Graph graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } # Function Call path, weight = dijkstra(graph, \'A\', \'D\') print(path, weight) # Expected output might be: [\'A\', \'B\', \'C\', \'D\'], 4.0 ``` # Guidelines: - Ensure to handle edge cases, such as when the graph is sparse. - Use a priority queue (min-heap) to optimize the algorithm\'s performance. - Document the solution clearly, including any helper functions used.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[str, List[Tuple[str, float]]], start: str, end: str) -> Tuple[List[str], float]: Computes the shortest path using Dijkstra\'s algorithm from start to end in a weighted graph. Parameters: graph (Dict[str, List[Tuple[str, float]]]): The graph represented as an adjacency list. start (str): The starting node. end (str): The ending node. Returns: Tuple[List[str], float]: A tuple containing the list of nodes representing the shortest path and the total weight of this path. # Priority queue to store the nodes to be visited queue = [(0, start, [])] # Dictionary to store the shortest path to each node visited = set() min_dist = {start: 0} while queue: (cost, node, path) = heapq.heappop(queue) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path, cost for neighbor, weight in graph.get(node, []): if neighbor in visited: continue old_cost = min_dist.get(neighbor, float(\'inf\')) new_cost = cost + weight if new_cost < old_cost: min_dist[neighbor] = new_cost heapq.heappush(queue, (new_cost, neighbor, path)) return [], float(\'inf\') # In case no path is found # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } path, weight = dijkstra(graph, \'A\', \'D\') print(path, weight) # Expected output might be: [\'A\', \'B\', \'C\', \'D\'], 4.0"},{"question":"# Dijkstra\'s Algorithm Implementation with Heuristic In this task, you are required to implement a modified version of Dijkstra\'s algorithm that incorporates a heuristic function to prioritize nodes during traversal, similar to an A* search algorithm but without requiring strict admissibility of the heuristic function. Your Task Write a function `dijkstra_with_heuristic` that modifies the Dijkstra\'s algorithm as follows: * **Input**: - `graph`: Dictionary where keys are vertex indices and values are lists of tuples representing edges with `(destination_vertex, cost)`. - `vertex_count`: Integer denoting the number of vertices. - `src`: Integer denoting the source vertex. - `heuristic`: Function taking two arguments `(vertex, target)` returning an integer cost estimate from the current vertex to the target. - `target`: Integer denoting the target vertex. * **Output**: - Return a list of shortest distances from the source to each vertex. - If the provided graph is disconnected or the target is unreachable, include `float(\'inf\')` for unreachable vertices only. - Use the heuristic function to influence the traversal priority, but do not modify the fundamental cost-based optimization of Dijkstra\'s algorithm. Constraints * (1 leq text{vertex_count} leq 500) * Vertex indices range from (0) to (vertex_count - 1). * Edge costs can be non-negative integers. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } vertex_count = 4 src = 0 target = 3 def heuristic(u, v): # Example heuristic: all paths are equal (no specific knowledge of graph) return 1 shortest_distances = dijkstra_with_heuristic(graph, vertex_count, src, heuristic, target) print(\\"Shortest distances:\\", shortest_distances) ``` Expectations: 1. **Correctness**: Properly compute the shortest paths from the source to all vertices while incorporating the heuristic. 2. **Efficiency**: Implement the algorithm within the provided constraints. 3. **Robust Handling**: Properly address edge cases and handle any error scenarios. This question requires implementing Dijkstra\'s algorithm with an added twist of a heuristic function to influence traversal, closely aligning with the complexity, scope, and style of the original questions.","solution":"import heapq def dijkstra_with_heuristic(graph, vertex_count, src, heuristic, target): Function to perform a modified version of Dijkstra\'s algorithm with a heuristic. Parameters: graph (dict): Dictionary representing the adjacency list of the graph. vertex_count (int): Number of vertices in the graph. src (int): Source vertex. heuristic (function): Function that returns the heuristic cost estimate. target (int): Target vertex. Returns: list: List of shortest distances from the source to each vertex. # Initialize distances with infinity distances = [float(\'inf\')] * vertex_count distances[src] = 0 # Priority queue to store (cost, vertex) pq = [(0 + heuristic(src, target), src)] while pq: current_cost, u = heapq.heappop(pq) # Early exit if we reach the target if u == target: break # Explore neighbors for v, weight in graph.get(u, []): if distances[u] + weight < distances[v]: distances[v] = distances[u] + weight heapq.heappush(pq, (distances[v] + heuristic(v, target), v)) return distances"},{"question":"# Task: Implementing and Optimizing Merge Sort You are required to implement a merge sort algorithm optimized for performance and stability. Your implementation should gracefully handle typical edge cases and aim for better average-case performance over the provided merge sort example. # Input: 1. **list of integers or floats, `arr`**: The data to be sorted. # Output: - **list of sorted numbers**: The input list sorted in ascending order. # Constraints: - `-10^7 <= arr[i] <= 10^7` for all valid `i`. - `0 <= len(arr) <= 10^6`. # Performance Requirements: - Optimize for both time and space usage while maintaining stability. - Handle edge cases like empty lists, single element lists, and large range of values effectively. - Ensure the algorithm performs competitively with traditional comparison-based sorting algorithms in terms of runtime (O(n log n)). # Example: ```python # Example usage: data = [12, 11, 13, 5, 6, 7] assert merge_sort(data) == sorted(data) data = [] assert merge_sort(data) == [] data = [42] assert merge_sort(data) == [42] ``` # Additional Notes: - Carefully design the merge operations to maintain stability. - Consider the impact of space complexity during the recursive splits and merges. - Account for real-world datasets and prepare for non-uniform distributions. # Implementation Hints: - Utilize a helper function to merge two sorted subarrays. - Ensure the base case handles lists of length 0 or 1 directly. - If possible, implement an adaptive version that switches to insertion sort for small subarrays (e.g., less than a specified threshold).","solution":"def merge_sort(arr): Perform merge sort on the input list and return the sorted list. if len(arr) <= 1: return arr def merge(left, right): Merge two sorted subarrays into a single sorted array in a stable manner. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def merge_sort_recursive(sublist): if len(sublist) <= 10: # Use insertion sort for small sublists to improve performance return insertion_sort(sublist) mid = len(sublist) // 2 left_half = merge_sort_recursive(sublist[:mid]) right_half = merge_sort_recursive(sublist[mid:]) return merge(left_half, right_half) def insertion_sort(sublist): for i in range(1, len(sublist)): key = sublist[i] j = i - 1 while j >= 0 and key < sublist[j]: sublist[j + 1] = sublist[j] j -= 1 sublist[j + 1] = key return sublist return merge_sort_recursive(arr)"},{"question":"# Question You are required to design a function that finds and returns all the strongly connected components (SCCs) in a directed graph using Tarjan\'s algorithm. **Core Concepts**: A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph, i.e., a subgraph where every vertex is reachable from every other vertex in the subgraph. # Input - An integer `n` representing the number of vertices in the graph. - A list of tuples `edges` representing the edges of the graph. Each tuple ( (u, v) ) represents a directed edge from vertex `u` to vertex `v`. # Output - A list of lists where each inner list represents a strongly connected component, containing the vertices of that component in ascending order. # Constraints - 1 ≤ n ≤ 1000 (number of vertices) - 0 ≤ len(edges) ≤ 2000 (number of edges) # Example ```python n = 5 edges = [(1, 0), (0, 2), (2, 1), (0, 3), (3, 4)] print(find_scc(n, edges)) ``` Output: ```python [[0, 1, 2], [3], [4]] ``` # Implementation Function signature: ```python def find_scc(n: int, edges: list[tuple[int, int]]) -> list[list[int]]: pass ``` # Steps to Solve: 1. Construct the graph from the input edge list. 2. Use Tarjan\'s algorithm to perform a Depth First Search (DFS) and compute the discovery and low-link values for each vertex. 3. Identify and extract the strongly connected components based on the computed values during the DFS traversal. **Additional Information**: Your implementation should efficiently handle graphs with a large number of vertices and edges within the constraints. Consider edge cases such as isolated vertices or multiple strongly connected components within the graph.","solution":"def find_scc(n, edges): from collections import defaultdict def tarjan_scc(u): nonlocal index disc[u] = low[u] = index index += 1 stack.append(u) on_stack[u] = True for v in graph[u]: if disc[v] == -1: # If v is not visited tarjan_scc(v) low[u] = min(low[u], low[v]) elif on_stack[v]: low[u] = min(low[u], disc[v]) # If u is a root node if low[u] == disc[u]: scc = [] while True: v = stack.pop() on_stack[v] = False scc.append(v) if v == u: break scc_result.append(sorted(scc)) graph = defaultdict(list) for u, v in edges: graph[u].append(v) disc = [-1] * n low = [-1] * n on_stack = [False] * n stack = [] index = 0 scc_result = [] for i in range(n): if disc[i] == -1: tarjan_scc(i) return sorted(scc_result, key=lambda x: x[0])"},{"question":"# Longest Consecutive Subarray of Distinct Elements Objective This task requires you to write a function that finds the length of the longest consecutive subarray consisting of distinct elements from a given list of integers. Scenario You are developing a feature for a music streaming app that helps users find the longest sequence of unique songs they have listened to without repeating any song. Function Signature ```python def longest_distinct_subarray_length(nums: Sequence[int] | None = None) -> int: ``` Input and Output - **Input**: A single parameter, `nums`, which is a sequence of integers. If `nums` is `None` or an empty sequence, the function should raise a `ValueError` with the message \\"Input sequence should not be empty\\". - **Output**: Returns an integer representing the length of the longest subarray with all distinct elements in the input list. Constraints - The sequence can include both positive and negative integers. - The function should strive to be optimized with a target time complexity of O(n). Examples 1. `longest_distinct_subarray_length([1, 2, 3, 1, 2])` should return `3` because the longest subarray with distinct elements is `[1, 2, 3]`. 2. `longest_distinct_subarray_length([1, 1, 1, 1, 1])` should return `1` because the longest subarray with distinct elements is `[1]`. 3. `longest_distinct_subarray_length([-1, -2, -3, -2, -1])` should return `3` because the longest subarray with distinct elements is `[-1, -2, -3]`. 4. `longest_distinct_subarray_length([])` should raise a `ValueError` with the message \\"Input sequence should not be empty\\". Instructions 1. Implement the `longest_distinct_subarray_length` function. 2. The implementation must handle edge cases like empty arrays and arrays with all repeated numbers. 3. The implementation should pass the provided examples and other edge cases effectively. Testing - Ensure to test your implementation with the provided examples. - Evaluate other potential edge cases to ensure robustness.","solution":"from typing import Sequence def longest_distinct_subarray_length(nums: Sequence[int] | None = None) -> int: Returns the length of the longest consecutive subarray consisting of distinct elements. Parameters: nums (Sequence[int]): The list of integers to examine. Returns: int: Length of the longest subarray with distinct elements. Raises: ValueError: If the input sequence is None or empty. if nums is None or len(nums) == 0: raise ValueError(\\"Input sequence should not be empty\\") max_len = 0 start = 0 seen = {} for end, value in enumerate(nums): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Water Tanks Capacity Calculation Context In civil engineering, calculating the total water holding capacity of a series of water tanks with varying dimensions and shapes is crucial for designing efficient water storage systems. The tanks can be either cylindrical or rectangular prism shapes. Problem Write a Python function `calculate_total_capacity` that computes the total water holding capacity of a series of tanks with varying dimensions and shapes using the following signature: ```python def calculate_total_capacity(tanks: List[Dict[str, Union[str, float]]]) -> float: pass ``` Input & Output **Input:** - **tanks** (List[Dict[str, Union[str, float]]]): A list of dictionaries where each dictionary represents a tank. Each dictionary contains: - **\'shape\'** (str): Shape of the tank, either \'cylindrical\' or \'rectangular\'. - For cylindrical tanks: - **\'radius\'** (float): Radius of the cylindrical tank in meters. - **\'height\'** (float): Height of the cylindrical tank in meters. - For rectangular tanks: - **\'length\'** (float): Length of the rectangular tank in meters. - **\'width\'** (float): Width of the rectangular tank in meters. - **\'height\'** (float): Height of the rectangular tank in meters. **Output:** - **Result:** (float) Total water holding capacity of all the tanks combined in cubic meters. Constraints 1. All input parameters must be positive. 2. The shape of the tank must be either \'cylindrical\' or \'rectangular\'. 3. Radius, length, width, and height must be positive values. Performance Constraints The function should operate efficient enough to handle lists up to 10,000 tanks in a reasonable time. Function Execution - If the input values do not meet the constraints, raise a `ValueError` with the message \\"Invalid input parameters\\". # Examples ```python >>> tanks = [ {\\"shape\\": \\"cylindrical\\", \\"radius\\": 2, \\"height\\": 5}, {\\"shape\\": \\"rectangular\\", \\"length\\": 3, \\"width\\": 2, \\"height\\": 4} ] >>> calculate_total_capacity(tanks) 88.0 >>> tanks = [ {\\"shape\\": \\"cylindrical\\", \\"radius\\": 1, \\"height\\": 10}, {\\"shape\\": \\"rectangular\\", \\"length\\": 2, \\"width\\": 2, \\"height\\": 3} ] >>> calculate_total_capacity(tanks) 34.28 ``` Note - For cylindrical tanks, use the formula for volume ( V = pi r^2 h ). - For rectangular tanks, use the formula for volume ( V = l times w times h ).","solution":"from math import pi from typing import List, Dict, Union def calculate_total_capacity(tanks: List[Dict[str, Union[str, float]]]) -> float: total_capacity = 0.0 for tank in tanks: shape = tank.get(\'shape\') if shape == \'cylindrical\': radius = tank.get(\'radius\') height = tank.get(\'height\') if not (radius and height and radius > 0 and height > 0): raise ValueError(\\"Invalid input parameters\\") capacity = pi * (radius ** 2) * height elif shape == \'rectangular\': length = tank.get(\'length\') width = tank.get(\'width\') height = tank.get(\'height\') if not (length and width and height and length > 0 and width > 0 and height > 0): raise ValueError(\\"Invalid input parameters\\") capacity = length * width * height else: raise ValueError(\\"Invalid input parameters\\") total_capacity += capacity return round(total_capacity, 2)"},{"question":"# Coding Assessment Question Context In computer graphics, scaling is a transformation that enlarges or diminishes objects. Let us consider 2D scaling across x and y axes. The scaling can be controlled with two scale factors: `sx` for the x-axis and `sy` for the y-axis. The formula to compute the scaled coordinates ((x\', y\')) from original coordinates ((x, y)) is given by: [ x\' = sx times x ] [ y\' = sy times y ] Where (sx) and (sy) are the scaling factors for the x-axis and y-axis respectively. Task Write a function `scale_coordinates` that takes three arguments: - `coordinates` (List[Tuple[float, float]]): a list of tuples where each tuple represents original coordinates ((x, y)), - `sx` (float): the scaling factor along the x-axis, - `sy` (float): the scaling factor along the y-axis. The function should correctly calculate and return a new list of tuples representing the scaled coordinates. Function Signature ```python def scale_coordinates(coordinates: list[tuple[float, float]], sx: float, sy: float) -> list[tuple[float, float]]: pass ``` Input Constraints 1. `coordinates`: non-empty list of tuples, each containing two floats. 2. `sx` and `sy`: float values representing the scaling factors. Both can be positive, negative, or zero. Output Return a list of tuples representing the scaled coordinates. Example Usage ```python >>> scale_coordinates([(1, 2), (3, 4), (5, 6)], 2, 3) [(2, 6), (6, 12), (10, 18)] >>> scale_coordinates([(0, 0), (-1, -2), (4.5, 3.3)], -1, -1) [(0, 0), (1, 2), (-4.5, -3.3)] >>> scale_coordinates([(10, 20), (30, 40)], 0, 0) [(0, 0), (0, 0)] >>> scale_coordinates([(1.5, 2.5)], 1, 0) [(1.5, 0.0)] ``` Performance Requirements None specific for this function, due to linear complexity based on the length of the input list.","solution":"def scale_coordinates(coordinates, sx, sy): Scales 2D coordinates by given factors sx (x-axis) and sy (y-axis). :param coordinates: List of tuples, each containing two floats representing the coordinates (x, y) :param sx: Scaling factor along the x-axis :param sy: Scaling factor along the y-axis :return: List of tuples with scaled coordinates return [(sx * x, sy * y) for x, y in coordinates]"},{"question":"# Problem Statement You are required to design a system that simulates the management of a parking lot. The parking lot has a fixed number of spaces, and vehicles can either enter or exit the lot. Each vehicle is identified by a unique license plate. The goal is to efficiently manage vehicle entries and exits and to keep track of the current occupied and available spaces in the parking lot. # Requirements 1. **Class Implementation**: Implement the class `ParkingLot` which manages the parking lot operations. - **Methods**: - `__init__(self, total_spaces: int)`: Initializes the parking lot with a given number of total parking spaces. - `enter(self, license_plate: str) -> bool`: Registers a vehicle entering the parking lot. Returns `True` if the vehicle successfully entered (i.e., there was an available space), `False` otherwise. - `exit(self, license_plate: str) -> bool`: Registers a vehicle exiting the parking lot. Returns `True` if the vehicle successfully exited (i.e., the vehicle was indeed in the lot), `False` otherwise. - `get_current_occupancy(self) -> int`: Returns the current number of occupied spaces. - `get_available_spaces(self) -> int`: Returns the current number of available spaces. 2. **Constraints**: - Assume that all license plates are valid, unique strings. - A vehicle cannot enter if it is already in the parking lot. - A vehicle cannot exit if it is not currently in the parking lot. - The parking lot cannot have more vehicles than its total capacity. 3. **Example**: ```python parking_lot = ParkingLot(3) print(parking_lot.enter(\'ABC123\')) # Output: True print(parking_lot.enter(\'DEF456\')) # Output: True print(parking_lot.enter(\'GHI789\')) # Output: True print(parking_lot.enter(\'JKL012\')) # Output: False print(parking_lot.get_current_occupancy()) # Output: 3 print(parking_lot.get_available_spaces()) # Output: 0 print(parking_lot.exit(\'DEF456\')) # Output: True print(parking_lot.get_current_occupancy()) # Output: 2 print(parking_lot.get_available_spaces()) # Output: 1 print(parking_lot.enter(\'JKL012\')) # Output: True ``` 4. **Edge Cases**: - A vehicle attempting to enter when the lot is full. - A vehicle attempting to exit when it is not currently in the lot. - A vehicle attempting to enter when it is already in the lot. # Hints - Use a set to keep track of the vehicles currently in the parking lot. - Ensure efficient operations with appropriate data structures to handle the add, remove, and check operations.","solution":"class ParkingLot: def __init__(self, total_spaces: int): Initializes the parking lot with a given number of total parking spaces. self.total_spaces = total_spaces self.occupied_spaces = 0 self.vehicles = set() # Use a set to keep track of vehicles in the parking lot def enter(self, license_plate: str) -> bool: Registers a vehicle entering the parking lot. Returns True if the vehicle successfully entered, False otherwise. if self.occupied_spaces < self.total_spaces and license_plate not in self.vehicles: self.vehicles.add(license_plate) self.occupied_spaces += 1 return True return False def exit(self, license_plate: str) -> bool: Registers a vehicle exiting the parking lot. Returns True if the vehicle successfully exited, False otherwise. if license_plate in self.vehicles: self.vehicles.remove(license_plate) self.occupied_spaces -= 1 return True return False def get_current_occupancy(self) -> int: Returns the current number of occupied spaces. return self.occupied_spaces def get_available_spaces(self) -> int: Returns the current number of available spaces. return self.total_spaces - self.occupied_spaces"},{"question":"# Programming Question: Number to Roman Numerals Converter **Context**: Converting numbers into Roman numerals is a common problem that tests one\'s understanding of loops, conditionals, and mapping between different numeral systems. This task could be useful for educational software or applications that involve displaying date and numerical information in historical formats. **Problem Statement**: Write a function `int_to_roman(num: int) -> str` that converts an integer to its Roman numeral representation. Ensure to handle various input constraints and validate the range of the number. **Function Signature**: ```python def int_to_roman(num: int) -> str: pass ``` **Input**: * An integer `num` representing the number to be converted. **Output**: * A string stating: `\'The number {num} in Roman numerals is {roman}!\'`, where `{roman}` is the constructed Roman numeral string. **Constraints**: * The `num` must be between 1 and 3999 inclusive. * Ensure the function raises appropriate exceptions for: * Numbers outside the valid range. **Examples**: ```python int_to_roman(4) # Output: \'The number 4 in Roman numerals is IV!\' int_to_roman(1990) # Output: \'The number 1990 in Roman numerals is MCMXC!\' int_to_roman(2024) # Output: \'The number 2024 in Roman numerals is MMXXIV!\' ``` **Notes**: * You may use a predefined mapping of integers to Roman numeral strings. * Pay attention to the correct order and combination of Roman numeral values. * Do not worry about zero or negative numbers, as they are outside the valid range.","solution":"def int_to_roman(num): Converts an integer to its Roman numeral representation. Args: - num: an integer between 1 and 3999 inclusive. Returns: - A string stating: \'The number {num} in Roman numerals is {roman}!\', where {roman} is the constructed Roman numeral string. if not (1 <= num <= 3999): raise ValueError(\\"The number must be between 1 and 3999 inclusive.\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return f\'The number {num} in Roman numerals is {roman_num}!\'"},{"question":"# Compression Ratio Calculation Consider that you are developing a software tool for use in automotive engineering. One of the tasks is to calculate the compression ratio of an internal combustion engine. The compression ratio is defined as the ratio of the total volume of the combustion chamber when the piston is at the bottom of its stroke (BDC) to the volume of the combustion chamber when the piston is at the top of its stroke (TDC). The formula for calculating the compression ratio (CR) is: [ CR = dfrac{V_{BDC}}{V_{TDC}} ] Where: - ( V_{BDC} ) is the volume of the combustion chamber at bottom dead center (in cubic centimeters). - ( V_{TDC} ) is the volume of the combustion chamber at top dead center (in cubic centimeters). You need to implement a function that takes two parameters and returns the compression ratio. Input values should be validated according to their physical constraints: - Volume at BDC must be greater than volume at TDC. - Both volumes must be greater than 0. # Function Signature ```python def calculate_compression_ratio(volume_bdc: float, volume_tdc: float) -> float: ``` # Input - `volume_bdc` (float): The volume of the combustion chamber at bottom dead center in cubic centimeters (must be > 0 and > `volume_tdc`). - `volume_tdc` (float): The volume of the combustion chamber at top dead center in cubic centimeters (must be > 0 and < `volume_bdc`). # Output - `float`: The compression ratio of the engine. # Constraints - Raise a `ValueError` with an appropriate message for the following conditions: - If `volume_bdc` ≤ 0: \\"Invalid volume at BDC\\" - If `volume_tdc` ≤ 0: \\"Invalid volume at TDC\\" - If `volume_bdc` ≤ `volume_tdc`: \\"Volume at BDC must be greater than volume at TDC\\" # Examples 1. `calculate_compression_ratio(volume_bdc=500, volume_tdc=50)` should return `10.0`. 2. `calculate_compression_ratio(volume_bdc=600, volume_tdc=60)` should return `10.0`. 3. `calculate_compression_ratio(volume_bdc=700, volume_tdc=70)` should return `10.0`. 4. `calculate_compression_ratio(volume_bdc=600, volume_tdc=100)` should return `6.0`. 5. `calculate_compression_ratio(volume_bdc=700, volume_tdc=0)` should raise `ValueError: Invalid volume at TDC`. 6. `calculate_compression_ratio(volume_bdc=-500, volume_tdc=50)` should raise `ValueError: Invalid volume at BDC`. 7. `calculate_compression_ratio(volume_bdc=500, volume_tdc=600)` should raise `ValueError: Volume at BDC must be greater than volume at TDC`. Implement the function in Python, considering the validation rules and example cases discussed above.","solution":"def calculate_compression_ratio(volume_bdc: float, volume_tdc: float) -> float: Calculate the compression ratio of an internal combustion engine. Parameters: volume_bdc (float): Volume at bottom dead center in cubic centimeters. volume_tdc (float): Volume at top dead center in cubic centimeters. Returns: float: Compression ratio of the engine. Raises: ValueError: If volume_bdc <= 0, volume_tdc <= 0, or volume_bdc <= volume_tdc. if volume_bdc <= 0: raise ValueError(\\"Invalid volume at BDC\\") if volume_tdc <= 0: raise ValueError(\\"Invalid volume at TDC\\") if volume_bdc <= volume_tdc: raise ValueError(\\"Volume at BDC must be greater than volume at TDC\\") return volume_bdc / volume_tdc"},{"question":"# Coding Assessment Question **Context**: Imagine you are developing a software system that handles various algorithms involving permutations and combinations. One of the required features is to find the k-th lexicographical permutation of a given string. **Problem Statement**: Implement a function that, given a string and an integer k, returns the k-th lexicographical permutation of the string. # Function Signature: ```python def kth_permutation(s: str, k: int) -> str: pass ``` # Input: 1. **s (str)**: A string containing unique characters. 2. **k (int)**: The 1-based index of the permutation desired. # Output: Returns a string representing the k-th lexicographical permutation of the input string. # Constraints: 1. ( 1 leq len(s) leq 10 ) 2. ( 1 leq k leq len(s)! ) 3. Input characters are unique and can be any printable ASCII character. # Example: ```python assert kth_permutation(\\"abc\\", 3) == \\"bac\\" assert kth_permutation(\\"bca\\", 1) == \\"abc\\" assert kth_permutation(\\"dcba\\", 24) == \\"abcd\\" ``` # Explanation: 1. For the first example, the lexicographical permutations of \\"abc\\" are [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]. The 3rd permutation in this list is \\"bac\\". 2. For the second example, the lexicographical permutations of \\"bca\\" are [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]. The 1st permutation in this list is \\"abc\\". 3. For the third example, the lexicographical permutations of \\"dcba\\" are the reverse of permutations of \\"abcd\\" (\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"). The 24th permutation in this list is \\"abcd\\". # Notes: - Permutations should be computed in lexicographical order. - Optimize the solution to handle the constraints efficiently. Ensure to handle larger values of k without explicitly generating all permutations.","solution":"def kth_permutation(s: str, k: int) -> str: from math import factorial # Ensure k is within the valid range if not (1 <= k <= factorial(len(s))): return \\"\\" # Convert k to 0-based index k -= 1 # Initialize the result and get a sorted list of characters from the input string result = [] chars = sorted(s) # Generate the k-th permutation while chars: n = len(chars) fact = factorial(n - 1) index = k // fact result.append(chars.pop(index)) k %= fact return \'\'.join(result)"},{"question":"# Scenario You are designing an automated vending machine system in Python. One of the essential functions of this system is to dispense an item and calculate the change when a purchase is made. The machine should be able to process a wide range of currency inputs and dispense the correct change using the least number of coins. # Objective Write a Python function named `vending_machine` that accepts two parameters: the purchase price of the item and the amount of money inserted into the machine. The function should return a tuple containing the change as a dictionary, which includes the count of each type of coin. # Function Signature ```python def vending_machine(price: float, money_inserted: float) -> dict: pass ``` # Input 1. `price` (float): The purchase price of the item. 2. `money_inserted` (float): The amount of money inserted into the vending machine. # Output * Returns a dictionary representing the count of each type of coin needed to make the change. The coins available are in the denomination of `50`, `25`, `10`, `5`, and `1` cents. # Constraints * The `price` and `money_inserted` should be non-negative values. * The `money_inserted` must be greater than or equal to the `price`. # Requirements 1. The function should return a ValueError if `price` or `money_inserted` is negative. 2. The function should return a ValueError if `money_inserted` is less than `price`. 3. The change must be calculated such that the least number of coins is used. # Examples ```python >>> vending_machine(0.75, 1) {25: 1} >>> vending_machine(1.25, 2) {50: 1, 25: 1} >>> vending_machine(1.10, 1.50) {25: 1, 10: 1, 5: 1} >>> vending_machine(1.00, 1.00) {} >>> vending_machine(0.99, 1.00) {1: 1} >>> vending_machine(0.99, 0.98) Traceback (most recent call last): ... ValueError: money_inserted must be greater than or equal to price >>> vending_machine(-1.00, 1.00) Traceback (most recent call last): ... ValueError: price and money_inserted must be non-negative >>> vending_machine(1.00, -0.50) Traceback (most recent call last): ... ValueError: price and money_inserted must be non-negative ``` # Notes * The solution should handle the precision issues typically associated with floating-point arithmetic. * Proper input validation is necessary to ensure the inputs are within the specified range and type. Provide well-documented code and include any assumptions made in your solution.","solution":"def vending_machine(price: float, money_inserted: float) -> dict: Calculate the change to be returned by the vending machine in the least number of coins. Args: price (float): Purchase price of the item money_inserted (float): Money inserted into the machine Returns: dict: A dictionary with the number of each coin type needed for change Raises: ValueError: If price or money_inserted is negative or if money_inserted is less than price if price < 0 or money_inserted < 0: raise ValueError(\\"price and money_inserted must be non-negative\\") if money_inserted < price: raise ValueError(\\"money_inserted must be greater than or equal to price\\") # Convert dollars to cents to avoid floating-point precision issues price_cents = round(price * 100) money_inserted_cents = round(money_inserted * 100) change_cents = money_inserted_cents - price_cents # Denominations of the coins available coin_types = [50, 25, 10, 5, 1] change_dict = {} for coin in coin_types: if change_cents >= coin: coin_count = change_cents // coin change_cents -= coin_count * coin change_dict[coin] = coin_count return change_dict"},{"question":"# Context: Efficient Management of Social Network Data with Disjoint Set Union-Find You are tasked with designing a feature for a social network platform to manage user connections. The platform places a strong emphasis on frequent union or joining of user groups and constant-time querying to check if two users are directly or indirectly connected. Using the principles of the Disjoint Set Union-Find data structure discussed above, implement a subclass that extends the provided Union-Find structure to include the following additional features: 1. **Connected Components Size**: Implement a method `component_size` that returns the size of the connected component (the number of users) in which a given user resides. 2. **Largest Component**: Implement a method `largest_component` that returns the size of the largest connected component in the network. # Task Requirements - Implement `component_size` method: This should return the number of users in the connected component containing the specified user. - Implement `largest_component` method: This should return the size of the largest connected component in the network. Function Signatures: ```python class ExtendedUnionFind(UnionFind): def component_size(self, user: int) -> int: pass def largest_component(self) -> int: pass ``` Input/Output Formats: - **component_size**: - **Input**: Integer `user` representing a user ID. - **Output**: Integer size of the connected component containing the specified user. - **largest_component**: - **Input**: None. - **Output**: Integer size of the largest connected component. Constraints: - user IDs are non-negative integers. - The Union-Find structure should have been initialized to include up to a specified number of users, and their IDs range from 0 to size-1.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.size = [1] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP self.size[rootP] += self.size[rootQ] elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ self.size[rootQ] += self.size[rootP] else: self.parent[rootQ] = rootP self.size[rootP] += self.size[rootQ] self.rank[rootP] += 1 class ExtendedUnionFind(UnionFind): def component_size(self, user: int) -> int: root = self.find(user) return self.size[root] def largest_component(self) -> int: return max(self.size)"},{"question":"# Digit Sum Calculation Background In many computational problems, it is essential to manipulate and analyze individual digits of integers. A common operation is to compute the sum of the digits of a given number. This task can be useful in numerical analysis and digital root calculations, frequently used in checksum algorithms and digital root-based arithmetic. Task Write a Python function `digit_sum(n: int) -> int` that calculates and returns the sum of all the digits of the given integer `n`. The function must follow these rules: 1. Work for both positive and negative integers by considering the absolute value of the number. 2. If the input is zero, return zero. Input * One parameter: * `n` (int): The integer whose digits need to be summed. Output * An integer representing the sum of the digits of the absolute value of `n`. Examples ```python >>> digit_sum(123) 6 >>> digit_sum(-456) 15 >>> digit_sum(0) 0 >>> digit_sum(987654321) 45 >>> digit_sum(-10101010) 4 ```","solution":"def digit_sum(n: int) -> int: Returns the sum of all digits of the given integer n. Consider the absolute value of the number. If the input is zero, return zero. return sum(int(digit) for digit in str(abs(n)))"},{"question":"# Context You are tasked with enhancing a text editor to support various text manipulation commands efficiently. Each command will modify the content of the editor, allowing actions such as inserting text, deleting a range of characters, and reversing segments. # Problem Statement Write a class `TextEditor` with the following methods: 1. `insert(position: int, text: str) -> None` 2. `delete(start: int, end: int) -> None` 3. `reverse(start: int, end: int) -> None` 4. `get_text() -> str` Method Descriptions: * **insert**: Inserts the given `text` at the specified `position` in the current content. * **delete**: Deletes the text from the `start` index up to, but not including, the `end` index. * **reverse**: Reverses the text from the `start` index up to, but not including, the `end` index. * **get_text**: Returns the current content of the text editor as a string. Input and Output Formats: * **Input**: - `position`, `start`, `end`: Integer positions indicating the start and end indices for the operations (0 <= position, start, end <= length of current text). - `text`: A string to be inserted. * **Output**: - `insert`, `delete`, and `reverse` do not return any value. - `get_text` returns the modified content of the text editor as a string. Constraints: 1. The text length and positions are within valid ranges specified. 2. Deleting from an empty string or reversing a zero-length range should not affect the content. Example Usage: ```python editor = TextEditor() editor.insert(0, \\"Hello\\") print(editor.get_text()) # Output: \\"Hello\\" editor.insert(5, \\" World\\") print(editor.get_text()) # Output: \\"Hello World\\" editor.delete(5, 11) print(editor.get_text()) # Output: \\"Hello\\" editor.insert(5, \\", my friend!\\") print(editor.get_text()) # Output: \\"Hello, my friend!\\" editor.reverse(0, 5) print(editor.get_text()) # Output: \\"olleH, my friend!\\" ``` # Performance Requirement The methods should perform respective text manipulations efficiently, aiming for linear complexity relative to the text length where applicable. Ensure your solution handles edge cases properly and maintains the logical integrity of the text content throughout the manipulations. Good luck!","solution":"class TextEditor: def __init__(self): self.content = \\"\\" def insert(self, position: int, text: str) -> None: if position < 0 or position > len(self.content): raise ValueError(\\"Position out of bounds\\") self.content = self.content[:position] + text + self.content[position:] def delete(self, start: int, end: int) -> None: if start < 0 or end > len(self.content) or start > end: raise ValueError(\\"Invalid start or end positions\\") self.content = self.content[:start] + self.content[end:] def reverse(self, start: int, end: int) -> None: if start < 0 or end > len(self.content) or start > end: raise ValueError(\\"Invalid start or end positions\\") self.content = self.content[:start] + self.content[start:end][::-1] + self.content[end:] def get_text(self) -> str: return self.content"},{"question":"# Coding Assessment Question **Scenario**: In the world of competitive programming, it\'s crucial to determine if an array is a rotated version of another sorted array. Imagine you are given two arrays, and you need to verify whether one is a rotation of the other. # Problem Statement: Implement a function `is_rotation(arr1: list, arr2: list) -> bool` that determines if `arr2` is a rotated version of `arr1`. Two arrays are considered rotated versions of each other if there exists some integer `k` such that rotating `arr1` by `k` positions results in `arr2`. # Requirements: 1. **Input**: - Two lists of integers `arr1` and `arr2`. 2. **Output**: - A boolean value `True` if `arr2` is a rotated version of `arr1`, otherwise `False`. 3. **Constraints**: - The lengths of lists `arr1` and `arr2` will be between 0 and 1000. - All elements in the arrays are integers between -10^6 and 10^6. # Examples: ```python >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) False >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) True >>> is_rotation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) True >>> is_rotation([1, 2, 3], [4, 5, 6]) False ``` # Guidelines: * Ensure your implementation correctly handles edge cases such as empty arrays and arrays of different lengths. * The function should be able to determine if `arr2` is a rotated version of `arr1` efficiently. * Consider using concatenation techniques to simplify the problem and reduce complexity.","solution":"def is_rotation(arr1, arr2): Determines if arr2 is a rotated version of arr1. if len(arr1) != len(arr2): return False if not arr1: # both arrays are empty return True concatenated = arr1 + arr1 return \'\'.join(map(str, arr2)) in \'\'.join(map(str, concatenated))"},{"question":"# Scenario You are tasked with developing a function for a calendar application that helps users determine the day of the week for a given date. The function should take in a date string in the format \\"YYYY-MM-DD\\" and return the corresponding day of the week in full name (e.g., \\"Monday\\"). # Task Implement a function `find_day_of_week(date: str) -> str` that: 1. Parses the input date string. 2. Computes the day of the week for the given date. 3. Returns the day of the week as a full name in English. # Function Signature ```python def find_day_of_week(date: str) -> str: pass ``` # Input * `date`: A string representing a date in the format \\"YYYY-MM-DD\\" (1900-01-01 ≤ date ≤ 2100-12-31). # Output * Returns a string representing the day of the week for the input date. # Examples ```python >>> find_day_of_week(\\"2023-10-15\\") \\"Sunday\\" >>> find_day_of_week(\\"2000-01-01\\") \\"Saturday\\" >>> find_day_of_week(\\"1980-12-25\\") \\"Thursday\\" >>> find_day_of_week(\\"1999-07-20\\") \\"Tuesday\\" ``` # Constraints * Do not use any external libraries. * Ensure the function computes the result accurately, as incorrect results will fail the test cases. * The function should handle edge cases such as leap years and boundary dates efficiently.","solution":"import datetime def find_day_of_week(date: str) -> str: Given a date string in the format YYYY-MM-DD, returns the day of the week. # Parse the date string into a date object year, month, day = map(int, date.split(\'-\')) date_obj = datetime.date(year, month, day) # Extract and return the day of the week return date_obj.strftime(\'%A\')"},{"question":"# Palindrome Number Problem Statement You are given an integer `x`. Your task is to write a function `is_palindrome` that determines if `x` is a palindrome. A palindrome number is defined as a number that reads the same backward as forward. Function Signature ```python def is_palindrome(x: int) -> bool: ``` Input - `x`: An integer. Output - Return `True` if `x` is a palindrome, otherwise return `False`. Example ```python # Example 1: x = 121 print(is_palindrome(x)) # Output: True # Example 2: x = -121 print(is_palindrome(x)) # Output: False # Example 3: x = 10 print(is_palindrome(x)) # Output: False # Example 4: x = -101 print(is_palindrome(x)) # Output: False ``` Constraints - -2^31 <= x <= 2^31 - 1 Additional Information - You must not convert the integer to a string explicitly or implicitly to solve this problem. Hints - Consider reversing half of the number and compare it to the remaining half. - You might find it useful to use the modulo operator (`%`) to isolate digits and the integer division operator (`//`) to reduce the number.","solution":"def is_palindrome(x: int) -> bool: Determines if x is a palindrome number. A palindrome number reads the same backward as forward. if x < 0: return False original, reversed_num = x, 0 while x > 0: last_digit = x % 10 reversed_num = reversed_num * 10 + last_digit x //= 10 return original == reversed_num"},{"question":"Create a function `simulate_population_growth` that will model population growth using an exponential model. Given the initial population size, growth rate, and number of time steps, your function should compute the population size at each step and return a list of population sizes over time. # Function Signature ```python def simulate_population_growth( initial_population: float, growth_rate: float, time_steps: int ) -> list: ``` # Input - `initial_population`: A float representing the initial size of the population. - `growth_rate`: A float representing the rate of population growth per time step (e.g., a value of 0.1 represents a 10% increase per time step). - `time_steps`: An integer representing the number of time steps over which to simulate growth. # Output - Returns a list of floats representing the population size at each time step, including the initial population size. # Constraints - `initial_population` is a positive float. - `growth_rate` can be any float (positive, zero, or negative). - `time_steps` is a non-negative integer. # Example ```python population = simulate_population_growth(100, 0.1, 5) print(population) # Output: [100, 110.0, 121.0, 133.1, 146.41, 161.051] ``` In this example, starting with an initial population of 100, the population grows by 10% each time step, resulting in the list of population sizes [100, 110.0, 121.0, 133.1, 146.41, 161.051]. **Note**: Ensure your function handles scenarios where the growth rate is zero (no growth) or negative (population decline). The function should be able to handle a variety of growth rates and initial population sizes accurately and efficiently.","solution":"def simulate_population_growth(initial_population: float, growth_rate: float, time_steps: int) -> list: Simulates population growth using an exponential model. Parameters: - initial_population (float): Initial size of the population. - growth_rate (float): Rate of population growth per time step. - time_steps (int): Number of time steps over which to simulate growth. Returns: - list: A list of population sizes at each time step, including the initial population size. population_sizes = [] current_population = initial_population for _ in range(time_steps + 1): # Including the initial time step population_sizes.append(current_population) current_population += current_population * growth_rate return population_sizes"},{"question":"# Question: Implement a Minimal Spanning Tree using Kruskal\'s Algorithm **Context**: You are a software engineer working on a network optimization project. Your task is to find the minimal spanning tree (MST) of a connected, undirected graph using Kruskal\'s Algorithm. This will help in reducing the cable length between all the offices connected in the network. **Function Signature**: ```python def kruskal_mst(edges: List[Tuple[int, int, float]], n: int) -> List[Tuple[int, int, float]]: ``` **Input**: * `edges`: A list of tuples where each tuple consists of three elements `(u, v, w)`, representing an edge between vertex `u` and vertex `v` with weight `w`. * `n`: An integer representing the number of vertices. **Output**: * Returns a list of tuples representing the edges of the Minimal Spanning Tree. Each tuple should be in the format `(u, v, w)` denoting an edge from vertex `u` to vertex `v` with weight `w`. **Constraints**: * `1 <= n <= 1000` * All edge weights are non-negative. * The input graph is connected and undirected. * Edge vertices are zero-indexed. **Performance Requirement**: * The solution should be efficient and use Union-Find data structure for cycle detection and edge sorting. **Example**: ```python edges = [ (0, 1, 4.0), (0, 2, 3.0), (1, 2, 1.0), (1, 3, 2.0), (2, 3, 5.0), ] print(kruskal_mst(edges, 4)) # Expected output: [(1, 2, 1.0), (1, 3, 2.0), (0, 2, 3.0)] ``` **Notes**: * You may implement and use the Union-Find data structure (Disjoint Set Union) to help find and merge sets efficiently. * Sort the edges based on their weight, then iterate and select edges while ensuring no cycles are formed. * Make sure to handle all possible cases especially edge cases for input size and vertex connections.","solution":"from typing import List, Tuple def kruskal_mst(edges: List[Tuple[int, int, float]], n: int) -> List[Tuple[int, int, float]]: Computes the Minimal Spanning Tree (MST) of a connected undirected graph using Kruskal\'s Algorithm. Parameters: edges (List[Tuple[int, int, float]]): A list of edges in the format (u, v, weight) n (int): The number of vertices in the graph Returns: List[Tuple[int, int, float]]: The edges in the MST. # Helper function for finding the root/parent of a node with path compression def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function for performing union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort edges by their weight edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n mst = [] for u, v, weight in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst.append((u, v, weight)) union(parent, rank, root_u, root_v) return mst"},{"question":"# **List of Dictionaries: Sorting by Key** Write a function `sort_dictionary_list(dict_list: list[dict], sort_key: str, reverse: bool = False) -> list[dict]` that sorts a list of dictionaries based on a specified key. For this task: 1. **Input:** - `dict_list`: A list of dictionaries. - `sort_key`: A string representing the key name to sort by. - `reverse` (default `False`): Boolean indicating if the sort should be in descending order. 2. **Output:** - A list of dictionaries sorted based on the values associated with `sort_key`. 3. **Constraints:** - Each dictionary in `dict_list` contains the `sort_key`. - The values for `sort_key` are comparable (all numbers, or all strings, etc.). - If `dict_list` is empty, return an empty list. - If `reverse` is `True`, sort in descending order; if `False`, sort in ascending order. 4. **Handling Errors:** - If the `sort_key` is not found in any dictionary, raise a `KeyError` with the message `\\"Key not found in one or more dictionaries\\"`. # Example Usage ```python >>> sort_dictionary_list([{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 20}], \\"age\\") [{\'name\': \'Charlie\', \'age\': 20}, {\'name\': \'Alice\', \'age\': 25}, {\'name\': \'Bob\', \'age\': 30}] >>> sort_dictionary_list([{\\"name\\": \\"Alice\\", \\"age\\": 25}, {\\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 20}], \\"name\\", True) [{\'name\': \'Charlie\', \'age\': 20}, {\'name\': \'Bob\', \'age\': 30}, {\'name\': \'Alice\', \'age\': 25}] >>> sort_dictionary_list([{\\"name\\": \\"Apple\\", \\"points\\": 10}, {\\"name\\": \\"Banana\\", \\"points\\": 5}, {\\"name\\": \\"Cherry\\", \\"points\\": 15}], \\"points\\") [{\'name\': \'Banana\', \'points\': 5}, {\'name\': \'Apple\', \'points\': 10}, {\'name\': \'Cherry\', \'points\': 15}] >>> sort_dictionary_list([{\\"name\\": \\"A\\", \\"value\\": 2}, {\\"name\\": \\"B\\", \\"value\\": 1}], \\"weight\\") Traceback (most recent call last): ... KeyError: \'Key not found in one or more dictionaries\' >>> sort_dictionary_list([], \\"age\\") [] ``` Note that you should handle possible edge cases and account for performance where possible. # Requirements * Ensure the function handles invalid input gracefully by raising exceptions where necessary. * Use efficient sorting algorithms to manage performance when dealing with larger input data.","solution":"def sort_dictionary_list(dict_list: list[dict], sort_key: str, reverse: bool = False) -> list[dict]: Sorts a list of dictionaries based on a specified key. Args: dict_list (list of dict): The list of dictionaries to be sorted. sort_key (str): The key by which to sort the dictionaries. reverse (bool, optional): If True, sorts in descending order. Defaults to False. Returns: list of dict: The sorted list of dictionaries. Raises: KeyError: If the sort_key is not found in any of the dictionaries. # Check for the presence of the sort_key in each dictionary for d in dict_list: if sort_key not in d: raise KeyError(\\"Key not found in one or more dictionaries\\") # Sort the list of dictionaries by the specified key return sorted(dict_list, key=lambda x: x[sort_key], reverse=reverse)"},{"question":"# Question for Coding Assessment: # Intermediate Problem: Counting Unique Substrings Scenario You are a software developer working on a text analysis tool, and you need to provide functionality that counts the number of unique substrings in a given string. A substring is defined as any contiguous sequence of characters within the string. This is a fundamental problem in string processing, often used in text analysis, information retrieval, and bioinformatics. Your task is to implement a function that calculates the number of unique substrings of a given string. Requirements * **Function Signature**: Implement the function `count_unique_substrings(s: str) -> int`. * **Input**: - `s` (str): The input string containing only lowercase English letters (a-z). * **Output**: - Return the total number of unique substrings in `s`. Constraints 1. `1 <= len(s) <= 1000` 2. The input string contains only lowercase English letters (a-z). Performance Requirements - Aim for a time complexity of O(n^2) or better, where n is the length of the string. - Make efficient use of data structures to ensure your solution can handle the upper input limits. Example ```python def count_unique_substrings(s: str) -> int: # Implement the function # Example usage: s = \\"abc\\" # Expected output: 6 (The unique substrings are \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", and \\"abc\\") print(count_unique_substrings(s)) s = \\"aaa\\" # Expected output: 3 (The unique substrings are \\"a\\", \\"aa\\", and \\"aaa\\") print(count_unique_substrings(s)) ``` Remember to handle edge cases, optimize for performance, and ensure your code is robust and well-documented.","solution":"def count_unique_substrings(s: str) -> int: Counts the number of unique substrings in a given string. :param s: The input string containing only lowercase English letters. :return: The total number of unique substrings. substrings = set() for i in range(len(s)): for j in range(i, len(s)): substrings.add(s[i:j+1]) return len(substrings)"},{"question":"# Problem Statement: You are required to implement a function that converts a given list of integers to Roman numerals. The function should take in a list of integers and return a corresponding list of strings representing the Roman numerals. # Function Signature: ```python def to_roman_numerals(numbers: List[int]) -> List[str]: pass ``` # Input: - `numbers`: A list of integers where each integer represents a number to be converted to a Roman numeral. # Output: - Returns a list of strings where each string is the Roman numeral representation of the corresponding integer in the input list. # Constraints: - 0 < len(numbers) <= 1000 - 1 <= numbers[i] <= 3999 (for each number in the input list) # Performance Requirements: - The function should be efficient and run within a reasonable time for lists of maximum size. # Example: ```python numbers = [1, 4, 9, 58, 1994] roman_numerals = to_roman_numerals(numbers) # Expected output: # [\\"I\\", \\"IV\\", \\"IX\\", \\"LVIII\\", \\"MCMXCIV\\"] ``` # Notes: - Roman numerals are represented by the following symbols: | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | - The Roman numeral system uses a subtractive notation, where placing a smaller numeral before a larger numeral indicates subtraction (e.g., IV for 4, IX for 9). - Ensure your function handles edge cases, such as the conversion of the largest possible number (3999) efficiently and correctly.","solution":"def to_roman_numerals(numbers): Converts a list of integers to their corresponding Roman numeral representations. Args: numbers: List of integers where each integer is a number to be converted to a Roman numeral. Returns: A list of strings where each string is the Roman numeral representation of the corresponding integer in the input list. def int_to_roman(num): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num return [int_to_roman(num) for num in numbers]"},{"question":"# Concurrent Real-time Chat Application Your task is to implement a basic real-time chat application using socket programming that supports multiple clients communicating with each other simultaneously. Requirements: 1. **Server Function**: Implement a server function `chat_server` that manages multiple clients. It should relay messages from one client to all other connected clients. 2. **Client Function**: Implement a client function `chat_client` that connects to the server and allows the user to send and receive messages in real-time. 3. **Concurrency**: Utilize threading or asynchronous I/O to handle multiple clients concurrently. 4. **Error Handling**: Ensure robust error handling for network issues, such as connection loss. Technical Specifications: * **Input (Server)**: `host` (str) and `port` (int). * **Output (Server)**: Print messages received from clients, and send them to all other clients. * **Input (Client)**: `host` (str), `port` (int), and an optional `username` (str for identification). * **Output (Client)**: Print messages from other clients to the console. # Example **Server (`chat_server` example usage):** ```python def chat_server(host: str = \\"0.0.0.0\\", port: int = 12345) -> None: # Implementation here if __name__ == \\"__main__\\": chat_server() ``` **Client (`chat_client` example usage):** ```python def chat_client(host: str, port: int, username: str = \\"User\\") -> None: # Implementation here if __name__ == \\"__main__\\": chat_client(\\"localhost\\", 12345, \\"Alice\\") ``` **Constraints:** * The server should be capable of handling multiple clients simultaneously. * Each client should be able to see messages from other clients in real time. * Gracefully handle any client disconnects without crashing the server. Implement the two required functions (`chat_server` and `chat_client`), ensuring they work together to create a concurrent real-time chat application.","solution":"import socket import threading def broadcast_message(message, connections): for conn in connections: try: conn.send(message.encode()) except Exception as e: print(f\\"Error sending message: {e}\\") connections.remove(conn) def handle_client(conn, addr, connections): print(f\\"[NEW CONNECTION] {addr} connected.\\") connected = True while connected: try: message = conn.recv(1024).decode() if message: print(f\\"[{addr}] {message}\\") broadcast_message(f\\"[{addr}] {message}\\", connections) else: connected = False except Exception as e: print(f\\"Error handling message from {addr}: {e}\\") connected = False conn.close() connections.remove(conn) print(f\\"[DISCONNECTED] {addr} disconnected.\\") def chat_server(host=\\"0.0.0.0\\", port=12345): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind((host, port)) server.listen() print(f\\"[LISTENING] Server is listening on {host}:{port}\\") connections = [] while True: conn, addr = server.accept() connections.append(conn) thread = threading.Thread(target=handle_client, args=(conn, addr, connections)) thread.start() def chat_client(host, port, username=\\"User\\"): client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((host, port)) def receive_messages(): while True: try: message = client.recv(1024).decode() print(message) except Exception as e: print(f\\"Error receiving message: {e}\\") break thread = threading.Thread(target=receive_messages) thread.start() while True: try: message = input() if message: client.send(f\\"{username}: {message}\\".encode()) except Exception as e: print(f\\"Error sending message: {e}\\") break"},{"question":"# Scenario You are employed at a tech company where you are responsible for optimizing a database query engine. The current system struggles with efficiently executing queries that involve complex joins, often resulting in high latency and negatively impacting user experience. # Question Implement a function to optimize the execution time of SQL queries involving `JOIN` operations. Your task is to examine a list of SQL queries, identify those that require optimization, and propose changes to improve performance. Specifically, you will rewrite queries to utilize indexing and consider query rewriting techniques such as subquery unnesting and join reordering to achieve optimal performance. # Specifications 1. **Input and Query Analysis:** - Input a list of SQL queries as strings. - Detect and identify `JOIN` operations within each query. 2. **Optimization Techniques:** - Apply indexing strategies to columns used in the `JOIN` operations. - Optimize queries by reordering `JOIN` operations. - Utilize subqueries unnesting where applicable to flatten nested queries for better performance. 3. **Output the Optimized Queries:** - Return the list of optimized queries. - Maintain original query functionality while improving execution efficiency. # Function Signature ```python def optimize_sql_queries(queries: List[str]) -> List[str]: pass ``` # Input - A list (`queries`) of SQL query strings that need optimization. # Output - A list containing optimized SQL query strings. # Constraints - Assume SQL queries are syntactically correct and valid. - Aim to reduce query execution time as much as possible without changing the results. # Performance Requirements - The function should be able to handle up to 10,000 SQL queries efficiently. # Examples ```python queries = [ \\"SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id JOIN products p ON o.product_id = p.id WHERE c.country = \'USA\';\\", \\"SELECT employee.name, department.name FROM employee JOIN department ON employee.dept_id = department.id;\\" ] optimized_queries = optimize_sql_queries(queries) print(optimized_queries) ``` # Notes - Assume necessary SQL libraries for query transformation and optimization are available. - Consider specific optimizations such as creating indexes before `JOIN` queries and adopting best practices to prevent Cartesian products. - Ensure that optimized queries are syntactically correct and functional.","solution":"from typing import List def optimize_sql_queries(queries: List[str]) -> List[str]: Optimize a list of SQL queries by proposing indexing strategies and rewriting techniques like join reordering and subquery unnesting. def optimize_query(query: str) -> str: # This is a placeholder for the real optimization logic # For simplicity, we\'ll add indexing recommendations and try to reorder joins # Note: In reality, parsing SQL and applying these optimizations requires SQL parser libraries query = query.replace(\\"JOIN\\", \\"STRATEGY FOR JOIN: create INDEX or reorder if possiblenJOIN\\") return query optimized_queries = [optimize_query(query) for query in queries] return optimized_queries"},{"question":"# Scenario You are developing a web-based application that must evaluate and analyze user input data in real time. One of the features requires parsing expression-like strings and performing basic arithmetic operations based on the provided expressions. Your task is to build the necessary functions to parse and evaluate these expressions. # Task 1. **Implement `parse_expression` function** - Input: A string `expression`. - Output: A Python data structure (e.g., list or tree) representing the parsed expression. - Constraints: - The function should handle nested expressions correctly. - It should identify invalid formats and raise appropriate errors. 2. **Implement `evaluate_expression` function** - Input: A data structure (as defined by `parse_expression`) - Output: The result of the numerical evaluation of the expression. - Constraints: - Address arithmetic operations including addition, subtraction, multiplication, and division. - Throw relevant errors for invalid operations (e.g., division by zero). # Requirements - Ensure the implementation supports at least the following operators: `+`, `-`, `*`, `/`. - Handle operator precedence correctly (i.e., `*` and `/` have higher precedence than `+` and `-`). # Function Specifications # `parse_expression(expression: str) -> Union[list, dict, any]` - **Input**: A string representing the arithmetic expression. - **Output**: A parsed data structure. # `evaluate_expression(parsed_expression: Union[list, dict, any]) -> float` - **Input**: The parsed data structure from the `parse_expression` function. - **Output**: The result of the evaluation as a float. # Example Usage ```python # Parsing Example expression = \\"3 + 5 * (2 - 8) / 3\\" parsed_expression = parse_expression(expression) print(parsed_expression) # Possible output: [\'+\', 3, [\'/\', [\'*\', 5, [\'-\', 2, 8]], 3]] # Evaluation Example result = evaluate_expression(parsed_expression) print(result) # Output: 0.666... ``` # Additional Considerations - Ensure robustness to handle a variety of valid and invalid inputs. - Pay attention to whitespace and parenthesis handling within the expressions. - Aim for optimized and elegant code solutions.","solution":"import re def parse_expression(expression): Parses the given arithmetic expression and returns it as a nested list. def get_tokens(expression): tokens = re.findall(r\'d+|+|-|*|/|(|)\', expression) return tokens def parse(tokens): def helper(): token = tokens.pop(0) if token == \'(\': sub_expr = [] while tokens[0] != \')\': sub_expr.append(helper()) tokens.pop(0) # remove \')\' return sub_expr elif token.isnumeric() or re.match(r\'d+.d+\', token): return float(token) if \'.\' in token else int(token) elif token in \\"+-*/\\": return token else: raise ValueError(f\\"Unexpected token: {token}\\") output = [] while tokens: output.append(helper()) return output tokens = get_tokens(expression.replace(\\" \\", \\"\\")) parsed_expr = parse(tokens) return parsed_expr def evaluate_expression(parsed_expression): Evaluates the nested list representing the parsed expression and returns the result. def evaluate(expr): if isinstance(expr, (int, float)): return expr if isinstance(expr, list): if len(expr) == 1: return evaluate(expr[0]) if len(expr) == 3: left, op, right = expr left_val = evaluate(left) right_val = evaluate(right) if op == \'+\': return left_val + right_val elif op == \'-\': return left_val - right_val elif op == \'*\': return left_val * right_val elif op == \'/\': if right_val == 0: raise ZeroDivisionError(\\"division by zero\\") return left_val / right_val else: raise ValueError(f\\"Unknown operator: {op}\\") else: raise ValueError(f\\"Unexpected term length in expression: {len(expr)}\\") return evaluate(parsed_expression)"},{"question":"# Coding Question Scenario You are developing a software tool for geospatial data analysis. One of the key features of this tool is to calculate the area enclosed by a polygon. The polygon is defined by a series of vertices in a 2D plane given as a list of (x, y) coordinates. You need to compute the area using the Shoelace formula. Problem Statement Write a function `polygon_area` that calculates the area of a polygon defined by a list of vertices. The function should implement the Shoelace formula to ensure accurate area calculation. Implementation - The function should accept a list of tuples `vertices` where each tuple contains two float values representing the coordinates `(x, y)` of a vertex. - The vertices list will define a closed polygon, with each vertex connected sequentially and the last vertex connecting back to the first. - The function should return a float representing the area of the polygon. Input - `vertices`: A list of tuples `List[Tuple[float, float]]` containing the coordinates of the polygon vertices. The list will have at least 3 vertices. Output - A float representing the area of the polygon. Constraints - The coordinates (x, y) will be within the range `-1,000,000.0` to `1,000,000.0`. - The number of vertices will be between 3 and 1,000. Example ```python def polygon_area(vertices): # implementation here vertices = [(0, 0), (4, 0), (4, 3), (0, 3)] print(polygon_area(vertices)) # Output should be 12.0 ``` You are expected to use a precise and efficient approach to implement the Shoelace formula. Ensure that your implementation handles both concave and convex polygons, as well as edge cases like polygons with vertices in non-standard order.","solution":"def polygon_area(vertices): Calculate the area of a polygon using the Shoelace formula. :param vertices: A list of tuples representing the vertices of the polygon. :return: A float representing the area of the polygon. n = len(vertices) area = 0.0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - x2 * y1 return abs(area) / 2.0"},{"question":"# Task: You are tasked with creating a function that identifies and replaces specific words in a string with an anonymized version using a given word mapping, while preserving the overall sentence structure. The function should be case-insensitive but return the output with the original case of the words replaced. # Function Specification: ```python def anonymize_text(text: str, word_mapping: dict) -> str: Replaces specified words in the given text with their anonymized versions based on a given word mapping. Parameters: text (str): The input string containing words to be anonymized. word_mapping (dict): A dictionary where keys are words to be replaced (case-insensitive) and values are their anonymized strings. Returns: str: The text with specified words replaced by their anonymized versions. Examples: >>> anonymize_text(\'My email is Example@example.com and my phone number is 123-456-7890\', {\'example@example.com\': \'email@example.com\', \'123-456-7890\': \'XXX-XXX-XXXX\'}) \'My email is email@example.com and my phone number is XXX-XXX-XXXX\' >>> anonymize_text(\'Contact John at john.doe@example.com or Jane at jane.doe@example.com\', {\'john.doe@example.com\': \'anon_email1@example.com\', \'jane.doe@example.com\': \'anon_email2@example.com\'}) \'Contact John at anon_email1@example.com or Jane at anon_email2@example.com\' >>> anonymize_text(\'Alice: Alice_Wonderland@example.com\', {\'alice_wonderland@example.com\': \'anon@example.com\'}) \'Alice: anon@example.com\' >>> anonymize_text(\'My account number is ABC123 and PIN is 9876\', {\'abc123\': \'XXXXX\', \'9876\': \'****\'}) \'My account number is XXXXX and PIN is ****\' # Your code here ``` # Requirements: 1. **Input**: - A non-empty input string which contains words to be anonymized. - A dictionary containing word mappings where keys are words to be replaced (case-insensitive) and values are the anonymized words. 2. **Output**: - A string with specified words replaced by their anonymized versions, preserving the original case. 3. **Constraints**: - The words to be replaced and their mappings in the dictionary are case-insensitive. - Maintain the original case of the replacements in the output. 4. **Error Handling**: - Ensure the function handles both lower and upper case of the words to be anonymized. - Return the original text if no words to be anonymized are found. # Scenario: In an application that handles user sensitive data, it is crucial to anonymize specific information before logging or sharing for internal reviews. By creating an anonymize function, we can ensure that any sensitive information is appropriately replaced to protect user privacy. # Hint: Consider using regular expressions or other string manipulation techniques to identify and replace the words while preserving the original case.","solution":"import re def anonymize_text(text: str, word_mapping: dict) -> str: Replaces specified words in the given text with their anonymized versions based on a given word mapping. Parameters: text (str): The input string containing words to be anonymized. word_mapping (dict): A dictionary where keys are words to be replaced (case-insensitive) and values are their anonymized strings. Returns: str: The text with specified words replaced by their anonymized versions. def replacer(match): word = match.group(0) return word_mapping.get(word.lower(), word) pattern = re.compile(\'|\'.join(re.escape(key) for key in word_mapping), re.IGNORECASE) return pattern.sub(replacer, text)"},{"question":"# Budget Management System You are tasked with creating a simple budget management system to keep track of expenses and income. Design your system to handle various types of financial records and provide insightful summaries. Problem Statement Implement the `BudgetManager` class with the following functionality: 1. **Initialization**: - A constructor that initializes the budget manager with an empty list of records. 2. **Adding a Record**: - A method `add_record(date: str, description: str, amount: float, record_type: str)` that adds a financial record. - `date` is a string in the format \'YYYY-MM-DD\'. - `description` is a string describing the record. - `amount` is a float representing the amount in dollars. - `record_type` is a string either \'income\' or \'expense\'. - Raise a `ValueError` if `record_type` is neither \'income\' nor \'expense\'. 3. **Removing a Record**: - A method `remove_record(index: int)` that removes a financial record at a specified index. - Raise an `IndexError` if the index is out of bounds. 4. **Calculating Balance**: - A method `calculate_balance()` that returns the net balance as a float (total income - total expenses). 5. **Generating Report**: - A method `generate_report()` that returns a string summarizing the total income, total expenses, and net balance, each in a new line. - The report should format the dollar amounts to two decimal places. Example ```python budget = BudgetManager() budget.add_record(\\"2023-01-15\\", \\"Salary\\", 3000.00, \\"income\\") budget.add_record(\\"2023-01-17\\", \\"Groceries\\", 150.75, \\"expense\\") budget.add_record(\\"2023-01-20\\", \\"Freelance Project\\", 600.00, \\"income\\") budget.add_record(\\"2023-01-22\\", \\"Utilities\\", 120.30, \\"expense\\") print(budget.calculate_balance()) # 3328.95 print(budget.generate_report()) # Total Income: 3600.00 # Total Expenses: 271.05 # Net Balance: 3328.95 budget.remove_record(1) # Removing the record at index 1 (Groceries) print(budget.calculate_balance()) # 3479.70 print(budget.generate_report()) # Total Income: 3600.00 # Total Expenses: 120.30 # Net Balance: 3479.70 ``` Constraints - The `date` should be a valid string in the format \'YYYY-MM-DD\'. - `description` length should be less than 100 characters. - `amount` should be greater than 0. - Implement all methods to handle financial records efficiently. Implement the `BudgetManager` class with the described methods and properties.","solution":"class BudgetManager: def __init__(self): self.records = [] def add_record(self, date: str, description: str, amount: float, record_type: str): if record_type not in [\'income\', \'expense\']: raise ValueError(\\"record_type must be \'income\' or \'expense\'\\") if not (0 < len(description) <= 100): raise ValueError(\\"description length should be less than 100 characters\\") if amount <= 0: raise ValueError(\\"amount should be greater than 0\\") self.records.append({\\"date\\": date, \\"description\\": description, \\"amount\\": amount, \\"record_type\\": record_type}) def remove_record(self, index: int): if index < 0 or index >= len(self.records): raise IndexError(\\"index out of bounds\\") self.records.pop(index) def calculate_balance(self): total_income = sum(record[\\"amount\\"] for record in self.records if record[\\"record_type\\"] == \\"income\\") total_expenses = sum(record[\\"amount\\"] for record in self.records if record[\\"record_type\\"] == \\"expense\\") return total_income - total_expenses def generate_report(self): total_income = sum(record[\\"amount\\"] for record in self.records if record[\\"record_type\\"] == \\"income\\") total_expenses = sum(record[\\"amount\\"] for record in self.records if record[\\"record_type\\"] == \\"expense\\") net_balance = total_income - total_expenses return f\\"Total Income: {total_income:.2f}nTotal Expenses: {total_expenses:.2f}nNet Balance: {net_balance:.2f}\\""},{"question":"# Coding Assessment Question Objective Create a function that determines whether a given collection of words can be formed using a given set of letters. Each letter can only be used as many times as it appears in the given set. Scenario You are provided with a set of letters and a collection of words. The task is to check if each word in the collection can be formed using the letters in the set. The frequency of each letter in the set should be accounted for, i.e., you can\'t use a letter more times than it appears in the given set. Function Signature ```python def can_form_words(letters: str, words: List[str]) -> List[bool]: pass ``` Input - `letters` (str): A string containing the set of letters available for forming words. - `words` (List[str]): A list of words to be checked against the set of letters. Output - List of bool: A list of boolean values where each element corresponds to whether the word at that index in `words` can be formed using the given set of letters. Constraints - The length of `letters` is at most (1000). - The length of the `words` list is at most (1000). - Each word in `words` has a length between (1) and (50). - The input strings consist of lowercase English letters only. Example ```python letters = \\"aabbc\\" words = [\\"abb\\", \\"ac\\", \\"bbc\\", \\"bbb\\", \\"abc\\"] print(can_form_words(letters, words)) # Expected Output: [True, True, True, False, True] ``` Notes - Ensure that the solution accounts for the frequency of each letter in the set when determining if a word can be formed. - Aim for an efficient solution to handle the upper limits of the input sizes effectively. - Consider edge cases like empty words list or a letters string with no characters.","solution":"from typing import List from collections import Counter def can_form_words(letters: str, words: List[str]) -> List[bool]: Determines whether each word in the list can be formed using the given set of letters. Args: letters (str): A string containing the set of letters available for forming words. words (List[str]): A list of words to be checked against the set of letters. Returns: List[bool]: A list of boolean values where each element corresponds to whether the word at that index in `words` can be formed using the given set of letters. letter_count = Counter(letters) result = [] for word in words: word_count = Counter(word) # Check if for every character in the word, the count in the letter_count is sufficient can_form = True for char in word_count: if word_count[char] > letter_count.get(char, 0): can_form = False break result.append(can_form) return result"},{"question":"# Linked List Reversal The following class definition initializes a node for a singly linked list: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None) -> None: self.value = value self.next = next ``` # Function Implementation Using the `ListNode` class, implement a function to reverse a given singly linked list. Additionally, create a method to check if two linked lists are identical. Requirements 1. **Function Name**: `reverse_linked_list` * **Input**: The head node of a singly linked list. * **Output**: The head node of the reversed linked list. 2. **Function Name**: `are_identical` * **Input**: The head nodes of two singly linked lists. * **Output**: `True` if the two linked lists are identical, otherwise `False`. # Example: ```python # Creating a linked list 1 -> 2 -> 3 head = ListNode(1, ListNode(2, ListNode(3))) # Reversing the linked list reversed_head = reverse_linked_list(head) # Creating another linked list 3 -> 2 -> 1 head2 = ListNode(3, ListNode(2, ListNode(1))) print(are_identical(reversed_head, head2)) # Output: True # Creating another linked list 1 -> 2 head3 = ListNode(1, ListNode(2)) print(are_identical(reversed_head, head3)) # Output: False ``` # Constraints * You must ensure the reversal of the linked list is done in O(n) time complexity where n is the number of nodes in the list. * The function to check if the linked lists are identical must also run in O(n) time complexity.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None) -> None: self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def are_identical(head1: ListNode, head2: ListNode) -> bool: while head1 and head2: if head1.value != head2.value: return False head1 = head1.next head2 = head2.next return head1 is None and head2 is None"},{"question":"# Context: You are given a simple implementation of a stack data structure that supports push and pop operations. Your task is to extend this stack to support a `getMin` operation, which should return the minimum element currently in the stack. # Problem: 1. Write a method `getMin(self)` that returns the minimum element in the stack without modifying the stack. This method should handle cases where the stack is empty by returning an appropriate message or value. 2. Modify the stack\'s existing methods (`push` and `pop`) to ensure that `getMin` operates efficiently. # Implementation Details: - Class definition: `class MinStack(Stack):` - Methods to implement: * `def getMin(self):` * Modify existing `push(self, value)` and `pop(self)` methods if necessary. # Input: - `getMin()` takes no parameters. - `push(self, value)` takes a single parameter: * `value` (int): The value to be pushed onto the stack. - `pop(self)` takes no parameters. # Output: - `getMin()` will return the minimum element currently in the stack or an appropriate message/value if the stack is empty. - `push(self, value)` and `pop(self)` will operate as usual without changing their basic functionalities. # Constraints: - The stack will only contain integer values. - Do not use any additional libraries or data structures beyond what\'s necessary. # Performance Requirements: - `getMin()` should have an average time complexity of O(1). - `push(self, value)` and `pop(self)` should not have their average time complexity increased beyond O(1) due to the `getMin` implementation. # Example Usage: ```python min_stack = MinStack() # Pushing elements onto the stack min_stack.push(3) min_stack.push(5) min_stack.push(2) min_stack.push(1) # Getting the minimum element print(min_stack.getMin()) # Output should be 1 # Popping an element from the stack min_stack.pop() # Getting the minimum element again print(min_stack.getMin()) # Output should be 2 # Handling an empty stack min_stack.pop() min_stack.pop() min_stack.pop() print(min_stack.getMin()) # Output should indicate stack is empty ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if self.stack: value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() else: raise IndexError(\\"pop from empty stack\\") def getMin(self): if not self.min_stack: return \\"Stack is empty\\" return self.min_stack[-1]"},{"question":"Problem Statement You are tasked with writing a function that finds the k-th smallest element in an unsorted array. Your implementation should aim for an average-case time complexity of O(n). # Requirements: 1. **Function Signature**: ```python def find_kth_smallest(arr: list, k: int) -> int: ``` 2. **Input**: * A list of integers `arr` which can be empty or contain up to (10^6) elements. * An integer (k) representing the 1-based index of the k-th smallest element to find. 3. **Output**: * An integer representing the k-th smallest element in the array. 4. **Constraints**: * (1 leq k leq len(arr)) * The function should handle lists of varying lengths efficiently. * Do **not** use the built-in `sort()` or `sorted()` methods to find the k-th smallest element. # Example Cases: Example 1: * Input: `arr = [3, 2, 1, 5, 4]`, `k = 3` * Output: `3` Example 2: * Input: `arr = [9, -1, 3, 5, 2]`, `k = 2` * Output: `2` Example 3: * Input: `arr = [1]`, `k = 1` * Output: `1` # Edge Cases to Consider: 1. Empty list (should never occur due to constraints). 2. List with a single element. 3. List with all elements the same. 4. Large list approaching (10^6) elements. 5. List with negative and positive integers. Implement the function `find_kth_smallest` in Python to solve the problem.","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low < high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) return arr[low] def find_kth_smallest(arr, k): if not arr: raise ValueError(\\"Array cannot be empty.\\") if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds.\\") return quickselect(arr[:], 0, len(arr) - 1, k - 1)"},{"question":"# Coding Assessment Question **Scenario**: You are developing a utility function for an array manipulation library. One of the tasks is to remove all duplicates from a list of numbers and return the list in sorted order without using built-in sorting functions or libraries. **Task**: Write a function `remove_duplicates_and_sort` that: - Takes a single argument, `arr`, which is a list of integers. - Returns a new list that contains all the unique integers from `arr`, sorted in ascending order. - Does not use built-in sorting functions like `sorted()` or `list.sort()`. **Input**: - A list `arr` of integers. **Output**: - A list of integers, containing all unique elements from `arr`, sorted in ascending order. **Constraints**: - The input list can have up to 10^5 elements. - The elements in the list are in the range of -10^9 to 10^9. - Your function should handle edge cases such as an empty list or a list with all duplicate elements efficiently. **Function Signature**: ```python def remove_duplicates_and_sort(arr: [int]) -> [int]: ``` **Examples**: ```python remove_duplicates_and_sort([4, 1, 2, 1, 3, 2]) # Expected output: [1, 2, 3, 4] remove_duplicates_and_sort([10, 9, 8, 7, 6, 6, 6]) # Expected output: [6, 7, 8, 9, 10] remove_duplicates_and_sort([1, 1, 1, 1]) # Expected output: [1] remove_duplicates_and_sort([]) # Expected output: [] remove_duplicates_and_sort([-1, -2, -3, -1, -2, 3]) # Expected output: [-3, -2, -1, 3] ``` Write thorough test cases to ensure your function correctly removes duplicates and sorts the remaining elements. Ensure the function performs efficiently on large inputs within the constraints.","solution":"def remove_duplicates_and_sort(arr): Remove duplicates from the list and return sorted list without using built-in sort functions. unique_elements = list(set(arr)) # Remove duplicates # Implementing basic sort if not allowed for built-in sorting functions for i in range(len(unique_elements)): for j in range(0, len(unique_elements) - i - 1): if unique_elements[j] > unique_elements[j + 1]: unique_elements[j], unique_elements[j + 1] = unique_elements[j + 1], unique_elements[j] return unique_elements"},{"question":"Unique Paths in a Grid You are given a grid of size `m x n` (m rows and n columns) representing a maze. Your task is to find out how many unique paths there are from the top-left corner to the bottom-right corner of the grid. You are only allowed to move either down or right at any point in time. # Input - Two integers `m` and `n`, representing the number of rows and columns in the grid. # Output - An integer which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Constraints - (1 leq m, n leq 100) - Both `m` and `n` will be at least 1. # Example ```python m = 3 n = 7 def unique_paths(m: int, n: int) -> int: # Your code here if __name__ == \\"__main__\\": print(unique_paths(m, n)) ``` Write the function `unique_paths` such that passing the example values `m = 3` and `n = 7` returns the number of unique paths from the top-left corner to the bottom-right corner of the 3x7 grid. Note: The grid is empty and there are no obstacles blocking the path.","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner in an m x n grid where you can only move right or down. # Create a 2D list to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column to 1 since there\'s only one way to get to each cell in them for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The value in the bottom-right cell is the number of unique paths return dp[m-1][n-1]"},{"question":"**Context**: You are improving a recommendation system using collaborative filtering to predict user preferences. The system is based on user-item interaction data and is designed to predict the ratings that a user would give to items they have not yet rated. **Task**: 1. Implement a class `CollaborativeFiltering` to manage user-item interactions and apply the collaborative filtering algorithm. 2. Implement a function `predict_ratings` that uses `CollaborativeFiltering` to predict the ratings for a specific user. # Class Definition ```python class CollaborativeFiltering: def __init__(self): Initializes an empty collaborative filtering system. # Implement this method pass def add_interaction(self, user: str, item: str, rating: float) -> None: Records a user\'s rating for an item. :param user: The user who provided the rating. :param item: The item being rated. :param rating: The rating provided by the user. # Implement this method pass def similarity(self, user1: str, user2: str) -> float: Calculates the similarity score between two users based on their ratings. :param user1: The first user. :param user2: The second user. :return: The similarity score between user1 and user2. # Implement this method pass def predict(self, user: str, item: str) -> float: Predicts the rating a user would give to an item. :param user: The user for whom the rating is being predicted. :param item: The item for which the rating is being predicted. :return: The predicted rating. # Implement this method pass ``` # Function Definition ```python def predict_ratings(target_user: str, interactions: list[tuple[str, str, float]], items_to_predict: list[str]) -> dict[str, float]: Predicts the ratings for a specific user and a list of items using collaborative filtering. :param target_user: The user for whom ratings are being predicted. :param interactions: A list of tuples (user, item, rating) representing user-item interactions. :param items_to_predict: A list of items for which ratings need to be predicted. :return: A dictionary with the predicted ratings for the given items. # Implement this method pass ``` # Constraints: 1. The ratings are on a scale from 1 to 5. 2. Each user has rated at least 1 item. 3. The number of users, `U`, will not exceed 500. 4. The number of items, `I`, will not exceed 1000. 5. The number of interactions, `R`, will not exceed 10000. # Example: ```python interactions = [ (\'user1\', \'item1\', 5.0), (\'user1\', \'item2\', 3.0), (\'user2\', \'item1\', 4.0), (\'user2\', \'item3\', 2.0), (\'user3\', \'item2\', 2.0), (\'user3\', \'item3\', 4.0) ] items_to_predict = [\'item1\', \'item2\', \'item3\'] result = predict_ratings(\'user3\', interactions, items_to_predict) ``` **Note**: The output should be a dictionary where keys are item names and values are the predicted ratings for the `target_user`.","solution":"import numpy as np from collections import defaultdict class CollaborativeFiltering: def __init__(self): Initializes an empty collaborative filtering system. self.user_ratings = defaultdict(dict) self.item_ratings = defaultdict(dict) def add_interaction(self, user: str, item: str, rating: float) -> None: Records a user\'s rating for an item. self.user_ratings[user][item] = rating self.item_ratings[item][user] = rating def similarity(self, user1: str, user2: str) -> float: Calculates the similarity score between two users based on their ratings. common_items = set(self.user_ratings[user1]) & set(self.user_ratings[user2]) if not common_items: return 0.0 ratings1 = np.array([self.user_ratings[user1][item] for item in common_items]) ratings2 = np.array([self.user_ratings[user2][item] for item in common_items]) mean1, mean2 = np.mean(ratings1), np.mean(ratings2) ratings1 -= mean1 ratings2 -= mean2 numerator = np.dot(ratings1, ratings2) denominator = np.sqrt(np.dot(ratings1, ratings1) * np.dot(ratings2, ratings2)) return numerator / denominator if denominator != 0 else 0.0 def predict(self, user: str, item: str) -> float: Predicts the rating a user would give to an item. total_similarity = 0 weighted_sum = 0 for other_user, other_rating in self.item_ratings[item].items(): if other_user == user: continue similarity_score = self.similarity(user, other_user) total_similarity += abs(similarity_score) weighted_sum += similarity_score * (other_rating - np.mean(list(self.user_ratings[other_user].values()))) if total_similarity == 0: return np.mean(list(self.user_ratings[user].values())) user_mean = np.mean(list(self.user_ratings[user].values())) predicted_rating = user_mean + (weighted_sum / total_similarity) return max(1.0, min(predicted_rating, 5.0)) def predict_ratings(target_user: str, interactions: list[tuple[str, str, float]], items_to_predict: list[str]) -> dict[str, float]: Predicts the ratings for a specific user and a list of items using collaborative filtering. cf = CollaborativeFiltering() for user, item, rating in interactions: cf.add_interaction(user, item, rating) predictions = {} for item in items_to_predict: predictions[item] = cf.predict(target_user, item) return predictions"},{"question":"# Problem Scenario You are tasked with developing a function that counts the number of prime numbers in a given range of integers. This will test your understanding of number theory and optimization techniques in algorithms. # Task Write a function `count_primes_in_range(start: int, end: int) -> int`. Your function should: 1. Take two integers as input, `start` and `end`, which indicate the range (inclusive). 2. Return the count of prime numbers within this range. 3. Utilize an efficient algorithm to handle large ranges and ensure correctness for various input scenarios. # Expected Input and Output Input: - Two integers, `start` and `end`: - Example: `10, 30` Output: - An integer representing the count of prime numbers in the range. - Example: `6` # Constraints: - The range defined by `start` and `end` will contain at most 1,000,000 integers. - `start` and `end` will be in the range [1,000,000, 2,000,000]. # Performance Requirements: - Your solution should be optimized to handle large ranges efficiently within the constraints provided. # Example ```python def count_primes_in_range(start: int, end: int) -> int: # Implement optimized algorithm to count primes in the given range pass # Example usage: print(count_primes_in_range(10, 30)) # Output: 6 (as prime numbers are [11, 13, 17, 19, 23, 29]) ``` Provide your implementation of the `count_primes_in_range()` function following the optimized logic for prime number detection in the given range.","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes_in_range(start: int, end: int) -> int: count = 0 for num in range(start, end + 1): if is_prime(num): count += 1 return count"},{"question":"# Array Rotation and Maximum Value Challenge You are given an array of integers and an integer `k`. Your task is to implement two functions: 1. **rotate_array(arr, k)**: - **Input**: A list of integers `arr` and an integer `k`. - **Output**: Return the array after rotating it to the right by `k` positions. - **Constraints**: * Rotations performed should be effective (i.e., rotating an array of length `n` by `k` positions where `k` is much larger than `n` should only perform rotations equivalent to `k % n`). 2. **find_max_after_rotations(arr, queries)**: - **Input**: A list of integers `arr` and a list of integers `queries`. Each query represents a number of positions to rotate. - **Output**: For each query, return the maximum value in the array after performing the corresponding rotation. - **Constraints**: * You cannot use any built-in rotation methods. * Handle large queries efficiently. **Function Signatures**: ```python def rotate_array(arr: list[int], k: int) -> list[int]: pass def find_max_after_rotations(arr: list[int], queries: list[int]) -> list[int]: pass ``` # Example ```python # Example usage: arr = [1, 2, 3, 4, 5] # Test rotate_array assert rotate_array(arr, 2) == [4, 5, 1, 2, 3] assert rotate_array(arr, 5) == [1, 2, 3, 4, 5] assert rotate_array(arr, 7) == [4, 5, 1, 2, 3] # Test find_max_after_rotations assert find_max_after_rotations(arr, [1, 3, 5, 7]) == [5, 5, 5, 5] assert find_max_after_rotations([9, 8, 7, 6], [2, 4]) == [9, 9] assert find_max_after_rotations([4, 2, 3, 1], [0, 1]) == [4, 4] ``` **Note**: - Your implementations should optimize for efficiency, particularly in cases where the input size is large. - Handle edge cases such as empty arrays or rotations by zero.","solution":"def rotate_array(arr, k): Rotates the array to the right by k positions. if not arr: return [] n = len(arr) k = k % n # Effective rotations return arr[-k:] + arr[:-k] def find_max_after_rotations(arr, queries): For each query, return the maximum value in the array after performing the corresponding rotation. if not arr: return [] maxes = [] for k in queries: rotated_arr = rotate_array(arr, k) maxes.append(max(rotated_arr)) return maxes"},{"question":"# Scenario You are developing a program that interacts with a database to retrieve and store information about books. Your task includes defining a `Book` class and creating functions to add and retrieve book details from a list acting as a simple database. Additionally, you need to write tests to confirm the correctness of your code. # Task 1. Define a `Book` class with the following attributes: `title`, `author`, and `isbn`. 2. Implement a function `add_book` that takes a `Book` instance and a list (acting as the database) and adds the book to the list. 3. Implement a function `get_books_by_author` that takes an author\'s name and the list of books and returns a list of books written by that author. 4. Write unit tests for your functions to ensure they work correctly. # Requirements **Class Definition**: ```python class Book: def __init__(self, title: str, author: str, isbn: str): self.title = title self.author = author self.isbn = isbn ``` **Function Signatures**: ```python def add_book(book: Book, book_list: list) -> None: # Your implementation here def get_books_by_author(author: str, book_list: list) -> list: # Your implementation here ``` # Example ```python # Example Usage book1 = Book(\\"Title1\\", \\"Author1\\", \\"ISBN-1\\") book2 = Book(\\"Title2\\", \\"Author1\\", \\"ISBN-2\\") book3 = Book(\\"Title3\\", \\"Author2\\", \\"ISBN-3\\") book_list = [] add_book(book1, book_list) add_book(book2, book_list) add_book(book3, book_list) books_by_author1 = get_books_by_author(\\"Author1\\", book_list) # Expected output: [book1, book2] ``` # Constraints - The `add_book` function should not allow duplicate entries (based on ISBN). - The `get_books_by_author` function should return an empty list if no books by the author are found. # Testing - Use assertions in your unit tests to check for correct functionality. - Verify that the `add_book` function correctly adds books and handles duplicates. - Confirm that the `get_books_by_author` function retrieves the correct books and handles the case of no matching authors. # Additional Information - Ensure that the code correctly initializes instances of the `Book` class and accurately adds or retrieves books from the list. - Handle edge cases such as adding a book to an empty list or searching for an author without any books correctly.","solution":"class Book: def __init__(self, title: str, author: str, isbn: str): self.title = title self.author = author self.isbn = isbn def add_book(book: Book, book_list: list) -> None: Adds a book to the book_list if it is not already present based on ISBN. if book.isbn not in [b.isbn for b in book_list]: book_list.append(book) def get_books_by_author(author: str, book_list: list) -> list: Retrieves a list of books written by the specified author. return [book for book in book_list if book.author == author]"},{"question":"# Problem Statement You are tasked with writing a function `make_change` that calculates the different ways to make change for a given amount of money using a set of denominations. # Function Signature ```python def make_change(amount: int, denominations: list) -> int: ``` # Input * An integer `amount`, where ( 0 leq text{amount} leq 10000 ). * A list of integers `denominations` representing the available coin denominations. All elements in the list are positive integers and the list is non-empty. # Output * An integer representing the number of different ways to make change for the given amount using the provided denominations. # Constraints * You must handle invalid inputs (e.g., non-integer, negative values) by raising appropriate exceptions. * The `denominations` list may not be sorted, but you can assume it does not contain duplicate values. # Performance Requirements * Your solution should be efficient, particularly with respect to time complexity, given the constraints. # Example ```python assert make_change(4, [1, 2, 3]) == 4 # Explanation: (1+1+1+1, 1+1+2, 1+3, 2+2) assert make_change(10, [2, 5, 3, 6]) == 5 # Explanation: (2+2+2+2+2, 5+5, 2+3+5, 6+2+2, 6+4) assert make_change(0, [1, 2, 3]) == 1 # Explanation: There\'s one way to make change for 0, which is to use no coins. ``` # Notes * Consider using dynamic programming techniques to achieve an efficient solution. * Ensure to handle edge cases and invalid inputs as specified in the constraints. For example, if `amount` is 0, there should be exactly one way to make change (using no coins). * The function should compute the number of ways without actually generating the combinations, focusing on counting distinct ways of making change.","solution":"def make_change(amount: int, denominations: list) -> int: Calculates the number of different ways to make change for a given amount using a set of denominations. Parameters: amount (int): The total amount of money. denominations (list): The list of coin denominations. Returns: int: The number of different ways to make change for the given amount. if not isinstance(amount, int) or not all(isinstance(d, int) for d in denominations): raise ValueError(\\"Amount and all denominations must be integers.\\") if amount < 0 or any(d <= 0 for d in denominations): raise ValueError(\\"Amount must be non-negative and denominations must be positive.\\") if not denominations: raise ValueError(\\"Denominations list must not be empty.\\") # Create a table to store results of subproblems dp = [0] * (amount + 1) # There is one way to make 0 amount, which is to use no coins dp[0] = 1 # Iterate over all coins for coin in denominations: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount]"},{"question":"# Problem Statement You are tasked with implementing a data structure `LibraryManagement` to manage a collection of books in a library. The data structure should efficiently support the following operations: 1. **Initialization**: Initialize the data structure with a list of book titles, their authors, and their quantities. 2. **Add Book**: Add a new book or increase the quantity of an existing book in the library. 3. **Remove Book**: Remove a book from the library if it exists. 4. **Search by Title**: Search for books by their titles. 5. **Search by Author**: Search for books by their authors. Your implementation must ensure efficient query operations for searching and managing the library. # Function Signatures ```python class LibraryManagement: def __init__(self, books: list[tuple[str, str, int]]) -> None: Initializes the library with the given list of books. Each book is represented as a tuple containing (title, author, quantity). def add_book(self, title: str, author: str, quantity: int) -> None: Adds a new book to the library or increases the quantity of an existing book. def remove_book(self, title: str) -> bool: Removes a book by its title from the library if it exists, returns True if removed. def search_by_title(self, title: str) -> list[tuple[str, str, int]]: Searches for books by their title, returns a list of matching books and their details. def search_by_author(self, author: str) -> list[tuple[str, str, int]]: Searches for books by their author, returns a list of matching books and their details. ``` # Input Constraints - Each book title and author name is a string of length up to `100`. - The initial list of books can contain up to `10^5` books. - Queries for adding, removing, and searching books will be performed frequently. # Example Usage ```python # Initialize the library management system library = LibraryManagement([ (\\"Moby Dick\\", \\"Herman Melville\\", 5), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3), (\\"1984\\", \\"George Orwell\\", 8) ]) # Add a new book to the library library.add_book(\\"Pride and Prejudice\\", \\"Jane Austen\\", 4) # Increase the quantity of an existing book library.add_book(\\"1984\\", \\"George Orwell\\", 2) # Remove a book from the library print(library.remove_book(\\"Moby Dick\\")) # Output: True # Search for books by title print(library.search_by_title(\\"1984\\")) # Output: [(\\"1984\\", \\"George Orwell\\", 10)] # Search for books by author print(library.search_by_author(\\"Harper Lee\\")) # Output: [(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3)] ``` # Constraints - Handle edge cases such as adding duplicate book entries, removing non-existing books, and searching with no matches. - Optimize the performance of add, remove, and search operations to handle frequent requests efficiently.","solution":"class LibraryManagement: def __init__(self, books: list[tuple[str, str, int]]) -> None: self.books_by_title = {} self.books_by_author = {} for title, author, quantity in books: self._add_book_to_collections(title, author, quantity) def _add_book_to_collections(self, title: str, author: str, quantity: int) -> None: if title in self.books_by_title: self.books_by_title[title][\'quantity\'] += quantity else: self.books_by_title[title] = {\'author\': author, \'quantity\': quantity} if author in self.books_by_author: self.books_by_author[author].append({\'title\': title, \'quantity\': quantity}) else: self.books_by_author[author] = [{\'title\': title, \'quantity\': quantity}] def add_book(self, title: str, author: str, quantity: int) -> None: self._add_book_to_collections(title, author, quantity) def remove_book(self, title: str) -> bool: if title in self.books_by_title: author = self.books_by_title[title][\'author\'] del self.books_by_title[title] for book in self.books_by_author[author]: if book[\'title\'] == title: self.books_by_author[author].remove(book) break return True return False def search_by_title(self, title: str) -> list[tuple[str, str, int]]: if title in self.books_by_title: book = self.books_by_title[title] return [(title, book[\'author\'], book[\'quantity\'])] return [] def search_by_author(self, author: str) -> list[tuple[str, str, int]]: if author in self.books_by_author: return [(book[\'title\'], author, book[\'quantity\']) for book in self.books_by_author[author]] return []"},{"question":"# Coding Assessment Question Context You are tasked with enhancing a binary search tree (BST) implementation by adding a new functionality: checking if the tree is balanced. A balanced BST is defined as one where the height of the two subtrees of every node never differ by more than one. The goal is to determine your ability to traverse the tree and calculate height while maintaining efficiency. Task Implement a method `is_balanced` within the `BST` class that checks if the binary search tree is balanced. Function Specification ```python def is_balanced(self) -> bool: Checks if the binary search tree is balanced. Examples: >>> bst = BST() >>> bst.insert(4) >>> bst.insert(2) >>> bst.insert(6) >>> bst.insert(1) >>> bst.insert(3) >>> bst.insert(5) >>> bst.insert(7) >>> bst.is_balanced() True A balanced tree that becomes unbalanced: >>> bst = BST() >>> bst.insert(3) >>> bst.insert(2) >>> bst.insert(1) >>> bst.is_balanced() False When the binary search tree is empty: >>> bst = BST() >>> bst.is_balanced() True Returns: bool: True if the tree is balanced, False otherwise. pass ``` Constraints * The time complexity of the solution should be O(n), where n is the number of nodes in the tree. * The additional space complexity should be O(h), where h is the height of the tree due to the recursion stack. Input Format A method `is_balanced` is added to the `BST` class with no input parameters. Output Format The method returns a boolean value indicating whether the tree is balanced. Examples * Input: BST with nodes containing values [1, 2, 3] * Method Call: `bst.is_balanced()` * Expected Output: False, since it is a right-skewed tree (one-sided heavy)","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def is_balanced(self) -> bool: Checks if the binary search tree is balanced. Returns: bool: True if the tree is balanced, False otherwise. def _height_and_balanced(node): if node is None: return 0, True left_height, left_balanced = _height_and_balanced(node.left) right_height, right_balanced = _height_and_balanced(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, is_balanced = _height_and_balanced(self.root) return is_balanced"},{"question":"# List Number Rotation Challenge Understanding and manipulating lists is a fundamental skill in programming. For this challenge, you will write a function to perform a rotation operation on a list. # Problem Statement Implement a function `rotate_list(nums: List[int], k: int) -> List[int]` that rotates the list `nums` to the right by `k` steps. The function should: 1. Accept a list of integers `nums` and an integer `k`. 2. Rotate the list `nums` to the right by `k` positions. # Constraints - The length of `nums` is between 0 and 1000. - `k` is a non-negative integer. - `nums` may contain both positive and negative integers. - If `k` is greater than the length of the list, rotate the list by `k % len(nums)`. # Example ```python def rotate_list(nums: List[int], k: int) -> List[int]: pass # Example runs print(rotate_list([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_list([-1, -100, 3, 99], 2)) # Output: [3, 99, -1, -100] ``` # Edge Cases to Consider 1. **Empty list**: Should return an empty list. 2. **Rotation by zero steps**: Should return the list as is. 3. **`k` greater than the length of the list**: Handle rotations larger than the list\'s length correctly. 4. **Single element list**: Should return the list as is regardless of `k`. # Guidelines - Focus on the efficiency of the algorithm, especially for large lists. - Ensure proper handling of edge cases. - Aim to keep the solution simple and readable, using list slicing or other appropriate techniques. Hint: Think about how the list behaves when it\'s rotated rather than moving elements one by one. Consider using slicing to achieve the result efficiently.","solution":"def rotate_list(nums, k): Rotates the list nums to the right by k steps. Parameters: nums (List[int]): The list of integers to be rotated. k (int): The number of steps to rotate the list. Returns: List[int]: The rotated list. n = len(nums) if n == 0: return nums k = k % n return nums[-k:] + nums[:-k]"},{"question":"# Palindrome Detection You are to implement a function to determine whether a given string is a palindrome. This exercise will test your understanding of string manipulation, conditionals, and iteration. **Function Signature:** ```python def is_palindrome(s: str) -> bool: ``` **Input:** - `s`: A string. (Up to 10^5 characters, including letters, digits, and special characters) **Output:** - A boolean value indicating whether the string is a palindrome. **Constraints:** - Consider only alphanumeric characters (ignore special characters and spaces) and ignore case. - The function should be optimized to handle large input sizes efficiently. **Performance Requirements:** - The function should operate in linear time O(n). # Scenario Imagine you are developing a feature for a text editor that checks if a user\'s input is a palindrome, disregarding case and non-alphanumeric characters. This feature should be fast enough to handle even the longest strings without significant delay. # Example ```python >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"0P\\") False >>> is_palindrome(\\"Able was I, ere I saw Elba\\") True ``` **Note:** This task examines your ability to manipulate strings, handle various character types, and implement efficient algorithms.","solution":"def is_palindrome(s: str) -> bool: Determines whether a given string is a palindrome. A string is a palindrome if it reads the same forwards and backwards, ignoring case and non-alphanumeric characters. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Normalize the string by converting to lowercase and filtering out non-alphanumeric characters filtered_string = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_string == filtered_string[::-1]"},{"question":"# Problem Statement Write a function `magic_matrix` that takes a 2D list (matrix) of integers and returns a modified matrix following these rules: 1. If an element in the matrix is the number 0, set all elements in the same row and column to 0. 2. The transformation should be performed in a single pass (i.e., without using extra space for a copy of the matrix to track changes). # Input * A 2D list `matrix` where each element is an integer and 1 <= len(matrix) <= 100, 1 <= len(matrix[0]) <= 100. # Output * A modified 2D list where the rules above have been applied. # Constraints * The function should handle edge cases where the matrix might have only one row or one column. * The original structure of the matrix (number of rows and columns) must remain intact. # Performance Requirements * Aim for an O(n * m) time complexity, where n is the number of rows and m is the number of columns in the matrix. * Limit space complexity to O(1), i.e. modify the matrix in place without using additional matrices. # Example ```python matrix = [ [1, 2, 3], [4, 0, 6], [7, 8, 9] ] magic_matrix(matrix) # After execution, the matrix should become: # [ # [1, 0, 3], # [0, 0, 0], # [7, 0, 9] # ] matrix = [ [5, 0], [3, 4] ] magic_matrix(matrix) # After execution, the matrix should become: # [ # [0, 0], # [3, 0] # ] ``` # Hints * Think about initially identifying the rows and columns that will have their values set to 0 using a non-destructive marking strategy.","solution":"def magic_matrix(matrix): If an element in the matrix is the number 0, set all elements in the same row and column to 0. rows = len(matrix) cols = len(matrix[0]) rows_to_zero = set() cols_to_zero = set() # First pass: identify all rows and columns that have a 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 0: rows_to_zero.add(i) cols_to_zero.add(j) # Second pass: set entire rows to 0 for i in rows_to_zero: for j in range(cols): matrix[i][j] = 0 # Third pass: set entire columns to 0 for j in cols_to_zero: for i in range(rows): matrix[i][j] = 0 return matrix"},{"question":"# Problem Statement You are given a grid of size `m x n` consisting of integers representing the heights in a 2D landscape. Your task is to implement a function `trap_rain_water` that calculates the amount of water that can be trapped after raining over the entire landscape. Water can only be trapped in interior cells and not on the boundary of the grid. # Function Definition ```python def trap_rain_water(heights: List[List[int]]) -> int: :param heights: 2D list representing the height of each cell. :return: Integer value representing total volume of water trapped. ``` # Input * `heights` is an `m x n` list of integers (1 ≤ m, n ≤ 100). * Each element in `heights` represents the height at that cell, with heights between 0 and 10^4. # Output * Return the total volume of water trapped. # Constraints * Ensure the algorithm works efficiently with a time complexity better than the brute force O(m^2 * n^2). * Handle edge cases such as grids with varying height patterns and boundary conditions. # Example Example 1: ```python heights = [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ] # Output: 4 Explanation: After rain, the water trapped in the grid is represented as: [ [ 1, 4, 3, 1, 3, 2], [ 3, 2, 4, 3, 3, 4], [ 2, 3, 3, 2, 3, 1] ] Total water trapped = (4 - 1) + (3 - 1) + (4 - 3) + (4 - 3) = 3 + 2 + 1 + 1 = 4. ``` Example 2: ```python heights = [ [3, 3, 3, 3, 3], [3, 2, 2, 2, 3], [3, 2, 1, 2, 3], [3, 2, 2, 2, 3], [3, 3, 3, 3, 3] ] # Output: 10 Explanation: Water is trapped in the entire interior cells, with the height of water being: [ [ 3, 3, 3, 3, 3], [ 3, 3, 3, 3, 3], [ 3, 3, 3, 3, 3], [ 3, 3, 3, 3, 3], [ 3, 3, 3, 3, 3] ] Total water trapped = (3 - 2) * 8 + (3 - 1) = 10. ``` # Note * Use efficient data structures to manage and update the boundary cells during the simulation. * Make sure to analyze and handle all possible edge conditions such as flat regions and varying boundary heights.","solution":"from typing import List import heapq def trap_rain_water(heights: List[List[int]]) -> int: if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) visited = [[False] * n for _ in range(m)] water_trapped = 0 min_heap = [] # Push all the boundary cells into min_heap and mark them as visited for i in range(m): heapq.heappush(min_heap, (heights[i][0], i, 0)) heapq.heappush(min_heap, (heights[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(min_heap, (heights[0][j], 0, j)) heapq.heappush(min_heap, (heights[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heights[nx][ny]) heapq.heappush(min_heap, (max(height, heights[nx][ny]), nx, ny)) return water_trapped"},{"question":"Data Synchronization and Conflict Resolution Scenario You are tasked with developing part of a collaborative text editing application where multiple users can edit the same document in real-time. To ensure consistency, the application needs to synchronize changes from different users and resolve conflicts. Task Implement a function `synchronize_changes(doc_id: str, changes: list) -> dict` that: 1. Takes a `doc_id` (a string representing the document ID) and a `changes` list (each element being a dictionary representing edits from a user). 2. Applies these changes to the document and resolves any conflicts. 3. Returns the final state of the document as a dictionary. Requirements 1. **Input Format**: * `doc_id`: `str` - a unique identifier for the document. * `changes`: `list` - a list of dictionaries where each dictionary contains keys: * `user_id`: `str` - Identifier of the user who made the changes. * `edit`: `str` - The new text to be applied. * `timestamp`: `int` - Unix timestamp of when the edit was made. 2. **Output Format**: * `dict` - The final state of the document with keys: * `doc_id`: `str` - the unique document ID. * `content`: `str` - the final text content of the document. 3. **Constraints**: * Resolve conflicts by always keeping the latest edit based on the `timestamp`. * Initial document content is an empty string if no prior edits have been made. * The function should gracefully handle cases where `changes` list is empty or missing critical information like `timestamp`. 4. **Performance**: * Ensure that the function performs efficiently even with a large number of changes. Example ```python def synchronize_changes(doc_id: str, changes: list) -> dict: # Your implementation here pass # Sample Usage changes = [ {\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765}, {\\"user_id\\": \\"user3\\", \\"edit\\": \\"Hello, everyone!\\", \\"timestamp\\": 1625077763} ] final_document = synchronize_changes(doc_id=\\"doc_123\\", changes=changes) print(final_document) # Output: {\'doc_id\': \'doc_123\', \'content\': \'Hello, world!\'} ``` Implement the above function following the requirements. Ensure you handle any exceptions and provide meaningful error messages.","solution":"def synchronize_changes(doc_id: str, changes: list) -> dict: Applies changes from different users to a document and resolves conflicts. Args: doc_id (str): Unique identifier for the document. changes (list): A list of dictionaries, each containing keys: - user_id (str): Identifier of the user who made the changes. - edit (str): The new text to be applied. - timestamp (int): Unix timestamp of when the edit was made. Returns: dict: The final state of the document. if not changes: return {\\"doc_id\\": doc_id, \\"content\\": \\"\\"} # Resolve conflicts by considering the latest edit based on timestamp changes = [change for change in changes if \\"timestamp\\" in change] if not changes: return {\\"doc_id\\": doc_id, \\"content\\": \\"\\"} latest_change = max(changes, key=lambda change: change[\'timestamp\']) return {\\"doc_id\\": doc_id, \\"content\\": latest_change[\'edit\']}"},{"question":"# Binary Search Tree Operations As a software developer, you are tasked with implementing several fundamental operations on a Binary Search Tree (BST). Task: Implement the following functions: 1. **Insert**: Insert a node with a given value into the BST. 2. **Delete**: Delete a node with a given value from the BST. 3. **Find**: Check if a node with a given value exists in the BST. 4. **In-Order Traversal**: Print the values of all nodes in the BST in in-order. Specifications: * **Input Format**: - Number of operations: `q` - Operations: A sequence of operations where each operation is either `insert x`, `delete x`, `find x`, or `inorder`. - `insert x`: Insert a node with value `x` into the BST. - `delete x`: Delete a node with value `x` from the BST. - `find x`: Check if a node with value `x` exists in the BST. - `inorder`: Print the values of all nodes in the BST in in-order traversal. * **Output Format**: - **Insert/Delete**: No explicit output required. - **Find**: Print `True` if the node exists, otherwise print `False`. - **In-Order Traversal**: Print the values of all nodes in in-order traversal. * **Constraints**: - 1 ≤ q ≤ 100 - Assume all node values are unique and within a reasonable integer range. Example: ```python Input: Number of operations: 7 Operations: insert 10 insert 5 insert 15 find 5 delete 10 find 10 inorder Output: True False 5 15 ``` Additional Information: 1. Handle the BST properties: left child nodes are less than the parent node and right child nodes are more than the parent node. 2. Ensure that deleting a node properly rearranges the tree to maintain the BST properties. 3. Handle edge cases such as inserting into an empty tree, deleting a non-existent node, and finding a value not present in the tree.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find(self, key): return self._find(self.root, key) def _find(self, node, key): if node is None: return False if node.val == key: return True if key < node.val: return self._find(node.left, key) return self._find(node.right, key) def inorder_traversal(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.val) self._inorder(node.right, result)"},{"question":"Question You need to write a Python function `can_form_by_deletion` that determines if a string `s` can be formed from another string `source` by deleting some or none of the characters from `source` without changing the order of the remaining characters. # Function Signature ```python def can_form_by_deletion(source: str, s: str) -> bool: ``` # Input - `source` (string): The source string from which characters can be deleted (length <= 1000). - `s` (string): The target string to be formed (length <= 100). # Output - `bool`: Return `True` if `s` can be formed from `source` by deleting some characters from `source`; otherwise return `False`. # Constraints - `1 <= len(source) <= 1000` - `1 <= len(s) <= 100` # Examples ```python >>> can_form_by_deletion(\\"helloworld\\", \\"hlo\\") True >>> can_form_by_deletion(\\"helloworld\\", \\"hero\\") False >>> can_form_by_deletion(\\"abcde\\", \\"ace\\") True >>> can_form_by_deletion(\\"abcde\\", \\"aec\\") False >>> can_form_by_deletion(\\"aaaaa\\", \\"aa\\") True ``` # Considerations - Use two pointers technique to traverse both strings and check if `s` can be formed by deleting characters from `source`. - Ensure the function efficiently handles the given constraints on the lengths of the strings.","solution":"def can_form_by_deletion(source: str, s: str) -> bool: Determines if `s` can be formed from `source` by deleting some of the characters in `source` without reordering the remaining characters. :param source: The source string from which characters are deleted. :param s: The target string to form. :return: True if s can be formed by deleting characters from source, otherwise False. source_index = 0 s_index = 0 while source_index < len(source) and s_index < len(s): if source[source_index] == s[s_index]: s_index += 1 source_index += 1 return s_index == len(s)"},{"question":"# Context and Problem Statement You are tasked with building an automated system for managing warehouse inventory using barcode scanning. Each item in the warehouse is assigned a unique barcode. The system needs to log every item when it is added to the inventory and provide functionality to query details about the items. # Task Implement a class `WarehouseInventory` with the following methods: 1. **`add_item(barcode: str, description: str, quantity: int) -> None`**: - Adds an item to the inventory with the specified barcode, description, and quantity. If the item already exists, update its quantity by adding the new quantity to the existing one. 2. **`remove_item(barcode: str, quantity: int) -> bool`**: - Removes the specified quantity of the item with the given barcode. If the operation is successful (i.e., the item exists and has at least the specified quantity), return `True`. If the item does not have enough quantity or does not exist, return `False`. 3. **`query_item(barcode: str) -> Tuple[str, int]`**: - Returns a tuple containing the description and the quantity of the item with the given barcode. If the item does not exist, return a tuple with empty string `\\"\\"` and `0`. # Input and Output Formats **Methods and Parameters:** - `add_item(barcode: str, description: str, quantity: int) -> None` - `barcode` (str): The barcode of the item. - `description` (str): The description of the item. - `quantity` (int): The quantity of the item being added. - `remove_item(barcode: str, quantity: int) -> bool` - `barcode` (str): The barcode of the item. - `quantity` (int): The quantity to be removed. - `query_item(barcode: str) -> Tuple[str, int]` - `barcode` (str): The barcode of the item. **Returns:** - Methods return the specified type as described above. # Constraints * Each barcode is unique to an item. * The quantity of an item in the inventory will always be a non-negative integer. * Barcodes and descriptions are non-empty strings consisting of alphanumeric characters. # Example ```python inventory = WarehouseInventory() # Adding items inventory.add_item(\\"12345\\", \\"Item A\\", 50) inventory.add_item(\\"67890\\", \\"Item B\\", 20) inventory.add_item(\\"12345\\", \\"Item A\\", 25) # Updates quantity of Item A to 75 # Querying items assert inventory.query_item(\\"12345\\") == (\\"Item A\\", 75) assert inventory.query_item(\\"67890\\") == (\\"Item B\\", 20) assert inventory.query_item(\\"11111\\") == (\\"\\", 0) # Non-existent item # Removing items assert inventory.remove_item(\\"12345\\", 30) == True # Quantity of Item A is now 45 assert inventory.remove_item(\\"12345\\", 50) == False # Not enough quantity assert inventory.remove_item(\\"67890\\", 20) == True # Item B is completely removed # Querying items after removal assert inventory.query_item(\\"12345\\") == (\\"Item A\\", 45) assert inventory.query_item(\\"67890\\") == (\\"Item B\\", 0) # Item B no longer exists ``` # Explanation: 1. Items can be added or updated in the inventory using the `add_item` method. 2. Items can be removed using the `remove_item` method, which ensures that the quantity does not become negative and checks if enough items are available. 3. The `query_item` method allows retrieving the description and the available quantity of the item by its barcode.","solution":"from typing import Tuple, Dict class WarehouseInventory: def __init__(self): self.inventory = {} # Dictionary to store items with barcode as key def add_item(self, barcode: str, description: str, quantity: int) -> None: if barcode in self.inventory: self.inventory[barcode][\'quantity\'] += quantity else: self.inventory[barcode] = {\'description\': description, \'quantity\': quantity} def remove_item(self, barcode: str, quantity: int) -> bool: if barcode in self.inventory and self.inventory[barcode][\'quantity\'] >= quantity: self.inventory[barcode][\'quantity\'] -= quantity if self.inventory[barcode][\'quantity\'] == 0: del self.inventory[barcode] return True else: return False def query_item(self, barcode: str) -> Tuple[str, int]: if barcode in self.inventory: return (self.inventory[barcode][\'description\'], self.inventory[barcode][\'quantity\']) else: return (\\"\\", 0)"},{"question":"# Problem Statement You are tasked with writing a function to simulate a modified version of the \\"100 Prisoners and a Light Bulb\\" problem. In this variant, each prisoner has a unique prime number associated with them and must communicate through toggling a light bulb to indicate when they have been in the central room. You need to determine the minimum number of days required for all prisoners to be sure that every single one has been in the room at least once. # Function Signature ```python def minimum_days_to_visit(n: int) -> int: pass ``` # Input: * A single integer `n` representing the number of prisoners. Each prisoner is labeled with a unique prime number. # Output: * Return an integer representing the minimum number of days required for all prisoners to be sure that everyone has visited the room at least once. # Example: ```python def test_minimum_days_to_visit(): assert minimum_days_to_visit(5) == 23 assert minimum_days_to_visit(10) == 67 assert minimum_days_to_visit(20) == 199 test_minimum_days_to_visit() ``` # Constraints: * The input `n` will be between 1 and 100 exclusive. * The solution should be efficient and able to handle the increasing complexity with a growing number of prisoners. # Performance Considerations: * Ensure efficient simulation of the days and toggling the light bulb logic. * Optimize for calculating days ensure all prisoners have been in the room at least once, considering their associated prime numbers.","solution":"def minimum_days_to_visit(n): This function calculates the minimum number of days required for n prisoners to be sure that all of them have been in the room at least once. Each prisoner is associated with a unique prime number, and they communicate through toggling a light bulb. def nth_prime(n): Return the nth prime number using the Sieve of Eratosthenes. primes = [] candidate = 2 while len(primes) < n: is_prime = all(candidate % prime != 0 for prime in primes) if is_prime: primes.append(candidate) candidate += 1 return primes[-1] # Get the nth prime number, which represents the maximum days needed in the worst-case scenario. return nth_prime(n)"},{"question":"# Matrix Rotation and Sum Challenge You are tasked with implementing a function to rotate a square matrix by 90 degrees clockwise and then calculate the sum of the elements of the rotated matrix. Task: Implement the following function: 1. `rotate_and_sum(matrix: List[List[int]]) -> int`: This function takes a square matrix (a list of lists) of integers, rotates the matrix by 90 degrees clockwise, and returns the sum of all elements in the rotated matrix. Your implementation should: 1. Rotate the matrix by 90 degrees clockwise. 2. Calculate the sum of all elements in the rotated matrix. 3. Handle any potential edge cases for square matrices including empty matrices. Input: * The `matrix` will be a list of lists where each inner list represents a row of the matrix. Each element in the matrix will be an integer. Output: * Your function should return an integer representing the sum of the elements of the rotated matrix. Examples: ```python rotate_and_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # should return 45 rotate_and_sum([[1, 2], [3, 4]]) # should return 10 rotate_and_sum([[1]]) # should return 1 rotate_and_sum([]) # should return 0 ``` Constraints: * The input matrix will be a square matrix (n x n) where 0 <= n <= 1000. * Each element in the matrix will be an integer within the bounds of -1000 to 1000. Make sure your function is efficient and handles all edge cases correctly. Implement the `rotate_and_sum` function to solve this problem.","solution":"def rotate_and_sum(matrix): Rotates the given square matrix by 90 degrees clockwise and returns the sum of all the elements in the rotated matrix. If the matrix is empty, returns 0. if not matrix or not matrix[0]: return 0 n = len(matrix) rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] total_sum = sum(sum(row) for row in rotated_matrix) return total_sum"},{"question":"# Objective Develop a scheduler function that leverages a priority queue to handle and execute tasks based on their priority. This problem will demonstrate your ability to work with data structures, specifically heaps or priority queues. # Question Implement a priority scheduler function that accepts a list of tasks, each with an associated priority, and returns a list of tasks in the order they should be executed based on their priority. # Function Signature ```python def priority_scheduler(tasks: List[Tuple[int, str]]) -> List[str]: Schedule tasks based on their priorities using a priority queue. Parameters: - tasks (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer representing the priority (higher number means higher priority) and a string representing the task\'s name. Returns: - List[str]: A list of task names ordered by their priority from highest to lowest. ``` # Input/Output - **Input**: A list of tuples where each tuple contains an integer (priority) and a string (task name). - **Output**: A list of task names ordered by their priority, with the highest priority tasks first. # Constraints - The input list will have at most 10^5 tasks. - Priority values are within the range of -10^3 to 10^3, where higher numbers indicate higher priority. # Performance Requirement - Aim for efficient implementation using a priority queue (O(n log n) complexity). # Example ```python from typing import List, Tuple import heapq def priority_scheduler(tasks: List[Tuple[int, str]]) -> List[str]: # Create a max-heap (priority queue) max_heap = [(-priority, task) for priority, task in tasks] heapq.heapify(max_heap) # Extract tasks based on their priority scheduled_tasks = [] while max_heap: priority, task = heapq.heappop(max_heap) scheduled_tasks.append(task) return scheduled_tasks # Example usage tasks = [(3, \'task1\'), (1, \'task2\'), (4, \'task3\'), (2, \'task4\')] result = priority_scheduler(tasks) print(result) ``` # Notes: 1. Ensure efficiency by leveraging heap operations. 2. Validate your function with various test cases to handle different task lists and priorities.","solution":"from typing import List, Tuple import heapq def priority_scheduler(tasks: List[Tuple[int, str]]) -> List[str]: Schedule tasks based on their priorities using a priority queue. Parameters: - tasks (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer representing the priority (higher number means higher priority) and a string representing the task\'s name. Returns: - List[str]: A list of task names ordered by their priority from highest to lowest. # Create a max-heap (priority queue) max_heap = [(-priority, task) for priority, task in tasks] heapq.heapify(max_heap) # Extract tasks based on their priority scheduled_tasks = [] while max_heap: priority, task = heapq.heappop(max_heap) scheduled_tasks.append(task) return scheduled_tasks"},{"question":"# Coding Assessment Question **Context**: You are tasked with implementing a simple validation function for a username registration system. The system requires each username to meet specific criteria for it to be considered valid. **Objective**: Write a function `is_valid_username` that checks if a given username meets the required criteria. **Function signature**: ```python def is_valid_username(username: str) -> bool: pass ``` **Input**: * A single string `username` which consists of alphanumeric characters and underscores. **Output**: * Return `True` if the username is valid, `False` otherwise. **Constraints**: 1. The username must be between 5 and 12 characters inclusive. 2. The username must start with an alphabetical character (either lowercase or uppercase). 3. The username can only contain alphabetic characters, numerical digits, and underscores. **Example**: ```python >>> is_valid_username(\'User_123\') True >>> is_valid_username(\'user\') False >>> is_valid_username(\'123User\') False >>> is_valid_username(\'User@name\') False ``` **Performance Requirements**: * The function should be efficient and handle typical edge cases such as an empty string or extremely long strings gracefully. **Additional Information**: * Consider using regular expressions or character checks to validate the criteria. * Ensure that the function has clear and understandable error handling for any edge cases.","solution":"import re def is_valid_username(username: str) -> bool: Validate if the username meets the required criteria: 1. Must be between 5 and 12 characters inclusive. 2. Must start with an alphabetical character. 3. Can only contain alphabetic characters, numerical digits, and underscores. if not (5 <= len(username) <= 12): return False if not username[0].isalpha(): return False if not re.match(r\'^[A-Za-z0-9_]+\', username): return False return True"},{"question":"# Assignment: Implement a Basic Image Processing Pipeline You will be creating a simple image processing pipeline that includes loading an image, applying a grayscale filter, resizing the image, and saving the result. # Task: 1. Implement the function `load_image` to load an image from a file path. * Input: * `file_path` - A string representing the path to the image file. * Output: * An image object (you may use libraries like PIL to handle images). 2. Implement the function `grayscale` to convert an image to grayscale. * Input: * `image` - The image object to be converted to grayscale. * Output: * The grayscale version of the input image. 3. Implement the function `resize_image` to resize the image to the specified width and height. * Input: * `image` - The image object to be resized. * `width` - The width to resize the image to. * `height` - The height to resize the image to. * Output: * The resized image object. 4. Implement the function `save_image` to save the modified image to a file path. * Input: * `image` - The image object to be saved. * `file_path` - A string representing the path to save the image file. * Output: * None (the function should save the image to the specified path). # Constraints: * Assume the image file is a commonly used format like PNG, JPEG, or BMP. * Ensure the pipeline can handle different image sizes and color profiles. * Handle possible file I/O errors, such as file not found or permission issues. # Example: ```python # Loading an image image = load_image(\'path/to/image.jpg\') # Converting the image to grayscale gray_image = grayscale(image) # Resizing the grayscale image resized_image = resize_image(gray_image, 128, 128) # Saving the result save_image(resized_image, \'path/to/processed_image.jpg\') ``` # Notes: * Be mindful of edge cases such as invalid file paths, unsupported image formats, and invalid dimensions for resizing. * Ensure the functions are robust, handling exceptions and providing meaningful error messages where appropriate. * Your implementation should use a suitable image processing library where necessary (e.g., PIL or OpenCV).","solution":"from PIL import Image import os def load_image(file_path): Loads an image from the specified file path. :param file_path: str, path to the image file. :return: Image object. if not os.path.isfile(file_path): raise FileNotFoundError(f\\"No such file: \'{file_path}\'\\") return Image.open(file_path) def grayscale(image): Converts the given image to grayscale. :param image: Image object to be converted. :return: Grayscale Image object. return image.convert(\\"L\\") def resize_image(image, width, height): Resizes the given image to the specified width and height. :param image: Image object to be resized. :param width: int, width to resize the image to. :param height: int, height to resize the image to. :return: Resized Image object. return image.resize((width, height)) def save_image(image, file_path): Saves the given image to the specified file path. :param image: Image object to be saved. :param file_path: str, path to save the image file. image.save(file_path)"},{"question":"# Question You are given a list of integers, where each integer appears exactly twice except for one integer which appears only once. Your task is to implement the `find_single_number` function that identifies the single integer that appears only once in the list. # Function Signature ```python def find_single_number(array: list) -> int: ``` # Input * An integer list `array` where `1 <= len(array) <= 10^5`. * The array has exactly one integer appearing only once, and all other integers appear exactly twice. # Output * The function should return the single integer that appears only once. # Constraints * The array contains only integers. * The array will have at least one element. # Requirements * You must write a linear time algorithm (O(n)). * Use constant space (O(1)). # Examples ```python # Example 1 input_array = [2, 3, 2] print(find_single_number(input_array)) # Output: 3 # Example 2 input_array = [4, 1, 2, 1, 2] print(find_single_number(input_array)) # Output: 4 # Example 3 input_array = [7] print(find_single_number(input_array)) # Output: 7 # Example 4 input_array = [-3, -1, -1, -3, -5] print(find_single_number(input_array)) # Output: -5 ``` # Explanation * In **Example 1**, the integer `3` is the only one that appears once in the list `[2, 3, 2]`. * In **Example 2**, the integer `4` is the only one that appears once in the list `[4, 1, 2, 1, 2]`. * In **Example 3**, the list has only one element which is `7`, hence it is the number that appears once. * In **Example 4**, the integer `-5` is the only one that appears once in the list `[-3, -1, -1, -3, -5]`. # Additional Information * Consider edge cases such as the smallest possible array size and arrays with negative numbers. * Utilize an appropriate algorithm to meet the requirements of time complexity and space complexity.","solution":"def find_single_number(array: list) -> int: Given a list of integers where each element appears twice except for one, find the integer that appears only once. result = 0 for num in array: result ^= num # XOR operation return result"},{"question":"**Problem Statement:** You are given an integer `n` and an integer list of size `n`, where each element represents the height of a building. Write a function `find_total_rain_water(heights)` that calculates the total amount of rainwater that could be trapped between the buildings after raining. # Function Signature ```python def find_total_rain_water(heights: List[int]) -> int: ``` # Input: * **heights (List[int])**: A list of integers representing the height of buildings (0 ≤ heights[i] ≤ 1000, 1 ≤ n ≤ 10^4). # Output: * **int**: An integer representing the total units of water trapped between the buildings. # Constraints: * The solution should handle up to `n=10^4` heights efficiently in terms of time complexity. # Example: ```python assert find_total_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert find_total_rain_water([4,2,0,3,2,5]) == 9 ``` # Implementation Requirements: Create a program that: 1. Uses a two-pointer approach or precomputed left and right max arrays to efficiently calculate the trapped water. 2. Traverses the list while maintaining the maximum height of buildings to the left and right of each position. 3. Calculates the water trapped at each position as the minimum of maximum heights to the left and right of that position minus the height of the building at the current position. 4. Returns the total units of water trapped as an integer. # Note: Take care of edge cases, such as lists with less than three elements where no water can be trapped.","solution":"from typing import List def find_total_rain_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"# Question: Implement a Simple Binary Search Tree (BST) Context: You are required to create a simple Binary Search Tree (BST) with basic functionalities. The BST should allow insertion, searching, and in-order traversal. # Task: Implement a class `BinarySearchTree` with the following methods: 1. **Insertion**: Method `insert(data)` to add a new node with the given data. 2. **Search**: Method `search(data)` to find whether a node with the given data exists. 3. **In-order Traversal**: Method `inorder_traversal()` to return a list of elements in ascending order. # Requirements: 1. **Input/Output**: - Each method should operate on instances of `BinarySearchTree`. - The `insert` method should add the new data in the appropriate location. - The `search` method should return `True` if the data exists in the tree, otherwise `False`. - The `inorder_traversal` method should return a list of elements in ascending order. 2. **Constraints**: - The BST should not allow duplicate elements. - Handle edge cases such as inserting/searching in an empty tree. 3. **Performance**: - Ensure that all methods have time complexity considerations appropriate for a BST. # Example: ```python # Creating BinarySearchTree and inserting initial data bst = BinarySearchTree() initial_data = [20, 10, 30, 5, 15, 25, 35] for data in initial_data: bst.insert(data) # In-order Traversal print(bst.inorder_traversal()) # Expected: [5, 10, 15, 20, 25, 30, 35] # Searching for elements print(bst.search(15)) # Expected: True print(bst.search(100)) # Expected: False # Inserting additional data and performing in-order traversal bst.insert(12) print(bst.inorder_traversal()) # Expected: [5, 10, 12, 15, 20, 25, 30, 35] ``` # Note: Ensure to manage the tree\'s structure appropriately for each insertion, making sure it adheres to the properties of a binary search tree (i.e., all nodes on the left subtree have values less than the root, and all nodes on the right subtree have values greater than the root).","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) elif data > node.data: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) # Do nothing if data is equal since BST should not have duplicates def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def inorder_traversal(self): elements = [] self._inorder_traversal(self.root, elements) return elements def _inorder_traversal(self, node, elements): if node: self._inorder_traversal(node.left, elements) elements.append(node.data) self._inorder_traversal(node.right, elements)"},{"question":"# Coding Question: Advanced Subarray Sum Checker You are tasked with developing a feature for a financial analysis platform that detects fraudulent activities. One common indicator of fraud is the presence of a subarray (contiguous segment of an array) that sums up to a specific target amount. Your goal is to implement a function that verifies whether such a subarray exists within a given array of integers. # Requirements: 1. Implement the `has_subarray_with_sum(numbers: list[int], target: int) -> bool` function. 2. The function should return `True` if there exists at least one subarray within `numbers` that sums to `target`, and `False` otherwise. 3. The function should have an optimal time complexity and not just rely on a brute-force approach. # Input: * `numbers`: A list of integers representing the array to be analyzed. * `target`: An integer representing the target sum for the subarray. # Output: * A boolean value (`True` or `False`) indicating whether a subarray with the target sum exists. # Constraints: * The input list `numbers` can be empty. * The integers in the list can be positive, negative, or zero. * Aim for a solution more efficient than O(N^2) where N is the number of elements in the list. # Performance Requirements: * Your solution should handle large input sizes efficiently, making use of appropriate data structures as necessary. # Function Signature: ```python def has_subarray_with_sum(numbers: list[int], target: int) -> bool: pass ``` # Example: ```python numbers = [1, 2, 3, 7, 5] target = 12 assert has_subarray_with_sum(numbers, target) == True # Expected: True, subarray [2, 3, 7] numbers = [1, 4, 20, 3, 10, 5] target = 33 assert has_subarray_with_sum(numbers, target) == True # Expected: True, subarray [20, 3, 10] numbers = [-10, 0, 2, -2, 10, 5] target = 0 assert has_subarray_with_sum(numbers, target) == True # Expected: True, subarray [-10, 0, 2, -2, 10] numbers = [1, 2, 3] target = 6 assert has_subarray_with_sum(numbers, target) == True # Expected: True, entire array subarray [1, 2, 3] numbers = [1, 2, 3] target = 7 assert has_subarray_with_sum(numbers, target) == False # Expected: False, no subarray sums to 7 ``` # Additional Notes: * Test your function rigorously with different cases, including those with negative, zero, and positive values. * Aim for an efficient solution that leverages appropriate algorithms and data structures to minimize the time complexity.","solution":"def has_subarray_with_sum(numbers: list[int], target: int) -> bool: Determines if there exists at least one subarray within `numbers` that sums to `target`. current_sum = 0 prefix_sums = set() for number in numbers: current_sum += number if current_sum == target or (current_sum - target) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"# Task You are required to write a function `fewest_coins(coins: list, amount: int) -> int` that determines the minimum number of coins needed to make up a given amount using coins of specified denominations. # Input - A list of positive integers `coins` representing the available coin denominations. - A positive integer `amount` representing the total amount of money. # Output - The minimum number of coins needed to make up the given amount. - Return `-1` if it is not possible to make the amount with the given coin denominations. # Constraints - All elements in the `coins` list are unique. - (1 leq amount leq 10^4) - (1 leq coins[i] leq 10^4) - The list of coins will contain at most 50 different denominations. # Performance Requirements - The solution must be efficient, ideally with a polynomial time complexity relative to `amount`. # Scenario You are designing an algorithm for an automated teller machine (ATM) that needs to dispense cash with the fewest number of coins possible. This optimization not only minimizes the use of physical space but also simplifies currency distribution. # Example ```python >>> fewest_coins([1, 2, 5], 11) 3 >>> fewest_coins([2], 3) -1 >>> fewest_coins([1, 2, 5], 0) 0 >>> fewest_coins([1], 2) 2 ``` # Implementation ```python def fewest_coins(coins: list, amount: int) -> int: dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1 ```","solution":"def fewest_coins(coins: list, amount: int) -> int: Determines the minimum number of coins needed to make up a given amount using the specified coin denominations. Returns -1 if it\'s not possible to make the amount with the given coins. # Array to store the minimum coins needed for each amount up to the target amount dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins are needed to make the amount 0 for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float(\'inf\'): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Coding Question: Implement an Optimized Trie Data Structure for Word Search **Context**: A Trie (pronounced as \\"try\\") is a specialized tree-like data structure used in various applications such as autocomplete, spell checker, and search engines. The Trie\'s nodes store characters, and each path down the tree represents a word or a prefix of words. This structure allows for efficient querying of words and prefixes. **Challenge**: Your task is to implement an enhanced version of a `Trie` class. In this version, you will add functionality to: 1. Efficiently insert multiple words. 2. Search for words and prefixes. 3. Support autocomplete suggestions based on a given prefix. **Function Signature**: ```python class TrieNode: def __init__(self): self.children = {} self.is_word = False class EnhancedTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass def autocomplete(self, prefix: str) -> list[str]: pass ``` **Detailed Requirements**: 1. **Initialization**: The `EnhancedTrie` class should initialize with a root node, which is an instance of the `TrieNode` class. The `TrieNode` class should have: - A dictionary of children nodes (`self.children`). - A boolean flag (`self.is_word`) indicating if the node is the end of a word. 2. **Insert Function**: - The `insert` method should take a word and add it to the Trie. 3. **Search Function**: - The `search` method should take a word and return `True` if the word exists in the Trie, otherwise return `False`. 4. **Prefix Function**: - The `starts_with` method should take a prefix and return `True` if any word in the Trie starts with that prefix. 5. **Autocomplete Function**: - The `autocomplete` method should take a prefix and return a list of all words in the Trie that start with that prefix. **Constraints**: - Input strings are non-empty and consist of lowercase alphabetical characters. - Your program should handle multiple operations efficiently even when the Trie contains thousands of words. **Performance Requirements**: - Operations should be optimized for both latency and memory usage. - Ensure that the searching and prefix operations are efficient in both time and space complexity. **Example**: ```python >>> trie = EnhancedTrie() >>> trie.insert(\\"hello\\") >>> trie.insert(\\"helium\\") >>> trie.insert(\\"hero\\") >>> assert trie.search(\\"hello\\") == True >>> assert trie.search(\\"hell\\") == False >>> assert trie.starts_with(\\"he\\") == True >>> autocomplete_results = trie.autocomplete(\\"he\\") >>> print(autocomplete_results) [\'hello\', \'helium\', \'hero\'] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class EnhancedTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def autocomplete(self, prefix: str) -> list[str]: def dfs(node, path, results): if node.is_word: results.append(path) for char in node.children: dfs(node.children[char], path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"# Question: Validating Parentheses with Custom Rules Your objective is to implement a function to validate strings that contain nested parentheses, brackets, and curly braces according to specific rules. You are given a string consisting of characters: \'(\', \')\', \'[\', \']\', \'{\', and \'}\'. Write a function `is_valid_parentheses(s: str) -> bool` that determines if the given string is valid. A valid string meets the following criteria: 1. **Opening brackets must be closed by the same type of brackets** (\\"(\\", \\")\\", \\"[\\", \\"]\\", \\"{\\", \\"}\\"). 2. **Opening brackets must be closed in the correct order**. 3. **Every close bracket has a corresponding open bracket before it**. # Input * `s` (str): A string consisting of characters \'(\', \')\', \'[\', \']\', \'{\', and \'}\'. # Output * A boolean value: `True` if the string is valid, `False` otherwise. # Constraints * The length of the string (`n`): 1 ≤ n ≤ 10^4. # Examples ```python print(is_valid_parentheses(\\"()\\")) # Expected Output: True print(is_valid_parentheses(\\"()[]{}\\")) # Expected Output: True print(is_valid_parentheses(\\"(]\\")) # Expected Output: False print(is_valid_parentheses(\\"([)]\\")) # Expected Output: False print(is_valid_parentheses(\\"{[]}\\")) # Expected Output: True print(is_valid_parentheses(\\"[{}}\\")) # Expected Output: False ``` # Hints * Use a stack data structure to keep track of the opening brackets encountered. * Iterate through the string character by character, and push opening brackets onto the stack. * When a closing bracket is encountered, check if it matches the most recent opening bracket on the stack. * Ensure the stack is empty at the end for the string to be valid. # Performance Requirements * The solution must complete in O(n) time complexity. * Space complexity should be O(n) due to the use of an auxiliary stack. Compose a clean and efficient function to solve the problem while considering edge cases, such as mismatched brackets or incorrect nesting, and including adequate testing in your implementation.","solution":"def is_valid_parentheses(s: str) -> bool: Determines if a given string of parentheses, brackets, and braces is valid. stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in bracket_map: # If it\'s a closing bracket top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: # It\'s an opening bracket stack.append(char) return not stack"},{"question":"# Question You are developing a library to facilitate scientific computing and need to implement a function that computes the rank of a square matrix. The rank of a matrix is the dimension of the vector space generated (or spanned) by its rows. This is the same as the dimension of the vector space generated (or spanned) by its columns. Your task is to write a function `matrix_rank` that calculates the rank of a given square matrix using Gaussian elimination. **Function Signature:** ```python def matrix_rank(matrix: list[list[float]]) -> int: pass ``` # Input: - `matrix`: A square matrix represented as a list of lists, where each inner list is a row of the matrix. Each element is a `float`. # Output: - Returns an integer representing the rank of the given matrix. # Constraints: - Assume the input matrix is always a valid square matrix (n x n). - Floating-point precision issues can be ignored for simplicity. - The matrix will not exceed dimensions of 100 x 100 for practical performance considerations. # Example: ```python # Example Usage: matrix = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ] print(matrix_rank(matrix)) # Output: 2 ``` In this example, the matrix has a rank of 2 because the rows (and columns) of the matrix are linearly dependent.","solution":"def matrix_rank(matrix: list[list[float]]) -> int: Computes the rank of a square matrix using Gaussian elimination. n = len(matrix) def swap_rows(i, j): matrix[i], matrix[j] = matrix[j], matrix[i] def reduce_rows(i, j, scale): for col in range(n): matrix[i][col] -= scale * matrix[j][col] rank = 0 for col in range(n): pivot_row = None for row in range(rank, n): if abs(matrix[row][col]) > 1e-10: # Avoid floating point precision issues pivot_row = row break if pivot_row is None: continue swap_rows(rank, pivot_row) for row in range(rank + 1, n): reduce_rows(row, rank, matrix[row][col] / matrix[rank][col]) rank += 1 return rank"},{"question":"# Coding Question Scenario In the realm of natural language processing, tokenizing a text is a crucial step. Tokenization refers to the process of segmenting text into individual tokens, such as words or phrases. This task often involves removing punctuation and converting text to lowercase to ensure uniformity. Task Implement the function `tokenize_text` to tokenize an input string into a list of words, adhering to the following rules: 1. Remove all punctuation. 2. Convert the entire text to lowercase. 3. Split the text into individual words based on spaces. # Function Signature ```python def tokenize_text(text: str) -> list[str]: ``` # Input * `text`: A string representing a passage of text to be tokenized. # Output * A list of lowercase words with no punctuation. # Constraints * The length of `text` will be between 0 and 10^6. * The `text` may include any printable ASCII characters. # Requirements 1. If `text` is an empty string, the function should return an empty list. 2. Punctuation marks to remove include: `! \\" # % & \' ( ) * + , - . / : ; < = > ? @ [ ] ^ _ ` { | } ~` # Example ```python # Input text = \\"Hello, World! This is a test.\\" # Output [\'hello\', \'world\', \'this\', \'is\', \'a\', \'test\'] ``` **Notes:** - You may use Python\'s `string.punctuation` to identify punctuation characters. - Consider edge cases such as multiple spaces, text with no alpha characters, and varying punctuation. **Edge cases to consider:** - Empty input string. - Text that\'s primarily punctuation. - Uppercase and mixed-case handling.","solution":"import string def tokenize_text(text: str) -> list[str]: This function takes a string of text and returns a list of words, after removing punctuation, converting to lowercase, and splitting by spaces. # Remove punctuation using str.translate and str.maketrans translator = str.maketrans(\'\', \'\', string.punctuation) text_without_punct = text.translate(translator) # Convert the text to lowercase text_lower = text_without_punct.lower() # Split the text by spaces words = text_lower.split() return words"},{"question":"# Merge Sorted Arrays You are tasked with implementing an efficient algorithm to merge multiple sorted arrays into a single sorted array. Problem Given `k` sorted arrays, merge them into one sorted array and return the result. Input - A list of `k` sorted arrays, where each array has `n_i` elements (1 ≤ n_i ≤ 2000) and 1 ≤ k ≤ 100. Output - A list representing the single sorted array containing all elements from the input arrays. Example ```python >>> merge_sorted_arrays([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_sorted_arrays([[10, 20, 30], [5, 15, 25], [1, 2, 3]]) [1, 2, 3, 5, 10, 15, 20, 25, 30] >>> merge_sorted_arrays([[-5, 0, 5], [-10, 0, 10]]) [-10, -5, 0, 0, 5, 10] ``` # Constraints - The algorithm should be efficient, using a time complexity of O(n log k), where `n` is the total number of elements across all `k` arrays. - Ensure your solution handles edge cases such as: - Arrays containing duplicate elements. - Arrays of varying lengths. Implementation Implement the function `merge_sorted_arrays(arrays: list[list[int]]) -> list[int]`.","solution":"from heapq import heappop, heappush def merge_sorted_arrays(arrays): Merge k sorted arrays into a single sorted array. :param arrays: List of lists, each list is sorted in ascending order. :return: A single sorted list containing all the elements from the input arrays. merged = [] heap = [] # Initialize the heap with the first element of each array for i, array in enumerate(arrays): if array: heappush(heap, (array[0], i, 0)) # Extract the smallest element from the heap and add next element of that array to the heap while heap: val, array_idx, element_idx = heappop(heap) merged.append(val) if element_idx + 1 < len(arrays[array_idx]): next_tuple = (arrays[array_idx][element_idx + 1], array_idx, element_idx + 1) heappush(heap, next_tuple) return merged"},{"question":"# Problem Statement: Scrabble Word Scoring You are tasked with implementing a function that calculates the Scrabble score for a given word. The score is determined based on the letter values as defined by traditional Scrabble rules. Function Signature ```python def scrabble_score(word: str) -> int: Calculate the Scrabble score of a given word based on traditional Scrabble letter values. :param word: The word for which the Scrabble score needs to be calculated. :return: The total Scrabble score. pass ``` Input * `word`: a string consisting of uppercase and/or lowercase letters. Output * The function should return an integer representing the total Scrabble score for the input word. Constraints 1. The input word will contain only alphabet letters and will be non-empty. 2. Case insensitive scoring: \'a\' and \'A\' are treated as the same with respect to scoring. 3. Traditional Scrabble letter values are as follows: - 1 point: A, E, I, O, U, L, N, S, T, R - 2 points: D, G - 3 points: B, C, M, P - 4 points: F, H, V, W, Y - 5 points: K - 8 points: J, X - 10 points: Q, Z Example ```python word = \\"Straight\\" score = scrabble_score(word) # Output: 12 word = \\"HELLO\\" score = scrabble_score(word) # Output: 8 word = \\"quiz\\" score = scrabble_score(word) # Output: 22 ``` Requirements 1. Implement the function while ensuring case insensitivity. 2. Validate the function with edge cases such as words with high point letters (e.g., \'Q\' and \'Z\'). 3. Maintain performance efficiency for typical word lengths in Scrabble.","solution":"def scrabble_score(word: str) -> int: Calculate the Scrabble score of a given word based on traditional Scrabble letter values. :param word: The word for which the Scrabble score needs to be calculated. :return: The total Scrabble score. letter_values = { \'A\': 1, \'E\': 1, \'I\': 1, \'O\': 1, \'U\': 1, \'L\': 1, \'N\': 1, \'S\': 1, \'T\': 1, \'R\': 1, \'D\': 2, \'G\': 2, \'B\': 3, \'C\': 3, \'M\': 3, \'P\': 3, \'F\': 4, \'H\': 4, \'V\': 4, \'W\': 4, \'Y\': 4, \'K\': 5, \'J\': 8, \'X\': 8, \'Q\': 10, \'Z\': 10 } score = 0 for letter in word.upper(): score += letter_values.get(letter, 0) return score"},{"question":"# String Pattern Matching with Wildcards **Objective**: Implement a function to perform pattern matching where the pattern can contain wildcards `\'*\'` and `\'?\'` and ensure a robust matching algorithm. **Task**: 1. **Core Functionality**: Implement a function `wildcard_match` that matches a given input string against a pattern containing wildcards. 2. **Pattern Wildcards**: * `\'*\'` matches any sequence of characters (including an empty sequence). * `\'?\'` matches any single character. 3. **Validation**: Ensure proper validation for input strings and patterns, and handle edge cases as described. **Input and Output Formats**: * **Input**: * `input_str` (str): The input string to be matched. * `pattern` (str): The pattern string which may include wildcards. * **Output**: Boolean value indicating whether the pattern matches the input string. **Constraints**: * `input_str` and `pattern` are both non-empty strings. * Patterns may contain characters a-z, A-Z, 0-9, as well as the wildcards `\'*\'` and `\'?\'`. **Performance Requirements**: The function should handle typical use cases efficiently, with a reasonable balance between time and space complexity. **Function Signature**: ```python def wildcard_match(input_str: str, pattern: str) -> bool: pass ``` **Examples**: 1. `wildcard_match(\\"abcdef\\", \\"a*d?f\\")` should return `True`. 2. `wildcard_match(\\"hello\\", \\"h*o\\")` should return `True`. 3. `wildcard_match(\\"test\\", \\"te?t*\\")` should return `True`. 4. `wildcard_match(\\"pattern\\", \\"patt?rn*\\")` should return `False`. **Notes**: 1. Ensure that all possible wildcard and character positions in the pattern are considered. 2. Handle scenarios where the input string or pattern contains no wildcards. 3. Consider edge cases such as empty pattern after wildcards, patterns ending with multiple wildcards, etc. This question tests the ability to implement and understand pattern matching algorithms, handle string manipulations, and account for edge cases related to wildcards.","solution":"def wildcard_match(input_str: str, pattern: str) -> bool: Determines if the input_str matches the pattern with wildcards. :param input_str: The input string to be matched. :param pattern: The pattern string which may include wildcards * and ?. :return: True if the pattern matches the input string, False otherwise. # Initialize the DP table dp = [[False] * (len(pattern) + 1) for _ in range(len(input_str) + 1)] dp[0][0] = True # Empty pattern matches empty string # Fill in the first row for patterns starting with \'*\' for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Build the DP table for i in range(1, len(input_str) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == \'*\': # * can be treated as empty or one/more characters dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or pattern[j - 1] == input_str[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(input_str)][len(pattern)]"},{"question":"# **Question: Simulate a Cache System with Least Recently Used (LRU) Eviction Policy** Design a cache system that uses the Least Recently Used (LRU) eviction policy. You need to implement a class `LRUCache` that supports the following operations: 1. `get(key: int) -> int`: Returns the value of the `key` if the `key` exists in the cache, otherwise returns -1. 2. `put(key: int, value: int) -> None`: Inserts the `key` and `value` if the `key` does not already exist in the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. **Class Definition:** ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` # Constraints: - The number of `get` and `put` operations will not exceed `10^4`. - The keys and values are positive integers. - The capacity is a positive integer and does not exceed `10^4`. # Example: ```python # Example Usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` **Notes:** - You must use an Ordered Dictionary or equivalent to ensure O(1) time complexity for the `get` and `put` methods. - Ensure that the solution maintains the order of use to correctly evict the least recently used item. Develop a clean and efficient implementation that adheres to the described behavior and constraints.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value # re-insert to mark it as recently used return value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first added (least recently used) self.cache[key] = value"},{"question":"# Sorting and Merging Task Context: You are working on a data analysis project that involves sorting and merging datasets. Your job is to create a function that sorts a list of dictionaries based on a specified key and then merges two such sorted lists into a single sorted list. This is often useful in scenarios like preparing data for reporting or integrating information from multiple sources. Task: Write a Python function, `merge_and_sort_lists(list1: list, list2: list, sort_key: str) -> list`, that takes two lists of dictionaries and a key. The function should sort each list based on the given key and then merge the lists into a single sorted list, maintaining the overall sorted order. Input: 1. `list1` (list): The first list of dictionaries to be sorted and merged. 2. `list2` (list): The second list of dictionaries to be sorted and merged. 3. `sort_key` (str): The key in the dictionaries to sort the lists by. Output: - A single list of dictionaries that is the merged and sorted version of the input lists. Example Input: ```python list1 = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, ] list2 = [ {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 88}, {\\"name\\": \\"David\\", \\"age\\": 20, \\"score\\": 95}, ] sort_key = \\"age\\" ``` Example Output: ```python [ {\\"name\\": \\"David\\", \\"age\\": 20, \\"score\\": 95}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 88}, ] ``` Constraints: 1. The input lists may contain up to (10^4) dictionaries. 2. The sort key will always be present in all dictionaries. 3. Each dictionary will have consistent and comparable values for the sort key. Requirements: 1. Ensure the function handles edge cases where lists may be empty. 2. Ensure efficient sorting and merging to handle large datasets. # Example Usage: ```python result = merge_and_sort_lists(list1, list2, sort_key) print(result) ```","solution":"def merge_and_sort_lists(list1, list2, sort_key): Sorts two lists of dictionaries by a specified key and merges them into one sorted list. Parameters: list1 (list): The first list of dictionaries. list2 (list): The second list of dictionaries. sort_key (str): The key to sort the dictionaries by. Returns: list: A single merged and sorted list of dictionaries. sorted_list1 = sorted(list1, key=lambda x: x[sort_key]) sorted_list2 = sorted(list2, key=lambda x: x[sort_key]) merged_list = [] i = j = 0 # Merging two sorted lists while i < len(sorted_list1) and j < len(sorted_list2): if sorted_list1[i][sort_key] <= sorted_list2[j][sort_key]: merged_list.append(sorted_list1[i]) i += 1 else: merged_list.append(sorted_list2[j]) j += 1 # Append the remaining elements merged_list.extend(sorted_list1[i:]) merged_list.extend(sorted_list2[j:]) return merged_list"},{"question":"**Array Transformation and Analysis** You are building a data processing tool that involves a series of transformations for numerical arrays. Your objective is to implement functions that perform four specific transformations and an evaluation step. **Objective:** Complete the missing implementations for these transformations and evaluate the processed arrays using provided datasets. **Requirements:** 1. **Scaling Transformation**: - Implement a function that scales a 1D numpy array by a given factor. - Refer to `scale_array`. 2. **Exponential Transformation**: - Implement a function that applies an exponential transformation to a 1D numpy array. - Refer to `exponential_transform`. 3. **Mean Subtraction**: - Implement a function that subtracts the mean of the array from each element. - Refer to `subtract_mean`. 4. **Array Smoothing**: - Use `smooth_array` to implement a smoothing transformation using a moving average filter of a given window size. 5. **Array Comparison**: - Implement a function to compare two arrays and compute the Mean Squared Error (MSE) between them. - Refer to `compare_arrays`. **Function Signatures**: ```python import numpy as np def scale_array(array: np.ndarray, factor: float) -> np.ndarray: # Implement scaling transformation pass def exponential_transform(array: np.ndarray) -> np.ndarray: # Implement exponential transformation pass def subtract_mean(array: np.ndarray) -> np.ndarray: # Implement mean subtraction transformation pass def smooth_array(array: np.ndarray, window_size: int) -> np.ndarray: # Implement array smoothing transformation pass def compare_arrays(array1: np.ndarray, array2: np.ndarray) -> float: # Implement array comparison using Mean Squared Error (MSE) pass ``` **Input and Output**: Input: 1. A list of 1D numpy arrays. 2. A scale factor. 3. The window size for the moving average filter. 4. A base index to compare the transformed arrays against. Output: 1. A ranked list of arrays based on the Mean Squared Error (MSE) compared to the base array. **Constraints**: - Arrays will have at least 5 elements. - The window size for the moving average will be a positive integer less than or equal to the length of the arrays. **Example**: ```python arrays = [np.array([1, 2, 3, 4, 5]), np.array([2, 3, 4, 5, 6]), np.array([5, 4, 3, 2, 1])] base_index = 0 scale_factor = 2 window_size = 2 ranked_arrays = array_transformation_pipeline(arrays, base_index, scale_factor, window_size) ``` Output: ``` Query: array1 Ranking: (0) array1 (1) array2 (2) array3 ```","solution":"import numpy as np def scale_array(array: np.ndarray, factor: float) -> np.ndarray: Scales the array by a given factor. return array * factor def exponential_transform(array: np.ndarray) -> np.ndarray: Applies exponential transformation to the array. return np.exp(array) def subtract_mean(array: np.ndarray) -> np.ndarray: Subtracts the mean of the array from each element. mean = np.mean(array) return array - mean def smooth_array(array: np.ndarray, window_size: int) -> np.ndarray: Applies a moving average filter with a given window size to smooth the array. cumsum = np.cumsum(np.insert(array, 0, 0)) return (cumsum[window_size:] - cumsum[:-window_size]) / window_size def compare_arrays(array1: np.ndarray, array2: np.ndarray) -> float: Computes the Mean Squared Error (MSE) between two arrays. return np.mean((array1 - array2) ** 2) def array_transformation_pipeline(arrays, base_index, scale_factor, window_size): Applies transformations to the arrays and ranks them based on MSE compared to the base array. transformed_arrays = [] for arr in arrays: scaled = scale_array(arr, scale_factor) exp_transformed = exponential_transform(scaled) mean_subtracted = subtract_mean(exp_transformed) smoothed = smooth_array(mean_subtracted, window_size) transformed_arrays.append(smoothed) base_array = transformed_arrays[base_index] mse_list = [(i, compare_arrays(base_array, trans_array)) for i, trans_array in enumerate(transformed_arrays)] ranked_list = sorted(mse_list, key=lambda x: x[1]) return ranked_list"},{"question":"# Pathfinding in a Maze Scenario You are working on a robotics project that requires navigating a robot through a maze from a starting position to a target position. The maze is represented as a 2D grid where `1` represents an obstacle and `0` represents a free space. You decide to use the Breadth-First Search (BFS) algorithm to find the shortest path in the maze. Task Implement the `find_shortest_path` function to find the shortest path between two points in a given maze. Function Signature ```python def find_shortest_path( maze: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> Optional[int] ``` Input * `maze`: A 2D list of integers representing the maze. * `start`: A tuple `(x, y)` representing the starting position in the maze. * `target`: A tuple `(x, y)` representing the target position in the maze. Output An integer representing the number of steps in the shortest path from `start` to `target`, or `None` if no such path exists. Constraints * The dimensions of the maze `n x m` satisfy (1 leq n, m leq 1000). * The starting and target positions are always within the bounds of the maze and are initially free spaces (`0`). * All moves are restricted to the four cardinal directions (up, down, left, right). Example Consider the following maze and query: ```python maze = [ [0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0] ] start = (0, 0) target = (4, 4) # Expected Output # Shortest Path: 8 ``` Performance Requirements Ensure the algorithm executes efficiently for maze dimensions up to (1000 times 1000). The algorithm should operate within a time complexity of (O(n times m)).","solution":"from collections import deque from typing import List, Tuple, Optional def find_shortest_path(maze: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> Optional[int]: n, m = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_in_bounds(x: int, y: int) -> bool: return 0 <= x < n and 0 <= y < m visited = set() queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_in_bounds(nx, ny) and (nx, ny) not in visited and maze[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return None"},{"question":"# Circular Array Rotation In computer science, a common task is to rotate elements of an array. One variant of this task is called \\"circular array rotation,\\" where the elements of the array are shifted to the right by a number of steps, with the elements that fall off the end being re-introduced at the start of the array. **Problem Statement**: Given an array of integers `arr` and an integer `k`, implement the `circular_array_rotation` function to return a new array that is the result of rotating `arr` to the right by `k` steps. # Function Signature: ```python def circular_array_rotation(arr: List[int], k: int) -> List[int]: pass ``` # Input: * `arr` (List[int]): A list of integers to be rotated. * `k` (int): The number of steps to rotate the array to the right. # Output: * Returns a List[int] that represents the array after performing the circular rotation. # Constraints: * The elements in the array can be negative or positive integers. * The length of the array (n) will be between 1 and 10^5. * The value of `k` will be between 0 and 10^5. * Optimize your solution to handle large inputs efficiently. # Example: ```python # Rotates array [1, 2, 3, 4, 5] by 1 step to the right print(circular_array_rotation([1, 2, 3, 4, 5], 1)) # Output: [5, 1, 2, 3, 4] # Rotates array [1, 2, 3, 4, 5] by 3 steps to the right print(circular_array_rotation([1, 2, 3, 4, 5], 3)) # Output: [3, 4, 5, 1, 2] # Rotates array [1, 2, 3, 4, 5] by 5 steps to the right print(circular_array_rotation([1, 2, 3, 4, 5], 5)) # Output: [1, 2, 3, 4, 5] # Rotates array [1, 2, 3, 4, 5] by 0 step to the right print(circular_array_rotation([1, 2, 3, 4, 5], 0)) # Output: [1, 2, 3, 4, 5] ``` # Notes: - Circular rotation means that the array\'s end elements are wrapped around to the array\'s start. - Consider modular arithmetic to handle cases where `k` >= `n`. # Tests: Provide additional test cases covering edge cases like: - Large values of `k` that are more than the length of the array. - Arrays with a single element. - Negative numbers in the array. - Ensure the correct array is returned with different input lengths and types.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) k = k % n # Normalize k to avoid unnecessary full rotations return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You are tasked with implementing a function to evaluate the similarity between two strings using the Jaccard similarity coefficient. The Jaccard similarity coefficient is defined as the size of the intersection divided by the size of the union of the sample sets. In this context, the sample sets are the n-grams (substrings of length n) of the two input strings. # Function Signature ```python def jaccard_similarity(s1: str, s2: str, n: int) -> float: pass ``` # Input - `s1`: A string representing the first input string. - `s2`: A string representing the second input string. - `n`: An integer representing the length of the n-grams to be used for comparison. # Output - A float representing the Jaccard similarity coefficient between the two input strings based on their n-grams. # Constraints - The length of `s1` and `s2` will be between 1 and 1000 characters. - The value of `n` will be a positive integer less than or equal to the length of the shorter string. # Example ```python # Example usage s1 = \\"abcde\\" s2 = \\"cdefg\\" n = 2 # Expected output: # The 2-grams for s1 are: {\'ab\', \'bc\', \'cd\', \'de\'} # The 2-grams for s2 are: {\'cd\', \'de\', \'ef\', \'fg\'} # The intersection of the sets is: {\'cd\', \'de\'} # The union of the sets is: {\'ab\', \'bc\', \'cd\', \'de\', \'ef\', \'fg\'} # The Jaccard similarity coefficient is 2/6 = 0.333 jaccard_similarity(s1, s2, n) ``` # Task Description 1. **Generate n-grams**: Write a helper function to generate n-grams for a given string and integer n. 2. **Calculate Intersection and Union**: Compute the intersection and union of the n-grams of the two input strings. 3. **Compute Similarity**: Calculate and return the Jaccard similarity coefficient as a float. 4. **Edge Cases & Performance**: Handle edge cases such as empty strings or n greater than the string lengths and ensure the solution performs efficiently for longer strings.","solution":"def generate_ngrams(s, n): Generate n-grams for a given string and length. return {s[i:i+n] for i in range(len(s) - n + 1)} def jaccard_similarity(s1, s2, n): Returns the Jaccard similarity coefficient between two strings based on their n-grams. if n > len(s1) or n > len(s2): return 0.0 ngrams1 = generate_ngrams(s1, n) ngrams2 = generate_ngrams(s2, n) intersection = ngrams1.intersection(ngrams2) union = ngrams1.union(ngrams2) if not union: return 0.0 # Avoid division by zero return len(intersection) / len(union)"},{"question":"# Coding Question: Contact Management System You are tasked with developing a simple contact management system where you can add and look up contacts. The system should also be able to handle contact searches with partial names (case insensitive). You will write two functions: `add_contact(name: str, phone_number: str) -> None` and `search_contacts(query: str) -> List[str]`. Function 1: add_contact(name, phone_number) * `name` is a string representing the name of the contact. * `phone_number` is a string representing the contact\'s phone number. * There is no return value for this function. Function 2: search_contacts(query) * `query` is a string that represents the search query (which could be a full or partial contact name). * This function returns a list of strings. Each string in the list should be in the format \\"name: phone_number\\". * If no contacts match the query, return an empty list. Constraints: * Contact names and queries are case-insensitive. * Ensure the contact names do not exceed 50 characters. * Phone numbers are strings of digits that may include dashes and spaces for formatting. * Ensure that duplicate contacts (same name and phone number) are not added. # Example: ```python def add_contact(name: str, phone_number: str) -> None: >>> add_contact(\'Alice Johnson\', \'123-456-7890\') >>> add_contact(\'Bob Thompson\', \'098-765-4321\') >>> add_contact(\'alice johnson\', \'123-456-7890\') # Duplicate def search_contacts(query: str) -> List[str]: >>> search_contacts(\'Alice\') [\'Alice Johnson: 123-456-7890\'] >>> search_contacts(\'bo\') [\'Bob Thompson: 098-765-4321\'] >>> search_contacts(\'Jo\') [] ``` # Notes: * Validate the input to ensure no contact exceeds the name length limit and phone number patterns are adhered to. * Utilize appropriate data structures to ensure efficient contact lookup and management. * Handle cases where input is empty or contains unusual characters gracefully. This question combines concepts of data storage, string manipulation, and search algorithms to manage and query a simple dataset, similar in complexity to the given advanced route cipher question.","solution":"contacts = {} def add_contact(name: str, phone_number: str) -> None: name = name.strip().lower() if len(name) > 50: raise ValueError(\\"Contact name exceeds 50 characters\\") phone_number = phone_number.strip() if name in contacts and contacts[name] == phone_number: return # Duplicate contact, do nothing contacts[name] = phone_number def search_contacts(query: str) -> list: query = query.strip().lower() results = [] for name, phone_number in contacts.items(): if query in name: formatted_name = name.title() formatted_contact = f\\"{formatted_name}: {phone_number}\\" results.append(formatted_contact) return sorted(results)"},{"question":"Question Maintaining accurate records of inventory is crucial in large-scale retail management. You are tasked with developing a function to track and update inventory counts efficiently. Your function will receive a list of transactions indicating items sold and returned, updating the initial inventory accordingly. # Function Signature ```python def update_inventory(initial_inventory: dict, transactions: list) -> dict: pass ``` # Input * A dictionary `initial_inventory` where keys are item names (strings) and values are the quantities (integers) present in the inventory initially. * A list of `transactions` where each transaction is represented as a tuple of the form `(item_name: str, change_in_qty: int)`. # Output * A dictionary containing the updated inventory after applying all transactions. # Constraints * Each item name will be a non-empty string. * All inventory changes are integers and can be negative (indicating items returned). # Examples ```python >>> update_inventory({\'apples\': 10, \'bananas\': 5, \'oranges\': 8}, [(\'apples\', -3), (\'bananas\', 2), (\'oranges\', -5), (\'kiwis\', 7)]) {\'apples\': 7, \'bananas\': 7, \'oranges\': 3, \'kiwis\': 7} >>> update_inventory({\'notebooks\': 20, \'pens\': 50}, [(\'notebooks\', -10), (\'pens\', -25), (\'markers\', 12)]) {\'notebooks\': 10, \'pens\': 25, \'markers\': 12} >>> update_inventory({}, [(\'bottles\', 5), (\'cans\', 3)]) {\'bottles\': 5, \'cans\': 3} ``` # Scenario In a retail system, the inventory must be constantly updated to reflect sales and returns of items. Your function will assist store managers in maintaining up-to-date records of all items, thus ensuring better stock management. This function needs to handle new items being added dynamically and update existing items correctly. # Notes Implement the function to efficiently handle updates, considering that the number of transactions can be large. Make sure to manage cases where new items are introduced through transactions and when multiple changes happen for the same item. The function will be tested with varying sizes and types of inputs to ensure robustness and correctness.","solution":"def update_inventory(initial_inventory: dict, transactions: list) -> dict: Updates the initial inventory based on the transactions provided. Parameters: initial_inventory (dict): A dictionary where keys are item names (strings) and values are quantities (integers). transactions (list): A list of transactions where each transaction is a tuple of the form (item_name: str, change_in_qty: int). Returns: dict: The updated inventory after applying all transactions. updated_inventory = initial_inventory.copy() for item_name, change_in_qty in transactions: if item_name in updated_inventory: updated_inventory[item_name] += change_in_qty else: updated_inventory[item_name] = change_in_qty return updated_inventory"},{"question":"# Matrix Exponentiation **Context:** Matrix exponentiation is a powerful technique used for solving linear recurrence relations efficiently. You are tasked with implementing a function to compute the nth power of a given square matrix using matrix exponentiation by squaring. **Problem Statement:** Craft a function `matrix_exponentiation` that calculates the nth power of a square matrix (M) using an efficient algorithm rather than performing repeated matrix multiplication naively. Matrix exponentiation by squaring should be implemented to ensure optimal performance. ```python def matrix_exponentiation(matrix: np.ndarray, exponent: int) -> np.ndarray: pass ``` **Function Definition:** * **Input**: * `matrix` (np.ndarray): The square matrix to be raised to the power of `exponent`. * `exponent` (int): The power to which the matrix is to be raised. (0 leq text{exponent} leq 10^9) * **Output**: * Returns np.ndarray: The resultant matrix after raising the input matrix to the given power. **Constraints**: 1. The input matrix should be a square matrix. 2. The value of `exponent` is non-negative and can be as large as (10^9). 3. Ensure that the function handles large exponents efficiently using matrix exponentiation by squaring. **Edge Cases to Consider**: 1. `exponent` is 0, which should return the identity matrix. 2. Handle large exponents within reasonable time limits. 3. Non-square input matrices should raise an error. # Example: ```python import numpy as np matrix = np.array([[1, 2], [3, 4]]) exponent = 2 print(matrix_exponentiation(matrix, exponent)) # Output: array([[ 7, 10], [15, 22]]) ``` **Verification**: Write unit tests to ensure the `matrix_exponentiation` function correctly raises the matrix to the given power, including handling edge cases. ```python import unittest class TestMatrixExponentiation(unittest.TestCase): def test_matrix_exponentiation(self): matrix = np.array([[1, 2], [3, 4]]) exponent = 2 result = matrix_exponentiation(matrix, exponent) expected = np.array([[7, 10], [15, 22]]) np.testing.assert_array_equal(result, expected) def test_zero_exponent(self): matrix = np.array([[1, 2], [3, 4]]) exponent = 0 result = matrix_exponentiation(matrix, exponent) expected = np.eye(2) np.testing.assert_array_equal(result, expected) def test_identity_matrix(self): matrix = np.eye(3) exponent = 5 result = matrix_exponentiation(matrix, exponent) expected = np.eye(3) np.testing.assert_array_equal(result, expected) def test_non_square_matrix(self): matrix = np.array([[1, 2, 3], [4, 5, 6]]) exponent = 2 with self.assertRaises(ValueError): matrix_exponentiation(matrix, exponent) if __name__ == \'__main__\': unittest.main() ```","solution":"import numpy as np def matrix_exponentiation(matrix: np.ndarray, exponent: int) -> np.ndarray: if not isinstance(matrix, np.ndarray) or len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input must be a square matrix.\\") if exponent < 0: raise ValueError(\\"The exponent must be a non-negative integer.\\") n = matrix.shape[0] def matrix_multiply(A, B): return np.dot(A, B) def identity_matrix(size): return np.eye(size) def matrix_pow(matrix, exp): if exp == 0: return identity_matrix(n) elif exp == 1: return matrix else: half_pow = matrix_pow(matrix, exp // 2) half_pow_squared = matrix_multiply(half_pow, half_pow) if exp % 2 == 0: return half_pow_squared else: return matrix_multiply(half_pow_squared, matrix) return matrix_pow(matrix, exponent)"},{"question":"# Coding Question: Circular Motion Analysis Tool **Context**: You are developing a physics education tool that helps students understand circular motion. Given the radius of the circular path and the angular velocity of an object, you need to calculate three values: 1. The linear velocity of the object. 2. The centripetal acceleration of the object. 3. The period of revolution for the object. To achieve this, you\'ll utilize fundamental physics equations for circular motion. **Task**: Implement three functions: 1. `linear_velocity(radius: float, angular_velocity: float) -> float` 2. `centripetal_acceleration(radius: float, angular_velocity: float) -> float` 3. `period_of_revolution(angular_velocity: float) -> float` These functions should validate the inputs and perform the required calculations based on the provided formulas. **Constraints**: - Radius (`radius`) must be a positive number. - Angular velocity (`angular_velocity`) must be a positive number. - Values must be rounded to two decimal places. **Formulas**: - Linear velocity: [ text{linear_velocity} = r cdot omega ] - Centripetal acceleration: [ text{acceleration} = r cdot omega^2 ] - Period of revolution: [ text{period} = frac{2pi}{omega} ] Here, ( r ) is the radius, and ( omega ) is the angular velocity. **Input/Output**: - **Input**: Two float numbers representing the radius and angular velocity. - **Output**: Three float numbers representing linear velocity, centripetal acceleration, and period of revolution respectively. **Examples**: ```python assert linear_velocity(10, 2) == 20.00 assert centripetal_acceleration(10, 2) == 40.00 assert period_of_revolution(2) == 3.14 assert linear_velocity(5, 3) == 15.00 assert centripetal_acceleration(5, 3) == 45.00 assert period_of_revolution(3) == 2.09 ``` Write the functions based on the provided formulas and constraints, ensuring to handle invalid inputs appropriately.","solution":"import math def linear_velocity(radius: float, angular_velocity: float) -> float: if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") if angular_velocity <= 0: raise ValueError(\\"Angular velocity must be a positive number\\") return round(radius * angular_velocity, 2) def centripetal_acceleration(radius: float, angular_velocity: float) -> float: if radius <= 0: raise ValueError(\\"Radius must be a positive number\\") if angular_velocity <= 0: raise ValueError(\\"Angular velocity must be a positive number\\") return round(radius * angular_velocity ** 2, 2) def period_of_revolution(angular_velocity: float) -> float: if angular_velocity <= 0: raise ValueError(\\"Angular velocity must be a positive number\\") return round(2 * math.pi / angular_velocity, 2)"},{"question":"# Coding Question on Array Manipulation and Dynamic Programming Context Array manipulation problems often require dynamic programming techniques to achieve efficient computations. You are tasked with developing a function that finds the maximum sum of non-adjacent elements in an array. Problem Design a function `max_non_adjacent_sum(arr)`, where `arr` is a list of integers. The function should calculate the maximum sum of non-adjacent elements, ensuring no two elements contributing to the sum are directly next to each other in the array. Requirements To achieve this: 1. Use dynamic programming to iterate through the array while maintaining the maximum sum up to the current index, considering non-adjacency constraints. 2. Optimize space by utilizing two variables to store the maximum sums up to previous indices. 3. Ensure the function works efficiently even for larger arrays. Input and Output * **Input**: - A list of integers `arr` of length `n` (e.g., `[3, 2, 5, 10, 7]`). * **Output**: - An integer representing the maximum sum of non-adjacent elements in the array. Implementation Constraints * Optimize for performance with linear time complexity O(n) and constant space complexity O(1). * Ensure the function handles potential edge cases, such as all negative numbers in the array or an empty array. Example ```python def max_non_adjacent_sum(arr): # Your code here # Example: print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Expected output: 15 print(max_non_adjacent_sum([-2, -1, -3, -4])) # Expected output: 0 (since no selection is better than negative sum) ``` You are required to provide a function definition for `max_non_adjacent_sum(arr)` and ensure it accurately produces the expected output for the example cases. Use dynamic programming techniques to maintain efficiency and handle edge cases appropriately.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the array. if not arr: return 0 incl = 0 # Stores the maximum sum including the current element excl = 0 # Stores the maximum sum excluding the current element for num in arr: # Current max excluding i new_excl = max(incl, excl) # Current max including i incl = excl + num excl = new_excl # Return max of incl and excl return max(incl, excl)"},{"question":"# Coding Question: Product of Array Except Self You are given an array of integers `nums` where the length of the array is `n`. Your task is to write a function `product_except_self` that returns an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must solve it without using division and in O(n) time complexity. # Input - The input array `nums` which is a list of integers. # Output - A list of integers `answer` where `answer[i]` represents the product of all elements in `nums` except `nums[i]`. # Constraints - The length of `nums` will be in the range `[2, 10^5]`. - Each element of `nums` will be in the range `[-30, 30]`. - There will be at least one non-zero element in `nums`. # Example: ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] ``` # Note: For the given input `nums = [1, 2, 3, 4]`, your function should return `[24, 12, 8, 6]` as `24 = 2*3*4`, `12 = 1*3*4`, `8 = 1*2*4`, and `6 = 1*2*3`.","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the input array except itself. n = len(nums) answer = [1] * n left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"In this exercise, you are asked to implement a word frequency analyzer that processes a given text and counts the occurrences of each unique word, ignoring case and punctuation. # Function to Implement 1. **sanitize_text**: This function should remove punctuation and convert all letters to lowercase. 2. **word_frequency**: Count the frequency of each word in the sanitized text. 3. **most_common_words**: Return a list of tuples containing the most common words and their frequencies, in descending order of frequency. # Input and Output * **Input**: - A text string containing a mix of uppercase and lowercase letters, spaces, punctuation, and possibly newline characters. * **Output**: - For **word_frequency**: A dictionary where keys are words and values are their respective frequencies. - For **most_common_words**: A list of tuples, each tuple containing a word and its frequency, sorted by frequency in descending order. # Constraints * The text length will be at most 10^5 characters. * Words are sequences of letters and can appear more than once in the text. # Example ```python def sanitize_text(text: str) -> str: pass def word_frequency(text: str) -> dict: pass def most_common_words(text: str, n: int) -> list: pass # Example usage: text = \\"Hello, world! Hello everyone. This is a simple text, with punctuation.\\" sanitized = sanitize_text(text) word_freq = word_frequency(sanitized) print(word_freq) # Example Output: {\'hello\': 2, \'world\': 1, \'everyone\': 1, \'this\': 1, \'is\': 1, \'a\': 1, \'simple\': 1, \'text\': 1, \'with\': 1, \'punctuation\': 1} most_common = most_common_words(sanitized, 3) print(most_common) # Example Output: [(\'hello\', 2), (\'world\', 1), (\'everyone\', 1)] ``` # Requirements 1. The `sanitize_text` function should handle spaces, punctuation, and proper casing. 2. The `word_frequency` function must count each unique word correctly. 3. The `most_common_words` function should return the most frequently occurring words in the correct order as specified.","solution":"import re from collections import Counter def sanitize_text(text: str) -> str: Remove punctuation from the text and convert it to lowercase. # Convert to lowercase text = text.lower() # Remove punctuation using regex sanitized = re.sub(r\'[^ws]\', \'\', text) return sanitized def word_frequency(text: str) -> dict: Count the frequency of each word in the sanitized text. words = text.split() frequency = Counter(words) return dict(frequency) def most_common_words(text: str, n: int) -> list: Return the n most common words in the sanitized text. frequency = word_frequency(text) most_common = Counter(frequency).most_common(n) return most_common # Example usage: # text = \\"Hello, world! Hello everyone. This is a simple text, with punctuation.\\" # sanitized = sanitize_text(text) # word_freq = word_frequency(sanitized) # print(word_freq) # most_common = most_common_words(sanitized, 3) # print(most_common)"},{"question":"# Coding Challenge Problem Statement You are given an integer array `arr` and an integer `k`. Your task is to write a function `find_pairs_with_sum` that returns the number of unique pairs (a, b) in the array such that their sum is equal to `k`. Each pair should be counted only once, and you should not count reversed pairs separately (e.g., (a, b) and (b, a) are considered the same). The function should accept two parameters: - `arr`: The list of integers. - `k`: The target sum for the pairs. Function Signature ```python def find_pairs_with_sum(arr: list[int], k: int) -> int: pass ``` Input - `arr` (list[int]): A list of integers (0 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6). - `k` (int): The target sum for the pairs (-10^6 <= k <= 10^6). Output - Returns an integer representing the number of unique pairs that sum up to `k`. Example ```python print(find_pairs_with_sum([1, 2, 3, 4, 3], 6)) # Output: 2 (Pairs: (2, 4), (3, 3)) print(find_pairs_with_sum([1, 1, 1, 1], 2)) # Output: 1 (Pair: (1, 1)) print(find_pairs_with_sum([-1, -2, 3, 7], 6)) # Output: 1 (Pair: (-1, 7)) ``` Constraints - Ensure that your solution is optimized for large input sizes (up to length 10^4). - Consider edge cases such as empty arrays or when no pairs sum up to `k`. Notes - Pairs (a, b) and (b, a) should be considered the same and counted only once. - Ensure that pairs are formed by using unique elements from the array -- do not count duplicates. - You may assume all input is valid and conforms to the problem constraints.","solution":"def find_pairs_with_sum(arr: list[int], k: int) -> int: Returns the number of unique pairs in the array such that their sum is equal to k. seen = set() pairs = set() for number in arr: target = k - number if target in seen: pairs.add((min(number, target), max(number, target))) seen.add(number) return len(pairs)"},{"question":"# Coding Question: Polynomial Addition and Multiplication Your task is to implement a class `Polynomial` that can handle basic polynomial operations, such as addition and multiplication. Each polynomial will be represented as a list of coefficients starting from the constant term. You will implement: - A method `add(other)` to add two polynomials. - A method `multiply(other)` to multiply two polynomials. - A method `__str__()` to return the polynomial as a formatted string. Class: ```python class Polynomial: def __init__(self, coefficients: list): # Initializes the polynomial with the given coefficients. def add(self, other: \'Polynomial\') -> \'Polynomial\': # Adds two polynomials and returns a new polynomial. def multiply(self, other: \'Polynomial\') -> \'Polynomial\': # Multiplies two polynomials and returns a new polynomial. def __str__(self) -> str: # Returns the polynomial as a formatted string. ``` Input: * The `__init__` constructor will take a list of integers `coefficients` representing the polynomial. * The `add` and `multiply` methods will each take another `Polynomial` object. * The polynomials will have at least one term and will only contain integer coefficients. Output: * The `add` method should return a new `Polynomial` object representing the sum. * The `multiply` method should return a new `Polynomial` object representing the product. * The `__str__` method should return a string representation of the polynomial in standard form. Example: ```python p1 = Polynomial([1, 2, 3]) # Represents 1 + 2x + 3x^2 p2 = Polynomial([3, 4]) # Represents 3 + 4x >>> print(p1) 1 + 2x + 3x^2 >>> print(p2) 3 + 4x >>> p3 = p1.add(p2) >>> print(p3) 4 + 6x + 3x^2 >>> p4 = p1.multiply(p2) >>> print(p4) 3 + 10x + 17x^2 + 12x^3 ``` # Notes: * Ensure the class correctly handles polynomials of different lengths. * The `__str__()` method should format the polynomial as a human-readable string, considering edge cases like coefficients of zero. * Add appropriate error checking and edge case handling.","solution":"class Polynomial: def __init__(self, coefficients: list): self.coefficients = coefficients def add(self, other: \'Polynomial\') -> \'Polynomial\': max_len = max(len(self.coefficients), len(other.coefficients)) # Extend shorter list with zeros new_coeffs = [0] * max_len for i in range(max_len): if i < len(self.coefficients): new_coeffs[i] += self.coefficients[i] if i < len(other.coefficients): new_coeffs[i] += other.coefficients[i] return Polynomial(new_coeffs) def multiply(self, other: \'Polynomial\') -> \'Polynomial\': result_len = len(self.coefficients) + len(other.coefficients) - 1 new_coeffs = [0] * result_len for i in range(len(self.coefficients)): for j in range(len(other.coefficients)): new_coeffs[i + j] += self.coefficients[i] * other.coefficients[j] return Polynomial(new_coeffs) def __str__(self) -> str: terms = [] for i, coef in enumerate(self.coefficients): if coef != 0: if i == 0: terms.append(f\\"{coef}\\") else: terms.append(f\\"{coef}x^{i}\\" if i > 1 else f\\"{coef}x\\") return \\" + \\".join(terms) if terms else \\"0\\""},{"question":"# Context You have been hired as a software engineer at a tech company. The company requires you to implement functionality for compressing strings, which will help reduce the amount of data stored in their databases. You need to use a basic form of run-length encoding (RLE) for this compression task. # Problem Statement Create a function `rle_compress` which takes a single argument: 1. `input_str`: a string that needs to be compressed. The function should return the compressed version of the string, where consecutive occurrences of the same character are replaced by the character followed by the number of occurrences. # Input - `input_str`: A string comprised of only uppercase and lowercase alphabets (A-Z, a-z). The length of `input_str` will be between `1` and `1000`. # Output - Returns a string representing the run-length encoded version of `input_str`. # Constraints Ensure your function efficiently handles edge cases, including: - Single-character strings. - Strings with no consecutive repeated characters. - Strings where all characters are the same. - Mixed case strings. # Example ```python input_str = \\"aaabbbbcc\\" rle_compress(input_str) # Expected Output: \\"a3b4c2\\" ``` # Notes - If the compressed string is longer than the original, return the original string. - Handle repeated characters carefully to ensure correctness of the encoded string. - Test your implementation with various cases to ensure it performs as expected.","solution":"def rle_compress(input_str): Compresses the input string using run-length encoding. If the compressed string is longer than the original, returns the original string. Parameters: input_str (str): The string to be compressed. Returns: str: The compressed string or the original string if compression is not efficient. if not input_str: return input_str compressed = [] count = 1 prev_char = input_str[0] for char in input_str[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(input_str) else input_str"},{"question":"# Container Loading Optimization You are given `N` containers, each of varying capacities, and a set of `M` items, each with a specific weight. Your task is to determine the maximum number of items that can be loaded into the containers such that no container is overloaded. # Input Format: * Integer `N`: The number of containers (1 <= N <= 100). * List of integers `capacities`: A list of `N` integers where each integer represents the capacity of a container (1 <= capacities[i] <= 1000). * Integer `M`: The number of items (1 <= M <= 100). * List of integers `weights`: A list of `M` integers where each integer represents the weight of an item (1 <= weights[i] <= 1000). # Output Format: * Integer: The maximum number of items that can be loaded into the containers without exceeding any container\'s capacity. # Constraints: * A container can hold multiple items as long as the total weight of items does not exceed the container\'s capacity. # Example: Input: ``` 3 [10, 15, 7] 5 [5, 7, 3, 9, 2] ``` Output: ``` 4 ``` Explanation: You can fit items with weights 5, 3, and 2 into the first container (total weight 10), item with weight 7 into the second container (total weight 7), and none into the third container. This results in 4 items loaded without exceeding any container\'s capacity. # Function Signature: ```python def max_items_loaded(N: int, capacities: list[int], M: int, weights: list[int]) -> int: # Your implementation here pass ``` **Hint**: Consider using a greedy approach to fit the heaviest items into containers with sufficient remaining capacity. Alternatively, this problem can also be approached using dynamic programming techniques to evaluate the optimal distribution of weights into containers.","solution":"def max_items_loaded(N: int, capacities: list[int], M: int, weights: list[int]) -> int: # Sort the capacities of containers and weights of items in ascending order capacities.sort() weights.sort() # Initialize a list to keep track of remaining capacities remaining_capacities = capacities[:] # Initialize the count of loaded items loaded_items = 0 # Iterate over each item for weight in weights: for i in range(N): if remaining_capacities[i] >= weight: remaining_capacities[i] -= weight loaded_items += 1 break return loaded_items"},{"question":"**Word Ladder Transformation** You are provided with an implementation of the word ladder algorithm. The goal is to find the shortest transformation sequence from a start word to an end word, given a dictionary of intermediate words. Each transformation must change exactly one character at a time, and the new word must be a valid word in the dictionary. **Task**: Implement the algorithm to find the shortest transformation sequence from the start word to the end word. **Function Signature**: ```python def word_ladder(beginWord: str, endWord: str, wordList: list) -> int: Finds the length of the shortest transformation sequence from beginWord to endWord. Args: beginWord (str): The starting word. endWord (str): The target word. wordList (list): A list of valid words for the transformation. Returns: int: The length of the shortest transformation sequence, or 0 if no such sequence exists. ``` **Input/Output**: - **Input**: - A string `beginWord`. - A string `endWord`. - A list of strings `wordList`. - **Output**: An integer representing the length of the shortest transformation sequence, or 0 if no such sequence exists. **Constraints**: - All input words are of the same length. - All words contain only lowercase alphabetical characters. - The word list may contain duplicate words. - The word list size can be up to 5000. **Performance**: - Aim to ensure the implementation runs efficiently, ideally within a time complexity of O(N * M), where N is the number of words in `wordList` and M is the length of each word. **Examples**: ```python >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 >>> word_ladder(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2 >>> word_ladder(\\"aaa\\", \\"bbb\\", [\\"aab\\", \\"abb\\", \\"bbb\\"]) 4 >>> word_ladder(\\"start\\", \\"end\\", [\\"smart\\", \\"smort\\", \\"short\\", \\"shart\\", \\"end\\"]) 0 ``` **Additional Challenge**: Optimize the algorithm to handle large dictionaries efficiently. Discuss the optimization points and their impact on the algorithm\'s performance in the comments.","solution":"from collections import deque def word_ladder(beginWord: str, endWord: str, wordList: list) -> int: Finds the length of the shortest transformation sequence from beginWord to endWord. Args: beginWord (str): The starting word. endWord (str): The target word. wordList (list): A list of valid words for the transformation. Returns: int: The length of the shortest transformation sequence, or 0 if no such sequence exists. wordSet = set(wordList) if endWord not in wordSet: return 0 queue = deque([(beginWord, 1)]) alphabet = \'abcdefghijklmnopqrstuvwxyz\' while queue: current_word, length = queue.popleft() if current_word == endWord: return length for i in range(len(current_word)): for char in alphabet: next_word = current_word[:i] + char + current_word[i+1:] if next_word in wordSet: queue.append((next_word, length + 1)) wordSet.remove(next_word) return 0"},{"question":"# Coding Question Context You are enhancing a social media application that allows users to post, like, and comment on posts. Currently, the application does not support tracking trending topics based on hashtags. Your task is to implement a feature that efficiently tracks the top N trending hashtags. Task Write a function `get_trending_hashtags` that processes a list of posts and returns the top N trending hashtags. Each post is represented as a string containing text, and hashtags are denoted by words starting with the \'#\' character. Function Signature ```python def get_trending_hashtags(posts: List[str], top_n: int) -> List[str]: pass ``` Requirements 1. **Input**: * `posts` (List[str]): A list of posts where each post is a string of text. * `top_n` (int): The number of top trending hashtags to return. 2. **Output** (List[str]): A list of the top N trending hashtags. 3. **Constraints**: * Assume a hashtag consists only of alphanumeric characters and underscores after the \'#\' character. * Handle the case where `top_n` is greater than the number of unique hashtags. * If two hashtags have the same frequency, prioritize them lexicographically. Example: ```python posts = [ \\"Loving the weather today! #sunny #happy\\", \\"Just finished a 5k run #fitness #happy\\", \\"Reading a great book #books #sunny\\", \\"Exploring nature #adventure #sunny\\" ] top_n = 2 print(get_trending_hashtags(posts, top_n)) # Output: [\'#sunny\', \'#happy\'] ``` Notes: * Implement efficient parsing and counting of hashtags. * Consider edge cases, such as posts without hashtags or identical count of different hashtags. * Write clean, efficient, and well-documented code.","solution":"from typing import List from collections import Counter import re def get_trending_hashtags(posts: List[str], top_n: int) -> List[str]: Returns the top N trending hashtags from the provided list of posts. Parameters: posts (List[str]): A list of posts where each post is a string of text. top_n (int): The number of top trending hashtags to return. Returns: List[str]: A list of the top N trending hashtags. hashtag_counter = Counter() # Define a regex pattern to extract hashtags hashtag_pattern = re.compile(r\'#w+\') # Iterate through each post and find all hashtags for post in posts: hashtags = hashtag_pattern.findall(post) hashtag_counter.update(hashtags) # Sort hashtags by count (descending) and lexicographically sorted_hashtags = sorted(hashtag_counter.items(), key=lambda x: (-x[1], x[0])) # Extract only the hashtags from the sorted list and return the top N return [hashtag for hashtag, count in sorted_hashtags[:top_n]]"},{"question":"# Scenario You are working on a weather forecasting application that uses historical weather data to predict future weather conditions. One of the key tasks is to implement a function that takes a set of temperature readings and determines whether the weather trend is generally warming up, cooling down, or stable over a given period. # Task Create a function `determine_weather_trend` that: 1. Normalizes the temperature data. 2. Uses a linear regression model to predict the trend. 3. Determines whether the trend is warming, cooling, or stable based on the slope of the regression line. # Function Signature ```python def determine_weather_trend(temperatures: List[float]) -> str: ``` # Input - `temperatures`: A list of floats representing daily temperature readings over a certain period. # Output - Returns a string: \\"Warming\\" if the trend is warming up, \\"Cooling\\" if the trend is cooling down, and \\"Stable\\" if there is no significant trend. # Constraints - The list `temperatures` contains at least 10 readings. - The temperature readings are in degrees Celsius. # Performance - The solution should handle temperature lists of up to 365 readings efficiently. # Example ```python print(determine_weather_trend([22.1, 22.3, 22.5, 23.0, 23.5, 24.0, 24.3, 24.5, 24.7, 25.0])) # Output should be \\"Warming\\" print(determine_weather_trend([25.0, 24.7, 24.5, 24.3, 24.0, 23.5, 23.0, 22.5, 22.3, 22.1])) # Output should be \\"Cooling\\" print(determine_weather_trend([22.0, 22.1, 22.0, 22.1, 22.0, 22.1, 22.1, 22.0, 22.1, 22.1])) # Output should be \\"Stable\\" ``` Use the provided method signature and implement the logic within the `determine_weather_trend` function to achieve the described functionality.","solution":"from typing import List from sklearn.linear_model import LinearRegression import numpy as np def determine_weather_trend(temperatures: List[float]) -> str: Determines the weather trend based on temperature readings. Parameters: temperatures (List[float]): A list of float numbers representing temperature readings over a period. Returns: str: \\"Warming\\" if the trend is warming up, \\"Cooling\\" if cooling down, or \\"Stable\\" if no significant trend. # Creating an array for indexes (x) to fit into the linear model x = np.arange(len(temperatures)).reshape(-1, 1) # Creating array for temperature readings (y) y = np.array(temperatures) # Fitting linear regression to temperature data model = LinearRegression().fit(x, y) # Getting the slope of the regression line slope = model.coef_[0] # Based on the slope determine the trend if slope > 0.05: return \\"Warming\\" elif slope < -0.05: return \\"Cooling\\" else: return \\"Stable\\""},{"question":"# Matrix Transposition with Diagonal Elements You are required to implement a function that performs a special type of matrix transposition. This transposition involves swapping the elements at each position ((i, j)) with their corresponding ( (j, i) ) positions. However, the elements on the main diagonal (where (i = j)) should remain unchanged. # Task: Write a function `transpose_with_diagonal` that performs this matrix transposition while keeping the diagonal elements intact. Function Signature: ```python def transpose_with_diagonal(matrix): Parameters: matrix (list[list[int]]): A two-dimensional list representing a square matrix of size n x n. Returns: transposed (list[list[int]]): The transposed matrix with unchanged diagonal elements. ``` Input: * `matrix`: A two-dimensional list of integers, representing a square matrix of size (n times n). Output: * `transposed`: A two-dimensional list representing the transposed matrix, with diagonal elements remaining the same. Constraints: * (1 leq n leq 100) * Elements of the matrix are integers. # Requirements: 1. Ensure that the function handles square matrices with varying sizes efficiently. 2. Keep the main diagonal elements unchanged during the transposition. 3. The function should handle edge cases, such as 1x1 matrices and larger matrices up to 100x100 in size. # Examples: 1. **Example 1:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_with_diagonal(matrix)) # Output: [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` 2. **Example 2:** ```python matrix = [ [10, 20], [30, 40] ] print(transpose_with_diagonal(matrix)) # Output: [ # [10, 30], # [20, 40] # ] ``` 3. **Example 3:** ```python matrix = [ [42] ] print(transpose_with_diagonal(matrix)) # Output: [ # [42] # ] ``` # Notes: * You can assume that the input matrix will always be a valid square matrix with integer elements. * Implement the function in a way that is efficient in terms of both time and space complexity.","solution":"def transpose_with_diagonal(matrix): Returns the transposed matrix with unchanged diagonal elements. Parameters: matrix (list[list[int]]): A two-dimensional list representing a square matrix of size n x n. Returns: transposed (list[list[int]]): The transposed matrix with unchanged diagonal elements. n = len(matrix) transposed = [row[:] for row in matrix] # Create a deep copy of the matrix for i in range(n): for j in range(i + 1, n): # Only iterate for j > i if i != j: transposed[i][j], transposed[j][i] = transposed[j][i], transposed[i][j] return transposed"},{"question":"# Scenario You have been assigned to work on a text processing tool that minimizes repeated words in a document to save space. This tool uses a technique called Word Frequency Encoding (WFE). WFE compresses a string by recording each word and how many times it repeats consecutively. For example, the string \\"hello hello world world world\\" would be compressed to [(\'hello\', 2), (\'world\', 3)]. # Task Write two functions: 1. `word_frequency_encode(text: str) -> list` - This function should take a string and return its WFE compressed form as a list of tuples. 2. `word_frequency_decode(encoded: list) -> str` - This function should take a WFE compressed list and return the original string. # Constraints * The input string for encoding will be a sequence of words separated by spaces. * The input for decoding will always be a valid WFE encoded list of tuples. # Input and Output Formats * **Encoding Function**: * Input: A string `text`. * Output: A list of tuples, where each tuple contains a word and its consecutive count. * **Decoding Function**: * Input: A list of tuples, where each tuple consists of a word and its consecutive count. * Output: The original string. --- # Example Encoding ```python >>> word_frequency_encode(\\"hello hello world world world\\") [(\'hello\', 2), (\'world\', 3)] ``` Decoding ```python >>> word_frequency_decode([(\'hello\', 2), (\'world\', 3)]) \'hello hello world world world\' ``` # Edge Cases 1. Encoding and decoding with an empty string: ```python >>> word_frequency_encode(\\"\\") [] >>> word_frequency_decode([]) \\"\\" ``` 2. Encoding and decoding with no repeated words: ```python >>> word_frequency_encode(\\"one two three four\\") [(\'one\', 1), (\'two\', 1), (\'three\', 1), (\'four\', 1)] >>> word_frequency_decode([(\'one\', 1), (\'two\', 1), (\'three\', 1), (\'four\', 1)]) \'one two three four\' ``` Ensure both functions handle these scenarios correctly.","solution":"def word_frequency_encode(text): Encode a string using Word Frequency Encoding. Args: text (str): The input string to be encoded. Returns: list: A list of tuples where each tuple contains a word and its consecutive count. if not text: return [] words = text.split() result = [] current_word = words[0] count = 1 for i in range(1, len(words)): if words[i] == current_word: count += 1 else: result.append((current_word, count)) current_word = words[i] count = 1 result.append((current_word, count)) return result def word_frequency_decode(encoded): Decode a list using Word Frequency Encoding into the original string. Args: encoded (list): A list of tuples where each tuple contains a word and its consecutive count. Returns: str: The original string. result = [] for word, count in encoded: result.extend([word] * count) return \' \'.join(result)"},{"question":"Sorting and Searching in Rotated Sorted Array # Objective Implement a Python function to search for a target value within a rotated sorted array. You are required to write a search function that handles the rotated aspect of the array efficiently. # Description You are given a sorted array that has been rotated at an unknown pivot. The task is to find the index of a target value within this array. # Requirements 1. Implement the `search_rotated_array` function that takes a rotated sorted array and a target value. The function should return the index of the target value if it exists in the array; otherwise, return `-1`. # Input - `arr` (list[int]): The rotated sorted array. - `target` (int): The target value to search for. # Output - The index of the target value if found; otherwise, `-1`. # Constraints 1. `1 <= len(arr) <= 10^4` 2. `-10^4 <= arr[i], target <= 10^4` 3. Assume no duplicates in the array. # Example ```python def search_rotated_array(arr: list[int], target: int) -> int: # Your implementation here pass # Example usage: arr = [4, 5, 6, 7, 0, 1, 2, 3] target = 1 index = search_rotated_array(arr, target) print(index) # Output should be 5 target = 8 index = search_rotated_array(arr, target) print(index) # Output should be -1 ``` # Explanation of Example - In the first example, the rotated sorted array is `[4, 5, 6, 7, 0, 1, 2, 3]`, and the target `1` is found at index `5`. - In the second example, the target `8` is not present in the array, so the function returns `-1`. * Ensure you handle edge cases and validate inputs where necessary. * Optimize for performance using an efficient searching algorithm. This question assesses the candidate\'s ability to implement searching algorithms for specialized cases, such as rotated sorted arrays.","solution":"def search_rotated_array(arr, target): Searches for a target value in a rotated sorted array. Returns the index if found; otherwise, returns -1. Parameters: - arr (list[int]): The rotated sorted array. - target (int): The target value to search for. Returns: int: The index of the target value if found; otherwise, -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is properly sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Design and implement a simple text editor that supports undo and redo operations. You are required to write two classes: `SimpleEditor` and `Operation`. The `SimpleEditor` class should have the following methods: 1. `insert(char: str)`: Inserts a single character at the end of the text. 2. `delete()`: Deletes the last character of the text. 3. `undo()`: Undoes the last operation (insert or delete). 4. `redo()`: Redoes the last undone operation. The `Operation` class should encapsulate the details of an operation (either insert or delete). # Requirements 1. Use stacks to manage the operations for efficient undo and redo. 2. Ensure the `undo` and `redo` methods handle edge cases such as no operations to undo or redo. 3. The text editor should maintain the correct state of the editor after multiple operations, undoes, and redoes. # Input and Output Format - `SimpleEditor() -> None` - `insert(char: str) -> None` - `delete() -> None` - `undo() -> None` - `redo() -> None` - `get_text() -> str`: Returns the current text in the editor. Here\'s an example of how these classes should work: ```python editor = SimpleEditor() editor.insert(\'a\') editor.insert(\'b\') assert editor.get_text() == \'ab\' editor.delete() assert editor.get_text() == \'a\' editor.undo() assert editor.get_text() == \'ab\' editor.redo() assert editor.get_text() == \'a\' editor.undo() editor.undo() assert editor.get_text() == \'\' ``` # Solution Template ```python class Operation: def __init__(self, action: str, char: str): self.action = action self.char = char class SimpleEditor: def __init__(self): self.text = [] self.undo_stack = [] self.redo_stack = [] def insert(self, char: str): self.text.append(char) self.undo_stack.append(Operation(\'insert\', char)) self.redo_stack.clear() def delete(self): if self.text: char = self.text.pop() self.undo_stack.append(Operation(\'delete\', char)) self.redo_stack.clear() def undo(self): if self.undo_stack: operation = self.undo_stack.pop() if operation.action == \'insert\': self.text.pop() elif operation.action == \'delete\': self.text.append(operation.char) self.redo_stack.append(operation) def redo(self): if self.redo_stack: operation = self.redo_stack.pop() if operation.action == \'insert\': self.text.append(operation.char) elif operation.action == \'delete\': self.text.pop() self.undo_stack.append(operation) def get_text(self) -> str: return \'\'.join(self.text) # Example usage: editor = SimpleEditor() editor.insert(\'a\') editor.insert(\'b\') assert editor.get_text() == \'ab\' editor.delete() assert editor.get_text() == \'a\' editor.undo() assert editor.get_text() == \'ab\' editor.redo() assert editor.get_text() == \'a\' editor.undo() editor.undo() assert editor.get_text() == \'\' ```","solution":"class Operation: def __init__(self, action: str, char: str): Initialize an operation with an action (insert or delete) and a character. self.action = action self.char = char class SimpleEditor: def __init__(self): Initialize the text editor with an empty text, an undo stack, and a redo stack. self.text = [] self.undo_stack = [] self.redo_stack = [] def insert(self, char: str): Insert a character at the end of the text and record the operation. self.text.append(char) self.undo_stack.append(Operation(\'insert\', char)) self.redo_stack.clear() def delete(self): Delete the last character from the text and record the operation. if self.text: char = self.text.pop() self.undo_stack.append(Operation(\'delete\', char)) self.redo_stack.clear() def undo(self): Undo the last operation (insert or delete). if self.undo_stack: operation = self.undo_stack.pop() if operation.action == \'insert\': self.text.pop() elif operation.action == \'delete\': self.text.append(operation.char) self.redo_stack.append(operation) def redo(self): Redo the last undone operation (insert or delete). if self.redo_stack: operation = self.redo_stack.pop() if operation.action == \'insert\': self.text.append(operation.char) elif operation.action == \'delete\': self.text.pop() self.undo_stack.append(operation) def get_text(self) -> str: Get the current text as a string. return \'\'.join(self.text)"},{"question":"# Problem Statement You are tasked with creating a simple in-memory cache with an expiration mechanism. The cache should store key-value pairs and each entry should expire after a specified time to live (TTL). Implement a Python class `SimpleCache` that provides basic cache operations with TTL. # Requirements 1. **Cache Operations**: Implement methods `set`, `get`, and `delete` to manage the cache. 2. **Expiration Handling**: Ensure that cache entries expire after the specified TTL (in seconds). 3. **Efficiency**: Ensure that the expiration mechanism does not significantly degrade performance. # Constraints - You can use standard Python libraries, including `time` and `threading`. - Ensure that the `get` method does not return expired entries. - Assume the maximum number of entries in the cache is 1000. # Function Signature ```python import time from threading import RLock class SimpleCache: def __init__(self): self.cache = {} self.lock = RLock() def set(self, key: str, value: any, ttl: int) -> None: # Implement this method pass def get(self, key: str) -> any: # Implement this method pass def delete(self, key: str) -> None: # Implement this method pass def _clean_expired_entries(self) -> None: # Implement this method pass if __name__ == \\"__main__\\": cache = SimpleCache() cache.set(\\"key1\\", \\"value1\\", 5) # Cache \\"key1\\" with value \\"value1\\" and TTL of 5 seconds time.sleep(3) print(cache.get(\\"key1\\")) # Output: \\"value1\\" time.sleep(3) print(cache.get(\\"key1\\")) # Output: None (expired) ``` # Expected Behavior 1. **Input**: Methods to set a cache entry with key, value, and TTL, get a cache entry by key, and delete a cache entry by key. 2. **Output**: Correct handling of TTL so that expired entries are not returned and properly managed. # Example Usage ```python cache = SimpleCache() cache.set(\\"user123\\", {\\"name\\": \\"Alice\\", \\"age\\": 30}, 10) print(cache.get(\\"user123\\")) # Output: {\\"name\\": \\"Alice\\", \\"age\\": 30} time.sleep(10) print(cache.get(\\"user123\\")) # Output: None (expired) ``` Ensure the `SimpleCache` class correctly handles cache operations and expiration of entries.","solution":"import time from threading import RLock class SimpleCache: def __init__(self): self.cache = {} self.lock = RLock() def set(self, key: str, value: any, ttl: int) -> None: with self.lock: expire_at = time.time() + ttl self.cache[key] = (value, expire_at) def get(self, key: str) -> any: with self.lock: value, expire_at = self.cache.get(key, (None, None)) if expire_at and expire_at > time.time(): return value elif key in self.cache: del self.cache[key] return None def delete(self, key: str) -> None: with self.lock: if key in self.cache: del self.cache[key] def _clean_expired_entries(self) -> None: with self.lock: keys_to_delete = [key for key, (_, expire_at) in self.cache.items() if expire_at <= time.time()] for key in keys_to_delete: del self.cache[key]"},{"question":"# Problem Statement As part of a network optimization program, you are required to write a function that calculates the shortest path between two nodes in an unweighted, undirected graph using the Breadth-First Search (BFS) algorithm. # Task Design a function `shortest_path(graph: dict, start: str, end: str) -> int` that takes: - A dictionary `graph` where the keys are node identifiers (strings) and the values are lists of neighboring node identifiers. - Two strings `start` and `end` representing the start and end nodes, respectively. The function should return the length of the shortest path from the start node to the end node. If no path exists, return -1. # Input - A dictionary `graph` representing the adjacency list of an undirected graph. Each key is a string representing a node, and its value is a list of strings representing adjacent nodes. - A string `start` indicating the start node. - A string `end` indicating the end node. # Output - An integer representing the length of the shortest path from the start node to the end node. If no path exists, return -1. # Constraints - The graph will have at least 1 and at most 1000 nodes. - Each node identifier is a non-empty string containing only alphanumeric characters. - The length of the adjacency list for any node does not exceed 1000. - `start` and `end` will always be valid nodes within the graph. # Example ```python >>> graph = { ... \'A\': [\'B\', \'C\'], ... \'B\': [\'A\', \'D\', \'E\'], ... \'C\': [\'A\', \'F\'], ... \'D\': [\'B\'], ... \'E\': [\'B\', \'F\'], ... \'F\': [\'C\', \'E\'], ... } >>> shortest_path(graph, \'A\', \'F\') 2 >>> shortest_path(graph, \'A\', \'D\') 2 >>> shortest_path(graph, \'A\', \'G\') -1 >>> shortest_path(graph, \'A\', \'A\') 0 ``` # Detailed Requirements 1. The function should utilize the BFS algorithm to explore the graph and find the shortest path. 2. If the start and end nodes are the same, return 0, as no edges need to be traversed. 3. If no path exists between the start and end nodes, return -1. 4. Ensure the solution is efficient in both time and space, adhering to the given constraints. # Instructions 1. Implement and test the function to ensure it meets all the requirements. 2. Validate the graph structure and handle possible edge cases, such as the start node being the same as the end node or the presence of isolated nodes with no edges.","solution":"from collections import deque def shortest_path(graph, start, end): Returns the length of the shortest path from the start node to the end node in an unweighted, undirected graph. If no path exists, return -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) # (current_node, current_distance) while queue: current_node, current_distance = queue.popleft() if current_node == end: return current_distance visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, current_distance + 1)) visited.add(neighbor) return -1"},{"question":"# Maximum Sum Submatrix of a Fixed Size Problem Description: Given a 2D array of integers and a fixed submatrix size, your task is to find the maximum sum of any submatrix with the given dimensions. The submatrix must be fully contained within the bounds of the original matrix. # Input: - An integer `n` (1 ≤ `n` ≤ 100), which represents the number of rows in the matrix. - An integer `m` (1 ≤ `m` ≤ 100), which represents the number of columns in the matrix. - An integer `a` (1 ≤ `a` ≤ n), which represents the number of rows in the submatrix. - An integer `b` (1 ≤ `b` ≤ m), which represents the number of columns in the submatrix. - A 2D list `matrix` consisting of `n` rows and `m` columns, which contains integers. # Output: - An integer representing the maximum sum of any submatrix of size `a` x `b`. # Function Signature: ```python def max_sum_submatrix(n: int, m: int, a: int, b: int, matrix: List[List[int]]) -> int: pass ``` # Constraints: - The matrix will contain integers which can be both positive and negative. # Example: ```python n = 4 m = 5 a = 2 b = 2 matrix = [ [1, -2, 3, 4, 5], [-7, 8, 9, -10, 11], [12, -13, 14, 15, 16], [-17, 18, 19, 20, -21] ] max_sum_submatrix(n, m, a, b, matrix) # Output: 54 # The submatrix with the maximum sum is: # 14 15 # 19 20 # Sum of this submatrix is: 14 + 15 + 19 + 20 = 68 ``` # Implementation Details: 1. Iterate through possible positions for the top-left corner of the submatrix. 2. For each position, calculate the sum of the submatrix starting from that position. 3. Keep track of the maximum sum encountered during these iterations. 4. Return the maximum sum at the end of the iterations. Good luck!","solution":"from typing import List def max_sum_submatrix(n: int, m: int, a: int, b: int, matrix: List[List[int]]) -> int: max_sum = float(\'-inf\') # Create a prefix sum array prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Fill the prefix sum array for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = ( matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) # Calculate the maximum sum of a submatrix of size a x b for i in range(a, n + 1): for j in range(b, m + 1): current_sum = ( prefix_sum[i][j] - prefix_sum[i-a][j] - prefix_sum[i][j-b] + prefix_sum[i-a][j-b] ) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Scenario You have been hired by a tech company that specializes in computer graphics. Your first task is to streamline some of the geometry calculations performed in their rendering engine. One core function needed is to determine if a point lies inside a given triangle in a 2D space. # Coding Task Implement a function `is_point_in_triangle` that determines if a given point (x, y) lies inside the triangle formed by three vertices (x1, y1), (x2, y2), and (x3, y3) on a 2D plane. Use the area method to come to a conclusion. Special cases, such as points lying on the edges or vertices of the triangle, should be considered inside. # Constraints 1. **Inputs**: - `x`, `y`: Coordinates of the point to check. - `x1`, `y1`, `x2`, `y2`, `x3`, `y3`: Coordinates of the vertices of the triangle. 2. **Outputs**: - Return `True` if the point is inside or on the edges of the triangle. - Return `False` otherwise. # Example ```python def is_point_in_triangle(x: float, y: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> bool: # implementation required here assert is_point_in_triangle(0, 0, 0, 0, 5, 0, 0, 5) == True assert is_point_in_triangle(3, 3, 0, 0, 5, 0, 0, 5) == False assert is_point_in_triangle(1, 1, 0, 0, 5, 0, 0, 5) == True assert is_point_in_triangle(2.5, 2.5, 0, 0, 5, 0, 0, 5) == False ``` # Additional Requirements 1. **Geometric robustness**: Ensure the function accurately handles edge cases where the point lies on a vertex or an edge of the triangle. 2. Consider numerical precision issues, especially with floating-point arithmetic, and handle them appropriately.","solution":"def is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3): Determine if point (x, y) lies inside the triangle formed by (x1, y1), (x2, y2), and (x3, y3). def area(x1, y1, x2, y2, x3, y3): return abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0) # Calculate area of the triangle ABC A = area(x1, y1, x2, y2, x3, y3) # Calculate area of the triangle PAB A1 = area(x, y, x1, y1, x2, y2) # Calculate area of the triangle PBC A2 = area(x, y, x2, y2, x3, y3) # Calculate area of the triangle PAC A3 = area(x, y, x1, y1, x3, y3) # Check if sum of A1, A2 and A3 is same as A return A == A1 + A2 + A3"},{"question":"# Problem Statement You are required to implement a Binary Search Tree (BST) with additional functionality to find the kth smallest element in the tree. The BST should support the standard operations of insertion, search, and deletion of nodes, and the additional operation to retrieve the kth smallest element. The BST should be implemented such that all operations maintain optimal performance characteristics. Requirements 1. **`insert(key: int) -> None`**: * Insert a new key into the BST. * Ensure the properties of the BST are maintained after insertion. 2. **`search(key: int) -> bool`**: * Search for a key in the BST. * Return `True` if the key is found, `False` otherwise. 3. **`delete(key: int) -> None`**: * Delete a key from the BST. * Ensure the properties of the BST are maintained after deletion. 4. **`kth_smallest(k: int) -> int`**: * Find and return the kth smallest element in the BST. * If k is out of the valid range, return `None`. Constraints * Each function should maintain the properties of the BST correctly. * Keys are guaranteed to be unique integers. * Consider edge cases such as searching for non-existent keys, deleting keys not present in the BST, and finding the kth smallest element in an empty or sparsely populated tree. Example ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.size = 1 # Number of nodes in the subtree rooted at this node class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): # Implement the insertion method. def search(self, key): # Implement the search method. def delete(self, key): # Implement the deletion method. def kth_smallest(self, k): # Implement the kth smallest element retrieval method. ``` Testing * Create a BST and perform a series of insertions, ensuring the tree structure is maintained. * Construct test cases to search both present and non-present keys. * Delete keys and verify that the BST properties and remaining elements\' integrity are maintained. * Test the kth smallest retrieval with various values of k, including out-of-bounds scenarios. * Ensure the operations handle edge cases such as an empty tree or a single-node tree.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.size = 1 # Number of nodes in the subtree rooted at this node class BinarySearchTree: def __init__(self): self.root = None def _update_size(self, node): if node: node.size = 1 + (node.left.size if node.left else 0) + (node.right.size if node.right else 0) def _insert(self, node, key): if node is None: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) self._update_size(node) return node def insert(self, key): self.root = self._insert(self.root, key) def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def search(self, key): return self._search(self.root, key) def _find_min(self, node): while node.left is not None: node = node.left return node def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_node = self._find_min(node.right) node.key = min_node.key node.right = self._delete(node.right, min_node.key) self._update_size(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _kth_smallest(self, node, k): if node is None: return None left_size = node.left.size if node.left else 0 if k <= left_size: return self._kth_smallest(node.left, k) elif k == left_size + 1: return node.key else: return self._kth_smallest(node.right, k - left_size - 1) def kth_smallest(self, k): return self._kth_smallest(self.root, k)"},{"question":"# Median Smoothing **Context**: You are developing an image processing tool that includes noise reduction features. One commonly used technique for reducing noise in images is median smoothing. Median smoothing replaces each pixel\'s value with the median value of the pixels in its neighborhood. **Task**: Implement the `median_smooth` function that takes a grayscale PIL image object and applies median smoothing to it. The function should use a 3x3 kernel for neighborhood calculation. # Function Signature: ```python def median_smooth(image: Image) -> Image: image: is a grayscale PIL image object returns: the smoothed image using median smoothing with a 3x3 kernel ``` # Constraints: 1. The input image is guaranteed to be non-empty and in grayscale. 2. The borders of the image should be handled by replicating the border pixels. 3. The function should create a new image for the smoothed output and avoid modifying the input image in place. # Expected Input/Output: - **Input**: A grayscale PIL image object. - **Output**: A grayscale PIL image object with median smoothing applied. **Example**: ```python from PIL import Image import numpy as np # Creating a mock grayscale image using numpy image_data = np.random.randint(0, 256, (10, 10), dtype=np.uint8) image = Image.fromarray(image_data, \'L\') # Applying median_smooth output_image = median_smooth(image) # Output image will be a median smoothed version of the input image ``` # Additional Notes: - Make sure your code handles edge cases, such as images with uniform pixel values. - Consider any possible optimizations to enhance the efficiency of your algorithm. - The algorithm should handle the border case by replicating the neighboring border pixels. This new question maintains the style, complexity, scope, and context of the original question, providing a consistent experience while addressing a different but related image processing technique.","solution":"from PIL import Image import numpy as np def median_smooth(image: Image) -> Image: Apply median smoothing using a 3x3 kernel to a grayscale image. Parameters: image (Image): A grayscale PIL image object. Returns: Image: A new PIL image with median smoothing applied. image_array = np.array(image) padded_image = np.pad(image_array, ((1, 1), (1, 1)), mode=\'edge\') smoothed_image = np.zeros(image_array.shape, dtype=np.uint8) for i in range(1, padded_image.shape[0] - 1): for j in range(1, padded_image.shape[1] - 1): window = padded_image[i-1:i+2, j-1:j+2] smoothed_image[i-1, j-1] = np.median(window) return Image.fromarray(smoothed_image)"},{"question":"# Genetic Algorithm Optimization Context You are tasked with implementing and enhancing a Genetic Algorithm (GA) to solve optimization problems. This assessment will verify your understanding of components such as selection, crossover, mutation, and overall GA workflow. Task 1. **Implement and Enhance Selection Methods**: - Add support for Tournament selection and Rank-Based selection in addition to the provided Roulette Wheel selection. - Ensure these methods are correctly integrated into the GA loop. 2. **Implement Crossover and Mutation**: - Implement Single-Point and Two-Point crossover methods. - Implement Mutation with a configurable probability and mutation strategy (e.g., bit flip for binary genomes, gaussian noise for real-valued genomes). Expected Function Implementation 1. **Selection Methods (Tournament, Rank-Based)**: ```python def tournament_selection(population: List, fitness: List, k: int) -> List: # Your code here def rank_based_selection(population: List, fitness: List) -> List: # Your code here ``` 2. **Crossover (Single-Point, Two-Point)**: ```python def single_point_crossover(parent1: List, parent2: List) -> (List, List): # Your code here def two_point_crossover(parent1: List, parent2: List) -> (List, List): # Your code here ``` 3. **Mutation**: ```python def mutation(individual: List, mutation_prob: float) -> List: # Your code here ``` 4. **Integration and GA Workflow**: - Ensure your functions integrate seamlessly into the GA process involving an initial population, selection, crossover, mutation, and generation of successive populations. Input and Output **Input**: - Initial population as a list of genomes (each genome is a list of values) - Number of generations (integer) - Population size (integer) - Crossover rate (float) - Mutation probability (float) - Fitness function (callable) **Output**: - Best solution obtained (genome with the highest fitness score) Constraints - Population should only be valid lists of genomes. - The number of generations should be a positive integer. - Population size should be a positive integer. - Crossover rate and mutation probability should be between 0 and 1. - Fitness function should be callable. Scenario Implement the required functions and modifications, integrate them into a GA framework to optimize a sample fitness function (e.g., a function with a known global maximum), and validate that the GA identifies the optimal solution correctly. --- This new question maintains the assessment\'s style, complexity, and scope, focusing on another crucial area of machine learning and optimization.","solution":"import random from typing import List, Callable, Tuple # Selection Methods def tournament_selection(population: List, fitness: List, k: int) -> List: selected = [] for _ in range(len(population)): tournament = random.sample(list(zip(population, fitness)), k) winner = max(tournament, key=lambda x: x[1]) selected.append(winner[0]) return selected def rank_based_selection(population: List, fitness: List) -> List: sorted_population = [p for p, f in sorted(zip(population, fitness), key=lambda x: x[1])] ranks = [i+1 for i in range(len(sorted_population))] total_rank = sum(ranks) probabilities = [rank/total_rank for rank in ranks] selected = random.choices(sorted_population, weights=probabilities, k=len(population)) return selected # Crossover Methods def single_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: point = random.randint(1, len(parent1) - 1) child1 = parent1[:point] + parent2[point:] child2 = parent2[:point] + parent1[point:] return child1, child2 def two_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: point1, point2 = sorted(random.sample(range(1, len(parent1)), 2)) child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:] child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:] return child1, child2 # Mutation Method def mutation(individual: List, mutation_prob: float) -> List: return [gene if random.random() > mutation_prob else 1 - gene for gene in individual] # Genetic Algorithm Framework def genetic_algorithm( population: List[List[int]], generations: int, population_size: int, crossover_rate: float, mutation_prob: float, fitness_func: Callable[[List[int]], float], selection_method: Callable[[List[List[int]], List[float]], List[List[int]]] = rank_based_selection, crossover_method: Callable[[List[int], List[int]], Tuple[List[int], List[int]]] = single_point_crossover ) -> List[int]: for generation in range(generations): fitness = [fitness_func(individual) for individual in population] selected_population = selection_method(population, fitness) next_population = [] while len(next_population) < population_size: if len(selected_population) >= 2: parent1, parent2 = random.sample(selected_population, 2) if random.random() < crossover_rate: offspring1, offspring2 = crossover_method(parent1, parent2) else: offspring1, offspring2 = parent1, parent2 next_population.extend([offspring1, offspring2]) else: next_population.append(selected_population[0]) next_population = [mutation(individual, mutation_prob) for individual in next_population][:population_size] population = next_population best_individual = max(population, key=fitness_func) return best_individual"},{"question":"# Scenario In web development, handling user input is crucial for creating dynamic and interactive web pages. One of the common operations is to validate email addresses entered by users to ensure they follow a standard format. # Task Write a Python function, `is_valid_email()`, that takes a string as input and returns `True` if the string is a valid email address, and `False` otherwise. A valid email address should meet the following criteria: 1. Contains exactly one \\"@\\" symbol. 2. The domain part (after \\"@\\") should contain at least one dot (\\".\\"). 3. The local part (before \\"@\\") and the domain part (after \\"@\\") should not be empty. 4. The top-level domain (the part after the last dot in the domain) should be at least 2 characters long. # Requirements 1. **Function Signature**: ```python def is_valid_email(email: str) -> bool: ``` 2. **Input**: A single string `email` representing the email address to be validated. 3. **Output**: A boolean value - `True` if the email is valid, `False` otherwise. 4. **Constraints**: * You may assume that the input is always a string. * Consider only the basic format rules mentioned above and ignore other specific rules or exceptions for simplicity. * The function should handle edge cases like missing parts or extra symbols gracefully. # Example ```python print(is_valid_email(\\"test@example.com\\")) # Output: True print(is_valid_email(\\"test.example@com\\")) # Output: False print(is_valid_email(\\"test@.com\\")) # Output: False print(is_valid_email(\\"@example.com\\")) # Output: False print(is_valid_email(\\"test@example.c\\")) # Output: False ``` # Additional Guidelines * Avoid using regular expressions for this task to ensure the solution is comprehensible and educational for beginners. * Ensure your function is efficient and includes error handling for different types of invalid formats. * Write a few test cases to validate your implementation.","solution":"def is_valid_email(email: str) -> bool: Validates if the given email address is in a valid format. :param email: A string representing the email address to be validated. :return: True if the email is valid, False otherwise. try: # Split the email into local and domain parts local, domain = email.split(\'@\') except ValueError: # If there\'s not exactly one \\"@\\" symbol, return False return False # Check if local part and domain part are not empty if not local or not domain: return False # Check if the domain part contains at least one dot \\".\\" if \'.\' not in domain: return False # Check if the top-level domain is at least 2 characters long tld = domain.split(\'.\')[-1] if len(tld) < 2: return False return True"},{"question":"# Inverse Matrix Calculation and Determinant Background Calculating the inverse of a matrix is a fundamental operation in linear algebra, used in various applications such as solving systems of linear equations, computer graphics, and optimization. The determinant of a matrix also provides valuable insights into its properties, such as whether it is invertible. Objective Implement a function to compute the inverse of a given square matrix and its determinant. Problem Statement Write a function `inverse_and_determinant` that takes a 2D numpy array representing a square matrix and returns a tuple containing the inverse of the matrix and its determinant. Function Signature ```python def inverse_and_determinant(matrix: np.ndarray) -> (np.ndarray, float): pass ``` Input * `matrix`: A 2D numpy array of shape `(n, n)`, where `n` is the dimension of the matrix. The matrix elements are floats. Output The function returns a tuple containing: 1. `inverse_matrix`: A 2D numpy array of shape `(n, n)` representing the inverse of the input matrix. 2. `determinant`: A float representing the determinant of the input matrix. Constraints * The input matrix will have a size between 2x2 and 100x100. * The determinant of the input matrix will not be zero (i.e., the matrix is always invertible). Requirements * Use numpy\'s functions to compute the determinant and inverse of the matrix. * Handle potential numerical stability issues. Performance Considerations Ensure that the solution can handle large matrices efficiently, leveraging numpy\'s optimized functionalities. Example ```python import numpy as np matrix = np.array([ [1.0, 2.0, 3.0], [0.0, 1.0, 4.0], [5.0, 6.0, 0.0] ]) inverse_matrix, determinant = inverse_and_determinant(matrix) # Example output # The inverse_matrix should be: # [ # [-24.0, 18.0, 5.0], # [20.0, -15.0, -4.0], # [-5.0, 4.0, 1.0] # ] # The determinant should be: # 1.0 ``` Notes * Validate the determinant before attempting to calculate the inverse to avoid numerical errors. * Consider edge cases where the matrix elements are very large or very small.","solution":"import numpy as np def inverse_and_determinant(matrix: np.ndarray) -> (np.ndarray, float): Computes the inverse and determinant of a given square matrix. Parameters: matrix (np.ndarray): A 2D numpy array representing a square matrix. Returns: (np.ndarray, float): A tuple containing the inverse of the matrix and its determinant. determinant = np.linalg.det(matrix) if determinant == 0: raise ValueError(\\"The matrix is not invertible because its determinant is zero.\\") inverse_matrix = np.linalg.inv(matrix) return inverse_matrix, determinant"},{"question":"# Remove Consecutive Duplicate Words Objective You are required to write a function that processes a given string by removing consecutive duplicate words. # Description Write a function `remove_consecutive_duplicates` that takes a string `sentence` and returns a new string with all consecutive duplicate words removed, preserving the order of the remaining words. # Function Signature ```python def remove_consecutive_duplicates(sentence: str) -> str: pass ``` # Input - `sentence`: A string containing words separated by single spaces. # Output - A string with all consecutive duplicate words removed. The order of the remaining words should be maintained. # Constraints - The `sentence` will contain only lowercase and uppercase alphabetical characters and spaces. - Words are separated by single spaces, and there are no leading or trailing spaces in the input. - The function should handle an empty string as input. Example Usage ```python assert remove_consecutive_duplicates(\\"hello hello world\\") == \\"hello world\\" assert remove_consecutive_duplicates(\\"this is is a test test\\") == \\"this is a test\\" assert remove_consecutive_duplicates(\\"no duplicates here\\") == \\"no duplicates here\\" assert remove_consecutive_duplicates(\\"repeat repeat repeat\\") == \\"repeat\\" assert remove_consecutive_duplicates(\\"repeat\\") == \\"repeat\\" ``` # Requirements - The function should validate the input: * Ensure `sentence` is a string. - The function should handle the edge cases gracefully: * Input string with no words. * Input string with one word only. * Input string with all words unique. * Input string with all words consecutive duplicates. - The function should raise appropriate exceptions for invalid inputs. Possible Edge Cases - `remove_consecutive_duplicates(\\"\\")` should return an empty string. - `remove_consecutive_duplicates(\\"a a a a\\")` should return `\\"a\\"`. - `remove_consecutive_duplicates(\\"test test case case case\\")` should return `\\"test case\\"`. Tips - Utilize splitting and joining methods for strings to break the sentence into words and reassemble the processed result. - Iterate through the list of words efficiently, comparing each word with the previous one to detect and remove duplicates. - Consider edge cases like an empty sentence or a sentence without any duplicates.","solution":"def remove_consecutive_duplicates(sentence: str) -> str: Removes consecutive duplicate words from the sentence. if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") words = sentence.split() if not words: return \\"\\" result = [words[0]] for i in range(1, len(words)): if words[i] != words[i - 1]: result.append(words[i]) return \\" \\".join(result)"},{"question":"# Question: Implement Iterative and Recursive Factorial Calculation You are developing a numerical computation library. Your task is to implement two functions to calculate the factorial of a non-negative integer. You will write one function using an **iterative approach** and another function using a **recursive approach**. Function Signatures 1. `def factorial_iterative(n: int) -> int` 2. `def factorial_recursive(n: int) -> int` Requirements * The iterative function should calculate the factorial using a loop. * The recursive function should calculate the factorial using recursive calls. * Both functions should raise a `ValueError` if the input is negative. * Ensure that your implementations handle the base cases correctly. Input * `n`: A non-negative integer. Example: `5` Output * Return the factorial of the input integer `n`. Constraints * The input will be a non-negative integer. * Ensure the input value is within a reasonable range to avoid excessive computation time for large values. Examples ```python # Iterative Examples assert factorial_iterative(5) == 120 assert factorial_iterative(0) == 1 assert factorial_iterative(1) == 1 try: factorial_iterative(-1) except ValueError: pass # This is expected # Recursive Examples assert factorial_recursive(5) == 120 assert factorial_recursive(0) == 1 assert factorial_recursive(1) == 1 try: factorial_recursive(-1) except ValueError: pass # This is expected ``` Constraints & Limitations * Performance should be O(n) for both functions. * Space complexity for the iterative function should be O(1), while the recursive function should take into account the call stack space. * Ensure that your implementations handle edge cases correctly and provide sufficient test cases in your documentation.","solution":"def factorial_iterative(n: int) -> int: Calculate the factorial of a non-negative integer n using an iterative approach. Raises ValueError if n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") result = 1 for i in range(2, n + 1): result *= i return result def factorial_recursive(n: int) -> int: Calculate the factorial of a non-negative integer n using a recursive approach. Raises ValueError if n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 return n * factorial_recursive(n - 1)"},{"question":"# Question: You are building a simple program to simulate a queue where elements are entered and removed based on certain rules. Your task is to implement the `Queue` data structure with the following functionalities: 1. **Queue Initialization**: Initialize the queue with optional initial elements. 2. **Enqueue Operation**: Add an element to the end of the queue. 3. **Dequeue Operation**: Remove an element from the front of the queue and return it. If the queue is empty, return `None`. 4. **Peek Operation**: Return the element at the front of the queue without removing it. If the queue is empty, return `None`. 5. **IsEmpty Operation**: Return `True` if the queue is empty, `False` otherwise. **Class Signature**: ```python class Queue: def __init__(self, elements: list = None): pass def enqueue(self, item): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass ``` **Function Descriptions**: - `__init__(self, elements: list = None)`: Initializes the queue. If `elements` is provided, initialize the queue with these elements. If `elements` is `None`, initialize an empty queue. - `enqueue(self, item)`: Adds `item` to the end of the queue. - `dequeue(self)`: Removes and returns the element at the front of the queue. If the queue is empty, returns `None`. - `peek(self)`: Returns the element at the front of the queue without removing it. If the queue is empty, returns `None`. - `is_empty(self)`: Returns `True` if the queue is empty, `False` otherwise. **Example**: ```python >>> q = Queue([1, 2, 3]) >>> q.is_empty() False >>> q.enqueue(4) >>> q.peek() 1 >>> q.dequeue() 1 >>> q.dequeue() 2 >>> q.dequeue() 3 >>> q.is_empty() False >>> q.dequeue() 4 >>> q.is_empty() True >>> q.dequeue() None ``` *Your task is to implement the `Queue` class according to the described requirements.*","solution":"class Queue: def __init__(self, elements: list = None): self.queue = elements if elements is not None else [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): return None return self.queue.pop(0) def peek(self): if self.is_empty(): return None return self.queue[0] def is_empty(self): return len(self.queue) == 0"},{"question":"# Subarray Sum Parity You are tasked with investigating the parity (even or odd) of subarray sums within a given integer array. Implement a function that determines whether there exists any subarray with an odd sum. Problem Given an array of integers `arr`, determine if there exists a subarray with an odd sum. Input - An array `arr` of length n (1 ≤ n ≤ 100000) where each element is an integer (-10^6 ≤ arr[i] ≤ 10^6). Output - A boolean value `True` if there\'s at least one subarray with an odd sum, and `False` otherwise. Example ```python >>> has_odd_sum_subarray([1, 2, 3, 4]) True >>> has_odd_sum_subarray([2, 4, 6, 8]) False >>> has_odd_sum_subarray([1]) True >>> has_odd_sum_subarray([10]) False ``` # Constraints - The algorithm should efficiently handle large input sizes up to 100,000 elements. - Ensure that your solution correctly identifies subarrays of size one (single elements) as valid subarrays. Notes - A simple way to verify if a sum is odd is to check if the sum modulo 2 equals 1. - If the entire array is even, the result is obviously False. - If there\'s at least one odd number, the result is True since a subarray containing just that odd number would have an odd sum. Implementation Implement the function `has_odd_sum_subarray(arr: list[int]) -> bool`.","solution":"def has_odd_sum_subarray(arr): Determines whether there exists any subarray with an odd sum. :param arr: List[int] - The input array of integers. :return: bool - True if there\'s at least one subarray with an odd sum, False otherwise. # If there is at least one odd number in the array, then we can form a subarray with an odd sum for num in arr: if num % 2 != 0: return True # If all elements are even, there is no subarray with an odd sum return False"},{"question":"# Coding Assessment Question Context You have been given a function that calculates the factorial of a number using recursion. However, for larger inputs, this approach can lead to a stack overflow due to deep recursion. Additionally, we need to improve the performance by storing intermediate results. Task Your task is to refactor the given recursive factorial function to use dynamic programming for optimizing performance and to prevent stack overflow for large inputs. Specifically, you need to: 1. **Memoization**: Implement a memoized version of the factorial function to store intermediate results and avoid redundant calculations. 2. **Iterative Approach**: Implement an iterative version of the factorial function to further improve performance and eliminate the risk of stack overflow. Function Signature ```python def factorial_memo(n: int, memo: dict = {}) -> int: Calculate factorial of a number using memoization. Parameters: n (int): The number to calculate the factorial for. memo (dict): Dictionary to store intermediate results for memoization. Returns: int: The factorial of the number n. def factorial_iter(n: int) -> int: Calculate factorial of a number using an iterative approach. Parameters: n (int): The number to calculate the factorial for. Returns: int: The factorial of the number n. ``` Input * **n (int)**: The number to calculate the factorial for. Output * Both functions should return the factorial of the number `n`. Constraints * `0 <= n <= 10^5` * For the memoized implementation, the memo dictionary should be used to store computed values. * Ensure the iterative implementation prevents risk of stack overflow. Example ```python # Call the functions for factorial of 5 print(factorial_memo(5)) # Expected output: 120 print(factorial_iter(5)) # Expected output: 120 # Call the functions for factorial of 10 print(factorial_memo(10)) # Expected output: 3628800 print(factorial_iter(10)) # Expected output: 3628800 ``` Good luck!","solution":"def factorial_memo(n: int, memo: dict = {}) -> int: Calculate factorial of a number using memoization. Parameters: n (int): The number to calculate the factorial for. memo (dict): Dictionary to store intermediate results for memoization. Returns: int: The factorial of the number n. if n in memo: return memo[n] if n == 0 or n == 1: memo[n] = 1 else: memo[n] = n * factorial_memo(n - 1, memo) return memo[n] def factorial_iter(n: int) -> int: Calculate factorial of a number using an iterative approach. Parameters: n (int): The number to calculate the factorial for. Returns: int: The factorial of the number n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Coding Assessment Question Your task is to implement a function that calculates the largest sum of a non-adjacent subarray from a given list of integers. The function should return the largest possible sum that can be obtained by summing elements of the subarray, while ensuring that no two elements in the subarray are adjacent in the original array. Function Signature: ```python def largest_non_adjacent_sum(nums: List[int]) -> int: ``` Input * `nums` (list of integers): A list of integers from which the non-adjacent subarray sum needs to be calculated. The list may contain positive and negative integers. Output * An integer representing the largest sum of a non-adjacent subarray. Constraints * The input list will have a maximum length of 10^5 elements. * Elements in the input list can be any integer in the range of [-10^4, 10^4]. Example ```python assert largest_non_adjacent_sum([2, 4, 6, 2, 5]) == 13 # (2 + 6 + 5) assert largest_non_adjacent_sum([5, 1, 1, 5]) == 10 # (5 + 5) assert largest_non_adjacent_sum([-1, -2, -3, -4]) == 0 # No non-adjacent subarray includes negative total assert largest_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 # (3 + 10 + 2) assert largest_non_adjacent_sum([]) == 0 # No elements to sum ``` Additional Information * For the empty list, the sum is considered to be 0. * Ensure the solution handles edge cases like all negative numbers gracefully. * Aim for an efficient solution, ideally running in linear time relative to the number of elements in the list. **Hint**: Consider using dynamic programming to keep track of the maximum sum at each step, avoiding adjacent elements.","solution":"from typing import List def largest_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include, exclude = 0, 0 for num in nums: # Current max excluding num new_exclude = max(include, exclude) # Current max including num include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Problem Statement Design a function to balance a binary search tree (BST) that has become unbalanced due to insertions or deletions, ensuring that the tree maintains its BST properties and becomes height-balanced. # Requirements 1. **Function Signature:** - `def balance_bst(root: TreeNode) -> TreeNode:` 2. **TreeNode Class:** - A class `TreeNode` with properties: - `val`: integer value of the node. - `left`: pointer to the left child TreeNode. - `right`: pointer to the right child TreeNode. 3. **Balance BST:** - The function receives the root of an unbalanced BST as input. - It returns the root of the balanced BST. # Constraints - The number of nodes in the BST is in the range [1, 10^4]. - The value of each node is a unique integer in the range [-10^5, 10^5]. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: # Step 1: Perform an in-order traversal to extract the elements of the tree in sorted order. def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] def sorted_list_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_list_to_bst(nums[:mid]) node.right = sorted_list_to_bst(nums[mid+1:]) return node sorted_elements = inorder_traversal(root) return sorted_list_to_bst(sorted_elements) # Example Usage root = TreeNode(1) root.right = TreeNode(3) root.right.left = TreeNode(2) balanced_root = balance_bst(root) ``` # Input Format - A single binary search tree root node. # Output Format - A single TreeNode representing the root of the balanced binary search tree. # Explanation In the provided example, the binary search tree is initially unbalanced. The `balance_bst` function is responsible for converting it into a balanced tree while preserving its BST properties. The function performs an in-order traversal to obtain the sorted elements of the tree, then constructs a balanced BST from this sorted list. Each recursive call ensures that the new tree is height-balanced by splitting the sorted list into two halves, using the middle element as the root of the subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] def sorted_list_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_list_to_bst(nums[:mid]) node.right = sorted_list_to_bst(nums[mid+1:]) return node sorted_elements = inorder_traversal(root) return sorted_list_to_bst(sorted_elements)"},{"question":"# Consecutive Subarray Sum You need to implement a function `find_max_sum_subarray(arr: List[int], k: int) -> int` that finds the maximum sum of any contiguous subarray of length `k` in an array of integers. Your implementation should utilize sliding window technique to ensure optimal performance. Requirements: 1. The function will take a list of integers `arr` and an integer `k`, and return the maximum sum of any contiguous subarray of length `k`. 2. The function should handle edge cases, including: - `k` being greater than the length of the array (should return -1). - Array being empty (should return -1). - Non-integer or negative `k` should raise a `ValueError`. Constraints: - The length of `arr` will be between 1 and 10^6. - The elements of `arr` will be between -10^4 and 10^4. - `k` will be a positive integer. Input: - `arr: List[int]` - a list of integers representing the array. - `k: int` - a positive integer representing the length of the subarray to consider. Output: - `int` - the maximum sum of any contiguous subarray of length `k`. Example: ```python assert find_max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 assert find_max_sum_subarray([1, 2, 3, -2, 5], 3) == 6 assert find_max_sum_subarray([1, 2], 3) == -1 assert find_max_sum_subarray([], 2) == -1 ``` # Function Signature: ```python from typing import List def find_max_sum_subarray(arr: List[int], k: int) -> int: pass ```","solution":"from typing import List def find_max_sum_subarray(arr: List[int], k: int) -> int: if not isinstance(k, int) or k <= 0: raise ValueError(\\"k should be a positive integer\\") if len(arr) == 0 or k > len(arr): return -1 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are responsible for maintaining a warehouse management system, which keeps track of inventory in various sections. The system requires a function to record and retrieve information in an efficient manner. The data structure of choice is a dictionary where each key is a section name and each value is a list of items in that section. # Task: Write a function `section_inventory_manager` that can perform two types of operations: 1. `add_item(section: str, item: str)`: Adds the item to the specified section. 2. `get_items(section: str)`: Returns a list of items in the specified section. Function Signature: ```python def section_inventory_manager(operations: List[Tuple[str, str, str]]) -> List[str]: pass ``` # Input: - `operations` (List[Tuple[str, str, str]]): A list of tuples where each tuple represents an operation to be performed. Each tuple contains exactly three strings. * The first string is either `\\"add\\"` or `\\"get\\"` indicating the type of operation. * The second string is the `section` name. * The third string is either an `item` name if the operation is `\\"add\\"`, or an empty string if the operation is `\\"get\\"`. # Output: - A list of strings representing the result of each `\\"get\\"` operation in the order they appear in the `operations` list. # Examples: ```python # Example 1: operations = [(\\"add\\", \\"SectionA\\", \\"item1\\"), (\\"add\\", \\"SectionA\\", \\"item2\\"), (\\"get\\", \\"SectionA\\", \\"\\")] # Expected output: [\\"item1,item2\\"] # Example 2: operations = [(\\"add\\", \\"SectionB\\", \\"item3\\"), (\\"add\\", \\"SectionB\\", \\"item4\\"), (\\"get\\", \\"SectionB\\", \\"\\")] # Expected output: [\\"item3,item4\\"] # Example 3: operations = [(\\"add\\", \\"SectionC\\", \\"item5\\"), (\\"add\\", \\"SectionC\\", \\"item6\\"), (\\"get\\", \\"SectionA\\", \\"\\"), (\\"get\\", \\"SectionC\\", \\"\\")] # Expected output: [\\"\\", \\"item5,item6\\"] ``` # Constraints: - The section and item names will only contain uppercase and/or lowercase English letters. - The section and item names will not exceed 100 characters. - The total number of operations will not exceed 1000. # Notes: - If a `\\"get\\"` operation is performed on a section that does not exist, it should return an empty string. - When returning items for a `\\"get\\"` operation, the items should be in the order they were added, separated by commas. If there are no items, return an empty string. - The function should manage the inventory in a case-sensitive manner. Good luck!","solution":"def section_inventory_manager(operations): inventory = {} result = [] for operation, section, item in operations: if operation == \\"add\\": if section not in inventory: inventory[section] = [] inventory[section].append(item) elif operation == \\"get\\": if section not in inventory or not inventory[section]: result.append(\\"\\") else: result.append(\\",\\".join(inventory[section])) return result"},{"question":"# Shifted Array Search You are given a \\"shifted\\" sorted array; a sorted array that has been shifted by an unknown number of positions. Your task is to write a function to find a given target value inside this shifted array. **Problem Statement**: Write a function `shifted_array_search(arr: List[int], target: int) -> int` that takes two arguments: - `arr`: A list of integers representing the shifted and sorted array. - `target`: An integer representing the target value to search for. The function should return the index of the `target` in the array `arr`. If the `target` is not found, the function should return `-1`. **Input Constraints**: - The `arr` list contains unique integers sorted in ascending order, but has been shifted by an unknown number of positions. - The `arr` will have at least one element and at most 10^5 elements. - The target can be any integer. **Requirements**: 1. The function should run in O(log n) time complexity. 2. Handle cases with shift boundaries effectively. 3. Return `-1` if the `target` is not present in the array. **Example**: ```python >>> print(shifted_array_search([6, 7, 8, 1, 2, 3, 4], 8)) 2 >>> print(shifted_array_search([4, 5, 6, 1, 2, 3], 2)) 4 >>> print(shifted_array_search([1], 1)) 0 >>> print(shifted_array_search([1], 0)) -1 >>> print(shifted_array_search([1, 2, 3, 4, 5], 7)) -1 ``` **Instructions**: - Implement the function using a binary search approach to maintain the desired time complexity. - Thoroughly test the function with various inputs, including edge cases where the array is minimally shifted or not shifted at all.","solution":"def shifted_array_search(arr, target): Find the index of target in a shifted sorted array. Return -1 if target is not found. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Check if the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question Context You are working on a financial application that needs to manage and manipulate monetary values represented in dollars and cents. The application requires various utility functions for handling these amounts in different ways. # Objective Implement a set of functions to parse, validate, and manipulate monetary values, ensuring proper handling of currency format and precision up to two decimal places. # Problem Statement 1. **Function: `parse_currency(amount_str)`** - **Description**: Parse a string representing a monetary amount and convert it to a float. - **Input**: A string amount in the format `\\"123.45\\"`. - **Output**: A float representing the monetary value. - **Constraints**: Ensure the string includes a dollar sign and is in the correct format. 2. **Function: `validate_currency(amount_str)`** - **Description**: Validate if a given string is a correctly formatted monetary amount. - **Input**: A string amount in the format `\\"123.45\\"`. - **Output**: A boolean indicating whether the amount is valid. - **Constraints**: Ensure the string is properly formatted with a dollar sign and two decimal places. 3. **Function: `add_currency(amount1, amount2)`** - **Description**: Add two monetary amounts and return the result. - **Input**: Two float values representing monetary amounts. - **Output**: A float representing the sum of the two amounts. - **Error Handling**: Ensure the amounts have precision up to two decimal places. # Example ```python def parse_currency(amount_str): # [Write your code here] def validate_currency(amount_str): # [Write your code here] def add_currency(amount1, amount2): # [Write your code here] # Example Usage: assert parse_currency(\\"123.45\\") == 123.45 assert parse_currency(\\"0.99\\") == 0.99 assert validate_currency(\\"123.45\\") == True assert validate_currency(\\"123.45\\") == False assert add_currency(123.45, 0.55) == 124.00 assert add_currency(100.00, 23.45) == 123.45 ```","solution":"def parse_currency(amount_str): Parse a string representing a monetary amount and convert it to a float. if amount_str.startswith(\'\') and validate_currency(amount_str): return float(amount_str[1:]) raise ValueError(\\"Invalid currency format\\") def validate_currency(amount_str): Validate if a given string is a correctly formatted monetary amount. if not amount_str.startswith(\'\'): return False try: amount = float(amount_str[1:]) except ValueError: return False # Ensure two decimal places parts = amount_str.split(\'.\') if len(parts) != 2 or len(parts[1]) != 2: return False return True def add_currency(amount1, amount2): Add two monetary amounts and return the result. # Round the result to two decimal places in case of floating-point arithmetic issues return round(amount1 + amount2, 2)"},{"question":"# Coding Assessment Question Objective: Implement a function to calculate and return the Fibonacci sequence up to the n-th term. The function should use an iterative approach to minimize the risk of stack overflow and ensure efficient computation. Description: You are tasked with writing a function called `generate_fibonacci` that takes an integer n and returns a list containing the Fibonacci sequence up to the n-th term (inclusive). The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. Input: - An integer n (0 <= n <= 50) representing the number of terms to generate in the Fibonacci sequence. Output: - A list of integers representing the Fibonacci sequence up to the n-th term. Constraints: - The input n will be a non-negative integer and will not surpass the value of 50. - Ensure the function handles the edge case when n is 0. Example: ```python input_n = 10 expected_output = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] ``` Function Signature: ```python def generate_fibonacci(n: int) -> list: pass ``` Implementation Instructions: 1. Start with the base cases for n = 0 and n = 1. 2. Use a loop to iteratively compute the following terms of the sequence until you reach the n-th term. 3. Make sure the function is efficient in both time and space complexity. Additional Examples: Example 1: ```python input_n = 5 expected_output = [0, 1, 1, 2, 3, 5] ``` Example 2: ```python input_n = 1 expected_output = [0, 1] ``` Example 3: ```python input_n = 0 expected_output = [0] ``` Implement your code following the above instructions and constraints.","solution":"def generate_fibonacci(n: int) -> list: Returns the Fibonacci sequence up to the n-th term (inclusive). Args: n (int): The number of terms to generate. Returns: list: A list of integers representing the Fibonacci sequence up to the n-th term. if n == 0: return [0] elif n == 1: return [0, 1] fibonacci_sequence = [0, 1] for i in range(2, n + 1): next_value = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_value) return fibonacci_sequence"},{"question":"# Task: Implement a Simple Letter Frequency Counter Scenario You need to create a function that counts the frequency of each letter in a given string. The function should be case-insensitive, meaning \'A\' and \'a\' should be treated as the same character. It should only count alphabetic characters and ignore any non-alphabetic ones. Core Requirements Develop a function that: 1. Converts all letters in the input string to lowercase. 2. Counts the frequency of each letter and returns a dictionary with letters as keys and their frequencies as values. 3. Ignores non-alphabetic characters in the input string. Function Specifications You need to implement the following function: 1. `letter_frequency_counter(text: str) -> dict` Input - `text` (str): A string that can contain alphabetic and non-alphabetic characters of any length. Output - Returns a dictionary where the keys are lowercase letters and the values are integers representing the frequency of each letter. Constraints - The function should efficiently handle strings of various lengths, including very long ones. - Non-alphabetic characters should be ignored and not included in the output dictionary. Example ```python # example usage print(letter_frequency_counter(\\"Hello, World!\\")) # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} print(letter_frequency_counter(\\"Python 3.8\\")) # Output: {\'p\': 1, \'y\': 1, \'t\': 1, \'h\': 1, \'o\': 1, \'n\': 1} ```","solution":"def letter_frequency_counter(text: str) -> dict: Counts the frequency of each letter in a given string, case-insensitive. Non-alphabetic characters are ignored. Args: text (str): The input string to be analyzed. Returns: dict: A dictionary with letters as keys and their frequencies as values. text = text.lower() frequency = {} for char in text: if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Coding Assessment Question Objective Implement a function to find all prime numbers less than a given number using the Sieve of Eratosthenes algorithm. Problem Statement A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. For this task, you need to find all prime numbers less than a given `n` using the Sieve of Eratosthenes method. Function Specification ```python def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than a given number n. Args: - n (int): The upper limit to find prime numbers below. Returns: - List[int]: List of prime numbers less than n. ``` Input * `n` (2 ≤ n ≤ 10^6): The upper limit to find prime numbers below. Output * Returns a list of integers representing all prime numbers less than `n`. Constraints 1. Your solution should efficiently handle the constraints using the Sieve of Eratosthenes algorithm. 2. Consider both time and space complexity in your implementation. Performance Requirements - Ensure your solution has a time complexity of O(n log log n) and a space complexity of O(n). Example ```python print(sieve_of_eratosthenes(10)) # Expected output: [2, 3, 5, 7] print(sieve_of_eratosthenes(30)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Additional Notes - The Sieve of Eratosthenes is an ancient algorithm with a wide range of uses. Ensure that you understand its implementation details and optimize for both small and large inputs.","solution":"def sieve_of_eratosthenes(n: int) -> list[int]: Returns a list of all prime numbers less than a given number n. Args: - n (int): The upper limit to find prime numbers below. Returns: - List[int]: List of prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiples in range(start*start, n, start): sieve[multiples] = False return [num for num in range(n) if sieve[num]]"},{"question":"# Chat Room Server with Non-Blocking I/O and Connection Management You are tasked with creating a basic chat room server that handles multiple clients concurrently. The server should use non-blocking I/O operations to efficiently manage multiple connected clients and broadcast messages received from any client to all connected clients. Function Specification: Implement the function `start_chat_server(port: int = 12345) -> None`. This function should: 1. Create a non-blocking server socket that listens for incoming client connections on the specified port. 2. Accept new client connections and add them to the list of managed clients using non-blocking operations. 3. Read messages from clients in non-blocking mode and broadcast each received message to all other connected clients. 4. Manage client disconnections gracefully, ensuring all resources are properly released. 5. Add logging to provide insights into the server\'s operation (client connections/disconnections, message reception/transmission, errors, etc.). Input: - `port` (int): The port number on which the chat server will listen for incoming connections. Defaults to `12345`. Constraints: - The server should handle multiple clients simultaneously. - The server should efficiently manage client connections and disconnections. - Use non-blocking operations for socket interactions. - Ensure the server can be terminated gracefully (e.g., using signal handlers for SIGINT). - Messages are assumed to be UTF-8 encoded strings, ending with a newline character. Example Usage: ```python if __name__ == \\"__main__\\": start_chat_server(23456) ``` In this example, the chat server will start and listen for incoming connections on port `23456`. Once clients connect, it will broadcast any messages received to all connected clients. Notes: - Consider using Python\'s `selectors` module for managing non-blocking socket operations. - Ensure your server closes client connections and the server socket gracefully on termination. - Handle partial reads/writes and ensure buffer management for client messages. - You do not need to implement the client-side code, but you may write it for testing purposes. This question effectively integrates with the provided set by adhering to the same level of complexity, style, and focus on non-blocking socket programming and comprehensive error handling.","solution":"import selectors import socket import types import signal import logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(message)s\') selector = selectors.DefaultSelector() def accept(sock): conn, addr = sock.accept() # Should be ready to read logging.info(f\\"Accepted connection from {addr}\\") conn.setblocking(False) data = types.SimpleNamespace(addr=addr, inb=b\'\', outb=b\'\') events = selectors.EVENT_READ | selectors.EVENT_WRITE selector.register(conn, events, data=data) def service_connection(key, mask): sock = key.fileobj data = key.data if mask & selectors.EVENT_READ: recv_data = sock.recv(1024) # Should be ready to read if recv_data: logging.info(f\\"Received data from {data.addr}: {recv_data.decode()}\\") data.outb += recv_data else: logging.info(f\\"Closing connection to {data.addr}\\") selector.unregister(sock) sock.close() if mask & selectors.EVENT_WRITE: if data.outb: logging.info(f\\"Sending data to {data.addr}: {data.outb.decode()}\\") sent = sock.send(data.outb) # Should be ready to write data.outb = data.outb[sent:] def start_chat_server(port=12345): # Create listener socket lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) lsock.bind((\'localhost\', port)) lsock.listen() logging.info(f\\"Listening on (\'localhost\', {port})\\") lsock.setblocking(False) selector.register(lsock, selectors.EVENT_READ, data=None) try: while True: events = selector.select(timeout=None) for key, mask in events: if key.data is None: accept(key.fileobj) else: service_connection(key, mask) except KeyboardInterrupt: logging.info(\\"Caught keyboard interrupt, exiting\\") finally: selector.close()"},{"question":"# Programming Assessment Question Context Understanding and manipulating strings is a fundamental skill in programming. Sometimes, you need to process a string according to specific rules. This exercise will test your ability to work with strings and follow defined constraints. Task **Objective:** Write a function that processes a given string and returns a new string that consists of alternating characters starting with the first character. # Requirements * **Function Signature**: ```python def alternate_characters(s: str) -> str: ``` * **Inputs**: - `s`: A string consisting of lowercase alphabets. * **Output**: - Returns a new string formed by picking characters from the original string such that the characters are at even indices (0-based). # Constraints * The input string can be of any length, including 0. * The input string will only contain lowercase alphabetical characters (\'a\' to \'z\'). # Example Scenarios 1. **Example 1**: ```python alternate_characters(\\"abcdef\\") # Returns: \\"ace\\" ``` (Explanation: The characters at even indices are \'a\', \'c\', and \'e\'.) 2. **Example 2**: ```python alternate_characters(\\"xyz\\") # Returns: \\"xz\\" ``` (Explanation: The characters at even indices are \'x\' and \'z\'.) 3. **Example 3**: ```python alternate_characters(\\"\\") # Returns: \\"\\" ``` (Explanation: The input string is empty, so the output is also an empty string.) 4. **Example 4**: ```python alternate_characters(\\"a\\") # Returns: \\"a\\" ``` (Explanation: There is only one character, and it\'s at an even index.) # Additional Requirements * Your implementation should handle edge cases such as an empty string or a string of length 1. * Ensure that the function efficiently constructs the new string by iterating over the original string only once.","solution":"def alternate_characters(s: str) -> str: This function returns a new string formed by picking characters from the original string at even indices (0-based). :param s: Original string :return: New string with alternating characters starting from the first character return s[::2]"},{"question":"# Problem Statement Write a function that takes a string representing a mathematical expression in postfix notation and evaluates it. # Task Description 1. **Function: `evaluate_postfix(expression: str) -> float`** - Takes a postfix notation string as input and evaluates it to return the result as a floating point number. - Ensures the function handles errors such as division by zero, invalid characters, and insufficient operands. Your solution should comply with the following constraints and properties: - The postfix expression contains single-digit numbers and the operators (+, -, *, /, %, ^). - Assume the input string is properly formatted. - Handle and raise appropriate exceptions for division by zero and other invalid operations. # Input - A valid postfix expression `expression` as a string up to length 100. - Assume the input will be non-empty and consist of valid operands and operators. # Output - Return the evaluated result as a floating-point number. # Example ```python assert evaluate_postfix(\\"23+\\") == 5.0 assert evaluate_postfix(\\"52/\\") == 2.5 assert evaluate_postfix(\\"93-\\") == 6.0 assert evaluate_postfix(\\"234*+\\") == 14.0 try: evaluate_postfix(\\"90/\\") # Division by zero case. except ZeroDivisionError as e: assert str(e) == \\"division by zero\\" try: evaluate_postfix(\\"22+\\") # Insufficient operands case. except ValueError as e: assert str(e) == \\"Insufficient operands for the operation\\" ``` # Constraints - The postfix expression will have at most 100 characters. # Exception Handling - Raise `ZeroDivisionError` for division by zero attempts. - Raise `ValueError` for expressions containing invalid operations or insufficient operands.","solution":"def evaluate_postfix(expression: str) -> float: Evaluates a postfix expression and returns the result as a floating-point number. :param expression: A string representing the postfix expression. :return: The evaluated result as a floating-point number. :raises ZeroDivisionError: If there is an attempt to divide by zero. :raises ValueError: If the expression is invalid or there are insufficient operands. stack = [] for char in expression: if char.isdigit(): stack.append(float(char)) else: if len(stack) < 2: raise ValueError(\\"Insufficient operands for the operation\\") b = stack.pop() a = stack.pop() if char == \'+\': result = a + b elif char == \'-\': result = a - b elif char == \'*\': result = a * b elif char == \'/\': if b == 0: raise ZeroDivisionError(\\"division by zero\\") result = a / b elif char == \'%\': result = a % b elif char == \'^\': result = a ** b else: raise ValueError(\\"Invalid operator encountered\\") stack.append(result) if len(stack) != 1: raise ValueError(\\"The expression is invalid and cannot be evaluated\\") return stack[0]"},{"question":"# Scenario In a city’s public transportation system, buses operate on multiple routes, with each route having a specific schedule of stops. Each route is represented by a unique identifier and consists of a series of bus stops, each associated with a distinct arrival time. Riders need to know the schedule of bus stops for a given route to plan their trips accordingly. # Problem Description Implement a class `BusRoute` in Python, which manages the schedule of bus stops for a specific route. The class should allow you to add stops, retrieve the list of stops in order of their arrival times, and find the next available stop after a given time. # Class Implementation ```python class BusRoute: def __init__(self, route_id: str): Initializes the BusRoute object with a route identifier. Args: route_id (str): Unique identifier for the bus route. pass def add_stop(self, stop_name: str, arrival_time: str): Adds a bus stop to the route with the specified arrival time. Args: stop_name (str): Name of the bus stop. arrival_time (str): Arrival time at the stop in \'HH:MM\' format. pass def get_schedule(self) -> list: Returns the list of stops in the order of their arrival times. Returns: list: A list of tuples where each tuple contains stop_name and arrival_time. pass def next_stop(self, current_time: str) -> tuple: Finds the next available stop after the given time. Args: current_time (str): Current time in \'HH:MM\' format. Returns: tuple: A tuple containing the next stop name and arrival time. pass ``` # Input and Output Formats * The `BusRoute` constructor takes a single string as a parameter, which represents the unique identifier for the route. * The `add_stop` method takes two parameters: * `stop_name` - a string representing the name of the bus stop. * `arrival_time` - a string representing the arrival time at the stop in \'HH:MM\' format (24-hour clock). * The `get_schedule` method returns a list of tuples, where each tuple contains the stop name and the arrival time in \'HH:MM\' format. * The `next_stop` method takes a single string parameter `current_time` and returns a tuple containing the next stop name and the arrival time in \'HH:MM\' format. If there are no stops after the given time, the method should return `None`. # Example Usage ```python # Initialize a bus route route = BusRoute(\\"A1\\") # Add stops to the route route.add_stop(\\"Stop1\\", \\"08:00\\") route.add_stop(\\"Stop2\\", \\"08:15\\") route.add_stop(\\"Stop3\\", \\"08:30\\") # Print the schedule of stops print(route.get_schedule()) # Output: [(\'Stop1\', \'08:00\'), (\'Stop2\', \'08:15\'), (\'Stop3\', \'08:30\')] # Find the next stop after 08:10 print(route.next_stop(\\"08:10\\")) # Output: (\'Stop2\', \'08:15\') # Find the next stop after 08:45 print(route.next_stop(\\"08:45\\")) # Output: None ``` # Constraints * Only valid times (from \'00:00\' to \'23:59\') will be provided for stop arrival times and current time. * Stops will be added in ascending order of arrival times. * No two stops will have the same arrival time on the same route. * Input strings will always comply with the \'HH:MM\' format. * The route will have at least one stop when querying for the next stop.","solution":"class BusRoute: def __init__(self, route_id: str): Initializes the BusRoute object with a route identifier. Args: route_id (str): Unique identifier for the bus route. self.route_id = route_id self.stops = [] def add_stop(self, stop_name: str, arrival_time: str): Adds a bus stop to the route with the specified arrival time. Args: stop_name (str): Name of the bus stop. arrival_time (str): Arrival time at the stop in \'HH:MM\' format. self.stops.append((stop_name, arrival_time)) self.stops.sort(key=lambda x: x[1]) # Ensure stops are sorted by arrival time def get_schedule(self) -> list: Returns the list of stops in the order of their arrival times. Returns: list: A list of tuples where each tuple contains stop_name and arrival_time. return self.stops def next_stop(self, current_time: str) -> tuple: Finds the next available stop after the given time. Args: current_time (str): Current time in \'HH:MM\' format. Returns: tuple: A tuple containing the next stop name and arrival time, or None if no stop is available. for stop in self.stops: if stop[1] > current_time: return stop return None"},{"question":"# Rainwater Trapping Calculation You are given a list of non-negative integers representing an elevation map where the width of each bar is 1. Write a function to calculate how much rainwater can be trapped after it rains. Each bar\'s width is equal to one unit. Input * A list of integers `heights` where `heights[i]` is the height of the elevation at the i-th index. Output * An integer representing the total units of water that can be trapped. Constraints * `1 ≤ len(heights) ≤ 2 * 10^4` * `0 ≤ heights[i] ≤ 10^5` Example ```python # Input heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # Output 6 ``` Explanation The elevation map [0,1,0,2,1,0,1,3,2,1,2,1] can trap 6 units of rainwater as displayed in the diagram below: ``` █ █────█─█ █───█──█─█─█ ``` Notice that the trapped water is bounded by higher bars on both the left and the right, and the amount of trapped water depends on the heights of the bounding bars. Implement the function `trap_rainwater(heights: List[int]) -> int`: ```python def trap_rainwater(heights): # Implement here pass ```","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"# Coding Question Context You are required to manipulate and analyze a sequence of timestamped temperature readings from various sensors. The readings are stored in a list of tuples, where each tuple consists of a timestamp, a sensor ID, and the temperature reading. Your task is to implement a function that finds the highest temperature recorded by each sensor within a specified time range. Problem Statement Implement a function `max_temperature_in_range` that takes a list of readings, a start time, and an end time as input and returns a dictionary mapping each sensor ID to its highest temperature recorded within the given time range. ```python def max_temperature_in_range(readings, start_time, end_time): Finds the highest temperature recorded by each sensor within the given time range. Parameters: readings (list of tuples): Each tuple contains (timestamp: int, sensor_id: str, temperature: float). start_time (int): The start time of the range (inclusive). end_time (int): The end time of the range (inclusive). Returns: dict: Mapping of sensor ID to the highest temperature recorded within the range. pass ``` # Constraints 1. The timestamps are represented as positive integers. 2. All sensor IDs are unique strings. 3. Temperature readings are floating-point numbers. 4. The list of readings is sorted by timestamps in ascending order. 5. Ensure the solution is efficient and scalable with respect to the number of readings. Example ```python readings = [ (1, \\"sensor_1\\", 22.5), (2, \\"sensor_2\\", 19.2), (3, \\"sensor_1\\", 23.1), (5, \\"sensor_2\\", 20.5), (6, \\"sensor_3\\", 25.3), (8, \\"sensor_3\\", 26.0), (10, \\"sensor_1\\", 24.0) ] start_time = 3 end_time = 8 result = max_temperature_in_range(readings, start_time, end_time) # Expected output: {\'sensor_1\': 23.1, \'sensor_2\': 20.5, \'sensor_3\': 26.0} ``` # Performance Requirements Your function should efficiently find the highest temperatures for sensors within the given time range, considering that the list of readings is sorted by timestamps. Aim for an optimal solution that can handle large datasets effectively.","solution":"def max_temperature_in_range(readings, start_time, end_time): Finds the highest temperature recorded by each sensor within the given time range. Parameters: readings (list of tuples): Each tuple contains (timestamp: int, sensor_id: str, temperature: float). start_time (int): The start time of the range (inclusive). end_time (int): The end time of the range (inclusive). Returns: dict: Mapping of sensor ID to the highest temperature recorded within the range. result = {} for timestamp, sensor_id, temperature in readings: if start_time <= timestamp <= end_time: if sensor_id not in result: result[sensor_id] = temperature else: result[sensor_id] = max(result[sensor_id], temperature) return result"},{"question":"Circular Queue Implementation and Manipulation # Objective: Implement a circular queue data structure in Python. Demonstrate your understanding by creating a class that simulates standard queue operations such as enqueue, dequeue, and viewing the front element in a circular manner. # Requirements: 1. **Class Definition**: Define a class `CircularQueue` that initializes with a predefined size. 2. **Enqueue Function**: Implement an `enqueue(self, value)` method to add elements to the queue. 3. **Dequeue Function**: Implement a `dequeue(self)` method to remove elements from the queue. 4. **Front Element**: Implement a `front(self)` method to view the front element without dequeuing it. 5. **Edge Handling**: Ensure proper handling when the queue is full or empty, and throw relevant exceptions or return appropriate messages. # Input & Output Format: - **Input**: - Class `CircularQueue` with a constructor that accepts: - `size`: The maximum number of elements the queue can hold. - Methods within `CircularQueue` for: - `enqueue(value)`: Adds `value` to the queue. - `dequeue()`: Removes and returns the front element of the queue. - `front()`: Returns the front element without removing it. - **Output**: - Print the result of the operations and the state of the queue after each operation. - Handle and print messages for edge cases like queue overflow and underflow. # Examples: ```python # Initialize Circular Queue with size 3 cq = CircularQueue(3) # Enqueue elements cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) # Expected Output: # Queue after enqueuing 10, 20, 30: [10, 20, 30] # Dequeue an element print(cq.dequeue()) # Expected Output: # Dequeued element: 10 # Queue after dequeue: [20, 30] # View the front element print(cq.front()) # Expected Output: # Front element: 20 # Try to enqueue into a full queue cq.enqueue(40) # Expected Output: # Queue is full # Expected Output: # Queue after failed enqueuing attempt: [20, 30] # Dequeue all elements print(cq.dequeue()) print(cq.dequeue()) # Expected Output: # Dequeued element: 20 # Dequeued element: 30 # Queue after dequeuing all elements: [] # Try to dequeue from an empty queue print(cq.dequeue()) # Expected Output: # Queue is empty ``` # Constraints: - Ensure that the enqueue operation handles wrapping around the end of the array correctly. - Prevent overflow by checking if the queue is full before enqueuing a new element. - Prevent underflow by checking if the queue is empty before dequeuing an element. # Performance: - The complexity for each operation should be O(1), leveraging the circular nature of the queue for maximum efficiency. Implement the `CircularQueue` class with the specified functionality and validate with the provided examples and edge cases.","solution":"class CircularQueue: def __init__(self, size): self.size = size self.queue = [None] * size self.front_index = -1 self.rear_index = -1 def enqueue(self, value): if (self.rear_index + 1) % self.size == self.front_index: print(\\"Queue is full\\") return \\"Queue is full\\" if self.front_index == -1: self.front_index = 0 self.rear_index = (self.rear_index + 1) % self.size self.queue[self.rear_index] = value return self.queue def dequeue(self): if self.front_index == -1: print(\\"Queue is empty\\") return \\"Queue is empty\\" dequeued_element = self.queue[self.front_index] self.queue[self.front_index] = None if self.front_index == self.rear_index: self.front_index = -1 self.rear_index = -1 else: self.front_index = (self.front_index + 1) % self.size return dequeued_element def front(self): if self.front_index == -1: print(\\"Queue is empty\\") return \\"Queue is empty\\" return self.queue[self.front_index]"},{"question":"# Question: Calculate the Roots of a Quadratic Equation Given the coefficients a, b, and c of a quadratic equation `ax^2 + bx + c = 0`, write a Python function to calculate the roots of the equation. The function should return a dictionary containing the roots in sorted order. If the equation has complex roots, the function should return them as complex numbers in their simplest form. The roots of the quadratic equation can be found using the quadratic formula: [ x = frac{{-b pm sqrt{{b^2 - 4ac}}}}{2a} ] # Function Signature: ```python def find_quadratic_roots(a: float, b: float, c: float) -> dict[str, float | complex]: pass ``` # Input: - `a` (float): Coefficient of x^2, must not be zero. - `b` (float): Coefficient of x. - `c` (float): Constant term. # Output: - A dictionary with two key-value pairs: - `\'root1\'`: The first root of the quadratic equation (float or complex). - `\'root2\'`: The second root of the quadratic equation (float or complex). # Constraints: - The input coefficient \'a\' should be non-zero. - If the discriminant (`b^2 - 4ac`) is zero, the function should return the same root for both keys. - If the discriminant is positive, both roots are real numbers. - If the discriminant is negative, roots are complex numbers. # Example: ```python >>> find_quadratic_roots(1, -3, 2) {\'root1\': 1.0, \'root2\': 2.0} >>> find_quadratic_roots(1, 2, 1) {\'root1\': -1.0, \'root2\': -1.0} >>> find_quadratic_roots(1, 0, -1) {\'root1\': -1.0, \'root2\': 1.0} >>> find_quadratic_roots(1, 1, 1) {\'root1\': (-0.5-0.8660254037844386j), \'root2\': (-0.5+0.8660254037844386j)} ``` # Notes: - Ensure to handle edge cases where the inputs lead to zero or negative discriminant values appropriately. - Ensure the roots are accurate and sorted in ascending order if they are real numbers. - Use Python\'s complex number functionality to handle complex roots.","solution":"import cmath def find_quadratic_roots(a: float, b: float, c: float) -> dict: Calculates the roots of the quadratic equation ax^2 + bx + c = 0. Args: a (float): Coefficient of x^2, must not be zero. b (float): Coefficient of x. c (float): Constant term. Returns: dict: A dictionary with two key-value pairs: \'root1\' and \'root2\' containing the roots (float or complex). discriminant = b**2 - 4*a*c if discriminant >= 0: root1 = (-b - discriminant**0.5) / (2 * a) root2 = (-b + discriminant**0.5) / (2 * a) return {\'root1\': min(root1, root2), \'root2\': max(root1, root2)} else: root1 = (-b - cmath.sqrt(discriminant)) / (2 * a) root2 = (-b + cmath.sqrt(discriminant)) / (2 * a) return {\'root1\': root1, \'root2\': root2}"},{"question":"# Question: Implement Movie Ticket Booking System Background Designing a simple movie ticket booking system can cover several fundamental programming concepts like arrays, sorting, and searching. The system stores movie showtimes and allows users to book tickets for available showtimes. Task Your task is to extend the given `MovieBookingSystem` class to include the following functionalities: 1. Add a new movie showtime to the system. 2. Search for available movie showtimes on a given date. 3. Book a ticket for a given showtime if seats are available. Requirements - Implement the methods according to the specifications provided below. - Ensure the input validations and error handling is appropriately managed. # Class Specifications `MovieBookingSystem` - **Attributes**: - `showtimes` (list): A list to store movie showtimes. Each showtime is represented as a dictionary with keys `date`, `time`, `movie_title`, and `available_seats`. - **Methods**: 1. `add_showtime(date: str, time: str, movie_title: str, available_seats: int) -> None` - **Input**: - `date` (str): The showtime date in the format \\"YYYY-MM-DD\\". - `time` (str): The showtime time in the format \\"HH:MM\\". - `movie_title` (str): Title of the movie. - `available_seats` (int): Number of available seats for the showtime. - **Output**: Adds a new showtime to the list of showtimes. - **Constraints**: - Validate the format of the date and time. - Ensure available seats are positive. 2. `search_showtimes(date: str) -> list` - **Input**: - `date` (str): The date to search for showtimes in the format \\"YYYY-MM-DD\\". - **Output**: A list of showtimes on the given date. Each showtime should be a string in the format \\"HH:MM - movie_title\\". - **Constraints**: - Validate the format of the date. 3. `book_ticket(date: str, time: str) -> str` - **Input**: - `date` (str): The date of the showtime in the format \\"YYYY-MM-DD\\". - `time` (str): The time of the showtime in the format \\"HH:MM\\". - **Output**: Returns a confirmation message when a ticket is successfully booked or an error message if no seats are available. - **Constraints**: - Validate the format of the date and time. - Ensure there are available seats before booking. # Example Usage ```python # Create the movie booking system system = MovieBookingSystem() # Add some showtimes system.add_showtime(\\"2022-12-25\\", \\"18:00\\", \\"Movie A\\", 50) system.add_showtime(\\"2022-12-25\\", \\"20:00\\", \\"Movie B\\", 30) # Search showtimes on a date print(system.search_showtimes(\\"2022-12-25\\")) # Output: [\'18:00 - Movie A\', \'20:00 - Movie B\'] # Attempt to book a ticket for a showtime with available seats print(system.book_ticket(\\"2022-12-25\\", \\"18:00\\")) # Output: \'Ticket booked for Movie A at 18:00 on 2022-12-25\' # Attempt to book a ticket for a showtime with no seats available for _ in range(50): system.book_ticket(\\"2022-12-25\\", \\"18:00\\") print(system.book_ticket(\\"2022-12-25\\", \\"18:00\\")) # Output: \'No available seats for Movie A at 18:00 on 2022-12-25\' ``` # Notes 1. Include necessary validations to handle invalid dates and times. 2. Ensure methods are efficient and handle the edge cases properly.","solution":"from datetime import datetime class MovieBookingSystem: def __init__(self): self.showtimes = [] def add_showtime(self, date: str, time: str, movie_title: str, available_seats: int) -> None: # Validate date and time format try: datetime.strptime(date, \'%Y-%m-%d\') datetime.strptime(time, \'%H:%M\') except ValueError: raise ValueError(\\"Invalid date or time format\\") # Validate available seats if available_seats <= 0: raise ValueError(\\"Number of available seats must be positive\\") # Add showtime to the list self.showtimes.append({ \'date\': date, \'time\': time, \'movie_title\': movie_title, \'available_seats\': available_seats }) def search_showtimes(self, date: str) -> list: # Validate date format try: datetime.strptime(date, \'%Y-%m-%d\') except ValueError: raise ValueError(\\"Invalid date format\\") # Find showtimes for the given date result = [] for showtime in self.showtimes: if showtime[\'date\'] == date: result.append(f\\"{showtime[\'time\']} - {showtime[\'movie_title\']}\\") return result def book_ticket(self, date: str, time: str) -> str: # Validate date and time format try: datetime.strptime(date, \'%Y-%m-%d\') datetime.strptime(time, \'%H:%M\') except ValueError: raise ValueError(\\"Invalid date or time format\\") # Find and book showtime if available for showtime in self.showtimes: if showtime[\'date\'] == date and showtime[\'time\'] == time: if showtime[\'available_seats\'] > 0: showtime[\'available_seats\'] -= 1 return f\\"Ticket booked for {showtime[\'movie_title\']} at {time} on {date}\\" else: return f\\"No available seats for {showtime[\'movie_title\']} at {time} on {date}\\" return f\\"No showtime found at {time} on {date}\\""},{"question":"# Coding Question: Find the First Repeated Character You are tasked with creating a function that finds the first repeated character in a given string. The function should return the first character that appears more than once. If no character repeats, it should return `None`. Function Signature: Implement the function `first_repeated_character`: ```python def first_repeated_character(s: str) -> str: pass ``` Input: * `s`: A string containing only alphabets (both uppercase and lowercase) with a length of at least 1 and at most 10^5 characters. Output: * Returns the first repeated character (`str`). If there is no repeated character, return `None`. Constraints: * The string `s` will have at least 1 character and at most 10^5 characters. Examples: ```python >>> first_repeated_character(\\"programming\\") \\"r\\" >>> first_repeated_character(\\"abacabad\\") \\"a\\" >>> first_repeated_character(\\"abcdefg\\") None ``` Explanation: 1. In the string `\\"programming\\"`, the first repeated character is `\\"r\\"`. 2. In the string `\\"abacabad\\"`, the first repeated character is `\\"a\\"`. 3. In the string `\\"abcdefg\\"`, there are no repeated characters, so the function returns `None`. Hint: Consider using a set to keep track of characters you have encountered as you iterate through the string.","solution":"def first_repeated_character(s: str) -> str: This function returns the first repeated character in the given string s. If no character repeats, it returns None. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"# Data Manipulation & Analysis You are working on an e-commerce platform that collects extensive data about users\' purchase history. Your task is to analyze this data and identify the top three products that have been bought together most frequently in each month. This information is vital for improving product recommendations and marketing strategies. Task: Implement a function `top_three_products_per_month(purchase_data: list[dict]) -> dict[tuple[int, int], list[tuple[str, int]]]` that processes the purchase data and returns the top three products bought together for each month. Requirements: 1. **Input:** `purchase_data` (list of dictionaries) - Each dictionary represents a purchase transaction and contains the following keys: * \'transaction_id\' (string) - The unique identifier for the transaction. * \'user_id\' (string) - The unique identifier for the user. * \'product_ids\' (list of strings) - The list of product IDs involved in the transaction. * \'timestamp\' (string) - The date and time when the transaction occurred in the format \'YYYY-MM-DD HH:MM:SS\'. 2. **Output:** A dictionary where: * The key is a tuple (year, month) indicating the year and month of the transactions. * The value is a list of tuples, each containing: - Product combination (tuple of product IDs) - A tuple representing the combination of products bought together. - Frequency (integer) - The number of times this combination has been bought together in that month. 3. The function should handle the following edge cases: * Ensure proper handling of product combinations irrespective of their order in the list. * Transactions might span across multiple years. 4. The output should only include the top three frequently bought product combinations for each month. If there are fewer than three combinations, include only the available ones. Constraints: * Transactions can involve between 2 to 10 products. * Each product ID is a string consisting of alphanumeric characters. * The dataset can include transactions from multiple users over several years. Example: ```python purchase_data = [ {\'transaction_id\': \'1\', \'user_id\': \'A\', \'product_ids\': [\'P1\', \'P2\'], \'timestamp\': \'2023-01-15 10:30:00\'}, {\'transaction_id\': \'2\', \'user_id\': \'B\', \'product_ids\': [\'P1\', \'P3\'], \'timestamp\': \'2023-01-15 11:00:00\'}, {\'transaction_id\': \'3\', \'user_id\': \'C\', \'product_ids\': [\'P1\', \'P2\', \'P3\'], \'timestamp\': \'2023-02-10 14:00:00\'}, {\'transaction_id\': \'4\', \'user_id\': \'A\', \'product_ids\': [\'P2\', \'P3\'], \'timestamp\': \'2023-02-12 09:30:00\'}, # Additional transactions... ] result = top_three_products_per_month(purchase_data) for (year, month), top_products in result.items(): print(f\\"Year: {year}, Month: {month}\\") for combination, frequency in top_products: print(f\\"Products: {combination} - Bought Together: {frequency} times\\") ``` This should analyze the purchase data and print the top three product combinations for each month along with their frequencies. Note: Make sure to handle date parsing properly and consider optimizations for processing large datasets. You can use Python\'s `collections` module to help with counting and managing product combinations efficiently.","solution":"import itertools from collections import defaultdict, Counter from datetime import datetime def top_three_products_per_month(purchase_data): Analyze purchase data and identify the top three products that have been bought together most frequently in each month. Args: - purchase_data (list of dicts): Each dictionary contains the following keys: - \'transaction_id\' (string) - \'user_id\' (string) - \'product_ids\' (list of strings) - \'timestamp\' (string) Returns: - dict: Keys are tuples (year, month) and values are lists of tuples (product combination, frequency). product_combinations = defaultdict(Counter) for purchase in purchase_data: timestamp = datetime.strptime(purchase[\'timestamp\'], \'%Y-%m-%d %H:%M:%S\') year_month = (timestamp.year, timestamp.month) product_ids = sorted(purchase[\'product_ids\']) for comb in itertools.combinations(product_ids, 2): product_combinations[year_month][comb] += 1 result = {} for year_month, counter in product_combinations.items(): top_three = counter.most_common(3) result[year_month] = top_three return result"},{"question":"# Context You are working on a project that involves processing large text documents. One particular task is to identify and count all unique words in a given text file, ignoring the letter case. This requires parsing the text, normalizing it, and efficiently counting occurrences of each word. # Task Implement a function `unique_word_count(file_path: str) -> Dict[str, int]` that reads a text file and returns a dictionary containing each unique word as a key and its frequency of occurrence as the value. The words should be normalized to lowercase, and punctuation should be ignored. # Function Signature ```python def unique_word_count(file_path: str) -> Dict[str, int]: pass ``` # Input - `file_path`: A string denoting the path to the text file you need to process. # Output - A dictionary where the keys are unique words (in lowercase) from the text file, and the values are the frequency counts of those words. # Constraints - You can assume the file is reasonably sized to fit in memory. - The file consists of plain text and conforms to standard English language typographic conventions. # Performance Requirements - The implementation should handle large files efficiently. # Example Example 1: Assume `example.txt` contains the following text: ``` Hello world! This is a test. Hello again; this is another test. ``` ```python >>> unique_word_count(\'example.txt\') { \'hello\': 2, \'world\': 1, \'this\': 2, \'is\': 2, \'a\': 1, \'test\': 2, \'again\': 1, \'another\': 1 } ``` # Notes - Pay special attention to handling punctuation, ensuring it\'s not considered part of the words. - Use efficient file reading and string processing techniques to ensure optimal performance.","solution":"import re from typing import Dict def unique_word_count(file_path: str) -> Dict[str, int]: Reads a text file and returns a dictionary containing each unique word as a key and its frequency of occurrence as the value. The words are normalized to lowercase, and punctuation is ignored. word_count = {} # Open and read the file with open(file_path, \'r\') as file: for line in file: # Remove punctuation and normalize to lowercase words = re.findall(r\'bw+b\', line.lower()) for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"# Problem Statement You are required to implement a function that counts the number of unique substrings within a given string. Your task is to write a function `count_unique_substrings(s: str) -> int` that takes in a string `s` and returns the count of all possible unique substrings that can be constructed from `s`. Input - A single string `s` which consists only of lowercase English letters (1 <= len(s) <= 1000). Output - An integer representing the number of unique substrings in the given string `s`. Examples 1. `count_unique_substrings(\\"abc\\")` should return `6` (substrings: [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"]) 2. `count_unique_substrings(\\"aaa\\")` should return `3` (substrings: [\\"a\\", \\"aa\\", \\"aaa\\"]) 3. `count_unique_substrings(\\"ababa\\")` should return `9` (substrings: [\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\", \\"bab\\", \\"aba\\", \\"abab\\", \\"ababa\\"]) Constraints - The length of the string `s` will be at least 1 and at most 1000. Requirements 1. The function should be efficient and work within the given constraints. 2. Handle edge cases such as very short or repetitive strings effectively. 3. Avoid unnecessary computations to ensure the function runs in a reasonable time frame for longer strings. Notes - The solution should focus on optimizing the substring generation and uniqueness check. - Carefully consider the data structures used to store and check for unique substrings to maintain efficiency and clarity.","solution":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string. substrings = set() # Generate all possible substrings and store in a set for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"# Sum of Squared Differences Between Lists Context Calculating the sum of squared differences between corresponding elements of two lists is a common task in various fields such as statistics, optimization, and machine learning. This concept is often used in computing loss functions like Mean Squared Error (MSE). Task Implement a function `sum_squared_diffs` that takes in two lists of equal length and returns the sum of squared differences between corresponding elements. Function Signature ```python def sum_squared_diffs(list1: List[int], list2: List[int]) -> int: pass ``` Input * `list1` (List of int): The first list of integers. * `list2` (List of int): The second list of integers. Output * (int): The sum of the squared differences between corresponding elements of the input lists. Constraints 1. Both input lists will have the same length. 2. The inputs can be positive, zero, or negative integers. 3. The input lists can be empty. Example ```python assert sum_squared_diffs([1, 2, 3], [4, 5, 6]) == 27 # (1-4)^2 + (2-5)^2 + (3-6)^2 = 9 + 9 + 9 = 27 assert sum_squared_diffs([0, -1, 2], [-1, 0, 2]) == 2 # (0-(-1))^2 + (-1-0)^2 + (2-2)^2 = 1 + 1 + 0 = 2 assert sum_squared_diffs([], []) == 0 ``` Edge Cases to Consider: - Lists with all identical elements. - Lists with all zero elements. - Lists of large length with large integer values.","solution":"def sum_squared_diffs(list1, list2): Returns the sum of squared differences between corresponding elements of two lists. return sum((x - y) ** 2 for x, y in zip(list1, list2))"},{"question":"# Coding Challenge: Transform Matrix to Zero Matrix **Objective:** Given an `m x n` matrix, write a function that sets the entire row and column to zero if an element in the matrix is zero. Your task is to implement the core functionality to modify the matrix in-place to achieve this transformation. **Function Signature:** ```python def set_zeroes(matrix: List[List[int]]) -> None: pass ``` **Parameters:** * `matrix` (List[List[int]]): A 2D list representing an `m x n` matrix containing integers. **Returns:** * The function returns `None`, but the input matrix is modified in-place to meet the requirements. **Constraints:** 1. ( 1 leq m, n leq 200 ) 2. Matrix elements are assumed to be integers. **Example:** ```python matrix = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] set_zeroes(matrix) # The matrix is modified to: # [ # [1, 0, 1], # [0, 0, 0], # [1, 0, 1] # ] matrix = [ [0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5] ] set_zeroes(matrix) # The matrix is modified to: # [ # [0, 0, 0, 0], # [0, 4, 5, 0], # [0, 3, 1, 0] # ] ``` **Requirements:** 1. Accurately iterate over the matrix to identify the positions of zero elements. 2. Efficiently mark the rows and columns that need to be zeroed. 3. Ensure the modification happens in-place without using additional space for another matrix. 4. Handle edge cases such as matrices with no zero elements and completely zero matrices. **Tips:** * Consider using sets to store the indices of rows and columns that contain zeros to avoid additional space complexity. * Take care with in-place modification to avoid prematurely zeroing elements before all zeros have been identified. Good luck!","solution":"def set_zeroes(matrix): # Find the rows and columns that need to be set to zero zero_rows = set() zero_cols = set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: zero_rows.add(i) zero_cols.add(j) # Set the found rows to zero for row in zero_rows: for j in range(len(matrix[0])): matrix[row][j] = 0 # Set the found columns to zero for col in zero_cols: for i in range(len(matrix)): matrix[i][col] = 0"},{"question":"# Coding Assessment Question: **Objective**: Write a function that removes duplicates from a list of integers while preserving the original order of the remaining elements. This will demonstrate your understanding of list manipulation, iteration, and set operations. # Problem Statement: Implement the function `remove_duplicates(nums: List[int]) -> List[int]` which takes a list of integers `nums` and returns a new list with all duplicates removed, maintaining the order of their first occurrences. # Function Signature: ```python def remove_duplicates(nums: List[int]) -> List[int]: ``` # Input: - `nums` (List[int]): The input list of integers that may contain duplicates. # Output: - List[int]: A new list with duplicates removed, preserving the order of their first appearances. # Constraints: - The length of the list `nums` is between 0 and 10^5. - The integers in the list `nums` are within the range of -10^6 to 10^6. # Examples: - `remove_duplicates([1, 2, 2, 3, 4, 2, 5])` -> [1, 2, 3, 4, 5] - `remove_duplicates([4, 1, 2, 1, 4, 5, 4, 6])` -> [4, 1, 2, 5, 6] - `remove_duplicates([])` -> [] - `remove_duplicates([7, 7, 7, 7, 7])` -> [7] - `remove_duplicates([-1, -2, -2, 0, 0, 5, -2])` -> [-1, -2, 0, 5] # Edge Cases to Consider: - The function should handle an empty list. - The function should handle a list where all elements are the same. - The function should efficiently process a large list size, ensuring good performance. # Notes: - You may assume that the input list `nums` can contain negative numbers and zero. - The function should not use additional libraries or convert the list to a set, as that would not maintain the order of first occurrences. Use a manual approach to achieve the desired result.","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from a list while maintaining original order of first occurrences. Args: nums (List[int]): The input list of integers that may contain duplicates. Returns: List[int]: A new list with duplicates removed, preserving the order of first appearances. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Problem: Customer Order Management You are tasked with creating a class to manage customer orders for an e-commerce platform. Each order includes a unique order ID, customer ID, a list of items (with associated quantities and prices), and a status that can be either \\"pending\\", \\"shipped\\", or \\"delivered\\". Your task is to create a class `OrderManagement` with the following methods: 1. **add_order**: Adds a new order to the system. 2. **update_status**: Updates the status of an existing order. 3. **calculate_total**: Calculates the total cost of an order. 4. **remove_order**: Removes an order from the system. # Input - `order_id` (string): Unique ID for the order. - `customer_id` (string): Unique ID for the customer. - `items` (list of tuples): Each tuple contains item name (string), quantity (int), and price (float). - `status` (string): The status of the order, either \\"pending\\", \\"shipped\\", or \\"delivered\\". # Output - For `add_order` and `remove_order`, return a boolean indicating success. - For `update_status`, return the updated order status. - For `calculate_total`, return the total cost (float) of the order. # Constraints - `order_id`, `customer_id`, and `status` are non-empty strings. - `items` list is non-empty, and each item tuple contains valid data. - Status can only be \\"pending\\", \\"shipped\\", or \\"delivered\\". - Ensure methods handle attempts to access or modify non-existent orders gracefully. # Example Usage ```python # Initialize order_manager = OrderManagement() # Add Order order_manager.add_order(\\"id001\\", \\"cust01\\", [(\\"item1\\", 2, 10.0), (\\"item2\\", 1, 15.0)], \\"pending\\") # Update Status order_manager.update_status(\\"id001\\", \\"shipped\\") # Calculate Total total = order_manager.calculate_total(\\"id001\\") print(total) # Expected output: 35.0 # Remove Order order_manager.remove_order(\\"id001\\") ``` # Implementation Tips - Use a dictionary to store orders with `order_id` as the key. - Each order can be represented as another dictionary containing customer ID, items list, and status. - Ensure `add_order` does not overwrite an existing order, and `update_status` only accepts valid statuses. - For `calculate_total`, ensure it properly multiplies item quantities by their prices and sums the results. - Implement appropriate error handling for non-existent `order_id` in relevant methods.","solution":"class OrderManagement: def __init__(self): self.orders = {} def add_order(self, order_id, customer_id, items, status): if order_id in self.orders: return False if status not in [\\"pending\\", \\"shipped\\", \\"delivered\\"]: return False self.orders[order_id] = { \\"customer_id\\": customer_id, \\"items\\": items, \\"status\\": status } return True def update_status(self, order_id, status): if order_id not in self.orders: return None if status not in [\\"pending\\", \\"shipped\\", \\"delivered\\"]: return None self.orders[order_id][\\"status\\"] = status return self.orders[order_id][\\"status\\"] def calculate_total(self, order_id): if order_id not in self.orders: return None total = 0.0 for item in self.orders[order_id][\\"items\\"]: total += item[1] * item[2] # quantity * price return total def remove_order(self, order_id): if order_id not in self.orders: return False del self.orders[order_id] return True"},{"question":"# Problem Statement Given a string of letters, find the longest subsequence which forms a valid English word according to a provided dictionary. Return that word. If there are multiple words of the same maximum length, return the lexicographically smallest one. A subsequence differs from a substring, as the characters in the subsequence do not need to be contiguous but must appear in the same relative order. **Function to Implement** Implement the following function in Python: ```python def find_longest_word_subsequence(s: str, dictionary: List[str]) -> str: Given a string `s` and a list of strings `dictionary`, find the longest word from the dictionary that can be formed by taking a subsequence of `s`. If multiple words have the same length, return the lexicographically smallest one. :param s: The input string :param dictionary: A list of valid English words :return: The longest valid word that is a subsequence of the given string ``` Input: - `s` (str): The input string, 1 <= len(s) <= 1000. - `dictionary` (List[str]): A list of valid English words, 1 <= len(dictionary) <= 1000, 1 <= len(dictionary[i]) <= 100. Output: - The longest word that can be formed as a subsequence of `s`. If multiple words have the same length, return the smallest lexicographical one. Constraints: - The input string `s` will consist of lowercase letters. - Each word in the dictionary will consist of lowercase letters. - All words in the dictionary are distinct. # Example **Example 1:** ```python s = \\"abppplee\\" dictionary = [\\"able\\", \\"ale\\", \\"apple\\", \\"bale\\", \\"kangaroo\\"] ``` **Output:** ``` apple ``` **Explanation:** The longest word from the dictionary that can be formed by subsequence is \\"apple\\". **Example 2:** ```python s = \\"babgbag\\" dictionary = [\\"bag\\", \\"bagger\\", \\"gab\\", \\"grab\\"] ``` **Output:** ``` bag ``` **Explanation:** Although \\"bagger\\" and \\"gab\\" can be formed, \\"bag\\" is the longest option, and among the longest words, it is also the lexicographically smallest one. Make sure your solution returns the correct longest word subsequence and handles the lexicographical order correctly when there are ties.","solution":"from typing import List def is_subsequence(s: str, word: str) -> bool: Helper function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def find_longest_word_subsequence(s: str, dictionary: List[str]) -> str: Given a string `s` and a list of strings `dictionary`, find the longest word from the dictionary that can be formed by taking a subsequence of `s`. If multiple words have the same length, return the lexicographically smallest one. :param s: The input string :param dictionary: A list of valid English words :return: The longest valid word that is a subsequence of the given string longest_word = \\"\\" for word in dictionary: if is_subsequence(s, word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"# Graph Connectivity Check # Objective: Implement the `Graph` class to determine if an undirected graph is connected. # Constraints: 1. The graph can have up to 100,000 nodes. 2. The edges are undirected and can have up to 1,000,000 edges. 3. Node IDs are given as integers starting from 1 up to the number of nodes. 4. The graph may contain isolated nodes. # Requirements: 1. Implement methods to: * Add nodes and edges to the graph. * Determine if the graph is connected (all nodes can reach all other nodes). # Input: - List of edges as pairs of integers `(u, v)` representing an undirected edge between nodes `u` and `v`. - Number of nodes in the graph as an integer. # Output: - Return `True` if the graph is connected, and `False` otherwise. # Example: ```python graph = Graph(5) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) graph.add_edge(4, 5) print(graph.is_connected()) # Should return True graph.add_edge(1, 3) graph = Graph(3) print(graph.is_connected()) # Should return False if no edges are added yet ``` # Edge Cases: 1. A graph with no edges and multiple nodes (should return `False` unless there\'s only one node). 2. Fully connected graph (should return `True`). 3. Large sparse graph with many isolated nodes (should return `False`). # Performance Notes: - Efficient handling of memory for large number of nodes and edges. - Use appropriate data structures to manage graph representations (e.g., adjacency list). - Implement algorithms that ensure connectivity check runs efficiently even for the maximum constraint limits.","solution":"class Graph: def __init__(self, nodes): self.nodes = nodes self.adj_list = {i: [] for i in range(1, nodes + 1)} def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def is_connected(self): visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in self.adj_list[current]: if neighbor not in visited: stack.append(neighbor) # Find the first node with at least one connection for node in self.adj_list: if self.adj_list[node]: break else: return self.nodes == 1 dfs(node) return len(visited) == self.nodes"},{"question":"# Coding Assessment Question: Matrix Spiral Traversal Scenario: Matrix problems are a common exercise to hone multi-dimensional data manipulation skills. One interesting way to traverse a matrix is in a spiral order, starting from the top-left corner and proceeding clockwise. Problem Statement: Write a Python function `spiral_traverse(matrix)` that takes a `n x m` matrix (a list of lists) and returns a list containing all the elements of the matrix in spiral order. Input: - A 2D list `matrix` of dimensions `n` by `m`, where `n` and `m` are the number of rows and columns, respectively. Output: - A list of matrix elements in spiral order. Constraints: * You may assume that the matrix is non-empty and has at least one row and one column. * The width and height of the matrix will not exceed 100 elements. * The matrix can contain any integer values. Example: Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ```python [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Tips: 1. Consider dividing the problem into traversing the perimeter of the matrix, followed by the sub-matrix that\'s left. 2. Think about the direction you\'re moving (right, down, left, up) and how to shift directions at the edges. 3. Use boundary variables to keep track of the frames you have already visited. **Good Luck!**","solution":"def spiral_traverse(matrix): This function traverses the input 2D list in spiral order. :param matrix: List[List[int]], the input matrix. :return: List[int], the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"# Problem You are tasked with implementing a basic inventory management system for a small retail shop. The shop needs to track the stock levels of various products, process sales, and generate restock notifications. Your task is to complete the function implementation that initializes the inventory with a set of products, processes sales transactions, and generates a list of products that need to be restocked. # Function Signature ```python def manage_inventory( initial_stock: dict, sales: list, restock_threshold: int ) -> dict: pass ``` # Parameters - **initial_stock** `(dict)`: A dictionary where keys are product names (strings) and values are the initial stock levels (integers) for those products (0 ≤ stock ≤ 1000). - **sales** `(list)`: A list of tuples, where each tuple contains a product name (string) and the quantity sold (integer) in a single transaction (0 ≤ quantity ≤ 100). - **restock_threshold** `(int)`: The stock level threshold below which a product needs to be restocked (0 ≤ restock_threshold ≤ 100). # Returns - **result** `(dict)`: A dictionary with two keys: `updated_stock` and `restock`. - `updated_stock` is a dictionary with the updated stock levels of the products after processing all sales. - `restock` is a list of product names that need to be restocked. # Detailed Requirements 1. **Initialization**: - Start with the `initial_stock` provided. 2. **Processing Sales**: - For each sale in the `sales` list, subtract the quantity sold from the stock level of the corresponding product. - If a sale exceeds the available stock, sell only the available stock (i.e., stock cannot go negative). 3. **Restock Notification**: - After processing all sales, identify products whose stock levels are below the `restock_threshold`. - Include these products in the `restock` list. 4. **Return Updated Stock and Restock List**: - Return the `updated_stock` dictionary and the `restock` list as part of the final result. # Example ```python initial_stock = { \\"apples\\": 50, \\"bananas\\": 20, \\"oranges\\": 75 } sales = [ (\\"apples\\", 10), (\\"bananas\\", 5), (\\"apples\\", 45), (\\"oranges\\", 80) ] restock_threshold = 10 result = manage_inventory( initial_stock, sales, restock_threshold ) print(result) # Output: {\'updated_stock\': {\'apples\': 0, \'bananas\': 15, \'oranges\': 0}, \'restock\': [\'apples\', \'oranges\']} ``` In this example, the function initializes the stock levels, processes each sale, updates the stock levels accordingly, and generates a list of products that need to be restocked. The final output reflects the updated stock and the products in need of restocking.","solution":"def manage_inventory(initial_stock: dict, sales: list, restock_threshold: int) -> dict: updated_stock = initial_stock.copy() # Process each sale for product, quantity_sold in sales: if product in updated_stock: updated_stock[product] = max(updated_stock[product] - quantity_sold, 0) # Generate the restock list restock = [product for product, stock in updated_stock.items() if stock < restock_threshold] return { \\"updated_stock\\": updated_stock, \\"restock\\": restock }"},{"question":"# Coding Assessment Question Context Develop a function to merge two non-decreasing sorted linked lists into one non-decreasing sorted linked list efficiently. Ensure that the function does not create any new nodes and only reuses the provided nodes. Requirements Modify the `merge_two_sorted_lists` function to: 1. Take two linked lists represented by `ListNode` objects and merge them into one sorted linked list. 2. Ensure that the merged linked list preserves the non-decreasing order. 3. Avoid additional allocations by reusing the input list nodes. Constraints * Each ListNode will have two attributes: `val` (an integer) and `next` (a reference to the next node or `None`). * It is guaranteed that both input lists are in non-decreasing order. * There may be zero or more nodes in each input list. Input & Output # Input * `l1`: ListNode — the head node of the first sorted linked list. * `l2`: ListNode — the head node of the second sorted linked list. # Output * Returns a ListNode — the head of the merged sorted linked list. Example ```python >>> class ListNode: >>> def __init__(self, x): >>> self.val = x >>> self.next = None >>> l1 = ListNode(1) >>> l1.next = ListNode(3) >>> l1.next.next = ListNode(5) >>> l2 = ListNode(2) >>> l2.next = ListNode(4) >>> l2.next.next = ListNode(6) >>> merged = merge_two_sorted_lists(l1, l2) >>> while merged: >>> print(merged.val, end=\' \') >>> merged = merged.next 1 2 3 4 5 6 ``` Function Signature ```python def merge_two_sorted_lists( l1: ListNode, l2: ListNode ) -> ListNode: pass ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Take two sorted linked lists, and merge them into one sorted linked list. # Create a dummy node to serve as the starting point of the new list dummy = ListNode(0) current = dummy # Traverse both lists and stitch them together while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If one of the lists is not empty, directly append it to the merged list if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"# Priority Queue - Handling Task Scheduling You are tasked with developing a PriorityQueue class that handles scheduling tasks based on their priority. Implement methods to insert tasks, remove the highest priority task, and view the current highest priority task without removing it. Tasks are represented by a string and their priority is an integer value where a lower value represents a higher priority. **Expected Input and Output Formats**: * **Input**: Methods should accept task descriptions (strings) and priority values (integers). * **Output**: Methods should return appropriate values depending on the operation performed. **Constraints/Limitations**: * The priority queue should allow for efficient insertion and removal of tasks. * Priority values are unique among tasks in the queue. **Performance Requirements**: * All operations should be optimized to ensure O(log N) complexity where N is the number of tasks. * Use an appropriate data structure to maintain the priority order. **Function and Class Signatures**: ```python class PriorityQueue: def insert(self, task: str, priority: int) -> None: ... def remove_highest_priority(self) -> str: ... def view_highest_priority(self) -> str: ... ``` # Example: ```python # Example usage and validation pq = PriorityQueue() pq.insert(\\"Task A\\", 3) pq.insert(\\"Task B\\", 1) pq.insert(\\"Task C\\", 2) print(pq.view_highest_priority()) # Should output Task B print(pq.remove_highest_priority()) # Should output Task B print(pq.view_highest_priority()) # Should output Task C # Handle case with no tasks empty_pq = PriorityQueue() print(empty_pq.view_highest_priority()) # Should raise an appropriate exception ``` **Notes**: * Provide handling for cases where methods are called on an empty queue. * Ensure that the internal data structure maintains tasks in the correct priority order efficiently.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, task: str, priority: int) -> None: Inserts a new task with the given priority into the priority queue. heapq.heappush(self.heap, (priority, task)) def remove_highest_priority(self) -> str: Removes and returns the highest priority task from the priority queue. if not self.heap: raise IndexError(\\"remove_highest_priority from an empty priority queue\\") return heapq.heappop(self.heap)[1] def view_highest_priority(self) -> str: Returns the highest priority task without removing it from the priority queue. if not self.heap: raise IndexError(\\"view_highest_priority from an empty priority queue\\") return self.heap[0][1]"},{"question":"# Repeated Substring Pattern Checker Scenario You are tasked with developing a function for a string analysis tool that checks if a given string can be constructed by repeating a substring of it. This check could be useful in various applications such as data compression or pattern recognition. Implement a function that determines whether a string can be constructed by repeating a smaller substring at least once. Function Signature ```python def repeated_substring_pattern(s: str) -> bool: ``` Input * `s` (str): A non-empty string of length (n) where (1 leq n leq 10^4). Output * Returns a boolean indicating whether the string can be constructed by repeating a smaller substring. Constraints * The function should have a time complexity of (O(n)). * The string only consists of lowercase alphabetic characters. Example **Input:** ```python s = \\"abab\\" ``` **Output:** ```python True ``` **Input:** ```python s = \\"aba\\" ``` **Output:** ```python False ``` **Input:** ```python s = \\"abcabcabcabc\\" ``` **Output:** ```python True ``` Explanation * The string \\"abab\\" can be constructed by repeating the substring \\"ab\\". * The string \\"aba\\" cannot be constructed by repeating any substring. * The string \\"abcabcabcabc\\" can be constructed by repeating the substring \\"abc\\".","solution":"def repeated_substring_pattern(s: str) -> bool: Determines if the input string can be constructed by repeating a smaller substring at least once. Args: s (str): The input string. Returns: bool: True if the string can be constructed by repeating a smaller substring, otherwise False. # Create a new string by concatenating the original string to itself doubled_s = s + s # Remove the first and the last character from the doubled string modified_doubled_s = doubled_s[1:-1] # Check if the original string is a substring of the modified doubled string return s in modified_doubled_s"},{"question":"**Context**: In the field of natural language processing, text normalization is a crucial preprocessing step to improve the performance of machine learning models. One common normalization task is to convert written text to lowercase, remove punctuation, and reduce multiple spaces to a single space. **Task**: Write a function `normalize_text` that takes a string containing a sentence and returns the normalized version of that sentence. The normalization process involves converting all characters to lowercase, removing any punctuation marks, and reducing any instances of multiple spaces to a single space. **Input Format**: - A string `sentence` containing the input text. **Output Format**: - A string which is the normalized version of the input text. **Function Signature**: ```python def normalize_text(sentence: str) -> str: pass ``` **Examples**: ```python >>> normalize_text(\\"Hello, World!!!\\") \'hello world\' >>> normalize_text(\\"Normalize this text, please.\\") \'normalize this text please\' ``` **Constraints**: - The input sentence will only contain ASCII characters. - The length of the input sentence will be of size up to (10^4) characters.","solution":"import re def normalize_text(sentence: str) -> str: Normalizes the input sentence by converting to lowercase, removing punctuation, and reducing multiple spaces to a single space. Args: sentence (str): The input sentence. Returns: str: The normalized version of the input sentence. # Convert to lowercase sentence = sentence.lower() # Remove punctuation sentence = re.sub(r\'[^ws]\', \'\', sentence) # Reduce multiple spaces to a single space sentence = re.sub(r\'s+\', \' \', sentence) # Strip leading and trailing spaces sentence = sentence.strip() return sentence"},{"question":"# Coding Assessment Question: Context: Natural language processing tasks often involve basic text transformations and analyses which can help in various applications like sentiment analysis, data cleaning, and preparation. In this task, you are required to write a function to prepare a text dataset by performing various preprocessing steps. Task: Write a Python function named `preprocess_text_data` that reads a text file, performs several preprocessing steps, and writes the cleaned text to a new file. The preprocessing tasks include converting to lowercase, removing numbers, removing punctuation and special characters, and replacing multiple spaces with a single space. Function Signature: ```python def preprocess_text_data(input_filepath: str, output_filepath: str) -> None: ``` Inputs: * **input_filepath**: A string representing the file path of the input text file. * **output_filepath**: A string representing the file path where the preprocessed text should be saved. Outputs: * This function should not return anything. Instead, it should save the preprocessed text to the specified output file. Constraints: * Handle file I/O errors gracefully and ensure the input and output file paths are valid. * Use regular expressions where appropriate to clean the text efficiently. Example: ```python preprocess_text_data(\\"raw_text.txt\\", \\"cleaned_text.txt\\") ``` After running the function, the content of \\"raw_text.txt\\" should be read, processed, and written to \\"cleaned_text.txt\\" with all specified preprocessing done. For example, the text \\"Hello World! 123 This is a sample text...\\" would be transformed to \\"hello world this is a sample text\\".","solution":"import re def preprocess_text_data(input_filepath: str, output_filepath: str) -> None: try: with open(input_filepath, \'r\') as file: text = file.read() # Convert to lowercase text = text.lower() # Remove numbers text = re.sub(r\'d+\', \'\', text) # Remove punctuation and special characters text = re.sub(r\'[^ws]\', \'\', text) # Replace multiple spaces with a single space text = re.sub(r\'s+\', \' \', text).strip() with open(output_filepath, \'w\') as file: file.write(text) except FileNotFoundError: print(f\\"The file {input_filepath} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"# Coding Assessment Question Objective: To assess your understanding of dynamic programming and optimization techniques, implement a function to determine the maximum sum of non-adjacent elements in a list. Scenario: In many real-world applications, including finance and operations research, selecting non-adjacent elements to optimize a given objective is a common problem. For this task, you need to identify the maximum sum obtainable from a list of integers, provided the selected integers are not adjacent in the original list. Efficiency is key as the list can be lengthy. Requirements: 1. **Function Name**: `max_non_adjacent_sum` 2. **Input**: A list of integers `nums` where `1 ≤ len(nums) ≤ 10^4` and `-10^4 ≤ nums[i] ≤ 10^4`. 3. **Output**: An integer representing the maximum sum of non-adjacent elements. 4. **Constraints**: Your algorithm should efficiently handle larger lists up to 10,000 elements and should not use excessive memory. 5. **Performance**: Aim for a solution with linear time complexity O(n). Example: ```python >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 # (selecting 3, 10, and 2) >>> max_non_adjacent_sum([3, 7, 4, 6, 5]) 13 # (selecting 3 and 7, 0r 7 and 5) >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 # (selecting 1 and 5, or 3 and 5) >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 # (selecting 5, 100, and 5) ``` Edge Cases to Consider: - Ensure the function handles small inputs like an empty list or a list with a single element correctly. - Ensure the function accounts for negative values correctly. - Consider the scenarios where all elements are negative or positive. ```python def max_non_adjacent_sum(nums: [int]) -> int: # Your implementation here pass # Test cases print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Expected: 15 print(max_non_adjacent_sum([3, 7, 4, 6, 5])) # Expected: 13 print(max_non_adjacent_sum([-2, 1, 3, -4, 5])) # Expected: 8 print(max_non_adjacent_sum([5, 5, 10, 100, 10, 5])) # Expected: 110 ```","solution":"def max_non_adjacent_sum(nums: [int]) -> int: Returns the maximum sum of non-adjacent elements in the list. # Edge case for empty list if not nums: return 0 # Edge case for single element list if len(nums) == 1: return max(0, nums[0]) # Initializing values for max sums of non-adjacent elements prev1, prev2 = 0, 0 for num in nums: # Calculate the new max sum including the current number current = max(prev1, prev2 + num) # Update the previous sums for the next iteration prev2 = prev1 prev1 = current return prev1"},{"question":"# Scenario: A company wants you to develop a monitoring system to detect anomalies in their data stream. They use a sliding window to analyze recent data points. Specifically, they need a method to identify if a stream of integer data contains a duplicate value within a specified range of recent data points. # Problem Statement: Your task is to implement a method called `contains_nearby_duplicate` for the `DataStream` class which checks if there are any duplicate integers within a specified sliding window size. Implementation Requirements: - The method `contains_nearby_duplicate` should be added to the `DataStream` class. - It should take two parameters: - `data`: a list of integers representing the data stream. - `k`: an integer representing the size of the sliding window. - It should return a boolean value: - `True` if the data stream contains duplicates within the sliding window size `k`. - `False` otherwise. # Constraints: 1. The length of the list `data` is not greater than 100,000. 2. The integers in `data` can be positive, negative, or zero. 3. The sliding window size `k` is a non-negative integer not greater than the length of `data`. Input: - The method `contains_nearby_duplicate` will receive the list `data` and the integer `k`. Output: - A boolean value (`True` or `False`). # Example: Assuming you have a `DataStream` instance as follows: ```python stream = DataStream() data = [1, 2, 3, 1, 2, 3] k = 3 ``` After implementing `contains_nearby_duplicate`, calling `stream.contains_nearby_duplicate(data, k)` will return `True` because the integer `1` is repeated within a sliding window of size 3 (indices 0 and 3). # Instructions: 1. Add your method to the `DataStream` class. 2. Ensure it correctly identifies duplicates within the specified sliding window size. 3. Check edge cases such as empty data streams, sliding window size of zero, and data streams with no duplicates. Good luck!","solution":"class DataStream: def contains_nearby_duplicate(self, data, k): Checks if there are any duplicates within the sliding window size k. :param data: List of integers representing the data stream. :param k: Integer representing the size of the sliding window. :return: True if duplicates exist within sliding window size k, else False. seen = {} for index, value in enumerate(data): if value in seen and index - seen[value] <= k: return True seen[value] = index return False"},{"question":"# Coding Question: Dynamic Spreadsheet Formula Evaluator Imagine you are developing a simplified spreadsheet application, and you need to implement a dynamic formula evaluator. The application should process and evaluate custom formulas inserted in a grid-based spreadsheet. Implement a function `calculate_formula` to evaluate given formulas based on their dependencies, and compute values for all cells accurately, accounting for the dependencies between cells. Function Signature ```python def calculate_formula(grid: List[List[Union[str, int]]]) -> List[List[Union[int, float]]]: ``` Parameters - **grid**: A 2D list representing the spreadsheet where each element can be: - An integer or float number, representing a value. - A string starting with `=` followed by an arithmetic expression. The expression can include references to other cells (e.g., `=A1 + B2`). The cells are referenced by a combination of letters and numbers where the letter designates the column (starting from \'A\' for the 1st column) and the number designates the row (starting from 1 for the first row). Returns - A 2D list of the same dimensions with each cell containing the calculated value (as integer or float). Constraints - **Grid** dimensions range from 1x1 to 10x10. - **Formulas** can include the operations addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). - Cell references within the expressions are guaranteed to be valid and refer to existing cells within the grid. - Circular references are not allowed. - Ensure handling division by zero in the formulas appropriately (you can return `float(\'inf\')` in such cases). Example Usage ```python spreadsheet = [ [5, \'=A1 + 10\'], [3, \'=A1 * B1\'] ] print(calculate_formula(spreadsheet)) # Output: [[5, 15], [3, 75]] ``` Additional Notes - Assume that all cell references and formulas are provided in valid format. - Implement robust error handling to preclude invalid calculations or references. Return `float(\'inf\')` in case of division by zero. - Consider all edge cases, such as empty cells or references to empty cells, which can be treated as value `0`.","solution":"from typing import List, Union def evaluate_expression(expr: str, grid, values_cache): if expr in values_cache: return values_cache[expr] letters = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\' def get_value(cell): col = letters.index(cell[0]) row = int(cell[1:]) - 1 return evaluate_cell(grid[row][col], grid, values_cache) tokens = expr.split() new_expr = \'\' for token in tokens: if token[0] in letters and token[1:].isdigit(): new_expr += str(get_value(token)) else: new_expr += token try: result = eval(new_expr) except ZeroDivisionError: result = float(\'inf\') values_cache[expr] = result return result def evaluate_cell(cell, grid, values_cache): if isinstance(cell, (int, float)): return cell if cell[0] == \'=\': return evaluate_expression(cell[1:], grid, values_cache) raise ValueError(f\\"Unrecognized cell content: {cell}\\") def calculate_formula(grid: List[List[Union[str, int]]]) -> List[List[Union[int, float]]]: rows = len(grid) cols = len(grid[0]) if rows else 0 values_cache = {} result = [] for r in range(rows): result_row = [] for c in range(cols): result_row.append(evaluate_cell(grid[r][c], grid, values_cache)) result.append(result_row) return result"},{"question":"# Coding Question: Sum of Divisors of a List Write a function that calculates the sum of divisors for each integer in a list and returns a new list with these sums. The sum of divisors of an integer `n` is the sum of all positive integers less than or equal to `n` that divide `n` without leaving a remainder. Function Signature ```python def sum_of_divisors_list(nums: List[int]) -> List[int]: :param nums: A list of integers :return: A list containing the sum of divisors for each integer in the input list Note: This function expects a non-empty list of positive integers >>> sum_of_divisors_list([1, 2, 3, 4, 5]) [1, 3, 4, 7, 6] >>> sum_of_divisors_list([12]) [28] >>> sum_of_divisors_list([16, 18, 19]) [31, 39, 20] >>> sum_of_divisors_list([]) Traceback (most recent call last): ... ValueError: Input list must not be empty >>> sum_of_divisors_list([-3, 5]) Traceback (most recent call last): ... ValueError: All elements in the input list must be positive integers >>> sum_of_divisors_list([3.5, 5]) Traceback (most recent call last): ... TypeError: All elements in the input list must be integers pass ``` # Constraints 1. The input `nums` should be a non-empty list of positive integers. 2. Handle scenarios where the input list is empty by raising an appropriate error. 3. Handle scenarios where the input list contains non-integer or non-positive values by raising appropriate errors. # Task Implement the `sum_of_divisors_list` function that: - Takes `nums` as an argument, which is a list of integers. - Returns a new list where each element is the sum of divisors of the corresponding element in the input list. *Hints*: - Define a helper function to calculate the sum of divisors for a single number. - Validate the input before proceeding with the calculations.","solution":"from typing import List def sum_of_divisors_list(nums: List[int]) -> List[int]: Calculates the sum of divisors for each integer in a list and returns a new list with these sums. :param nums: A list of integers :return: A list containing the sum of divisors for each integer in the input list if not nums: raise ValueError(\\"Input list must not be empty\\") if any(not isinstance(x, int) for x in nums): raise TypeError(\\"All elements in the input list must be integers\\") if any(x <= 0 for x in nums): raise ValueError(\\"All elements in the input list must be positive integers\\") def sum_of_divisors(n: int) -> int: return sum(i for i in range(1, n + 1) if n % i == 0) return [sum_of_divisors(num) for num in nums]"},{"question":"# Problem Statement You are given a sequence of integers and a target integer. Your task is to find the number of distinct pairs of integers in the sequence that sum up to the target integer. A pair is considered distinct if there are no repeated indices, even if they comprise the same values. # Your Task Implement the function `count_pairs_with_sum(arr: list, target: int) -> int` which computes and returns the number of distinct pairs that sum up to the target integer. # Input Format - `arr`: A list of integers. - `target`: An integer representing the target sum. # Output Format Returns an integer representing the number of distinct pairs that sum up to the target integer. # Constraints - The elements in the list and the target integer can be both positive and negative. - The length of the list is between 2 and 10^5. - Each integer in the list is between -10^9 and 10^9. Here is a basic structure to get you started: ```python def count_pairs_with_sum(arr: list, target: int) -> int: # Your implementation here pass if __name__ == \\"__main__\\": arr = [1, 3, 2, 2, -1, 4, 0, 3] target = 4 result = count_pairs_with_sum(arr, target) print(f\\"The number of distinct pairs is: {result}\\") ``` # Example For `arr = [1, 3, 2, 2, -1, 4, 0, 3]` and `target = 4`, calling `count_pairs_with_sum(arr, target)` should return `3`. The valid pairs are (1, 3), (1, 3), and (2, 2). For `arr = [1, 1, 1, 1]` and `target = 2`, calling `count_pairs_with_sum(arr, target)` should return `6`. The valid pairs are all pairs of \'1\'s at different indices. # Notes - Ensure your solution handles all edge cases and utilizes efficient computation methods as much as possible. - Clearly comment your code to explain the logic behind key steps.","solution":"def count_pairs_with_sum(arr: list, target: int) -> int: Returns the number of distinct pairs that sum up to the target integer. counts = {} pair_count = 0 # Count occurrences of each number for number in arr: counts[number] = counts.get(number, 0) + 1 # Check for pairs that sum up to target for number in list(counts): complement = target - number if complement in counts: if number == complement: # Handling pairs with the same number (n, n) pair_count += counts[number] * (counts[number] - 1) // 2 elif complement > number: # Only count each pair once (n, m) where n < m pair_count += counts[number] * counts[complement] return pair_count"},{"question":"# Coding Assessment Question Context: In the world of competitive programming, understanding matrix operations can be crucial. A common operation is rotating an image represented as an `N x N` matrix, where each pixel in the image is an integer value. Problem: Write a function `rotate_matrix` that takes a square matrix as input and rotates it 90 degrees clockwise. Additionally, write a function `is_rotated_equal` to check if applying the 90-degree rotation to a given input matrix results in another given matrix. Function Signatures: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass def is_rotated_equal(matrix: List[List[int]], target: List[List[int]]) -> bool: pass ``` Input: * `matrix`: A square matrix (2D list) with dimensions `N x N` containing integers. * `target`: Another square matrix (2D list) with the same dimensions `N x N` that you need to compare against the rotated input matrix. Output: * For `rotate_matrix`: A square matrix representing the input matrix rotated 90 degrees clockwise. * For `is_rotated_equal`: A boolean indicating whether the rotation of the matrix equals the target matrix. Constraints: * The dimensions of the matrices will be between 1 and 1000 (inclusive). * Each matrix element will be an integer in the range [-10^4, 10^4]. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] matrix = [ [1, 2], [3, 4] ] target = [ [3, 1], [4, 2] ] is_rotated_equal(matrix, target) # Output: True matrix = [ [1, 2], [3, 4] ] target = [ [4, 3], [2, 1] ] is_rotated_equal(matrix, target) # Output: False ``` Instructions: 1. Implement the `rotate_matrix` function that will rotate an `N x N` matrix 90 degrees clockwise. 2. Implement the `is_rotated_equal` function to verify if a rotated matrix is equal to a target matrix. 3. Ensure your code handles edge cases such as small matrices or matrices with identical rows or columns.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given N x N matrix by 90 degrees clockwise. N = len(matrix) rotated = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N - i - 1] = matrix[i][j] return rotated def is_rotated_equal(matrix: List[List[int]], target: List[List[int]]) -> bool: Checks if the matrix rotated 90 degrees clockwise is equal to the target matrix. return rotate_matrix(matrix) == target"},{"question":"# Coding Challenge: **Problem Statement:** You are given a list of integers. Your task is to find the longest subsequence of consecutive integers in the list. If there are multiple subsequences of the same length, return the subsequence that starts with the smallest integer. **Function Signature:** ```python def find_longest_consecutive_subsequence(nums: List[int]) -> List[int]: ``` **Input:** - A list of integers (nums) (0 ≤ len(nums) ≤ 1000, -10^6 ≤ nums[i] ≤ 10^6) **Output:** - A list of integers representing the longest subsequence of consecutive integers. **Constraints:** - The input list (nums) can contain both positive and negative integers, including duplicates and unsorted elements. **Examples:** ```python >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> find_longest_consecutive_subsequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> find_longest_consecutive_subsequence([10, 20, 30, 40]) [10] ``` **Explanation:** - Iterate through the list to find all starting points of consecutive sequences. - Use a set for quick look-up of integers to determine the presence of consecutive elements. - Track the length and starting point of each consecutive subsequence found. - Compare the lengths to find the longest subsequence and return it; if multiple are of the same length, the smallest starting element is chosen. **Solve this problem by implementing the `find_longest_consecutive_subsequence` function. Ensure the solution handles edge cases and performs efficiently given the constraints.**","solution":"from typing import List def find_longest_consecutive_subsequence(nums: List[int]) -> List[int]: if not nums: return [] num_set = set(nums) best_start = None best_length = 0 for num in num_set: if num - 1 not in num_set: # This is the start of a new sequence current_start = num current_length = 1 while num + current_length in num_set: current_length += 1 if (current_length > best_length or (current_length == best_length and current_start < best_start)): best_start = current_start best_length = current_length return [best_start + i for i in range(best_length)]"},{"question":"# Question: Pathfinding in a Grid You are working on a navigation system that helps a robot find the shortest path in a grid. The robot can only move up, down, left, or right. Some cells in the grid are impassable. Instructions 1. Implement a function `shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int`: * Takes a grid (2D list of integers where 0 represents a passable cell and 1 represents an impassable cell), a start coordinate, and an end coordinate. * Uses a pathfinding algorithm to find the shortest path from the start to the end cell. * Returns the length of the shortest path. If the path does not exist, return -1. 2. Assume the input grid is always a valid 2D list with at least one cell, and start and end coordinates are within the bounds of the grid. Constraints * The grid dimensions do not exceed 100x100 cells. * The start and end coordinates are always located in passable cells. Example ```python from typing import List, Tuple grid = [ [0, 0, 0, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0] ] start = (0, 0) end = (4, 4) output = shortest_path(grid, start, end) print(output) ``` Expected Output: ```python 8 ``` Write your solution in Python.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path in a grid from start to end using BFS. Args: grid (List[List[int]]): The grid representation (2D list) of the map. start (Tuple[int, int]): Starting position in the grid. end (Tuple[int, int]): Ending position in the grid. Returns: int: The length of the shortest path, or -1 if no path exists. # Helper function to check if a cell is within grid bounds and passable def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 # Directions we can move in the grid: (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize queue for BFS queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (current_x, current_y), dist = queue.popleft() # Check if we have reached the end if (current_x, current_y) == end: return dist # Explore all possible neighboring cells for direction in directions: new_x, new_y = current_x + direction[0], current_y + direction[1] if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), dist + 1)) # If we finished our BFS without finding the end, return -1 return -1"},{"question":"# Question: Binary Search Tree Enhancement Context: Consider a Binary Search Tree (BST) which supports insertion, deletion, and traversal operations. The insertion and deletion operations maintain the property of the BST: For any node with value `v`, all nodes in its left subtree have values less than `v`, and all nodes in its right subtree have values greater than `v`. Task: Extend the functionality of the existing BST class with the following new methods: 1. `find_kth_smallest(k)`: Find and return the k-th smallest element in the BST. 2. `is_balanced()`: Determine if the BST is height-balanced. A BST is height-balanced if the height of the two subtrees of every node never differs by more than 1. 3. `find_lca(n1, n2)`: Find the lowest common ancestor (LCA) of two nodes with values `n1` and `n2` in the BST. Implementation Details: - **find_kth_smallest(k)**: - Input: `k` (an integer representing the k-th smallest element to be found). - Output: The value of the k-th smallest element. - **is_balanced()**: - Input: None. - Output: Boolean value indicating whether the tree is balanced (`True`) or not (`False`). - **find_lca(n1, n2)**: - Input: `n1` (value of the first node), `n2` (value of the second node). - Output: Value of the lowest common ancestor (LCA). Constraints: - The input BST will have at most 10000 nodes. - Nodes are represented using unique integers. Example: ```python bst = BinarySearchTree() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) # Requirements print(bst.find_kth_smallest(3)) # Output: 15 (3rd smallest element in BST) print(bst.is_balanced()) # Output: True (The tree is balanced) print(bst.find_lca(5, 15)) # Output: 10 (Lowest common ancestor of 5 and 15) ``` This question maintains consistency with the provided example by expanding on familiar data structure concepts prominently used in computer science, such as Binary Search Trees. The additional methods introduced will test the candidate\'s understanding of tree traversal, search algorithms, and tree balance checks, all fundamental to data structures and algorithms.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_kth_smallest(self, k): def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] inorder_list = inorder_traversal(self.root) return inorder_list[k-1] if 0 < k <= len(inorder_list) else None def is_balanced(self): def check_balance(node): if node is None: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balanced = check_balance(self.root) return balanced def find_lca(self, n1, n2): def _find_lca(node, n1, n2): if node is None: return None if node.val < n1 and node.val < n2: return _find_lca(node.right, n1, n2) if node.val > n1 and node.val > n2: return _find_lca(node.left, n1, n2) return node lca_node = _find_lca(self.root, n1, n2) return lca_node.val if lca_node else None"},{"question":"# Problem Statement You are designing a booking system for a small hotel. Each day the hotel can accept a certain number of room bookings. For the simplicity of the problem, assume every booking is for one room and there is exactly one type of room available each day. The goal is to write a function that determines whether a new batch of bookings can be accepted for a given date based on the current reservations. Function Signature ```python def can_accept_bookings(current_bookings: int, new_reservations: int, max_capacity: int) -> bool: pass ``` # Input * `current_bookings` - an integer representing the number of current bookings for the given date. * `new_reservations` - an integer representing the number of new reservations requested for the given date. * `max_capacity` - an integer representing the maximum room capacity of the hotel for that date. # Output * Returns a boolean value: * `True` if all new reservations can be accommodated. * `False` if the sum of current bookings and new reservations exceeds maximum capacity. # Constraints * `current_bookings` will always be a non-negative integer. * `new_reservations` will always be a non-negative integer. * `max_capacity` will always be a positive integer. * `current_bookings` and `new_reservations` will be such that their sum logically fits in an integer. # Examples ```python >>> can_accept_bookings(current_bookings=20, new_reservations=5, max_capacity=25) True >>> can_accept_bookings(current_bookings=20, new_reservations=6, max_capacity=25) False >>> can_accept_bookings(current_bookings=0, new_reservations=25, max_capacity=25) True >>> can_accept_bookings(current_bookings=10, new_reservations=16, max_capacity=25) False >>> can_accept_bookings(current_bookings=25, new_reservations=0, max_capacity=25) True ``` # Notes * Handle edge cases where the number of new reservations exactly equals the remaining capacity. * Ensure proper validation of input constraints.","solution":"def can_accept_bookings(current_bookings: int, new_reservations: int, max_capacity: int) -> bool: Determines whether a new batch of bookings can be accepted for a given date based on current reservations. :param current_bookings: int - the number of current bookings. :param new_reservations: int - the number of new reservations requested. :param max_capacity: int - the maximum room capacity of the hotel. :return: bool - True if new reservations can be accommodated, False otherwise. # Calculate the total bookings if new reservations are accepted total_bookings = current_bookings + new_reservations # Check if the total bookings are within the max capacity return total_bookings <= max_capacity"},{"question":"Problem Description You are tasked with building a system to evaluate and compare the scores of players in a game of bowling. Each player has multiple games, and you need to determine the player with the highest total score. # Input - A list of strings, where each string represents the scores of a single player\'s games. Each line is formatted with the player\'s name followed by their scores in different games, separated by spaces. Scores for each game are integers. # Output - A string representing the name of the player with the highest total score. # Function Signature ```python def find_highest_scorer(players_scores: list[str]) -> str: pass ``` # Constraints - Each player has played at least one game. - There are no ties; one player will have the highest total score. # Example ```python players_scores = [ \\"Alice 150 200 180\\", \\"Bob 210 180 170\\", \\"Charlie 160 190 180\\" ] print(find_highest_scorer(players_scores)) # Output: \\"Bob\\" ``` # Notes - You must parse each player\'s scores, sum them up, and compare the totals to find the highest scorer. - Ensure that you handle cases with varying numbers of games per player properly.","solution":"def find_highest_scorer(players_scores: list) -> str: Determines the player with the highest total score from a list of player game scores. Arguments: players_scores -- A list of strings where each string includes a player\'s name followed by their scores in different games, separated by spaces. Returns: The name of the player with the highest total score. highest_scorer = \\"\\" highest_score = 0 for player_score in players_scores: parts = player_score.split() name = parts[0] scores = list(map(int, parts[1:])) total_score = sum(scores) if total_score > highest_score: highest_scorer = name highest_score = total_score return highest_scorer"},{"question":"# Problem Statement You have been provided with a code snippet that defines a function for merging two sorted linked lists into one sorted linked list. Each linked list is assumed to be in non-decreasing order. You are tasked with extending the functionality by writing a function that can merge `k` sorted linked lists into one sorted linked list: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: list[ListNode]) -> ListNode: pass ``` # Input - `lists` (list[ListNode]): A list of `k` linked lists, where each linked list is represented by its head node (which can be `None` if the linked list is empty). # Output - Returns the head node of the merged linked list sorted in non-decreasing order. # Constraints - The number of linked lists `k` will be between 1 and 1000. - Each linked list will contain at most 5000 nodes. - The value of each node in the linked lists will be an integer between -10^9 and 10^9. # Example ```python # Example linked list creation for input node1 = ListNode(1, ListNode(4, ListNode(5))) node2 = ListNode(1, ListNode(3, ListNode(4))) node3 = ListNode(2, ListNode(6)) lists = [node1, node2, node3] # Merging k sorted linked lists merged_head = merge_k_sorted_lists(lists) # Traversal of the merged linked list current = merged_head while current: print(current.val, end=\\" -> \\") current = current.next # Expected output: \\"1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> \\" ``` # Notes - Utilize efficient data structures or algorithms that can handle the merging of multiple linked lists optimally. - Consider using a priority queue (or min-heap) to achieve better performance than a naive approach. - Ensure that the solution maintains the constraints on time and space complexity.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists): min_heap = [] # Initialize the heap with the head node of each list for index, head in enumerate(lists): if head: heapq.heappush(min_heap, (head.val, index, head)) dummy = ListNode() current = dummy while min_heap: val, index, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"# Coding Assessment Question Write a function that takes a list of strings and returns a dictionary where the keys are the strings from the list, and the values are the number of times each string appears in the list. Function Signature: ```python def count_string_occurrences(strings: List[str]) -> Dict[str, int]: ``` Input * `strings` (list of strings): A list containing strings for which the occurrences need to be counted. The list can contain duplicate strings and may have zero or more elements. Output * A dictionary with the strings from the input list as keys and their respective counts as values. Constraints * The input list will contain up to 10^6 elements. * Each string within the list will have a maximum length of 100 characters. * The strings will only contain alphabetical characters and will be case-sensitive. Example ```python assert count_string_occurrences([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} assert count_string_occurrences([\\"a\\", \\"b\\", \\"a\\", \\"a\\", \\"c\\", \\"b\\"]) == {\\"a\\": 3, \\"b\\": 2, \\"c\\": 1} assert count_string_occurrences([]) == {} assert count_string_occurrences([\\"unique\\", \\"words\\", \\"only\\"]) == {\\"unique\\": 1, \\"words\\": 1, \\"only\\": 1} assert count_string_occurrences([\\"Repeated\\", \\"repeated\\", \\"REPEATED\\"]) == {\\"Repeated\\": 1, \\"repeated\\": 1, \\"REPEATED\\": 1} ``` Additional Information * Ensure your solution is efficient in terms of time and space complexity. * Be mindful of edge cases, such as an empty list or a list with non-repeating strings.","solution":"from typing import List, Dict def count_string_occurrences(strings: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary with the strings as keys and their respective counts as values. occurrences = {} for string in strings: if string in occurrences: occurrences[string] += 1 else: occurrences[string] = 1 return occurrences"},{"question":"# Question: Graph Processing with BFS Context: You are developing a feature for a graph-based application that requires the computation of various properties of the graph using Breadth-First Search (BFS). One specific task is to determine the shortest path between nodes and identify components within the graph. Problem Statement: Write a Python function `analyze_graph(graph: dict, start_node: int) -> dict:` which processes the provided graph using BFS to compute the shortest paths from the `start_node` to all other reachable nodes, as well as to identify all connected components of the graph. Your function should: 1. Take as input a dictionary `graph` where keys are node identifiers (integers) and values are lists of neighboring node identifiers. 2. Take a starting node `start_node` from which shortest paths are computed. 3. Use BFS to determine the shortest path from `start_node` to each reachable node. 4. Identify all connected components using BFS. 5. Return a dictionary with two keys: - `shortest_paths`: a dictionary where keys are node identifiers and values are the shortest path length from the `start_node`. - `components`: a list of sets where each set contains the node identifiers of a connected component. Input: * `graph`: a dictionary where keys are integers representing nodes and values are lists of integers representing neighboring nodes. * `start_node`: an integer representing the starting node for the BFS search. Output: * A dictionary with the following structure: - `shortest_paths`: a dictionary where keys are integers representing nodes and values are integers representing the shortest path length from the `start_node` to the node. - `components`: a list of sets, each set containing integers representing the nodes in one connected component. Constraints: - Assume that the input graph is undirected and does not contain multiple edges or self-loops. - The graph can be disconnected, implying multiple components. - Nodes in the graph are uniquely identifiable by positive integers. Example: ```python # Example Input graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } start_node = 1 # Expected Output result = analyze_graph(graph, start_node) print(result) # {\'shortest_paths\': {1: 0, 2: 1, 3: 1, 4: 2}, # \'components\': [{1, 2, 3, 4}, {5, 6}]} ``` Implement the function `analyze_graph` to solve the given problem. ```python def analyze_graph(graph, start_node): from collections import deque, defaultdict shortest_paths = {} components = [] # BFS for shortest paths from start_node queue = deque([start_node]) shortest_paths[start_node] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in shortest_paths: shortest_paths[neighbor] = shortest_paths[node] + 1 queue.append(neighbor) # BFS to find all components visited = set() for node in graph: if node not in visited: component = set() queue = deque([node]) visited.add(node) component.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) component.add(neighbor) components.append(component) result = { \'shortest_paths\': shortest_paths, \'components\': components } return result # Example usage graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } start_node = 1 result = analyze_graph(graph, start_node) print(result) # {\'shortest_paths\': {1: 0, 2: 1, 3: 1, 4: 2}, # \'components\': [{1, 2, 3, 4}, {5, 6}]} ```","solution":"def analyze_graph(graph, start_node): from collections import deque, defaultdict shortest_paths = {} components = [] # BFS for shortest paths from start_node queue = deque([start_node]) shortest_paths[start_node] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in shortest_paths: shortest_paths[neighbor] = shortest_paths[node] + 1 queue.append(neighbor) # BFS to find all components visited = set() for node in graph: if node not in visited: component = set() queue = deque([node]) visited.add(node) component.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) component.add(neighbor) components.append(component) result = { \'shortest_paths\': shortest_paths, \'components\': components } return result"},{"question":"Anagram Pair Finder # Scenario You are invited to take part in the development of a system that identifies pairs of words that are anagrams. Two words are considered anagrams if one word can be rearranged to form the other, using all the original letters exactly once. # Function to Implement Write a function, `find_anagram_pairs`, which will accept a list of words and return a list of tuples, where each tuple contains two words that are anagrams of each other. # Function Signature ```python def find_anagram_pairs(words: list) -> list: pass ``` # Input - A list of strings representing words. (1 ≤ len(words) ≤ 500, 1 ≤ len(word) ≤ 50) # Output - A list of tuples, where each tuple contains two strings that are anagrams of each other. # Constraints - Assume all words are case-insensitive and should be converted to lowercase. - Words may contain spaces or punctuation; these should be ignored when determining anagrams. - Each pair of words should be unique in the list of anagram pairs, i.e., once a pair is reported, it should not appear in the reverse order or repeated further. # Example ```python find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"Dormitory\\", \\"Dirty room\\", \\"School master\\", \\"The classroom\\", \\"Hello\\", \\"Olelh\\"]) ``` Output: ```python [ (\\"Listen\\", \\"Silent\\"), (\\"Dormitory\\", \\"Dirty room\\"), (\\"School master\\", \\"The classroom\\"), (\\"Hello\\", \\"Olelh\\") ] ``` # Notes - The function should handle mixed case and non-alphabetic characters with appropriate conversion and stripping. - Ensure efficient string manipulation for performance optimization when dealing with larger input sizes.","solution":"def clean_word(word): Returns a cleaned version of the word with all letters in lowercase, and all non-alphabetic characters removed. return \'\'.join(filter(str.isalpha, word)).lower() def find_anagram_pairs(words): Returns a list of tuples. Each tuple contains two words that are anagrams of each other. anagram_pairs = [] seen_words = set() for i in range(len(words)): word1 = words[i] cleaned_word1 = clean_word(word1) # Skip if this word has been processed in a pair already. if cleaned_word1 in seen_words: continue for j in range(i + 1, len(words)): word2 = words[j] cleaned_word2 = clean_word(word2) if sorted(cleaned_word1) == sorted(cleaned_word2): anagram_pairs.append((word1, word2)) seen_words.add(cleaned_word1) seen_words.add(cleaned_word2) break # Found a pair, no need to look further for this word. return anagram_pairs"},{"question":"# Problem Statement You have been provided with a `CircularBuffer` class which simulates a circular buffer (or ring buffer). This class currently supports basic operations such as adding elements and reading them. Your task is to extend the existing functionality by implementing a new method for the buffer. # Function to Implement **Function**: `average(self) -> float` You need to implement the above function in the given `CircularBuffer` class. This function should return the average of all the elements currently stored in the buffer. # Input and Output Formats * **Input**: None. * **Output**: * **float**: The average value of the elements in the buffer. # Constraints * The buffer may contain any number of elements from 0 up to its maximum capacity. * The elements in the buffer are integers. # Examples ```python cb = CircularBuffer(5) cb.add(10) cb.add(20) cb.add(30) assert cb.average() == 20.0 cb.add(40) cb.add(50) cb.add(60) # This add will overwrite the 10 assert cb.average() == 40.0 # Elements currently in buffer are [60, 20, 30, 40, 50] cb.add(70) # This add will overwrite the 20 assert cb.average() == 50.0 # Elements currently in buffer are [60, 70, 30, 40, 50] ``` # Implementation Details * Ensure the function correctly handles edge cases such as an empty buffer or buffers with fewer elements than their maximum capacity. * Optimize the function by minimizing additional space and unnecessary computations.","solution":"class CircularBuffer: def __init__(self, capacity): self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.count = 0 def add(self, value): if self.count < self.capacity: self.buffer[self.count] = value else: self.buffer[self.start] = value self.start = (self.start + 1) % self.capacity self.count = min(self.count + 1, self.capacity) def get_elements(self): if self.count < self.capacity: return self.buffer[:self.count] return self.buffer[self.start:] + self.buffer[:self.start] def average(self) -> float: if self.count == 0: return 0.0 elements = self.get_elements() return sum(elements) / self.count"},{"question":"# Analyze Daily Temperature Changes Scenario: You are building a weather analysis tool for meteorologists that analyzes daily temperature variations. A critical feature is to identify the consecutive days where the temperature has consistently been increasing. # Task Write a Python function to identify the longest streak of increasing temperatures given a list of temperature readings. Function Signature ```python def longest_increasing_streak(temperatures: list) -> int: pass ``` Input * `temperatures` (list): A list of integers representing daily temperatures. Output * Returns the length of the longest consecutive days of increasing temperatures (int). Constraints * The length of the `temperatures` list `n` is such that `1 <= n <= 10^4` * Each temperature value is an integer within the range `[-100, 100]`. Examples ```python >>> longest_increasing_streak([30, 32, 33, 31, 34, 36, 35, 37]) 3 >>> longest_increasing_streak([50, 50, 50, 50]) 1 >>> longest_increasing_streak([1, 2, 3, 4, 5]) 5 >>> longest_increasing_streak([10, 9, 8, 7]) 1 ``` Additional Notes * If there are multiple sequences of the same length, the function should return the length of any one of these sequences. * Ensure the function handles edge cases such as an empty list or lists with all the same values effectively.","solution":"def longest_increasing_streak(temperatures): if not temperatures: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak"},{"question":"# Task Overview: You are given a list of integers representing a stream of data. Your objective is to design a class `DataStream` that maintains a dynamically sliding window of the last `k` unique integers. You need to implement methods to add new integers to the stream and determine the current set of unique integers in the window. # Class Signature: ```python class DataStream: def __init__(self, k: int): Initializes the DataStream class with a window size `k`. Parameters: k (int): The size of the sliding window. def add(self, num: int) -> None: Adds a new number to the data stream and updates the window. Parameters: num (int): The number to be added to the stream. def get_unique(self) -> list[int]: Returns a list of unique integers currently in the window. Returns: list[int]: A list of unique integers in the sliding window. ``` # Input: - `k`: An integer representing the size of the sliding window. - `num`: An integer to be added to the data stream. # Output: - A list of integers representing the unique elements currently in the sliding window. # Constraints: - The number of elements in the stream will be at most 10^4. - The elements of the stream will be integers. # Example: ```python # Example usage: ds = DataStream(3) ds.add(1) ds.add(2) ds.add(1) print(ds.get_unique()) # Output: [1, 2] ds.add(3) print(ds.get_unique()) # Output: [1, 2, 3] ds.add(2) print(ds.get_unique()) # Output: [1, 3, 2] ``` # Explanation: 1. **First Update:** - Adding 1 results in the window [1]. Unique elements are [1]. 2. **Second Update:** - Adding 2 results in the window [1, 2]. Unique elements are [1, 2]. 3. **Third Update:** - Adding another 1 results in the window [1, 2, 1] but the unique elements remain [1, 2]. 4. **Fourth Update:** - Adding 3 results in the window shifting to the last 3 elements [2, 1, 3]. Unique elements are [1, 2, 3]. 5. **Fifth Update:** - Adding another 2 results in the window shifting to [1, 3, 2]. Unique elements are [1, 2, 3] but reordered as [1, 3, 2] to reflect recent insertions. This exercise will test the candidate\'s ability to manage and manipulate data structures efficiently, incorporate object-oriented programming principles, and handle unique element extraction dynamically as the stream evolves.","solution":"from collections import deque, defaultdict class DataStream: def __init__(self, k: int): Initializes the DataStream class with a window size `k`. self.k = k self.stream = deque() self.freq = defaultdict(int) def add(self, num: int) -> None: Adds a new number to the data stream and updates the window. if len(self.stream) == self.k: old_num = self.stream.popleft() self.freq[old_num] -= 1 if self.freq[old_num] == 0: del self.freq[old_num] self.stream.append(num) self.freq[num] += 1 def get_unique(self) -> list[int]: Returns a list of unique integers currently in the window. return list(self.freq.keys())"},{"question":"# Problem Statement You are tasked with performing basic TCP packet analysis. Given a list of TCP packets, your goal is to extract and return the payloads ordered by their sequence numbers. Each packet contains a sequence number, length, and the payload data. # Function Signature - Implement the function `extract_payload(packets: List[Dict[str, Union[int, str]]]) -> str`. This function will: - Take a list of dictionaries representing TCP packets. - Return a string representing the concatenated payloads sorted by sequence numbers. ```python from typing import List, Dict, Union def extract_payload(packets: List[Dict[str, Union[int, str]]]) -> str: pass ``` # Input and Output Input 1. `packets` (List[Dict[str, Union[int, str]]]): A list of dictionaries where each dictionary contains: - `sequence_number` (int): The sequence number of the packet. Constraints: `0 ≤ sequence_number ≤ 1000000`. - `length` (int): The length of the payload. Constraints: `1 ≤ length ≤ 1000`. - `payload` (str): The payload data of the packet. Constraints: `1 ≤ len(payload) ≤ 1000`. Output 1. `extract_payload(packets)` returns a string representing the concatenated payloads sorted by sequence numbers. # Example 1. `extract_payload([ {\'sequence_number\': 10, \'length\': 4, \'payload\': \'DATA\'}, {\'sequence_number\': 0, \'length\': 4, \'payload\': \'TEST\'}, {\'sequence_number\': 4, \'length\': 2, \'payload\': \'EX\'} ])` - Returns: `\\"TESTEXDATA\\"` # Constraints - You must check for invalid types and raise appropriate exceptions (`TypeError`, `ValueError`) if any dictionary is missing required keys or if the payload lengths do not match their specified lengths. - Ensure your solution is efficient and handles edge cases. # Notes - Pay attention to sorting based on sequence numbers. - Validate that the length of each payload matches the specified length and that required keys are present in each dictionary. - Handle cases where the packet list is empty and return an empty string in such cases.","solution":"from typing import List, Dict, Union def extract_payload(packets: List[Dict[str, Union[int, str]]]) -> str: Extracts and concatenates payloads from packets ordered by their sequence numbers. Parameters: packets (List[Dict[str, Union[int, str]]]): A list of dictionaries representing TCP packets. Returns: str: The concatenated payloads sorted by sequence numbers. # Validate input for packet in packets: if not isinstance(packet, dict): raise TypeError(\'Each packet must be a dictionary.\') if \'sequence_number\' not in packet or \'length\' not in packet or \'payload\' not in packet: raise ValueError(\'Each packet must contain sequence_number, length, and payload.\') if not isinstance(packet[\'sequence_number\'], int) or not isinstance(packet[\'length\'], int) or not isinstance(packet[\'payload\'], str): raise TypeError(\'Invalid data types in packet.\') if len(packet[\'payload\']) != packet[\'length\']: raise ValueError(\'Payload length does not match the length specified.\') # Sort packets by sequence number sorted_packets = sorted(packets, key=lambda x: x[\'sequence_number\']) # Concatenate payloads result = \'\'.join(packet[\'payload\'] for packet in sorted_packets) return result"},{"question":"# Coding Assessment Question Context You are designing a system to measure the correlation between high precision timestamps of events in a sequence. Problem Create a function `calculate_max_time_gap` that finds the maximum gap between consecutive events given a list of high precision timestamps. Function Signature ```python def calculate_max_time_gap(timestamps: List[str]) -> float: pass ``` Input - `timestamps` (List[str]): A list of strings, where each string represents a timestamp in the format `YYYY-MM-DD HH:MM:SS.mmmmmm`. Output - The function should return a float representing the maximum gap (in seconds) between any two consecutive timestamps. Constraints 1. The list `timestamps` will contain at least two timestamps. 2. Timestamps are guaranteed to be in strictly increasing order. 3. Handle up to 10,000 timestamps. 4. Ensure the precision of the output is up to six decimal places. Examples ```python assert calculate_max_time_gap([\\"2023-01-01 12:00:00.000001\\", \\"2023-01-01 12:00:02.000001\\", \\"2023-01-01 12:00:02.000002\\"]) == 2.0 assert calculate_max_time_gap([\\"2023-01-01 12:00:00.099999\\", \\"2023-01-01 12:00:01.000001\\", \\"2023-01-01 12:00:03.000003\\"]) == 2.000002 ``` Scenario In critical applications like logging systems for high-frequency trading platforms or real-time monitoring systems, detecting the maximum delay between events is crucial for performance analysis and bottleneck detection. Notes Use Python\'s `datetime` module to manage and compute differences between timestamps accurately. Ensure that the floating-point arithmetic maintains the necessary precision.","solution":"from datetime import datetime from typing import List def calculate_max_time_gap(timestamps: List[str]) -> float: # Parse strings into datetime objects datetime_list = [datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S.%f\\") for ts in timestamps] # Calculate the differences between consecutive datetime objects max_gap = 0.0 for i in range(1, len(datetime_list)): diff = (datetime_list[i] - datetime_list[i - 1]).total_seconds() if diff > max_gap: max_gap = diff # Return the maximum gap found return round(max_gap, 6)"},{"question":"# Problem Statement: Reconstruct the Permutation You are given an encoded list derived from the original permutation of integers from 0 to n-1 by XORing every two adjacent elements. Your task is to reconstruct the original permutation. # Function Signature ```python def reconstruct_permutation(encoded: List[int], first: int) -> List[int]: pass ``` # Input - `encoded`: A list of n-1 integers representing the XOR of two adjacent elements in the original permutation. - `first`: An integer, the first element of the original permutation. # Output - A list of n integers representing the original permutation. # Constraints - 2 ≤ encoded.length ≤ 10^5 - 0 ≤ encoded[i] < 2^16 - 0 ≤ first < 2^16 # Example ```python # Given encoded list and the first element reconstruct_permutation([1, 2, 3], 1) # Expected output: [1, 0, 2, 1] reconstruct_permutation([6, 5, 4], 2) # Expected output: [2, 4, 1, 5] reconstruct_permutation([0, 0, 0], 10) # Expected output: [10, 10, 10, 10] ``` # Instructions 1. Implement the `reconstruct_permutation` function to derive the original permutation using the encoded list and the provided first element. 2. Recall that for any two elements a and b, the expression a ^ b signifies their XOR operation, and it holds that a = b ^ (a ^ b). 3. Use iterative XOR operations to decode each element of the permutation based on the given encoded list. 4. Your solution should be efficient and handle the input constraints effectively.","solution":"def reconstruct_permutation(encoded, first): Reconstruct the original permutation given the encoded array and the first element. :param encoded: List[int] - The encoded array where encoded[i] = perm[i] ^ perm[i + 1] :param first: int - The first element of the original permutation. :return: List[int] - The original permutation. # Initialize the list with the first element permutation = [first] # Iteratively find the next element using the properties of XOR for e in encoded: next_element = permutation[-1] ^ e permutation.append(next_element) return permutation"},{"question":"# Recursive Calculation of Factorial with Caching Given the code snippet, you are asked to implement a function that calculates the factorial of a non-negative integer `n` using recursion and memoization to cache previously computed results for efficiency. Function Signature: ```python def factorial(n: int, cache: dict = None) -> int: ``` # Requirements: 1. **Inputs**: - `n` (int): A non-negative integer for which the factorial needs to be calculated (e.g., 5). - `cache` (dict, optional): A dictionary used to store precomputed factorial values. If not provided, it should default to an empty dictionary. 2. **Outputs**: - `result` (int): The factorial of the given integer `n`. # Constraints: 1. `n` must be a non-negative integer (i.e., 0 or greater). 2. Use recursion to calculate the factorial. 3. Utilize caching to store and reuse previously computed factorials to enhance performance. # Example: ```python print(factorial(5)) # Output: 120 print(factorial(3)) # Output: 6 print(factorial(0)) # Output: 1 # Testing with cache optimization cache = {} print(factorial(5, cache)) # Output: 120 print(factorial(6, cache)) # Output: 720 ``` # Implementation Details: - Initialize the cache dictionary if not provided. - Implement the base case for `n = 0` and `n = 1` where the factorial values are known. - For other values, check if the result is already in the cache; if not, perform the recursive calculation, store the result in the cache, and return it. - Raise a `ValueError` if `n` is negative. This question evaluates the understanding of recursion, memoization, and handling of function parameters.","solution":"def factorial(n: int, cache: dict = None) -> int: Calculate the factorial of a non-negative integer `n` using recursion and memoization. Args: - n (int): A non-negative integer. - cache (dict, optional): A dictionary to store previously computed factorial values. Returns: - int: The factorial of the integer `n`. Raises: - ValueError: If `n` is a negative integer. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if cache is None: cache = {} if n == 0 or n == 1: return 1 if n in cache: return cache[n] cache[n] = n * factorial(n - 1, cache) return cache[n]"},{"question":"# Scenario You are developing a tool that generates reports from server log data. One of the features requires filtering the logs to find entries associated with a particular user. Efficient extraction of relevant log entries based on the user ID is crucial for performance. # Task Write a function `filter_logs_by_user(logs: List[str], user_id: str) -> List[str]` that filters a list of server log entries to return only those entries that are associated with a specific user ID. # Input - A list of strings `logs`, where each log entry is formatted as `\\"timestamp|user_id|action\\"`. - `timestamp` is a string in the format \\"YYYY-MM-DD hh:mm:ss\\". - `user_id` is a string consisting of alphanumeric characters. - `action` is a description of the user\'s action. - A string `user_id` representing the user ID you wish to filter by. # Output - Return a list of strings representing the log entries that contain the specified `user_id`. # Example ```python input: [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u456|logout\\", \\"2023-01-01 12:10:00|u123|download\\"] user_id: \\"u123\\" output: [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:10:00|u123|download\\"] ``` # Constraints - The function should process each log entry and filter accurately based on the user ID. - The number of log entries (n) can be large, so the efficiency of the function should aim for O(n). - The length of each log entry may vary but will follow the provided format. # Notes - Assume the input list `logs` is non-empty and always contains valid log entries formatted as described. - Consider edge cases such as no matching user ID and multiple actions for the same user ID.","solution":"from typing import List def filter_logs_by_user(logs: List[str], user_id: str) -> List[str]: Filters the list of log entries to return only those associated with the given user_id. Parameters: - logs: List of log entries each formatted as \\"timestamp|user_id|action\\". - user_id: The user ID to filter the logs by. Returns: - A list of log entries associated with the user_id. return [log for log in logs if f\\"|{user_id}|\\" in log]"},{"question":"# Prim\'s Minimum Spanning Tree Problem You have been provided with an algorithm for finding the Minimum Spanning Tree (MST) using Prim\'s algorithm, which is designed to find a subset of the edges that connects all the vertices in the graph with the minimal total edge weight. Problem Statement Implement the function `prims_mst(graph: Dict[int, List[Tuple[int, float]]]) -> List[Tuple[int, int, float]]`. This function should execute Prim\'s algorithm on the given graph and return the edges in the Minimum Spanning Tree. # Input - `graph` (Dict[int, List[Tuple[int, float]]]): An adjacency list representation of a weighted undirected graph. Each key is a node, and the value is a list of tuples where each tuple consists of a neighboring node and the edge weight. # Output - Returns a list of tuples representing the edges of the Minimum Spanning Tree. Each tuple contains two nodes and the weight of the edge between them. # Constraints - The graph is connected and undirected. - Every edge has a positive weight. - There are no duplicated edges between the same pair of nodes. # Performance Requirements - The algorithm should efficiently construct the MST with time complexity O(E log V), where E is the number of edges and V is the number of vertices. # Example ```python graph = { 0: [(1, 4), (7, 8)], 1: [(0, 4), (2, 8), (7, 11)], 2: [(1, 8), (3, 7), (8, 2), (5, 4)], 3: [(2, 7), (4, 9), (5, 14)], 4: [(3, 9), (5, 10)], 5: [(2, 4), (3, 14), (4, 10), (6, 2)], 6: [(5, 2), (7, 1), (8, 6)], 7: [(0, 8), (1, 11), (6, 1), (8, 7)], 8: [(2, 2), (6, 6), (7, 7)] } mst_edges = prims_mst(graph) assert mst_edges == [ (0, 1, 4), (1, 2, 8), (2, 5, 4), (5, 6, 2), (6, 7, 1), (2, 8, 2), (3, 2, 7), (4, 3, 9), ] graph = { 0: [(1, 3), (3, 1)], 1: [(0, 3), (2, 1)], 2: [(1, 1), (3, 1), (4, 2)], 3: [(0, 1), (2, 1), (4, 5)], 4: [(2, 2), (3, 5)] } mst_edges = prims_mst(graph) assert mst_edges == [ (0, 3, 1), (3, 2, 1), (2, 1, 1), (2, 4, 2), ] ``` Your task is to implement the function `prims_mst` that constructs the Minimum Spanning Tree for the given graph according to the constraints and requirements outlined above.","solution":"import heapq from typing import Dict, List, Tuple def prims_mst(graph: Dict[int, List[Tuple[int, float]]]) -> List[Tuple[int, int, float]]: # Number of nodes in the graph num_nodes = len(graph) # To store the MST edges mst_edges = [] # Priority queue for edges edge_pq = [] # Visited set to keep track of nodes already added to MST visited = set() # Start with an arbitrary node, here node 0 start_node = 0 visited.add(start_node) # Add all edges from the start node to the priority queue for neighbor, weight in graph[start_node]: heapq.heappush(edge_pq, (weight, start_node, neighbor)) # While there are edges in the priority queue and we haven\'t visited all nodes while edge_pq and len(visited) < num_nodes: # Get the edge with the smallest weight weight, frm, to = heapq.heappop(edge_pq) # If the destination node of this edge is already visited, skip it if to in visited: continue # Add the edge to the MST mst_edges.append((frm, to, weight)) visited.add(to) # Add all edges from the new node to non-visited nodes to the priority queue for neighbor, weight in graph[to]: if neighbor not in visited: heapq.heappush(edge_pq, (weight, to, neighbor)) return mst_edges"},{"question":"# Loops and String Manipulation Coding Question You are tasked with implementing a function that processes a list of names to standardize and format them. Each name in the list is a string comprised of first and last names separated by a space, and the function should return a formatted string containing all the names in \'Last, First\' format, sorted alphabetically by last name and then by first name if necessary. **Function Implementation:** 1. **Function Signature**: `def format_names(names: List[str]) -> str:` 2. **Input**: The input will be a list of names, where each name is a string containing a first and last name separated by a space. 3. **Process**: * Split each name string into first and last names. * Reformat each name to \'Last, First\'. * Sort the list of reformatted names first by last name, then by first name. * Join the formatted names into a single string separated by semicolons. 4. **Output**: A single string containing all the formatted names, sorted and separated by semicolons. **Constraints**: * Each name string will contain exactly one first name and one last name. * Assume the input list will not be empty and all names are correctly formatted (no leading or trailing spaces). * First and last names are composed of alphabetic characters only. **Example**: ```python >>> names = [\\"John Doe\\", \\"Jane Smith\\", \\"Alice Johnson\\", \\"Michael Jordan\\"] >>> format_names(names) \\"Johnson, Alice; Doe, John; Jordan, Michael; Smith, Jane\\" ``` **Note**: Ensure to handle capitalization properly, respecting the format \'Last, First\' where the first character of each name is capitalized. Good luck! Make sure to test your solution on various list sizes and name combinations to ensure accuracy.","solution":"from typing import List def format_names(names: List[str]) -> str: Reformats a list of names into \'Last, First\' format, sorts them alphabetically, and joins them with semicolons. formatted_names = [] for name in names: first_name, last_name = name.split() formatted_names.append(f\\"{last_name}, {first_name}\\") sorted_names = sorted(formatted_names) return \\"; \\".join(sorted_names)"},{"question":"# Coding Task: Fraction to Recurring Decimal Conversion **Objective**: Write a Python function that converts a given fraction to its decimal representation. If the decimal representation has a repeating cycle, specify which part of the decimal repeats in parentheses. Function to Implement: 1. **`fraction_to_decimal(numerator: int, denominator: int) -> str`**: - **Input**: - `numerator` (Integer): The numerator of the fraction. - `denominator` (Integer): The denominator of the fraction. - **Output**: - Returns the decimal representation of the fraction as a string, with the repeating part enclosed in parentheses, if applicable. - **Constraints**: - Both `numerator` and `denominator` are non-zero integers. - **Exception Handling**: - Raise `ZeroDivisionError` if `denominator == 0`. - Raise `TypeError` if either `numerator` or `denominator` is not an integer. **Example Usages**: ```python # Regular fractions assert fraction_to_decimal(1, 2) == \\"0.5\\" assert fraction_to_decimal(2, 1) == \\"2\\" # Fractions with repeating decimals assert fraction_to_decimal(1, 3) == \\"0.(3)\\" assert fraction_to_decimal(2, 3) == \\"0.(6)\\" assert fraction_to_decimal(1, 6) == \\"0.1(6)\\" ``` **Notes**: - Ensure that your code correctly handles negative fractions. - Document your implementation with appropriate comments and example usages. - Optimize the algorithm to handle large numerators and denominators efficiently.","solution":"def fraction_to_decimal(numerator, denominator): if not (isinstance(numerator, int) and isinstance(denominator, int)): raise TypeError(\\"Numerator and denominator must be integers\\") if denominator == 0: raise ZeroDivisionError(\\"Denominator cannot be zero\\") if numerator == 0: return \\"0\\" result = [] # Determine the sign if (numerator < 0) ^ (denominator < 0): result.append(\'-\') numerator, denominator = abs(numerator), abs(denominator) # Append the integer part result.append(str(numerator // denominator)) numerator %= denominator if numerator == 0: return \'\'.join(result) result.append(\'.\') index_map = {} while numerator != 0: if numerator in index_map: result.insert(index_map[numerator], \'(\') result.append(\')\') break index_map[numerator] = len(result) numerator *= 10 result.append(str(numerator // denominator)) numerator %= denominator return \'\'.join(result)"},{"question":"# Coding Assessment Question Scenario Sorting algorithms are fundamental in computer science and are widely used in various applications such as organizing data, improving search performance, and managing large datasets. Task Implement a hybrid sorting algorithm in Python that combines Merge Sort and Insertion Sort. The algorithm should use Merge Sort for larger portions of the array and switch to Insertion Sort when the sub-array size falls below a certain threshold (k). Requirements 1. Implement a function `hybrid_sort` that: - Accepts a list of integers and a threshold value `k`. - Uses Merge Sort as the primary sorting method. - Switches to Insertion Sort for sub-arrays of size `k` or smaller. 2. Ensure your implementation handles edge cases such as empty lists and lists with one element. 3. Demonstrate your implementation with the following cases: - Sort the list `[12, 11, 13, 5, 6, 7]` with `k=3`. - Sort the list `[3, 0, 2, 5, -1, 4, 1]` with `k=4`. Function Signature ```python def hybrid_sort(arr: list, k: int) -> list: # Implement the hybrid sorting logic # Example usage print(hybrid_sort([12, 11, 13, 5, 6, 7], 3)) # Expected output: [5, 6, 7, 11, 12, 13] print(hybrid_sort([3, 0, 2, 5, -1, 4, 1], 4)) # Expected output: [-1, 0, 1, 2, 3, 4, 5] ``` Input Format - A list of integers. - An integer `k` representing the threshold for switching to Insertion Sort. Output Format - A list of integers sorted in ascending order. Constraints - `1 ≤ len(arr) ≤ 10^6` - `0 ≤ k ≤ 10^3` Performance Requirements - The implementation should efficiently handle both small and large datasets. - Ensure optimal time complexity for the combined sorting approach.","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid L = arr[left:mid + 1] R = arr[mid + 1:right + 1] i = j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def hybrid_sort_recursive(arr, left, right, k): if left < right: if (right - left + 1) <= k: insertion_sort(arr, left, right) else: mid = (left + right) // 2 hybrid_sort_recursive(arr, left, mid, k) hybrid_sort_recursive(arr, mid + 1, right, k) merge(arr, left, mid, right) def hybrid_sort(arr, k): if len(arr) <= 1: return arr hybrid_sort_recursive(arr, 0, len(arr) - 1, k) return arr"},{"question":"# Arithmetic Expression Validator and Evaluator You are tasked with creating a function to validate and evaluate arithmetic expressions provided as strings. The expressions include basic operations (addition, subtraction, multiplication, division) and parentheses for grouping. Your function should first ensure that the expression is valid in terms of proper use of parentheses and operators, then evaluate the expression to return the calculated result. # Instructions 1. **Function Signature**: ```python def validate_and_evaluate(expression: str) -> Any: ``` 2. **Inputs**: * `expression`: A string representing the arithmetic expression to validate and evaluate. The expression may contain: - Digits (0-9) - Operators (+, -, *, /) - Parentheses (()) 3. **Outputs**: * If the expression is invalid (due to mismatched parentheses, invalid characters, or improper operator usage), the function should return the string `\\"Invalid expression\\"`. * If the expression is valid, return a float representing the evaluated result of the expression. 4. **Constraints**: * Division by zero should be caught and return the string `\\"Invalid expression\\"`. * The length of the expression will be between 1 and 1000 characters. * The expression will not contain any spaces, and it will only include valid arithmetic characters as defined above. 5. **Example**: ```python expression1 = \\"(3+2)*5-8/4\\" result1 = validate_and_evaluate(expression1) print(result1) # Output: 23.0 expression2 = \\"3+(4*2\\" result2 = validate_and_evaluate(expression2) print(result2) # Output: \\"Invalid expression\\" expression3 = \\"(3+5)/0\\" result3 = validate_and_evaluate(expression3) print(result3) # Output: \\"Invalid expression\\" ``` 6. **Hint**: Utilize a stack to help validate the parentheses and ensure correct precedence of operations when evaluating the expression. Implement the function `validate_and_evaluate` to validate and evaluate the expression accordingly, handling all specified edge cases.","solution":"def validate_and_evaluate(expression: str) -> any: Validates and evaluates an arithmetic expression. Parameters: expression (str): The arithmetic expression to validate and evaluate. Returns: float or str: If invalid, returns \\"Invalid expression\\", otherwise the calculated result as a float. # Helper function to check if character is an operator def is_operator(c): return c in \\"+-*/\\" # Check for invalid characters for c in expression: if not (c.isdigit() or is_operator(c) or c in \\"()\\"): return \\"Invalid expression\\" # Check for balanced parentheses def are_parentheses_balanced(expression): stack = [] for char in expression: if char == \\"(\\": stack.append(\\"(\\") elif char == \\")\\": if not stack: return False stack.pop() return len(stack) == 0 if not are_parentheses_balanced(expression): return \\"Invalid expression\\" # Check for improper operator usage if expression[0] in \\"*/\\" or expression[-1] in \\"+-*/\\": return \\"Invalid expression\\" # Check for consecutive operators for i in range(len(expression) - 1): if is_operator(expression[i]) and is_operator(expression[i + 1]): return \\"Invalid expression\\" # Try evaluating the expression try: result = eval(expression) if isinstance(result, (int, float)): return float(result) else: return \\"Invalid expression\\" except: return \\"Invalid expression\\""},{"question":"# Data Processing and Transformation Challenge Objective: Write a Python function `process_employee_data(employee_data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Dict[str, Union[int, float]]]` that processes a list of employee records and returns a summary of data organized by department. Input: * A list of dictionaries `employee_data`, where each dictionary represents an employee\'s details with the following keys: * `name` (str): The name of the employee. * `department` (str): The department the employee works in. * `salary` (float): Annual salary of the employee. * `years_of_experience` (int): Number of years the employee has worked. Output: * A dictionary where the keys are department names and the values are dictionaries with the following structure: * `total_employees` (int): Total number of employees in the department. * `average_salary` (float): Average salary of employees in the department. * `average_experience` (float): Average years of experience of employees in the department. * The average values should be rounded to two decimal places. Constraints: * Ensure that all numerical values are correctly computed. * Handle the case of an empty employee list gracefully. * Departments with no employees should not be included in the output. Context: You are tasked with generating a report that summarizes employee data by their departments to help the HR department understand the distribution of workforce and compensation within different areas of the company. Requirements: 1. Your function should correctly aggregate the required numerical data by department. 2. Ensure calculations are performed with due consideration to rounding for floating-point values. 3. Code should handle edge cases such as no employees or unusual department names appropriately. Example Usage: ```python employee_data = [ {\\"name\\": \\"Alice Johnson\\", \\"department\\": \\"Engineering\\", \\"salary\\": 80000, \\"years_of_experience\\": 5}, {\\"name\\": \\"Bob Smith\\", \\"department\\": \\"HR\\", \\"salary\\": 50000, \\"years_of_experience\\": 3}, {\\"name\\": \\"Carol White\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000, \\"years_of_experience\\": 6}, {\\"name\\": \\"David Brown\\", \\"department\\": \\"Sales\\", \\"salary\\": 55000, \\"years_of_experience\\": 4} ] result = process_employee_data(employee_data) for dept, summary in result.items(): print(f\\"Department: {dept}\\") for key, value in summary.items(): print(f\\"{key}: {value}\\") ``` Expected output for the provided `employee_data` could look like: ``` Department: Engineering total_employees: 2 average_salary: 85000.0 average_experience: 5.5 Department: HR total_employees: 1 average_salary: 50000.0 average_experience: 3.0 Department: Sales total_employees: 1 average_salary: 55000.0 average_experience: 4.0 ``` Note: Ensure the implementation is tested for its robustness, particularly with respect to correct handling of numerical rounding and empty input scenarios.","solution":"from typing import List, Dict, Union def process_employee_data(employee_data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Dict[str, Union[int, float]]]: Process employee data to summarize information by department. Args: - employee_data: A list of dictionaries containing employee details. Returns: - A dictionary summarizing data by department. department_summary = {} for record in employee_data: department = record[\'department\'] salary = record[\'salary\'] experience = record[\'years_of_experience\'] if department not in department_summary: department_summary[department] = { \'total_employees\': 0, \'total_salary\': 0.0, \'total_experience\': 0 } department_summary[department][\'total_employees\'] += 1 department_summary[department][\'total_salary\'] += salary department_summary[department][\'total_experience\'] += experience result = {} for department, summary in department_summary.items(): total_employees = summary[\'total_employees\'] if total_employees > 0: result[department] = { \'total_employees\': total_employees, \'average_salary\': round(summary[\'total_salary\'] / total_employees, 2), \'average_experience\': round(summary[\'total_experience\'] / total_employees, 2) } return result"},{"question":"Row with Maximum 1s You are given a binary matrix where each row is sorted in non-decreasing order. Your task is to write a function to find the row with the maximum number of 1s. # Function Requirements You need to implement the function `row_with_max_ones(matrix: list[list[int]]) -> int` following these requirements: 1. **Input**: - `matrix` (list[list[int]]): A list of lists where each inner list represents a row in the binary matrix sorted in non-decreasing order. 2. **Output**: - An integer representing the index of the row with the maximum number of 1s. If there are multiple rows with the same number of 1s, return the index of the first one. # Steps 1. **Binary Search**: - Use binary search to optimize the search for the first occurrence of 1 in each row, exploiting the sorted property of the rows. 2. **Count 1s**: - For each row, count the number of 1s based on the position of the first 1 found. 3. **Tracking Maximum**: - Track the row with the maximum number of 1s. In case of a tie, prioritize the row with the smaller index. # Constraints: - The matrix size could be as large as 1000x1000. - Execution time should be optimized considering the matrix size constraints. # Example: ```python >>> matrix = [ ... [0, 0, 0, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ... ] >>> row_with_max_ones(matrix) 2 ``` # Implementation: Write your solution as a function in Python. ```python def row_with_max_ones(matrix: list[list[int]]) -> int: n = len(matrix) max_ones_row = -1 max_ones = -1 for i in range(n): low, high = 0, len(matrix[i]) - 1 while low <= high: mid = (low + high) // 2 if matrix[i][mid] == 1: high = mid - 1 else: low = mid + 1 num_ones = len(matrix[i]) - low if num_ones > max_ones: max_ones = num_ones max_ones_row = i return max_ones_row ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def row_with_max_ones(matrix: list[list[int]]) -> int: Returns the index of the row with the maximum number of 1s. If there are multiple rows with the same number of 1s, returns the index of the first one. n = len(matrix) # Number of rows in the matrix m = len(matrix[0]) if matrix else 0 # Number of columns in the matrix max_ones_row = -1 # Index of the row with the maximum number of 1s max_ones = -1 # Maximum number of 1s found in any row # Iterate over each row in the matrix for i in range(n): low, high = 0, m - 1 # Binary search to find the first occurrence of 1 in the row while low <= high: mid = (low + high) // 2 if matrix[i][mid] == 1: high = mid - 1 else: low = mid + 1 # Calculate the number of 1s in the current row num_ones = m - low # Update the row with the maximum number of 1s if necessary if num_ones > max_ones: max_ones = num_ones max_ones_row = i return max_ones_row"},{"question":"# Coding Question Context In recent classes, you have covered the basics of data manipulation and transformation using basic functions and array operations. One such common problem is transforming array elements based on certain conditions to produce a new array. In this question, you will implement a function that calculates the transformation of an array of integers based on specific conditions. Task You are required to implement a function that transforms an array of integers based on the following rules: 1. For every element `arr[i]`, if it is even, replace it with the sum of digits of `arr[i]`. 2. If it is odd, replace it with the product of its digits. Define the function as follows: **transform_array(arr: List[int]) -> List[int]** * Input: `arr` - a list of integers. * Output: A new list of integers where each element has been transformed according to the defined rules. Input and Output Formats * Input: * A list of integers `arr` where each integer can be positive or negative. * Output: * A new list of integers with the same length as `arr`, where each element is transformed. Performance Requirements Your solution should be efficient enough to handle arrays with lengths up to 10^5 elements. Constraints * The elements in the array can range from -10^6 to 10^6. * The array will have at least one and at most 10^5 elements. Example ```python # Example assert transform_array([23, -42, 56, 9, 18]) == [6, 6, 11, 9, 9] # Explanation: # 23 -> 2*3 = 6 # -42 (absolute value 42) -> 4+2 = 6 # 56 -> 5+6 = 11 # 9 -> 9*1 = 9 # 18 -> 1+8 = 9 ``` Solution Outline 1. Define a helper function to compute the sum of digits of a number. 2. Define a helper function to compute the product of digits of a number. 3. Loop through each element in the array: * If the element is even, replace it with the sum of its digits. * If the element is odd, replace it with the product of its digits. 4. Return the transformed array. You are expected to write efficient and clean code to complete this task. Good luck!","solution":"from typing import List def transform_array(arr: List[int]) -> List[int]: def sum_of_digits(n: int) -> int: return sum(int(digit) for digit in str(abs(n))) def product_of_digits(n: int) -> int: product = 1 for digit in str(abs(n)): product *= int(digit) return product result = [] for num in arr: if num % 2 == 0: result.append(sum_of_digits(num)) else: result.append(product_of_digits(num)) return result"},{"question":"Human Resource Management System Report Generation # Background: You have been tasked with enhancing a Human Resource Management (HRM) system by adding a feature to generate various reports. These reports will provide insights into the employee data stored within the system. # Task: Implement a Python class to represent employee records and include methods to generate summaries and detailed reports based on various parameters. # Requirements: 1. You will be provided with a base `EmployeeRecord` class and need to add methods to: 1. Generate an overview report summarizing employee counts by department. 2. Generate a detailed report of all employees within a specified department. 2. You will implement a function to filter employees by department. # Class and Function Definitions: 1. **EmployeeRecord Class**: * This class will hold the following attributes: * `employee_id` (int) * `name` (str) * `department` (str) * `position` (str) * Implement the following methods: * A class method `generate_overview_report` that: * Accepts a list of `EmployeeRecord` instances. * Returns a dictionary with department names as keys and employee counts as values. * A class method `generate_detailed_report` that: * Accepts a list of `EmployeeRecord` instances and a department name (str). * Returns a list of `EmployeeRecord` instances belonging to the specified department. 2. **Filter Function**: * Implement `filter_employees_by_department` function which: * Takes a list of `EmployeeRecord` instances and a department name. * Returns a list of `EmployeeRecord` instances that belong to the specified department. # Example Code: ```python class EmployeeRecord: def __init__(self, employee_id: int, name: str, department: str, position: str): self.employee_id = employee_id self.name = name self.department = department self.position = position @classmethod def generate_overview_report(cls, employees: list): report = {} for employee in employees: if employee.department in report: report[employee.department] += 1 else: report[employee.department] = 1 return report @classmethod def generate_detailed_report(cls, employees: list, department: str): return [employee for employee in employees if employee.department == department] def filter_employees_by_department(employees: list, department: str): return [employee for employee in employees if employee.department == department] ``` # Input/Output: * **Input**: * A list of `EmployeeRecord` instances. * Department name (for filtering and detailed reports). * Example: ```python employees = [ EmployeeRecord(1, \\"Alice\\", \\"Engineering\\", \\"Developer\\"), EmployeeRecord(2, \\"Bob\\", \\"HR\\", \\"Manager\\"), EmployeeRecord(3, \\"Charlie\\", \\"Engineering\\", \\"Developer\\") ] overview_report = EmployeeRecord.generate_overview_report(employees) # Generates an overview report detailed_report = EmployeeRecord.generate_detailed_report(employees, \\"Engineering\\") # Generates a detailed report for Engineering department filtered_employees = filter_employees_by_department(employees, \\"HR\\") # Filter employees in HR ``` * **Output**: * Overview report: Dictionary with department counts. ```python {\'Engineering\': 2, \'HR\': 1} ``` * Detailed report: List of `EmployeeRecord` instances for the specified department. ```python [ EmployeeRecord(1, \\"Alice\\", \\"Engineering\\", \\"Developer\\"), EmployeeRecord(3, \\"Charlie\\", \\"Engineering\\", \\"Developer\\") ] ``` * Filtered employees: List of `EmployeeRecord` instances for the specified department. ```python [ EmployeeRecord(2, \\"Bob\\", \\"HR\\", \\"Manager\\") ] ``` # Constraints: * Use only native Python libraries. * Ensure code is efficient when working with large numbers of employees. * Handle edge cases gracefully (e.g., no employees in a department). Complete your implementation such that it seamlessly fits into a HRM system, providing the requested reporting functionality.","solution":"class EmployeeRecord: def __init__(self, employee_id: int, name: str, department: str, position: str): self.employee_id = employee_id self.name = name self.department = department self.position = position @classmethod def generate_overview_report(cls, employees: list): report = {} for employee in employees: if employee.department in report: report[employee.department] += 1 else: report[employee.department] = 1 return report @classmethod def generate_detailed_report(cls, employees: list, department: str): return [employee for employee in employees if employee.department == department] def filter_employees_by_department(employees: list, department: str): return [employee for employee in employees if employee.department == department]"},{"question":"Problem Description You are tasked with writing a function to find all prime numbers between two given numbers, inclusive. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Input - Two integers `a` and `b` (`1 <= a <= b <= 10^6`). # Output - A list of integers representing all prime numbers between `a` and `b`, inclusive. # Function Signature ```python def find_primes(a: int, b: int) -> list[int]: pass ``` # Constraints - The values of `a` and `b` are such that the difference between them (`b - a`) is at most 10^5. - The input values are valid, and `1 <= a <= b <= 10^6`. # Example ```python a = 10 b = 20 print(find_primes(a, b)) # Output: [11, 13, 17, 19] a = 1 b = 10 print(find_primes(a, b)) # Output: [2, 3, 5, 7] ``` # Notes - Use an efficient algorithm to determine prime numbers, such as the Sieve of Eratosthenes, to ensure the function performs well even for large values of `a` and `b`. - Be mindful of edge cases, such as when `a` and `b` are equal or when there are no prime numbers in the given range.","solution":"def find_primes(a: int, b: int) -> list[int]: def sieve(n): is_prime = [True] * (n + 1) p = 2 while (p ** 2 <= n): if (is_prime[p] == True): for i in range(p ** 2, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] if a <= 1: a = 2 # Adjust a as 1 is not a prime number primes_up_to_b = sieve(b) return [p for p in primes_up_to_b if p >= a]"},{"question":"# Coding Assessment Question Scenario You are working on a data processing module where one of the tasks is to handle and analyze text data. Specifically, you need to write a function that finds the most frequently occurring word in a given text. In case of a tie (i.e., more than one word has the highest frequency), you should return the word that comes first lexicographically. Task Write a function `most_frequent_word` that accepts a string of text and returns the most frequently occurring word, adhering to specific constraints as described below. Requirements 1. If the input string is empty, raise a `ValueError` with the message \\"Input text cannot be empty\\". 2. Consider words as sequences of alphanumeric characters. Punctuation marks and other symbols should be ignored. 3. The function should be case-insensitive when counting word frequencies but should return the word in its original casing as it appears first in the text. Function Signature ```python def most_frequent_word(text: str) -> str: pass ``` Inputs - `text` (str): A string of text containing words and possibly punctuation marks. Output - (str): The most frequently occurring word in the text. Constraints - The input string may contain up to (1e6) characters. - The words may be mixed case, but the function should be case-insensitive for counting (e.g., \\"Hello\\" and \\"hello\\" should be considered the same word). Example ```python >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\") \'the\' >>> most_frequent_word(\\"To be or not to be, that is the question.\\") \'be\' ``` Implement the function to ensure it handles all the edge cases and constraints effectively.","solution":"import re from collections import Counter def most_frequent_word(text: str) -> str: if not text: raise ValueError(\\"Input text cannot be empty\\") # Normalize the text and extract words words = re.findall(r\'bw+b\', text.lower()) if not words: raise ValueError(\\"Input text cannot be empty after removing non-alphanumeric characters\\") # Count word frequencies word_counts = Counter(words) max_frequency = max(word_counts.values()) # Find words with the max frequency most_frequent_words = [word for word, count in word_counts.items() if count == max_frequency] most_frequent_words.sort() # Return the lexicographically first word with max frequency return most_frequent_words[0]"},{"question":"# Longest Increasing Subsequence You are developing a feature for a learning platform that tracks the progress of students based on their test scores. You\'ve been assigned to implement a function that calculates the length of the longest increasing subsequence of a student\'s scores over time. Task Write a function `longest_increasing_subsequence` that determines the length of the longest subsequence of increasing scores from a given list of scores. Function Signature ```python def longest_increasing_subsequence(scores: List[int]) -> int: ``` Input - `scores` (List[int]): A list of integers representing the student\'s scores over time (1 ≤ len(scores) ≤ 10^5, 0 ≤ scores[i] ≤ 10^6 for all valid i). Output - An integer representing the length of the longest increasing subsequence of the given scores. Constraints - The scores list can contain duplicates. Example ```python longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) -> 4 longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) -> 4 longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) -> 1 ``` Explanation 1. For scores [10, 9, 2, 5, 3, 7, 101, 18]: - Longest increasing subsequence: [2, 3, 7, 101] 2. For scores [0, 1, 0, 3, 2, 3]: - Longest increasing subsequence: [0, 1, 2, 3] 3. For scores [7, 7, 7, 7, 7, 7, 7]: - Longest increasing subsequence: [7]","solution":"from typing import List import bisect def longest_increasing_subsequence(scores: List[int]) -> int: Returns the length of the longest increasing subsequence of a given list of scores. if not scores: return 0 lis = [] for score in scores: pos = bisect.bisect_left(lis, score) if pos < len(lis): lis[pos] = score else: lis.append(score) return len(lis)"},{"question":"# Implement a Min-Heap Using an Array Scenario: Heaps are a specialized tree-based data structure that satisfy the heap property. In a Min-Heap, for any given node `i`, the value of `i` is less than or equal to its children. Heaps are commonly implemented using arrays because they can be efficiently managed with indices. Problem: You need to implement a `MinHeap` class using an array. The class should support the following operations: 1. `insert(self, value)`: Insert a new integer into the heap. 2. `get_min(self)`: Retrieve and remove the minimum element from the heap. 3. `peek_min(self)`: Retrieve but not remove the minimum element from the heap. 4. `size(self)`: Return the number of elements currently in the heap. Input and Output Formats: * **Input**: An instance of `MinHeap` that performs various operations: `insert`, `get_min`, `peek_min`, and `size`. * **Output**: Depends on the method called. * `get_min(self)`: Returns the minimum element from the heap. * `peek_min(self)`: Returns the minimum element from the heap without removing it. * `size(self)`: Returns the number of elements in the heap. Constraints: * All values in the heap are integers (positive, negative, and zero). * The number of operations can be zero or more. * The heap should maintain the min-heap property after every insertion and deletion. * Expect efficient performance with `insert` and `get_min` operations in O(log n) time complexity. Example Usage: ```python heap = MinHeap() # Insert some values heap.insert(4) heap.insert(7) heap.insert(1) heap.insert(3) heap.insert(10) # Get the minimum element min_element = heap.get_min() # Output should be 1 # Peek at the minimum element without removing it min_element_peek = heap.peek_min() # Output should be 3 # Check the size of the heap heap_size = heap.size() # Output should be 4 ``` Method Signatures: ```python class MinHeap: def __init__(self): Initializes an empty Min-Heap. self.heap = [] def insert(self, value: int) -> None: Inserts a new integer into the heap. :param value: The value to be inserted into the heap. :type value: int # Implementation goes here def get_min(self) -> int: Removes and returns the minimum element from the heap. :returns: The minimum element from the heap. :rtype: int # Implementation goes here def peek_min(self) -> int: Retrieves but does not remove the minimum element from the heap. :returns: The minimum element from the heap. :rtype: int # Implementation goes here def size(self) -> int: Returns the number of elements currently in the heap. :returns: The number of elements in the heap. :rtype: int # Implementation goes here ``` Additional Considerations: * Ensure the heap property is maintained after each operation. * Handle edge cases such as calling `get_min` or `peek_min` on an empty heap. * Consider corner cases such as duplicate values in the heap.","solution":"class MinHeap: def __init__(self): Initializes an empty Min-Heap. self.heap = [] def insert(self, value: int) -> None: Inserts a new integer into the heap. :param value: The value to be inserted into the heap. :type value: int self.heap.append(value) self._heapify_up(len(self.heap) - 1) def get_min(self) -> int: Removes and returns the minimum element from the heap. :returns: The minimum element from the heap. :rtype: int if not self.heap: raise IndexError(\'get_min from an empty heap\') min_val = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() self._heapify_down(0) return min_val def peek_min(self) -> int: Retrieves but does not remove the minimum element from the heap. :returns: The minimum element from the heap. :rtype: int if not self.heap: raise IndexError(\'peek_min from an empty heap\') return self.heap[0] def size(self) -> int: Returns the number of elements currently in the heap. :returns: The number of elements in the heap. :rtype: int return len(self.heap) def _heapify_up(self, index): parent = (index - 1) // 2 if parent >= 0 and self.heap[parent] > self.heap[index]: self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent] self._heapify_up(parent) def _heapify_down(self, index): left = 2 * index + 1 right = 2 * index + 2 smallest = index if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Coding Assessment Question Objective Implement a function to perform binary tree serialization and deserialization, ensuring that the method handles null nodes appropriately. You will also assess the reconstruction fidelity of the tree structure. Problem Statement You are given a binary tree. Write two functions: 1. `serialize(root: TreeNode) -> str`: * Encodes a tree to a single string. * Returns the encoded string representation of the tree. 2. `deserialize(data: str) -> TreeNode`: * Decodes the encoded data to reconstruct the tree. * Returns the root of the reconstructed binary tree. Class Declaration ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Input * A root node of a binary tree with `TreeNode` structure. Output * For `serialize`: A string representing the serialized tree. * For `deserialize`: The reconstructed `TreeNode` root of the binary tree. Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000` Requirements * Ensure that the serialization and deserialization methods faithfully preserve the tree structure, including null nodes. Example Cases **Case 1: Simple Tree** Serialization Input: ```python # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) ``` Serialization Output: ```python \\"1,2,null,null,3,4,null,null,5,null,null\\" ``` Deserialization Input: ```python data = \\"1,2,null,null,3,4,null,null,5,null,null\\" ``` Deserialization Output: ```python # Returns the root of the reconstructed tree, which should be identical to the original tree. ``` **Case 2: Empty Tree** Serialization Input: ```python root = None ``` Serialization Output: ```python \\"\\" ``` Deserialization Input: ```python data = \\"\\" ``` Deserialization Output: ```python # Returns None, indicating the tree is empty. ``` Implementation Note Ensure you handle edge cases such as trees with a single child or completely unbalanced trees during the serialization and deserialization process.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. if not root: return \'\' def dfs(node): if not node: return \'null,\' left_serialized = dfs(node.left) right_serialized = dfs(node.right) return f\'{node.val},{left_serialized}{right_serialized}\' return dfs(root).rstrip(\',\') def deserialize(data): Decodes your encoded data to tree. if not data: return None nodes = data.split(\',\') index = 0 def dfs(): nonlocal index if nodes[index] == \'null\': index += 1 return None node = TreeNode(int(nodes[index])) index += 1 node.left = dfs() node.right = dfs() return node return dfs()"},{"question":"# Problem Scenario You are working on a sales analytics dashboard and need to analyze daily sales data for a retail shop. Your task is to calculate a key performance indicator (KPI): the maximum difference between any two daily sales figures where the later day has higher sales than an earlier day. This will help you identify the best possible gain in sales over a period of time. # Task Write a function `max_sales_gain(sales: list) -> int`. Your function should: 1. Take as input a list of integers representing daily sales figures. 2. Return the maximum difference (gain) between any two days where the later day has a higher sales figure than an earlier day. 3. Handle various edge cases and ensure correctness for typical input scenarios. # Expected Input and Output Input: * A list of integers, `sales`. - Example: `[100, 200, 150, 300, 250, 500]` Output: * An integer representing the maximum sales gain. - Example: `400` # Constraints: * The length of the list will be at most 10,000. * Each integer in the list will be a non-negative number and will be at most 1,000,000. * If there is no valid gain (i.e., the sales only decrease or remain constant), return `0`. # Performance Requirements: * The solution should be optimal with a time complexity of O(n). # Example ```python def max_sales_gain(sales: list) -> int: # Implement the logic to find the maximum sales gain pass # Example usage: print(max_sales_gain([100, 200, 150, 300, 250, 500])) # Output: 400 ``` Provide your implementation of the `max_sales_gain()` function to determine the maximum gain in sales between any two days.","solution":"def max_sales_gain(sales): Returns the maximum difference (gain) between any two days where the later day has a higher sales figure than an earlier day. if not sales or len(sales) < 2: return 0 min_sales = sales[0] max_gain = 0 for sale in sales[1:]: if sale > min_sales: max_gain = max(max_gain, sale - min_sales) min_sales = min(min_sales, sale) return max_gain"},{"question":"# Problem Statement In this exercise, you will design and implement a Python function to interact with the Twitter API to fetch a user\'s most recent tweets. Your task is to return the text of those tweets as a list, handling any potential errors during the process. # Requirements 1. **Function Name**: `fetch_recent_tweets` 2. **Input**: - `bearer_token` (string): A valid Twitter API bearer token. - `username` (string): The Twitter username whose tweets you want to fetch. - `count` (int): The number of recent tweets to fetch (maximum 10). 3. **Output**: - A list of strings, where each string contains the text of a tweet. 4. **Constraints**: - Handle network errors and API failures gracefully. - Timeout for the request must be set to 10 seconds. - Use environment variable for the bearer token. # Function Signature ```python def fetch_recent_tweets(bearer_token: str, username: str, count: int) -> list[str]: pass ``` # Example Suppose the bearer token is `ABCDE` and the Twitter username is `jack`, with the count set to 2, the expected output should be similar to the structure below (Note: This example does not reflect actual tweet data): ```python [ \\"Just setting up my twttr\\", \\"inviting coworkers\\" ] ``` # Notes - Ensure that you use the `requests` library for making HTTP calls. - Fetch tweets from the endpoint: `https://api.twitter.com/2/tweets?screen_name={username}&count={count}`. - If an error occurs (network error, invalid token, etc.), handle it gracefully and return an empty list. - Store your bearer token in an environment variable and retrieve it using `os.environ`. # Testing - Test your function with a valid Twitter username and bearer token. - Handle and test edge cases, such as user not found, missing or invalid token, network issues.","solution":"import os import requests def fetch_recent_tweets(bearer_token: str, username: str, count: int) -> list[str]: Fetches the most recent tweets of a user. Parameters: - bearer_token (str): A valid Twitter API bearer token. - username (str): The Twitter username whose tweets are to be fetched. - count (int): The number of recent tweets to fetch (maximum 10). Returns: - List of tweet texts (List[str]). Empty list if an error occurs. if count > 10: count = 10 headers = { \\"Authorization\\": f\\"Bearer {bearer_token}\\" } url = f\\"https://api.twitter.com/2/tweets?screen_name={username}&count={count}\\" try: response = requests.get(url, headers=headers, timeout=10) response.raise_for_status() tweets = response.json().get(\'data\', []) tweet_texts = [tweet[\'text\'] for tweet in tweets] return tweet_texts except requests.RequestException: return [] os.environ[\'TWITTER_BEARER_TOKEN\'] = \\"ABCDE\\" # Example token for demonstration purposes"},{"question":"# Question: Implement a Min-Heap Scenario A min-heap is a binary tree where the value of each parent node is less than or equal to the values of its children, ensuring the smallest element is kept at the root. You are tasked to implement a min-heap for efficiently managing priority queues where the smallest element needs to be accessed or removed quickly. Task Implement a class `MinHeap` with the following methods: 1. **`__init__(self):`** * Initializes an empty min-heap. 2. **`insert(self, val: int) -> None:`** * Inserts the value into the min-heap. 3. **`get_min(self) -> int:`** * Returns the smallest value from the min-heap without removing it. 4. **`extract_min(self) -> int:`** * Removes and returns the smallest value from the min-heap. 5. **`heapify(self, arr: List[int]) -> None:`** * Turns a given list into a min-heap in place. Constraints * Follow the min-heap property and maintain logarithmic time complexity for insertions and deletions. * The heap should support dynamic insertion and deletion of elements. * The methods will be called as follows: * `heap = MinHeap()` * `heap.insert(val)` * `min_val = heap.get_min()` * `min_val = heap.extract_min()` * `heap.heapify(arr)` Example ```python heap = MinHeap() heap.insert(3) heap.insert(1) heap.insert(6) print(heap.get_min()) # returns 1 print(heap.extract_min()) # returns 1 and removes it print(heap.get_min()) # returns 3 heap.insert(2) print(heap.get_min()) # returns 2 arr = [5, 2, 8, 3, 4] heap.heapify(arr) print([heap.extract_min() for _ in range(len(arr))]) # prints [2, 3, 4, 5, 8] ```","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: heapq.heappush(self.heap, val) def get_min(self) -> int: return self.heap[0] if self.heap else None def extract_min(self) -> int: return heapq.heappop(self.heap) if self.heap else None def heapify(self, arr: list) -> None: self.heap = arr[:] heapq.heapify(self.heap)"},{"question":"# Coding Assessment Question: Word Pattern Matching You are tasked to create a function to check if a given string follows a specified pattern. Each character in the pattern should map to a word in the string, and no two characters in the pattern should map to the same word. # Requirements - Implement the `follows_pattern(pattern: str, s: str) -> bool` function to check if the string `s` follows the given `pattern`. # Input - A string pattern where each character represents a unique element. - A string `s` that contains words separated by spaces. # Output - Return `True` if `s` follows the given pattern; otherwise, return `False`. # Function Signature ```python def follows_pattern(pattern: str, s: str) -> bool: pass ``` # Constraints - Both `pattern` and `s` are non-empty. - The pattern and words in `s` will only contain lowercase English letters. - The words in `s` are separated by a single space. # Example ```python if __name__ == \\"__main__\\": pattern = \\"abba\\" s = \\"dog cat cat dog\\" result = follows_pattern(pattern, s) print(f\\"Does the string follow the pattern? {result}\\") # Output: True pattern = \\"abba\\" s = \\"dog cat cat fish\\" result = follows_pattern(pattern, s) print(f\\"Does the string follow the pattern? {result}\\") # Output: False pattern = \\"aaaa\\" s = \\"dog dog dog dog\\" result = follows_pattern(pattern, s) print(f\\"Does the string follow the pattern? {result}\\") # Output: True pattern = \\"aaaa\\" s = \\"dog dog dog cat\\" result = follows_pattern(pattern, s) print(f\\"Does the string follow the pattern? {result}\\") # Output: False ```","solution":"def follows_pattern(pattern: str, s: str) -> bool: Determines if the given string s follows the specified pattern. Args: pattern (str): The pattern string where each character represents a particular word. s (str): The string composed of words separated by spaces. Returns: bool: True if the pattern matches the given string s, otherwise False. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# List Reversal with Constraints Background Handling and manipulating arrays is a fundamental aspect of programming. A common task is reversing the order of elements within a list. However, additional constraints can make this task more challenging and require more thoughtful implementation. This problem tests your understanding of list operations and constrained transformations. Problem Statement Write a function `reverse_within_bounds` that reverses the elements of a given list within specified bounds. The inputs are a list, a start index, and an end index, within which the reversal of elements should take place. The rest of the elements outside these bounds should remain in their original order. ```python def reverse_within_bounds(array: list, start: int, end: int) -> list: Reverses elements of the given list \'array\' from index \'start\' to index \'end\' (inclusive). Elements outside the specified bounds should remain unchanged. Examples: >>> reverse_within_bounds([1, 2, 3, 4, 5, 6], 1, 4) [1, 5, 4, 3, 2, 6] >>> reverse_within_bounds([\'a\', \'b\', \'c\', \'d\', \'e\'], 0, 2) [\'c\', \'b\', \'a\', \'d\', \'e\'] >>> reverse_within_bounds([10, 20, 30, 40, 50], 2, 4) [10, 20, 50, 40, 30] >>> reverse_within_bounds([1, 2, 3, 4], 0, 3) [4, 3, 2, 1] pass ``` # Input - `array` (list): The input list containing elements to be manipulated. - `start` (int): The starting index of the range within which elements need to be reversed. - `end` (int): The ending index of the range within which elements need to be reversed. # Output - `list`: A list where elements between `start` and `end` (inclusive) are reversed, while elements outside this range remain in their original order. # Constraints - The array may contain any type of elements (e.g., integers, strings). - The start and end indices will always be valid and within the length of the array. - The start index will be less than or equal to the end index. # Requirements - Handle edge cases such as single-element lists, and no-op reversals where start and end indices encapsulate an invalid (or empty) range. - Ensure the implementation is efficient, even for long lists. # Testing You may assume the presence of a testing framework similar to `doctest`. Comprehensive tests covering all mentioned scenarios will be appreciated. Good luck, and happy coding!","solution":"def reverse_within_bounds(array: list, start: int, end: int) -> list: Reverses elements of the given list \'array\' from index \'start\' to index \'end\' (inclusive). Elements outside the specified bounds should remain unchanged. Examples: >>> reverse_within_bounds([1, 2, 3, 4, 5, 6], 1, 4) [1, 5, 4, 3, 2, 6] >>> reverse_within_bounds([\'a\', \'b\', \'c\', \'d\', \'e\'], 0, 2) [\'c\', \'b\', \'a\', \'d\', \'e\'] >>> reverse_within_bounds([10, 20, 30, 40, 50], 2, 4) [10, 20, 50, 40, 30] >>> reverse_within_bounds([1, 2, 3, 4], 0, 3) [4, 3, 2, 1] # Slice the array for the reversal range reversed_segment = array[start:end+1][::-1] # Combine the segments to form the final array return array[:start] + reversed_segment + array[end+1:]"},{"question":"# Coding Assessment Question Context You are tasked with enhancing a binary tree implementation to include a new functionality: checking if the tree is a valid binary search tree (BST). The goal is to ensure you understand how to traverse a binary tree and validate its properties. Task Implement a method `is_bst` within the `BinaryTree` class that checks whether the binary tree satisfies the conditions of a binary search tree. Function Specification ```python def is_bst(self) -> bool: Checks if the binary tree is a valid binary search tree (BST). Examples: >>> tree = BinaryTree() >>> tree.insert(2) >>> tree.insert(1) >>> tree.insert(3) >>> tree.is_bst() True When the binary tree is empty: >>> empty_tree = BinaryTree() >>> empty_tree.is_bst() True When the binary tree is not a BST: >>> tree = BinaryTree() >>> tree.root = TreeNode(5) >>> tree.root.left = TreeNode(3) >>> tree.root.right = TreeNode(8) >>> tree.root.left.left = TreeNode(2) >>> tree.root.left.right = TreeNode(6) # Incorrect to have 6 here >>> tree.is_bst() False Returns: bool: True if the binary tree is a valid BST, False otherwise. pass ``` Constraints * You should traverse the binary tree using in-order traversal. * Aim to complete the check in O(n) time complexity, where n is the number of nodes in the binary tree. * The additional space complexity should be O(h), where h is the height of the tree (considering the recursion stack). Input Format A method `is_bst` is added to the `BinaryTree` class with no input parameters. Output Format A boolean value, True if the tree is a valid BST, False otherwise. Examples * Input: BinaryTree with nodes inserted in the order [2, 1, 3] * Expected Output after `is_bst` is called: True * Input: BinaryTree with structure where node 5 has left child 3 and right child 8, and node 3 has left child 2 and right child 6 (incorrect placement) * Expected Output after `is_bst` is called: False","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.val: if root.left is None: root.left = TreeNode(val) else: self._insert(root.left, val) else: if root.right is None: root.right = TreeNode(val) else: self._insert(root.right, val) def is_bst(self) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')) -> bool: if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(self.root)"},{"question":"# Finding Longest Palindromic Substring Context You are developing a feature for a text editor that identifies the longest palindromic substring within the provided text. A palindromic substring is a substring that reads the same forward and backward (ignoring spaces and punctuation). Problem Statement Write a function `longest_palindromic_substring` that takes a string `s` and returns the longest palindromic substring within `s`. The function should ignore spaces and punctuation when determining the palindrome but return the exact substring from the original input. Input Format - A string `s` of length `1 <= len(s) <= 10^4`. - The string can contain letters (both uppercase and lowercase), spaces, and punctuation marks. Output Format - A string representing the longest palindromic substring found in `s`. Constraints - The search should be case-insensitive, meaning \'A\' is considered equal to \'a\'. - If there are multiple palindromic substrings of the same maximum length, return the one that appears first. Performance Requirements - The time complexity should be O(n^2) in the worst case. - Optimize space usage to ensure it is efficient given the constraints. Function Signature ```python def longest_palindromic_substring(s: str) -> str: pass ``` Example ```python # Input s = \\"Madam, in Eden, I\'m Adam.\\" # Output \\"Madam, in Eden, I\'m Adam\\" # Another example s = \\"A man, a plan, a canal, Panama!\\" # Output \\"A man, a plan, a canal, Panama\\" # Explanation For both examples, the longest palindromic substring includes almost all the text, ignoring spaces and punctuation. def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the input string `s`. import re def clean_string(s): return re.sub(r\'[^A-Za-z]\', \'\', s).lower() def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 if not s: return \\"\\" cleaned_s = clean_string(s) if not cleaned_s: return \\"\\" start, end = 0, 0 for i in range(len(cleaned_s)): l1, r1 = expand_around_center(cleaned_s, i, i) l2, r2 = expand_around_center(cleaned_s, i, i + 1) if (r1 - l1) > (end - start): start, end = l1, r1 if (r2 - l2) > (end - start): start, end = l2, r2 original_start = original_end = None idx = cleaned_s.find(cleaned_s[start:end + 1]) cleaned_segment = list(cleaned_s[start:end + 1]) count = 0 for i, char in enumerate(s): if re.match(r\'[A-Za-z]\', char, re.I): if count == idx: original_start = i if count == idx + len(cleaned_segment) - 1: original_end = i count += 1 return s[original_start:original_end + 1] # Test cases assert longest_palindromic_substring(\\"Madam, in Eden, I\'m Adam.\\") == \\"Madam, in Eden, I\'m Adam\\" assert longest_palindromic_substring(\\"A man, a plan, a canal, Panama!\\") == \\"A man, a plan, a canal, Panama\\" ```","solution":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the input string `s`. import re def clean_string(s): return re.sub(r\'[^A-Za-z]\', \'\', s).lower() def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 if not s: return \\"\\" cleaned_s = clean_string(s) if not cleaned_s: return \\"\\" start, end = 0, 0 for i in range(len(cleaned_s)): l1, r1 = expand_around_center(cleaned_s, i, i) l2, r2 = expand_around_center(cleaned_s, i, i + 1) if (r1 - l1) > (end - start): start, end = l1, r1 if (r2 - l2) > (end - start): start, end = l2, r2 original_start = original_end = None idx = cleaned_s.find(cleaned_s[start:end + 1]) cleaned_segment = list(cleaned_s[start:end + 1]) count = 0 for i, char in enumerate(s): if re.match(r\'[A-Za-z]\', char, re.I): if count == idx: original_start = i if count == idx + len(cleaned_segment) - 1: original_end = i break count += 1 return s[original_start:original_end + 1]"},{"question":"# Problem Statement You are given an array of positive integers and a series of range queries. Each query asks for the range sum of the array\'s elements between two given indices. Your task is to efficiently preprocess the array to handle the queries quickly using a Fenwick Tree (Binary Indexed Tree). Input Format 1. An integer `n` representing the number of elements in the array. 2. An array of `n` positive integers. 3. An integer `q` representing the number of range sum queries. 4. `q` pairs of integers `(l, r)` representing the inclusive starting and ending indices for each range sum query. Output Format Print `q` integers, each representing the sum of the array\'s elements for the corresponding range `(l, r)`. Constraints - (1 leq n leq 10^5) - (1 leq a_i leq 10^4) where (a_i) is the i-th element of the array - (1 leq q leq 10^5) - (0 leq l leq r < n) Example **Input** ``` 8 1 2 3 4 5 6 7 8 3 0 2 1 5 2 7 ``` **Output** ``` 6 20 33 ``` Task Implement the following function: ```python def find_range_sums(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: # Your implementation here ``` In this function, `n` is the number of elements in the array, `arr` is the list of `n` positive integers, and `queries` is the list of `q` range sum queries. **Performance Notes**: - Ensure that the preprocessing and query handling are efficient, leveraging the Fenwick Tree (Binary Indexed Tree) for optimal performance. - Each query should be answered in logarithmic time. # Explanation To solve this problem, you should: 1. Construct a Fenwick Tree (Binary Indexed Tree) for the prefix sums of the array. 2. Process each range sum query using the prefix sums computed using the Fenwick Tree. This method ensures efficient preprocessing and fast query response time, making it suitable for large input sizes.","solution":"from typing import List, Tuple class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def add(self, idx: int, value: int): idx += 1 while idx <= self.size: self.tree[idx] += value idx += (idx & -idx) def sum(self, idx: int) -> int: idx += 1 result = 0 while idx > 0: result += self.tree[idx] idx -= (idx & -idx) return result def range_sum(self, left: int, right: int) -> int: if left > 0: return self.sum(right) - self.sum(left - 1) else: return self.sum(right) def find_range_sums(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.add(i, arr[i]) result = [] for l, r in queries: result.append(fenwick_tree.range_sum(l, r)) return result"},{"question":"# Coding Assessment Question Context You are working on a program that analyzes social media posts. A key feature of the program is to detect the sentiment of each post. The sentiment scores range from -1 (very negative) to 1 (very positive). You need to write a function to analyze the posts and compute the average sentiment score, which will help in understanding the overall sentiment of the posts. Task Write a function `average_sentiment_score` that, given a list of sentiment scores of social media posts, computes the average sentiment score. # Function Signature ```python def average_sentiment_score(scores: List[float]) -> float: Computes the average sentiment score of social media posts. Args: scores: List of floats representing the sentiment scores of different social media posts. Returns: float: The average sentiment score. ``` # Input and Output Format - **Input**: - `scores` : A list of floats where each element is a sentiment score ranging from -1 to 1. - **Output**: A float value representing the average sentiment score. # Constraints - Assume `0 <= len(scores) <= 10^6`. - The sentiment scores range from -1.0 to 1.0. # Example ```python scores = [0.5, -0.2, 0.8, -0.9, 0.1] average_score = average_sentiment_score(scores) print(average_score) # Expected output: 0.06 ``` # Notes - Consider the case where the list is empty and handle it appropriately. An empty list should return a sentiment score of `0.0`. Hints 1. Use the built-in `sum` and `len` functions to compute the average. 2. Handle edge cases such as an empty list by returning `0.0`. --- This question aims to test your ability to work with basic numerical computations and lists, ensuring that the solution is efficient and handles edge cases appropriately.","solution":"from typing import List def average_sentiment_score(scores: List[float]) -> float: Computes the average sentiment score of social media posts. Args: scores: List of floats representing the sentiment scores of different social media posts. Returns: float: The average sentiment score. if not scores: return 0.0 return sum(scores) / len(scores)"},{"question":"# Problem Description You need to implement a function `find_missing_number` that determines the missing number in an array containing distinct numbers from `1` to `n` except one missing number. # Function Signature ```python def find_missing_number(arr: List[int]) -> int: pass ``` # Input - `arr (List[int])`: A list of integer numbers representing the sequence from `1` to `n` with exactly one number missing. The length of the list is `n-1`. # Output - An integer that is the missing number from the sequence. # Constraints - The array `arr` will have a length of `n-1` where `1 ≤ n ≤ 10^5`. - The elements of `arr` are distinct and within the range from `1` to `n`. # Example ```python # Example 1 arr = [3, 7, 1, 2, 8, 4, 5] print(find_missing_number(arr)) # Output: 6 # Example 2 arr = [1, 2, 4, 5, 6] print(find_missing_number(arr)) # Output: 3 ``` # Note - Be mindful of the time complexity of your solution, as the array length `n` can be as large as `10^5`. - Consider how the sum of the first `n` natural numbers can help in finding the missing number efficiently. # Hints * You may use the formula for the sum of the first `n` natural numbers: ( text{Sum} = frac{n times (n + 1)}{2} ). * Subtract the sum of the numbers in the array from the total sum to find the missing number.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Determines the missing number in an array containing distinct numbers from 1 to n except one missing number. Parameters: arr (List[int]): List of integer numbers representing the sequence from 1 to n with one number missing. Returns: int: The missing number from the sequence. n = len(arr) + 1 # since one number is missing total_sum = n * (n + 1) // 2 arr_sum = sum(arr) return total_sum - arr_sum"},{"question":"# Objective Create a class to model a simple Inventory System that can track items, calculate total inventory value, and handle restocking of items. # Class Design Class: `InventoryItem` - **Attributes**: - `name` (str): Name of the inventory item. - `quantity` (int): Quantity of the item in stock. - `price_per_unit` (float): Price per unit of the item. - **Methods**: - `__init__(self, name: str, quantity: int, price_per_unit: float)`: Constructor to initialize the item attributes. - `get_total_value(self) -> float`: Calculate and return the total value of the inventory item (quantity * price per unit). - `restock(self, amount: int)`: Increase the quantity of the item by the specified amount. Class: `Inventory` - **Attributes**: - `items` (list): A list to hold `InventoryItem` objects. - **Methods**: - `__init__(self)`: Constructor to initialize the items list. - `add_item(self, item: InventoryItem)`: Add a new `InventoryItem` to the inventory. - `get_inventory_value(self) -> float`: Calculate and return the total value of all inventory items. - `find_item(self, name: str) -> InventoryItem`: Find and return the `InventoryItem` object with the given name. Raise a `ValueError` if the item is not found. # Example ```python class InventoryItem: def __init__(self, name: str, quantity: int, price_per_unit: float): if quantity < 0 or price_per_unit < 0: raise ValueError(\\"Quantity and price per unit must be non-negative.\\") self.name = name self.quantity = quantity self.price_per_unit = price_per_unit def get_total_value(self) -> float: return self.quantity * self.price_per_unit def restock(self, amount: int): if amount < 0: raise ValueError(\\"Restock amount must be non-negative.\\") self.quantity += amount class Inventory: def __init__(self): self.items = [] def add_item(self, item: InventoryItem): self.items.append(item) def get_inventory_value(self) -> float: total_value = 0 for item in self.items: total_value += item.get_total_value() return total_value def find_item(self, name: str) -> InventoryItem: for item in self.items: if item.name == name: return item raise ValueError(\\"Item not found in the inventory.\\") ``` Sample Usage ```python # Create inventory items item1 = InventoryItem(\\"Laptop\\", 10, 999.99) item2 = InventoryItem(\\"Phone\\", 25, 499.99) item3 = InventoryItem(\\"Tablet\\", 15, 329.99) # Create an inventory inventory = Inventory() # Add items to the inventory inventory.add_item(item1) inventory.add_item(item2) inventory.add_item(item3) # Calculate the total inventory value print(inventory.get_inventory_value()) # Expected output: 19974.75 # Restock an item item1.restock(5) print(item1.quantity) # Expected output: 15 # Find an item in the inventory found_item = inventory.find_item(\\"Phone\\") print(found_item.name, found_item.quantity, found_item.price_per_unit) # Expected output: Phone 25 499.99 ``` # Notes - Ensure appropriate error handling for negative quantities and prices. - Make sure the solution adheres to object-oriented design principles. - Handle edge cases effectively.","solution":"class InventoryItem: def __init__(self, name: str, quantity: int, price_per_unit: float): if quantity < 0 or price_per_unit < 0: raise ValueError(\\"Quantity and price per unit must be non-negative.\\") self.name = name self.quantity = quantity self.price_per_unit = price_per_unit def get_total_value(self) -> float: return self.quantity * self.price_per_unit def restock(self, amount: int): if amount < 0: raise ValueError(\\"Restock amount must be non-negative.\\") self.quantity += amount class Inventory: def __init__(self): self.items = [] def add_item(self, item: InventoryItem): self.items.append(item) def get_inventory_value(self) -> float: total_value = 0 for item in self.items: total_value += item.get_total_value() return total_value def find_item(self, name: str) -> InventoryItem: for item in self.items: if item.name == name: return item raise ValueError(\\"Item not found in the inventory.\\")"},{"question":"# Coding Assessment Question Context You have been provided with a code snippet that implements a basic word frequency counter from a given text. The current implementation processes the entire text at once, which can be inefficient for large texts. Your task is to improve the code to handle large texts more efficiently. Task Your task is to refactor the existing code to improve its performance and handle edge cases. Specifically, you need to address the following improvements: 1. **Chunk Processing**: Modify the implementation to process the text in fixed-size chunks instead of processing the entire text at once. This involves reading the text in chunks and updating the frequency counter incrementally. 2. **Case Insensitivity**: Ensure the word frequency count is case-insensitive. 3. **Error Handling**: Ensure the code can handle cases where the input text is empty or contains no valid words. Function Signature ```python def run_optimized_word_counter(file_path: str, chunk_size: int): Optimized word frequency counter with chunk processing. Parameters: file_path (str): Path to the text file. chunk_size (int): Size of the chunks to process. Note: Ensure case insensitivity and proper error handling. ``` Input * **file_path (str)**: The path to the text file. * **chunk_size (int)**: The size of the chunks to process the text. Output * The function should print the word frequency dictionary. * It should handle and print appropriate messages for edge cases such as empty or invalid text files. Constraints * Use a reasonable chunk size to balance memory usage and performance. * Ensure the code is robust against empty text files or files with no valid words. Example ```python # Call the function with a file path and chunk size 1024 run_optimized_word_counter(file_path=\\"sample.txt\\", chunk_size=1024) ``` **Expected Outcome**: The function should efficiently count word frequencies, print the frequency dictionary, and handle edge cases appropriately. Good luck!","solution":"from collections import defaultdict import re def run_optimized_word_counter(file_path: str, chunk_size: int): Optimized word frequency counter with chunk processing. Parameters: file_path (str): Path to the text file. chunk_size (int): Size of the chunks to process. Note: Ensure case insensitivity and proper error handling. word_count = defaultdict(int) try: with open(file_path, \'r\', encoding=\'utf-8\') as file: while True: chunk = file.read(chunk_size) if not chunk: break # Normalize case chunk = chunk.lower() # Find all words using regex words = re.findall(r\'bw+b\', chunk) for word in words: word_count[word] += 1 except FileNotFoundError: print(\\"File not found. Please check the file path.\\") return if len(word_count) == 0: print(\\"No valid words found in the file.\\") print(dict(word_count))"},{"question":"# Question You need to implement a thread-safe bounded blocking queue, which consistently controls access and modifications by multiple threads. # Problem Statement: Design and implement a `BoundedBlockingQueue` class that meets the following specifications: - The queue should have a fixed capacity and support multiple threads concurrently adding and removing elements. - Implement essential thread-synchronization mechanisms to ensure safe operations across various threads. - Provide methods to `enqueue` elements at the rear, `dequeue` elements from the front, and a method `size` to get the current number of elements in the queue. - Ensure proper handling of edge cases like attempting to add elements when the queue is full, or removing elements when the queue is empty. # Input and Output: **Input**: - The capacity of the queue, specified during instantiation. - A sequence of operations performed by multiple threads (performed in a test setting). **Output**: - Appropriate results based on the performed operations. **Constraints**: - The queue\'s capacity will remain fixed once it is initialized. - Only integers will be enqueued. - The total number of operations will not exceed 100000. # Example: ```python Example 1: Queue initialized with capacity: 2 Thread 1 enqueues: [1, 2] Thread 2 attempts to enqueue: 3 (blocks as queue is full) Thread 3 dequeues: 1 (Thread 2 is now able to enqueue 3) Thread 3 dequeues: 2 Method size() returns: 1 ``` Implement `BoundedBlockingQueue` class that ensures thread safety during concurrent operations. Include proper handling of synchronization using locks or other concurrency control mechanisms, and ensure thorough testing for concurrency issues. ```python from threading import Lock, Condition class BoundedBlockingQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [] self.lock = Lock() self.not_full = Condition(self.lock) self.not_empty = Condition(self.lock) def enqueue(self, element: int) -> None: with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while not self.queue: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: with self.lock: return len(self.queue) ``` Ensure that your implementation handles cases where multiple threads access the queue simultaneously, and validate the correctness and performance through thorough testing.","solution":"from threading import Lock, Condition class BoundedBlockingQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [] self.lock = Lock() self.not_full = Condition(self.lock) self.not_empty = Condition(self.lock) def enqueue(self, element: int) -> None: with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while not self.queue: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: with self.lock: return len(self.queue)"},{"question":"# Coding Question: Implement Inverted Index Construction for Text Documents Context An inverted index is a data structure used to create a mapping from terms to their locations in a database of documents. This is a fundamental concept in information retrieval systems. Task **Implement a function to construct an inverted index from a given list of documents, each represented as a string. Your implementation should be efficient in handling large datasets and include case-insensitive term processing.** Input * `documents` (List of strings): A list of `n` documents, where each document is a string consisting of words separated by spaces. Output * A dictionary where each key is a unique term (in lowercase), and the value is a list of document indices (0-based) in which the term appears. The list of indices should be in ascending order. Requirements * Efficiently process the documents, especially for large lists containing many terms. * Ensure the terms are case-insensitive. * The output should exclude any empty terms caused by processing (e.g., multiple spaces). Constraints * The number of documents `n` can be as large as `10^5`. * Each document can contain up to `10^4` words. # Example ```python >>> documents = [\\"Hello World\\", \\"HELLO there\\", \\"World\\"] >>> inverted_index(documents) { \'hello\': [0, 1], \'world\': [0, 2], \'there\': [1] } >>> documents = [\\"The quick brown fox\\", \\"jumps over the lazy dog\\"] >>> inverted_index(documents) { \'the\': [0, 1], \'quick\': [0], \'brown\': [0], \'fox\': [0], \'jumps\': [1], \'over\': [1], \'lazy\': [1], \'dog\': [1] } ``` # Implementation Notes 1. Use dictionaries to efficiently map terms to their document indices. 2. Normalize all terms to lowercase to ensure case-insensitivity. 3. Maintain the order of document indices in the lists for each term. ```python from collections import defaultdict from typing import List, Dict def inverted_index(documents: List[str]) -> Dict[str, List[int]]: Construct an inverted index from a list of text documents. Args: documents (List[str]): A list of strings where each string represents a document. Returns: Dict[str, List[int]]: A dictionary mapping each term to a list of document indices. index = defaultdict(list) for doc_id, content in enumerate(documents): terms = content.lower().split() seen_terms = set() for term in terms: if term not in seen_terms: index[term].append(doc_id) seen_terms.add(term) return dict(index) # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from collections import defaultdict from typing import List, Dict def inverted_index(documents: List[str]) -> Dict[str, List[int]]: Construct an inverted index from a list of text documents. Args: documents (List[str]): A list of strings where each string represents a document. Returns: Dict[str, List[int]]: A dictionary mapping each term to a list of document indices. index = defaultdict(list) for doc_id, content in enumerate(documents): terms = content.lower().split() seen_terms = set() for term in terms: if term not in seen_terms: index[term].append(doc_id) seen_terms.add(term) return dict(index)"},{"question":"# Problem Statement A factory builds widgets, and each widget consists of multiple parts. To ensure quality and consistency, every part (denoted by a positive integer) of a widget must be divisible by a specific divisor. Your task is to design a function that counts the number of valid widgets in a list based on this criterion. A valid widget is defined as a list of parts where each part in the widget list is divisible by a given integer divisor `d`. # Function Signature ```python def count_valid_widgets(widget_parts: List[List[int]], d: int) -> int: pass ``` # Input - `widget_parts` (List[List[int]]): A list of widgets, where each widget is represented as a list of integers (the parts). - `d` (int): A positive integer representing the divisor. # Output - Return the number of valid widgets. A valid widget has each part divisible by `d`. # Constraints 1. `1 ≤ len(widget_parts) ≤ 10^4` - the number of widgets 2. `1 ≤ len(widget_parts[i]) ≤ 10^2` - the number of parts in each widget 3. `1 ≤ widget_parts[i][j] ≤ 10^6` - the value of each part 4. `1 ≤ d ≤ 10^6` - the divisor # Examples ```python assert count_valid_widgets([[4, 8, 12], [3, 6, 9], [5, 10, 15]], 4) == 1 assert count_valid_widgets([[2, 4, 6], [8, 10, 12], [14, 16, 18]], 2) == 3 assert count_valid_widgets([[7, 14, 21], [28, 35, 42], [49, 56, 63]], 7) == 3 assert count_valid_widgets([[5, 10, 15], [20, 25, 30], [35, 40, 45]], 10) == 0 ``` # Detailed explanation for example cases 1. In the first example, only the first widget `[4, 8, 12]` is valid for the divisor `4`, so the result is `1`. 2. In the second example, all widgets `[2, 4, 6]`, `[8, 10, 12]`, and `[14, 16, 18]` are valid for the divisor `2`, so the result is `3`. 3. In the third example, all widgets are valid for the divisor `7`. 4. In the fourth example, none of the widgets contain only parts divisible by the divisor `10`.","solution":"from typing import List def count_valid_widgets(widget_parts: List[List[int]], d: int) -> int: Count the number of valid widgets in the list `widget_parts` where each part of a widget is divisible by the divisor `d`. Parameters: widget_parts (List[List[int]]): A list of widgets, where each widget is represented as a list of integers (the parts). d (int): A positive integer representing the divisor. Returns: int: The number of valid widgets. valid_count = 0 for widget in widget_parts: if all(part % d == 0 for part in widget): valid_count += 1 return valid_count"},{"question":"# Question: Implement an In-Place Merge of Two Sorted Arrays Context: You need to merge two sorted arrays into one sorted array. However, the catch is that you have to do this merge operation in-place. The first array (`arr1`) has enough buffer at its end to accommodate all elements of the second array (`arr2`). The elements of `arr1` initially fill up the front part of the array, followed by zeros which serve as placeholders for the elements of `arr2`. Requirements: 1. **Function Signature**: - `def merge(arr1: List[int], m: int, arr2: List[int], n: int) -> None` 2. **Input and Output Formats**: - The function takes four parameters: two lists (`arr1` and `arr2`) and two integers (`m` and `n`). - `arr1` has a total length of `m + n` with its first `m` elements sorted and valid, and the remaining elements being `0`. - `arr2` has `n` sorted elements. - The function does not return anything, but modifies `arr1` in-place to contain the merged elements. 3. **Constraints**: - `0 <= m, n <= 10^4` - Both `arr1` and `arr2` are already sorted in non-decreasing order. - The elements in `arr1` and `arr2` are integers. Example Usage: ```python arr1 = [1, 2, 3, 0, 0, 0] arr2 = [2, 5, 6] merge(arr1, 3, arr2, 3) assert arr1 == [1, 2, 2, 3, 5, 6] arr1 = [1] arr2 = [] merge(arr1, 1, arr2, 0) assert arr1 == [1] arr1 = [0] arr2 = [1] merge(arr1, 0, arr2, 1) assert arr1 == [1] ``` Instructions: 1. Implement the `merge` function to merge `arr2` into `arr1`, modifying `arr1` in-place. 2. Ensure to handle the edge cases where either `m` or `n` is zero. 3. The solution should efficiently handle large inputs with minimal extra space, running in O(m + n) time complexity. --- Here\'s the function signature to get you started: ```python from typing import List def merge(arr1: List[int], m: int, arr2: List[int], n: int) -> None: # Start filling \'arr1\' from the end last = m + n - 1 # Pointers for arr1 and arr2 i, j = m - 1, n - 1 # Merge arr1 and arr2 starting from the end of both arrays while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[last] = arr1[i] i -= 1 else: arr1[last] = arr2[j] j -= 1 last -= 1 # Fill arr1 with the remaining elements of arr2 (if any) while j >= 0: arr1[last] = arr2[j] j -= 1 last -= 1 # No need to fill arr1 with remaining elements of arr1, since they are already in place ```","solution":"from typing import List def merge(arr1: List[int], m: int, arr2: List[int], n: int) -> None: last = m + n - 1 i, j = m - 1, n - 1 while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[last] = arr1[i] i -= 1 else: arr1[last] = arr2[j] j -= 1 last -= 1 while j >= 0: arr1[last] = arr2[j] j -= 1 last -= 1"},{"question":"**Question:** You are assigned to find the smallest positive integer `n` such that the product of the first `n` Fibonacci numbers is a perfect square. The Fibonacci sequence is defined as: - F(1) = 1 - F(2) = 1 - F(n) = F(n-1) + F(n-2) for n > 2 Given that Fibonacci numbers grow exponentially, you need to come up with an efficient algorithm to determine the required smallest `n`. # Task: Implement the function `smallest_fibonacci_square` that computes and returns the smallest positive integer `n` such that the product of the first `n` Fibonacci numbers is a perfect square. # Input: None. The function does not require any parameters. # Output: - **Return Type**: Integer - **Description**: The smallest positive integer `n` such that the product of the first `n` Fibonacci numbers is a perfect square. # Constraints and Notes: - You may assume that there exists such a positive integer `n`. - The Fibonacci numbers involved can be large, hence consider efficiency in both time and space. - Make use of properties of Fibonacci numbers and perfect squares where necessary to optimize your solution. # Example: When you call the function `smallest_fibonacci_square()`, it should compute and return the smallest integer `n` that meets the criteria. Suppose the function is implemented and executed: ```python def smallest_fibonacci_square() -> int: # implement the function here pass if __name__ == \\"__main__\\": result = smallest_fibonacci_square() print(result) # Should print the smallest integer n ``` You are expected to validate the products of Fibonacci numbers, check for perfect squares efficiently, and ensure that your solution performs well even for relatively high values of `n`. Implement any supporting utility functions within `smallest_fibonacci_square` as required.","solution":"import math def is_perfect_square(x): Check if x is a perfect square. s = int(math.isqrt(x)) return s * s == x def smallest_fibonacci_square(): Find the smallest positive integer n such that the product of the first n Fibonacci numbers is a perfect square. # Initial variables a, b = 1, 1 # F(1), F(2) product = 1 # Product of Fibonacci numbers index = 2 # Because we already have F(1) and F(2) and F(1)*F(2)=1 (which is a perfect square) while True: if is_perfect_square(product): return index - 1 # Generate the next Fibonacci number product *= a a, b = b, a + b index += 1"},{"question":"# Coding Assessment Question You are part of a development team working on an e-commerce platform. One of the services the platform offers is the ability to track the inventory of products. As part of maintaining the inventory, a crucial function is to determine the highest price of items available in stock given an inventory of products with their respective prices. Problem Statement Write a function named `find_max_price` that finds and returns the highest price of any product from a given dictionary. The dictionary keys represent product names, and the values represent their prices. Function Signature ```python def find_max_price(products: dict) -> float: pass ``` Input - `products`: A dictionary where: - The key is a string representing the name of a product. - The value is a float representing the price of the product. Output - Returns a float representing the highest price of any product in the dictionary. - If the dictionary is empty, the function should return `None`. Example ```python assert find_max_price({\\"Laptop\\": 899.99, \\"Smartphone\\": 699.50, \\"Tablet\\": 400.00}) == 899.99 assert find_max_price({\\"Book\\": 15.95, \\"Pen\\": 1.20, \\"Pencil\\": 0.25}) == 15.95 assert find_max_price({}) == None assert find_max_price({\\"Shoes\\": 45.99, \\"Hat\\": 20.00, \\"Jacket\\": 89.99, \\"Scarf\\": 25.00}) == 89.99 ``` Constraints - The price values will always be non-negative floats. - Product names will be non-empty strings. - Edge case: Handle an empty dictionary by returning `None`. Requirements - Implement the function `find_max_price` as described. - Ensure the function passes basic tests to verify its correctness.","solution":"def find_max_price(products: dict) -> float: Returns the highest price from a dictionary of products. If the dictionary is empty, returns None. if not products: return None return max(products.values())"},{"question":"# Coding Assessment Question You are required to extend the functionality of a program that monitors a cryptocurrency portfolio using a public API. The existing implementation calculates the current value of the portfolio based on real-time prices. Now, extend the functionality to include calculations of the highest and lowest portfolio value within a specific date range. Task: 1. Implement a function `get_portfolio_value_by_date_range(api_key: str, portfolio: dict, start_date: str, end_date: str) -> dict` that: - Fetches historical price data for each cryptocurrency in the portfolio within the specified date range. - Calculates and returns a dictionary containing the highest and lowest portfolio values during that period. 2. Optimize the `get_current_portfolio_value` function to handle invalid API responses and edge cases. Expected Input and Output: * `get_portfolio_value_by_date_range`: - **Input**: - `api_key`: str - `portfolio`: dict (where keys are cryptocurrency symbols and values are amounts held, e.g., {\'BTC\': 1.5, \'ETH\': 10}) - `start_date`: str (in YYYY-MM-DD format) - `end_date`: str (in YYYY-MM-DD format) - **Output**: Dictionary with keys \'highest_value\' and \'lowest_value\', each containing the respective portfolio value as a float. * `get_current_portfolio_value`: - **Input**: `api_key`: str, `portfolio`: dict - **Output**: Returns the current portfolio value as a float, or an error message in case of failure. Constraints: - All input strings will be non-empty and properly formatted as per their descriptions. - The date range will be valid (i.e., the end date will always be equal to or after the start date). Performance Requirements: - Ensure network requests are handled efficiently. - Include basic error handling to manage potential failure scenarios (e.g., invalid API key, network timeout). Hints: - Use Python\'s `requests` library for making HTTP requests. - Handle JSON responses and potential exceptions gracefully. - Utilize a Crypto API that provides historical data, such as CoinGecko or CryptoCompare. Implement the following: ```python import requests from datetime import datetime, timedelta def get_historical_price(api_key: str, symbol: str, date: str) -> float: url = f\\"https://api.coingecko.com/api/v3/coins/{symbol}/history\\" params = {\'date\': date.replace(\'-\', \'\'), \'localization\': \'false\'} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json() return data[\'market_data\'][\'current_price\'][\'usd\'] except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return 0.0 def get_portfolio_value_by_date_range(api_key: str, portfolio: dict, start_date: str, end_date: str) -> dict: start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') highest_value = 0.0 lowest_value = float(\'inf\') while start <= end: portfolio_value = 0.0 for symbol, amount in portfolio.items(): price = get_historical_price(api_key, symbol, start.strftime(\'%d-%m-%Y\')) portfolio_value += amount * price highest_value = max(highest_value, portfolio_value) lowest_value = min(lowest_value, portfolio_value) start += timedelta(days=1) return {\'highest_value\': highest_value, \'lowest_value\': lowest_value} def get_current_portfolio_value(api_key: str, portfolio: dict) -> float: url = \\"https://api.coingecko.com/api/v3/simple/price\\" params = { \'ids\': \',\'.join(portfolio.keys()), \'vs_currencies\': \'usd\' } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() prices = response.json() total_value = sum(amount * prices[symbol][\'usd\'] for symbol, amount in portfolio.items()) return total_value except requests.RequestException as e: return {\\"error\\": str(e)} ```","solution":"import requests from datetime import datetime, timedelta def get_historical_price(api_key: str, symbol: str, date: str) -> float: url = f\\"https://api.coingecko.com/api/v3/coins/{symbol}/history\\" params = {\'date\': date.replace(\'-\', \'\'), \'localization\': \'false\'} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json() return data[\'market_data\'][\'current_price\'][\'usd\'] except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return 0.0 def get_portfolio_value_by_date_range(api_key: str, portfolio: dict, start_date: str, end_date: str) -> dict: start = datetime.strptime(start_date, \'%Y-%m-%d\') end = datetime.strptime(end_date, \'%Y-%m-%d\') highest_value = 0.0 lowest_value = float(\'inf\') while start <= end: portfolio_value = 0.0 for symbol, amount in portfolio.items(): price = get_historical_price(api_key, symbol, start.strftime(\'%d-%m-%Y\')) portfolio_value += amount * price highest_value = max(highest_value, portfolio_value) lowest_value = min(lowest_value, portfolio_value) start += timedelta(days=1) return {\'highest_value\': highest_value, \'lowest_value\': lowest_value} def get_current_portfolio_value(api_key: str, portfolio: dict) -> float: url = \\"https://api.coingecko.com/api/v3/simple/price\\" params = { \'ids\': \',\'.join(portfolio.keys()), \'vs_currencies\': \'usd\' } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() prices = response.json() total_value = sum(amount * prices[symbol][\'usd\'] for symbol, amount in portfolio.items()) return total_value except requests.RequestException as e: return {\\"error\\": str(e)}"},{"question":"# Problem Statement You are given an array of integers, which might contain duplicates, and an integer `k`. Your task is to implement a function `find_kth_largest` that returns the k-th largest element in the array. If the array is empty or if `k` is out of the valid range, the function should return `None`. **Function Signature:** ```python def find_kth_largest(nums: List[int], k: int) -> int: pass ``` **Input:** * `nums`: An array of integers which might contain duplicates (0 <= len(nums) <= 10^6). * `k`: An integer representing the position of the largest element to find (1 <= k <= len(nums)). **Output:** * An integer representing the k-th largest element in the `nums`, or `None` if the array is empty or `k` is out of range. **Constraints:** - Elements in the array can be negative or positive and are not guaranteed to be unique. - Ensure your implementation runs efficiently even for large inputs. **Performance Requirements:** - Your implementation should aim for an average-case time complexity of O(n), using methods such as Quickselect (or equivalent). **Example:** ```python assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 assert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 assert find_kth_largest([], 1) == None assert find_kth_largest([7], 1) == 7 assert find_kth_largest([3, 3, 3], 2) == 3 assert find_kth_largest([1, 1, 1, 1], 3) == 1 assert find_kth_largest([10, 2, 3, 5, 8], 5) == 2 ``` **Explanation**: The function `find_kth_largest` finds the k-th largest element in the array possibly containing duplicates through an efficient selection algorithm. The function handles edge cases such as empty arrays and out-of-bound `k` values by returning `None`. This requires an efficient approach to deal with potentially large arrays, ensuring optimal average case time complexity.","solution":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: if not nums or k < 1 or k > len(nums): return None def quickselect(left, right, k_smallest): if left == right: return nums[left] pivot_index = partition(left, right) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) def partition(left, right): pivot = nums[right] i = left for j in range(left, right): if nums[j] > pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[right] = nums[right], nums[i] return i return quickselect(0, len(nums) - 1, k - 1)"},{"question":"# Problem Statement You have been tasked with implementing a basic spell-checking system that recognizes potentially incorrectly spelled words in a document. The system should be capable of suggesting possible correct words based on the given dictionary. The suggestion is based on edit distance (Levenshtein distance), which measures the minimum number of single-character edits required to change one word into another. Input - A list of `dictionary` words, all in lowercase. - A string `document` which may contain words separated by spaces, punctuation, or special characters. All characters in the `document` will be lowercase. Output - A list of tuples where each tuple contains an incorrectly spelled word from the document and a list of its closest matches from the dictionary based on edit distance. Function Signature ```python def spell_check(dictionary: List[str], document: str) -> List[Tuple[str, List[str]]]: # Implementation here ``` # Constraints 1. The size of the dictionary will be between `1` and `10000`. 2. Each word in the dictionary will not exceed `100` characters in length. 3. Words in the document will not exceed `100` characters in length. 4. The document will have at most `1000` words. # Example Input ```python dictionary = [\\"hello\\", \\"world\\", \\"spell\\", \\"checker\\", \\"programming\\", \\"language\\"] document = \\"helo word spel chequer progamming langauge\\" ``` Output ```python [ (\\"helo\\", [\\"hello\\"]), (\\"word\\", [\\"world\\"]), (\\"spel\\", [\\"spell\\"]), (\\"chequer\\", [\\"checker\\"]), (\\"progamming\\", [\\"programming\\"]), (\\"langauge\\", [\\"language\\"]) ] ``` # Additional Information 1. Implement `edit_distance` to compute the Levenshtein distance between two words. 2. For each word in the document that is not found in the dictionary, find the closest match(es) from the dictionary based on the edit distance. 3. If multiple words in the dictionary have the same minimum edit distance to the misspelled word, include all those words in the suggestion list. --- In this problem, you\'ll demonstrate understanding of string manipulation, usage of data structures to store and access information, and proficiency in implementing an algorithm to calculate edit distances between words.","solution":"from typing import List, Tuple import re def edit_distance(word1: str, word2: str) -> int: Computes the edit distance (Levenshtein distance) between two words. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i else: if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n] def spell_check(dictionary: List[str], document: str) -> List[Tuple[str, List[str]]]: Spell check a document against a dictionary and suggest correct words based on edit distance. # Split the document into words using regex to catch words separated by punctuation or special characters words_in_document = re.findall(r\'bw+b\', document) incorrect_words_with_suggestions = [] for word in words_in_document: if word not in dictionary: min_distance = float(\'inf\') closest_words = [] for dict_word in dictionary: distance = edit_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_words = [dict_word] elif distance == min_distance: closest_words.append(dict_word) incorrect_words_with_suggestions.append((word, closest_words)) return incorrect_words_with_suggestions"},{"question":"# [Coding Assessment Question] Implement a function `max_non_adjacent_sum(nums: List[int]) -> int` that calculates the maximum sum of non-adjacent elements in a given list of integers. # Input: - A list `nums` of integers where (0 <= len(nums) <= 1000 and -10^6 <= nums[i] <= 10^6 for all 0 <= i < len(nums)) # Output: - An integer representing the maximum sum of non-adjacent elements in the input list. # Constraints: 1. Your solution should handle lists with both positive and negative numbers. 2. Ensure an efficient algorithm capable of processing lists up to the maximum length limit. 3. Consider edge cases such as empty lists, lists with one element, or lists with all negative numbers. # Example: ```python assert max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 assert max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 assert max_non_adjacent_sum([3, 2, 7, 10]) == 13 assert max_non_adjacent_sum([]) == 0 assert max_non_adjacent_sum([5]) == 5 ``` # Scenario: You are working on a financial analytics system where you need to compute the maximum possible profit from a series of potential transactions, ensuring that no two transactions are adjacent in time. This problem simulates scenarios like stock trading where you must skip days between transactions to maximize gain.","solution":"def max_non_adjacent_sum(nums): This function returns the maximum sum of non-adjacent elements in the input list of integers. Args: nums (List[int]): List of integers to consider Returns: int: Maximum sum of non-adjacent elements # Handling edge cases if not nums: return 0 elif len(nums) == 1: return nums[0] # Initialize variables to store the maximum sum including and excluding the last considered element include, exclude = 0, 0 for num in nums: # Current maximum excluding this element will be maximum of previous include and exclude new_exclude = max(include, exclude) # Current include will be previous exclude + current element include = exclude + num exclude = new_exclude # Return maximum of include and exclude return max(include, exclude)"},{"question":"**Scenario**: You are working for a logistics company that deals with managing deliveries and maintaining an efficient schedule. One of the challenges is to sort the delivery list based on the delivery distance from the central warehouse. The goal is to implement a sorting functionality that sorts the delivery packages based on their distance from the central warehouse using a custom comparator. Each package object contains the destination\'s coordinates and the package\'s details. **Objective**: Using the MergeSort algorithm, implement the `sort_packages` function, which should sort the delivery packages in ascending order based on their distance from the warehouse. # Function Signature ```python def sort_packages(packages: List[Package]) -> List[Package]: pass ``` # Input - A list of `Package` objects, where each `Package` object contains: - `x`: x-coordinate of the delivery destination - `y`: y-coordinate of the delivery destination - `details`: other details of the package # Output - The list of `Package` objects sorted by their distances from the central warehouse (origin `(0, 0)`). # Constraints - Calculate the distance using the Euclidean distance formula. - Use the MergeSort algorithm to achieve O(n log n) time complexity. - Package list can contain between 1 and 10,000 packages. # Example Usage ```python class Package: def __init__(self, x, y, details): self.x = x self.y = y self.details = details >>> packages = [ Package(3, 4, \\"Package 1\\"), Package(1, 2, \\"Package 2\\"), Package(5, 1, \\"Package 3\\"), ] >>> sorted_packages = sort_packages(packages) >>> [(pkg.x, pkg.y, pkg.details) for pkg in sorted_packages] [(1, 2, \'Package 2\'), (3, 4, \'Package 1\'), (5, 1, \'Package 3\')] ``` # Additional Notes - Ensure that the sorting algorithm is implemented correctly and efficiently. - Handle edge cases such as multiple packages at the same distance. - Prioritize clarity and correctness in your implementation.","solution":"import math from typing import List class Package: def __init__(self, x, y, details): self.x = x self.y = y self.details = details def calculate_distance(package: Package) -> float: return math.sqrt(package.x ** 2 + package.y ** 2) def merge_sort(packages: List[Package]) -> List[Package]: if len(packages) <= 1: return packages mid = len(packages) // 2 left_half = merge_sort(packages[:mid]) right_half = merge_sort(packages[mid:]) return merge(left_half, right_half) def merge(left: List[Package], right: List[Package]) -> List[Package]: sorted_packages = [] i = j = 0 while i < len(left) and j < len(right): if calculate_distance(left[i]) <= calculate_distance(right[j]): sorted_packages.append(left[i]) i += 1 else: sorted_packages.append(right[j]) j += 1 sorted_packages.extend(left[i:]) sorted_packages.extend(right[j:]) return sorted_packages def sort_packages(packages: List[Package]) -> List[Package]: return merge_sort(packages)"},{"question":"# Text Transformer and Entropy Calculations In this task, you are required to implement a function that processes a list of strings, applies text transformations, computes Shannon entropy for each transformed string, and ranks the strings based on their entropy values. # Function Requirements You will implement the following function: ```python def rank_texts(texts: list[str], transformations: dict[str, str]) -> list[tuple[int, float]]: Processes a list of text strings, applies specified text transformations, computes the Shannon entropy for each transformed string, and ranks them based on their entropy values. Args: - texts: List of text strings to be processed. - transformations: Dictionary where keys are characters to be replaced and values are the characters to replace them with. Returns: - A list of tuples where each tuple contains the index of the string and its entropy value, ranked by entropy value in descending order. pass ``` # Input/Output - **Input**: - `texts`: list of strings, the text strings to be processed. - `transformations`: dictionary, where keys are characters to replace and values are the replacement characters. - **Output**: - List of tuples, each containing the index of a text string and its entropy value, ranked by entropy in descending order. # Constraints: - Each text string may vary in length. - The `transformations` dictionary will always have unique keys. - You can assume that the inputs are valid strings and dictionary. # Example: ```python texts = [\\"hello world\\", \\"example text\\", \\"shannon entropy\\"] transformations = {\\"e\\": \\"3\\", \\"o\\": \\"0\\", \\"a\\": \\"4\\"} rank_texts(texts, transformations) ``` # Scenario: You are developing a system to analyze and prioritize text samples based on their information content. The system will transform the given texts based on specified rules, compute the entropy of each transformed text to measure its informational complexity, and rank the texts accordingly. # Note: - Ensure your solution correctly applies the text transformations, computes the Shannon entropy accurately, and returns the ranking of texts based on entropy values. - You might find the `collections` and `math` modules useful for this task. This is an example of how your function might be called: ```python texts = [\\"data science\\", \\"machine learning\\", \\"artificial intelligence\\"] transformations = {\\"a\\": \\"@\\", \\"e\\": \\"3\\", \\"i\\": \\"1\\"} print(rank_texts(texts, transformations)) # Output: [(1, entropy_value1), (0, entropy_value2), (2, entropy_value3)] ``` Where `entropy_value1`, `entropy_value2`, and `entropy_value3` are the entropy values of the respective transformed strings.","solution":"import math from collections import Counter def compute_entropy(text): Compute the Shannon entropy of a given text. if not text: return 0.0 # Calculate the frequency of each character in the text counter = Counter(text) length = len(text) # Shannon entropy computation entropy = 0.0 for count in counter.values(): probability = count / length entropy -= probability * math.log2(probability) return entropy def apply_transformations(text, transformations): Apply the given transformations to the text. for original, replacement in transformations.items(): text = text.replace(original, replacement) return text def rank_texts(texts, transformations): Processes a list of text strings, applies specified text transformations, computes the Shannon entropy for each transformed string, and ranks them based on their entropy values. transformed_texts = [apply_transformations(text, transformations) for text in texts] entropies = [(index, compute_entropy(text)) for index, text in enumerate(transformed_texts)] # Sorting by entropy in descending order entropies.sort(key=lambda x: x[1], reverse=True) return entropies"},{"question":"# Question: Find the Longest Common Subsequence You are tasked with implementing a function to find the longest common subsequence (LCS) between two given strings. The LCS is the longest sequence that can be derived from both strings by deleting some or no characters without changing the order of the remaining characters. Requirements 1. Implement a method `find_lcs(self, s1: str, s2: str) -> str` inside the `StringProcessor` class. 2. The method should return the LCS of the two input strings. 3. If there are multiple LCS of the same length, the method can return any one of them. Example ```python >>> sp = StringProcessor() >>> result = sp.find_lcs(\\"AGGTAB\\", \\"GXTXAYB\\") >>> print(result) \\"GTAB\\" >>> result = sp.find_lcs(\\"abcde\\", \\"ace\\") >>> print(result) \\"ace\\" ``` Constraints 1. The input strings consist of only lowercase English letters. 2. The length of each string does not exceed 1000 characters. 3. The solution should have a reasonable time complexity to handle the input size constraints efficiently.","solution":"class StringProcessor: def find_lcs(self, s1: str, s2: str) -> str: Returns the longest common subsequence (LCS) between two strings. # Create a 2D array to store lengths of longest common subsequence. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Populate the dp array. for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the LCS from the dp array. index = dp[m][n] lcs = [\\"\\"] * index i, j = m, n while i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: lcs[index - 1] = s1[i - 1] i -= 1 j -= 1 index -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return \'\'.join(lcs)"},{"question":"# Question: Matrix Median Extraction You are required to implement a function to extract the median value from a list of `n` sorted matrices. Each matrix is of size `m x m` and contains integers sorted in non-decreasing order both row-wise and column-wise. # Function Signature ```python def find_median_of_matrices(matrices: List[List[List[int]]]) -> int: Computes the median value from a list of sorted matrices. Parameters: matrices (List[List[List[int]]]): A list of sorted matrices, where each matrix is of size `m x m`. Returns: int: The median value from all the matrices. ``` # Input - `matrices` (List[List[List[int]]]): A list of `n` sorted matrices, where `n` is a positive integer and each matrix is of size `m x m`. # Output - Returns an integer representing the median value from all the matrices. # Constraints - The number of matrices `n` will be in the range [1, 1000]. - Each matrix is of size `m x m` where `m` will be in the range [1, 100]. - Each matrix is sorted in non-decreasing order both row-wise and column-wise. # Examples ```python >>> matrices = [[[1, 3, 5], [2, 6, 9], [3, 6, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> find_median_of_matrices(matrices) 5 >>> matrices = [[[1, 2, 3]], [[2, 3, 4]], [[3, 4, 5]]] >>> find_median_of_matrices(matrices) 3 >>> matrices = [[[10]]] >>> find_median_of_matrices(matrices) 10 >>> matrices = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]] >>> find_median_of_matrices(matrices) 4 ``` # Notes - The median is the middle value in the list of numbers. If the list has an even number of elements, the median is the average of the two middle numbers. - Ensure that your solution is efficient and can handle the upper limits of the input constraints within reasonable execution time. - Consider using an algorithm that takes advantage of the properties of sorted matrices for optimal performance. # Implementation Implement your solution in the function `find_median_of_matrices` as described.","solution":"from typing import List import heapq def find_median_of_matrices(matrices: List[List[List[int]]]) -> int: Computes the median value from a list of sorted matrices. Parameters: matrices (List[List[List[int]]]): A list of sorted matrices, where each matrix is of size `m x m`. Returns: int: The median value from all the matrices. # Flatten the matrices into a single list flattened = [] for matrix in matrices: for row in matrix: flattened.extend(row) # Calculate the number of elements in the flattened list num_elements = len(flattened) # Use a min-heap to find the median median_value = None if num_elements % 2 == 1: # For odd number of elements, the median is the middle element median_value = heapq.nsmallest(num_elements // 2 + 1, flattened)[-1] else: # For even number of elements, the median is the average of the two middle elements left_middle = heapq.nsmallest(num_elements // 2, flattened)[-1] right_middle = heapq.nsmallest(num_elements // 2 + 1, flattened)[-1] median_value = (left_middle + right_middle) // 2 return median_value"},{"question":"# Time Complexity Analysis of Sorting Algorithms You are required to implement a function that approximates the time complexity of different sorting algorithms based on the input data size. The function needs to estimate the number of operations for three given sorting algorithms: Bubble Sort, Merge Sort, and Quick Sort. Consider the best, worst, and average case complexities for these algorithms. # Function Specification Implement the following function in Python: ```python def sorting_time_complexity( algorithm: str, data_size: int, case: str ) -> int: Estimate the number of operations required for a given sorting algorithm and input data size. Parameters: - algorithm (str): The sorting algorithm to evaluate. Must be one of \'bubble_sort\', \'merge_sort\', \'quick_sort\'. - data_size (int): The number of elements in the input data. Must be a non-negative integer. - case (str): The case to consider for the complexity analysis. Must be one of \'best\', \'average\', \'worst\'. Returns: - int: Estimated number of operations required. Raises: - ValueError: If algorithm or case are not valid strings, or if data_size is negative. Example Usage: >>> sorting_time_complexity(\'bubble_sort\', 1000, \'average\') 500000 >>> sorting_time_complexity(\'merge_sort\', 1000, \'worst\') 9968 >>> sorting_time_complexity(\'quick_sort\', 1000, \'best\') 996 >>> sorting_time_complexity(\'quick_sort\', -1, \'average\') Traceback (most recent call last): ... ValueError: Data size must be non-negative. ``` # Input and Output - **Input**: - `algorithm` (str): The sorting algorithm to analyze. Must be \'bubble_sort\', \'merge_sort\', or \'quick_sort\'. - `data_size` (int): The number of elements in the dataset. Must be a non-negative integer. - `case` (str): The type of case for the complexity estimate. Must be \'best\', \'average\', or \'worst\'. - **Output**: The function should return an integer representing the estimated number of operations. # Complexity Cases - **Bubble Sort**: - Best Case: O(n) - Average Case: O(n²) - Worst Case: O(n²) - **Merge Sort**: - Best Case: O(n log n) - Average Case: O(n log n) - Worst Case: O(n log n) - **Quick Sort**: - Best Case: O(n log n) - Average Case: O(n log n) - Worst Case: O(n²) # Example: ```python >>> sorting_time_complexity(\'bubble_sort\', 1000, \'average\') 500000 >>> sorting_time_complexity(\'merge_sort\', 1000, \'worst\') 9968 >>> sorting_time_complexity(\'quick_sort\', 1000, \'best\') 996 >>> sorting_time_complexity(\'quick_sort\', -1, \'average\') Traceback (most recent call last): ... ValueError: Data size must be non-negative. >>> sorting_time_complexity(\'heap_sort\', 1000, \'average\') Traceback (most recent call last): ... ValueError: Unsupported algorithm. Choose from \'bubble_sort\', \'merge_sort\', \'quick_sort\'. >>> sorting_time_complexity(\'quick_sort\', 1000, \'best_case\') Traceback (most recent call last): ... ValueError: Unexpected case parameter. Use \'best\', \'average\', or \'worst\'. ``` Implement the function according to the specification above and ensure it passes the provided test cases.","solution":"def sorting_time_complexity(algorithm: str, data_size: int, case: str) -> int: Estimate the number of operations required for a given sorting algorithm and input data size. Parameters: - algorithm (str): The sorting algorithm to evaluate. Must be one of \'bubble_sort\', \'merge_sort\', \'quick_sort\'. - data_size (int): The number of elements in the input data. Must be a non-negative integer. - case (str): The case to consider for the complexity analysis. Must be one of \'best\', \'average\', \'worst\'. Returns: - int: Estimated number of operations required. Raises: - ValueError: If algorithm or case are not valid strings, or if data_size is negative. if data_size < 0: raise ValueError(\\"Data size must be non-negative.\\") if algorithm not in [\'bubble_sort\', \'merge_sort\', \'quick_sort\']: raise ValueError(\\"Unsupported algorithm. Choose from \'bubble_sort\', \'merge_sort\', \'quick_sort\'.\\") if case not in [\'best\', \'average\', \'worst\']: raise ValueError(\\"Unexpected case parameter. Use \'best\', \'average\', or \'worst\'.\\") if algorithm == \'bubble_sort\': if case == \'best\': return data_size else: return data_size * data_size if algorithm == \'merge_sort\': import math return data_size * math.floor(math.log2(data_size)) if algorithm == \'quick_sort\': if case == \'best\' or case == \'average\': import math return data_size * math.floor(math.log2(data_size)) else: return data_size * data_size"},{"question":"# Problem Statement: You are a software engineer tasked with developing a string manipulation function to help customer support team process user feedbacks effectively. Each feedback message is a string consisting of words separated by spaces. Your goal is to write a Python function that replaces certain keywords in the feedback messages with predefined substitute words. # Task: Write a function `replace_keywords()` that takes two arguments: - `feedback` (str): The original feedback message. - `replacements` (dict): A dictionary where keys are the words to be replaced and values are their corresponding substitutes. The function should return the modified feedback message with all specified replacements applied. The replacements should be case-sensitive and only full words should be replaced (not parts of other words). Constraints: - The feedback string may contain punctuation, but replacements should only apply to words. - The feedback string will contain between 1 and 1000 words. - Each word in the feedback string will be between 1 and 20 characters long. - The replacements dictionary will contain between 1 and 50 entries, each key and value being non-empty strings with a maximum length of 20 characters. Example: ```python def replace_keywords(feedback: str, replacements: dict) -> str: pass # Your implementation here # Example Test Cases: feedback_1 = \\"The service was excellent and the food was marvelous\\" replacements_1 = {\\"excellent\\": \\"great\\", \\"marvelous\\": \\"fantastic\\"} print(replace_keywords(feedback_1, replacements_1)) # Output: \\"The service was great and the food was fantastic\\" feedback_2 = \\"I found the ride very comfortable and the driver polite\\" replacements_2 = {\\"comfortable\\": \\"cozy\\", \\"polite\\": \\"courteous\\"} print(replace_keywords(feedback_2, replacements_2)) # Output: \\"I found the ride very cozy and the driver courteous\\" feedback_3 = \\"The product is good but the packaging needs improvement\\" replacements_3 = {\\"good\\": \\"decent\\", \\"improvement\\": \\"upgrading\\"} print(replace_keywords(feedback_3, replacements_3)) # Output: \\"The product is decent but the packaging needs upgrading\\" ``` # Requirements: - Ensure the function performs replacements correctly for the given constraints. - Implement necessary error checking, if applicable.","solution":"def replace_keywords(feedback, replacements): Replace words in the feedback string with their substitutes from the replacements dictionary. Parameters: feedback (str): The original feedback message. replacements (dict): A dictionary with words to be replaced as keys and their substitutes as values. Returns: str: The modified feedback message with specified replacements. words = feedback.split() for i in range(len(words)): word = words[i].strip(\'.,!?\') if word in replacements: words[i] = words[i].replace(word, replacements[word]) return \' \'.join(words)"},{"question":"# Coding Assessment Question: Scenario: You are required to implement a function that determines if a given positive integer is a prime number. This function will be useful for various applications needing prime number validation. Function Specification: Write a function `is_prime_optimized(n: int) -> bool` that checks whether a given number is prime using an optimized approach. Input: * `n`: an integer `n` (1 <= n <= 10^9) to be checked for primality. Output: * Returns `True` if `n` is a prime number, otherwise returns `False`. Constraints: * Raise a `ValueError` if `n` is not a positive integer. Performance Requirements: * The implementation should aim for better time complexity than O(n), ideally O(sqrt(n)). Examples: ```python >>> is_prime_optimized(2) True >>> is_prime_optimized(3) True >>> is_prime_optimized(10) False >>> is_prime_optimized(17) True >>> is_prime_optimized(1) False >>> is_prime_optimized(29) True >>> is_prime_optimized(1.5) Traceback (most recent call last): ... ValueError: Input must be an integer >>> is_prime_optimized(-3) Traceback (most recent call last): ... ValueError: Input must be positive ``` Ensure that your function is optimized and handles edge cases appropriately. Validate the input, raise errors for invalid cases, and strive for an efficient implementation.","solution":"import math def is_prime_optimized(n): Determines if the given positive integer n is a prime number. Raises a ValueError if n is not a positive integer. if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"Input must be positive\\") if n == 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True"},{"question":"# Maximize Array Sum with Non-Adjacent Elements Problem Statement You are given an array of positive integers where each element represents the maximum amount of money you can collect from a house. However, every house is connected to adjacent houses which means if you rob one house, you cannot rob the houses directly connected to it (i.e., no two adjacent houses can be robbed). Your task is to determine the maximum amount of money you can collect without robbing two directly connected houses. Function Signature ```python def max_robbery(nums: list[int]) -> int: Returns the maximum amount of money that can be collected by robbing houses without robbing two adjacent houses. Parameters: nums (list[int]): A list of positive integers representing the money from each house. Returns: int: The maximum money that can be collected without robbing two adjacent houses. ``` Input and Output Format **Input**: - A list of integers `nums` representing the money from each house, where `0 <= len(nums) <= 1000` and each element is a positive integer `1 <= nums[i] <= 10000`. **Output**: - The function should return a single integer which is the maximum money that can be collected without robbing two directly connected houses. Constraints - The list can be empty, in which case the return value should be 0. Example ```python >>> max_robbery([1, 2, 3, 1]) 4 >>> max_robbery([2, 7, 9, 3, 1]) 12 >>> max_robbery([]) 0 >>> max_robbery([5, 5, 10, 100, 10, 5]) 110 ``` Implementation Requirements: - Use dynamic programming to solve the problem efficiently. - Consider both time and space complexity. - Optimize the solution to use constant space. Notes: - Do not use recursion to avoid stack overflow issues. - Clearly comment on your code for readability and understanding of logic.","solution":"def max_robbery(nums): Returns the maximum amount of money that can be collected by robbing houses without robbing two adjacent houses. Parameters: nums (list[int]): A list of positive integers representing the money from each house. Returns: int: The maximum money that can be collected without robbing two adjacent houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] prev1 = 0 # Represents the maximum money we could get up to the house i-1 prev2 = 0 # Represents the maximum money we could get up to the house i-2 for num in nums: current = max(prev1, prev2 + num) # Rob current house or skip it prev2 = prev1 # Update prev2 to be the previous prev1 prev1 = current # Update prev1 to be the current return prev1"},{"question":"**Problem:** Largest Diameter Binary Search Tree Finder You are given a binary search tree (BST) represented using the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The diameter of a tree is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. **Task**: Write a function `find_bst_diameter(root: TreeNode) -> int` that returns the diameter of the given BST. **Input/Output Format**: - **Input**: A binary search tree represented by its root node `root`. - **Output**: Integer representing the diameter of the tree. **Constraints**: 1. The number of nodes in the tree is in the range `[1, 10^4]`. 2. The values in the BST are unique integers within the range `[-10^4, 10^4]`. 3. Assume the tree is balanced. **Function Signature**: ```python def find_bst_diameter(root: TreeNode) -> int: pass ``` **Example**: Consider the following binary search tree: ``` 4 / 2 6 / / 1 3 5 7 ``` ``` >>> tree = TreeNode(4) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(6) >>> tree.left.left = TreeNode(1) >>> tree.left.right = TreeNode(3) >>> tree.right.left = TreeNode(5) >>> tree.right.right = TreeNode(7) >>> find_bst_diameter(tree) 4 # Example output for confirmation ``` **Hints**: - Consider depth-first search (DFS) to find the depth of each subtree. - Optimize the traversal by keeping track of sub-diameters to avoid redundant calculations within the same recursive call.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bst_diameter(root: TreeNode) -> int: Returns the diameter of the given BST. diameter = [0] def dfs(node): if not node: return 0 # Recurse on left and right children left_depth = dfs(node.left) right_depth = dfs(node.right) # Update diameter if the path through the root is larger diameter[0] = max(diameter[0], left_depth + right_depth) # Return the depth of the tree return max(left_depth, right_depth) + 1 dfs(root) return diameter[0]"},{"question":"# Problem Statement: Matrix Diagonal Sum Calculator You are required to implement the `MatrixDiagonalSum` class that calculates the sum of the diagonals of a given square matrix. The class should handle both the primary and secondary diagonals. # Requirements: 1. **Diagonal Sums**: The class should be able to compute the sum of all elements on the primary diagonal and the secondary diagonal of the given square matrix. 2. **Error Handling**: Properly handle non-square matrices, returning an appropriate error or message. 3. **Performance**: Ensure the solution processes the matrix efficiently for up to 1000x1000 elements. # Class Implementations: - `__init__`: Initialize the matrix. - `primary_diagonal_sum`: Compute and return the sum of the primary diagonal elements. - `secondary_diagonal_sum`: Compute and return the sum of the secondary diagonal elements. - `get_diagonal_sums`: A convenience method that returns both sums as a tuple `(primary_sum, secondary_sum)`. # Input Format: - The matrix will be a list of lists where each inner list represents a row of the matrix. # Output Format: - For `primary_diagonal_sum`, return an integer representing the sum of the primary diagonal. - For `secondary_diagonal_sum`, return an integer representing the sum of the secondary diagonal. - For `get_diagonal_sums`, return a tuple with two integers representing the primary and secondary diagonal sums. # Example: ```python # Creating a new instance with a 3x3 matrix matrix = MatrixDiagonalSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Getting the sum of the primary diagonal primary_sum = matrix.primary_diagonal_sum() print(primary_sum) # Output: 15 (1 + 5 + 9) # Getting the sum of the secondary diagonal secondary_sum = matrix.secondary_diagonal_sum() print(secondary_sum) # Output: 15 (3 + 5 + 7) # Getting both diagonal sums diagonal_sums = matrix.get_diagonal_sums() print(diagonal_sums) # Output: (15, 15) ``` # Constraints: - The matrix will only contain integer values. - The matrix dimensions will not exceed 1000x1000 elements. - Non-square matrices should return an error message: \\"Matrix is not square.\\" # Hint: You may use Python\'s built-in functions for list and matrix manipulations to simplify your implementation.","solution":"class MatrixDiagonalSum: def __init__(self, matrix): self.matrix = matrix self.n = len(matrix) for row in matrix: if len(row) != self.n: raise ValueError(\\"Matrix is not square\\") def primary_diagonal_sum(self): return sum(self.matrix[i][i] for i in range(self.n)) def secondary_diagonal_sum(self): return sum(self.matrix[i][self.n - 1 - i] for i in range(self.n)) def get_diagonal_sums(self): return (self.primary_diagonal_sum(), self.secondary_diagonal_sum())"},{"question":"# Problem Statement You are tasked with implementing a contact management system for small businesses. The initial framework for managing contacts is already in place, but several improvements are necessary. Specifically, you need to add functionality for importing contacts from a CSV file, exporting contacts to JSON, and providing basic error handling for invalid data. # Requirements 1. **CSV Import**: Implement the `import_contacts` function to read contact details from a CSV file and add them to the contact list. Each contact must have a name, email, and phone number. Ensure that duplicates (contacts with the same email) are not added. 2. **JSON Export**: Implement the `export_contacts` function to export all contacts to a JSON file. The JSON should contain a list of contacts, each with a name, email, and phone number. 3. **Error Handling**: Include error handling to manage issues such as missing data fields, invalid email formats, and duplicate records during import. # Constraints - You can use standard Python libraries such as `csv`, `json`, and `re`. - Assume a maximum of 1000 contacts. # Function Signature ```python import csv import json import re def import_contacts(csv_file_path: str, existing_contacts: list[dict]) -> list[dict]: # Implement this function pass def export_contacts(json_file_path: str, contacts: list[dict]) -> None: # Implement this function pass def is_valid_email(email: str) -> bool: # Helper function to validate email format pass if __name__ == \\"__main__\\": contacts = [] contacts = import_contacts(\\"contacts.csv\\", contacts) export_contacts(\\"contacts.json\\", contacts) ``` # Expected Behavior 1. **Input**: `csv_file_path` (file path of the CSV to import), `existing_contacts` (current contact list), and `json_file_path` (file path to export the JSON to). 2. **Output**: `import_contacts` returns an updated contact list. `export_contacts` writes the contact list to a JSON file. # Example Assume the `contacts.csv` file contains the following data: ``` Name,Email,Phone John Doe,john.doe@example.com,123-456-7890 Jane Smith,jane.smith@example.com,987-654-3210 John Doe,john.doe@example.com,123-456-7890 ``` Example usage: ```python contacts = import_contacts(\\"contacts.csv\\", []) export_contacts(\\"contacts.json\\", contacts) ``` After importing, `contacts` will be: ```python [ {\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@example.com\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@example.com\\", \\"phone\\": \\"987-654-3210\\"} ] ``` The `contacts.json` file will then contain: ```json [ {\\"name\\": \\"John Doe\\", \\"email\\": \\"john.doe@example.com\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Jane Smith\\", \\"email\\": \\"jane.smith@example.com\\", \\"phone\\": \\"987-654-3210\\"} ] ```","solution":"import csv import json import re def is_valid_email(email: str) -> bool: Helper function to validate email format using regex. regex = r\'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\' return re.match(regex, email) is not None def import_contacts(csv_file_path: str, existing_contacts: list[dict]) -> list[dict]: Reads contact details from a CSV file and adds them to the contact list. Ensures that duplicates (contacts with the same email) are not added. Parameters: csv_file_path (str): The file path of the CSV to import. existing_contacts (list[dict]): The current list of contacts. Returns: list[dict]: The updated contact list. email_set = {contact[\'email\'] for contact in existing_contacts} updated_contacts = existing_contacts[:] with open(csv_file_path, mode=\'r\', newline=\'\', encoding=\'utf-8\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: name = row.get(\'Name\') email = row.get(\'Email\') phone = row.get(\'Phone\') if not name or not email or not phone: # Skip rows with missing data fields continue if not is_valid_email(email): # Skip rows with invalid email format continue if email in email_set: # Skip duplicate contacts continue contact = {\'name\': name, \'email\': email, \'phone\': phone} updated_contacts.append(contact) email_set.add(email) return updated_contacts def export_contacts(json_file_path: str, contacts: list[dict]) -> None: Exports all contacts to a JSON file. Parameters: json_file_path (str): The file path to export the JSON to. contacts (list[dict]): The current list of contacts. with open(json_file_path, mode=\'w\', encoding=\'utf-8\') as jsonfile: json.dump(contacts, jsonfile, indent=4) # Example usage: # if __name__ == \\"__main__\\": # contacts = [] # contacts = import_contacts(\\"contacts.csv\\", contacts) # export_contacts(\\"contacts.json\\", contacts)"},{"question":"# Longest Increasing Subsequence (LIS) in an Array Context: The Longest Increasing Subsequence (LIS) problem is a classic problem in computer science that asks for the length of the longest subsequence in a given sequence of numbers such that all elements of the subsequence are in strictly increasing order. Problem Statement: Given an array `A` of `n` integers, your task is to find the length of the longest strictly increasing subsequence. Input: - The first line contains a single integer `n` (`1 <= n <= 10000`), representing the number of elements in the array. - The second line contains `n` space-separated integers `A[i]` (`-10^9 <= A[i] <= 10^9`), representing the elements of the array. Output: - Output should be a single integer representing the length of the longest strictly increasing subsequence in the array. Constraints: - The array can have up to 10,000 elements. - The elements of the array can range between `-10^9` and `10^9`. Example: **Input:** ``` 8 10 22 9 33 21 50 41 60 ``` **Output:** ``` 5 ``` *Explanation:* The longest increasing subsequence is [10, 22, 33, 50, 60], and its length is 5. **Additional Example:** **Input:** ``` 6 5 8 3 7 9 1 ``` **Output:** ``` 3 ``` *Explanation:* The longest increasing subsequence is [5, 7, 9], and its length is 3. # Implementation Requirements: - You need to implement the main function `longest_increasing_subsequence()` that calculates the length of the LIS. - Ensure to handle edge cases, such as an array with all identical numbers or the smallest possible array size. Good luck!","solution":"def longest_increasing_subsequence(A): Returns the length of the longest increasing subsequence in the array A. if not A: return 0 # Initialize the list to store the length of the longest increasing subsequence up to each element n = len(A) lis = [1] * n # Fill lis[] so that lis[i] contains the length of the longest LIS ending with A[i] for i in range(1, n): for j in range(i): if A[i] > A[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Maximum value in lis[] is the length of LIS return max(lis)"},{"question":"# String Pattern Matcher You are asked to implement a class `StringPatternMatcher` that is able to match a specific pattern within a given string. For the purpose of this question, a pattern is defined as a string that can contain wildcard characters `*` (which matches zero or more characters) and `?` (which matches exactly one character). The class should support functions to set the pattern, test a string against the set pattern, and clear the current pattern. Class Definition ```python class StringPatternMatcher: def __init__(self) -> None: Initialize the StringPatternMatcher with no pattern set. pass def set_pattern(self, pattern: str) -> None: Set the pattern to be used for matching. pass def match(self, string: str) -> bool: Return True if the string matches the set pattern, otherwise False. pass def clear_pattern(self) -> None: Clear the current pattern. pass ``` # Requirements 1. **Initialization**: The `__init__` method should initialize the class without any pattern set. 2. **set_pattern**: This method sets the pattern string that will be used for matching. 3. **match**: This method takes a string and returns a boolean indicating whether the string matches the current pattern. Pay attention to handling wildcards `*` and `?` properly. 4. **clear_pattern**: This method clears the current pattern. # Constraints * Input strings and pattern strings will be of reasonable length (no longer than 10,000 characters). * Characters in the pattern and string are restricted to lowercase English letters and the wildcard characters `*` and `?`. Example Usage: ```python matcher = StringPatternMatcher() matcher.set_pattern(\\"a*b?c\\") print(matcher.match(\\"aabxc\\")) # Output: True print(matcher.match(\\"abc\\")) # Output: False matcher.set_pattern(\\"a*\\") print(matcher.match(\\"abcdefgh\\")) # Output: True matcher.clear_pattern() print(matcher.match(\\"anything\\")) # Output: False ``` # Notes * The `match` function must handle patterns with multiple wildcards, ensuring that `*` matches zero or more characters and `?` matches exactly one character. * Consider preprocessing the pattern to optimize the matching process, especially for large input sizes. * Provide sufficient documentation and method-level comments to explain your logic and decisions. * Ensure to handle edge case scenarios like empty strings, patterns without wildcards, and entirely wildcard-based patterns.","solution":"class StringPatternMatcher: def __init__(self) -> None: Initialize the StringPatternMatcher with no pattern set. self.pattern = None def set_pattern(self, pattern: str) -> None: Set the pattern to be used for matching. self.pattern = pattern def match(self, string: str) -> bool: Return True if the string matches the set pattern, otherwise False. if self.pattern is None: return False return self._match_helper(string, self.pattern) def _match_helper(self, string: str, pattern: str) -> bool: Helper function to perform pattern matching using dynamic programming. m, n = len(string), len(pattern) # dp[i][j] will be True if the first i characters in string match the first j characters in the pattern. dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Fill the first row for patterns with leading stars for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == string[i - 1] or pattern[j - 1] == \'?\': dp[i][j] = dp[i - 1][j - 1] return dp[m][n] def clear_pattern(self) -> None: Clear the current pattern. self.pattern = None"},{"question":"# Problem Statement You are tasked with implementing a function to find the longest common subsequence (LCS) between two strings. The function should accept two input strings and determine the length of their longest common subsequence. # Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: ``` # Input - `s1` (str): The first string to compare. - `s2` (str): The second string to compare. # Output - Returns an integer representing the length of the longest common subsequence between the two strings. # Constraints - Both input strings will have a maximum length of 1000 characters. - The strings can contain upper and lower case letters, and digits. # Example Scenarios 1. `longest_common_subsequence(\\"abcde\\", \\"ace\\")` should return `3` (LCS is \\"ace\\"). 2. `longest_common_subsequence(\\"abc\\", \\"abc\\")` should return `3` (LCS is \\"abc\\"). 3. `longest_common_subsequence(\\"abc\\", \\"def\\")` should return `0` (no common subsequence). 4. `longest_common_subsequence(\\"abcdefg\\", \\"xaybzcf\\")` should return `4` (LCS is \\"abcf\\"). # Detailed Description The function should create a 2D dp table where `dp[i][j]` represents the length of the longest common subsequence of the first `i` characters of `s1` and the first `j` characters of `s2`. The function should return the value of `dp[len(s1)][len(s2)]`. **Steps**: 1. Initialize a `dp` table with dimensions `(len(s1)+1) x (len(s2)+1)` filled with zeros. 2. Populate the dp table using the rules: - If characters `s1[i-1]` and `s2[j-1]` are equal, then `dp[i][j] = dp[i-1][j-1] + 1`. - If not equal, then `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`. 3. The result will be in `dp[len(s1)][len(s2)]`.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Function to find the length of the longest common subsequence between two strings. # Initialize dp table dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)] # Fill dp table for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[len(s1)][len(s2)]"},{"question":"# Coding Assessment Question Context In a data processing pipeline, it’s often necessary to find the k most frequent elements in a dataset. This operation should be optimized for both time and space efficiency, especially when dealing with large datasets where the number of elements can be very large and their frequencies highly varied. Problem Statement Given a list of integers representing a dataset, write a Python function `top_k_frequent(nums: list, k: int) -> list` that returns the k most frequent elements in the list. Input Format * A list of integers `nums` representing the dataset. For example, [1, 1, 1, 2, 2, 3] represents a dataset with elements 1, 2, and 3. * An integer `k` representing the number of top frequent elements to return. Output Format * Return a list of integers representing the k most frequent elements. Constraints * The length of the list `nums` will be between 1 and 10^5. * `k` will be a positive integer between 1 and the number of unique elements in `nums`. * Each integer in `nums` will be between -10^9 and 10^9. Examples ```python >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 2, 3, 4, 5], 3) [1, 2, 3] >>> top_k_frequent([4, 4, 4, 4, 4], 1) [4] ``` Performance Requirements * The expected time complexity should be O(N log k). * The expected space complexity should be O(N + k). Implementation Notes * Handle edge cases where the input list has fewer elements than k. * Consider using a hash map to count the frequencies and a heap to keep track of the top k elements efficiently.","solution":"import heapq from collections import Counter def top_k_frequent(nums, k): Returns the k most frequent elements in the list nums. if k == 0: return [] # Count the frequency of each element count = Counter(nums) # Use a heap to get the k most frequent elements most_common = heapq.nlargest(k, count.keys(), key=count.get) return most_common"},{"question":"# Coding Assessment Question You are developing a command-line tool to manage a list of tasks with priority levels. Implement a `TaskManager` class to handle adding, listing, and retrieving tasks based on their priority. **Requirements**: 1. Implement the `TaskManager` class constructor to initialize an empty list of tasks. 2. Implement the `add_task` method to add a new task with a given priority. 3. Implement the `list_tasks` method to return all tasks sorted by their priority in ascending order. 4. Implement the `get_highest_priority_task` method to return the task with the highest priority. **Function Signatures**: ```python class TaskManager: def __init__(self) -> None: Initialize an empty task list. def add_task(self, task: str, priority: int) -> None: Add a new task with the given priority. def list_tasks(self) -> list[tuple[str, int]]: List all tasks sorted by priority in ascending order. def get_highest_priority_task(self) -> str: Retrieve the task with the highest priority. ``` **Input**: * **task**: A string representing the description of the task. * **priority**: An integer representing the priority level of the task. **Output**: * **add_task**: Adds the task to the task list. * **list_tasks**: Returns a list of tuples, each containing a task and its priority, sorted by priority. * **get_highest_priority_task**: Returns the description of the task with the highest priority. If no tasks are present, return \\"No tasks available\\". **Example**: ```python task_manager = TaskManager() task_manager.add_task(\\"Write report\\", 2) task_manager.add_task(\\"Prepare presentation\\", 1) task_manager.add_task(\\"Team meeting\\", 3) print(task_manager.list_tasks()) # Output: [(\\"Prepare presentation\\", 1), (\\"Write report\\", 2), (\\"Team meeting\\", 3)] print(task_manager.get_highest_priority_task()) # Output: \\"Prepare presentation\\" task_manager.add_task(\\"Check emails\\", 1) print(task_manager.list_tasks()) # Output: [(\\"Prepare presentation\\", 1), (\\"Check emails\\", 1), (\\"Write report\\", 2), (\\"Team meeting\\", 3)] ``` **Constraints**: * Task descriptions are non-empty strings with a maximum length of 100 characters. * Priority levels are positive integers (1 - highest priority, 2, 3, ...). * Assume a maximum of 1000 tasks.","solution":"class TaskManager: def __init__(self) -> None: Initialize an empty task list. self.tasks = [] def add_task(self, task: str, priority: int) -> None: Add a new task with the given priority. self.tasks.append((task, priority)) def list_tasks(self) -> list: List all tasks sorted by priority in ascending order. return sorted(self.tasks, key=lambda x: x[1]) def get_highest_priority_task(self) -> str: Retrieve the task with the highest priority. if not self.tasks: return \\"No tasks available\\" return min(self.tasks, key=lambda x: x[1])[0]"},{"question":"# Coding Assessment Question Scenario/Context In computational problems, efficiently searching and indexing data is a critical skill. This problem will test your ability to perform string searches within a document, ensuring that your solution is both effective and optimal for large datasets. Problem Statement Write a function `find_substring_occurrences(text: str, substring: str) -> int` that computes the number of times a given substring appears within a larger text. # Function Signature `def find_substring_occurrences(text: str, substring: str) -> int:` # Input * `text` (str): A large string representing the text where the search will be performed. * `substring` (str): A smaller string representing the substring whose occurrences need to be counted. # Output * Returns an integer, the number of times `substring` appears in `text`. # Constraints * `1 <= len(text) <= 10^6` * `1 <= len(substring) <= 10^3` # Example ```python >>> find_substring_occurrences(\\"banana\\", \\"na\\") 2 >>> find_substring_occurrences(\\"aaaaaa\\", \\"aa\\") 5 >>> find_substring_occurrences(\\"abcdef\\", \\"gh\\") 0 ``` # Explanation 1. For the input text = \\"banana\\" and substring = \\"na\\"; \\"na\\" appears twice in \\"banana\\". 2. For the input text = \\"aaaaaa\\" and substring = \\"aa\\"; \\"aa\\" appears at indices (0,1), (1,2), (2,3), (3,4), and (4,5), a total of 5 times. 3. For the input text = \\"abcdef\\" and substring = \\"gh\\"; \\"gh\\" does not appear in \\"abcdef\\" so the result is 0. # Additional Points - Consider overlapping occurrences of the substring. - Optimize your solution to handle large inputs efficiently.","solution":"def find_substring_occurrences(text: str, substring: str) -> int: Returns the number of times the substring appears within the text including overlapping occurrences. count = start = 0 while True: start = text.find(substring, start) if start == -1: break count += 1 start += 1 # Move to the next position to allow overlapping matches return count"},{"question":"Scenario Learning and mastering recursive algorithms are essential for tackling various computational problems. This exercise will help you understand and implement a classic recursive algorithm to solve the problem of calculating the edit distance (Levenshtein distance) between two strings. # Problem Statement Write a function `edit_distance(s1: str, s2: str) -> int` that computes the minimum number of operations required to convert string `s1` into string `s2`. The allowed operations are: - Insert a character, - Delete a character, - Replace a character. # Input * `s1` (0 ≤ length of s1 ≤ 100): The first string. * `s2` (0 ≤ length of s2 ≤ 100): The second string. # Output * Return the minimum number of operations required to transform `s1` into `s2`. # Constraints * Both `s1` and `s2` consist only of lowercase English letters (`a` to `z`). # Performance Requirements Your solution should utilize a recursive approach but should be optimized using memoization to avoid excessive recomputation. Aim for a solution with a time complexity of `O(n * m)`, where `n` and `m` are the lengths of `s1` and `s2`, respectively. # Example ```python def edit_distance(s1: str, s2: str) -> int: # Implement your function here # Example usage: print(edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 ``` In this example, the function should compute the edit distance between \\"kitten\\" and \\"sitting\\", which is 3 operations (replace \'k\' with \'s\', insert \'i\', and replace \'e\' with \'i\'). # Notes - Use memoization to store previously computed results and avoid redundant computations. - Consider the base cases for when one string is empty. - Recursive approach should try all possible operations (insert, delete, replace) and choose the one with the minimal cost recursively.","solution":"def edit_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert string s1 into string s2. The allowed operations are inserting a character, deleting a character, or replacing a character. memo = {} def helper(i, j): if (i, j) in memo: return memo[(i, j)] # If first string is empty, the only option is to insert all characters of the second string if i == 0: return j # If second string is empty, the only option is to remove all characters of the first string if j == 0: return i # If last characters of both strings are the same, ignore the last character and recur for the remaining substring if s1[i - 1] == s2[j - 1]: memo[(i, j)] = helper(i - 1, j - 1) return memo[(i, j)] # If last characters are different, consider all three operations on the last character of the first string, # recursively compute the minimum cost for all three operations and take the minimum of three values insert_op = helper(i, j - 1) # Insert delete_op = helper(i - 1, j) # Remove replace_op = helper(i - 1, j - 1) # Replace memo[(i, j)] = 1 + min(insert_op, delete_op, replace_op) return memo[(i, j)] return helper(len(s1), len(s2))"},{"question":"# Song Metadata Organizer As a software engineer in a music streaming company, you are tasked with building a function to organize a list of songs based on specific metadata attributes. Your task involves the following steps: 1. **Implement Song Organizer**: Write a function `organize_songs(song_list, sort_by, order)` that: * Takes as input: * `song_list`, a list of dictionaries where each dictionary contains the attributes of a song. Each dictionary has the following keys: * \'title\': a string representing the title of the song * \'artist\': a string representing the artist of the song * \'duration\': an integer representing the duration of the song in seconds * \'year\': an integer representing the release year of the song * `sort_by`, a string indicating the attribute to sort the songs by (\'title\', \'artist\', \'duration\', or \'year\') * `order`, a string indicating the order of sorting (\'asc\' for ascending, \'desc\' for descending) * Returns: * A list of dictionaries representing the songs, sorted based on the specified `sort_by` attribute and `order`. 2. **Sorting Requirements**: The function should sort the songs efficiently and handle edge cases such as: * Sorting by numerical and string attributes. * Ties in the sorting attribute should be resolved using the original order of the songs in the input list. * The function should handle an empty list gracefully. **Input and Output Format**: Input: ```python song_list = [ {\'title\': \'Song A\', \'artist\': \'Artist 1\', \'duration\': 200, \'year\': 2021}, {\'title\': \'Song B\', \'artist\': \'Artist 2\', \'duration\': 180, \'year\': 2020}, {\'title\': \'Song C\', \'artist\': \'Artist 1\', \'duration\': 240, \'year\': 2021} ] sort_by = \'duration\' order = \'asc\' ``` Output: ```python [ {\'title\': \'Song B\', \'artist\': \'Artist 2\', \'duration\': 180, \'year\': 2020}, {\'title\': \'Song A\', \'artist\': \'Artist 1\', \'duration\': 200, \'year\': 2021}, {\'title\': \'Song C\', \'artist\': \'Artist 1\', \'duration\': 240, \'year\': 2021} ] ``` Your function must account for the following constraints and ensure it performs the sorting correctly and efficiently. ```python def organize_songs(song_list, sort_by, order): Organize a list of songs based on specified attribute and order. Args: song_list (list of dict): List of songs with attributes. sort_by (str): Attribute to sort by (\'title\', \'artist\', \'duration\', \'year\'). order (str): Sorting order (\'asc\' or \'desc\'). Returns: list of dict: Sorted list of songs. # Toggle between ascending and descending reverse = order == \'desc\' # Sort the song list by the specified attribute sorted_songs = sorted(song_list, key=lambda song: song[sort_by], reverse=reverse) return sorted_songs # Example usage (you can use this for testing your function): song_list = [ {\'title\': \'Song A\', \'artist\': \'Artist 1\', \'duration\': 200, \'year\': 2021}, {\'title\': \'Song B\', \'artist\': \'Artist 2\', \'duration\': 180, \'year\': 2020}, {\'title\': \'Song C\', \'artist\': \'Artist 1\', \'duration\': 240, \'year\': 2021} ] sorted_songs = organize_songs(song_list, \'duration\', \'asc\') print(sorted_songs) # Expected output based on the input example ```","solution":"def organize_songs(song_list, sort_by, order): Organize a list of songs based on specified attribute and order. Args: song_list (list of dict): List of songs with attributes. sort_by (str): Attribute to sort by (\'title\', \'artist\', \'duration\', \'year\'). order (str): Sorting order (\'asc\' or \'desc\'). Returns: list of dict: Sorted list of songs. # Toggle between ascending and descending reverse = order == \'desc\' # Sort the song list by the specified attribute sorted_songs = sorted(song_list, key=lambda song: song[sort_by], reverse=reverse) return sorted_songs"},{"question":"# Question: Implement a Function to Determine Longest Increasing Subsequence Length You have been hired by a financial analytics firm to develop an algorithm for assessing historical stock performance. Part of this involves computing the length of the longest increasing subsequence (LIS) from a sequence of stock prices to gauge positive trends. Your task is to write a function that takes a list of integers representing stock prices and returns the length of the longest increasing subsequence. Ensure your implementation is optimized for performance due to the large data sets involved in financial analysis. **Function Signature:** ```python def length_of_lis(prices: List[int]) -> int: pass ``` **Input:** - A list `prices` of length `1 <= len(prices) <= 10^4`, where each element represents a stock price as an integer. **Output:** - An integer representing the length of the longest increasing subsequence. **Constraints:** 1. The subsequence elements must be strictly increasing. 2. Optimize the algorithm to handle the upper constraint efficiently, considering both time and space complexities. **Examples:** ```python assert length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 # The LIS is [2, 3, 7, 101] assert length_of_lis([0, 1, 0, 3, 2, 3]) == 4 # The LIS could be [0, 1, 2, 3] assert length_of_lis([7, 7, 7, 7, 7, 7, 7]) == 1 # The LIS is [7] assert length_of_lis([4, 10, 4, 3, 8, 9]) == 3 # The LIS could be [4, 8, 9] or [3, 8, 9] assert length_of_lis([1]) == 1 # The LIS is [1] ``` **Scenario:** To assist in making informed investment decisions, you need to evaluate how stock prices perform over time. The algorithm must efficiently process historical data to identify the longest upward trends without causing delays or excessive memory usage in the analytics system.","solution":"from typing import List import bisect def length_of_lis(prices: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of prices. if not prices: return 0 # dp will store the increasing subsequences formed dp = [] for price in prices: # Find the index where the price fits in the dp array idx = bisect.bisect_left(dp, price) # If the price is larger than any element in dp, it extends the largest subsequence if idx == len(dp): dp.append(price) else: dp[idx] = price return len(dp)"},{"question":"# Regular Expression Matching Function Write a function that performs pattern matching using regular expressions. The function should return `True` if the entire input string matches the given pattern, and `False` otherwise. You are not allowed to use the built-in `re` module or any other pattern matching libraries. # Function Signature ```python def regex_match(s: str, p: str) -> bool: pass ``` # Input 1. `s`: A string representing the text to be searched. 2. `p`: A string representing the regular expression pattern. The pattern may include: - `.`: Matches any single character. - `*`: Matches zero or more of the preceding element. # Output * Returns a boolean `True` if the input string matches the entire pattern, `False` otherwise. # Constraints * The length of the input string `s` will not exceed 1000. * The length of the pattern string `p` will not exceed 1000. * The pattern is guaranteed to be a valid regular expression. # Examples Example 1: ```python print(regex_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` Example 2: ```python print(regex_match(\\"mississippi\\", \\"mis*is*p*.\\")) # Output: False ``` Example 3: ```python print(regex_match(\\"ab\\", \\".*\\")) # Output: True ``` # Note 1. Implement the function without utilizing the Python `re` module. 2. Consider edge cases such as empty strings and patterns. 3. Ensure your solution efficiently handles the maximum input sizes.","solution":"def regex_match(s: str, p: str) -> bool: Perform regular expression matching with support for \'.\' and \'*\'. # Create a memoization table memo = {} def dp(i, j): if (i, j) not in memo: if j == len(p): ans = i == len(s) else: first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j + 1] == \'*\': ans = (dp(i, j + 2) or # case where \'*\' means zero occurrences first_match and dp(i + 1, j)) # case where \'*\' means one or more occurrences else: ans = first_match and dp(i + 1, j + 1) memo[i, j] = ans return memo[i, j] return dp(0, 0)"},{"question":"Frequency Analysis You are required to perform frequency analysis on a given text. Frequency analysis is a technique used in cryptography to break ciphers by studying the frequency of occurrence of letters or groups of letters in a ciphertext. Your task is to write a program that counts the frequency of each character in the given text and returns the result in a sorted manner - most frequent characters first. The analysis should be case-insensitive and only consider alphabetic characters. Input Format - A string, `text`, which can contain letters, numbers, spaces, and punctuation. Output Format - A dictionary where the keys are the characters and the values are their corresponding frequencies in descending order. Example ```python def frequency_analysis(text: str) -> Dict[str, int]: # Implement the frequency analysis based on provided analysis and guidelines pass # Example Usage: # Analyzing the frequency of characters in a text print(frequency_analysis(\\"Hello, World!\\")) # Expected output: {\'l\': 3, \'o\': 2, \'h\': 1, \'e\': 1, \'w\': 1, \'r\': 1, \'d\': 1} ``` Implementation Details 1. **Preparation**: Convert the text to lowercase and filter out non-alphabetic characters. 2. **Frequency Counting**: Count the frequency of each character in the filtered text. 3. **Sorting**: Sort the characters by their frequency in descending order. 4. **Output**: Return the sorted frequencies as a dictionary. Note: Raise appropriate errors if the input is invalid.","solution":"from collections import Counter from typing import Dict def frequency_analysis(text: str) -> Dict[str, int]: Perform frequency analysis on a given text. Parameters: text (str): The input text to analyze. Returns: Dict[str, int]: Dictionary with characters as keys and their frequency counts as values, sorted by frequency. # Convert text to lowercase and filter out non-alphabetic characters processed_text = \'\'.join(char for char in text.lower() if char.isalpha()) # Count the frequency of each character frequency = Counter(processed_text) # Sort the frequency dictionary by frequency in descending order sorted_frequency = dict(sorted(frequency.items(), key=lambda item: item[1], reverse=True)) return sorted_frequency"},{"question":"# Count Characters and Return a Dictionary Write a function that counts the number of occurrences of each character in a given string and returns a dictionary where the keys are the characters and the values are the counts. Problem Statement: Implement a function that takes a string as input, counts the frequency of each character in the string, and returns a dictionary with the characters as keys and their respective counts as values. Function Signature: ```python def count_characters(input_string: str) -> dict: pass ``` Input: * `input_string`: A string containing any characters (including spaces and punctuation). Output: * Returns a dictionary where each key is a character from the string, and the corresponding value is the number of times that character appears in the string. Constraints: * The input string will not be empty. * The input string will have a length `n` where (1 le n le 10^6). Guidelines: 1. Handle uppercase and lowercase characters as distinct (case-sensitive). 2. Include spaces, punctuation, and special characters in the frequency count. Example: ```python >>> count_characters(\\"Hello World!\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1, \'!\': 1} >>> count_characters(\\"abracadabra\\") {\'a\': 5, \'b\': 2, \'r\': 2, \'c\': 1, \'d\': 1} ```","solution":"def count_characters(input_string: str) -> dict: Counts the number of occurrences of each character in a given string and returns a dictionary. Args: input_string (str): The string to count characters from. Returns: dict: A dictionary where the keys are characters and the values are the counts. char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Question: Matrix Multiplication You are required to implement a function that performs matrix multiplication. This task is fundamental in various fields including computer graphics, machine learning, and numerical simulations. Your function should take two matrices as inputs and return their product as the result. Function Signature ```python def matrix_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: ``` Input * `matrix_a`: A list of lists where each sublist represents a row in matrix A. * `matrix_b`: A list of lists where each sublist represents a row in matrix B. Output * Returns a list of lists representing the matrix product of `matrix_a` and `matrix_b`. Constraints * The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. * The elements of the matrices are integers. * If the matrices cannot be multiplied due to incompatible dimensions, the function should raise a `ValueError`. Example ```python # Matrix A (2x3) matrix_a = [ [1, 2, 3], [4, 5, 6] ] # Matrix B (3x2) matrix_b = [ [7, 8], [9, 10], [11, 12] ] # Expected result (2x2) # [ # [58, 64], # [139, 154] # ] print(matrix_multiplication(matrix_a, matrix_b)) # Matrix A (2x2) matrix_a = [ [2, 4], [1, 5] ] # Matrix B (2x2) matrix_b = [ [7, 1], [8, 2] ] # Expected result (2x2) # [ # [46, 10], # [47, 11] # ] print(matrix_multiplication(matrix_a, matrix_b)) ``` Note * Ensure that you handle cases where the dimensions of the matrices are not suitable for multiplication by raising a `ValueError`. * You can assume the matrices will always contain integers. This question tests your understanding and implementation of matrix operations, adherence to constraints, and error handling, aligning it with fundamental programming concepts.","solution":"def matrix_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: # Get the dimensions of the matrices rows_a, cols_a = len(matrix_a), len(matrix_a[0]) rows_b, cols_b = len(matrix_b), len(matrix_b[0]) # Check if the matrices can be multiplied if cols_a != rows_b: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeroes result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Context You are a software engineer tasked with implementing and managing a dynamic collection of intervals. For this task, you need to utilize an Interval Tree to efficiently handle insertion, removal, and querying of overlapping intervals. # Problem Statement Implement an **IntervalTree** class that supports dynamic interval insertion, deletion, and querying of all overlapping intervals within a given range. # Function Requirements 1. **Initializer**: `__init__(self) -> None` - Initialize the tree with no intervals. 2. **Insert**: `insert(self, start: int, end: int) -> None` - Insert an interval [start, end). - Time Complexity: (O(log n)) on average. 3. **Delete**: `delete(self, start: int, end: int) -> None` - Remove an interval [start, end). - Time Complexity: (O(log n)) on average. 4. **Query Overlapping**: `query(self, start: int, end: int) -> list[tuple[int, int]]` - Query all intervals overlapping with the given interval [start, end). - Time Complexity: (O(k + log n)), where (k) is the number of overlapping intervals. # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - Outputs should match the function descriptions mentioned above. # Constraints - You may assume that the interval values will always be within the range ([-10^9, 10^9]). - Assumed non-degenerate intervals, i.e., start < end. # Example ```python # Initializing the tree tree = IntervalTree() # Inserting intervals tree.insert(1, 3) tree.insert(5, 8) tree.insert(4, 10) # Querying overlapping intervals print(tree.query(2, 6)) # Outputs [(1, 3), (5, 8), (4, 10)] # Deleting an interval tree.delete(5, 8) # Querying overlapping intervals after deletion print(tree.query(2, 6)) # Outputs [(1, 3), (4, 10)] ``` # Notes - Make sure that the queries handle edge cases gracefully, such as intervals touching at endpoints and fully nested intervals. - Maintain optimal performance by utilizing efficient data structures and algorithms for the interval operations.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals = sorted(self.intervals, key=lambda x: x[0]) def delete(self, start: int, end: int) -> None: if (start, end) in self.intervals: self.intervals.remove((start, end)) def query(self, start: int, end: int) -> list: result = [] for interval in self.intervals: if interval[0] < end and interval[1] > start: result.append(interval) return result"},{"question":"Coding Assessment Question # Context You are managing a database for an online bookstore and need to implement a system to keep track of the inventory. Each book in the inventory has a unique ISBN (International Standard Book Number), title, author, genre, and number of copies in stock. # Task Create a class `BookInventory` that will manage the book inventory. This class should provide methods to add new books, remove books by ISBN, search for books by title or author, and return the current stock of a particular book by its ISBN. # Requirements - Implement the following methods in the `BookInventory` class: - `__init__(self)`: Initializes an empty inventory. - `add_book(self, isbn, title, author, genre, copies)`: Adds a new book or updates the number of copies if the book already exists in the inventory. - **Inputs**: - `isbn` (str): Unique identifier for the book. - `title` (str): Title of the book. - `author` (str): Author of the book. - `genre` (str): Genre of the book. - `copies` (int): Number of copies to add. - `remove_book(self, isbn)`: Removes a book from the inventory based on its ISBN. - **Input**: - `isbn` (str): Unique identifier for the book. - `search_by_title(self, title)`: Searches and returns a list of books that match the title. - **Input**: - `title` (str): Title of the book to search. - **Output**: - A list of dictionaries, where each dictionary represents a book. - `search_by_author(self, author)`: Searches and returns a list of books that match the author. - **Input**: - `author` (str): Author of the books to search. - **Output**: - A list of dictionaries, where each dictionary represents a book. - `get_stock(self, isbn)`: Returns the number of copies available for a book based on its ISBN. - **Input**: - `isbn` (str): Unique identifier for the book. - **Output**: - An integer representing the number of copies available. # Examples ```python # Initialization of BookInventory inventory = BookInventory() # Adding books to the inventory inventory.add_book(\'978-3-16-148410-0\', \'Book One\', \'Author A\', \'Fiction\', 5) inventory.add_book(\'978-1-60-309425-3\', \'Book Two\', \'Author B\', \'Non-Fiction\', 3) # Searching books by title books = inventory.search_by_title(\'Book One\') print(books) # Output: [{\'isbn\': \'978-3-16-148410-0\', \'title\': \'Book One\', \'author\': \'Author A\', \'genre\': \'Fiction\', \'copies\': 5}] # Searching books by author books = inventory.search_by_author(\'Author B\') print(books) # Output: [{\'isbn\': \'978-1-60-309425-3\', \'title\': \'Book Two\', \'author\': \'Author B\', \'genre\': \'Non-Fiction\', \'copies\': 3}] # Getting stock of a book by ISBN stock = inventory.get_stock(\'978-3-16-148410-0\') print(stock) # Output: 5 # Removing a book by ISBN inventory.remove_book(\'978-1-60-309425-3\') # Verifying the book removal books = inventory.search_by_author(\'Author B\') print(books) # Output: [] ``` # Note - Raise exceptions for invalid ISBN formats, zero or negative number of copies when adding, or if trying to remove a book that doesn\'t exist in the inventory.","solution":"class BookInventory: def __init__(self): self.inventory = {} def add_book(self, isbn, title, author, genre, copies): if not isbn or not title or not author or not genre or copies <= 0: raise ValueError(\\"Invalid input\\") if isbn in self.inventory: self.inventory[isbn][\'copies\'] += copies else: self.inventory[isbn] = { \'title\': title, \'author\': author, \'genre\': genre, \'copies\': copies } def remove_book(self, isbn): if isbn not in self.inventory: raise KeyError(\\"Book not found\\") del self.inventory[isbn] def search_by_title(self, title): return [book for isbn, book in self.inventory.items() if book[\'title\'] == title] def search_by_author(self, author): return [book for isbn, book in self.inventory.items() if book[\'author\'] == author] def get_stock(self, isbn): if isbn not in self.inventory: raise KeyError(\\"Book not found\\") return self.inventory[isbn][\'copies\']"},{"question":"# Question A company wants to monitor the performance of its customer service team by analyzing the logs of customer interactions. Your task is to write a function that processes these interaction logs and identifies the top N agents who have handled the most interactions. # Function to Implement Function Signature ```python def top_n_agents(logs: List[str], N: int) -> List[str] ``` Input * `logs` (List of strings): A list where each string represents a log entry in the format `\\"timestamp agent_id interaction_type\\"`. - `timestamp` is a string of 24-hour format \\"HH:MM:SS\\" - `agent_id` is a unique identifier string for the agent involved in the interaction - `interaction_type` is a string indicating the type of interaction (e.g., \\"call\\" or \\"chat\\") * `N` (int): The number of top-performing agents to return. Output * A list of strings containing the `agent_id`s of the top N agents sorted by the number of interactions they handled, in descending order. If two agents have the same number of interactions, their order in the output does not matter. # Examples ```python # Example 1 logs = [ \\"09:00:00 a123 call\\", \\"09:05:00 a123 chat\\", \\"09:10:00 b456 call\\", \\"09:15:00 a123 call\\", \\"09:20:00 b456 chat\\", \\"09:25:00 c789 call\\" ] N = 2 assert top_n_agents(logs, N) == [\\"a123\\", \\"b456\\"] # Example 2 logs = [ \\"10:00:00 x100 call\\", \\"10:05:00 x200 call\\", \\"10:10:00 x100 chat\\", \\"10:15:00 x200 chat\\", \\"10:20:00 x100 call\\" ] N = 1 assert top_n_agents(logs, N) == [\\"x100\\"] ``` # Constraints * The number of `logs` will be between 1 and 1000. * `agent_id` will be a string of 3 to 10 alphanumeric characters. * `N` will be a positive integer and not greater than the number of unique agents in the logs.","solution":"from typing import List from collections import Counter def top_n_agents(logs: List[str], N: int) -> List[str]: Returns the top N agents with the most interactions, in descending order by the number of interactions. # Extract agent IDs from the logs agent_interactions = [log.split()[1] for log in logs] # Count the number of interactions per agent interaction_counts = Counter(agent_interactions) # Get the top N agents based on interaction counts top_agents = [agent for agent, _ in interaction_counts.most_common(N)] return top_agents"},{"question":"# Zigzag Matrix Traversal Context You are tasked with implementing a specific traversal for a 2D matrix. The traversal should follow a zigzag pattern, meaning each row should be traversed in alternating directions: left to right for the first row, right to left for the second row, and so on. Task Write a function that takes a 2D matrix as input and returns a list containing the elements of the matrix in the desired zigzag order. Function Signature ```python def zigzag_traversal(matrix: list) -> list: ... ``` Input - `matrix` (list of list of int): A 2D list representing the matrix. The matrix will have at least one row and one column. Output - A list containing the elements of the matrix in zigzag order. Constraints - Matrix dimensions: (1 leq text{rows}, text{columns} leq 1000) - Each element of the matrix is an integer and can be negative. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = zigzag_traversal(matrix) print(result) # Output: [1, 2, 3, 6, 5, 4, 7, 8, 9] ``` In this example, the traversal follows: - 1st row: left to right [1, 2, 3] - 2nd row: right to left [6, 5, 4] - 3rd row: left to right [7, 8, 9]","solution":"def zigzag_traversal(matrix): result = [] for i, row in enumerate(matrix): if i % 2 == 0: result.extend(row) else: result.extend(reversed(row)) return result"},{"question":"# Context: You work for an e-commerce company which needs to optimize the management of its products\' prices during special sales events. The prices of products are regularly updated in batches, and the company needs to quickly retrieve the sum of prices for any subset of products. To efficiently manage these operations, you decide to use a Fenwick Tree, also known as a Binary Indexed Tree (BIT). # Task: Your task is to complete the given Fenwick Tree class with the necessary functions `update` and `query` from the template provided below. The `update` function should efficiently handle the price updates, and the `query` function should return the sum of prices up to a given product index. # Fenwick Tree class outline: ```python class FenwickTree: def __init__(self, size: int) -> None: # Implementation details def build(self, A: list[int]) -> None: # Implementation details def update(self, idx: int, delta: int) -> None: # To be implemented by students def query(self, idx: int) -> int: # To be implemented by students ``` # Requirements: - Implement the `update` function to increment the price of the product at the index `idx` by `delta`. - Implement the `query` function to return the sum of prices from the start to the product at index `idx`. # Constraints: - 1 ≤ size ≤ 10^5 - 1 ≤ idx ≤ size - -10^6 ≤ delta ≤ 10^6 - The operations will be made such that the array size, updates, and queries will fit within reasonable space and time needs for competitive programming. # Examples: ```python A = [12, 14, 30, 7, 18, 9, 25, 40, 6, 31] fenwick_tree = FenwickTree(10) fenwick_tree.build(A) print(fenwick_tree.query(5)) # Should output 81 (12 + 14 + 30 + 7 + 18) fenwick_tree.update(3, 10) # Adds 10 to the price at index 3 print(fenwick_tree.query(5)) # Should output 91 (12 + 14 + 40 + 7 + 18) print(fenwick_tree.query(10)) # Should output 192 (sum of all elements) ```","solution":"class FenwickTree: def __init__(self, size: int) -> None: self.size = size self.tree = [0] * (size + 1) def build(self, A: list[int]) -> None: for idx, value in enumerate(A, start=1): self.update(idx, value) def update(self, idx: int, delta: int) -> None: while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: result = 0 while idx > 0: result += self.tree[idx] idx -= idx & -idx return result"},{"question":"# Problem Statement You need to implement a system to find and return the k most frequently occurring words in a given text document. Each word, for the purpose of this task, is defined as a sequence of alphanumeric characters, and the words are case-insensitive. # Specifications * **Function**: `top_k_frequent_words(text: str, k: int) -> list[str]` * **Input**: - A string `text` representing the input text document. The document may contain multiple sentences and punctuations. - An integer `k` representing the number of most frequent words to return. * **Output**: A list of strings representing the k most frequently occurring words sorted by their frequency in descending order. If two words have the same frequency, they should appear in lexicographical (alphabetical) order. # Constraints * The length of the input text will not exceed `10^6` characters. * The number of unique words in the text does not exceed `10^5`. * The value of `k` will be positive and will not exceed the number of unique words in the text. * The function should be optimized for time complexity. # Example ```python # Given the following text text = \\"To be, or not to be, that is the question Whether \'tis nobler in the mind to suffer The slings and arrows of outrageous fortune\\" # and k = 3 # After running top_k_frequent_words on the text result = top_k_frequent_words(text, 3) # result should be [\'the\', \'to\', \'be\'] # Given another text text = \\"hello Hello hi Hi , hi hello\\" # and k = 2 # After running top_k_frequent_words on the text result = top_k_frequent_words(text, 2) # result should be [\'hello\', \'hi\'] ``` # Notes * Punctuations should be ignored while considering words. * Words are case-insensitive, \\"hello\\" and \\"Hello\\" should be treated as the same word.","solution":"def top_k_frequent_words(text: str, k: int) -> list[str]: import re from collections import Counter # Convert the text to lowercase and use regex to find all words words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) # Sort the words first by frequency (descending) and then lexicographically sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Extract only the top k words result = [word for word, _ in sorted_words[:k]] return result"},{"question":"# Problem Statement: Write a function `longest_balanced_substring` that takes a string consisting of only \'(\' and \')\' characters and returns the length of the longest balanced substring. A balanced substring is defined as one where the number of \'(\' characters is equal to the number of \')\' characters, and at no point in the substring is the number of \')\' greater than the number of \'(\'. # Function Signature: ```python def longest_balanced_substring(s: str) -> int: ``` # Input: - `s`: A string containing only \'(\' and \')\' characters. The length of `s` is `n` where 0 <= n <= 10^5. # Output: - Return the length of the longest balanced substring. # Constraints: 1. The function should have a time complexity of O(n). 2. The function should handle strings of varying lengths, including edge cases such as an empty string. # Example: ```python assert longest_balanced_substring(\\"(()())\\") == 6 assert longest_balanced_substring(\\"()(())\\") == 6 assert longest_balanced_substring(\\"((())\\") == 4 assert longest_balanced_substring(\\"()(()))\\") == 6 assert longest_balanced_substring(\\"\\") == 0 ``` # Notes: - The function should robustly handle different scenarios, including cases where the string is entirely balanced, partially balanced, or contains no balanced segments at all. - Consider edge cases where multiple balanced substrings of different lengths might exist. - Ensure the solution optimizes both time and space complexity. # Solution Criteria: - Your function should demonstrate a good understanding of stack-based and/or two-pointer techniques for solving string-based problems. - The implementation should efficiently parse the input string and correctly identify the longest balanced substring without unnecessary computations.","solution":"def longest_balanced_substring(s: str) -> int: max_len = 0 left = right = 0 # Traverse the string from left to right for char in s: if char == \'(\': left += 1 else: right += 1 if left == right: max_len = max(max_len, 2 * right) elif right > left: left = right = 0 left = right = 0 # Traverse the string from right to left for char in reversed(s): if char == \'(\': left += 1 else: right += 1 if left == right: max_len = max(max_len, 2 * left) elif left > right: left = right = 0 return max_len"},{"question":"# Question: Function to Implement: `triangle_area` Context: In geometry, a triangle is defined by its three sides. Heron\'s formula, named after Hero of Alexandria, provides a method for calculating the area of a triangle when the lengths of all three sides are known. The formula is given as: [ A = sqrt{s cdot (s - a) cdot (s - b) cdot (s - c)} ] Where: * ( A ) is the area of the triangle. * ( s ) is the semi-perimeter of the triangle, calculated as ( s = frac{a + b + c}{2} ). * ( a ), ( b ), and ( c ) are the lengths of the sides of the triangle. Task: You need to implement the function `triangle_area`: ```python def triangle_area(side_1: float, side_2: float, side_3: float) -> float: Input Parameters ---------------- side_1 : length of the first side in units side_2 : length of the second side in units side_3 : length of the third side in units Returns ------- result : the area of the triangle in square units. If the sides do not form a valid triangle, return 0. ``` Examples: 1. `triangle_area(side_1=5, side_2=12, side_3=13)` should return `30.0` 2. `triangle_area(side_1=3, side_2=4, side_3=5)` should return `6.0` 3. `triangle_area(side_1=1, side_2=1, side_3=2)` should return `0` (Invalid triangle) 4. `triangle_area(side_1=7, side_2=24, side_3=25)` should return `84.0` 5. `triangle_area(side_1=-3, side_2=4, side_3=5)` should raise `ValueError(\\"Side lengths must be positive\\")`. Constraints: * The lengths of the sides should be positive numbers. * The sides must satisfy the triangle inequality theorem (the sum of the lengths of any two sides must be greater than the length of the remaining side). * If the sides do not form a valid triangle, the function should return 0. Edge Cases: * Negative values for any of the sides. * Sides that do not satisfy the triangle inequality theorem. * Very small side lengths that result in a near-zero area.","solution":"import math def triangle_area(side_1: float, side_2: float, side_3: float) -> float: Calculates the area of a triangle using Heron\'s formula. If the sides do not form a valid triangle, returns 0. If side lengths are negative, raises a ValueError. Parameters: side_1: Length of the first side in units. side_2: Length of the second side in units. side_3: Length of the third side in units. Returns: The area of the triangle in square units. # Check if any side length is negative if side_1 <= 0 or side_2 <= 0 or side_3 <= 0: raise ValueError(\\"Side lengths must be positive\\") # Check triangle inequality theorem if (side_1 + side_2 <= side_3) or (side_1 + side_3 <= side_2) or (side_2 + side_3 <= side_1): return 0 # Calculate semi-perimeter s = (side_1 + side_2 + side_3) / 2 # Calculate area using Heron\'s formula area = math.sqrt(s * (s - side_1) * (s - side_2) * (s - side_3)) return area"},{"question":"# Problem Statement: Given a string containing digits from \'0\' to \'9\', you are required to find the smallest possible number that can be formed by deleting exactly one digit from the string. Write a function `smallest_number_after_deletion(s: str) -> str` that takes a string `s` as input and returns a new string representing the smallest number that can be obtained by removing exactly one digit from `s`. # Input Format: - `s` (string): A non-empty string consisting of digits from \'0\' to \'9\'. - The length of the string is between 2 and 100, inclusive. # Output Format: - Return a string representing the smallest possible number that can be formed by deleting one digit from the input string `s`. # Example: ```python >>> smallest_number_after_deletion(\\"123\\") \\"12\\" >>> smallest_number_after_deletion(\\"1024\\") \\"024\\" >>> smallest_number_after_deletion(\\"10\\") \\"0\\" ``` # Constraints: - Ensure your solution handles edge cases where removing different digits leads to different smallest possible numbers. - Make sure the leading zeros are handled correctly in the resulting number. - Your solution should run efficiently even for the maximum input size. # Implementation Details: To find the smallest possible number: 1. Iterate over each digit in the string. 2. For each digit, create a new number by removing that digit. 3. Compare all the resultant numbers to find the smallest one. 4. Return the smallest number as a string. Ensure minimal but sufficient checks for performance and correctness, especially considering the constraints on input size and the presence of leading zeros.","solution":"def smallest_number_after_deletion(s: str) -> str: smallest = None for i in range(len(s)): current_number = s[:i] + s[i+1:] if smallest is None or current_number < smallest: smallest = current_number return smallest"},{"question":"# Matrix Multiplication Design a function to perform matrix multiplication. Matrix multiplication involves multiplying rows of the first matrix by columns of the second matrix and summing the products to get the elements of the resulting matrix. Objective Write a function `matrix_multiply` that takes two matrices and returns their product, or raises a ValueError if they cannot be multiplied. Function Signature ```python def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: ``` # Input - A: A `m x p` matrix where `A[i][j]` is an integer for `0 <= i < m` and `0 <= j < p`. - B: A `p x n` matrix where `B[i][j]` is an integer for `0 <= i < p` and `0 <= j < n`. # Output - The resulting `m x n` matrix after multiplying `A` and `B`. # Constraints - `1 <= m, n, p <= 500` - `-1000 <= A[i][j], B[i][j] <= 1000` for all valid `i` and `j` # Examples ```python assert matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) == [[58, 64], [139, 154]] assert matrix_multiply([[1, 0], [0, 1]], [[4, 5], [6, 7]]) == [[4, 5], [6, 7]] assert matrix_multiply([[2, 3]], [[1], [2]]) == [[8]] ``` **Explanation**: 1. For the first example, multiplying `[[1, 2, 3], [4, 5, 6]]` by `[[7, 8], [9, 10], [11, 12]]` produces `[[58, 64], [139, 154]]`. 2. For the second example, multiplying `[[1, 0], [0, 1]]` by `[[4, 5], [6, 7]]` produces `[[4, 5], [6, 7]]`. 3. For the third example, multiplying `[[2, 3]]` by `[[1], [2]]` produces `[[8]]`. # Requirements - Ensure your implementation handles matrices of varying sizes efficiently. - Consider edge cases where the matrices cannot be multiplied and raise an appropriate error.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Number of rows in A m = len(A) # Number of columns in A (and rows in B) p = len(A[0]) # Number of columns in B n = len(B[0]) # Check if A and B can be multiplied if p != len(B): raise ValueError(\\"The number of columns in A must equal the number of rows in B\\") # Initialize the resulting matrix with zeros C = [[0 for _ in range(n)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): for k in range(p): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Question: Implement a Comprehensive Polynomial Class You are tasked with extending an existing `Polynomial` class to include functionalities for evaluating, adding, and subtracting polynomials, as well as for checking the equality of two polynomials. Problem Statement Modify the `Polynomial` class to handle the following requirements: 1. **Polynomial Evaluation**: - Implement a method `evaluate` that takes a value `x` and evaluates the polynomial at `x`. 2. **Polynomial Addition and Subtraction**: - Implement addition and subtraction operators (`__add__` and `__sub__`) for the `Polynomial` class, which allow for adding and subtracting two polynomials. 3. **Equality Check**: - Implement the equality operator (`__eq__`) to check if two polynomials are identical. Class Definition ```python class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients # List of coefficients, from lowest to highest degree def evaluate(self, x): # Implement evaluation of the polynomial at x def __add__(self, other): # Implement polynomial addition def __sub__(self, other): # Implement polynomial subtraction def __eq__(self, other): # Implement check for polynomial equality def __repr__(self): # Implement a readable string representation of the polynomial ``` Requirements 1. **Implement `evaluate` Method**: - The method should take a value `x` and calculate the polynomial\'s value at `x` using the coefficients. 2. **Implement `__add__` Method**: - The method should take another `Polynomial` object and return a new `Polynomial` that is the sum of the two polynomials. 3. **Implement `__sub__` Method**: - The method should take another `Polynomial` object and return a new `Polynomial` that is the difference of the two polynomials. 4. **Implement `__eq__` Method**: - The method should take another `Polynomial` object and return `True` if the two polynomials have the same coefficients, `False` otherwise. 5. **Implement `__repr__` Method**: - This method should provide a human-readable string representation of the polynomial (e.g., \\"3x^2 + 2x + 1\\"). Constraints - Ensure that the addition and subtraction handle polynomials of different lengths by padding with zeros. - Handle edge cases where polynomials may have coefficients that are all zeros. - Ensure the `__repr__` method converts the polynomial into a readable string format. Example ```python p1 = Polynomial([2, 0, 3]) # Represents 3x^2 + 2 p2 = Polynomial([1, 2]) # Represents 2x + 1 # Testing evaluation print(p1.evaluate(1)) # Output should be 5 (3*1^2 + 0*1 + 2) # Testing addition p3 = p1 + p2 print(p3) # Output should be \\"3x^2 + 2x + 3\\" # Testing subtraction p4 = p1 - p2 print(p4) # Output should be \\"3x^2 - 2x + 1\\" # Testing equality p5 = Polynomial([2, 0, 3]) print(p1 == p5) # Output should be True print(p1 == p2) # Output should be False ``` Testing and Performance - Ensure that the extended functionalities are tested with various polynomial degrees and coefficients. - Add test cases to validate the correctness of the evaluate, addition, subtraction, and equality check methods. Implement the above solution and validate using test cases to ensure correct behavior for polynomial operations.","solution":"class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients # List of coefficients, from lowest to highest degree def evaluate(self, x): Evaluates the polynomial at the given value x. result = 0 for exponent, coefficient in enumerate(self.coefficients): result += coefficient * (x ** exponent) return result def __add__(self, other): Adds two polynomials and returns a new polynomial. max_len = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] += other.coefficients[i] return Polynomial(result_coefficients) def __sub__(self, other): Subtracts one polynomial from another and returns a new polynomial. max_len = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] -= other.coefficients[i] return Polynomial(result_coefficients) def __eq__(self, other): Checks if two polynomials are equal. return self.coefficients == other.coefficients def __repr__(self): Returns a readable string representation of the polynomial. terms = [] for exponent, coefficient in enumerate(self.coefficients): if coefficient != 0: term = str(coefficient) if exponent == 1: term += \'x\' elif exponent > 1: term += f\'x^{exponent}\' terms.append(term) return \' + \'.join(terms[::-1]) if terms else \'0\'"},{"question":"# Problem Statement: You are working on a productivity tool that helps users manage their time effectively. One essential feature is to identify overlapping events in a user\'s calendar and suggest the minimum number of rooms required to hold all meetings without conflicts. Each event is characterized by a start time and an end time. Your task is to write a function that calculates the minimum number of rooms required to accommodate all events. # Function Signature: ```python def min_meeting_rooms(intervals: list[list[int]]) -> int: ``` # Input Format: * `intervals`: A list of lists, where each sublist contains two integers `[start, end]` representing the start and end times of a meeting. # Output Format: * Return an integer representing the minimum number of meeting rooms required. # Constraints: * 1 ≤ len(intervals) ≤ 10^4 * 0 ≤ start < end ≤ 10^9 # Performance Requirements: * The solution should have a time complexity of (O(n log n)), where `n` is the number of meetings. # Example: ```python >>> intervals = [[0, 30], [5, 10], [15, 20]] >>> min_meeting_rooms(intervals) 2 ``` # Explanation: In this example, two meetings overlap between times [0, 30] and [5, 10], requiring a minimum of two rooms to avoid conflicts. # Plan: 1. Extract the start and end times of all meetings and sort them separately. 2. Use a min-heap to keep track of end times of intervals. 3. Iterate through the start times: - If the meeting can start after the earliest ending meeting, remove the earliest ending meeting from the heap. - Add the current meeting\'s end time to the heap. 4. The size of the heap at the end of the iteration represents the minimum number of rooms required.","solution":"import heapq def min_meeting_rooms(intervals): if not intervals: return 0 intervals.sort(key=lambda x: x[0]) min_heap = [] heapq.heappush(min_heap, intervals[0][1]) for i in range(1, len(intervals)): if intervals[i][0] >= min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, intervals[i][1]) return len(min_heap)"},{"question":"# Classification of Customer Purchase Intention Using Linear Regression Given a dataset containing various features representing customer behaviors, implement the Linear Regression algorithm to predict the purchase intention of new customers from online data. The dataset includes numerical features like time spent on the website, number of pages visited, and the number of clicks. **Input**: * A `train_data` list of lists, each containing three numeric values representing the features of training samples. * A `train_target` list of floats representing the purchase intentions of training samples. * A `test_data` list of lists, each containing three numeric values for the test features. **Output**: * A list of predicted purchase intentions for each test sample. **Function Signature**: ```python def linear_regression_predict(train_data: list[list[float]], train_target: list[float], test_data: list[list[float]]) -> list[float]: # Function implementation ``` **Constraints**: * All feature values and target values will be floats. **Example**: ```python # Training Data train_data = [ [120.5, 30, 2], [150.3, 40, 3], [130.6, 35, 2.5], [200.8, 50, 4], [220.1, 55, 4.5] ] train_target = [1.0, 1.2, 1.1, 1.5, 1.7] # Test Data test_data = [ [140.5, 32, 2.2], [210.0, 52, 4.1] ] # Expected Output # The purchase intentions for the test data are expected to be in line with the learned model print(linear_regression_predict(train_data, train_target, test_data)) # Output: [predicted_value1, predicted_value2] ``` Ensure to implement linear regression to fit the training data and then predict the purchase intentions for the test data.","solution":"from sklearn.linear_model import LinearRegression def linear_regression_predict(train_data, train_target, test_data): Train a Linear Regression model using train_data and train_target, then predict the purchase intention on test_data. model = LinearRegression() model.fit(train_data, train_target) predictions = model.predict(test_data) return predictions.tolist()"},{"question":"# Context You are developing a simplified in-memory database system that performs range queries. The database should support inserting records and querying for records that fall within a given range. # Objective Write a class `RangeDatabase` that: 1. Allows inserting records. 2. Allows querying records within a specified range. # Required Implementations 1. **Define `RangeDatabase` Class**: - Method: `insert(record: List[float]) -> None` - Inserts a record consisting of floating-point coordinates into the database. - Method: `range_query(lower_bound: List[float], upper_bound: List[float]) -> List[List[float]]` - Returns a list of records where each coordinate falls within the corresponding range [lower_bound[i], upper_bound[i]]. # Constraints - The records may have up to 10 dimensions. - You can assume that the number of records will not exceed (10^5). - Handle edge cases such as performing range queries on an empty database. - All coordinates in `record`, `lower_bound`, and `upper_bound` will be floating-point numbers. # Example Usage ```python db = RangeDatabase() # Insert records db.insert([1.0, 2.0]) db.insert([3.5, 4.5]) db.insert([2.2, 3.3]) db.insert([5.0, 6.0]) # Perform range queries results = db.range_query([1.0, 2.0], [3.0, 4.0]) # Expected output: [[1.0, 2.0], [2.2, 3.3]] results = db.range_query([4.0, 4.0], [6.0, 7.0]) # Expected output: [[5.0, 6.0]] ``` # Performance Requirements The solution must efficiently handle both insertions and range queries for large datasets, aiming to minimize time complexity where possible. Implement your `RangeDatabase` class below with the required methods. Ensure optimal performance and robust handling of edge cases for accurate results.","solution":"class RangeDatabase: def __init__(self): self.records = [] def insert(self, record): Inserts a record consisting of floating-point coordinates into the database. self.records.append(record) def range_query(self, lower_bound, upper_bound): Returns a list of records where each coordinate falls within the corresponding range [lower_bound[i], upper_bound[i]]. result = [] for record in self.records: if all(lower_bound[i] <= record[i] <= upper_bound[i] for i in range(len(record))): result.append(record) return result"},{"question":"# Problem Statement A valid magic square is a grid of numbers where the sum of every row, column, and diagonal is the same. You are required to generate all possible 3x3 magic squares and count how many unique ones exist when arranging the numbers from 1 to 9 without repetition. **Function to Implement** Implement the following function in Python: ```python def count_magic_squares() -> int: Find and count all possible unique 3x3 magic squares that can be formed using numbers 1 to 9. :return: the total number of unique 3x3 magic squares. ``` Input: - The function does not take any parameters. Output: - An integer representing the total number of unique 3x3 magic squares. Constraints: - The grid numbers are restricted to the unique digits from 1 to 9. # Example **Example Usage:** ```python count_magic_squares() ``` **Output:** ``` 8 ``` **Explanation:** There are 8 unique 3x3 magic squares that can be formed using the numbers 1 to 9. Additional Notes: - A magic square is a 3x3 grid where the sum of each row, column, and diagonal is 15. - The function should iterate through all possible combinations of the numbers 1 to 9 in a 3x3 grid and check if they form a valid magic square. This problem assesses the candidate\'s ability to generate permutations, understand magic squares, and efficiently count unique solutions.","solution":"from itertools import permutations def is_magic_square(square): Check if a given 3x3 square is a magic square. :param square: List of lists representing the 3x3 square. :return: Boolean indicating if the square is a magic square. # Calculate the sums of rows, columns, and diagonals sums = [ sum(square[0]), sum(square[1]), sum(square[2]), # Rows sum(square[i][0] for i in range(3)), # Column 1 sum(square[i][1] for i in range(3)), # Column 2 sum(square[i][2] for i in range(3)), # Column 3 sum(square[i][i] for i in range(3)), # Diagonal 1 sum(square[i][2 - i] for i in range(3)) # Diagonal 2 ] # All sums should be the same and equal to 15 for a valid magic square return all(s == 15 for s in sums) def count_magic_squares() -> int: Find and count all possible unique 3x3 magic squares that can be formed using numbers 1 to 9. :return: the total number of unique 3x3 magic squares. count = 0 for perm in permutations(range(1, 10)): square = [ perm[:3], perm[3:6], perm[6:] ] if is_magic_square(square): count += 1 return count"},{"question":"# Context You are asked to develop a function that helps determine the execution order of a list of tasks based on their priorities. Each task is represented by a tuple containing a unique task identifier and its associated priority. Tasks with higher priority values should be executed before those with lower priority values. If two tasks have the same priority, they should maintain their relative order of appearance in the input list. # Task Implement a function `prioritize_tasks` that sorts a list of tasks according to their priorities in descending order. # Requirements * **Input**: * `tasks` (List[Tuple[str, int]]): A list of tuples where each tuple contains a task identifier (string) and its priority (int). * **Output**: * A list of strings representing the task identifiers sorted based on priority in descending order. * **Constraints**: * Each task identifier is unique. * The priority is an integer where a higher number indicates a higher priority. * If two tasks have the same priority, the task that appears first in the input list should appear first in the output list. # Example ```python def prioritize_tasks(tasks: List[Tuple[str, int]]) -> List[str]: Sort the tasks by priority in descending order. Parameters: tasks : List[Tuple[str, int]]: A list of (task identifier, priority) tuples. Returns: List[str]: Sorted list of task identifiers by their priority. Example: >>> prioritize_tasks([(\\"task1\\", 3), (\\"task2\\", 1), (\\"task3\\", 3)]) [\'task1\', \'task3\', \'task2\'] >>> prioritize_tasks([(\\"taskA\\", 2), (\\"taskB\\", 5), (\\"taskC\\", 4), (\\"taskD\\", 2)]) [\'taskB\', \'taskC\', \'taskA\', \'taskD\'] # Your implementation here pass # Test cases print(prioritize_tasks([(\\"task1\\", 3), (\\"task2\\", 1), (\\"task3\\", 3)])) # Output: [\'task1\', \'task3\', \'task2\'] print(prioritize_tasks([(\\"taskA\\", 2), (\\"taskB\\", 5), (\\"taskC\\", 4), (\\"taskD\\", 2)])) # Output: [\'taskB\', \'taskC\', \'taskA\', \'taskD\'] print(prioritize_tasks([(\\"taskX\\", 1), (\\"taskY\\", 1), (\\"taskZ\\", 2)])) # Output: [\'taskZ\', \'taskX\', \'taskY\'] ```","solution":"from typing import List, Tuple def prioritize_tasks(tasks: List[Tuple[str, int]]) -> List[str]: Sort the tasks by priority in descending order. Parameters: tasks : List[Tuple[str, int]]: A list of (task identifier, priority) tuples. Returns: List[str]: Sorted list of task identifiers by their priority. # Sort tasks by priority in descending order while maintaining relative order for those with the same priority sorted_tasks = sorted(tasks, key=lambda x: -x[1]) return [task[0] for task in sorted_tasks]"},{"question":"# Minimum Operations to Make Array Elements Equal Context: You are tasked with writing a function to determine the minimum number of operations required to make all elements of an array equal. The only operation allowed is incrementing `n-1` elements of the array by 1. Requirements: Implement a function `min_operations_to_equal_elements` that calculates the minimum number of operations needed to make all array elements the same. Function Signature: ```python def min_operations_to_equal_elements(nums: list[int]) -> int: pass ``` Input: - `nums` (list of int): A list of integers (1 <= |nums| <= 10^4, 1 <= nums[i] <= 10^5). Output: - `int`: The minimum number of operations required to make all elements of the array equal. Constraints: - You can only increment `n-1` elements by 1 in each operation. - The elements to be incremented are chosen arbitrarily but must be the same in each operation. Functionality Requirements: 1. Handle edge cases like arrays with a single element efficiently. 2. Ensure the solution is optimized for large input sizes. 3. Clear documentation and code comments for readability. Example: ```python nums = [1, 2, 3] print(min_operations_to_equal_elements(nums)) # Output: 3 ``` Explanation: To make all elements equal: - Increment elements `1` and `2` once: [2, 3, 3] - Increment elements `1` and `2` again: [3, 4, 3] - Increment elements `1` and `2` once more: [4, 4, 4] Hence, 3 operations are needed. Note: - Consider the relationship between the sum of the array and the minimum element to derive the solution efficiently.","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations required to make all elements of the list equal. The only allowed operation is to increment \'n-1\' elements by 1 in each operation. # The strategy is to find the number of operations to make every element equal to the minimum element in the list. min_elem = min(nums) # Total operations required is the sum of differences between each element and the minimum element. operations = sum(x - min_elem for x in nums) return operations"},{"question":"# Question You are provided with a set of numerical sequences. Your task is to design a function that identifies all the longest increasing subsequences (LIS) from a given sequence of integers. **Core Concepts**: A longest increasing subsequence in a sequence of numbers is a subsequence that is as long as possible, in which the elements are arranged in increasing order. # Input - A list of integers `seq` representing the numerical sequence. # Output - A list of lists, where each inner list represents one of the longest increasing subsequences. # Constraints - 1 ≤ len(seq) ≤ 1000 - -10^4 ≤ seq[i] ≤ 10^4 # Example ```python seq = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(find_longest_increasing_subsequences(seq)) ``` Output: ```python [[10, 22, 33, 50, 60, 80], [10, 22, 33, 41, 60, 80]] ``` # Implementation Function signature: ```python def find_longest_increasing_subsequences(seq: list[int]) -> list[list[int]]: pass ``` # Steps to Solve: 1. Calculate the length of the longest increasing subsequence using dynamic programming. 2. Trace back to find all the subsequences of such length. 3. Ensure optimal traversal and storage to handle the constraints efficiently. **Additional Information**: Your implementation should handle large inputs efficiently within the given constraints. Consider potential edge cases, such as sequences with repeated elements or sequences that are strictly increasing or decreasing.","solution":"def find_longest_increasing_subsequences(seq): if not seq: return [] # Length of the input sequence n = len(seq) # lengths[i] will be the length of the longest increasing subsequence ending at index i lengths = [1] * n # prev_elements[i] holds the indices of the previous elements that are part of the LIS ending at index i prev_elements = [[] for _ in range(n)] # Calculate lengths array for i in range(1, n): for j in range(i): if seq[i] > seq[j]: if lengths[j] + 1 > lengths[i]: lengths[i] = lengths[j] + 1 prev_elements[i] = [j] elif lengths[j] + 1 == lengths[i]: prev_elements[i].append(j) # Find the length of LIS max_len = max(lengths) # To collect all LIS of length max_len lis_sequences = [] # Helper function to backtrack and find all LIS of max_len length def build_sequences(index, path): if lengths[index] == 1: lis_sequences.append([seq[idx] for idx in reversed(path + [index])]) return for prev_index in prev_elements[index]: build_sequences(prev_index, path + [index]) # Start backtracking from all indices having LIS length == max_len for i in range(n): if lengths[i] == max_len: build_sequences(i, []) return lis_sequences"},{"question":"# Coding Assessment Question Scenario: You are working on a project for a logistics company tasked with optimizing the process of merging shipments. Shipments arrive with different weights, and the goal is to combine them into a single shipment. Each time you merge two shipments, the cost is equal to the sum of their weights. Your task is to determine the minimum possible cost to merge all shipments into one single shipment. Task: Write a function `min_merge_cost(weights: List[int]) -> int` that calculates the minimum cost required to merge all the given shipments into a single shipment. Input: 1. `weights`: A list of integers representing the weights of the shipments. Output: - An integer representing the minimum cost required to merge all the shipments. Constraints: - The length of `weights` will be at least 1 and at most 10,000. - Each weight will be a positive integer not exceeding 10,000. Example: ```python weights = [4, 3, 2, 6] print(min_merge_cost(weights)) # Output should be 29 ``` Explanation: - First, merge `2` and `3` (cost: 5), leading to the list [4, 5, 6] - Next, merge `4` and `5` (cost: 9), leading to the list [9, 6] - Finally, merge `9` and `6` (cost: 15), leading to the final single shipment. - Total cost: 5 + 9 + 15 = 29 # Performance Requirements: - The time complexity should be O(n log n) where n is the number of shipments. - The algorithm should efficiently handle up to 10,000 shipments. Note: - Ensure to use an efficient data structure to keep track of merging costs and weights. - Carefully consider edge cases, such as when there\'s only one shipment.","solution":"from heapq import heapify, heappop, heappush from typing import List def min_merge_cost(weights: List[int]) -> int: Calculate the minimum cost required to merge all the given shipments into a single shipment. if len(weights) <= 1: return 0 # Convert the list into a min-heap heapify(weights) total_cost = 0 while len(weights) > 1: # Pop the two smallest weights first = heappop(weights) second = heappop(weights) # Merge them cost = first + second total_cost += cost # Push the merged weight back into the heap heappush(weights, cost) return total_cost"},{"question":"# Coding Task: Distinct Elements Counter Objective: Write a function `count_distinct_elements` that takes a list of integers and returns the count of unique elements within the list. Function Signature: ```python def count_distinct_elements(nums: list) -> int: ``` Input: * **nums**: A list `nums` containing integers. The list can have both positive and negative integers. Output: * An integer representing the number of distinct elements in the input list. Constraints: * The length of the input list will not exceed (10^6) elements. * The integer values in the list will be within the range ([-10^6, 10^6]). Example: ```python >>> count_distinct_elements([1, 2, 2, 3, 4, 4, 4, 5, 6]) 6 >>> count_distinct_elements([10, 10, 10, -1, -1, 0, 0, 20]) 4 >>> count_distinct_elements([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) 11 ``` Notes: * Your solution should efficiently handle large lists up to the maximum constraint. * Consider using data structures that can provide fast lookup and insert operations to achieve optimal performance.","solution":"def count_distinct_elements(nums: list) -> int: Returns the count of unique elements within the list. return len(set(nums))"},{"question":"# Remove K Consecutive Duplicates You are given a string and an integer `k`. Your task is to write a function that removes `k` consecutive duplicates from the string. The removal process should be conducted iteratively, as long as there are `k` consecutive duplicates. Implement the following function: 1. `remove_k_consecutive_duplicates(s: str, k: int) -> str`: This function removes k consecutive duplicate characters from the string `s`. Input and Output Formats **`remove_k_consecutive_duplicates` function:** * Input: `s` (str) - The input string. * Input: `k` (int) - The number of consecutive duplicates to remove. * Output: A string with `k` consecutive duplicates removed iteratively until no such duplicates exist. Constraints * The input string `s` is non-empty and consists of lowercase English letters. * The input integer `k` is a positive integer (1 ≤ `k` ≤ len(s)). Examples ```python >>> remove_k_consecutive_duplicates(\\"deeedbbcccbdaa\\", 3) \\"aa\\" # Explanation: # Step 1: \\"deeedbbcccbdaa\\" -> \\"deddbaa\\" # Step 2: \\"deddbaa\\" -> \\"aa\\" >>> remove_k_consecutive_duplicates(\\"pbbcggttciiippooaais\\", 2) \\"ps\\" # Explanation: # Step 1: \\"pbbcggttciiippooaais\\" -> \\"pcgciips\\" # Step 2: \\"pcgciips\\" -> \\"ps\\" >>> remove_k_consecutive_duplicates(\\"abcd\\", 2) \\"abcd\\" >>> remove_k_consecutive_duplicates(\\"llltt\\", 3) \\"tt\\" ``` You need to handle the string input validation and integer `k` to ensure they fit within the constraints when implementing the actual function.","solution":"def remove_k_consecutive_duplicates(s: str, k: int) -> str: Removes k consecutive duplicate characters from the string s iteratively until no such duplicates exist. stack = [] for char in s: if stack and stack[-1][0] == char: stack[-1][1] += 1 else: stack.append([char, 1]) if stack[-1][1] == k: stack.pop() result = \'\'.join(char * count for char, count in stack) return result"},{"question":"# Sorting Log Data by Timestamp You are given a log file that contains multiple lines of log entries. Each log entry has a timestamp and a message. Your task is to sort these log entries by their timestamps in ascending order and write the sorted entries to a new file. Your Task Write a Python function, `sort_log_file_by_timestamp`, which will: 1. Read the log entries from the given log file. 2. Sort the entries by their timestamps. 3. Write the sorted entries into a new file named `\\"sorted_log_file.txt\\"`. # Function Signature ```python def sort_log_file_by_timestamp(input_file: str) -> None: ``` Implementation Details - The log entries are in the format `\\"timestamp message\\"`, where `timestamp` follows the format `YYYY-MM-DD HH:MM:SS` and `message` is a string containing the log message. - Use the `datetime` library to handle the timestamps. - Assume that each line in the input file is a valid log entry. Example Given the input file `\\"log_file.txt\\"` with the following entries: ``` 2023-10-05 14:48:00 Log entry one 2023-10-05 09:30:00 Log entry two 2023-10-05 12:15:00 Log entry three ``` After running your function, the `\\"sorted_log_file.txt\\"` should contain: ``` 2023-10-05 09:30:00 Log entry two 2023-10-05 12:15:00 Log entry three 2023-10-05 14:48:00 Log entry one ``` # Constraints - Handle potential file reading and writing errors. - Ensure that the timestamps are correctly parsed and sorted. # Hints - Use Python\'s `open` function to read and write files. - Use the `datetime` module for parsing and comparing timestamps. - You may use list sorting functions to order the log entries.","solution":"import datetime def sort_log_file_by_timestamp(input_file: str) -> None: with open(input_file, \'r\') as file: log_entries = file.readlines() log_entries = [entry.strip() for entry in log_entries] def extract_timestamp(log_entry): timestamp_str = log_entry.split(\\" \\", 2)[:2] timestamp_str = \\" \\".join(timestamp_str) return datetime.datetime.strptime(timestamp_str, \'%Y-%m-%d %H:%M:%S\') sorted_log_entries = sorted(log_entries, key=extract_timestamp) with open(\\"sorted_log_file.txt\\", \'w\') as file: for entry in sorted_log_entries: file.write(entry + \\"n\\")"},{"question":"# Problem Statement You are given a rectangular grid of dimensions `m x n` representing a park, where each cell may contain a tree (represented by a 1) or be empty (represented by a 0). A tree is considered part of an orchard if it is directly connected to another tree horizontally or vertically. However, diagonally adjacent trees are not considered connected. Your task is to determine the number of distinct orchards in the park. Each orchard must be counted exactly once, and an orchard is a group of contiguous `1`s connected horizontally and vertically. Implement the function `count_orchards`: ```python def count_orchards(grid: List[List[int]]) -> int: Count the number of distinct orchards in a rectangular grid. Args: - grid (List[List[int]]): A two-dimensional list representing the park with trees (1) and empty spaces (0). Returns: - int: The number of distinct orchards in the grid. ``` # Example: ```python assert count_orchards([ [1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 1] ]) == 2 # There are two distinct orchards assert count_orchards([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) == 3 # Each tree is an individual orchard ``` # Constraints: * `1 <= m, n <= 300` * All elements in `grid` are either 0 or 1. # Notes: * Use either depth-first search (DFS) or breadth-first search (BFS) to count the distinct groups of contiguous 1\'s. * Ensure the solution handles larger grids efficiently.","solution":"from typing import List def count_orchards(grid: List[List[int]]) -> int: def dfs(x, y): # If out of bounds or the cell is not a tree, return if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return grid[x][y] = 0 # Mark the cell as visited # Explore all 4 directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) m = len(grid) n = len(grid[0]) orchard_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: orchard_count += 1 dfs(i, j) return orchard_count"},{"question":"# Problem Statement You are required to implement a feature-rich `LibrarySystem` class that mimics a simple library system, allowing users to borrow and return books, check availability, and track borrowed books. Your task is to: 1. Implement methods to add and remove books from the system. 2. Implement methods to borrow and return books. 3. Track which books are currently borrowed by which users. 4. Provide a method to display the current status of all books in the system. # Requirements - Implement the `LibrarySystem` class with necessary methods. - Add three new methods to the class: * `add_book` to add a book to the system. * `remove_book` to remove a book from the system. * `borrow_book` for a user to borrow a book. * `return_book` for a user to return a borrowed book. # Function Implementation Method Header 1. **Adding a book**: ```python def add_book(self, book_title: str) -> None: ``` - **book_title**: The title of the book to be added. 2. **Removing a book**: ```python def remove_book(self, book_title: str) -> None: ``` - **book_title**: The title of the book to be removed. 3. **Borrowing a book**: ```python def borrow_book(self, user_id: str, book_title: str) -> Union[str, None]: ``` - **user_id**: The ID of the user borrowing the book. - **book_title**: The title of the book to be borrowed. - **returns**: `None` if the book was successfully borrowed, otherwise a string indicating the failure reason (e.g., \\"Book not available\\"). 4. **Returning a book**: ```python def return_book(self, user_id: str, book_title: str) -> Union[str, None]: ``` - **user_id**: The ID of the user returning the book. - **book_title**: The title of the book being returned. - **returns**: `None` if the book was successfully returned, otherwise a string indicating the failure reason (e.g., \\"Book not borrowed by user\\"). 5. **Displaying the status of books**: ```python def display_books_status(self) -> List[Tuple[str, str]]: ``` - **returns**: A list of tuples where each tuple contains the book title and its current status (either \\"Available\\" or the user ID of the borrower). # Input and Output Formats - Book titles and user IDs will be strings. - The `display_books_status` method should return the list sorted by book titles in alphabetical order. # Constraints - The system can handle up to 10,000 books. - All book titles will be unique. - A user cannot borrow more than 5 books at the same time. # Example ```python # Example usage of the LibrarySystem class library = LibrarySystem() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill a Mockingbird\\") print(library.borrow_book(\\"user1\\", \\"1984\\")) # Expected Output: None (successful borrow) print(library.borrow_book(\\"user2\\", \\"1984\\")) # Expected Output: \\"Book not available\\" (already borrowed) print(library.return_book(\\"user1\\", \\"1984\\")) # Expected Output: None (successful return) print(library.borrow_book(\\"user2\\", \\"1984\\")) # Expected Output: None (successful borrow) print(library.display_books_status()) # Expected Output: [(\'1984\', \'user2\'), (\'The Great Gatsby\', \'Available\'), (\'To Kill a Mockingbird\', \'Available\')] ``` # Notes - Ensure proper error handling for invalid operations, such as borrowing a book that does not exist, or a user trying to return a book they have not borrowed. - Maintain an efficient and clean tracking mechanism for checking the availability and borrowing status of each book.","solution":"from typing import List, Tuple, Union class LibrarySystem: def __init__(self): self.books = {} def add_book(self, book_title: str) -> None: if book_title not in self.books: self.books[book_title] = \\"Available\\" def remove_book(self, book_title: str) -> None: if book_title in self.books and self.books[book_title] == \\"Available\\": del self.books[book_title] def borrow_book(self, user_id: str, book_title: str) -> Union[str, None]: if book_title not in self.books: return \\"Book does not exist\\" if self.books[book_title] != \\"Available\\": return \\"Book not available\\" self.books[book_title] = user_id return None def return_book(self, user_id: str, book_title: str) -> Union[str, None]: if book_title not in self.books: return \\"Book does not exist\\" if self.books[book_title] != user_id: return \\"Book not borrowed by user\\" self.books[book_title] = \\"Available\\" return None def display_books_status(self) -> List[Tuple[str, str]]: return sorted(self.books.items()) # Example usage library = LibrarySystem() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill a Mockingbird\\") print(library.borrow_book(\\"user1\\", \\"1984\\")) # None print(library.borrow_book(\\"user2\\", \\"1984\\")) # \\"Book not available\\" print(library.return_book(\\"user1\\", \\"1984\\")) # None print(library.borrow_book(\\"user2\\", \\"1984\\")) # None print(library.display_books_status()) # [(\'1984\', \'user2\'), (\'The Great Gatsby\', \'Available\'), (\'To Kill a Mockingbird\', \'Available\')]"},{"question":"# Pascal\'s Triangle Generator Pascal\'s Triangle is a triangular array of binomial coefficients. The entry in the nth row and kth column of Pascal\'s triangle is given by (C(n, k) = frac{n!}{k!(n-k)!}). # Task Write a function `generate_pascals_triangle(n: int) -> list[list[int]]` that returns the first `n` rows of Pascal\'s Triangle. # Details - **Input**: A single integer `n` where (0 leq n leq 30). - **Output**: A list of lists, where each inner list represents one row of Pascal\'s Triangle. - **Constraints**: The function should handle erroneous inputs gracefully (e.g., non-integer, negative). # Performance Requirements - The function should have a time complexity of (O(n^2)) or better. # Example ```python def generate_pascals_triangle(n: int) -> list[list[int]]: pass # Your implementation here # Example usages and expected outputs print(generate_pascals_triangle(1)) # Expected output: [[1]] print(generate_pascals_triangle(2)) # Expected output: [[1], [1, 1]] print(generate_pascals_triangle(3)) # Expected output: [[1], [1, 1], [1, 2, 1]] ``` # Explanation 1. **Initialization**: Start with the first row as [1]. 2. **Construction**: Each subsequent row is constructed by adding the two numbers above it in the previous row. 3. **Row Generation**: - Begin with [1]. - For row (r), each element at position (k) is equal to the sum of element (k) and element (k-1) from row (r-1). - End the row with [1]. 4. **Result**: Repeat until `n` rows are generated, and return the list of these rows. # Constraints 1. Valid input ranges from 0 to 30. 2. Ensure input validation for non-integer and invalid values of `n`. # Corner Cases - If `n` is 0, the output should be an empty list. - If `n` is 1, the output should be [[1]]. ```python def generate_pascals_triangle(n: int) -> list[list[int]]: if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = result[i - 1][j - 1] + result[i - 1][j] result.append(row) return result ```","solution":"def generate_pascals_triangle(n: int) -> list[list[int]]: if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = result[i - 1][j - 1] + result[i - 1][j] result.append(row) return result"},{"question":"# Calculate Compound Interest You are developing a financial software tool to aid in the prediction of investments\' future value using compound interest. The formula to calculate the compound interest is: [ A = P left(1 + frac{r}{n}right)^{nt} ] where: - ( A ) is the amount of money accumulated after ( n ) years, including interest. - ( P ) is the principal amount (the initial amount of money). - ( r ) is the annual interest rate (in decimal). - ( n ) is the number of times the interest is compounded per year. - ( t ) is the number of years the money is invested or borrowed for. You need to implement a function that takes five parameters and returns the future value of the investment. # Function Signature ```python def calculate_compound_interest(principal: float, rate: float, times_compounded: int, years: float) -> float: ``` # Input - `principal` (float): The initial amount of money (must be > 0). - `rate` (float): The annual interest rate in decimal form (must be >= 0 and <= 1). - `times_compounded` (int): The number of times interest is compounded per year (must be > 0). - `years` (float): The number of years the money is invested or borrowed for (must be > 0). # Output - `float`: The amount of money accumulated after n years, including interest. # Constraints - Raise a `ValueError` with an appropriate message for the following conditions: - If the principal is ≤ 0: \\"Impossible principal amount\\" - If the rate is < 0 or > 1: \\"Impossible interest rate\\" - If the times_compounded is ≤ 0: \\"Impossible times compounded\\" - If the years is ≤ 0: \\"Impossible time period\\" # Examples 1. `calculate_compound_interest(principal=1000, rate=0.05, times_compounded=12, years=10)` should return `1647.00949769028`. 2. `calculate_compound_interest(principal=1500, rate=0.05, times_compounded=4, years=6)` should return `2016.41503749981`. 3. `calculate_compound_interest(principal=2000, rate=0.03, times_compounded=6, years=7)` should return `2481.07555418223`. 4. `calculate_compound_interest(principal=-1000, rate=0.05, times_compounded=4, years=10)` should raise `ValueError: Impossible principal amount`. 5. `calculate_compound_interest(principal=1000, rate=1.02, times_compounded=4, years=10)` should raise `ValueError: Impossible interest rate`. 6. `calculate_compound_interest(principal=1000, rate=0.05, times_compounded=0, years=10)` should raise `ValueError: Impossible times compounded`. 7. `calculate_compound_interest(principal=1000, rate=0.05, times_compounded=4, years=-5)` should raise `ValueError: Impossible time period`. Implement the function in Python, considering the points discussed above.","solution":"def calculate_compound_interest(principal: float, rate: float, times_compounded: int, years: float) -> float: Calculates compound interest. Parameters: principal (float): The initial amount of money rate (float): The annual interest rate (in decimal form) times_compounded (int): The number of times interest is compounded per year years (float): The number of years the money is invested Returns: float: The amount of money accumulated after n years, including interest Raises: ValueError: For invalid input values if principal <= 0: raise ValueError(\\"Impossible principal amount\\") if rate < 0 or rate > 1: raise ValueError(\\"Impossible interest rate\\") if times_compounded <= 0: raise ValueError(\\"Impossible times compounded\\") if years <= 0: raise ValueError(\\"Impossible time period\\") A = principal * (1 + rate / times_compounded) ** (times_compounded * years) return A"},{"question":"# Circular Queue Implementation **Context**: Circular queues are a kind of queue where the end of the queue wraps around to the front, forming a circle. They are useful in buffering scenarios where fixed-size storage that reuses space once it\'s read or processed is beneficial, like in CPU scheduling or data streaming. **Problem Statement**: Your task is to complete the implementation of a circular queue using a fixed-size list. The `CircularQueue` class has placeholders for its core queue operations. You will need to implement the `enqueue` and `dequeue` methods for adding and removing elements from the queue, as well as the `__len__` method to return the current size of the queue. Requirements: * Implement the `enqueue` method to add an element to the back of the queue. * Implement the `dequeue` method to remove and return the element from the front of the queue. * Implement the `__len__` method to return the current number of elements in the queue. * Ensure that the `enqueue` method handles overflows by raising an appropriate exception. * Ensure that the `dequeue` method handles underflows by raising an appropriate exception. # Function Signature ```python class CircularQueue: def __init__(self, capacity): self._data = [None] * capacity self._size = 0 self._front = 0 def enqueue(self, item): pass def dequeue(self): pass def __len__(self): pass ``` # Input & Output * The `enqueue` method takes an item to be added to the queue and returns nothing. * The `dequeue` method returns the item removed from the queue. * The `__len__` method returns the integer number of elements in the queue. # Example ```python >>> q = CircularQueue(3) >>> q.enqueue(10) >>> q.enqueue(20) >>> q.enqueue(30) >>> len(q) 3 >>> q.dequeue() 10 >>> len(q) 2 >>> q.enqueue(40) >>> q.dequeue() 20 ``` # Constraints * The circular queue has a fixed capacity defined at initialization. * Raise an exception when attempting to `enqueue` to a full queue. * Raise an exception when attempting to `dequeue` from an empty queue.","solution":"class CircularQueue: def __init__(self, capacity): self._data = [None] * capacity self._capacity = capacity self._size = 0 self._front = 0 self._rear = 0 def enqueue(self, item): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._data[self._rear] = item self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self._size == 0: raise IndexError(\\"Queue is empty\\") item = self._data[self._front] self._data[self._front] = None # Clear reference self._front = (self._front + 1) % self._capacity self._size -= 1 return item def __len__(self): return self._size"},{"question":"# Problem Statement You are required to implement a frequency analysis algorithm for text data. The algorithm will take a string as input and return the frequency of each character in the string. The output should be a dictionary where the keys are the characters and the values are the corresponding frequencies. Input - A string `text` containing only lowercase and uppercase English letters. Output - A dictionary with characters as keys and their frequencies as values. Function Signature ```python def frequency_analysis(text: str) -> Dict[str, int]: # Implementation here ``` # Constraints 1. The length of the string will be between `1` and `10^6`. 2. The string will contain only lowercase and uppercase English letters. # Example Input ```python text = \\"HelloWorld\\" ``` Output ```python { \'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'W\': 1, \'r\': 1, \'d\': 1 } ``` # Additional Information To get an accurate result: 1. Iterate through each character in the input string. 2. Maintain a dictionary to keep track of the frequency of each character. 3. Return the dictionary with the characters and their respective frequencies.","solution":"def frequency_analysis(text: str) -> dict: Returns a dictionary with the frequency of each character in the input string. frequency_dict = {} for char in text: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Generate Pascal\'s Triangle Row Context: You are developing a mathematical application that requires generating specific rows of Pascal\'s Triangle. Pascal\'s Triangle is a triangular array where each entry is the sum of the two directly above it. Task: Implement a function that generates a specific row of Pascal\'s Triangle: **Function**: `generate_pascals_triangle_row(n: int) -> List[int]` - Generates the nth row of Pascal\'s Triangle. - **Input**: An integer `n` representing the row index (0-based). - **Output**: A list of integers representing the nth row of Pascal\'s Triangle. Constraints: 1. The function should handle `n` in the range 0 <= n <= 30. 2. The result should be a 0-based index as Pascal\'s Triangle\'s top row is considered the 0th row. 3. Optimize the function for both memory usage and computational efficiency. Example: ```python >>> generate_pascals_triangle_row(0) [1] >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] ``` Implement the method ensuring accurate and efficient generation of Pascal\'s Triangle rows.","solution":"def generate_pascals_triangle_row(n): Generates the nth row of Pascal\'s Triangle. Args: n (int): The row index (0-based). Returns: List[int]: The nth row of Pascal\'s Triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): row.append(row[k - 1] * (n - k + 1) // k) return row"},{"question":"# Problem Statement You have been recruited to develop a function for a library management system that generates summaries of overdue books. The aim is to allow librarians to input a collection of loan records and for the module to output details of all overdue books along with the total fine. # Requirements You are to implement a function `overdue_books` that processes each loan record and determines which books are overdue, calculating the associated fines based on the given daily fine rate. Additionally, the function should return a summary of all overdue books and the cumulative fine. # Input and Output 1. **Input** - `overdue_books(loan_records: list, current_date: str, daily_fine_rate: float) -> dict` - `loan_records`: list of dictionaries, where each dictionary represents a book loan record with the keys: - `\'title\'`: string (the title of the book) - `\'due_date\'`: string (due date of the book in \'YYYY-MM-DD\' format) - `\'borrower\'`: string (name of the borrower) - `current_date`: string (current date in \'YYYY-MM-DD\' format) - `daily_fine_rate`: float (the fine charged per overdue day, must be non-negative) 2. **Output** - Return a dictionary containing: - `\'overdue_books\'`: list of dictionaries with the titles and overdue days of the overdue books - Each dictionary contains: - `\'title\'`: string (the title of the overdue book) - `\'overdue_days\'`: int (number of days the book is overdue) - `\'total_fine\'`: float (total fine for all overdue books) # Constraints - The input dates are guaranteed to be in the \'YYYY-MM-DD\' format. - `daily_fine_rate >= 0` # Example ```python loan_records = [ {\'title\': \'Book A\', \'due_date\': \'2023-05-10\', \'borrower\': \'Alice\'}, {\'title\': \'Book B\', \'due_date\': \'2023-05-05\', \'borrower\': \'Bob\'}, {\'title\': \'Book C\', \'due_date\': \'2023-05-15\', \'borrower\': \'Charlie\'} ] overdue_books(loan_records, \'2023-05-12\', 0.5) # Output: # {\'overdue_books\': [{\'title\': \'Book A\', \'overdue_days\': 2}, {\'title\': \'Book B\', \'overdue_days\': 7}], # \'total_fine\': 4.5} ``` # Notes - Perform validation to ensure the `daily_fine_rate` is non-negative and raise an exception for invalid inputs. - Ensure date calculations are accurate. You can use Python\'s `datetime` module for date manipulations. - Round the total fine to two decimal places. # Implementation Implement the function using the provided structure and ensure to handle edge cases such as no overdue books or zero fine rate appropriately.","solution":"from datetime import datetime def overdue_books(loan_records, current_date, daily_fine_rate): Processes loan records to determine overdue books and calculate total fine based on daily fine rate. Args: loan_records (list): List of dictionaries with keys \'title\', \'due_date\', and \'borrower\'. current_date (str): Current date in \'YYYY-MM-DD\' format. daily_fine_rate (float): Fine charged per overdue day. Must be non-negative. Returns: dict: A dictionary containing a list of overdue books with titles and overdue days, and the total fine. if daily_fine_rate < 0: raise ValueError(\\"Daily fine rate must be non-negative\\") current_date_dt = datetime.strptime(current_date, \'%Y-%m-%d\') overdue = [] total_fine = 0.0 for record in loan_records: due_date_dt = datetime.strptime(record[\'due_date\'], \'%Y-%m-%d\') overdue_days = (current_date_dt - due_date_dt).days if overdue_days > 0: overdue.append({ \'title\': record[\'title\'], \'overdue_days\': overdue_days }) total_fine += overdue_days * daily_fine_rate return { \'overdue_books\': overdue, \'total_fine\': round(total_fine, 2) }"},{"question":"# Sales Performance Bonus Calculation You are tasked with creating a function that calculates the bonus amount for a sales team based on their performance over a given period. The bonus amount is determined using a progressive bonus scheme where higher levels of sales achievement correspond to higher bonus rates. The bonus scheme is defined as follows: 1. 5% of total sales if the sales are up to 50,000. 2. 7% for the portion of sales between 50,001 and 100,000. 3. 10% for the portion of sales exceeding 100,000. The Task Given the total sales amount for the period, your function should calculate the total bonus amount according to the specified progressive bonus rates. **Function Signature:** ```python def calculate_bonus(total_sales: float) -> float: pass ``` **Input:** - `total_sales` (*float*): a non-negative floating-point number representing the total sales amount over a period. **Output:** - (*float*): The calculated bonus amount as a floating-point number. **Constraints:** - Total sales amount will be a non-negative value. - The function should handle large sales values efficiently. # Example Usages: ```python print(calculate_bonus(45000)) # Expected output: 2250.0 print(calculate_bonus(75000)) # Expected output: 4000.0 print(calculate_bonus(150000)) # Expected output: 11500.0 ``` **Scenario:** You are given the quarterly sales data of a sales team and need to compute the bonus amount each team member is eligible for. The bonus is calculated based on their total sales for that quarter as per the bonus scheme.","solution":"def calculate_bonus(total_sales: float) -> float: Calculate the bonus based on total sales using a progressive bonus scheme. Parameters: total_sales (float): The total sales amount. Returns: float: The total bonus amount. bonus = 0.0 if total_sales <= 50000: bonus = total_sales * 0.05 elif total_sales <= 100000: bonus = 50000 * 0.05 + (total_sales - 50000) * 0.07 else: bonus = 50000 * 0.05 + 50000 * 0.07 + (total_sales - 100000) * 0.10 return bonus"},{"question":"# Problem Statement You are given the task to implement a custom class that models a Stack data structure with an additional feature to return the minimum element in the stack in constant time (O(1)). You are required to demonstrate a robust understanding of stack operations as well as efficient data retrieval techniques. # Goal Create a `MinStack` class with the following methods: 1. `push(x)`: Push an integer `x` onto the stack. 2. `pop()`: Remove the element on the top of the stack. 3. `top()`: Get the top element. 4. `get_min()`: Retrieve the minimum element in the stack. # Implementation MinStack Class 1. **Initialization** * Initialize a main stack to store all the elements. * Initialize an auxiliary stack to store the minimum element at each level. 2. **Push Operation** * Push the element to the main stack. * If the auxiliary stack is empty or the new element is less than or equal to the top of the auxiliary stack, push the new element onto the auxiliary stack. 3. **Pop Operation** * Pop the element from the main stack. * If the popped element is equal to the top of the auxiliary stack, pop the element from the auxiliary stack as well. 4. **Top Operation** * Return the element at the top of the main stack. 5. **Get Min Operation** * Return the element at the top of the auxiliary stack, which represents the minimum element in the main stack. # Input and Output Format ```python class MinStack: def __init__(self): # Initialize the stack def push(self, val: int) -> None: # Implementation for push operation def pop(self) -> None: # Implementation for pop operation def top(self) -> int: # Implementation to get the top element def get_min(self) -> int: # Implementation to get the minimum element # Expected Input stack = MinStack() stack.push(5) stack.push(3) stack.push(7) print(stack.get_min()) # Expected Output: 3 stack.pop() print(stack.get_min()) # Expected Output: 3 stack.pop() print(stack.get_min()) # Expected Output: 5 stack.top() # Expected Output: 5 ``` # Constraints and Performance Requirements 1. All operations should be performed in constant time (O(1)). 2. The stack should handle a minimum of 10,000 operations efficiently. # Example Scenario ```python # Create a MinStack object stack = MinStack() # Perform operations stack.push(5) stack.push(3) stack.push(7) print(stack.get_min()) # Output: 3 stack.pop() print(stack.get_min()) # Output: 3 stack.pop() print(stack.get_min()) # Output: 5 print(stack.top()) # Output: 5 ``` # Write your MinStack class below:","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) # Push the new minimum to the min_stack if it\'s smaller than or equal to the current minimum if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: top = self.stack.pop() # If the popped element is the minimum, pop it from the min_stack as well if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: return self.stack[-1] if self.stack else None def get_min(self) -> int: return self.min_stack[-1] if self.min_stack else None"},{"question":"# Coding Question Context Given a sequence of integers, some of which may be duplicated, you need to identify and return the k most frequent elements in that sequence. If there is a tie in frequency, the element with smaller value should be preferred. Problem Statement Write a function called `top_k_frequent_elements` that takes two arguments: 1. `nums` (a list of integers): The list of integers, which may contain duplicates. 2. `k` (an integer): The number of top frequent elements to return. Your function should return a list of the k most frequent elements sorted in decreasing frequency. If multiple elements have the same frequency, they should be sorted in ascending order. Input Format * `nums` (1 <= len(nums) <= 10^5): A list of integers which may contain duplicates. * `k` (1 <= k <= len(nums)): An integer specifying the number of top frequent elements to return. Output Format * A list containing the k most frequent elements in the specified order. Example * Example 1: ```python top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) # Should return [1, 2] ``` * Example 2: ```python top_k_frequent_elements([4, 4, 4, 5, 5, 5, 6], 1) # Should return [4] ``` * Example 3: ```python top_k_frequent_elements([1, 2, 3, 4, 1, 2, 3, 1, 2], 2) # Should return [1, 2] ``` Constraints and Performance Requirements - The solution should be optimized to handle large lists efficiently. Consider using data structures and algorithms that help reduce time complexity. - Take care to handle ties in frequency as specified.","solution":"from collections import Counter import heapq def top_k_frequent_elements(nums, k): Returns the k most frequent elements from the nums list. If there is a tie in frequency, the element with the smaller value is preferred. # Calculate the frequency of each element in nums count = Counter(nums) # Create a max heap with negative frequency to get the k most frequent elements heap = [(-freq, num) for num, freq in count.items()] heapq.heapify(heap) # Extract the top k elements from the heap top_k = [heapq.heappop(heap)[1] for _ in range(k)] return top_k"},{"question":"# Problem Statement You are tasked with implementing a class that models a simplified playlist for managing songs. Each song has a title, artist, and duration (in seconds). Your class should support adding, removing, and retrieving songs, as well as calculating the total duration. Additionally, your playlist should be able to handle duplications: if the same song is added multiple times, it should only appear once in the playlist. Removing a song should remove all instances of that song from the playlist. # Instructions 1. Define a class `Song` with the following attributes: * `title`: the title of the song (string). * `artist`: the artist of the song (string). * `duration`: the duration of the song in seconds (integer). 2. Define a class `Playlist` with the following methods: * `add_song`: Adds a song to the playlist. If the song is already in the playlist, it should not add it again. * `remove_song`: Removes all instances of a specific song from the playlist. * `get_songs`: Returns a list of all songs currently in the playlist. * `total_duration`: Returns the total duration of all songs in the playlist. * Ensure that adding or removing a song appropriately handles duplicate songs based on their title, artist, and duration. # Example Usage ```python class Song: def __init__(self, title: str, artist: str, duration: int): self.title = title self.artist = artist self.duration = duration class Playlist: def __init__(self): self.songs = [] def add_song(self, song: Song): for s in self.songs: if s.title == song.title and s.artist == song.artist and s.duration == song.duration: return self.songs.append(song) def remove_song(self, song: Song): self.songs = [s for s in self.songs if not (s.title == song.title and s.artist == s.artist and s.duration == song.duration)] def get_songs(self) -> list: return self.songs def total_duration(self) -> int: return sum(song.duration for song in self.songs) # Example s1 = Song(\\"Title1\\", \\"Artist1\\", 300) s2 = Song(\\"Title2\\", \\"Artist2\\", 200) s3 = Song(\\"Title1\\", \\"Artist1\\", 300) playlist = Playlist() playlist.add_song(s1) playlist.add_song(s2) playlist.add_song(s3) # This should not add the song again print(len(playlist.get_songs())) # Output: 2 playlist.remove_song(s1) print(len(playlist.get_songs())) # Output: 1 print(playlist.total_duration()) # Output: 200 ``` # Constraints * The duration of a song is always a positive integer. * Song titles and artist names are always non-empty strings. * No two distinct songs have the same title, artist, and duration. # Function Signatures ```python class Song: def __init__(self, title: str, artist: str, duration: int): pass class Playlist: def __init__(self): pass def add_song(self, song: Song): pass def remove_song(self, song: Song): pass def get_songs(self) -> list: pass def total_duration(self) -> int: pass ```","solution":"class Song: def __init__(self, title: str, artist: str, duration: int): self.title = title self.artist = artist self.duration = duration def __eq__(self, other): return (self.title == other.title and self.artist == other.artist and self.duration == other.duration) def __hash__(self): return hash((self.title, self.artist, self.duration)) class Playlist: def __init__(self): self.songs = set() def add_song(self, song: Song): self.songs.add(song) def remove_song(self, song: Song): if song in self.songs: self.songs.remove(song) def get_songs(self) -> list: return list(self.songs) def total_duration(self) -> int: return sum(song.duration for song in self.songs) # Example s1 = Song(\\"Title1\\", \\"Artist1\\", 300) s2 = Song(\\"Title2\\", \\"Artist2\\", 200) s3 = Song(\\"Title1\\", \\"Artist1\\", 300) playlist = Playlist() playlist.add_song(s1) playlist.add_song(s2) playlist.add_song(s3) # This should not add the song again print(len(playlist.get_songs())) # Output: 2 playlist.remove_song(s1) print(len(playlist.get_songs())) # Output: 1 print(playlist.total_duration()) # Output: 200"},{"question":"# Pattern Matcher As a junior software developer for a company developing text analysis tools, you are tasked to create a tool that identifies all substrings in a given string that match a specific pattern. Additionally, you need to ensure the solution handles edge cases and performs efficiently. # Task: Implement a function `pattern_matcher(text: str, pattern: str) -> List[Tuple[int, int]]` that: * Takes a string (`text`) and a pattern string (`pattern`), where both can contain alphabetic characters only. * Returns a list of tuples, where each tuple contains the start and end indices (inclusive) of substrings in `text` that match the `pattern`. * Ensure that overlapping matches are allowed. # Input: * `text`: A string of lowercase alphabetic characters (1 <= len(text) <= 10^5) * `pattern`: A string of lowercase alphabetic characters (1 <= len(pattern) <= 100) # Output: * A list of tuples `(start_idx, end_idx)` indicating the start and end indices of each match found in the text. # Example: ```python >>> pattern_matcher(\'abracadabra\', \'abr\') [(0, 2), (7, 9)] >>> pattern_matcher(\'aaaaaa\', \'aaa\') [(0, 2), (1, 3), (2, 4), (3, 5)] ``` # Constraints: * Ensure your solution handles cases where the `pattern` does not exist in `text`. * Take into account patterns that overlap within the `text`. * Your solution must be efficient enough to handle large input sizes. # Performance Requirement: * Your solution should aim for linear time complexity relative to the size of `text`. This question ensures you handle string processing efficiently and consider edge cases in pattern matching—key skills for developing robust text processing algorithms.","solution":"from typing import List, Tuple def pattern_matcher(text: str, pattern: str) -> List[Tuple[int, int]]: Finds all substrings in `text` that match `pattern`. Returns a list of tuples with start and end indices (inclusive) of the matches. matches = [] n, m = len(text), len(pattern) for i in range(n - m + 1): if text[i:i + m] == pattern: matches.append((i, i + m - 1)) return matches"},{"question":"# Coding Question Problem Statement Given an array of integers, you are tasked with implementing a function `longestSubarrayWithSumK(arr: List[int], k: int) -> int` that finds the length of the longest continuous subarray with a sum equal to a given value `k`. # Input and Output Formats * **Input Format**: * `arr`: A list of integers. * `k`: An integer. * **Output Format**: * Return a single integer representing the length of the longest subarray that sums to `k`. # Constraints * `1 ≤ len(arr) ≤ 10^5` * `-10^9 ≤ arr[i] ≤ 10^9` for all valid `i` * `-10^9 ≤ k ≤ 10^9` # Performance Requirements * Your solution should be efficient, ideally with a time complexity better than (O(n^2)). # Example Input ```python arr = [1, -1, 5, -2, 3] k = 3 ``` Output ```python 4 ``` Explanation The subarray `[1, -1, 5, -2]` sums to `3` and has the length `4`. Input ```python arr = [-2, -1, 2, 1] k = 1 ``` Output ```python 2 ``` Explanation The subarray `[-1, 2]` sums to `1` and has the length `2`. # Hints * Consider using a hash map (dictionary) to track the sum of elements from the beginning of the array to the current position. Here\'s the function signature: ```python from typing import List def longestSubarrayWithSumK(arr: List[int], k: int) -> int: pass ```","solution":"from typing import List def longestSubarrayWithSumK(arr: List[int], k: int) -> int: sum_map = {} current_sum = 0 max_length = 0 for i in range(len(arr)): # Add the current element to the current_sum current_sum += arr[i] # If current_sum is equal to k, we found a subarray starting from index 0 if current_sum == k: max_length = i + 1 # If (current_sum - k) exists in sum_map, update max_length if we get a larger subarray length if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) # Add current_sum to sum_map if it is not already present if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"# Coding Question You are given a list of strings representing numerical values where each string may contain commas as thousand separators. Your task is to write a function that sorts these numerical values in descending order based on their actual numeric value. # Function Signature ```python def sort_numerical_strings(numbers: list) -> list: ``` # Input - `numbers` (list): A list of strings where each string represents a numerical value (positive integers only) and may contain commas as thousand separators. # Output - A list of strings sorted in descending order based on their numeric value. # Constraints - The input list is guaranteed to have at least one element. - Each element in the list is a string representing a positive integer. - Commas are used as thousand separators and should not affect the numerical comparison. # Performance Requirements - The solution should efficiently handle sorting even when the list contains thousands of elements. - Ensure that the conversion and sorting process is optimized for performance. # Examples ```python # Example 1 numbers = [\\"1,000\\", \\"20\\", \\"300\\", \\"4,000\\", \\"50\\"] assert sort_numerical_strings(numbers) == [\\"4,000\\", \\"1,000\\", \\"300\\", \\"50\\", \\"20\\"] # Example 2 numbers = [\\"10,000\\", \\"9,999\\", \\"100,000\\", \\"1,000,000\\"] assert sort_numerical_strings(numbers) == [\\"1,000,000\\", \\"100,000\\", \\"10,000\\", \\"9,999\\"] ``` # Notes - Make sure to handle the integer comparison correctly without being affected by the commas. - The returned list should preserve the original comma-separated format for each string.","solution":"def sort_numerical_strings(numbers: list) -> list: Sorts a list of numerical strings with commas as thousand separators in descending order based on their actual numeric value. Args: numbers (list): A list of strings representing numerical values. Returns: list: The list sorted in descending order based on numeric value. # Convert each string to an integer by removing commas numeric_values = [int(num.replace(\',\', \'\')) for num in numbers] # Pair the original string with its numeric value paired_values = list(zip(numbers, numeric_values)) # Sort based on numeric value in descending order paired_values.sort(key=lambda x: x[1], reverse=True) # Extract and return the original strings in sorted order sorted_numbers = [pair[0] for pair in paired_values] return sorted_numbers"},{"question":"# Implementing an Efficient Matrix Transposition Algorithm Context Transposing a matrix involves flipping it over its diagonal, turning its rows into columns, and vice versa. This operation is fundamental in various domains such as computer graphics, data analysis, and scientific computing. For this task, you are required to implement an efficient algorithm to transpose a given 2D matrix. Problem Statement Implement the function `transpose_matrix` which takes a single input - a 2D list `matrix` representing an `m x n` matrix - and returns its transpose. The transposed matrix should have the original matrix\'s rows become columns and the columns become rows. Your implementation should work efficiently for large matrices and handle edge cases appropriately. Requirements 1. **Input and Output Formats**: - Input for `transpose_matrix`: A 2D list `matrix` where each sub-list represents a row of the original matrix. - Output for `transpose_matrix`: A 2D list representing the transposed matrix. - If `matrix` is empty, return an empty list. - The `matrix` can have different number of rows and columns. 2. **Constraints**: - The number of rows `m` and columns `n` of the matrix: 0 ≤ m, n ≤ 1000. - Matrix elements are integers. 3. **Performance**: - Ensure the implementation efficiently handles the transpose operation within the given constraints. Example ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Implement this function pass # Example usage: input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transposed_matrix = transpose_matrix(input_matrix) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] input_matrix_2 = [ [1, 2], [3, 4], [5, 6] ] transposed_matrix_2 = transpose_matrix(input_matrix_2) # Expected output: # [ # [1, 3, 5], # [2, 4, 6] # ] ``` Notes - Consider the edge cases such as an empty matrix or matrices with a single row or a single column. - Optimize the solution to handle large matrices efficiently for both time and space complexity.","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. :param matrix: List[List[int]], a 2D list representing the input matrix :return: List[List[int]], a 2D list representing the transposed matrix if not matrix: return [] # Retrieve the number of rows and columns of the input matrix rows, cols = len(matrix), len(matrix[0]) # Create the transposed matrix with dimensions swapped transposed = [[0] * rows for _ in range(cols)] # Populate the transposed matrix for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"**Compute Fibonacci Sequence Using Dynamic Programming** You are tasked with implementing a function to compute the Fibonacci sequence using dynamic programming. This sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. # Function Signature ```python def fibonacci(n: int) -> int: Computes the nth Fibonacci number using dynamic programming. :param n: A non-negative integer representing the position in the Fibonacci sequence. :return: The nth Fibonacci number. ``` # Requirements 1. Implement the `fibonacci` function based on the principles of dynamic programming to optimize the computation. 2. The function should take a non-negative integer `n` and return the nth Fibonacci number. 3. Ensure the algorithm utilizes memoization to avoid redundant calculations. 4. Handle edge cases appropriately (e.g., when `n` is 0 or 1). 5. The input will always be a non-negative integer. # Examples ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025 ``` # Constraints * Do not use recursion without memoization due to potential inefficiency with large input values. * The function should have a time complexity of O(n) and auxiliary space complexity of O(n) due to the use of memoization. **Scenario/Context**: You are tasked with developing a module that computes Fibonacci numbers for a numerical analysis tool. Efficiency is crucial, especially for larger values of `n`, so you opt for a dynamic programming approach to minimize redundant calculations and improve performance.","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number using dynamic programming. :param n: A non-negative integer representing the position in the Fibonacci sequence. :return: The nth Fibonacci number. if n == 0: return 0 if n == 1: return 1 fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"# Context You are tasked with creating a data structure that models a book collection for a small library. Each book has attributes such as title, author, publication year, and genres. The library needs a function to search for books based on specific criteria: by title, author, or genre. # Task Implement a class `Library` with the following functionality: 1. **Add Book**: Add a new book to the collection. 2. **Search by Title**: Search for books by title (exact match). 3. **Search by Author**: Search for books by author (partial or exact match). 4. **Search by Genre**: Search for books by genre (exact match). # Class Definition ```python class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, publication_year: int, genres: list[str]): Add a new book to the library. Parameters: - title: The title of the book. - author: The author of the book. - publication_year: The year the book was published. - genres: A list of genres the book belongs to. self.books.append({\\"title\\": title, \\"author\\": author, \\"publication_year\\": publication_year, \\"genres\\": genres}) def search_by_title(self, title: str) -> list[dict]: Search for books by exact title match. Parameters: - title: The title of the book to search for. Returns: - A list of dictionaries representing books that match the title. return [book for book in self.books if book[\\"title\\"].lower() == title.lower()] def search_by_author(self, author: str) -> list[dict]: Search for books by partial or exact author match. Parameters: - author: The author to search for. Returns: - A list of dictionaries representing books that have the author name partially or exactly matched. return [book for book in self.books if author.lower() in book[\\"author\\"].lower()] def search_by_genre(self, genre: str) -> list[dict]: Search for books by exact genre match. Parameters: - genre: The genre to search for. Returns: - A list of dictionaries representing books that belong to the provided genre. return [book for book in self.books if genre.lower() in [g.lower() for g in book[\\"genres\\"]]] ``` # Example Usage ```python library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, [\\"Novel\\", \\"Historical\\"]) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960, [\\"Novel\\", \\"Southern Gothic\\", \\"Fiction\\"]) library.add_book(\\"1984\\", \\"George Orwell\\", 1949, [\\"Dystopian\\", \\"Science Fiction\\"]) # Search by title print(library.search_by_title(\\"1984\\")) # Output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'publication_year\': 1949, \'genres\': [\'Dystopian\', \'Science Fiction\']}] # Search by author print(library.search_by_author(\\"George Orwell\\")) # Output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'publication_year\': 1949, \'genres\': [\'Dystopian\', \'Science Fiction\']}] # Search by genre print(library.search_by_genre(\\"Novel\\")) # Output: [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'publication_year\': 1925, \'genres\': [\'Novel\', \'Historical\']}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'publication_year\': 1960, \'genres\': [\'Novel\', \'Southern Gothic\', \'Fiction\']}] ``` # Input Constraints - A book title, author, and genres are non-empty strings. - Publication year is a valid integer. - Genres is a non-empty list of strings. # Performance Requirements - The implementation should handle a library of up to 10,000 books efficiently.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, publication_year: int, genres: list[str]): Add a new book to the library. Parameters: - title: The title of the book. - author: The author of the book. - publication_year: The year the book was published. - genres: A list of genres the book belongs to. self.books.append({\\"title\\": title, \\"author\\": author, \\"publication_year\\": publication_year, \\"genres\\": genres}) def search_by_title(self, title: str) -> list[dict]: Search for books by exact title match. Parameters: - title: The title of the book to search for. Returns: - A list of dictionaries representing books that match the title. return [book for book in self.books if book[\\"title\\"].lower() == title.lower()] def search_by_author(self, author: str) -> list[dict]: Search for books by partial or exact author match. Parameters: - author: The author to search for. Returns: - A list of dictionaries representing books that have the author name partially or exactly matched. return [book for book in self.books if author.lower() in book[\\"author\\"].lower()] def search_by_genre(self, genre: str) -> list[dict]: Search for books by exact genre match. Parameters: - genre: The genre to search for. Returns: - A list of dictionaries representing books that belong to the provided genre. return [book for book in self.books if genre.lower() in [g.lower() for g in book[\\"genres\\"]]]"},{"question":"# Question: Matrix Transposition In this task, you will implement a function that computes the transpose of a given matrix. Transposing a matrix involves flipping it over its diagonal, switching the row and column indices of each element. **Function Signature**: ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` **Parameters**: - `matrix` (list[list[int]]): A 2D list representing an M x N matrix with integer elements. **Returns**: - A 2D list representing the transpose of the input matrix. **Examples**: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[7]]) [[7]] >>> transpose_matrix([]) [] ``` **Constraints**: - You can assume that `matrix` will have at most 1000 rows and 1000 columns. - The input matrix may be empty. Your task is to write a function that computes the transpose of a given 2D list efficiently. Consider edge cases such as an empty matrix and non-square matrices.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: if not matrix: return [] return [list(row) for row in zip(*matrix)]"},{"question":"# Question Description You are developing an e-commerce platform where each product has a distinct price. Implement a function to suggest the top K most expensive products. The function should return the names of the top K products sorted by price in descending order. Function Signature ```python def top_k_expensive_products(products: dict, k: int) -> list: ... ``` Input - `products`: A dictionary where the keys are product names (strings) and the values are their respective prices (integers). - `k`: An integer representing the number of top-priced products to retrieve. Output - `top_k_products`: A list of product names that correspond to the top K highest priced products, sorted in descending order of their prices. Constraints - The number of products will be at most 10^3. - Each product will have a distinct price. - 1 ≤ k ≤ number of products Example ```python products = { \\"laptop\\": 1200, \\"smartphone\\": 800, \\"headphones\\": 200, \\"monitor\\": 300, \\"keyboard\\": 100, } k = 3 top_k_products = top_k_expensive_products(products, k) print(top_k_products) # Expected Output: [\'laptop\', \'smartphone\', \'monitor\'] ``` Performance Requirements The function should handle the edge cases effectively and be efficiently implemented to handle the maximum constraints.","solution":"def top_k_expensive_products(products: dict, k: int) -> list: Returns the names of the top K most expensive products sorted by price in descending order. # Sort the items in the dictionary by price in descending order sorted_products = sorted(products.items(), key=lambda item: item[1], reverse=True) # Extract the first K product names top_k_products = [product[0] for product in sorted_products[:k]] return top_k_products"},{"question":"# Coding Assessment Question **Context:** You are developing a text-based data analysis tool that needs to extract and summarize trends from a collection of time-stamped logs. Your task is to create a function that parses log entries and generates a summary of event counts per hour. **Function Specification:** - **Function Name**: `summarize_logs` - **Input**: - `logs` (List[str]): A list of log entries, each in the format `\'YYYY-MM-DD HH:MM:SS <event>\'`, where `<event>` is an alphanumeric string describing the event. - **Output**: - A dictionary where the keys are strings representing the hour (`\'YYYY-MM-DD HH\'`), and the values are dictionaries mapping each distinct `<event>` to the number of occurrences during that hour. **Input Constraints**: - Log entries are sorted in chronological order. - Log entries strictly follow the given format. **Performance Requirements**: - Must efficiently handle large lists of log entries. - Should use optimal data structures to ensure quick access and updates. **Edge Cases to Consider**: - Logs with no entries. - Logs spanning multiple days, months, or years. - Entries with multiple events occurring at the same hour. **Examples**: ```python >>> logs = [ ... \'2023-01-01 12:00:00 login\', ... \'2023-01-01 12:15:00 logout\', ... \'2023-01-01 13:00:00 login\', ... \'2023-01-01 13:05:00 login\', ... \'2023-01-01 14:00:00 purchase\', ... \'2023-01-01 14:30:00 logout\' ... ] >>> summarize_logs(logs) { \'2023-01-01 12\': {\'login\': 1, \'logout\': 1}, \'2023-01-01 13\': {\'login\': 2}, \'2023-01-01 14\': {\'purchase\': 1, \'logout\': 1} } ``` **Implementation Notes**: - Utilize appropriate data structures like dictionaries to ensure efficient aggregation. - Focus on clear and concise code that correctly handles the formatting and counting of events per hour. - Ensure your solution is scalable for large input sizes while maintaining readability and simplicity.","solution":"def summarize_logs(logs): Summarizes log entries and generates a summary of event counts per hour. Args: logs (List[str]): A list of log entries, each in the format \'YYYY-MM-DD HH:MM:SS <event>\' Returns: dict: A dictionary where the keys are strings representing the hour (\'YYYY-MM-DD HH\'), and the values are dictionaries mapping each distinct <event> to the number of occurrences during that hour. from collections import defaultdict summary = defaultdict(lambda: defaultdict(int)) for log in logs: timestamp, event = log.rsplit(\' \', 1) hour = timestamp[:13] # Extract \'YYYY-MM-DD HH\' portion summary[hour][event] += 1 # Convert nested defaultdict to regular dict for the final output return {hour: dict(events) for hour, events in summary.items()}"},{"question":"# Question: Implementing a Custom Lowercase Function Context: In many programming languages, there are built-in functions to convert strings into different letter cases. For instance, Python has the `lower()` method which converts all the uppercase characters in a string to lowercase. However, in certain cases, you may need to implement a similar functionality from scratch without using the built-in methods. Problem Statement: Write a function `custom_lower(s: str) -> str` that takes a string and converts all the uppercase letters to their lowercase equivalents without using any built-in `lower()` or similar functions. Input: - A single string `s` containing the text to be converted. - The string may contain lowercase and uppercase letters, digits, spaces, and special characters. Output: - A string with all uppercase letters converted to lowercase while all other characters remain unchanged. Constraints: - The function should handle an empty string gracefully by returning an empty string. - The function should not use any built-in string conversion functions like `lower()`, `upper()`, `swapcase()`, etc. Examples: ```python >>> custom_lower(\\"Hello, World!\\") \\"hello, world!\\" >>> custom_lower(\\"PyThOn ProGraMminG!\\") \\"python programming!\\" >>> custom_lower(\\"123 ABC def\\") \\"123 abc def\\" >>> custom_lower(\\"\\") \\"\\" >>> custom_lower(\\"ALL CAPS\\") \\"all caps\\" >>> custom_lower(\\"no caps\\") \\"no caps\\" ``` Notes: - The ASCII value of \'A\' is 65 and \'a\' is 97. You can use this difference to convert uppercase characters to lowercase. - Remember to handle both Latin uppercase letters (A-Z) properly without affecting other characters in the string.","solution":"def custom_lower(s: str) -> str: Converts uppercase letters in the string to lowercase without using built-in lower() function. result = [] for char in s: if \'A\' <= char <= \'Z\': result.append(chr(ord(char) + 32)) else: result.append(char) return \'\'.join(result)"},{"question":"# Question: Implement a function `group_palindrome_anagrams` that groups a list of strings into subsets where each subset contains strings that are anagrams of each other and, when rearranged, can form a palindrome. Two strings are considered anagrams if one string can be rearranged to form the other. A string can be rearranged to form a palindrome if at most one character has an odd frequency count. Your function should: - Group the strings into subsets where each subset contains strings that are anagrams of each other and each string can be rearranged to form a palindrome. - Return a list of lists, where each sublist contains the grouped anagrams. # Input: - A list of strings `words` consisting of lowercase letters only. # Output: - A list of lists of strings, where each sublist contains strings that can be rearranged into a palindrome and are anagrams of each other. # Constraints: - Length of input list `words` can be up to 10^3. - Length of each string in `words` can be up to 10^2. # Function Signature: ```python def group_palindrome_anagrams(words: list) -> list: pass ``` # Example: ```python >>> words = [\'civic\', \'ivicc\', \'aabb\', \'bbaa\', \'abc\', \'cba\', \'bca\'] >>> group_palindrome_anagrams(words) [[\'civic\', \'ivicc\'], [\'aabb\', \'bbaa\']] >>> words = [\'aaa\', \'aba\', \'baa\', \'aab\', \'xyz\'] >>> group_palindrome_anagrams(words) [[\'aaa\'], [\'aba\', \'baa\', \'aab\']] ``` **Note**: Ensure your function runs efficiently, considering the input constraints.","solution":"from collections import Counter def can_form_palindrome(s): Determine if the string s can be rearranged to form a palindrome. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def group_palindrome_anagrams(words): Group the strings into subsets where each subset contains strings that are anagrams of each other and each string can be rearranged to form a palindrome. Args: words (list): List of strings consisting of lowercase letters only. Returns: list: List of lists, where each sublist contains the grouped anagrams. anagram_groups = {} for word in words: sorted_word = \'\'.join(sorted(word)) if sorted_word in anagram_groups: anagram_groups[sorted_word].append(word) else: anagram_groups[sorted_word] = [word] result = [] for group in anagram_groups.values(): if can_form_palindrome(group[0]): result.append(group) return result"},{"question":"# Coding Question Context Your company is developing an e-commerce platform and part of the requirement is to generate invoices based on the products purchased. Each product has a price and a quantity. The task is to generate the total price for each product and sum up all the total prices to generate the final invoice amount. Additionally, the platform requires a breakdown of the taxes applied to each product based on its category. Task Write a function `generate_invoice(products: List[Dict], tax_rates: Dict[str, float]) -> Dict[str, float]` where `products` is a list of dictionaries. Each dictionary contains details of a product, and `tax_rates` is a dictionary containing the tax rates for each category of products. # Function Signature ```python from typing import List, Dict def generate_invoice(products: List[Dict], tax_rates: Dict[str, float]) -> Dict[str, float]: pass ``` # Input - `products`: A list of dictionaries with the following keys: - `name`: A string representing the name of the product. - `category`: A string representing the category of the product. - `price`: A float representing the price of a single unit of the product. - `quantity`: An integer representing the quantity of the product purchased. - `tax_rates`: A dictionary where keys are the category names, and values are the respective tax rates (as floats) to be applied on the price of products in those categories. The tax rate is a percentage (e.g., 10 for 10%). # Output - A dictionary with the following keys: - `total`: A float representing the total invoice amount after taxes. - `breakdown`: A dictionary where each key is a product `name`, and its value is a dictionary with keys `subtotal` (the total price before tax) and `total_with_tax` (the total price after tax). # Constraints - 1 ≤ len(products) ≤ 1000 - Each product\'s `price` and `quantity` will be positive. - The `tax_rates` dictionary will have a valid tax rate for each product category appearing in `products`. # Example ```python products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"electronics\\", \\"price\\": 1200.00, \\"quantity\\": 2}, {\\"name\\": \\"Book\\", \\"category\\": \\"books\\", \\"price\\": 30.00, \\"quantity\\": 4}, {\\"name\\": \\"Headphones\\", \\"category\\": \\"electronics\\", \\"price\\": 200.00, \\"quantity\\": 3} ] tax_rates = { \\"electronics\\": 15.0, \\"books\\": 5.0 } output = generate_invoice(products, tax_rates) print(output) # Output should be something like: # { # \\"total\\": 3326.50, # \\"breakdown\\": { # \\"Laptop\\": {\\"subtotal\\": 2400.00, \\"total_with_tax\\": 2760.00}, # \\"Book\\": {\\"subtotal\\": 120.00, \\"total_with_tax\\": 126.00}, # \\"Headphones\\": {\\"subtotal\\": 600.00, \\"total_with_tax\\": 690.00} # } # } ``` The function `generate_invoice` should compute and return the total invoice amount, along with a detailed breakdown of the subtotal and total price after tax for each product.","solution":"from typing import List, Dict def generate_invoice(products: List[Dict], tax_rates: Dict[str, float]) -> Dict[str, float]: Generates an invoice with total amount after taxes and a breakdown of costs. Args: products: List[Dict] - A list of products where each product is a Dict with keys: - name (str) - category (str) - price (float) - quantity (int) tax_rates: Dict[str, float] - A dictionary where keys are the category names, and values are the respective tax rates (in percentage). Returns: Dict[str, float]: A dictionary with total invoice amount and a breakdown of costs per product. invoice = { \\"total\\": 0.0, \\"breakdown\\": {} } for product in products: name = product[\'name\'] category = product[\'category\'] price = product[\'price\'] quantity = product[\'quantity\'] subtotal = price * quantity tax_rate = tax_rates[category] / 100 total_with_tax = subtotal + (subtotal * tax_rate) invoice[\\"breakdown\\"][name] = { \\"subtotal\\": round(subtotal, 2), \\"total_with_tax\\": round(total_with_tax, 2) } invoice[\\"total\\"] += total_with_tax invoice[\\"total\\"] = round(invoice[\\"total\\"], 2) return invoice"},{"question":"# Temperature Conversion Calculator: Celsius and Fahrenheit Problem Statement: Temperature conversion is a common requirement in various scientific and daily applications. The task is to create a Python utility that converts temperatures between Celsius and Fahrenheit. You are required to implement two functions, `celsius_to_fahrenheit` and `fahrenheit_to_celsius` to perform these conversions according to the following specifications: 1. `celsius_to_fahrenheit(celsius: float) -> float`: This function should take the temperature in Celsius (°C) as input and return the equivalent temperature in Fahrenheit (°F). - Formula: F = (C × 9/5) + 32 2. `fahrenheit_to_celsius(fahrenheit: float) -> float`: This function should take the temperature in Fahrenheit (°F) as input and return the equivalent temperature in Celsius (°C). - Formula: C = (F − 32) × 5/9 Input and Output: 1. `celsius_to_fahrenheit(celsius: float) -> float` - **Input**: `celsius` (a float, representing the temperature in Celsius) - **Output**: A float representing the temperature in Fahrenheit equivalent to the given Celsius temperature. 2. `fahrenheit_to_celsius(fahrenheit: float) -> float` - **Input**: `fahrenheit` (a float, representing the temperature in Fahrenheit) - **Output**: A float representing the temperature in Celsius equivalent to the given Fahrenheit temperature. Constraints - The input values can be in the range of typical -200°C to 1000°C for Celsius inputs and -328°F to 1832°F for Fahrenheit inputs, but the functions should handle any floating point value within a reasonable range. Examples: ```python # Example usage: print(celsius_to_fahrenheit(0)) # Expected output: 32.0 print(celsius_to_fahrenheit(100)) # Expected output: 212.0 print(celsius_to_fahrenheit(-40)) # Expected output: -40.0 print(fahrenheit_to_celsius(32)) # Expected output: 0.0 print(fahrenheit_to_celsius(212)) # Expected output: 100.0 print(fahrenheit_to_celsius(-40)) # Expected output: -40.0 # Extreme value examples: print(celsius_to_fahrenheit(500)) # Expected output: 932.0 print(fahrenheit_to_celsius(932)) # Expected output: 500.0 ``` ```python # Implementation of functions def celsius_to_fahrenheit(celsius: float) -> float: return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: return (fahrenheit - 32) * 5/9 ```","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Converts the given temperature from Celsius to Fahrenheit. Formula: F = (C × 9/5) + 32 return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts the given temperature from Fahrenheit to Celsius. Formula: C = (F − 32) × 5/9 return (fahrenheit - 32) * 5/9"},{"question":"Question: You are tasked with implementing a function to reverse the words in a given sentence while maintaining the order of the characters within each word. This exercise is designed to evaluate your ability to manipulate strings and handle spaces appropriately. # Requirements: 1. **Function**: `def reverse_words(sentence: str) -> str:` 2. **Input**: * A string `sentence`, e.g., `\\"The quick brown fox jumps over the lazy dog\\"`. 3. **Output**: * A string where the order of words is reversed, but the characters within each word remain in the same order. 4. **Constraints**: * The input string can be empty or contain up to 10,000 characters. * Words are separated by single spaces. * No leading or trailing spaces. # Example: Input: `\\"The quick brown fox jumps over the lazy dog\\"` Output: `\\"dog lazy the over jumps fox brown quick The\\"` # Scenario: You have been given this problem by a publishing company that needs to generate mirrored versions of sentences for its creative department. Instead of reversing each character in the sentence, they specifically need the order of the words reversed while retaining the integrity of individual words. # Edge Cases to Consider: * The algorithm should handle empty strings gracefully by returning an empty string. * It should accurately reverse sentences with a single word by returning that word unchanged. * Consider sentences with multiple consecutive spaces between words, maintaining just one space between words in the output. # Additional Tests: Make sure your implementation passes the expected outputs for the following scenarios: 1. Input: `\\"Hello World\\"` Output: `\\"World Hello\\"` 2. Input: `\\"Python is fun\\"` Output: `\\"fun is Python\\"` 3. Input: `\\" A quick brown fox \\"` Output: `\\"fox brown quick A\\"` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of the words in a given sentence while maintaining the order of characters within each word. Parameters: sentence (str): The input sentence. Returns: str: The sentence with words reversed. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words back into a string with a space separator result = \' \'.join(reversed_words) return result"},{"question":"# Coding Assessment Question Context In a series of computer screens connected together, each screen displays a sequence of alphabets where each screen\'s sequence must be incrementally longer than the previous one. This problem involves arranging the alphabets in such a way that the sequences satisfy the required conditions. Problem Statement Given a single integer `n` representing the number of connected computer screens, you need to generate the sequences of alphabets for each screen such that: - The sequence for the `i-th` screen (where `i` starts from 1) is exactly `i` characters long. - Each character in any sequence can only be a lowercase English alphabet (`\'a\'` to `\'z\'`). - All characters in the sequences must be sorted in lexicographical order. Create a function `generate_screen_sequence(n: int) -> List[str]` that generates these sequences for `n` screens and returns them as a list of strings. # Input: - An integer `n` representing the number of screens (1 ≤ n ≤ 26). # Output: - Return a list of `n` strings, where the `i-th` string has exactly `i` characters, sorted in lexicographical order. # Example: ```python generate_screen_sequence(3) # Expected output: [\\"a\\", \\"ab\\", \\"abc\\"] ``` # Constraints: - Ensure that your solution correctly generates the sequences within the given constraints. - Utilize appropriate programming constructs to achieve the desired output. Notes: - The function should handle and return the results in an efficient manner for the given constraints. - Consider edge cases where `n` can be the smallest or the largest possible value.","solution":"def generate_screen_sequence(n: int) -> list[str]: Generate the sequences of alphabets for each screen such that: - The sequence for the `i-th` screen (where `i` starts from 1) is exactly `i` characters long. - Each character in any sequence can only be a lowercase English alphabet (`\'a\'` to `\'z\'`). - All characters in the sequences must be sorted in lexicographical order. :param n: Number of screens :return: List of strings representing the sequences for each screen alphabet = \'abcdefghijklmnopqrstuvwxyz\' return [alphabet[:i] for i in range(1, n+1)]"},{"question":"# Objective Create a function that processes a list of transactions to categorize spending into predefined categories, handling various edge cases such as invalid input data and categorization rules exceptions. Ensure the solution is robust and can handle diverse transaction data effectively. # Task Write a Python function `categorize_transactions(transactions: list, categories: dict) -> dict` that categorizes each transaction based on the given category rules. The function should handle the following: - Ensure each transaction is valid (contains required fields). - Implement rules to categorize transactions effectively. - Handle transactions that do not match any category by assigning them to an \\"Uncategorized\\" group. # Input - `transactions` (list): A list of transaction dictionaries. Each transaction contains: - `description` (string): The description of the transaction. - `amount` (float): The amount of the transaction. - `categories` (dict): A dictionary where keys are category names and values are lists of keywords. A transaction belongs to a category if its description contains any of the keywords. # Output - A dictionary where keys are category names and values are lists of transactions that belong to those categories. # Constraints - Transactions without a matching category should be placed under the \\"Uncategorized\\" category. - Ensure the function performs efficiently even with a large number of transactions. - Each transaction description and amount should be validated, raising an appropriate exception for invalid data. # Example Usage ```python transactions = [ {\\"description\\": \\"Grocery store purchase\\", \\"amount\\": 125.50}, {\\"description\\": \\"Online subscription\\", \\"amount\\": 9.99}, {\\"description\\": \\"Gym membership\\", \\"amount\\": 45.00}, {\\"description\\": \\"Bookstore purchase\\", \\"amount\\": 23.99}, ] categories = { \\"Groceries\\": [\\"grocery\\", \\"supermarket\\"], \\"Entertainment\\": [\\"subscription\\", \\"movie\\", \\"concert\\"], \\"Health\\": [\\"gym\\", \\"doctor\\", \\"pharmacy\\"] } try: categorized_transactions = categorize_transactions(transactions, categories) for category, txns in categorized_transactions.items(): print(f\\"{category}:\\") for txn in txns: print(txn) except Exception as e: print(f\\"Error: {e}\\") ``` # Notes - Ensure descriptions are compared case-insensitively when matching against keywords. - Transactions must contain both `description` and `amount` fields, otherwise, an appropriate exception should be raised. - The function should return an empty dictionary if no valid transactions are provided.","solution":"def categorize_transactions(transactions, categories): Categorizes transactions based on given categories. Args: transactions (list): A list of transaction dictionaries. categories (dict): A dictionary where keys are category names and values are lists of keywords. Returns: dict: A dictionary with category names as keys and lists of categorized transactions as values. # Initializing categorized transactions dictionary categorized_transactions = {category: [] for category in categories} categorized_transactions[\\"Uncategorized\\"] = [] for transaction in transactions: if not isinstance(transaction, dict) or \\"description\\" not in transaction or \\"amount\\" not in transaction: raise ValueError(\\"Each transaction must be a dictionary with \'description\' and \'amount\' fields.\\") description = transaction.get(\\"description\\", \\"\\").lower() matched_category = None for category, keywords in categories.items(): if any(keyword.lower() in description for keyword in keywords): matched_category = category break if matched_category: categorized_transactions[matched_category].append(transaction) else: categorized_transactions[\\"Uncategorized\\"].append(transaction) return categorized_transactions"},{"question":"# Question You are tasked with writing a program to manage a list of tasks and their priority levels. Each task consists of a description and a priority level (an integer). You will write three functions: `add_task`, `remove_task`, and `get_next_task`. The tasks should be stored in a way that always allows you to quickly retrieve the highest priority task. Priorities are handled such that a lower integer value indicates a higher priority (e.g., a task with a priority of 1 is more important than a task with a priority of 3). # Requirements 1. The `add_task` function should take a task description and a priority level and add it to the list of tasks. 2. The `remove_task` function should take a task description and remove it from the list of tasks if it exists. 3. The `get_next_task` function should return the task description with the highest priority and remove it from the list. If there are multiple tasks with the same priority, return the one that was added first. 4. All functions should handle an empty task list gracefully. # Input and Output Format - `add_task(description: str, priority: int) -> None` - `remove_task(description: str) -> bool` returns `True` if the task was successfully removed, `False` otherwise. - `get_next_task() -> str` returns the task description with the highest priority or an empty string if no tasks are available. # Constraints * Task descriptions are unique. * Priority levels are integers and can be positive or negative. * The number of tasks will not exceed 10,000. # Example ```python add_task(\\"Write report\\", 2) add_task(\\"Pay bills\\", 1) add_task(\\"Attend meeting\\", 1) # \\"Pay bills\\" is the highest priority task assert get_next_task() == \\"Pay bills\\" # \\"Attend meeting\\" is the next highest priority task assert get_next_task() == \\"Attend meeting\\" # Trying to remove a non-existent task should return False assert not remove_task(\\"Not in list\\") # \\"Write report\\" should be the next highest priority assert get_next_task() == \\"Write report\\" # Since there are no tasks left, it should return an empty string assert get_next_task() == \'\' ``` # Solution Template ```python from collections import deque import heapq class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, description: str, priority: int) -> None: if description in self.tasks: raise ValueError(\\"Task already exists\\") task = (priority, self.counter, description) self.counter += 1 self.tasks[description] = task heapq.heappush(self.task_queue, task) def remove_task(self, description: str) -> bool: if description not in self.tasks: return False task = self.tasks.pop(description) # mark task as invalid self.tasks[description] = (float(\'inf\'), float(\'inf\'), \'\') return True def get_next_task(self) -> str: while self.task_queue: priority, _, description = heapq.heappop(self.task_queue) if self.tasks.pop(description, None) and description: return description return \'\' # Create an instance of TaskManager task_manager = TaskManager() # Use the defined task manager functions as per the example task_manager.add_task(\\"Write report\\", 2) task_manager.add_task(\\"Pay bills\\", 1) task_manager.add_task(\\"Attend meeting\\", 1) assert task_manager.get_next_task() == \\"Pay bills\\" assert task_manager.get_next_task() == \\"Attend meeting\\" assert not task_manager.remove_task(\\"Not in list\\") assert task_manager.get_next_task() == \\"Write report\\" assert task_manager.get_next_task() == \'\' ``` # Additional Information - Use a heap to maintain the task priorities efficiently. - Ensure that the counter is used to manage the order of tasks with the same priority, making the operations efficient and straightforward. - Handle edge cases such as adding or removing tasks that don\'t exist gracefully.","solution":"from heapq import heappush, heappop class TaskManager: def __init__(self): self.tasks = {} self.task_queue = [] self.counter = 0 def add_task(self, description: str, priority: int) -> None: if description in self.tasks: raise ValueError(\\"Task already exists\\") task = (priority, self.counter, description) self.counter += 1 self.tasks[description] = task heappush(self.task_queue, task) def remove_task(self, description: str) -> bool: if description not in self.tasks: return False task = self.tasks.pop(description) # Mark task as invalid by using a sentinel value removed_task = (float(\'inf\'), float(\'inf\'), \'\') heappush(self.task_queue, removed_task) return True def get_next_task(self) -> str: while self.task_queue: priority, _, description = heappop(self.task_queue) if description != \'\' and description in self.tasks: self.tasks.pop(description, None) return description return \'\'"},{"question":"# Question You are tasked with creating a feature that checks if a given sequence of parentheses is balanced. A sequence is considered balanced if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\' and the pairs of parentheses are properly nested. Task Write a function named `is_balanced_parentheses(sequence: str) -> bool` that determines whether a given string sequence of parentheses is balanced. Your function should return `True` if the sequence is balanced, and `False` otherwise. Input - `sequence` (str): A string consisting only of the characters \'(\' and \')\'. Output - (bool): Returns `True` if the sequence is balanced, otherwise returns `False`. Constraints - The length of the sequence will be between 1 and 1,000,000. Example ```python assert is_balanced_parentheses(\\"()\\") == True assert is_balanced_parentheses(\\"(())\\") == True assert is_balanced_parentheses(\\"(()))\\") == False assert is_balanced_parentheses(\\")\\") == False assert is_balanced_parentheses(\\"(()())\\") == True assert is_balanced_parentheses(\\"(()\\") == False ```","solution":"def is_balanced_parentheses(sequence: str) -> bool: Determines whether the given string sequence of parentheses is balanced. Args: sequence (str): A string consisting only of the characters \'(\' and \')\'. Returns: bool: Returns True if the sequence is balanced, otherwise returns False. stack = [] for char in sequence: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"# Coding Assessment Question Scenario A travel agency wants to automate the process of booking train tickets for its customers. The software needs a functionality to check the availability of seats and book tickets accordingly. You are required to write a function that can manage this booking process. Requirements * Write a function `book_tickets(seats: List[int], passengers: int) -> List[int]` that performs the specified booking. * The function takes a list of seat numbers currently available and the number of passengers wanting to book tickets. * Seats are to be booked in a sequential manner from the available seats list. * Validate the inputs to ensure they meet the following constraints: - The available seats must be a list of positive integers. - The number of passengers must be a positive integer. - The number of passengers must not exceed the number of available seats. * You must raise appropriate exceptions if the input values do not meet the constraints. Expected Input and Output * **Input**: - `seats` (List[int]): A list of available seat numbers, where each seat is represented by a positive integer. - `passengers` (int): The number of passengers wanting to book tickets. * **Output**: - (List[int]): A list of seat numbers booked for the passengers. Examples 1. `book_tickets([1, 2, 3, 4, 5], 3)` should return `[1, 2, 3]` 2. `book_tickets([10, 15, 20], 2)` should return `[10, 15]` 3. `book_tickets([10, 15, 20], 4)` should raise an `Exception` with message \\"Not enough seats available\\" 4. `book_tickets([], 1)` should raise an `Exception` with message \\"No available seats to book\\" 5. `book_tickets([10, 15, 20], -1)` should raise an `Exception` with message \\"Number of passengers must be a positive integer\\" Constraints * The list of seats should be ordered in ascending order when input to the function. * The function should handle cases where the number of seats is zero appropriately. ***Write your function below:*** ```python from typing import List def book_tickets(seats: List[int], passengers: int) -> List[int]: Book tickets for the given number of passengers from the list of available seats. :param seats: List of available seat numbers :param passengers: Number of passengers wanting to book tickets :return: List of seat numbers booked :raises Exception: If inputs are not valid or if there are not enough available seats # Validate inputs if not all(isinstance(seat, int) and seat > 0 for seat in seats): raise Exception(\\"Available seats must be a list of positive integers\\") if passengers <= 0 or not isinstance(passengers, int): raise Exception(\\"Number of passengers must be a positive integer\\") if passengers > len(seats): raise Exception(\\"Not enough seats available\\") return seats[:passengers] ```","solution":"from typing import List def book_tickets(seats: List[int], passengers: int) -> List[int]: Book tickets for the given number of passengers from the list of available seats. :param seats: List of available seat numbers :param passengers: Number of passengers wanting to book tickets :return: List of seat numbers booked :raises Exception: If inputs are not valid or if there are not enough available seats # Validate inputs if not isinstance(seats, list) or not all(isinstance(seat, int) and seat > 0 for seat in seats): raise Exception(\\"Available seats must be a list of positive integers\\") if not isinstance(passengers, int) or passengers <= 0: raise Exception(\\"Number of passengers must be a positive integer\\") if passengers > len(seats): raise Exception(\\"Not enough seats available\\") return seats[:passengers]"},{"question":"# Coding Challenge: Task Scheduler Efficiency **Context:** You are given a set of tasks, each characterized by a unique identifier and a required execution time. Your ultimate goal is to determine the minimum units of time required to execute all tasks, given there can be a cooldown period between the execution of two identical tasks. The cooldown period can be represented as an integer `n`, specifying the minimum number of units of time that must pass before the same task can be executed again. During the cooldown period, other tasks may be executed or the system may remain idle if no other tasks are pending. **Task:** Write a function `least_interval` to determine the minimum number of time units required to complete all tasks following the given constraints. Function Signature: ```python def least_interval(tasks: list[str], n: int) -> int: ``` Input: - `tasks`: A list of characters where each character represents a task. - `n`: An integer representing the cooldown period. Output: - Returns an integer representing the minimum time units required to complete all tasks. Constraints: - The length of `tasks` will be at most 10^4. - Each character in `tasks` is an uppercase English letter. - `n` will be between 0 and 100. **Examples:** ```python assert least_interval([\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], 2) == 8 assert least_interval([\'A\', \'A\', \'A\', \'A\', \'B\', \'B\', \'B\', \'C\', \'C\'], 2) == 10 assert least_interval([\'A\', \'B\', \'A\'], 1) == 3 ``` **Hints:** 1. Count the frequency of each task. 2. Determine the maximum frequency task and utilize the most frequent task to calculate the idle slots needed to apply the cooldown period effectively.","solution":"from collections import Counter def least_interval(tasks, n): if not tasks: return 0 task_counts = Counter(tasks) max_task_count = max(task_counts.values()) max_count_tasks = sum(1 for task, count in task_counts.items() if count == max_task_count) # Calculate the parts that are required given the max frequency task part_count = max_task_count - 1 # Calculate the number of empty slots available on which cooldowns will be applied part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length # Decrease the empty slots count for the tasks left after occupying max slots available_tasks = len(tasks) - max_task_count * max_count_tasks idles = max(0, empty_slots - available_tasks) # Total time is the tasks plus any idle time return len(tasks) + idles"},{"question":"# Question Consider a list of words and a target word length. Implement the function `longest_words` that retrieves all the words from the list that have the exact length of the target word length. If there are multiple words with the same length, return the list of such words in the order they appear in the original list. # Input * **words**: A list of strings containing words. * **length**: An integer representing the target word length. # Output * A list of strings containing the words from the input list that have the exact length as specified by `length`. If no such words exist, return an empty list. # Constraints * The input list contains between 1 and 1000 words. * Each word in the list will contain between 1 and 100 characters. * The target length is a non-negative integer. # Example ```python def longest_words(words: list, length: int) -> list: # Your implementation here # Example 1 print(longest_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 5)) # Output: [\\"apple\\"] # Example 2 print(longest_words([\\"elephant\\", \\"dog\\", \\"cat\\", \\"hippopotamus\\"], 3)) # Output: [\\"dog\\", \\"cat\\"] # Example 3 print(longest_words([\\"kiwi\\", \\"mango\\", \\"pineapple\\", \\"grape\\"], 6)) # Output: [\\"mango\\"] # Example 4 print(longest_words([\\"strawberry\\", \\"blueberry\\", \\"raspberry\\"], 10)) # Output: [\\"strawberry\\", \\"blueberry\\"] ``` # Notes * Ensure your solution efficiently handles cases where there are no words with the exact target length. * Maintain the order of words as they appear in the input list while returning the output list. * Consider edge cases such as empty words list or target length being zero.","solution":"def longest_words(words, length): Retrieves all words from the list that have the exact length of the target word length. return [word for word in words if len(word) == length] # Example usage: print(longest_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 5)) # Output: [\\"apple\\"] print(longest_words([\\"elephant\\", \\"dog\\", \\"cat\\", \\"hippopotamus\\"], 3)) # Output: [\\"dog\\", \\"cat\\"] print(longest_words([\\"kiwi\\", \\"mango\\", \\"pineapple\\", \\"grape\\"], 6)) # Output: [\\"mango\\"] print(longest_words([\\"strawberry\\", \\"blueberry\\", \\"raspberry\\"], 10)) # Output: [\\"strawberry\\", \\"blueberry\\"]"},{"question":"# Problem Statement Write a function that calculates the nth term in a special sequence where the terms are generated by summing the cubes of the individual digits of the previous term. The first term of the sequence is always the integer 1. If a term results in a single-digit number, the next term will simply be that number itself. The sequence ends when the same number appears twice in succession. # Input - An integer `n` representing the term in the sequence to be calculated. # Output - The function should return the nth term of the sequence as an integer. # Constraints - 1 ≤ n ≤ 1000 # Special Notes - The sequence is not an ordinary arithmetic or geometric sequence. - Edge cases include the first few terms, which should handle small loops or repeating numbers correctly. # Function Signature ```python def special_sequence(n: int) -> int: pass ``` # Example Your implementation should produce the following outputs: ```python print(special_sequence(1)) print(special_sequence(5)) print(special_sequence(10)) ``` Expected Output: ```python 1 370 371 ``` # Explanation Given the following example for the first few terms: 1. The first term is 1. 2. The next term is calculated by cubing the digits of 1, which still results in 1 (1^3 = 1). 3. Since there is only one digit, the next term will again be 1. 4. Continuing this pattern: - Starting from 1, the second term is 1, - The third term is 1, - And so forth. For other values, the sequence continues uniquely by cubing the digits of the previous term, generating complex patterns of numbers. This function should correctly identify and return the nth term while accounting for any loops or repeated values that occur naturally in the sequence as per the rules described.","solution":"def special_sequence(n: int) -> int: def sum_of_cubes_of_digits(num): return sum(int(digit) ** 3 for digit in str(num)) sequence = [1] while len(sequence) < n: next_term = sum_of_cubes_of_digits(sequence[-1]) sequence.append(next_term) return sequence[n-1]"},{"question":"# Coding Assessment Question Design and implement a function to balance the load across servers in a distributed system. Given the initial load on each server and a series of operations that transfer load between servers, update and balance the system\'s load, ensuring the distribution remains as even as possible. Specifically, when load is transferred from one server to another, try to minimize the variance in load across all servers after each transfer. Requirements: 1. Implement a function `balance_load` that processes a list of initial server loads and a list of transfer operations. 2. Each transfer operation consists of a tuple `(source, target, amount)`, indicating the load to be transferred from the source server to the target server. 3. After processing all transfer operations, evenly distribute the load by moving excess load from overloaded servers to underloaded servers, if possible. # Function Signature ```python def balance_load(server_loads: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process load transfer operations and balance the loads across servers. :param server_loads: List of initial loads on each server :type server_loads: List[int] :param operations: List of load transfer operations :type operations: List[Tuple[int, int, int]] :return: Final balanced loads on each server :rtype: List[int] pass ``` # Input - `server_loads`: A list of integers where each value represents the initial load on each server. - `operations`: A list of tuples (source, target, amount) representing load transfer operations. # Output - A list of integers representing the final load on each server after processing all operations and balancing the load. # Constraints - The number of servers can be large, so optimize the solution for performance. - Ensure the load distribution does not result in a negative load on any server. - The transfer amounts are guaranteed to be non-negative integers. # Example ```python # Initial server loads server_loads = [10, 20, 30, 40] # Load transfer operations (source server, target server, amount) operations = [(0, 1, 5), (2, 3, 10), (1, 2, 15)] # Final balanced loads final_loads = balance_load(server_loads, operations) print(final_loads) # Output might be: [5, 20, 25, 50] after a balanced transfer ``` In this example, initial transfer operations are applied, followed by subsequent balancing to minimize variance in load across servers. # Additional Information Auxiliary helper methods may be defined within the script to facilitate load balancing and transfer operations, but the primary function to be tested is `balance_load`. Document any assumptions made. This problem tests the ability to: - Implement and understand distributed system concepts, - Handle dynamic load balancing and optimizations, - Manage and manipulate list data structures with efficient algorithms.","solution":"from typing import List, Tuple def balance_load(server_loads: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process load transfer operations and balance the loads across servers. :param server_loads: List of initial loads on each server :type server_loads: List[int] :param operations: List of load transfer operations :type operations: List[Tuple[int, int, int]] :return: Final balanced loads on each server :rtype: List[int] # First, apply all transfer operations for source, target, amount in operations: if source >= 0 and source < len(server_loads) and target >= 0 and target < len(server_loads): server_loads[source] -= amount server_loads[target] += amount # Now, balance the loads across all servers total_load = sum(server_loads) num_servers = len(server_loads) # Calculate the ideal load per server ideal_load = total_load // num_servers extra_load = total_load % num_servers balanced_loads = [ideal_load] * num_servers # Distribute the extra load evenly for i in range(extra_load): balanced_loads[i] += 1 return balanced_loads"},{"question":"# Longest Consecutive Sequence **Scenario**: A geneticist is analyzing a DNA sequence, which is represented by a string containing the characters \'A\', \'T\', \'C\', and \'G\'. They need to identify the longest consecutive sequence of a single character within the given DNA strand. As a software developer, you need to create a function that performs this task. **Function Signature**: ```python def longest_consecutive_sequence(dna: str) -> int: Finds the length of the longest consecutive sequence of a single character in the DNA strand. :param dna: A string representing the DNA sequence :return: The length of the longest consecutive sequence of a single character ``` **Input**: - A single string `dna` (1 <= len(dna) <= 10^6) consisting of the characters \'A\', \'T\', \'C\', and \'G\'. **Output**: - An integer representing the length of the longest consecutive sequence of a single character in the DNA strand. **Constraints**: - Your solution should efficiently handle strings up to the length of 10^6 characters. **Performance Requirements**: - Aim for an O(n) time complexity and O(1) space complexity for your solution, where n is the length of the DNA string. **Example**: ```python print(longest_consecutive_sequence(\\"ATCCCGGGGAT\\")) # Output: 4 print(longest_consecutive_sequence(\\"AATTCGGGA\\")) # Output: 3 print(longest_consecutive_sequence(\\"AGCT\\")) # Output: 1 print(longest_consecutive_sequence(\\"GCGCCCCG\\")) # Output: 4 ``` **Special Notes**: - Ensure to consider edge cases, such as very short DNA strings. - Optimize for both time and space to process long input sequences efficiently.","solution":"def longest_consecutive_sequence(dna: str) -> int: Finds the length of the longest consecutive sequence of a single character in the DNA strand. :param dna: A string representing the DNA sequence :return: The length of the longest consecutive sequence of a single character if not dna: return 0 max_length = 1 current_length = 1 for i in range(1, len(dna)): if dna[i] == dna[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"# Matrix Element Reversal Problem Description You are required to manipulate a given 2D matrix by reversing the elements in each row. The matrix dimensions and element values will be provided as input. Task Requirements Implement the function `reverse_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes: - A 2-dimensional list `matrix` containing integers. The function should return a new 2D list where each row of the input matrix has been reversed. Input and Output - **Input**: A 2-dimensional list of integers. - **Output**: A 2-dimensional list of integers with each row reversed. Constraints - The number of rows ((n)) and columns ((m)) in the input matrix can range from 0 to 1000. - Matrix element values ((matrix[i][j])) must be integers in the range from (-1000) to (1000). Example ```python >>> reverse_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 2, 1], [6, 5, 4], [9, 8, 7]] >>> reverse_matrix([[10, 20, 30], [40, 50, 60]]) [[30, 20, 10], [60, 50, 40]] >>> reverse_matrix([[]]) [[]] >>> reverse_matrix([]) [] ``` Note: Ensure your implementation is efficient to handle the largest possible input within the constraints.","solution":"def reverse_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns a new matrix where each row of the input matrix is reversed. return [row[::-1] for row in matrix]"},{"question":"# Coding Question Context In data analysis, it is often useful to extract statistical metrics from a list of numbers. One common task is to calculate the mean and the median from the given data set. Task Implement a function `calculate_mean_and_median(numbers: List[float]) -> Tuple[float, float]` that calculates and returns the mean and median of a list of numbers. Requirements 1. **Function Signature**: `calculate_mean_and_median(numbers: List[float]) -> Tuple[float, float]` 2. **Inputs**: - `numbers` (List[float]): A list of floating-point numbers. 3. **Outputs**: - Returns a tuple `(mean, median)` where: - `mean`: The arithmetic mean of the numbers. - `median`: The median value of the numbers. 4. **Constraints**: - The list `numbers` contains at least one number. - The list `numbers` can have both positive and negative numbers. Example ```python calculate_mean_and_median([1.0, 3.0, 4.0, 2.0, 5.0]) # mean = (1.0 + 3.0 + 4.0 + 2.0 + 5.0) / 5 = 3.0 # median = 3.0 (since sorted list is [1.0, 2.0, 3.0, 4.0, 5.0]) calculate_mean_and_median([1.0, 2.0, 3.0, 4.0]) # mean = (1.0 + 2.0 + 3.0 + 4.0) / 4 = 2.5 # median = (2.0 + 3.0) / 2 = 2.5 (since sorted list is [1.0, 2.0, 3.0, 4.0]) ``` Edge Cases - Handling single-element lists. - Handling lists with an even number of elements. - Ensuring correct handling of negative numbers and floating-point precision. Write clean and efficient code, considering both correctness and performance.","solution":"from typing import List, Tuple def calculate_mean_and_median(numbers: List[float]) -> Tuple[float, float]: Calculates and returns the mean and median of a list of numbers. Parameters: - numbers: List[float] : A list of floating-point numbers Returns: - Tuple[float, float] : A tuple containing the mean and median of the numbers # Calculating the mean mean = sum(numbers) / len(numbers) # Calculating the median sorted_numbers = sorted(numbers) n = len(sorted_numbers) if n % 2 == 1: # Odd number of elements median = sorted_numbers[n // 2] else: # Even number of elements median = (sorted_numbers[(n // 2) - 1] + sorted_numbers[n // 2]) / 2 return mean, median"},{"question":"# Coding Question: Binary Search Tree Operations Context You are building a library of functions to manipulate a Binary Search Tree (BST). The BST allows for insertion, deletion, and searching of integer values. Additionally, the BST can provide an in-order traversal of its elements. Task Write a function `bst_operations` to perform a series of operations on a BST as specified in an input list. Function Signature ```python def bst_operations(operations: list[tuple[str, int]]) -> list[list[int]]: Performs a series of operations on a Binary Search Tree. Args: operations: List of tuples where each tuple represents an operation in the format (op_type, value) - op_type: Operation type - \\"insert\\", \\"delete\\", \\"search\\", \\"inorder\\" - value: Value associated with the operation (integer) Returns: List of lists where each sublist contains the result of \\"inorder\\" traversal after its corresponding operation. For \\"search\\" operations, include a list of a single boolean value indicating whether the searched value is found. Example: bst_operations([ (\\"insert\\", 5), (\\"insert\\", 3), (\\"insert\\", 8), (\\"inorder\\", 0), (\\"search\\", 3), (\\"delete\\", 3), (\\"inorder\\", 0), (\\"search\\", 3) ]) => [[3, 5, 8], [True], [5, 8], [False]] ``` Requirements * Implement the `Node` and `BST` classes within your function. * The input list `operations` consists of multiple tuples where each tuple represents an operation on the BST. * The first element in the tuple (`op_type`) is the type of operation to perform, and the second (`value`) corresponds to the integer value to be inserted, searched, or deleted. * The \\"inorder\\" operation should result in a list of the current in-order traversal of the BST. * The \\"search\\" operation should return a boolean indicating whether the value is present in the BST or not. * The function should return a list where each element is the result of the \\"inorder\\" traversal after each such operation or the result of a \\"search\\" operation. Constraints - Only valid integer values will be used for insertion and search operations. - For \\"inorder\\" operations, the `value` parameter can be zero or any integer and should not influence the operation in the code.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if node is None: return Node(key) if key < node.key: node.left = self._insert_recursive(node.left, key) elif key > node.key: node.right = self._insert_recursive(node.right, key) return node def search(self, key): return self._search_recursive(self.root, key) is not None def _search_recursive(self, node, key): if node is None or node.key == key: return node if key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node, key): if node is None: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete_recursive(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.key) self._inorder_recursive(node.right, result) def bst_operations(operations): bst = BST() results = [] for op, value in operations: if op == \\"insert\\": bst.insert(value) elif op == \\"delete\\": bst.delete(value) elif op == \\"search\\": results.append([bst.search(value)]) elif op == \\"inorder\\": results.append(bst.inorder()) return results"},{"question":"# Scenario You are tasked with creating a simple voting system for a small organization. The system needs to determine whether a proposal is approved based on the votes cast. A proposal is approved if and only if it receives more \\"yes\\" votes than \\"no\\" votes. # Objective Implement the function `is_approved` that determines the outcome of the vote based on the counts of \\"yes\\" and \\"no\\" votes. # Function Signature ```python def is_approved(yes_votes: int, no_votes: int) -> bool: Determines whether a proposal is approved based on the counts of \\"yes\\" and \\"no\\" votes. :param yes_votes: The number of \\"yes\\" votes. :param no_votes: The number of \\"no\\" votes. :return: True if the proposal is approved (i.e., yes_votes > no_votes), otherwise False. ``` # Input 1. `yes_votes`: An integer representing the number of \\"yes\\" votes. 2. `no_votes`: An integer representing the number of \\"no\\" votes. # Output - A boolean value: - `True` if the number of \\"yes\\" votes is greater than the number of \\"no\\" votes. - `False` otherwise. # Constraints - `yes_votes` and `no_votes` must be non-negative integers. - If either `yes_votes` or `no_votes` is not a non-negative integer, the function should raise a `ValueError` with the message \\"Vote counts must be non-negative integers\\". # Examples ```python assert is_approved(10, 5) == True assert is_approved(3, 3) == False assert is_approved(7, 10) == False try: is_approved(-5, 3) except ValueError as e: assert str(e) == \\"Vote counts must be non-negative integers\\" try: is_approved(7, -2) except ValueError as e: assert str(e) == \\"Vote counts must be non-negative integers\\" try: is_approved(7, 3.5) except ValueError as e: assert str(e) == \\"Vote counts must be non-negative integers\\" ``` # Additional Notes Ensure your implementation handles only non-negative integer inputs for `yes_votes` and `no_votes`. Any violation of this should result in a `ValueError` with the appropriate message.","solution":"def is_approved(yes_votes: int, no_votes: int) -> bool: Determines whether a proposal is approved based on the counts of \\"yes\\" and \\"no\\" votes. :param yes_votes: The number of \\"yes\\" votes. :param no_votes: The number of \\"no\\" votes. :return: True if the proposal is approved (i.e., yes_votes > no_votes), otherwise False. if not (isinstance(yes_votes, int) and isinstance(no_votes, int)): raise ValueError(\\"Vote counts must be non-negative integers\\") if yes_votes < 0 or no_votes < 0: raise ValueError(\\"Vote counts must be non-negative integers\\") return yes_votes > no_votes"},{"question":"# Context You are developing a text processing application, and one of the key features is to check if two strings are anagrams. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. # Task Implement a function `are_anagrams` that determines if two given strings are anagrams of each other. Your solution should consider various input validation checks. # Requirements * Your function should take two parameters: `str1` and `str2`. * Your function should return `True` if the strings are anagrams, and `False` otherwise. * Raise a `TypeError` with an appropriate message if: - Either of the inputs is not a string. * Ignore spaces, punctuation, and case sensitivity while determining if the strings are anagrams. * Your solution should be efficient and handle edge cases like empty strings. # Function Signature ```python def are_anagrams(str1: str, str2: str) -> bool: pass ``` # Example Usage ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"Listen!\\", \\"Silent!\\") True >>> are_anagrams(123, \\"silent\\") Traceback (most recent call last): ... TypeError: Both inputs must be of type str ``` # Constraints and Considerations * Ensure your function correctly handles strings with spaces and various punctuation marks. * Consider the implications of case sensitivity and normalize inputs as needed. * Test your solution with different types of valid and invalid inputs to ensure robustness.","solution":"import re def are_anagrams(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams of each other, considering: - Only alphabet characters (ignore digits, spaces, punctuation) - Case insensitivity Raise TypeError if inputs are not strings. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Both inputs must be of type str\\") def clean_string(s): return sorted(re.sub(r\'[^a-zA-Z]\', \'\', s).lower()) return clean_string(str1) == clean_string(str2)"},{"question":"# Question **Problem Statement**: You are given a function to calculate the factorial of a number. Your task is to extend this functionality by writing two new functions: one to compute the factorial recursively and another to compute it iteratively. Additionally, you should compare the execution time of both methods for large input values. **Objective**: 1. Write a recursive function called `factorial_recursive(n: int) -> int` that takes a single integer `n` and returns the factorial of `n`. - Factorial of `n` (denoted as `n!`) is the product of all positive integers less than or equal to `n`. By definition, `0! = 1`. 2. Write an iterative function called `factorial_iterative(n: int) -> int` that takes a single integer `n` and returns the factorial of `n`. 3. Write a function called `compare_execution_time(n: int) -> dict` that takes an integer `n` and returns a dictionary with the execution time of both `factorial_recursive` and `factorial_iterative` functions for the given `n`. - Use the `time` module to measure the time taken by each method. **Constraints**: - You can assume `0 <= n <= 20` for the input of the factorial functions. **Input**: - A single integer for both `factorial_recursive` and `factorial_iterative` functions. - A single integer `n` for the `compare_execution_time` function. **Output**: - Integer result for both `factorial_recursive` and `factorial_iterative` functions. - Dictionary with execution times for the `compare_execution_time` function. **Examples**: 1. `factorial_recursive(5)` should return `120`. 2. `factorial_iterative(5)` should return `120`. 3. `compare_execution_time(5)` might return: ```python { \\"recursive_time\\": 0.000057, \\"iterative_time\\": 0.000032 } ``` This question will test your understanding of recursion, iteration, and performance analysis. Ensure your solution includes appropriate handling of edge cases and accurate timing measurements.","solution":"import time def factorial_recursive(n: int) -> int: Computes the factorial of n recursively. if n == 0: return 1 return n * factorial_recursive(n - 1) def factorial_iterative(n: int) -> int: Computes the factorial of n iteratively. result = 1 for i in range(1, n + 1): result *= i return result def compare_execution_time(n: int) -> dict: Compares the execution time of the recursive and iterative factorial functions for a given n. start_time = time.time() factorial_recursive(n) recursive_time = time.time() - start_time start_time = time.time() factorial_iterative(n) iterative_time = time.time() - start_time return { \\"recursive_time\\": recursive_time, \\"iterative_time\\": iterative_time }"},{"question":"# Matrix Pathfinding with Obstacles Context You are tasked with creating a utility for a robot that navigates through a grid. The robot can move in four directions: up, down, left, and right. Some cells in the grid are blocked, meaning the robot cannot pass through them. You need to check if the robot can reach a target cell starting from a given cell. Task Write a function called `can_reach_target` that determines if there is a path from the start cell to the target cell in a grid filled with obstacles. Function Signature ```python def can_reach_target(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> bool: pass ``` Input * `grid` (list[list[int]]): A 2D grid represented as a list of lists of integers, where `0` represents a free cell, and `1` represents an obstacle. * `start` (tuple[int, int]): A tuple (row, col) representing the starting cell. * `target` (tuple[int, int]): A tuple (row, col) representing the target cell. Output * `bool`: A Boolean value `True` if there is a path from the start cell to the target cell, `False` otherwise. Constraints * The grid can have up to (100 times 100) cells. * `0 <= row, col < 100` * The starting and target cells are not blocked and are within grid bounds. Example ```python def test_can_reach_target(): grid1 = [ [0, 0, 0, 1], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0] ] start1 = (0, 0) target1 = (3, 3) assert can_reach_target(grid1, start1, target1) == True, \\"Test case 1 failed\\" grid2 = [ [0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 0, 0] ] start2 = (0, 0) target2 = (3, 3) assert can_reach_target(grid2, start2, target2) == False, \\"Test case 2 failed\\" grid3 = [ [0, 0, 0], [0, 1, 1], [0, 0, 0] ] start3 = (0, 2) target3 = (2, 2) assert can_reach_target(grid3, start3, target3) == True, \\"Test case 3 failed\\" print(\\"All tests passed!\\") test_can_reach_target() ``` You should also consider writing additional test cases to cover edge cases, such as no possible path due to surrounding obstacles or the start cell being the same as the target cell.","solution":"def can_reach_target(grid, start, target): Determines if there is a path from the start cell to the target cell in a grid filled with obstacles. Parameters: - grid (list[list[int]]): The 2D grid represented as a list of lists of integers, where 0 represents a free cell and 1 represents an obstacle. - start (tuple[int, int]): The starting cell as a tuple (row, col). - target (tuple[int, int]): The target cell as a tuple (row, col). Returns: - bool: True if there is a path from the start cell to the target cell, False otherwise. rows, cols = len(grid), len(grid[0]) queue = [start] # Use a BFS queue visited = set() visited.add(start) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: current = queue.pop(0) if current == target: return True for direction in directions: new_row, new_col = current[0] + direction[0], current[1] + direction[1] if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: queue.append((new_row, new_col)) visited.add((new_row, new_col)) return False"},{"question":"# Problem: Finding Duplicate Files in a Directory Write a program to detect duplicate files in a directory. Two files are considered duplicates if they have the same size and the same content. Your program should resolve this problem using file comparison techniques and efficient file I/O operations. Input * A string `directory_path` which denotes the path to the directory you need to scan for duplicate files. Output * A list of lists, where each sublist contains the paths of files that are duplicates of each other. If no duplicates are found, the list should be empty. Constraints * The directory will contain at most 10,000 files. * Each file size will range between 1 byte and 1 GB. * File paths will not contain special characters or spaces, and will be unique in the directory. Example Given the directory structure under `test_directory`: ``` /test_directory file1.txt file2.txt file3.txt subdir1/ file4.txt file5.txt subdir2/ file6.txt ``` Where: - `file1.txt` and `file4.txt` have the same content. - `file2.txt` and `file5.txt` have the same content. - `file3.txt` and `file6.txt` have unique content. Your function should return something similar to: ``` [ [\'/test_directory/file1.txt\', \'/test_directory/subdir1/file4.txt\'], [\'/test_directory/file2.txt\', \'/test_directory/subdir1/file5.txt\'] ] ``` Function Signature ```python def find_duplicate_files(directory_path: str) -> list: ``` # Notes * Consider using file hashing (e.g., SHA-256) to efficiently compare file contents. * Ensure that your program can traverse subdirectories within the given directory recursively.","solution":"import os import hashlib from collections import defaultdict def calculate_file_hash(file_path): Calculate the hash of a file using SHA-256 hash_sha256 = hashlib.sha256() with open(file_path, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_sha256.update(chunk) return hash_sha256.hexdigest() def find_duplicate_files(directory_path): Find and return duplicate files in the directory file_hash_map = defaultdict(list) for root, _, files in os.walk(directory_path): for file_name in files: file_path = os.path.join(root, file_name) file_hash = calculate_file_hash(file_path) file_hash_map[file_hash].append(file_path) return [file_list for file_list in file_hash_map.values() if len(file_list) > 1]"},{"question":"# Trie Data Structure Implementation and Spell Checker Background A Trie (pronounced as \\"try\\") is a type of search tree often used to store a dynamic set or associative array where the keys are usually strings. It is particularly effective for tasks related to prefix-based searching and autocomplete functions. Problem Statement You are required to implement a Trie data structure and use it to develop a simple spell checker. The spell checker will add words to the Trie and provide suggestions for misspelled words based on existing Trie entries. Requirements 1. **Function Signatures and Definitions**: - `class Trie`: Constructor to initialize the Trie data structure. - `def add_word(word)`: Add a word into the Trie. - `def search_word(word)`: Check if a word exists in the Trie (return True if exists, False otherwise). - `def suggest_corrections(word)`: Given a potentially misspelled word, return a list of words in the Trie that are within a given edit distance (e.g., 1 or 2) from the input word. 2. **Input/Output**: - Initialize the Trie and input words into it. - Given a potentially misspelled word, output possible corrections based on the existing Trie entries. 3. **Constraints**: - Each word consists of lowercase English letters [a-z]. - The Trie\'s initial capacity is large enough to accommodate at least 10,000 words. - The maximum length of a word is 50 characters. - The spell checker should be able to handle words with up to 2 edit distance difference for corrections. 4. **Edit distance**: - Edit distance, also known as Levenshtein distance, is a metric for measuring how dissimilar two strings are by counting the minimum number of operations required to transform one string into the other. Operations typically include insertions, deletions, or substitutions. Objectives - Implement the Trie data structure to store and manage a large collection of words. - Develop functionalities to add words, search for exact matches, and suggest corrections for misspelled words. - Utilize the trie to efficiently navigate and query for related words based on edit distance. Implement the `Trie` class with the specified capabilities and ensure its ability to handle the described operations efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_word(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest_corrections(self, word, max_edit_distance=2): results = [] def dfs(current_node, current_word, index, max_distance, current_edits): if current_edits > max_distance: return if index == len(word): if current_node.is_end_of_word: results.append(current_word) return for char in current_node.children: if char == word[index]: dfs(current_node.children[char], current_word + char, index + 1, max_distance, current_edits) else: # Substitution dfs(current_node.children[char], current_word + char, index + 1, max_distance, current_edits + 1) # Deletion dfs(current_node, current_word, index + 1, max_distance, current_edits + 1) # Insertion for char in current_node.children: dfs(current_node.children[char], current_word + char, index, max_distance, current_edits + 1) dfs(self.root, \'\', 0, max_edit_distance, 0) return results"},{"question":"# Question: Determine the Intersection of Two Circles Write a function `find_circle_intersection` to determine if two circles intersect. The position and size of each circle are given by three parameters: the x-coordinate of the center, the y-coordinate of the center, and the radius. The function should return one of three possible values: - `\\"Touching\\"` if the two circles touch at exactly one point. - `\\"Intersecting\\"` if the two circles intersect at exactly two points. - `\\"Disjoint\\"` if the two circles do not intersect. # Function Signature ```python def find_circle_intersection(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> str: ``` # Input Parameters - `x1` (float): The x-coordinate of the center of the first circle. - `y1` (float): The y-coordinate of the center of the first circle. - `r1` (float): The radius of the first circle. Must be a non-negative value. - `x2` (float): The x-coordinate of the center of the second circle. - `y2` (float): The y-coordinate of the center of the second circle. - `r2` (float): The radius of the second circle. Must be a non-negative value. # Output - Returns a string: either `\\"Touching\\"`, `\\"Intersecting\\"`, or `\\"Disjoint\\"`. # Constraints - `r1` ≥ 0 - `r2` ≥ 0 # Example ```python >>> find_circle_intersection(x1=0, y1=0, r1=5, x2=10, y2=0, r2=5) \'Touching\' >>> find_circle_intersection(x1=0, y1=0, r1=5, x2=5, y2=0, r2=5) \'Intersecting\' >>> find_circle_intersection(x1=0, y1=0, r1=3, x2=10, y2=0, r2=2) \'Disjoint\' ``` # Notes - If either `r1` or `r2` is negative, raise a `ValueError`. - The function should handle floating point calculations with precision. - Adequate test cases should be provided to validate your implementation. # Hints - Use the Euclidean distance formula to calculate the distance between the centers of the two circles. - Consider the sum and absolute difference of the radii of the circles to determine the nature of the intersection.","solution":"import math def find_circle_intersection(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> str: Determine if two circles intersect, touch, or are disjoint. Parameters: x1 (float): x-coordinate of the first circle\'s center. y1 (float): y-coordinate of the first circle\'s center. r1 (float): radius of the first circle. x2 (float): x-coordinate of the second circle\'s center. y2 (float): y-coordinate of the second circle\'s center. r2 (float): radius of the second circle. Returns: str: \\"Touching\\", \\"Intersecting\\", or \\"Disjoint\\" based on the relationship between the circles. # Ensure the radii are non-negative if r1 < 0 or r2 < 0: raise ValueError(\\"Radii must be non-negative\\") # Calculate the distance between the centers of the two circles dist_centers = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) # Check for intersection, touching, and disjoint conditions if dist_centers > r1 + r2: return \\"Disjoint\\" elif dist_centers < abs(r1 - r2): return \\"Disjoint\\" elif dist_centers == r1 + r2 or dist_centers == abs(r1 - r2): return \\"Touching\\" else: return \\"Intersecting\\""},{"question":"# Implementing K-Nearest Neighbors (KNN) Classifier In this task, you are required to implement the K-Nearest Neighbors (KNN) algorithm for classification, including the correct handling of nearest neighbor searches and distance calculations. Your implementation should reflect the essential steps of the KNN algorithm while ensuring adequate error handling and efficiency. Objectives: 1. Design the function for **K-Nearest Neighbors (KNN) classifier**. 2. Include steps for distance calculations, neighbor searching, and majority vote determination. 3. Implement error handling, including checks for valid inputs and non-empty data arrays. Input * A feature matrix for training data (numpy array) with dimensions m x n. * Corresponding labels array (numpy array) for training data. * Feature matrix for test data (numpy array) whose labels need to be predicted. * Number of neighbors (k) for classification. Output * Predicted labels for test data (numpy array). Constraints * The training and test feature matrices will have at least one row and one column. * Labels array for training data will have the same number of elements as there are rows in the training feature matrix. * The value of k (number of neighbors) will not exceed the number of training samples. * Use numpy for matrix operations and distance calculations. Function Signature ```python def knn_classifier(train_features: np.ndarray, train_labels: np.ndarray, test_features: np.ndarray, k: int) -> np.ndarray: K-Nearest Neighbors Classifier. Parameters: * train_features: The feature matrix of the training data * train_labels: The labels corresponding to the training data * test_features: The feature matrix of the test data * k: Number of nearest neighbors to use for classification Returns: Predicted labels for the test data ``` Example Usage ```python import numpy as np from sklearn.datasets import load_iris # Loading sample dataset data = load_iris() features = data[\'data\'] labels = data[\'target\'] # Splitting the data into training and testing sets train_features = features[:100] train_labels = labels[:100] test_features = features[100:] # KNN Implementation k = 3 predicted_labels = knn_classifier(train_features, train_labels, test_features, k) print(predicted_labels) ``` Notes * Ensure that you include appropriate checks and error handling within your KNN function. * Use the provided example to verify your implementation. * Aim for clear, efficient, and well-documented code. * You may use numpy operations to compute Euclidean distances between vectors. [End of Question]","solution":"import numpy as np from collections import Counter def knn_classifier(train_features: np.ndarray, train_labels: np.ndarray, test_features: np.ndarray, k: int) -> np.ndarray: K-Nearest Neighbors Classifier. Parameters: - train_features: The feature matrix of the training data (m x n) - train_labels: The labels corresponding to the training data (m, ) - test_features: The feature matrix of the test data (p x n) - k: Number of nearest neighbors to use for classification Returns: - Predicted labels for the test data (p, ) # Ensure input validation if train_features.shape[0] != train_labels.shape[0]: raise ValueError(\\"Number of rows in train_features must match the length of train_labels\\") if k <= 0 or k > train_features.shape[0]: raise ValueError(\\"k must be a positive integer and no more than the number of training samples\\") def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2)) def predict(test_instance): # Compute distances from the test instance to all training samples distances = np.array([euclidean_distance(test_instance, train_instance) for train_instance in train_features]) # Get the indices of the k smallest distances neighbor_indices = np.argsort(distances)[:k] # Get the labels of the nearest neighbors neighbor_labels = train_labels[neighbor_indices] # Determine the majority vote majority_vote = Counter(neighbor_labels).most_common(1)[0][0] return majority_vote # Apply the predict function to all test samples predictions = np.apply_along_axis(predict, 1, test_features) return predictions"},{"question":"**Problem Statement:** You are given an integer `n` representing the number of rows of Pascal’s triangle. Your task is to implement the function `generate_pascals_triangle(n: int) -> List[List[int]]` which returns a list of lists of integers representing the first `n` rows of Pascal\'s triangle. **Input Format**: * `n`: An integer representing the number of rows of Pascal\'s triangle to generate (0 ≤ n ≤ 30). **Output Format**: * A list of lists of integers where each inner list represents a row of Pascal\'s triangle. **Constraints**: * Each number in Pascal\'s triangle is the sum of the two numbers directly above it in the previous row. * The topmost row (0th row) has a single 1. **Example**: ```python def generate_pascals_triangle(n): # your code here print(generate_pascals_triangle(5)) # Output: [ # [1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1] # ] print(generate_pascals_triangle(1)) # Output: [ # [1] # ] print(generate_pascals_triangle(7)) # Output: [ # [1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1], # [1, 5, 10, 10, 5, 1], # [1, 6, 15, 20, 15, 6, 1] # ] print(generate_pascals_triangle(0)) # Output: [] ``` **Your Task**: * Implement the `generate_pascals_triangle` function in an efficient manner. Ensure that your solution is optimized for the given constraints and handles edge cases appropriately.","solution":"from typing import List def generate_pascals_triangle(n: int) -> List[List[int]]: if n == 0: return [] triangle = [[1]] for row_num in range(1, n): row = [1] last_row = triangle[row_num - 1] for j in range(1, row_num): row.append(last_row[j - 1] + last_row[j]) row.append(1) triangle.append(row) return triangle"},{"question":"# Problem Statement You are given a list of non-negative integers representing the amount of rainwater trapped after raining over each index of the array. Your task is to develop a function `trap_rainwater` that calculates the total amount of rainwater trapped after the raining event. # Function Signature ```python def trap_rainwater(heights: list[int]) -> int: pass ``` # Input * **heights**: List of non-negative integers, where each integer represents the elevation at that index. # Output * An integer representing the total amount of rainwater trapped. # Constraints * All integers in the input list will be within the range of 0 to 10^5. * The length of the input list will be less than or equal to 100_000. # Performance Requirements * The solution must run efficiently considering the constraints (~O(n) is expected, for n up to 100_000). # Example ```python >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([4, 2, 3]) 1 >>> trap_rainwater([4]) 0 >>> trap_rainwater([0, 0, 0, 0]) 0 ``` # Edge Cases To Consider * Arrays with all zeros or single element arrays should return 0. * Arrays with no possible trapping (e.g., monotonically increasing or decreasing arrays should return 0). * Large flat sections in the array, e.g., `[0, 0, 0, 0]` or `[3, 3, 3]`. # Hints 1. Use two-pointer technique to efficiently calculate the trapped water. 2. Keep track of the maximum height from both ends while iterating towards the center.","solution":"def trap_rainwater(heights: list[int]) -> int: if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"# Coding Challenge: Valid Palindrome with Special Conditions Background A string is considered a palindrome if it reads the same backward as forward. Given a string `s`, determine if it can be made into a palindrome by removing at most one character. Task Write a function `valid_palindrome(s: str) -> bool` that determines whether the given string `s` can be transformed into a palindrome by removing at most one character. Input - A single string `s` (1 <= len(s) <= 10^5), consisting of lowercase letters. Output - Return `True` if the string can be made into a palindrome by removing at most one character, and `False` otherwise. Examples ```python assert valid_palindrome(\\"abca\\") == True assert valid_palindrome(\\"racecar\\") == True assert valid_palindrome(\\"hello\\") == False assert valid_palindrome(\\"a\\") == True assert valid_palindrome(\\"deified\\") == True assert valid_palindrome(\\"palap\\") == True assert valid_palindrome(\\"abcdef\\") == False ``` # Constraints - The input string will only contain lowercase alphabetical characters. - The function must handle strings of length up to 100,000 efficiently. # Explanation - For the string \\"abca\\", removing the character \'b\' results in \\"aca\\", which is a palindrome. - For the string \\"racecar\\", it is already a palindrome, so the function should return `True`. - For the string \\"hello\\", no single character removal can make it a palindrome, so the function should return `False`.","solution":"def valid_palindrome(s: str) -> bool: Determine if the string can be made into a palindrome by removing at most one character. def is_palindrome_range(i, j): Check if s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (i+j)//2 + 1)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Try to skip either the left character or the right character return is_palindrome_range(l+1, r) or is_palindrome_range(l, r-1) l += 1 r -= 1 return True"},{"question":"# Problem Description You are required to write a function `two_sum` that takes a list of integers and an integer target as input and returns the indices of the two numbers such that they add up to the target. Assume that each input has exactly one solution, and you may not use the same element twice. # Input Format - A list of integers `nums` (0 <= len(nums) <= 10^6) - An integer `target` # Output Format - A list of two integers representing the indices of the two numbers in the input list that add up to the target. # Constraints - Each input is guaranteed to have exactly one solution. - The list may contain negative numbers. - The integers in the list are distinct. - Minimize the impact of edge cases and ensure the function runs optimally for large inputs. # Performance Requirements - The solution should aim for O(n) time complexity. - Use O(n) additional space if necessary. # Example Scenarios 1. **Example 1:** - Input: nums = [2, 7, 11, 15], target = 9 - Output: [0, 1] 2. **Example 2:** - Input: nums = [3, 2, 4], target = 6 - Output: [1, 2] 3. **Example 3:** - Input: nums = [3, 3], target = 6 - Output: [0, 1] # Edge Cases 1. **Empty List:** - Input: nums = [], target = 0 - Output: [] 2. **Single Element List:** - Input: nums = [5], target = 5 - Output: [] # Function Signature ```python def two_sum(nums: list, target: int) -> list: pass ``` # Write the function `two_sum` to solve the problem:","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"# Sum of Each Digit Raised to the Power of the Number of Digits **Problem Description**: Given a positive integer `n`, your task is to determine whether the number is the sum of its own digits each raised to the power of the number of digits. For instance, 153 is such a number since: [ 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153 ] Such numbers are known as narcissistic numbers. **Your Task**: Write a function named `is_narcissistic(n: int) -> bool` that takes an integer `n` and returns a boolean value indicating whether the number is narcissistic. **Function Signature**: ```python def is_narcissistic(n: int) -> bool: pass ``` **Input**: * `n` (1 ≤ n ≤ 10^6): A positive integer. **Output**: * Returns `True` if `n` is a narcissistic number, else returns `False`. **Examples**: ```python is_narcissistic(153) # Returns True (since 1^3 + 5^3 + 3^3 = 153) is_narcissistic(9474) # Returns True (since 9^4 + 4^4 + 7^4 + 4^4 = 9474) is_narcissistic(123) # Returns False (since 1^3 + 2^3 + 3^3 = 36, which is ≠ 123) ``` **Constraints**: * You may assume that the solution exists and can be evaluated within the given constraints. **Hints**: 1. Determine the number of digits in the number. 2. Compute the sum of each digit raised to the power of the number of digits. 3. Check if the computed sum equals the original number.","solution":"def is_narcissistic(n: int) -> bool: Checks if a number is a narcissistic number. A number is considered narcissistic if it is the sum of its own digits each raised to the power of the number of digits. Parameters: n (int): The number to check. Returns: bool: True if the number is narcissistic, False otherwise. # Convert the number to string to iterate over its digits digits = str(n) num_digits = len(digits) # Calculate the sum of each digit raised to the power of the number of digits sum_of_powers = sum(int(digit) ** num_digits for digit in digits) # Check if the sum of powers is equal to the original number return sum_of_powers == n"},{"question":"# Problem Statement You are tasked with implementing a function that performs a depth-first search (DFS) on a directed graph and detects cycles within the graph. If a cycle is detected, the function should return `True`; otherwise, it should return `False`. # Input * A dictionary `graph` representing the adjacency list of the directed graph, where keys are node identifiers and values are lists of adjacent nodes. # Output * A boolean value `True` if a cycle is detected in the graph. * A boolean value `False` if no cycle is detected in the graph. # Constraints * The graph may be disconnected. * Node identifiers are strings. * The graph can have any number of nodes and edges. * There might be nodes with no outgoing edges (i.e., they have an empty list in the adjacency list). # Performance Requirements * The function should have a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. * The function should have a space complexity of O(V). # Scenario: Consider the graph represented as an adjacency list: ```python graph = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } ``` The function should return `True`, as there is a cycle among the nodes \\"A\\", \\"B\\", and \\"C\\". Consider the graph represented as an adjacency list: ```python graph = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } ``` The function should return `False`, as there are no cycles in the graph. # Function Signature ```python def detect_cycle(graph: dict[str, list[str]]) -> bool: pass ```","solution":"def detect_cycle(graph: dict[str, list[str]]) -> bool: Returns True if there is a cycle in the graph, False otherwise. :param graph: A dictionary representing the adjacency list of the graph. :return: A boolean indicating whether there is a cycle in the graph. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: # Cycle detected return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Coding Challenge You have been asked to develop a system to monitor and alert unusual activity on a social media platform. The system will analyze historical post data to detect significant spikes in activity and notify when a spike is detected using two different methods. Requirements: 1. **Implement** two anomaly detection models: - **Z-score Method** (`z_score_detection`). - **DBSCAN Clustering Method** (`dbscan_detection`). 2. **Implement** a notification system that triggers if either of the models detects an anomaly: - **Anomaly Notifier** (`anomaly_notifier`). 3. **Process** daily post data and detect if there is a significant spike in activity when compared to the historical data. # Input: - Historical data is provided in a list of integers, where each integer represents the number of posts made on that day. - Today\'s post count as an integer. # Output: - A boolean value indicating whether a significant spike in today\'s post activity is detected (`True`) or not (`False`). # Constraints: - The list will have a minimum size of 30. - All values in the list will be positive integers. - The models should handle edge cases, like uniform data distribution, gracefully. # Implementation Details: - Implement the anomaly detection functions `z_score_detection` and `dbscan_detection`. - Implement the anomaly notifier function `anomaly_notifier` which consolidates the results from the detection functions and decides if today is an anomaly. # Example: ```python historical_post_data = [50, 52, 53, 47, 48, 51, 45, 60, 49, 54, 55, 63, 42, 46, 58, 59, 57, 65, 62, 40, 53, 50, 55, 60, 61, 64, 51, 48, 52, 45] todays_post_count = 120 # You need to process the data # Implement anomaly detection models # Implement notification system # Expected output: # True (indicating a significant spike detected) ```","solution":"from scipy.stats import zscore import numpy as np from sklearn.cluster import DBSCAN def z_score_detection(historical_data, today_count, threshold=3): Detect outlier using Z-score method. An outlier is flagged if the Z-score is greater than the given threshold. historical_z_scores = zscore(historical_data) mean_historical = np.mean(historical_data) std_historical = np.std(historical_data) today_z_score = (today_count - mean_historical) / std_historical return today_z_score > threshold def dbscan_detection(historical_data, today_count, eps=3, min_samples=5): Detect outlier using DBSCAN clustering method. An outlier is flagged if today\'s post count is labeled as noise by DBSCAN. data_with_today = np.array(historical_data + [today_count]).reshape(-1, 1) dbscan = DBSCAN(eps=eps, min_samples=min_samples) labels = dbscan.fit_predict(data_with_today) return labels[-1] == -1 def anomaly_notifier(historical_data, today_count): Notify if there is an anomaly detected in today\'s post count. is_anomaly_z_score = z_score_detection(historical_data, today_count) is_anomaly_dbscan = dbscan_detection(historical_data, today_count) return is_anomaly_z_score or is_anomaly_dbscan"},{"question":"# Question: Implement a Custom Trie with Start Prefix Count **Context**: You are tasked with developing a custom Trie (prefix tree) data structure for efficient prefix-based searching. In addition to standard Trie functionalities, your implementation must support a new operation that counts how many words in the Trie start with a given prefix. **Function to Implement**: Implement the following Trie class with a nested TrieNode class: ```python class TrieNode: def __init__(self): A node in the Trie structure. self.children = {} self.end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): Initialize the Trie. self.root = TrieNode() def insert(self, word): Insert a word into the Trie. Parameters: word : A string representing the word to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.prefix_count += 1 node.end_of_word = True def search(self, word): Search for a word in the Trie. Parameters: word : A string representing the word to search. Returns: bool : True if the word exists in the Trie, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): Count how many words in the Trie start with the given prefix. Parameters: prefix : A string representing the prefix. Returns: int : The number of words that start with the given prefix. node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.prefix_count ``` **Input/Output**: - **Input**: - `word`: a string for insertion and search operations. - `prefix`: a string for the prefix count operation. - **Output**: - `search`: Returns `True` if the word exists in the Trie, `False` otherwise. - `starts_with`: Returns an integer indicating the number of words that start with the given prefix. **Constraints**: - All words and prefixes consist of lowercase English letters (\'a\' to \'z\'). - The length of any word or prefix does not exceed 100 characters. - The total number of words inserted into the Trie does not exceed 10^5. **Requirements**: 1. Implement a `TrieNode` class with required attributes. 2. Implement a `Trie` class with efficient `insert`, `search`, and `starts_with` methods. 3. Ensure that the `starts_with` method performs the prefix count operation optimally. **Performance Considerations**: - The implementation should handle the largest input efficiently within reasonable time limits. - Utilize appropriate data structures and algorithms to manage and retrieve the prefix counts effectively.","solution":"class TrieNode: def __init__(self): A node in the Trie structure. self.children = {} self.end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): Initialize the Trie. self.root = TrieNode() def insert(self, word): Insert a word into the Trie. Parameters: word : A string representing the word to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.prefix_count += 1 node.end_of_word = True def search(self, word): Search for a word in the Trie. Parameters: word : A string representing the word to search. Returns: bool : True if the word exists in the Trie, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): Count how many words in the Trie start with the given prefix. Parameters: prefix : A string representing the prefix. Returns: int : The number of words that start with the given prefix. node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.prefix_count"},{"question":"# Matrix Transposition and Multiplication Scenario You are working on a project involving matrix operations for a scientific computing application. To improve the performance of certain calculations, you need to implement two key matrix operations: transposition and multiplication. Task Your task is to implement two functions: one for transposing a matrix and another for multiplying two matrices. Each function should conform to the provided specifications. Functions 1. **Function `transpose_matrix`:** - **Input**: A list of lists (2D list) representing a matrix `matrix` where each sublist is a row of the matrix. The matrix has `m` rows and `n` columns. - **Output**: A new list of lists (2D list) representing the transpose of the input matrix. The transpose of a matrix is formed by swapping the rows with columns. 2. **Function `multiply_matrices`:** - **Input**: Two lists of lists (2D lists) representing matrices `matrix_a` and `matrix_b`. Matrix `matrix_a` has dimensions `m1 x n1` and matrix `matrix_b` has dimensions `m2 x n2`. The multiplication is only possible if `n1 == m2`. - **Output**: A new list of lists representing the product of the two input matrices. The resulting matrix will have dimensions `m1 x n2`. You need to ensure that the operations handle edge cases gracefully and are optimized for performance. ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transpose a given matrix. Parameters: - matrix (list[list[int]]): A 2D list representing the matrix Returns: - list[list[int]]: A 2D list representing the transposed matrix # Your code here def multiply_matrices(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Multiply two matrices. Parameters: - matrix_a (list[list[int]]): A 2D list representing the first matrix - matrix_b (list[list[int]]): A 2D list representing the second matrix Returns: - list[list[int]]: A 2D list representing the product of the two matrices # Your code here ``` Examples ```python # Example for transpose_matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix)) # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Example for multiply_matrices matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] print(multiply_matrices(matrix_a, matrix_b)) # [ # [58, 64], # [139, 154] # ] ``` Constraints * Ensure that your functions handle invalid inputs gracefully, such as mismatched dimensions for matrix multiplication. * Aim for clear and efficient implementation and comment your code to explain key parts. **Note:** Raise appropriate exceptions if inputs are invalid (e.g., matrices cannot be multiplied due to incompatible dimensions).","solution":"def transpose_matrix(matrix): Transpose a given matrix. Parameters: - matrix (list[list[int]]): A 2D list representing the matrix Returns: - list[list[int]]: A 2D list representing the transposed matrix return [list(row) for row in zip(*matrix)] def multiply_matrices(matrix_a, matrix_b): Multiply two matrices. Parameters: - matrix_a (list[list[int]]): A 2D list representing the first matrix - matrix_b (list[list[int]]): A 2D list representing the second matrix Returns: - list[list[int]]: A 2D list representing the product of the two matrices Note: Raise ValueError if the matrices cannot be multiplied due to incompatible dimensions. if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Matrices cannot be multiplied due to incompatible dimensions.\\") result = [[sum(a * b for a, b in zip(row_a, col_b)) for col_b in zip(*matrix_b)] for row_a in matrix_a] return result"},{"question":"# Context In data structures, trees represent hierarchical relationships and are pivotal for various applications like file systems, database indexing, and more. A Binary Search Tree (BST) is a binary tree where each node has at most two children generally referred to as the left child and right child. For each node, the left subtree contains only nodes with keys less than the node\'s key, and the right subtree contains only nodes with keys greater than the node\'s key. An AVL Tree is a self-balancing binary search tree where the difference between the heights of left and right subtrees cannot be more than one for all nodes. When nodes are added or removed, the tree performs rotations to maintain balance. In this task, you will implement a function to handle an insertion operation in an AVL tree. # Task Implement a function `insert_node` that inserts a new node into an AVL tree and returns the root of the balanced tree. 1. **Function Signature**: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def insert_node(root: Optional[TreeNode], key: int) -> TreeNode: pass ``` 2. **Parameters**: - `root`: The root of the AVL tree (it may be `None` for an empty tree). - `key`: The integer value of the new node to be inserted. 3. **Returns**: - The root of the AVL tree after inserting the new node and balancing the tree. # Constraints - The tree may contain up to `10^4` nodes. - The keys are unique integers. - The key values for insertion are within the range `-10^4` to `10^4`. # Example ```python # Example of usage root = TreeNode(10) root = insert_node(root, 20) root = insert_node(root, 30) # Create an AVL tree and insert nodes assert root.key == 20 assert root.left.key == 10 assert root.right.key == 30 ``` # Implementation Details 1. Start by implementing the basic structure of the TreeNode. 2. Implement the helper functions to get height, perform rotations (left and right), and update heights. 3. Insert the new node into the binary search tree. 4. After insertion, use rotations to balance the tree ensuring that it\'s an AVL tree.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def get_height(node): if not node: return 0 return node.height def update_height(node): node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def left_rotate(x): y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def insert_node(root, key): if not root: return TreeNode(key) if key < root.key: root.left = insert_node(root.left, key) else: root.right = insert_node(root.right, key) update_height(root) balance = get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root"},{"question":"# Message Encoder-Decoder Utility You are provided with a utility function that encodes a message into a special format and decodes it back to the original message. Currently, this function: 1. Converts each character in the message to its corresponding ASCII value. 2. Shifts each ASCII value by a certain number of positions to encode the message. 3. Reverses the process to decode the message back to its original form. Your task is to enhance this utility with the following features: * **Support for Custom Shift Value**: Allow the user to specify the number of positions to shift ASCII values during encoding and decoding. * **Case Insensitivity**: Ensure that the encoding and decoding process is case insensitive, treating \'A\' and \'a\' as equivalent. * **Preserve Non-Alphabetic Characters**: Maintain the original positions and characters of non-alphabetic symbols in the message. # Input - A string representing the message to be encoded or decoded. - An integer representing the shift value for encoding and decoding. # Output - The function should return the encoded or decoded message based on the input parameters. - It should handle edge cases gracefully, such as empty strings or invalid input types. # Constraints - The shift value will be a positive integer between 1 and 25. - Always treat the shift values modulo 26 for the case-insensitive alphabetic characters. - Non-alphabetic characters should remain unaffected by the encoding or decoding process. # Example ```python # Example utility functions def encode_message(message: str, shift: int) -> str: # Implement encoding logic pass def decode_message(encoded_message: str, shift: int) -> str: # Implement decoding logic pass # Example main invocation if __name__ == \\"__main__\\": message = \\"Hello, World!\\" shift = 3 encoded = encode_message(message, shift) print(f\\"Encoded Message: {encoded}\\") # Output example: \\"Khoor, Zruog!\\" decoded = decode_message(encoded, shift) print(f\\"Decoded Message: {decoded}\\") # Output: \\"Hello, World!\\" ``` **Note**: Assume that the utility imports and any additional required libraries are appropriately managed.","solution":"def encode_message(message: str, shift: int) -> str: encoded_message = [] for char in message: if char.isalpha(): new_char = chr((ord(char.lower()) - 97 + shift) % 26 + 97) if char.isupper(): new_char = new_char.upper() encoded_message.append(new_char) else: encoded_message.append(char) return \'\'.join(encoded_message) def decode_message(encoded_message: str, shift: int) -> str: decoded_message = [] for char in encoded_message: if char.isalpha(): new_char = chr((ord(char.lower()) - 97 - shift) % 26 + 97) if char.isupper(): new_char = new_char.upper() decoded_message.append(new_char) else: decoded_message.append(char) return \'\'.join(decoded_message)"},{"question":"# Question: Implement a Queue Using Two Stacks You are required to implement a queue using two stacks. The queue should allow basic operations including enqueue, dequeue, and checking if the queue is empty. # Requirements 1. Implement the `StackQueue` class. 2. Ensure that the class supports the following methods: - `enqueue(element)` - `dequeue()` - `is_empty()` - `__str__()` (to print the current state of the queue for testing) # Guidelines 1. Use two stacks, `stack1` and `stack2`, to implement the queue. 2. The `enqueue` operation should push elements onto `stack1`. 3. The `dequeue` operation should pop elements from `stack2`. If `stack2` is empty, it should transfer all elements from `stack1` to `stack2` before popping. 4. The `is_empty` method should return `True` if both stacks are empty, `False` otherwise. 5. Include appropriate error handling for scenarios like attempting to dequeue from an empty queue. # Example ```python class StackQueue: def __init__(self): ... def enqueue(self, element): ... def dequeue(self): ... def is_empty(self): ... def __str__(self): ... # Example usage: sq = StackQueue() print(sq) # Empty queue sq.enqueue(1) sq.enqueue(2) sq.enqueue(3) print(sq) # Queue with elements print(sq.dequeue()) # Output: 1 print(sq) # Remaining queue elements print(sq.is_empty()) # Output: False sq.dequeue() sq.dequeue() print(sq.is_empty()) # Output: True print(sq) ``` # Constraints 1. Elements in the queue can be any data type. 2. Assume no limit on the number of elements that can be enqueued or dequeued. # Submission Submit the `StackQueue` class definition along with test cases demonstrating the functionality of enqueue, dequeue, and is_empty operations.","solution":"class StackQueue: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, element): self.stack1.append(element) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def is_empty(self): return not self.stack1 and not self.stack2 def __str__(self): if self.stack2: output = list(self.stack2[::-1]) + self.stack1 else: output = self.stack1 return \\"Queue: \\" + str(output)"},{"question":"# Problem Statement You are given a sequence of integers. Your task is to determine the length of the longest subsequence where each subsequent element is double the previous one. A subsequence does not need to be contiguous but must maintain the order of the original sequence. Your task is to implement a function `longest_doubling_subsequence_length()` that takes in a list of integers and returns the length of the longest subsequence where each subsequent element is double the previous one. Function Signature ```python def longest_doubling_subsequence_length(seq: List[int]) -> int: ``` Input - `seq` (List[int]): A list of integers (1 ≤ len(seq) ≤ 1000, 1 ≤ seq[i] ≤ 10^6). Output - Returns an integer representing the length of the longest subsequence where each subsequent element is double the previous one. Constraints - The length of the sequence will be between 1 and 1000 inclusive. - Elements in the sequence will be positive integers and can go up to 1,000,000. Example ```python print(longest_doubling_subsequence_length([1, 2, 3, 4, 8, 16, 32])) # Should output 6 print(longest_doubling_subsequence_length([10, 20, 40, 10, 20])) # Should output 3 print(longest_doubling_subsequence_length([3, 6, 12, 24, 5, 10, 20, 40])) # Should output 4 ``` Explanation For the first example, the subsequence [1, 2, 4, 8, 16, 32] is the longest doubling subsequence. For the second example, the longest doubling subsequence is [10, 20, 40] or [10, 20, 40]. For the third example, the longest doubling subsequence can be [3, 6, 12, 24] or [5, 10, 20, 40]. Both have length 4. Use the function signature and empty implementation provided above to fill in your solution. Ensure that your code is efficient and well-commented.","solution":"def longest_doubling_subsequence_length(seq): if not seq: return 0 seq_len = len(seq) dp = [1] * seq_len # dp[i] will store the length of the longest sequence ending with seq[i] # Loop through each element to build the dp array for i in range(seq_len): for j in range(i): if seq[i] == 2 * seq[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Algorithm Optimization and Performance Tuning You are working as a software engineer in a company that handles large volumes of data processing. Your responsibility is to improve the performance of algorithms used for string manipulation and pattern matching. Your task is to implement a function that finds all starting indices of a given pattern in a text string using an efficient algorithm. Task 1. **Implement the Knuth-Morris-Pratt (KMP) algorithm to find all starting indices of a given pattern in a text string.** 2. **Optimize the implementation to handle large input sizes efficiently.** 3. **Analyze the time complexity and memory usage of your implementation.** Requirements 1. Implement the following function: - `kmp_search(text: str, pattern: str) -> List[int]`: This function should return a list of starting indices where the pattern is found in the text using the KMP algorithm. 2. **Constraints**: - The text and pattern will be non-empty strings consisting of lowercase English characters. - The length of the text will be up to 10^6 characters. - The length of the pattern will be up to 10^4 characters. 3. **Performance Requirements**: - The implementation must have a time complexity of O(n + m), where n is the length of the text and m is the length of the pattern. - Optimize memory usage to ensure efficiency with large inputs. Input - `text` (str): The text string in which the pattern needs to be searched. - `pattern` (str): The pattern string to be searched within the text. Output - `kmp_search` returns a list of integers, each representing the starting index of the pattern in the text. Example ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" indices = kmp_search(text, pattern) # Expected: [10] text = \\"abcdabcabcd\\" pattern = \\"abc\\" indices = kmp_search(text, pattern) # Expected: [0, 4, 7] ``` # Additional Information: - The KMP algorithm preprocesses the pattern to create a longest prefix suffix (LPS) array, which helps in achieving the linear time complexity. - Make sure to handle edge cases where the pattern is longer than the text or does not appear in the text at all. # Explanation: - In the first example, the pattern \\"ababd\\" starts at index 10 in the text \\"ababcabcabababd\\". - In the second example, the pattern \\"abc\\" starts at indices 0, 4, and 7 in the text \\"abcdabcabcd\\". Implement the function considering all the requirements and constraints.","solution":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: def compute_lps_array(pattern: str) -> List[int]: m = len(pattern) lps = [0] * m length = 0 i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) lps = compute_lps_array(pattern) result = [] i = 0 j = 0 while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Pascal\'s Triangle Generation You are tasked to implement a Python function that generates Pascal\'s Triangle up to a given number of rows. Your goal is to optimize the generation algorithm to minimize space complexity. # Objective Write a function `generate_pascals_triangle_optimized` that returns the Pascal\'s Triangle up to `n` rows using an optimized approach to minimize space usage. # Input and Output * **Inputs**: * `n: int` - the number of rows of Pascal\'s Triangle to generate. * **Output**: * A list of lists where each sublist represents a row in Pascal\'s Triangle. # Constraints * `0 <= n <= 30` # Guidelines 1. Optimize the space usage by generating rows iteratively. 2. Ensure that your function handles edge cases, such as n = 0. # Function Signature ```python def generate_pascals_triangle_optimized(n: int): # Your code here ``` # Example ```python def generate_pascals_triangle_optimized(n: int): if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] + [triangle[i-1][j] + triangle[i-1][j+1] for j in range(len(triangle[i-1]) - 1)] + [1] triangle.append(row) return triangle def main(): rows = 5 triangle = generate_pascals_triangle_optimized(rows) for row in triangle: print(row) if __name__ == \\"__main__\\": main() ``` # Scenario Suppose you are working on an analytics platform that includes visualizations of mathematical concepts. Generating Pascal’s Triangle efficiently not only saves memory but also can speed up the rendering processes, especially for larger values of `n`. Implement the optimized algorithm and describe its impact on space complexity.","solution":"def generate_pascals_triangle_optimized(n: int): Generates Pascal\'s Triangle up to n rows in an optimized way. if n == 0: return [] triangle = [[1]] for i in range(1, n): prev_row = triangle[-1] new_row = [1] for j in range(1, i): new_row.append(prev_row[j-1] + prev_row[j]) new_row.append(1) triangle.append(new_row) return triangle"},{"question":"# Question Scenario You have been hired to develop a restaurant reservation system that automatically assigns tables to reservations. Each table has a capacity, and each reservation requests a specific number of seats. Task Write a function `assign_tables(tables: List[int], reservations: List[int]) -> List[Tuple[int, int]]` that assigns tables to reservations in a way that minimizes the unused seats as much as possible. Your function should return a list of tuples, where each tuple consists of two integers. The first integer is the index of the reservation, and the second integer is the index of the assigned table. If a reservation cannot be assigned to any table, list its index along with -1. Input and Output formats * **Input**: * `tables`: A list of integers where each integer represents the capacity of a table. * `reservations`: A list of integers where each integer represents the number of seats requested in a reservation. * **Output**: * A list of tuples, where each tuple consists of two integers: the index of the reservation and the index of the assigned table. If a reservation cannot be assigned to any table, it should be paired with -1. Constraints * Each reservation must be assigned to exactly one table or none at all. * Tables are unique and indexed from 0 to n-1. * Reservations are unique and indexed from 0 to m-1. * There may be more reservations than tables or vice versa. * The length of `tables` and `reservations` will be at most 1000. Example ```python tables = [4, 2, 8, 6] reservations = [3, 5, 2, 8] print(assign_tables(tables, reservations)) # Output: # [(0, 3), (1, -1), (2, 1), (3, 2)] ``` Use the given tables and reservations lists to demonstrate the function in action.","solution":"from typing import List, Tuple def assign_tables(tables: List[int], reservations: List[int]) -> List[Tuple[int, int]]: Assign tables to reservations in a way that minimizes unused seats. Parameters: tables (List[int]): A list of integers representing the capacities of each table. reservations (List[int]): A list of integers representing the number of seats requested in each reservation. Returns: List[Tuple[int, int]]: A list of tuples where each tuple consists of the index of the reservation and the index of the assigned table. If a reservation cannot be assigned to any table, it is paired with -1. result = [] tables_with_indices = sorted([(capacity, idx) for idx, capacity in enumerate(tables)], key=lambda x: x[0]) for res_idx, res_seats in enumerate(reservations): assigned = False for table_idx, (table_cap, table_idx_orig) in enumerate(tables_with_indices): if table_cap >= res_seats: result.append((res_idx, table_idx_orig)) tables_with_indices.pop(table_idx) assigned = True break if not assigned: result.append((res_idx, -1)) return result"},{"question":"# Context You have explored various string manipulation techniques and are comfortable with basic operations such as reversing, concatenation, and substring extraction. Now, you\'re ready to solve a problem that involves processing a string to identify and manipulate palindromic substrings. # Problem Implement a function that finds all unique substrings of a given string that are palindromes. A palindrome is a string that reads the same forwards and backwards. Sort the identified palindromic substrings first by their lengths in ascending order and then lexicographically if they have the same length. # Task Implement the function `find_palindromic_substrings(s: str) -> List[str]` which takes a string `s` and returns a list of all unique palindromic substrings sorted as specified. # Requirements 1. **Function**: `find_palindromic_substrings` - **Input**: A single string `s`. (1 ≤ |s| ≤ 100) - **Output**: Returns a list of unique palindromic substrings sorted first by their lengths and then lexicographically where necessary. - **Constraints**: - Handle both uppercase and lowercase letters. The comparison is case-sensitive. # Examples ```python assert find_palindromic_substrings(\\"racecar\\") == [\'a\', \'c\', \'e\', \'r\', \'cec\', \'aceca\', \'racecar\'] assert find_palindromic_substrings(\\"abba\\") == [\'a\', \'b\', \'bb\', \'abba\'] assert find_palindromic_substrings(\\"abc\\") == [\'a\', \'b\', \'c\'] assert find_palindromic_substrings(\\"madam\\") == [\'a\', \'d\', \'m\', \'ada\', \'madam\'] assert find_palindromic_substrings(\\"level\\") == [\'e\', \'l\', \'v\', \'eve\', \'level\'] ``` ```python def find_palindromic_substrings(s: str) -> List[str]: palindromes = set() def is_palindrome(sub: str) -> bool: return sub == sub[::-1] n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes, key=lambda x: (len(x), x)) assert find_palindromic_substrings(\\"racecar\\") == [\'a\', \'c\', \'e\', \'r\', \'cec\', \'aceca\', \'racecar\'] assert find_palindromic_substrings(\\"abba\\") == [\'a\', \'b\', \'bb\', \'abba\'] assert find_palindromic_substrings(\\"abc\\") == [\'a\', \'b\', \'c\'] assert find_palindromic_substrings(\\"madam\\") == [\'a\', \'d\', \'m\', \'ada\', \'madam\'] assert find_palindromic_substrings(\\"level\\") == [\'e\', \'l\', \'v\', \'eve\', \'level\'] ```","solution":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: palindromes = set() def is_palindrome(sub: str) -> bool: return sub == sub[::-1] n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes, key=lambda x: (len(x), x))"},{"question":"# Problem: Circular Queue Implementation and Operations You are building a custom queue management system for a printer spooler. To efficiently manage and cycle through print jobs, you decide to implement a circular queue (also known as a circular buffer). Requirements: 1. **Implement a method `enqueue(data: int) -> bool`**: - This method should insert the specified data into the queue. - If the queue is full, the method should return `False`. - If the insertion is successful, the method should return `True`. 2. **Implement a method `dequeue() -> int | None`**: - This method should remove and return the front data from the queue. - If the queue is empty, return `None`. 3. **Implement a method `front() -> int | None`**: - This method should return the front element of the queue without removing it. - If the queue is empty, return `None`. Function Signatures: ```python class CircularQueue: def __init__(self, k: int) -> None: # Initialization with given capacity k def enqueue(self, data: int) -> bool: # Code for enqueue def dequeue(self) -> int | None: # Code for dequeue def front(self) -> int | None: # Code for front ``` Input/Output Formats: - `enqueue(data: int) -> bool` - Input: Data (integer) - Output: Boolean indicating success or failure of the operation - `dequeue() -> int | None` - Input: None - Output: Front element\'s data (integer) or None - `front() -> int | None` - Input: None - Output: Front element\'s data (integer) or None Constraints: - All operations on the circular queue should be performed in O(1) time. - The queue should have a fixed capacity specified during initialization. - Ensure proper handling of edge cases, such as enqueueing into a full queue and dequeuing from an empty queue. Here is an example to illustrate the usage of the CircularQueue class: ```python cq = CircularQueue(3) # Initialize a queue with capacity 3 print(cq.enqueue(10)) # True print(cq.enqueue(20)) # True print(cq.front()) # 10 print(cq.dequeue()) # 10 print(cq.enqueue(30)) # True print(cq.enqueue(40)) # True print(cq.enqueue(50)) # False, queue is full print(cq.front()) # 20 ```","solution":"class CircularQueue: def __init__(self, k: int) -> None: self.queue = [None] * k self.max_size = k self.front_index = 0 self.rear_index = 0 self.size = 0 def enqueue(self, data: int) -> bool: if self.size == self.max_size: return False self.queue[self.rear_index] = data self.rear_index = (self.rear_index + 1) % self.max_size self.size += 1 return True def dequeue(self) -> int | None: if self.size == 0: return None data = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.max_size self.size -= 1 return data def front(self) -> int | None: if self.size == 0: return None return self.queue[self.front_index]"},{"question":"# Recursive Sum Calculation Background: Recursion is a programming technique where a function calls itself in order to solve a problem. Recursive methods can simplify the code required to solve complex problems that have self-similar sub-problems. Task: You are required to implement the function `recursive_sum` which calculates the sum of all integers from 1 up to `n` inclusively using recursion. The function should handle edge cases appropriately and raise appropriate errors for non-natural numbers. Function Signature: ```python def recursive_sum(n: int) -> int: Calculate the sum of all positive integers up to and including n using recursion. Input Parameter: n (int): The upper limit integer up to which the sum is to be calculated. Returns: int: The sum of all integers from 1 to n. Raises: ValueError: If n is not a natural number (i.e., not a positive integer). ``` Example Tests: ```python >>> recursive_sum(1) 1 >>> recursive_sum(3) 6 # 1 + 2 + 3 >>> recursive_sum(5) 15 # 1 + 2 + 3 + 4 + 5 >>> recursive_sum(10) 55 # 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 >>> recursive_sum(0) Traceback (most recent call last): ... ValueError: Input must be a natural number (positive integer) >>> recursive_sum(-5) Traceback (most recent call last): ... ValueError: Input must be a natural number (positive integer) >>> recursive_sum(3.5) Traceback (most recent call last): ... ValueError: Input must be a natural number (positive integer) ``` Constraints: * The function should handle integers from 1 to very large numbers if needed and ensure input parameters are realistic. * Ensure that the recursion approach does not result in maximum recursion depth error for feasible values of `n`.","solution":"def recursive_sum(n: int) -> int: Calculate the sum of all positive integers up to and including n using recursion. Input Parameter: n (int): The upper limit integer up to which the sum is to be calculated. Returns: int: The sum of all integers from 1 to n. Raises: ValueError: If n is not a natural number (i.e., not a positive integer). if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a natural number (positive integer)\\") if n == 1: return 1 return n + recursive_sum(n - 1)"},{"question":"**Scenario**: You are developing a recursive function to compute the greatest common divisor (GCD) of two numbers. This question will test your understanding of recursion, mathematical concepts, and function implementation. **Problem Statement**: Write a function `gcd(a: int, b: int) -> int` that computes the greatest common divisor of two given integers `a` and `b` using the Euclidean algorithm. # Function Signature ```python def gcd(a: int, b: int) -> int: ``` # Input * `a` (1 <= a <= 10^9): An integer representing the first number. * `b` (1 <= b <= 10^9): An integer representing the second number. # Output * An integer representing the greatest common divisor of `a` and `b`. # Constraints * Ensure your solution uses recursion to calculate the GCD. * The function should handle edge cases where one of the numbers is much larger than the other. # Example ```python >>> gcd(48, 18) 6 # because the greatest common divisor of 48 and 18 is 6. >>> gcd(100, 25) 25 # because the greatest common divisor of 100 and 25 is 25. >>> gcd(13, 29) 1 # because 13 and 29 are prime numbers and their greatest common divisor is 1. >>> gcd(270, 192) 6 # because the greatest common divisor of 270 and 192 is 6. ``` # Note - The Euclidean algorithm is an efficient way to compute the GCD of two integers. - The function should handle cases where either `a` or `b` is 1. - Test the function with large values to ensure efficiency and correctness.","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two integers using the Euclidean algorithm recursively. if b == 0: return a else: return gcd(b, a % b)"},{"question":"# Coding Assessment Question **Problem Statement**: You are provided with a list of customer orders for products in an e-commerce system. Each order contains a customer ID and a product ID. Your task is to implement an algorithm to find the most frequently ordered product in the system. If there are multiple products with the same highest frequency, return all such products in ascending order. **Function Signature**: ```python def most_frequent_products(orders: List[Tuple[int, int]]) -> List[int]: ``` **Input**: - `orders`: A list of tuples, where each tuple `(customer_id, product_id)` represents an order made by the customer with ID `customer_id` for the product with ID `product_id`. **Output**: - Returns a list of integers representing the product IDs of the most frequently ordered products, sorted in ascending order. **Example**: ```python orders = [(1, 100), (2, 200), (1, 100), (3, 200), (4, 100)] Output: [100] orders = [(1, 101), (2, 101), (3, 202), (4, 202), (5, 101)] Output: [101, 202] ``` **Constraints**: - `0 <= len(orders) <= 10^5` - The values for `customer_id` and `product_id` are non-negative integers. - Each customer can order multiple different products, and a product can be ordered by multiple customers. **Hints**: 1. Use a dictionary to count the occurrences of each product ID. 2. Identify the maximum frequency of orders. 3. Collect all products with this maximum frequency and return them sorted in ascending order. **Performance Requirements**: - The solution should handle the input size efficiently. - Aim for a time complexity of O(n log k) where n is the number of orders and k is the number of unique products, considering the sorting step. Write the function `most_frequent_products` that accurately implements the above requirements, taking into account all necessary considerations for various edge cases and constraints.","solution":"from typing import List, Tuple from collections import defaultdict def most_frequent_products(orders: List[Tuple[int, int]]) -> List[int]: Finds the most frequently ordered product(s) in the e-commerce system. Parameters: orders (List[Tuple[int, int]]): A list of tuples where each tuple contains (customer_id, product_id). Returns: List[int]: A list of product IDs of the most frequently ordered products, sorted in ascending order. if not orders: return [] product_count = defaultdict(int) for _, product_id in orders: product_count[product_id] += 1 max_frequency = max(product_count.values()) most_frequent = [product_id for product_id, count in product_count.items() if count == max_frequency] return sorted(most_frequent)"},{"question":"Question: Spam Email Classification Using Random Forest You are tasked with classifying a given set of emails as either spam or not spam using a Random Forest classifier. The goal is to train a Random Forest model on the provided dataset and then evaluate its performance based on Accuracy and F1 Score. # Task 1. **Data Handling** - Write a function `data_handling(data: dict) -> tuple` that takes a dictionary containing the email features and target values. This function should return a tuple containing the feature data (`data[\'data\']`) and the target values (`data[\'target\']`). 2. **Model Training and Prediction** - Write a function `random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray` that: - Initializes and trains a Random Forest classifier on the provided training features and target values. - Predicts the target values for the given test features. - Returns the predictions. 3. **Main Function** - Write a function `main()` that: - Loads the provided spam email dataset. - Handles the dataset using the `data_handling` function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the `random_forest` function. - Computes and prints the Accuracy and F1 Score of the predictions. # Constraints - Do not alter the structure of the dataset. - Ensure reproducibility with a fixed random state of 42. - Handle edge cases where the dataset might have missing or NaN values. # Example ```python import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: return (data[\'data\'], data[\'target\']) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: rf = RandomForestClassifier(random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: # Example dataset (to be replaced with the actual dataset) example_data = { \\"data\\": np.random.rand(1000, 57), # 1000 samples, 57 features per sample \\"target\\": np.random.randint(2, size=1000) # Binary targets: 0 or 1 } data, target = data_handling(example_data) x_train, x_test, y_train, y_test = train_test_split(data, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"F1 Score: {f1_score(y_test, predictions)}\\") if __name__ == \\"__main__\\": main() ``` # Expected Results You should expect the following metrics: - **Accuracy**: ~0.90 (when using a real spam dataset) - **F1 Score**: ~0.85 (when using a real spam dataset)","solution":"import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: features = np.nan_to_num(data[\'data\']) target = np.nan_to_num(data[\'target\']) return (features, target) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: rf = RandomForestClassifier(random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: # Example dataset (to be replaced with the actual dataset) example_data = { \\"data\\": np.random.rand(1000, 57), # 1000 samples, 57 features per sample \\"target\\": np.random.randint(2, size=1000) # Binary targets: 0 or 1 } data, target = data_handling(example_data) x_train, x_test, y_train, y_test = train_test_split(data, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"F1 Score: {f1_score(y_test, predictions)}\\") if __name__ == \\"__main__\\": main()"},{"question":"Implement a class `InvertedIndex` which allows you to build an inverted index from a list of documents. Each document is represented as a string, and an inverted index maps each word to a list of document indices in which the word appears. 1. **Document Addition**: - Implement a method `add_document` to add a single document string to the inverted index. - Each word in the document should be converted to lowercase, and should exclude punctuation. 2. **Search**: - Implement a method `search` that takes a word and returns the list of document indices where the word appears. 3. **Performance**: - Ensure efficient search operations by using appropriate data structures. # Class Definition: ```python import re from collections import defaultdict from typing import List, Dict class InvertedIndex: def __init__(self): self.index = defaultdict(list) self.documents = [] def add_document(self, document: str) -> None: # Your implementation here def search(self, word: str) -> List[int]: # Your implementation here ``` # Methods Explanation: - `add_document`: Adds a new document to the index and updates the inverted index with the words from the document. - `document` (str): The document to be added. - `search`: Searches for a word in the index and returns a list of document indices where the word appears. - `word` (str): The word to search for. # Example Usage: ```python docs = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"Never jump over the lazy dog quickly.\\", \\"Brown dogs are quick and jump high.\\" ] index = InvertedIndex() for doc in docs: index.add_document(doc) print(index.search(\\"quick\\")) # Output: [0, 2] print(index.search(\\"lazy\\")) # Output: [0, 1] print(index.search(\\"dog\\")) # Output: [0, 1] ``` # Constraints: - Assume that the documents are non-empty strings. - Consider words to be sequences of alphanumeric characters and punctuation should be ignored. - The search method should perform efficiently even with a large number of documents. This class should allow performant searches and efficient document additions, leveraging the inverted index structure to map words to document positions.","solution":"import re from collections import defaultdict from typing import List, Dict class InvertedIndex: def __init__(self): self.index = defaultdict(list) self.documents = [] def _tokenize(self, document: str) -> List[str]: Tokenize the document into words, converting to lower case and removing punctuation. return re.findall(r\'bw+b\', document.lower()) def add_document(self, document: str) -> None: Adds a new document to the index and updates the inverted index with the words from the document. doc_index = len(self.documents) self.documents.append(document) words = self._tokenize(document) for word in words: if doc_index not in self.index[word]: self.index[word].append(doc_index) def search(self, word: str) -> List[int]: Searches for a word in the index and returns a list of document indices where the word appears. word = word.lower() return self.index[word]"},{"question":"# Context In data processing, particularly when dealing with text data, one common task is finding the most frequent word in a given text. This task is often used in text analysis, natural language processing, and search engines. You are tasked with implementing a function that identifies the most frequent word in a string of text. # Objective Write a Python function `most_frequent_word` that takes a string of text and returns the most frequently occurring word in that text. The function should handle various constraints and validate inputs appropriately. # Requirements 1. The function should accept exactly one parameter: `text`, a string of arbitrary length. 2. The function should return the most frequent word in the string. If there is a tie, return one of the most frequent words (any one of them is acceptable). 3. The function should handle input validation: - If the input is not a string, raise a `TypeError`. - If the string is empty, return an empty string. # Implementation Details - Convert the text to lowercase and split it into words using space as the delimiter. - Use a dictionary to count the occurrences of each word. - Identify and return the word with the highest frequency. - Ensure input validation as specified. # Input Format - `text` (str): A string of arbitrary length. # Output Format - A string representing the most frequently occurring word. # Examples 1. `most_frequent_word(\\"the quick brown fox jumps over the lazy dog\\")` returns `\'the\'` 2. `most_frequent_word(\\"hello world hello again\\")` returns `\'hello\'` 3. `most_frequent_word(\\"one two two three three three\\")` returns `\'three\'` 4. `most_frequent_word(\\"a b c d e f g a b c d e a b c\\")` returns `\'a\'` 5. `most_frequent_word(\\"\\")` returns `\'\'` 6. `most_frequent_word(\\"Python Python python\\")` returns `\'python\'` 7. `most_frequent_word([\'this\', \'is\', \'not\', \'a\', \'string\'])` raises `TypeError: Input must be a string` # Constraints - Ensure the function performs efficiently for typical use cases. - The words in text will be separated by single spaces only. Implement the function according to the requirements and constraints specified.","solution":"def most_frequent_word(text): Returns the most frequently occurring word in the given text. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") if text == \\"\\": return \\"\\" word_count = {} words = text.lower().split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_count = max(word_count.values()) for word, count in word_count.items(): if count == max_count: return word"},{"question":"# Deck of Cards Simulation You are tasked with simulating a basic deck of cards and implementing functions to perform essential operations. The deck should include standard 52 playing cards without jokers. 1. **Deck Initialization**: Create a class `Deck` that initializes a standard 52-card deck. Each card should have a rank (\\"2\\" to \\"10\\", \\"J\\", \\"Q\\", \\"K\\", \\"A\\") and a suit (\\"Hearts\\", \\"Diamonds\\", \\"Clubs\\", \\"Spades\\"). 2. **Shuffling the Deck**: Implement a method to shuffle the deck randomly. 3. **Drawing a Card**: Add functionality to draw a card from the top of the deck. Ensure that drawn cards are properly removed from the deck. 4. **Resetting the Deck**: Implement a method to reset the deck back to the full 52 cards and shuffle it again. # Input and Output Format * Implement a `Deck` class with the following: * `__init__()`: Initializes the deck with 52 cards. * `shuffle_deck() -> None`: Shuffles the deck randomly. * `draw_card() -> Tuple[str, str]`: Draws the top card from the deck and returns it as a tuple `(rank, suit)`. * `reset_deck() -> None`: Resets the deck to the full 52 cards and shuffles it. # Constraints * Each method should run in optimal time concerning the number of cards. * Use Python\'s built-in libraries for random shuffling. # Examples ```python # Example usage: deck = Deck() # Shuffle the deck deck.shuffle_deck() # Draw a card card = deck.draw_card() print(card) # Should print a tuple representing a card, e.g., (\'A\', \'Hearts\') # Draw another card card = deck.draw_card() print(card) # Should print another card e.g., (\'3\', \'Diamonds\') # Reset the deck deck.reset_deck() # Draw a card from the reset and shuffled deck card = deck.draw_card() print(card) # Should print a card, e.g., (\'K\', \'Spades\') # Ensure the deck has 52 unique cards initially or after reset # drawing all cards should check no duplicates or missing cards. ``` Implement the `Deck` class based on the above requirements and guidelines.","solution":"import random from typing import List, Tuple class Deck: def __init__(self): self._full_deck = self._initialize_deck() self.deck = list(self._full_deck) def _initialize_deck(self) -> List[Tuple[str, str]]: suits = [\\"Hearts\\", \\"Diamonds\\", \\"Clubs\\", \\"Spades\\"] ranks = [\\"2\\", \\"3\\", \\"4\\", \\"5\\", \\"6\\", \\"7\\", \\"8\\", \\"9\\", \\"10\\", \\"J\\", \\"Q\\", \\"K\\", \\"A\\"] return [(rank, suit) for suit in suits for rank in ranks] def shuffle_deck(self) -> None: random.shuffle(self.deck) def draw_card(self) -> Tuple[str, str]: if not self.deck: raise IndexError(\\"Cannot draw from an empty deck\\") return self.deck.pop() def reset_deck(self) -> None: self.deck = list(self._full_deck) self.shuffle_deck()"},{"question":"# Problem: Implement a Basic Calculator with Addition and Subtraction You are tasked with writing a function to evaluate a simple expression string containing only non-negative integers, plus \'+\', minus \'-\', and empty spaces \' \'. The expression will be valid, so there will be no need to check for invalid input. # Function Signature ```python def basic_calculator(expression: str) -> int: ``` # Input * `expression`: A string representing a mathematical expression composed of non-negative integers, \'+\', \'-\', and spaces. # Output * Returns the result of the evaluated expression as an integer. # Examples ```python >>> basic_calculator(\\"3 + 2 - 1\\") 4 >>> basic_calculator(\\" 10 + 4 - 7 \\") 7 >>> basic_calculator(\\"100 - 3 + 25\\") 122 >>> basic_calculator(\\" 0 + 0 - 0 \\") 0 ``` # Constraints * The input expression will not be empty and will contain only valid characters. * The integer values in the expression will fit within the range of a standard 32-bit signed integer. # Performance Requirements * Your solution should handle the length of the expression up to 10,000 characters efficiently. # Edge Cases to Consider * Expressions with leading, trailing, or multiple spaces. * Large numbers and long expressions. * Ensure the correct handling of spaces and the absence of operators at the edges. [indexes]","solution":"def basic_calculator(expression: str) -> int: Evaluate a simple expression string containing non-negative integers, \'+\', \'-\', and empty spaces. :param expression: str - A string representing a mathematical expression :return: int - The result of the evaluated expression # Remove spaces from the expression expression = expression.replace(\' \', \'\') # Initialize variables current_number = 0 result = 0 sign = 1 # 1 for positive, -1 for negative for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == \'+\': result += sign * current_number current_number = 0 sign = 1 elif char == \'-\': result += sign * current_number current_number = 0 sign = -1 # Add the last number to result result += sign * current_number return result"},{"question":"# Question Description Context Processing collections of numerical data often involves identifying and extracting significant elements within the data. One common task is to find the unique elements within a list of numbers. Task You are required to design a function to return a list of unique elements in the input list while maintaining the original order of their first occurrence. Detailed Instructions * **Function Signature**: ```python def unique_elements(nums: List[int]) -> List[int]: Extract unique elements from the list, preserving their order of first appearance. :param nums: List of integers. :return: A list of integers that are unique in the input list. ``` * **Expected Input and Output Formats**: * The function accepts a single list `nums` of integers. * The function returns a new list containing only the unique integers, in the same order as their first appearance. * **Constraints**: * Ensure the input is a list of integers. * The input list can be empty. * Duplicate elements should only appear once in the result, in the order they first appeared in the input list. * **Performance Requirements**: The function should run in linear time, i.e., O(n), where n is the length of the list. Examples: ```python >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1, 1]) [1] >>> unique_elements([6, 7, 8, 9, 6, 7, 8, 9]) [6, 7, 8, 9] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([]) [] >>> unique_elements([10, 10, 20, 20]) [10, 20] ``` Edge Cases: 1. If the input list is empty, the function should return an empty list. 2. If the input list contains all duplicate elements, the function should return a list containing one of each duplicate. 3. The function should correctly handle negative integers and zero.","solution":"from typing import List def unique_elements(nums: List[int]) -> List[int]: seen = set() unique_list = [] for num in nums: if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"# Deepest Node in a Binary Tree Scenario You are tasked with determining the deepest node in a binary tree for a data processing application that needs to identify the last inserted or deepest element in a hierarchical structure. Task Implement the `deepest_node` function, which locates the deepest (or a most recently added) node in a binary tree. Function Signature ```python def deepest_node(root: Optional[TreeNode]) -> Optional[int]: ``` Input * `root`: The root node of a binary tree. Output An integer representing the value of the deepest node. If the tree is empty, return `None`. Constraints * The tree nodes (`TreeNode`) have the following attributes: - `val`: The integer value of the node. - `left`: Left child node. - `right`: Right child node. * The number of nodes in the tree is in the range [0, (10^5)]. * The tree could be unbalanced. Example Consider the following binary tree: ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right # Example Binary Tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) # Running the function deepest = deepest_node(root) # Expected Output # Deepest Node: 7 ``` Performance Requirements Make sure the function can handle trees with up to (10^5) nodes efficiently. This ensures it can process large structures in a realistic time frame for practical applications.","solution":"from collections import deque from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def deepest_node(root: Optional[TreeNode]) -> Optional[int]: if not root: return None queue = deque([root]) current = None while queue: current = queue.popleft() if current.left: queue.append(current.left) if current.right: queue.append(current.right) return current.val if current else None"},{"question":"# Question: Implement a Task Scheduler for Dependent Tasks **Context**: You are developing a task scheduler for a project management tool. In this tool, tasks can have dependencies, meaning one task cannot start until another one finishes. You need to implement an algorithm to determine the correct order to execute all tasks while respecting their dependencies. You will implement a function `task_scheduler` that takes in a list of tasks and their dependencies and returns a valid order of task execution, or indicates that no valid order exists (i.e., there is a circular dependency). **Function Signature**: ```python def task_scheduler(num_tasks: int, dependencies: list[tuple[int, int]]) -> list[int]: pass ``` **Input**: - `num_tasks`: An integer representing the total number of tasks, numbered from 0 to num_tasks-1. - `dependencies`: A list of tuples where each tuple (a, b) represents a dependency that task `a` must be completed before task `b` can start. **Output**: - Returns a list of integers representing a valid order of task execution, or an empty list if no such order exists due to circular dependencies. **Constraints**: - `0 ≤ num_tasks ≤ 1000` - The size of `dependencies` will not exceed 2000. **Example**: ```python num_tasks = 4 dependencies = [ (1, 0), # Task 1 must be completed before task 0 (2, 1), # Task 2 must be completed before task 1 (3, 1) # Task 3 must be completed before task 1 ] task_scheduler(num_tasks, dependencies) # Expected output: [2, 3, 1, 0] or [3, 2, 1, 0] ``` # Guidelines: 1. Use topological sorting to determine the order of tasks while respecting the given dependencies. 2. Handle edge cases, such as circular dependencies, where no valid order exists, and return an appropriate result. 3. Consider utilizing graph traversal algorithms, like Depth-First Search (DFS) or Kahn’s algorithm, to solve the problem efficiently.","solution":"from collections import deque, defaultdict def task_scheduler(num_tasks, dependencies): Determines the correct order to execute tasks with dependencies. :param num_tasks: Total number of tasks :param dependencies: List of tuples representing dependencies :return: A list representing a valid order of tasks or an empty list if a circular dependency exists # Edge case if num_tasks == 0: return [] # Build the graph using adjacency list and in-degree count adj_list = defaultdict(list) in_degree = [0] * num_tasks for (src, dst) in dependencies: adj_list[src].append(dst) in_degree[dst] += 1 # Initialize the queue with all nodes with in-degree 0 queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) ordered_tasks = [] while queue: node = queue.popleft() ordered_tasks.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If ordered_tasks includes all tasks, no circular dependency is present, otherwise, there is a cycle if len(ordered_tasks) == num_tasks: return ordered_tasks else: return []"},{"question":"# Question You are asked to implement a function `find_common_elements` that takes two lists of integers and returns a list of their common elements in the order they appear in the first list. Specifications - Function: `find_common_elements(list1: list[int], list2: list[int]) -> list[int]` - **Input**: - `list1`: First list of integers to analyze. - `list2`: Second list of integers to analyze. - **Output**: - A list of integers representing the common elements in the order they appear in the first list. Constraints - The elements in each list are unique. - Length of each list: 1 to 10,000. Example ```python >>> list1 = [1, 2, 3, 4, 5] >>> list2 = [3, 4, 5, 6, 7] >>> find_common_elements(list1, list2) [3, 4, 5] >>> list1 = [7, 8, 9, 10] >>> list2 = [5, 6, 7, 8] >>> find_common_elements(list1, list2) [7, 8] >>> list1 = [1, 2, 3] >>> list2 = [4, 5, 6] >>> find_common_elements(list1, list2) [] ```","solution":"def find_common_elements(list1, list2): Returns a list of common elements between list1 and list2 in the order they appear in list1. set2 = set(list2) return [element for element in list1 if element in set2]"},{"question":"# Coding Question You are given a non-negative integer. Your task is to check if its digits form a strictly increasing sequence (each digit is greater than the previous one) starting from a specified index. Write a function that determines whether the digits from a given starting index form such a sequence. # Function Signature ```python def is_strictly_increasing(num: int, start_index: int) -> bool: pass ``` # Input * `num` (int): The non-negative integer to be checked. * `start_index` (int): The starting index from which to check the sequence. # Output * `bool`: Returns `True` if the digits starting from `start_index` form a strictly increasing sequence, otherwise `False`. # Constraints * `num >= 0` * `0 <= start_index < len(str(num))` # Example ```python assert is_strictly_increasing(123456, 0) == True assert is_strictly_increasing(987654, 2) == False assert is_strictly_increasing(14579, 1) == True assert is_strictly_increasing(13245, 2) == True assert is_strictly_increasing(122354, 0) == False ``` # Explanation - For the integer `123456` starting from index `0`, the digits `1, 2, 3, 4, 5, 6` form a strictly increasing sequence. - For the integer `987654` starting from index `2`, the digits `7, 6, 5, 4` do not form a strictly increasing sequence. - For the integer `14579` starting from index `1`, the digits `4, 5, 7, 9` form a strictly increasing sequence. - For the integer `13245` starting from index `2`, the digits `2, 4, 5` form a strictly increasing sequence. - For the integer `122354` starting from index `0`, the digits `1, 2, 2, 3, 5, 4` do not form a strictly increasing sequence because `2` is not greater than `2` in the sequence. **Considerations**: - Convert the integer to its string representation to iterate through digits. - Check the sequence from the given start index and compare each digit with the previous one. - Ensure the sequence starting from the index forms a strictly increasing order.","solution":"def is_strictly_increasing(num: int, start_index: int) -> bool: Checks if the digits of the number starting from the specified index form a strictly increasing sequence. :param num: A non-negative integer to check. :param start_index: The starting index from where to check the sequence. :return: True if digits starting from start_index form a strictly increasing sequence, False otherwise. num_str = str(num) for i in range(start_index, len(num_str) - 1): if num_str[i] >= num_str[i + 1]: return False return True"},{"question":"# Problem Statement Given a list of words, your task is to find the maximum product of the lengths of any two words that do not share any common letters. You need to write a function that returns this maximum product. # Function Signature: ```python def max_product_of_word_lengths(words: List[str]) -> int: ``` # Input: - `words`: A list of strings, where each string consists only of lowercase English letters. The length of the list is between 1 and 10^4. Each word\'s length is between 1 and 1000. # Output: - Returns an integer representing the maximum product of lengths of two words that do not share any common letters. # Constraints: - Each word contains only lowercase English letters (\'a\' to \'z\'). # Example: ```python words = [\\"abcw\\", \\"baz\\", \\"foo\\", \\"bar\\", \\"xtfn\\", \\"abcdef\\"] print(max_product_of_word_lengths(words)) # Output: 16 words = [\\"a\\", \\"ab\\", \\"abc\\", \\"d\\", \\"cd\\", \\"bcd\\", \\"abcd\\"] print(max_product_of_word_lengths(words)) # Output: 4 ``` # Notes: - A word is considered to \\"not share common letters\\" with another word if there are no overlapping characters between the two words. - An efficient solution should be used since the input size can be large. - Use bit manipulation to optimize the comparison of whether two words share common letters.","solution":"from typing import List def max_product_of_word_lengths(words: List[str]) -> int: def get_bitmask(word): bitmask = 0 for char in word: bitmask |= 1 << (ord(char) - ord(\'a\')) return bitmask n = len(words) bitmasks = [get_bitmask(word) for word in words] max_product = 0 for i in range(n): for j in range(i + 1, n): if bitmasks[i] & bitmasks[j] == 0: max_product = max(max_product, len(words[i]) * len(words[j])) return max_product"},{"question":"# Circular Linked List Detection You are working as a software developer for a company that handles large amounts of linked list data. One common problem you have encountered is the detection of circular references within linked lists. Your task is to implement a function that detects whether a given singly linked list has a cycle or not. Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: This function checks whether the given singly linked list contains a cycle. :param head: The head node of the linked list. :return: True if there is a cycle in the linked list, otherwise False. ``` Input 1. **head**: The head node of the singly linked list. Output * A boolean value: `True` if there is a cycle in the linked list, otherwise `False`. Constraints * The size of the linked list is at most (10^4). * Node values are integers. Example ```python # Creating a linked list: 3 -> 2 -> 0 -> -4 (creates a cycle by connecting -4 to the node with value 2) node1 = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Cycle here assert has_cycle(node1) == True # Creating a linked list: 1 -> 2 (no cycle) node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = None assert has_cycle(node1) == False ``` Notes * Consider using Floyd’s Cycle-Finding Algorithm, also known as Tortoise and Hare Algorithm, which has a time complexity of (O(n)) and a space complexity of (O(1)). * Ensure all edge cases are handled, including empty lists and single-node lists without cycles.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: This function checks whether the given singly linked list contains a cycle. :param head: The head node of the linked list. :return: True if there is a cycle in the linked list, otherwise False. if head is None or head.next is None: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Scenario: You are building a basic arithmetic processing unit for an educational robotics kit. One of the features required is a custom modulo operation. The custom modulo operation should determine the remainder when one positive integer is divided by another, with a specific rule: if the dividend is smaller than the divisor, the remainder should be the dividend itself. Given the function definition below, implement the custom modulo operation. # Function Specification **Function name**: `custom_modulo` **Input**: - `dividend` (int): The number to be divided (1 ≤ dividend ≤ 10^6). - `divisor` (int): The number by which to divide (1 ≤ divisor ≤ 10^6). **Output**: - (int): The result of the custom modulo operation. **Constraints**: - Both inputs will always be positive integers. **Examples**: ```python >>> custom_modulo(10, 3) 1 >>> custom_modulo(7, 7) 0 >>> custom_modulo(5, 10) 5 ``` # Task: Complete the implementation of the `custom_modulo` function to correctly compute the output based on the given description.","solution":"def custom_modulo(dividend, divisor): Returns the custom modulo operation result of the given dividend and divisor. If the dividend is smaller than the divisor, it returns the dividend itself. Otherwise, it returns the remainder when dividend is divided by divisor. if dividend < divisor: return dividend else: return dividend % divisor"},{"question":"# Problem: Number of Sunny Days in a Weather Data Set You are tasked with writing a function `count_sunny_days` that calculates the number of sunny days in a given dataset. Each entry in the dataset represents weather information for a particular day and includes the following information: date, temperature, and a description of the day\'s weather. The weather descriptions use specific keywords to indicate a sunny day, including \\"sunny\\", \\"clear\\", and \\"bright\\". Your function should use these keywords to identify and count sunny days. # Function Signature ```python def count_sunny_days(weather_data: List[Dict[str, str]]) -> int: pass ``` # Input 1. `weather_data` (List of dictionaries): Each dictionary contains: * `date` (string): The date in \'yyyy-mm-dd\' format. * `temperature` (string): The temperature as a string. * `description` (string): A textual description of the day\'s weather. # Output * An integer representing the number of days with sunny weather. # Examples ```python weather_data = [ {\\"date\\": \\"2023-01-01\\", \\"temperature\\": \\"15C\\", \\"description\\": \\"sunny and warm\\"}, {\\"date\\": \\"2023-01-02\\", \\"temperature\\": \\"8C\\", \\"description\\": \\"cold and clear\\"}, {\\"date\\": \\"2023-01-03\\", \\"temperature\\": \\"-2C\\", \\"description\\": \\"snow and wind\\"}, {\\"date\\": \\"2023-01-04\\", \\"temperature\\": \\"10C\\", \\"description\\": \\"cloudy and rainy\\"}, {\\"date\\": \\"2023-01-05\\", \\"temperature\\": \\"12C\\", \\"description\\": \\"bright and breezy\\"}, ] print(count_sunny_days(weather_data)) # Expected Output: 3 ``` # Constraints 1. The list `weather_data` will contain between 1 and 10,000 dictionaries. 2. The `temperature` string will always be followed by \\"C\\". 3. The weather `description` will have a length of at most 50 characters. 4. The `date` will always be in the format \'yyyy-mm-dd\'. # Scenario You are working on a weather analysis tool that needs to provide users with meaningful insights about sunny days. You will need to parse through large datasets and accurately count the number of sunny days based on the given descriptions.","solution":"from typing import List, Dict def count_sunny_days(weather_data: List[Dict[str, str]]) -> int: sunny_keywords = {\\"sunny\\", \\"clear\\", \\"bright\\"} sunny_days_count = 0 for entry in weather_data: description = entry.get(\\"description\\", \\"\\").lower() if any(keyword in description for keyword in sunny_keywords): sunny_days_count += 1 return sunny_days_count"},{"question":"# Context: Graph traversal is an important concept in computer science, particularly in the fields of computer networks and artificial intelligence. Breadth-First Search (BFS) is a popular algorithm used for traversing or searching tree or graph data structures. Your task is to implement BFS to count the number of nodes reachable from a given starting node within a graph. # Task: Write a function `reachable_nodes(graph: Dict[int, List[int]], start: int) -> int` that returns the number of nodes reachable from the `start` node using BFS. # Input: * A dictionary `graph` representing an undirected graph where keys are node identifiers (integers) and values are lists of adjacent nodes. * An integer `start` representing the starting node for the BFS traversal. # Output: * An integer representing the number of nodes reachable from the `start` node using BFS. # Constraints: * The graph can have up to `10^5` nodes. * Ensure the function handles large graphs efficiently. * Nodes may not be connected, and isolated nodes should be handled appropriately. * You may assume that the `start` node is always a valid node present in the graph. # Requirements: * Implement BFS without using recursion to avoid stack overflow on large graphs. * Ensure the function gracefully handles edge cases such as an empty graph or isolated nodes. Example Usage: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } print(reachable_nodes(graph, 0)) # Expected output: 5 graph = { 0: [1], 1: [0, 2], 2: [1], ... } print(reachable_nodes(graph, 1)) # Expected output: 3 ```","solution":"from collections import deque from typing import Dict, List def reachable_nodes(graph: Dict[int, List[int]], start: int) -> int: Returns the number of nodes reachable from the start node using BFS. :param graph: Dictionary representation of the graph. :param start: Starting node for BFS. :return: Number of reachable nodes. if start not in graph: return 0 visited = set() queue = deque([start]) reachable_count = 0 while queue: node = queue.popleft() if node not in visited: visited.add(node) reachable_count += 1 for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return reachable_count"},{"question":"# Scenario E-commerce platforms often need to manage large inventories and process bulk data updates efficiently. Suppose you are developing a utility to update the prices of products in an inventory database. The inventory is stored as a list of dictionaries, where each dictionary contains the product\'s information. The price updates are provided as a list of tuples containing the product\'s ID and the new price. Your task is to implement a Python function to update the prices based on the provided updates list. # Task Implement a Python function `update_inventory_prices(inventory: List[dict], price_updates: List[tuple]) -> List[dict]` that performs the following: 1. Takes the inventory list and the price_updates list as input. 2. Updates the prices of the products in the inventory based on the provided price updates. 3. Returns the updated inventory list. # Constraints * `inventory` is a list of dictionaries, where each dictionary contains the fields `id` (str), `name` (str), and `price` (float). * `price_updates` is a list of tuples, where each tuple contains an `id` (str) and a `new_price` (float). * If a product ID in the `price_updates` does not exist in the `inventory`, it should be ignored. * Assume all `id`s in the `inventory` are unique. * Ensure to handle edge cases, such as an empty inventory or price_updates list gracefully. # Function Signature ```python from typing import List, Dict, Tuple def update_inventory_prices(inventory: List[Dict[str, any]], price_updates: List[Tuple[str, float]]) -> List[Dict[str, any]]: pass ``` # Example ```python inventory = [ {\'id\': \'p1\', \'name\': \'Product 1\', \'price\': 100.0}, {\'id\': \'p2\', \'name\': \'Product 2\', \'price\': 150.0} ] price_updates = [(\'p1\', 110.0), (\'p3\', 170.0)] result = update_inventory_prices(inventory, price_updates) print(result) # Output: [{\'id\': \'p1\', \'name\': \'Product 1\', \'price\': 110.0}, {\'id\': \'p2\', \'name\': \'Product 2\', \'price\': 150.0}] ``` # Requirements * Handle edge cases where the inventory or price_updates list is empty. * Ensure that only valid product IDs in the price_updates list lead to price updates. * Maintain the original structure of the inventory dictionaries.","solution":"from typing import List, Dict, Tuple def update_inventory_prices(inventory: List[Dict[str, any]], price_updates: List[Tuple[str, float]]) -> List[Dict[str, any]]: # Create a dictionary from the price updates for quick lookup updates_dict = {update[0]: update[1] for update in price_updates} # Iterate through the inventory and update the prices based on the update dictionary for item in inventory: if item[\'id\'] in updates_dict: item[\'price\'] = updates_dict[item[\'id\']] return inventory"},{"question":"# Task You are asked to implement a function to perform matrix multiplication using the Strassen algorithm. This algorithm is particularly effective for large matrices and reduces the time complexity compared to conventional methods. # Problem Statement **Function Signature**: ```python def strassen_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: \'\'\' Parameters: A (List[List[int]]): The first matrix as a list of lists, where each inner list represents a row. B (List[List[int]]): The second matrix with appropriate dimensions for matrix multiplication. Returns: List[List[int]]: The resultant matrix after performing Strassen\'s matrix multiplication. \'\'\' ``` Your task is to implement the `strassen_matrix_multiplication` function, efficiently multiplying the input matrices using Strassen\'s approach. This method is particularly useful for large matrices, with a time complexity of approximately `O(n^2.81)` compared to `O(n^3)` for traditional methods. # Constraints - Matrices `A` and `B` are square matrices of size `2^k x 2^k` where `k` is a non-negative integer. - Elements within the matrices are integers in the range `[-100, 100]`. - The size constraints ensure that the implementation can handle matrices up to a reasonable size within competitive programming limits. # Examples Example 1: * Input: ```python A = [ [1, 0], [0, 1] ] B = [ [4, 1], [2, 2] ] ``` * Output: ```python [ [4, 1], [2, 2] ] ``` Example 2: * Input: ```python A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] ``` * Output: ```python [ [19, 22], [43, 50] ] ``` # Notes * Ensure the implementation is efficient and leverages the divide-and-conquer approach of Strassen\'s algorithm. * Validate the correctness of your function with various test cases, covering edge cases and the smallest matrices. * Handle matrix padding for dimensions not fitting `2^k x 2^k` if necessary. However, it\'s assumed the input matrices will already conform to the size requirements in this task.","solution":"from typing import List def add_matrices(A, B): return [[A[i][j] + B[i][j] for j in range(len(A))] for i in range(len(A))] def subtract_matrices(A, B): return [[A[i][j] - B[i][j] for j in range(len(A))] for i in range(len(A))] def split_matrix(M): mid = len(M) // 2 A11 = [row[:mid] for row in M[:mid]] A12 = [row[mid:] for row in M[:mid]] A21 = [row[:mid] for row in M[mid:]] A22 = [row[mid:] for row in M[mid:]] return A11, A12, A21, A22 def strassen_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if len(A) == 1: # Base case: 1x1 matrix return [[A[0][0] * B[0][0]]] # Split matrices A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) # Calculate intermediate matrices using Strassen\'s formula M1 = strassen_matrix_multiplication(add_matrices(A11, A22), add_matrices(B11, B22)) M2 = strassen_matrix_multiplication(add_matrices(A21, A22), B11) M3 = strassen_matrix_multiplication(A11, subtract_matrices(B12, B22)) M4 = strassen_matrix_multiplication(A22, subtract_matrices(B21, B11)) M5 = strassen_matrix_multiplication(add_matrices(A11, A12), B22) M6 = strassen_matrix_multiplication(subtract_matrices(A21, A11), add_matrices(B11, B12)) M7 = strassen_matrix_multiplication(subtract_matrices(A12, A22), add_matrices(B21, B22)) # Build the resulting matrix C11 = add_matrices(subtract_matrices(add_matrices(M1, M4), M5), M7) C12 = add_matrices(M3, M5) C21 = add_matrices(M2, M4) C22 = add_matrices(subtract_matrices(add_matrices(M1, M3), M2), M6) # Combine into a single result matrix n = len(C11) C = [[0] * (2 * n) for _ in range(2 * n)] for i in range(n): for j in range(n): C[i][j] = C11[i][j] C[i][j + n] = C12[i][j] C[i + n][j] = C21[i][j] C[i + n][j + n] = C22[i][j] return C"},{"question":"# Question Context: As a backend developer, you are working on a JSON-based API service that processes and analyzes data from multiple sources. The API needs to merge multiple nested dictionaries and sum the values of common keys. # Coding Task: Implement a function `merge_and_sum_dicts` that takes as input a list of dictionaries. Each dictionary may contain nested dictionaries. The function should merge all dictionaries and sum the values of common keys at all levels of nesting. # Input: * A list of dictionaries where each dictionary may contain nested dictionaries. * The values in the dictionaries are integers or further nested dictionaries. # Output: * A single dictionary where values of common keys at all levels are summed up. # Constraints: * Values associated with the same key at any nesting level are always integers. * Nested dictionaries only contain other dictionaries or integers. * No more than 10 levels of nesting. # Performance Requirements: * Your solution should be efficient in merging the dictionaries and summing values. * Aim to handle the recursive merging and summing with minimal overhead and clear logic. # Scenario: Consider the following example scenario to better understand the task requirements. ```python def merge_and_sum_dicts(dicts: List[Dict]) -> Dict: # Your implementation here pass # Example: dicts = [ {\'a\': 1, \'b\': {\'x\': 3, \'y\': 5}}, {\'a\': 4, \'b\': {\'x\': 2, \'z\': 1}}, {\'c\': 7, \'b\': {\'y\': 6}} ] # Calling the function should return a merged dictionary where common keys are summed: # { \'a\': 5, \'b\': { \'x\': 5, \'y\': 11, \'z\': 1 }, \'c\': 7 } print(merge_and_sum_dicts(dicts)) # Output: {\'a\': 5, \'b\': {\'x\': 5, \'y\': 11, \'z\': 1}, \'c\': 7} ```","solution":"from typing import Dict, List def merge_and_sum_dicts(dicts: List[Dict]) -> Dict: Merges a list of dictionaries and sums the values of common keys at all levels of nesting. def merge_two_dicts(dict1: Dict, dict2: Dict) -> Dict: result = dict1.copy() for key, value in dict2.items(): if key in result: if isinstance(result[key], dict) and isinstance(value, dict): result[key] = merge_two_dicts(result[key], value) else: result[key] += value else: result[key] = value return result merged_dict = {} for d in dicts: merged_dict = merge_two_dicts(merged_dict, d) return merged_dict"},{"question":"# Shortest Path in Weighted Graph You are given a weighted, undirected graph represented by a list of edges. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given starting node to all other nodes in the graph. The implementation should be efficient and handle the following requirements: 1. **Input**: - `edges`: A list of tuples where each tuple represents an edge with its weight ((u, v, w)), where (u) and (v) are the nodes connected by the edge and (w) is the weight of the edge. - `n`: An integer representing the number of nodes in the graph. - `start`: Integer representing the starting node. - Example: `edges = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 5), (2, 3, 8)]`, `n = 4`, `start = 0` 2. **Output**: - A list of integers representing the shortest path distances from the start node to all nodes. If a node is unreachable, the distance should be set to (infty). - Example: `[0, 3, 1, 8]` 3. **Constraints**: - (1 leq n leq 10^5) - There will be no negative weight edges. 4. **Requirements**: - The solution must be implemented using Dijkstra\'s algorithm, achieving a time complexity of (O(E log V)). - Handle edge cases such as graphs with disconnected components. # Instructions 1. **Function Signature**: Implement the function `dijkstra_shortest_path(edges: list[tuple[int, int, int]], n: int, start: int) -> list[float]`. 2. **Example**: ```python import heapq def dijkstra_shortest_path(edges, n, start): # Your implementation goes here # Test the function edges = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 5), (2, 3, 8)] n = 4 start = 0 print(dijkstra_shortest_path(edges, n, start)) # Output: [0, 3, 1, 8] ``` 3. **Performance**: Ensure your implementation is optimized for large datasets. Make use of appropriate data structures to achieve the required time complexity. Note: Design your solution from scratch and assume the graph will be passed as a list of edges. Consider creating helper functions as needed to manage priority queues and distance updates. Best of luck!","solution":"import heapq def dijkstra_shortest_path(edges, n, start): # Initialize the adjacency list adj_list = [[] for _ in range(n)] for u, v, w in edges: adj_list[u].append((v, w)) adj_list[v].append((u, w)) # Initialize the distances and priority queue distances = [float(\'inf\')] * n distances[start] = 0 pq = [(0, start)] # (distance, node) while pq: current_distance, u = heapq.heappop(pq) # If the distance in the priority queue is not up to date, skip it if current_distance > distances[u]: continue # Iterate over neighbours for v, w in adj_list[u]: distance = current_distance + w # Only consider this new path if it\'s better if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances"},{"question":"# Context Recursive problems are common in interviews to test a candidate\'s understanding of recursion and their ability to break down complex problems into simpler subproblems. # Problem Statement Given an integer `n`, write a function `sum_of_digits(n: int) -> int` that computes the sum of its digits using recursion. # Requirements 1. **sum_of_digits(n: int) -> int**: Returns the sum of the digits of `n`. # Input and Output Formats * **Input**: A single integer `n` (0 <= n <= 10^18). * **Output**: An integer representing the sum of the digits of `n`. # Constraints * The input integer `n` will always be non-negative. * Handle the base case when `n` is zero. # Performance Considerations * Ensure that your recursive solution is efficient and handles large input values correctly. # Example ```python # Example usage: print(sum_of_digits(12345)) # Output: 15 print(sum_of_digits(0)) # Output: 0 print(sum_of_digits(987654321)) # Output: 45 ``` # Edge Cases to Consider * n = 0 * n with all identical digits (e.g., 11111) * n with alternating digits (e.g., 1020304050) * Large values of n Implement the function: ```python def sum_of_digits(n: int) -> int: if n == 0: return 0 return n % 10 + sum_of_digits(n // 10) ```","solution":"def sum_of_digits(n: int) -> int: Computes the sum of the digits of a given integer n using recursion. Args: n (int): The input integer (0 <= n <= 10^18). Returns: int: The sum of the digits of n. if n == 0: return 0 return n % 10 + sum_of_digits(n // 10)"},{"question":"# Coding Task: Implement a Custom JSON Parser You are tasked with creating a simplified version of a JSON parser that can convert JSON strings into Python dictionaries and lists. # Objective Implement a class `SimpleJSONParser` that provides methods to parse JSON strings into appropriate Python data structures. Your parser should handle JSON objects, arrays, strings, numbers, booleans, and `null`. # Details Input * A JSON string containing a valid JSON object or array. Output * A corresponding Python dictionary for JSON objects or a list for JSON arrays. Example ```python parser = SimpleJSONParser() json_str1 = \'{\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false}\' json_str2 = \'[{\\"name\\": \\"Jane\\"}, {\\"name\\": \\"Doe\\"}]\' print(parser.parse(json_str1)) # Expected Output: {\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": False} print(parser.parse(json_str2)) # Expected Output: [{\\"name\\": \\"Jane\\"}, {\\"name\\": \\"Doe\\"}] ``` # Constraints * Your parser must correctly handle nested objects and arrays. * Strings in the JSON might include escaped quotes (e.g., `\\"name\\": \\"John \\"Doe\\"\\"`). * Numbers can be integers or floating-point values. # Performance Requirements * Optimal time complexity: O(n) where n is the size of the input JSON string. * Optimal space complexity: O(n) for the parsed data structure. # Notes * You should manually implement the parsing logic without using libraries such as `json` for parsing. * Handle various edge cases including but not limited to: empty objects/arrays, nested structures, and different data types. ```python class SimpleJSONParser: def __init__(self): self.index = 0 self.json_str = \\"\\" def parse(self, json_str): self.json_str = json_str.strip() self.index = 0 return self._parse_value() def _parse_value(self): char = self.json_str[self.index] if char == \'{\': return self._parse_object() elif char == \'[\': return self._parse_array() elif char == \'\\"\': return self._parse_string() elif char in \'0123456789-\': return self._parse_number() elif self.json_str.startswith(\\"true\\", self.index): self.index += 4 return True elif self.json_str.startswith(\\"false\\", self.index): self.index += 5 return False elif self.json_str.startswith(\\"null\\", self.index): self.index += 4 return None else: raise ValueError(\\"Invalid JSON value\\") def _parse_object(self): obj = {} self.index += 1 # skip \'{\' while self.json_str[self.index] != \'}\': key = self._parse_string() self.index += 1 # skip \':\' value = self._parse_value() obj[key] = value if self.json_str[self.index] == \',\': self.index += 1 # skip \',\' self.index += 1 # skip \'}\' return obj def _parse_array(self): array = [] self.index += 1 # skip \'[\' while self.json_str[self.index] != \']\': value = self._parse_value() array.append(value) if self.json_str[self.index] == \',\': self.index += 1 # skip \',\' self.index += 1 # skip \']\' return array def _parse_string(self): self.index += 1 # skip initial quote string = \\"\\" while self.json_str[self.index] != \'\\"\': if self.json_str[self.index] == \'\': self.index += 1 # skip the escape character string += self.json_str[self.index] self.index += 1 self.index += 1 # skip final quote return string def _parse_number(self): num_str = \\"\\" while self.json_str[self.index] in \'0123456789.-\': num_str += self.json_str[self.index] self.index += 1 if \'.\' in num_str: return float(num_str) else: return int(num_str) # Additional methods as required to support the above functionality # Test cases to verify correctness of the implementation def test_simple_json_parser(): parser = SimpleJSONParser() assert parser.parse(\'{\\"key\\": \\"value\\"}\') == {\\"key\\": \\"value\\"} assert parser.parse(\'[1, 2, 3, {\\"a\\": true}, null]\') == [1, 2, 3, {\\"a\\": True}, None] assert parser.parse(\'{\\"nested\\": {\\"a\\": 1, \\"b\\": [2, 3]}, \\"empty_list\\": []}\') == {\\"nested\\": {\\"a\\": 1, \\"b\\": [2, 3]}, \\"empty_list\\": []} # Call the test function test_simple_json_parser() ``` # Challenge * Ensure your parser handles invalid JSON inputs gracefully by raising appropriate errors without crashing.","solution":"class SimpleJSONParser: def __init__(self): self.index = 0 self.json_str = \\"\\" def parse(self, json_str): self.json_str = json_str.strip() self.index = 0 return self._parse_value() def _parse_value(self): char = self.json_str[self.index] if char == \'{\': return self._parse_object() elif char == \'[\': return self._parse_array() elif char == \'\\"\': return self._parse_string() elif char in \'0123456789-\': return self._parse_number() elif self.json_str.startswith(\\"true\\", self.index): self.index += 4 return True elif self.json_str.startswith(\\"false\\", self.index): self.index += 5 return False elif self.json_str.startswith(\\"null\\", self.index): self.index += 4 return None else: raise ValueError(\\"Invalid JSON value\\") def _parse_object(self): obj = {} self.index += 1 # skip \'{\' while self.json_str[self.index] != \'}\': if self.json_str[self.index] in \' tnr\': self.index += 1 continue key = self._parse_string() while self.json_str[self.index] in \' tnr\': self.index += 1 self.index += 1 # skip \':\' while self.json_str[self.index] in \' tnr\': self.index += 1 value = self._parse_value() obj[key] = value while self.json_str[self.index] in \' tnr\': self.index += 1 if self.json_str[self.index] == \',\': self.index += 1 # skip \',\' self.index += 1 # skip \'}\' return obj def _parse_array(self): array = [] self.index += 1 # skip \'[\' while self.json_str[self.index] != \']\': while self.json_str[self.index] in \' tnr\': self.index += 1 value = self._parse_value() array.append(value) while self.json_str[self.index] in \' tnr\': self.index += 1 if self.json_str[self.index] == \',\': self.index += 1 # skip \',\' self.index += 1 # skip \']\' return array def _parse_string(self): self.index += 1 # skip initial quote string = \\"\\" while self.json_str[self.index] != \'\\"\': if self.json_str[self.index] == \'\': self.index += 1 # skip the escape character string += self.json_str[self.index] self.index += 1 self.index += 1 # skip final quote return string def _parse_number(self): num_str = \\"\\" while self.json_str[self.index] in \'0123456789.-\': num_str += self.json_str[self.index] self.index += 1 if \'.\' in num_str: return float(num_str) else: return int(num_str)"},{"question":"# Problem Statement Implement a function that reverses a string without using any built-in string manipulation functions. The function must handle various edge cases, including empty strings and single-character strings. Additionally, the reversed string should maintain the original case and special characters. # Input Format 1. A single string `s`. # Output Format - A string representing the reversed input string. # Constraints * The length of the string will be in the range (text{0} leq text{len}(s) leq 10^6). * The string can contain any ASCII character. # Performance Requirements * Your solution should run efficiently for a string with length up to 1,000,000 characters. # Examples 1. **Input**: ``` s = \\"hello\\" ``` **Output**: ``` \\"olleh\\" ``` 2. **Input**: ``` s = \\"A man, a plan, a canal, Panama\\" ``` **Output**: ``` \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` 3. **Input**: ``` s = \\"\\" ``` **Output**: ``` \\"\\" ``` 4. **Input**: ``` s = \\"x\\" ``` **Output**: ``` \\"x\\" ``` # Function Signature ```python def reverse_string(s: str) -> str: # Your code here ``` # Notes - Do not use any built-in functions for reversing the string, such as `[::-1]`. - Handle all possible edge cases effectively including empty strings, strings with spaces, special characters, and mixed case letters.","solution":"def reverse_string(s: str) -> str: Reverses the given string without using built-in string manipulation functions. Parameters: s (str): Input string. Returns: str: Reversed string. # Initialize an empty list to store the reversed characters reversed_chars = [] # Iterate over the string in reverse order for i in range(len(s) - 1, -1, -1): reversed_chars.append(s[i]) # Join the list into a string return \'\'.join(reversed_chars)"},{"question":"# Question You have been tasked with implementing several text processing functions from scratch. These functions include text normalization, tokenization, and various calculations. Below is the detailed description of the functions you need to implement. 1. **Text Normalization**: Write a function `normalize_text(text: str) -> str` that converts the input text to lowercase, removes punctuation, and strips any leading or trailing whitespace. 2. **Word Tokenization**: Write a function `tokenize_text(text: str) -> List[str]` that splits the input text into words, assuming words are separated by whitespace. 3. **Word Frequency Count**: Write a function `word_frequency(text: str) -> Dict[str, int]` that counts the frequency of each word in the input text. The function should return a dictionary where keys are words and values are their respective counts. 4. **Bigram Generation**: Write a function `generate_bigrams(text: str) -> List[Tuple[str, str]]` that generates bigrams from the input text. A bigram is a pair of consecutive words from the text. 5. **TF-IDF Calculation**: Write a function `tf_idf(docs: List[str], doc_index: int) -> Dict[str, float]` that computes the Term Frequency-Inverse Document Frequency (TF-IDF) for the words in the document at `doc_index` relative to the list of documents `docs`. Ensure your functions handle various edge cases, including empty strings and diverse text inputs. Below are detailed constraints and expected inputs/outputs for each function: 1. **Text Normalization**: - **Input**: `text` (a string). - **Output**: Normalized text as a string. 2. **Word Tokenization**: - **Input**: `text` (a string). - **Output**: List of words as strings. 3. **Word Frequency Count**: - **Input**: `text` (a string). - **Output**: Dictionary where keys are words and values are counts. 4. **Bigram Generation**: - **Input**: `text` (a string). - **Output**: List of tuples, each containing a pair of consecutive words. 5. **TF-IDF Calculation**: - **Input**: `docs` (a list of strings), `doc_index` (integer index of the document for which to calculate TF-IDF). - **Output**: Dictionary where keys are words and values are TF-IDF scores. Provide complete implementations of these functions with proper error handling, ensuring correct results for different input scenarios and optimizing for performance where possible.","solution":"import re from collections import defaultdict from typing import List, Dict, Tuple import math def normalize_text(text: str) -> str: Converts the input text to lowercase, removes punctuation, and strips any leading or trailing whitespace. text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) return text.strip() def tokenize_text(text: str) -> List[str]: Splits the input text into words, assuming words are separated by whitespace. return text.split() def word_frequency(text: str) -> Dict[str, int]: Counts the frequency of each word in the input text. text = normalize_text(text) words = tokenize_text(text) frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency) def generate_bigrams(text: str) -> List[Tuple[str, str]]: Generates bigrams from the input text. A bigram is a pair of consecutive words from the text. text = normalize_text(text) words = tokenize_text(text) bigrams = [(words[i], words[i + 1]) for i in range(len(words) - 1)] return bigrams def tf_idf(docs: List[str], doc_index: int) -> Dict[str, float]: Computes the Term Frequency-Inverse Document Frequency (TF-IDF) for the words in the document at `doc_index` relative to the list of documents `docs`. term_frequency = word_frequency(docs[doc_index]) word_document_counts = defaultdict(int) for doc in docs: unique_words = set(tokenize_text(normalize_text(doc))) for word in unique_words: word_document_counts[word] += 1 total_documents = len(docs) tf_idf_scores = {} for word, freq in term_frequency.items(): tf = freq / sum(term_frequency.values()) idf = math.log(total_documents / (word_document_counts[word] or 1)) tf_idf_scores[word] = tf * idf return tf_idf_scores"},{"question":"# Problem: Non-decreasing Array Check Given an array of integers `nums`, your task is to implement a function `checkPossibility` that determines if the array could become non-decreasing by modifying at most one element. # Function Signature ```python def checkPossibility(nums: List[int]) -> bool: pass ``` # Input - `nums`: A non-empty list of integers. # Output - Return `True` if `nums` can be made non-decreasing by modifying at most one element. Otherwise, return `False`. # Constraints & Requirements - **Performance**: Your solution should efficiently handle lists up to length 10^4. - **Validation**: Ensure input is valid: - `nums` must be a non-empty list of integers. - Raise `ValueError` with appropriate messages if input is invalid. # Examples ```python print(checkPossibility([4, 2, 3])) # True print(checkPossibility([4, 2, 1])) # False print(checkPossibility([3, 4, 2, 3])) # False print(checkPossibility([1, 2, 3])) # True ``` # Explanation - In the first example, modifying the first 4 to 1 results in [1, 2, 3], which is non-decreasing. - In the second example, no modification to make the list non-decreasing with just one change. - In the third example, no single change can make the list non-decreasing. - In the fourth example, the list is already non-decreasing, so no modification needed. # Note Your implementation should focus on checking minimal changes and ensuring only one element modification is considered.","solution":"def checkPossibility(nums): if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a non-empty list of integers.\\") n = len(nums) count = 0 # Count of modifications for i in range(1, n): if nums[i] < nums[i - 1]: if count > 0: return False count += 1 if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"# Question: Implement a Matrix Transposition Function Context Matrix transposition is a simple and useful operation that involves flipping a matrix over its diagonal, switching the row and column indices of the matrix. Learning how to manipulate arrays with this operation is fundamental for understanding more complex algorithms in linear algebra and computer science. Task Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a matrix represented as a list of lists, transposes it, and returns the transposed matrix. Function Signature ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` Inputs - `matrix`: A list of lists of integers representing a matrix. Outputs - A list of lists of integers representing the transposed matrix. Constraints 1. Each inner list represents a row in the matrix. 2. The matrix can have any number of rows and columns (including a zero-size matrix). 3. The function should validate the input: * Raise `TypeError` if the input is not a list of lists of integers. Performance Requirements - The function should handle matrices with up to 1,000,000 elements efficiently. Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([]) [] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) [[1, 5], [2, 6], [3, 7], [4, 8]] ``` Error Handling Examples ```python >>> transpose_matrix([1, 2, 3]) Traceback (most recent call last): ... TypeError: input must be a list of lists of integers >>> transpose_matrix([[1, 2.5], [3, 4]]) Traceback (most recent call last): ... TypeError: input must be a list of lists of integers >>> transpose_matrix([[1, 2], [3, \'4\']]) Traceback (most recent call last): ... TypeError: input must be a list of lists of integers ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not isinstance(matrix, list) or any(not isinstance(row, list) for row in matrix): raise TypeError(\\"input must be a list of lists of integers\\") if any(not all(isinstance(element, int) for element in row) for row in matrix): raise TypeError(\\"input must be a list of lists of integers\\") if len(matrix) == 0 or len(matrix[0]) == 0: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for row in range(rows): for col in range(cols): transposed[col][row] = matrix[row][col] return transposed"},{"question":"# Question: Unique Character Counter Given a string `s`, implement a function `unique_char_counter(s: str) -> int` that returns the count of unique characters in the string. Function Signature: ```python def unique_char_counter(s: str) -> int: pass ``` # Input: * A string `s` where `1 <= len(s) <= 10^6`. # Output: * An integer representing the number of unique characters in the string. # Constraints: * The function should work efficiently even for the upper limits of the input size. * The input string may contain any printable ASCII characters. # Example: ```python assert unique_char_counter(\\"abcd\\") == 4 assert unique_char_counter(\\"aaabbbccc\\") == 3 assert unique_char_counter(\\"\\") == 0 assert unique_char_counter(\\"123abc!@#\\") == 9 ``` # Performance Requirements: * The function must run in O(n) time complexity where n is the length of the input string. **Hint**: Utilize appropriate data structures to ensure an efficient solution. # Scenario: Imagine you are designing a text analysis tool that needs to quickly determine the diversity of characters in a given dataset. This function is a fundamental component that will help in analyzing text uniqueness metrics, which is crucial for applications in cryptographic systems, data compression, and natural language processing. Consider edge cases such as empty strings and ensure your implementation handles large inputs efficiently.","solution":"def unique_char_counter(s: str) -> int: Returns the count of unique characters in the given string. :param s: input string :type s: str :return: number of unique characters :rtype: int return len(set(s))"},{"question":"# Task You are tasked with creating a program that models a simplified online banking system. The system should be able to handle basic account operations for multiple users. Specifically, you will implement a class that manages user accounts and allows for the following operations: 1. **Create New Account**: Each account has a unique account number, user name, and balance. 2. **Deposit**: Add a specified amount to an account balance. 3. **Withdraw**: Subtract a specified amount from an account balance, ensuring that the account does not go into a negative balance. 4. **Transfer**: Transfer a specified amount from one account to another. # Implementation: * Create a class `Bank` with methods to perform the above operations. * Implement the following methods: ```python class Bank: def __init__(self): self.accounts = {} def create_account(self, account_number: int, user_name: str, initial_balance: float): Create a new account with the provided account number, user name, and initial balance. pass def deposit(self, account_number: int, amount: float): Deposit a specified amount into the account identified by account_number. pass def withdraw(self, account_number: int, amount: float): Withdraw a specified amount from the account identified by account_number, if sufficient balance exists. pass def transfer(self, from_account: int, to_account: int, amount: float): Transfer a specified amount from one account to another, if sufficient balance exists in the source account. pass ``` # Requirements: * Handle any attempts to withdraw more than the current balance by raising an appropriate Exception. * Ensure all transfers and deposits only involve positive amounts. * Account numbers are integers and must be unique. * User names are strings, and initial balance must be a non-negative float. # Example ```python # Instantiate the bank system my_bank = Bank() # Create accounts my_bank.create_account(101, \'Alice\', 500.0) my_bank.create_account(102, \'Bob\', 300.0) # Deposit money into Alice\'s account my_bank.deposit(101, 200.0) # Withdraw money from Bob\'s account my_bank.withdraw(102, 100.0) # Transfer money from Alice to Bob my_bank.transfer(101, 102, 50.0) ``` # Constraints: - Account numbers are unique integers. - User names are strings with a maximum length of 100 characters. - Initial balances are non-negative floats. - All monetary transactions (deposit, withdraw, transfer) involve non-negative floats. Implement your solution by completing the `Bank` class methods as described. Validate your implementation with appropriate test cases to ensure correctness.","solution":"class Bank: def __init__(self): self.accounts = {} def create_account(self, account_number: int, user_name: str, initial_balance: float): if account_number in self.accounts: raise ValueError(\\"Account number must be unique\\") if initial_balance < 0: raise ValueError(\\"Initial balance must be non-negative\\") self.accounts[account_number] = { \'user_name\': user_name, \'balance\': initial_balance } def deposit(self, account_number: int, amount: float): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") if account_number not in self.accounts: raise ValueError(\\"Account number does not exist\\") self.accounts[account_number][\'balance\'] += amount def withdraw(self, account_number: int, amount: float): if amount <= 0: raise ValueError(\\"Withdraw amount must be positive\\") if account_number not in self.accounts: raise ValueError(\\"Account number does not exist\\") if self.accounts[account_number][\'balance\'] < amount: raise ValueError(\\"Insufficient balance\\") self.accounts[account_number][\'balance\'] -= amount def transfer(self, from_account: int, to_account: int, amount: float): if amount <= 0: raise ValueError(\\"Transfer amount must be positive\\") if from_account not in self.accounts or to_account not in self.accounts: raise ValueError(\\"One or both account numbers do not exist\\") if self.accounts[from_account][\'balance\'] < amount: raise ValueError(\\"Insufficient balance in the source account\\") self.accounts[from_account][\'balance\'] -= amount self.accounts[to_account][\'balance\'] += amount"},{"question":"# Coding Challenge Problem Statement Create a function `find_subarray_with_max_sum` that finds the contiguous subarray within a given array of integers `arr` which has the largest sum. The function should return the sum of this subarray. Function Signature ```python def find_subarray_with_max_sum(arr: List[int]) -> int: pass ``` Input - `arr` (List[int]): A list of integers, where 1 <= len(arr) <= 10000 and -1000 <= arr[i] <= 1000. Output - Returns an integer representing the sum of the subarray with the largest sum. Example ```python print(find_subarray_with_max_sum([1, -3, 2, 1, -1])) # Output: 3 print(find_subarray_with_max_sum([-2, -3, -1])) # Output: -1 print(find_subarray_with_max_sum([5, 4, -1, 7, 8])) # Output: 23 ``` Constraints - The array may contain both negative and positive integers. - The subarray can be the entire array itself or a smaller part. - You may assume all input is valid and conforms to the problem constraints. Notes - Consider the efficiency of your solution, especially for larger input arrays. - Test your solution with various edge cases such as all negative numbers, all positive numbers, and mixed numbers.","solution":"from typing import List def find_subarray_with_max_sum(arr: List[int]) -> int: max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global print(find_subarray_with_max_sum([1, -3, 2, 1, -1])) # Output: 3 print(find_subarray_with_max_sum([-2, -3, -1])) # Output: -1 print(find_subarray_with_max_sum([5, 4, -1, 7, 8])) # Output: 23"},{"question":"# Coding Question You are given a collection of words and a single `keyWord` which you need to search among this collection using a Trie (Prefix Tree). Construct a Trie for the given collection of words and implement a function to search whether the `keyWord` exists in the Trie or not. Your implementation should demonstrate a deep understanding of Trie structure\'s principles and properties. Function Signature ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, keyWord: str) -> bool: pass ``` Task 1. **Insert Words**: - Implement the `insert` method to insert each word from the collection into the Trie. - Ensure efficient insertion of words with time complexity O(m) per word, where m is the length of the word. 2. **Search Word**: - Implement the `search` method to search for the `keyWord` in the Trie. - The search should return `True` if the `keyWord` exists in the Trie and `False` otherwise. - Ensure the search operation runs in linear time concerning the length of the `keyWord`. Input - An instance of the `Trie` class is initialized. - The `insert(words)` method is called multiple times to insert a list of words into the Trie. - The `search(keyWord)` method is called with a string `keyWord` that needs to be searched within the Trie. Output - The `search` method should return `True` if the `keyWord` exists in the collection, `False` otherwise. Constraints - `1 <= len(words) <= 10^5` - `1 <= len(word) <= 1000` for each word in the collection - `words` and `keyWord` consist of lowercase English letters only. Example Usage ```python trie = Trie() trie.insert(\\"apricot\\") trie.insert(\\"banana\\") trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"apricot\\") == True assert trie.search(\\"banana\\") == True assert trie.search(\\"berry\\") == False assert trie.search(\\"bana\\") == False assert trie.search(\\"bananas\\") == False ``` Notes - You are required to write both methods in the `Trie` class. - Ensure optimal performance by adhering to the specified time complexities.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, keyWord: str) -> bool: node = self.root for char in keyWord: if char not in node.children: return False node = node.children[char] return node.is_end_of_word # Example usage: # trie = Trie() # trie.insert(\\"apricot\\") # trie.insert(\\"banana\\") # trie.insert(\\"apple\\") # print(trie.search(\\"apple\\")) # True # print(trie.search(\\"apricot\\")) # True # print(trie.search(\\"banana\\")) # True # print(trie.search(\\"berry\\")) # False # print(trie.search(\\"bana\\")) # False # print(trie.search(\\"bananas\\")) # False"},{"question":"# Scenario You are a software engineer at a company that manages a digital library. The library stores thousands of books in different genres and you need to implement a search feature that finds books by genre and returns them in alphabetical order by title. The function also needs to handle cases where there are no books of the specified genre and should return an appropriate message. # Task Write a function that retrieves all book titles from a specific genre and returns them alphabetically sorted. The function should handle cases where no books of the specified genre exist. # Function Signature ```python def search_books_by_genre(books: List[Dict[str, str]], genre: str) -> Union[List[str], str]: pass ``` # Input and Output * **Input**: * `books`: A list of dictionaries where each dictionary contains `title` and `genre` of the book. * `genre`: A string representing the genre to search for. * **Output**: * Returns a list of book titles of the specified genre, sorted in alphabetical order, or a string \\"No books found in the specified genre.\\" if no books of that genre are present. # Constraints * Each book\'s dictionary is guaranteed to contain a `title` and `genre` key. * If no books of the given genre are found, return the string \\"No books found in the specified genre.\\". # Example ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\"}, {\\"title\\": \\"Moby Dick\\", \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"The Road\\", \\"genre\\": \\"Dystopian\\"}, ] genre = \\"Fiction\\" result = search_books_by_genre(books, genre) print(result) # Expected output: [\'Moby Dick\', \'The Great Gatsby\', \'To Kill a Mockingbird\'] ``` # Performance Requirements Ensure the function handles the sorting operation efficiently, especially when dealing with large numbers of books. Provide optimal performance for searching and sorting within reasonable time complexity.","solution":"from typing import List, Dict, Union def search_books_by_genre(books: List[Dict[str, str]], genre: str) -> Union[List[str], str]: Retrieves all book titles from a specific genre and returns them alphabetically sorted. If no books of the specified genre are found, returns a message indicating no books found. :param books: List of dictionaries where each dictionary contains \'title\' and \'genre\' of the book. :param genre: Genre to search for. :return: List of book titles sorted alphabetically or a string message if no books found. selected_books = [book[\'title\'] for book in books if book[\'genre\'].lower() == genre.lower()] if not selected_books: return \\"No books found in the specified genre.\\" selected_books.sort() return selected_books"},{"question":"# Question You have been provided with a partially implemented **max-heap data structure** in Python. Your task is to complete the implementation by adding an additional method called `extract_top_k`. This method should return a list of the top `k` largest elements from the heap without altering the heap. **Function Signature**: ```python def extract_top_k(self, k: int) -> List[int]: pass ``` # Instructions 1. **Function Details**: - **Input**: An integer `k` representing the number of top elements to retrieve. - **Output**: Returns a list of the `k` largest elements in the heap, sorted in descending order. - **Constraints**: - If `k` is greater than the number of elements in the heap, return all elements in descending order. - Do **not** remove the elements from the heap, only retrieve them. 2. **Examples**: ```python # Example 1 heap = MaxHeap() heap.insert(1) heap.insert(5) heap.insert(3) heap.insert(7) assert heap.extract_top_k(2) == [7, 5] assert heap.extract_top_k(4) == [7, 5, 3, 1] # Example 2 heap = MaxHeap() heap.insert(20) heap.insert(15) heap.insert(30) heap.insert(10) assert heap.extract_top_k(1) == [30] assert heap.extract_top_k(5) == [30, 20, 15, 10] ``` 3. **Guidelines**: - Ensure that your implementation does not affect the existing functionalities of the max-heap. - Be mindful of the heap\'s structure and efficiency. # Additional Notes: - Focus on achieving the correct functionality within the specified constraints. - Make sure to handle edge cases, such as when `k` is zero or the heap is empty. Implement the `extract_top_k` method in the `MaxHeap` class: # Code to Implement ```python class MaxHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index: int) -> None: parent = (index - 1) // 2 if index and self.heap[parent] < self.heap[index]: self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent] self._heapify_up(parent) def extract_top_k(self, k: int) -> List[int]: # Your code here pass ... ```","solution":"import heapq from typing import List class MaxHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index: int) -> None: parent = (index - 1) // 2 if index and self.heap[parent] < self.heap[index]: self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent] self._heapify_up(parent) def extract_top_k(self, k: int) -> List[int]: # Use a temporary heap to get the top k elements without modifying the original heap temp_heap = self.heap[:] top_k = [] for _ in range(min(k, len(self.heap))): next_largest = heapq._heappop_max(temp_heap) top_k.append(next_largest) return top_k"},{"question":"# Question: Implement an Efficient String Permutation Checker You are developing an application that requires checking if two strings are permutations of each other. Your task is to implement a function that determines whether two given strings are permutations (i.e., anagrams) of each other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool ``` Requirements - The function should return `True` if the two strings are permutations of each other and `False` otherwise. - The function should be case-sensitive, meaning \\"a\\" and \\"A\\" are treated as different characters. - The function should consider only alphanumeric characters and should ignore any spaces. - Handle the case where either string is empty; the result should be `False` if one is empty and the other is not. If both are empty, the result should be `True`. Input - `str1`: A string of alphanumeric characters and spaces. - `str2`: Another string of alphanumeric characters and spaces. Output - Return `True` or `False` depending on whether the two strings are permutations of each other. Constraints - The input strings can be of any length. - The input strings may contain spaces which should be ignored. Examples ```python assert are_permutations(\\"abc\\", \\"cab\\") == True assert are_permutations(\\"abc\\", \\"abC\\") == False # case-sensitive check assert are_permutations(\\"a b c\\", \\"cba\\") == True # ignores spaces assert are_permutations(\\"123\\", \\"321\\") == True assert are_permutations(\\"hello\\", \\"olleh\\") == True assert are_permutations(\\"abc\\", \\"abcd\\") == False assert are_permutations(\\"\\", \\"\\") == True assert are_permutations(\\" \\", \\"\\") == True assert are_permutations(\\" \\", \\"a \\") == False ``` Constraints & Limitations - Ensure your function runs efficiently for large input sizes. - The solution should respect the constraints of O(n) time complexity where n is the length of the longer string. - Do not use any in-built Python sorting functions for this implementation. - Handle all edge cases properly and include good unit tests for them in your submission.","solution":"def are_permutations(str1: str, str2: str) -> bool: Determines if two strings are permutations of each other, ignoring spaces and being case-sensitive. from collections import Counter # Remove spaces from both strings str1 = str1.replace(\\" \\", \\"\\") str2 = str2.replace(\\" \\", \\"\\") # If lengths differ after removing spaces, they can\'t be permutations if len(str1) != len(str2): return False # Count the frequency of each character in both strings return Counter(str1) == Counter(str2)"},{"question":"# Alternating Sequence Checker You need to implement an algorithm that checks whether an array of integers forms an alternating sequence. An alternating sequence is defined as a sequence where each pair of consecutive elements has opposite signs, i.e., positive follows negative and negative follows positive. **Function Signature:** ```python def is_alternating_sequence(arr: list[int]) -> bool: Check if the array forms an alternating sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the array forms an alternating sequence, False otherwise. Examples: >>> is_alternating_sequence([1, -2, 3, -4, 5]) True >>> is_alternating_sequence([1, 2, -3, 4, 5]) False >>> is_alternating_sequence([-1, 1, -1, 1]) True >>> is_alternating_sequence([1]) True >>> is_alternating_sequence([]) True ``` # Input: - A list of integers `arr` of size `n` where `0 <= n <= 10^6` and each element is within the range `-10^6` to `10^6`. # Output: - Return a boolean value `True` if the array forms an alternating sequence, otherwise return `False`. # Example: ```markdown Example 1: Input: arr = [1, -2, 3, -4, 5] Output: True Example 2: Input: arr = [1, 2, -3, 4, 5] Output: False Example 3: Input: arr = [-1, 1, -1, 1] Output: True Example 4: Input: arr = [1] Output: True Example 5: Input: arr = [] Output: True ``` # Constraints: - The function must run in O(n) time complexity. - The function must use O(1) extra space. # Explanation: 1. If the array is empty or contains a single element, return `True` since an empty array or a single element can\'t violate the alternating condition. 2. Iterate through each pair of consecutive elements in the array: - Check if the pair has opposite signs (one positive and one negative). - If any pair does not meet this condition, return `False`. 3. If all pairs meet the condition, return `True` after the loop. Ensure your function handles edge cases and performs efficiently up to the maximum constraints.","solution":"def is_alternating_sequence(arr: list[int]) -> bool: Check if the array forms an alternating sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the array forms an alternating sequence, False otherwise. if not arr: return True for i in range(len(arr) - 1): if arr[i] * arr[i + 1] >= 0: return False return True"},{"question":"# Question You have been assigned to write a function that generates a summary report of book sales from a given CSV file. Each row in the file contains details about individual book sales, including the title, author, genre, and number of copies sold. Your function should return a summary report detailing the total number of books sold per genre. # Function Specification **Function Signature** ```python def genre_sales_report(file_path: str) -> Dict[str, int]: pass ``` **Input** - `file_path` (string): The file path to the CSV file containing book sales data. **Output** - Returns a dictionary: - keys (strings): The genres of the books. - values (integers): Total number of books sold for each genre. **Constraints** - The CSV file is guaranteed to be correctly formatted with headers. - Each row in the CSV file contains the following columns: `title`, `author`, `genre`, and `copies_sold`. - The function should handle file-related errors gracefully. # Example **CSV File (sample_books.csv)**: ``` title,author,genre,copies_sold The Hobbit,J.R.R. Tolkien,Fantasy,500 1984,George Orwell,Dystopia,200 The Catcher in the Rye,J.D. Salinger,Classic,150 To Kill a Mockingbird,Harper Lee,Classic,300 The Great Gatsby,F. Scott Fitzgerald,Classic,100 ``` **Function Call**: ```python report = genre_sales_report(\\"sample_books.csv\\") print(report) ``` **Expected Output**: ```python { \\"Fantasy\\": 500, \\"Dystopia\\": 200, \\"Classic\\": 550 } ``` # Instructions 1. Familiarize yourself with reading CSV files in Python. You may use the built-in `csv` module for this task. 2. Write the `genre_sales_report` function to read the CSV file and compute the total sales for each genre. 3. Ensure error handling for cases such as file not found or read errors. 4. Test the function with various CSV files to ensure correctness and robustness.","solution":"import csv from typing import Dict def genre_sales_report(file_path: str) -> Dict[str, int]: Reads a CSV file containing book sales data and returns a dictionary summarizing the total number of books sold per genre. :param file_path: The path to the CSV file :return: A dictionary with genre as keys and total copies sold as values result = {} try: with open(file_path, mode=\'r\', encoding=\'utf-8\') as file: reader = csv.DictReader(file) for row in reader: genre = row[\'genre\'] copies_sold = int(row[\'copies_sold\']) if genre in result: result[genre] += copies_sold else: result[genre] = copies_sold except FileNotFoundError: raise Exception(f\\"The file at {file_path} could not be found.\\") return result"},{"question":"# Coding Question: Least Common Multiple Calculation **Context**: You are working on a mathematical software that requires efficient calculation of the Least Common Multiple (LCM) for a pair of integers. This functionality is fundamental in applications involving fractions, periodic events, and many engineering problems. **Task**: Implement a function to calculate the **Least Common Multiple (LCM)** of two positive integers. **Input**: * Two positive integers `a` and `b` where `1 <= a, b <= 10000`. **Output**: * An integer representing the Least Common Multiple of `a` and `b`. **Constraints**: * You must implement the LCM calculation in an efficient manner ensuring that it handles edge cases well. * Avoid any unnecessary computations to ensure optimal performance, especially for large values of `a` and `b`. * Follow good engineering practices and write clean, readable code. **Specification**: Function Signature: `def lcm(a: int, b: int) -> int:` **Example**: ```python >>> lcm(4, 5) 20 >>> lcm(7, 3) 21 >>> lcm(6, 8) 24 >>> lcm(1, 1) 1 >>> lcm(12, 15) 60 ``` # Implementation Notes * The LCM of two numbers can be calculated using their Greatest Common Divisor (GCD) with the formula: [ text{LCM}(a, b) = frac{|a times b|}{text{GCD}(a, b)} ] * Consider using Python’s built-in `math.gcd` function for GCD calculation to ensure reliability.","solution":"import math def lcm(a: int, b: int) -> int: Returns the least common multiple of two positive integers a and b. return abs(a * b) // math.gcd(a, b)"},{"question":"Problem Statement You are tasked with implementing a function that validates and extracts all valid IPv4 addresses from a given string. A valid IPv4 address consists of four octets, each ranging from 0 to 255, separated by dots (\'.\'). Each octet cannot have leading zeros unless it is zero. # Function signature ```python def extract_ipv4_addresses(text: str) -> List[str]: pass ``` # Input * A string `text` (0 <= len(text) <= 1000) which can contain a mix of words, numbers, and special characters. # Output * Returns a list of valid IPv4 addresses extracted from the input string in the order they appear. # Constraints * Each address should be a valid IPv4 address as per the standard definition. * Addresses are considered valid only if they have four octets, each ranging from 0 to 255, and do not have leading zeros unless the octet is zero (e.g., \\"192.168.001.1\\" is invalid). # Example ```python assert extract_ipv4_addresses(\\"Sample text 192.168.0.1 with IP addresses 255.255.255.255 and some 999.999.999.999 invalid 10.0.10.01 addresses\\") == [\\"192.168.0.1\\", \\"255.255.255.255\\"] assert extract_ipv4_addresses(\\"No valid IP here 256.256.256.256\\") == [] assert extract_ipv4_addresses(\\"Text with multiple valid IPs: 1.1.1.1 , 172.16.254.1. More text.\\") == [\\"1.1.1.1\\", \\"172.16.254.1\\"] assert extract_ipv4_addresses(\\"Another text with 0.0.0.0, 8.8.8.8, 172.16.254.1, and invalid 300.300.300.300 IPs\\") == [\\"0.0.0.0\\", \\"8.8.8.8\\", \\"172.16.254.1\\"] ``` # Notes * Ensure that each detected IP address is validated for correct format and range. * Take into account the presence of other text and characters that might be mixed in with the potential IP addresses. * The output list should only contain valid IP addresses as per the criteria defined.","solution":"import re from typing import List def extract_ipv4_addresses(text: str) -> List[str]: Extract all valid IPv4 addresses from given text. ipv4_pattern = r\'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b\' candidate_ips = re.findall(ipv4_pattern, text) valid_ips = [] for ip in candidate_ips: octets = ip.split(\'.\') if all(octet.isdigit() and 0 <= int(octet) <= 255 and str(int(octet)) == octet for octet in octets): valid_ips.append(ip) return valid_ips"},{"question":"Number of Enclaves You are given a two-dimensional binary matrix `grid` where `0` represents water and `1` represents land. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. A land cell is classified as an enclave if it is not connected to the border of the grid. Write a function `num_enclaves(grid: List[List[int]]) -> int` that returns the number of land cells in all enclaves in the grid. Input * A two-dimensional list `grid` where each element is either `0` or `1`. * It is guaranteed that `grid` will have at least one element and each row in `grid` will also have at least one element. The dimensions of `grid` are at most (50 times 50). Output * A single integer representing the number of land cells in all enclaves. # Constraints * The function should handle different grid dimensions efficiently. * Avoid using excessive memory or deep recursion to prevent stack overflow. # Example ```python grid = [ [0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert num_enclaves(grid) == 3 grid = [ [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0] ] assert num_enclaves(grid) == 0 ``` # Additional Guidelines * Explain your approach clearly, considering edge cases and potential pitfalls. * Make sure your implementation is efficient and can handle the maximum constraints.","solution":"from typing import List def num_enclaves(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == 0: return grid[x][y] = 0 # Sink the land to water directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) # Flood fill all land connected to borders for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r in {0, rows-1} or c in {0, cols-1}): dfs(r, c) # Count remaining land cells enclaves = sum(grid[r][c] == 1 for r in range(rows) for c in range(cols)) return enclaves"},{"question":"# Maze Solver **Scenario**: You are tasked with implementing a maze solver. The given maze is represented by a grid of cells where each cell can be either an empty space (`\' \'`) or a wall (`\'#\'`). The objective is to find a path from the start position to the end position using recursive backtracking. **Objective**: Your job is to implement a function `solve_maze(maze: list[list[str]], start: tuple[int, int], end: tuple[int, int]) -> bool` to solve the maze. **Function Signature**: ```python def solve_maze(maze: list[list[str]], start: tuple[int, int], end: tuple[int, int]) -> bool: # your code here ``` **Input**: * `maze`: A 2D list representing the maze grid. Each element is either an empty space `\' \'` or a wall `\'#\'`. * `start`: A tuple representing the starting position in the maze in the format (row, column). * `end`: A tuple representing the destination position in the maze in the format (row, column). **Output**: * Returns `True` if there is a path from the start position to the end position, otherwise `False`. **Constraints**: * The start and end positions will always be empty spaces and not walls. * You can move in four possible directions: up, down, left, and right. * The path must not pass through walls or go out of the maze boundaries. * The use of backtracking is required to explore all possible paths. **Edge Cases**: * The maze is a minimal grid (e.g., 1x1 or 2x2 with walls). * The start and end positions are the same. * There is no possible path from start to end due to walls blocking the way. # Example ```python maze = [ [\' \', \'#\', \' \', \' \', \' \'], [\' \', \'#\', \' \', \'#\', \' \'], [\' \', \'#\', \' \', \'#\', \' \'], [\' \', \' \', \' \', \'#\', \' \'], [\'#\', \'#\', \' \', \' \', \' \'] ] start = (0, 0) end = (4, 4) solve_maze(maze, start, end) # Returns: True (and there is a path from start to end) maze = [ [\' \', \'#\', \' \', \' \', \' \'], [\' \', \'#\', \' \', \'#\', \' \'], [\' \', \'#\', \' \', \'#\', \' \'], [\' \', \' \', \' \', \'#\', \' \'], [\'#\', \'#\', \' \', \'#\', \' \'] ] start = (0, 0) end = (4, 4) solve_maze(maze, start, end) # Returns: False (as there is no path from start to end) ``` Write your function considering the provided scenarios and constraints. Ensure your implementation efficiently handles all edge cases and correctly determines if a path exists from the start position to the end position using the given maze grid.","solution":"def solve_maze(maze, start, end): def is_valid_move(x, y): return ( 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == \' \' ) def backtrack(x, y): # If we\'ve reached the end, return True if (x, y) == end: return True # Mark as visited maze[x][y] = \'#\' # Explore possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and backtrack(nx, ny): return True # Unmark as visited (backtrack) maze[x][y] = \' \' # If no path found return False return backtrack(start[0], start[1])"},{"question":"# Problem Statement You are tasked with developing a function `find_missing_number` that takes a list of integers as input, containing all the numbers from 1 to `n`, except one missing number. Your function should identify and return the missing number from the list. To solve this problem, you must not use any additional data structures (like sets or dictionaries) and should aim for a solution that runs in linear time (O(n)). Input - A list of integers containing all the numbers from 1 to `n` except one. Output - The missing integer. Constraints - The list contains `n-1` integers, and all integers are between 1 and `n` (inclusive). - There are no duplicate integers in the list. - The list may be in any order. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Example ```python assert find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 assert find_missing_number([1, 2, 3, 5]) == 4 assert find_missing_number([2, 3, 4, 5, 6]) == 1 ``` In the first example, the input list is `[3, 7, 1, 2, 8, 4, 5]`. The list contains numbers from 1 to 8, except 6, so the function should return 6.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in a list of integers ranging from 1 to n, except for one missing number. Args: nums (List[int]): A list of integers Returns: int: The missing integer n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Problem Statement You are tasked with writing a function `find_subsets` that returns all possible subsets of a given list of unique integers. The function should generate the subsets using backtracking. # Function Signature ```python def find_subsets(nums: List[int]) -> List[List[int]]: ``` # Input * A list of unique integers `nums` where (0 leq text{len}(nums) leq 10) and each element (1 leq text{nums}[i] leq 10^3). # Output * A list containing all possible subsets of the input list. The subsets can be returned in any order. # Constraints * The elements in the input list are unique. * Your solution should generate subsets efficiently within given constraints. * The function should raise appropriate errors for invalid inputs. # Performance Requirements * Time complexity: O(2^n) * Space complexity: O(2^n) # Edge Cases & Error Handling * If the input list is empty, the function should return `[[]]`. * If the input contains non-integer elements, raise a `TypeError`. # Example 1. Example 1: ```python find_subsets([1, 2, 3]) ``` Expected Output: ```python [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` 2. Example 2: ```python find_subsets([4, 5]) ``` Expected Output: ```python [[], [4], [5], [4, 5]] ``` 3. Edge Case 1: ```python find_subsets([]) ``` Expected Output: ```python [[]] ``` 4. Edge Case 2: ```python find_subsets([1, \\"a\\", 3]) ``` Expected Output: ```python TypeError: \'str\' object cannot be interpreted as an integer ``` Write the `find_subsets` function to solve the above problem statement.","solution":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of a list of unique integers. if not all(isinstance(x, int) for x in nums): raise TypeError(\\"All elements of the input list must be integers\\") def backtrack(start, path): output.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() output = [] backtrack(0, []) return output"},{"question":"# Fibonacci Similarity Sequence Objective Write a Python function that generates a sequence similar to the Fibonacci sequence but with a twist. The sequence starts with two numbers, `a` and `b`, and each subsequent number is the sum of the previous two, but multiplied by a constant factor `c`. Input - Three integers, `a`, `b`, and `c` where (1 ≤ a, b ≤ 10^5) and (1 ≤ c ≤ 10). Output - A list of integers representing the first `n` elements of the modified Fibonacci-like sequence, where `n` is the length of the generated sequence. Function Signature ```python def generate_modified_fibonacci_sequence(a: int, b: int, c: int, n: int) -> list[int]: pass ``` Constraints - `a` and `b` are the starting integers of the sequence. - `c` is the constant factor by which the sum of the last two numbers is multiplied. - `n` is an integer that represents the length of the sequence to generate and must be between 1 and 1000. - The function should raise a ValueError if `n` is less than 1 or greater than 1000. - The function should raise a TypeError if any input is not an integer. Examples ```python >>> generate_modified_fibonacci_sequence(1, 1, 2, 5) [1, 1, 4, 10, 28] >>> generate_modified_fibonacci_sequence(2, 3, 3, 6) [2, 3, 15, 54, 207, 783] >>> generate_modified_fibonacci_sequence(5, 7, 1, 4) [5, 7, 12, 19] ``` Notes Your implementation should aim for simplicity and clarity within the provided input constraints. Ensure proper handling of edge cases and data validation.","solution":"def generate_modified_fibonacci_sequence(a: int, b: int, c: int, n: int) -> list[int]: if not all(isinstance(x, int) for x in [a, b, c, n]): raise TypeError(\\"All input values must be integers\\") if n < 1 or n > 1000: raise ValueError(\\"The length of the sequence n must be between 1 and 1000\\") sequence = [a, b] while len(sequence) < n: next_value = c * (sequence[-1] + sequence[-2]) sequence.append(next_value) return sequence[:n]"},{"question":"URL Shortener System Context You\'ve been hired by a tech startup to contribute to their new URL shortener service. This service allows users to convert long URLs into shorter versions that are easier to share. The system must be highly efficient in encoding and decoding URLs while ensuring that each short URL is unique. For this task, you need to implement classes to: 1. Encode a long URL into a short URL. 2. Decode the short URL back into the original long URL. Class 1: URLShortener Write a class `URLShortener` that provides the following methods: 1. `encode(long_url: str) -> str`: Converts a `long_url` into a shorter URL. 2. `decode(short_url: str) -> str`: Retrieves the original `long_url` using the given `short_url`. * **Input**: - `encode` method takes a `long_url` (as a string). - `decode` method takes a `short_url` (as a string). * **Output**: - `encode` returns a short URL string. - `decode` returns the original long URL string. Constraints 1. The short URLs must be unique and sufficiently short. 2. Handle URL encoding and decoding efficiently. 3. Short URLs should be human-readable and not exceed a reasonable length. 4. You must maintain a mapping between long URLs and their short versions to support decoding. 5. Ensure thread safety if you intend to deploy this as a multi-user service. Examples ```python >>> url_shortener = URLShortener() >>> short_url = url_shortener.encode(\\"https://example.com/path/to/resource\\") >>> short_url \'http://short.url/abc123\' >>> original_url = url_shortener.decode(short_url) >>> original_url \'https://example.com/path/to/resource\' >>> another_short_url = url_shortener.encode(\\"https://another-example.com/page\\") >>> another_short_url \'http://short.url/def456\' >>> decoded_url = url_shortener.decode(another_short_url) >>> decoded_url \'https://another-example.com/page\' ``` Hint Use a dictionary to store the mapping between short URLs and long URLs. You might use a hash function or a sequential ID generator to create the short URLs. Consider using a base conversion method to generate the short URLs if you opt for a sequential ID approach. Implement the `URLShortener` class, ensuring accuracy and efficiency for the URL shortening service.","solution":"import hashlib class URLShortener: def __init__(self): # Stores the mapping from short_url to long_url self.url_mapping = {} self.base_url = \\"http://short.url/\\" def encode(self, long_url): Encode the given long_url into a short_url. # Use MD5 hash to generate a unique short URL hash_object = hashlib.md5(long_url.encode()) short_key = hash_object.hexdigest()[:6] # Use first 6 characters of the hash short_url = self.base_url + short_key # Map the short URL to the long URL self.url_mapping[short_url] = long_url return short_url def decode(self, short_url): Decode the given short_url back to the original long_url. # Retrieve the long URL from the mapping return self.url_mapping.get(short_url, \\"\\") # Example usage: # url_shortener = URLShortener() # short_url = url_shortener.encode(\\"https://example.com/path/to/resource\\") # print(short_url) # original_url = url_shortener.decode(short_url) # print(original_url)"},{"question":"# Question Context You are developing a booking system for a popular hotel. The core functionality involves ensuring no two bookings overlap for a single room. To support this, you need to implement a checker that determines if a new booking can be added without conflicting with existing ones. Task Implement a function `can_book` that takes a list of existing bookings and a new booking request. The function should return a boolean indicating whether the new booking can be added without any overlapping with any current bookings. Function Signature ```python def can_book(existing_bookings: list[tuple[str, str]], new_booking: tuple[str, str]) -> bool: ``` - **Input**: * existing_bookings: A list of tuples, where each tuple represents an existing booking with start and end dates in ISO format (YYYY-MM-DD). * new_booking: A tuple with start and end dates in ISO format. - **Output**: * A boolean value indicating if the new booking can be accommodated without overlaps. Constraints * Dates are represented in ISO format (YYYY-MM-DD). * Bookings are inclusive of the start date and exclusive of the end date (i.e., a booking from 2022-01-01 to 2022-01-03 means the room is booked on the 1st and 2nd, but free on the 3rd). * No booking will start and end on the same day. * The list of existing bookings will have at most 10^3 entries. - **Performance Requirements**: * The solution should handle up to 10^3 existing bookings efficiently. Example ```python existing_bookings = [ (\\"2022-01-01\\", \\"2022-01-05\\"), (\\"2022-01-07\\", \\"2022-01-10\\"), (\\"2022-01-15\\", \\"2022-01-20\\") ] new_booking = (\\"2022-01-05\\", \\"2022-01-07\\") assert can_book(existing_bookings, new_booking) == True new_booking = (\\"2022-01-04\\", \\"2022-01-06\\") assert can_book(existing_bookings, new_booking) == False ``` Explanation In the given example: 1. The new booking (\\"2022-01-05\\", \\"2022-01-07\\") does not overlap with any existing bookings, so it can be accommodated. 2. The new booking (\\"2022-01-04\\", \\"2022-01-06\\") overlaps with the existing booking (\\"2022-01-01\\", \\"2022-01-05\\"), so it cannot be accommodated. Ensure the function efficiently checks the overlap condition for the given bookings.","solution":"from datetime import datetime def can_book(existing_bookings, new_booking): Checks if a new booking can be accommodated without overlapping with any existing bookings. Args: existing_bookings (list of tuples): Existing bookings with start and end dates. new_booking (tuple): New booking start and end date. Returns: bool: True if the new booking can be added without overlaps, False otherwise. new_start, new_end = [datetime.strptime(date, \\"%Y-%m-%d\\") for date in new_booking] for start, end in existing_bookings: existing_start, existing_end = [datetime.strptime(date, \\"%Y-%m-%d\\") for date in (start, end)] # Check for overlap: if not (new_end <= existing_start or new_start >= existing_end): return False return True"},{"question":"# Coding Question: Finding the Common Elements in Multiple Lists You need to implement a function that finds the common elements in a given list of integer lists. This is a common task in data analysis, where you often need to identify shared items across multiple datasets. Function Signature ```python def find_common_elements(lists: List[List[int]]) -> List[int]: pass ``` # Description 1. **Input Validation**: Ensure that the input is a list of lists containing integers. 2. **Common Elements Function**: Implement a function `find_common_elements` that identifies the integers present in each of the lists provided in the input. # Input - The function takes one parameter: - `lists`: A list of integer lists. # Output - The function returns a list of integers that are present in all the input lists. # Constraints - All integers in the lists will be between -10^5 and 10^5. - The length of the list of lists will not exceed 1000. - Each list within the list of lists will not exceed 1000 integers. # Examples ```python >>> lists = [[1, 2, 3], [2, 3, 4], [3, 4, 5]] >>> print(find_common_elements(lists)) [3] >>> lists = [[-1, -2, -3], [-2, -3, -4], [-5, -6, -3]] >>> print(find_common_elements(lists)) [-3] >>> lists = [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 1, 2, 5, 4]] >>> print(find_common_elements(lists)) [1, 2, 3, 4, 5] ``` # Notes - You may assume the input lists are always non-empty and contain no duplicate integers within the same list. - The order of the common elements in the output list does not matter. - Consider using appropriate data structures to optimize the time complexity of your solution. - Adding docstrings and comments can help improve code readability and maintainability. - Additional edge-case and large input testing is recommended for robustness.","solution":"from typing import List, Set def find_common_elements(lists: List[List[int]]) -> List[int]: Finds the common elements in a given list of integer lists. Parameters: lists (List[List[int]]): A list of integer lists. Returns: List[int]: A list of integers that are present in all input lists. if not lists: return [] # Start with the set of the first list common_elements: Set[int] = set(lists[0]) # Intersect with each subsequent list for lst in lists[1:]: common_elements.intersection_update(lst) # Convert to sorted list before returning return sorted(list(common_elements))"},{"question":"# Problem Statement You are asked to implement a simple data compression algorithm using Run-Length Encoding (RLE). This technique is efficient for data with many repeated values. # Requirements Implement a function `run_length_encode(data: str) -> str` that takes a string and returns its Run-Length Encoded (RLE) version. Implement a function `run_length_decode(encoded_data: str) -> str` that takes an RLE-encoded string and returns its original version. # Components - **Run-Length Encoding (RLE)**: Consecutive occurrences of the same character are replaced with a single character followed by its count. If a character appears once, its count is omitted. # Example: - The string `\\"aaabbbcccaaa\\"` becomes `\\"a3b3c3a3\\"` using RLE. - The string `\\"abc\\"` becomes `\\"abc\\"` using RLE since none of the characters repeat consecutively. # Input Constraints: - `data` is a string containing printable ASCII characters with a length between 1 and 100,000 characters. # Expected Output: For the `run_length_encode` function, return the RLE-encoded string. For the `run_length_decode` function, return the original string. # Example: ```python # Example usage for encoding encoded_data = run_length_encode(\\"aaabbbcccaaa\\") print(\\"Encoded:\\", encoded_data) # Output: \\"a3b3c3a3\\" encoded_data = run_length_encode(\\"abc\\") print(\\"Encoded:\\", encoded_data) # Output: \\"abc\\" # Example usage for decoding original_data = run_length_decode(\\"a3b3c3a3\\") print(\\"Original:\\", original_data) # Output: \\"aaabbbcccaaa\\" original_data = run_length_decode(\\"abc\\") print(\\"Original:\\", original_data) # Output: \\"abc\\" ``` # Notes: 1. Ensure that the implementation is optimized for performance, particularly for handling large input sizes. 2. Handle edge cases such as empty input strings or strings without repetitive characters efficiently. 3. Ensure that the `run_length_decode` function properly interprets and reconstructs the original string from the encoded format.","solution":"def run_length_encode(data: str) -> str: if not data: return \\"\\" encoded_string = [] count = 1 previous_char = data[0] for char in data[1:]: if char == previous_char: count += 1 else: if count > 1: encoded_string.append(f\\"{previous_char}{count}\\") else: encoded_string.append(f\\"{previous_char}\\") previous_char = char count = 1 if count > 1: encoded_string.append(f\\"{previous_char}{count}\\") else: encoded_string.append(f\\"{previous_char}\\") return \\"\\".join(encoded_string) def run_length_decode(encoded_data: str) -> str: if not encoded_data: return \\"\\" decoded_chars = [] i = 0 length = len(encoded_data) while i < length: char = encoded_data[i] j = i + 1 while j < length and encoded_data[j].isdigit(): j += 1 if j != i + 1: count = int(encoded_data[i + 1:j]) decoded_chars.append(char * count) else: decoded_chars.append(char) i = j return \\"\\".join(decoded_chars)"},{"question":"# Problem Statement: # Context: In software development, efficient string manipulation is a crucial task, especially in scenarios such as data processing, text analysis, or code parsing. One common task is to transform a given string by applying a set of rules to each of its characters. **Purpose**: Implement a function that translates input strings by shifting each character by a certain number of positions in the alphabet. # Task: Write a function `caesar_cipher(input_str: str, shift: int) -> str` that takes in two arguments: 1. A string `input_str` which is the text to be transformed. 2. An integer `shift` indicating the number of positions each character in the input string should be shifted in the alphabet. The function should return a new string where each character in the input string is shifted by the specified number of positions, wrapping around the alphabet if necessary. # Input: - A string `input_str` containing only lowercase alphabetic characters (1 <= len(input_str) <= 10^6). - An integer `shift` (1 <= shift <= 25). # Output: - A string representing the transformed input string with each character shifted appropriately. # Constraints: - The function should handle large input strings efficiently. - Assume only lowercase English alphabet characters are provided in the input string. # Example: ```python >>> caesar_cipher(\\"abc\\", 2) \\"cde\\" # Explanation: Each character is shifted by 2 positions: \'a\' -> \'c\', \'b\' -> \'d\', \'c\' -> \'e\'. >>> caesar_cipher(\\"xyz\\", 3) \\"abc\\" # Explanation: Each character is shifted by 3 positions, wrapping around the alphabet: \'x\' -> \'a\', \'y\' -> \'b\', \'z\' -> \'c\'. ``` **Note**: Ensure that the function efficiently processes the string, especially for large inputs, and correctly handles the circular nature of the alphabet when shifting characters past \'z\'.","solution":"def caesar_cipher(input_str: str, shift: int) -> str: Applies a Caesar cipher to the input string by shifting each character by \'shift\' positions. Parameters: input_str (str): The string to be encoded. shift (int): The number of positions to shift each character. Returns: str: The encoded string. result = [] for char in input_str: # Calculate the shifted character considering wrap-around using modular arithmetic shifted_char = chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\')) result.append(shifted_char) # Join the list of characters into a single string return \'\'.join(result)"},{"question":"# Problem Description You are asked to design a Scheduler class that can manage concurrent tasks with dependencies between them. Each task is identified by a unique integer ID and has a list of prerequisites (tasks that must be completed before it). Implement the following functionalities for the scheduler: - `add_task(task_id: int, prerequisites: List[int])`: Adds a new task with its prerequisites. If the task already exists, it will update its prerequisites. - `can_execute(task_id: int) -> bool`: Checks if a task can be executed by verifying that all its prerequisites have been completed. - `mark_completed(task_id: int)`: Marks a task as completed if it is executable. If any prerequisites are not completed, do nothing. - `list_completed() -> List[int]`: Returns a list of all completed task IDs in the order they were marked completed. **Input Constraints** - Task IDs are unique integers. - Prerequisites are given as a list of unique integers. - Task ID ranges between 1 and 10^5. - Number of tasks given as input can be up to 10^4. **Output Description** - Implement the specified functions. - Ensure efficient operations respecting task constraints and dependencies. **Example Input** ```python scheduler = Scheduler() scheduler.add_task(1, []) scheduler.add_task(2, [1]) scheduler.add_task(3, [1, 2]) print(scheduler.can_execute(1)) # Output: True scheduler.mark_completed(1) print(scheduler.can_execute(2)) # Output: True scheduler.mark_completed(2) print(scheduler.can_execute(3)) # Output: True scheduler.mark_completed(3) print(scheduler.list_completed()) # Output: [1, 2, 3] ``` **Detailed Instructions** 1. Implement the `Scheduler` class with: - An `__init__` method to initialize the necessary data structures. - An `add_task` method to add or update tasks and their prerequisites. - A `can_execute` method to check if a task can be executed. - A `mark_completed` method to mark a task as completed. - A `list_completed` method to list all completed tasks in the completion order.","solution":"from typing import List class Scheduler: def __init__(self): self.tasks = {} self.completed = set() self.execution_order = [] def add_task(self, task_id: int, prerequisites: List[int]): self.tasks[task_id] = set(prerequisites) def can_execute(self, task_id: int) -> bool: return task_id in self.tasks and all(prerequisite in self.completed for prerequisite in self.tasks[task_id]) def mark_completed(self, task_id: int): if self.can_execute(task_id): self.completed.add(task_id) self.execution_order.append(task_id) def list_completed(self) -> List[int]: return self.execution_order"},{"question":"# Problem Statement Context In web development, URLs often contain query parameters that are passed to the server to filter or sort the data. Parsing these URLs accurately helps to understand the client\'s request and handle it appropriately. The task is to write a function that processes a given URL and extracts the values of specific query parameters. Task Your task is to implement a function `parse_url_params(url: str, params: List[str]) -> Dict[str, Any]` in Python that takes a URL and a list of parameter names, and returns a dictionary containing the values of those parameters from the URL. If a parameter is not found in the URL, it should not appear in the dictionary. Specifications 1. The URL will be a valid URL string containing query parameters. 2. The `params` list will contain valid query parameter names. 3. The returned dictionary should only include parameters found in the query string of the URL. 4. Query parameters\' values should be URL-decoded. Example ```python url = \\"https://example.com/search?query=python&sort=desc&limit=20\\" params = [\\"query\\", \\"limit\\"] ``` ```python parse_url_params(url, params) # should return {\\"query\\": \\"python\\", \\"limit\\": \\"20\\"} url = \\"https://example.com/search?category=books&query=python&sort=desc\\" params = [\\"category\\", \\"query\\", \\"page\\"] ``` ```python parse_url_params(url, params) # should return {\\"category\\": \\"books\\", \\"query\\": \\"python\\"} ``` Constraints - Do not use external libraries to parse the URL. - Handle cases where the same parameter appears multiple times by taking the last occurrence. - Query parameters may contain special characters and should be URL-decoded. ```python def parse_url_params(url: str, params: List[str]) -> Dict[str, Any]: # Your implementation here pass ```","solution":"from typing import List, Dict, Any import urllib.parse def parse_url_params(url: str, params: List[str]) -> Dict[str, Any]: Parses a given URL and extracts the values of specified query parameters. Args: url (str): The URL containing query parameters. params (List[str]): A list of parameter names to extract from the URL. Returns: Dict[str, Any]: A dictionary with the specified parameters and their corresponding values. query = urllib.parse.urlparse(url).query query_dict = dict(urllib.parse.parse_qsl(query)) return {param: query_dict[param] for param in params if param in query_dict}"},{"question":"# Pascal\'s Triangle Generator You are tasked with implementing a function that generates the first `num_rows` of Pascal\'s triangle. Function Signature ```python def generate_pascals_triangle(num_rows: int) -> List[List[int]]: ``` Input - A single integer `num_rows` where ( 1 leq num_rows leq 30 ). Output - A list of lists, where each inner list represents a row of Pascal’s triangle. Constraints - The function should efficiently generate rows of Pascal\'s triangle. - Consider edge cases where `num_rows` is a minimal or maximum input. Examples 1. `generate_pascals_triangle(1)` should return `[[1]]`. 2. `generate_pascals_triangle(3)` should return `[[1], [1, 1], [1, 2, 1]]`. 3. `generate_pascals_triangle(5)` should return `[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]`. Edge cases to consider: - Ensure the function can handle the smallest input gracefully. - Validate the function at the higher limit of `num_rows`. Implement your solution with thorough consideration of edge cases, performance, and accuracy. Provide appropriate test cases to validate your implementation.","solution":"from typing import List def generate_pascals_triangle(num_rows: int) -> List[List[int]]: Generates the first num_rows of Pascal\'s triangle. Args: num_rows: int - The number of rows of Pascal\'s triangle to generate. Returns: List[List[int]] - A list of lists, where each inner list represents a row of Pascal\'s triangle. triangle = [] for row_number in range(num_rows): # Each row starts with 1 row = [1] * (row_number + 1) # Compute the values for the interior of the row except the first and last element for j in range(1, row_number): row[j] = triangle[row_number - 1][j - 1] + triangle[row_number - 1][j] triangle.append(row) return triangle"},{"question":"# Coding Question Context You are given a list of website logs, each containing the IP address of a user and the timestamp of access to the website. Your task is to process these logs to identify IP addresses that accessed the website more frequently than a given threshold within a specified time window. Task Write a function `frequent_access_detector` that identifies and returns a list of IP addresses that accessed the website more than a given threshold within a specified time window. Function Signature ```python def frequent_access_detector(logs: List[Tuple[str, str]], threshold: int, window: int) -> List[str]: pass ``` Requirements 1. **Input**: * `logs` (List[Tuple[str, str]]): A list of tuples where each tuple contains an IP address and a corresponding timestamp (e.g., `(\'192.168.1.1\', \'2023-10-12T08:12:23Z\')`). * `threshold` (int): The minimum number of accesses within the time window to consider an IP address as a frequent visitor. * `window` (int): The time window in seconds. 2. **Output**: * A list of IP addresses (List[str]) that accessed the website more than the given threshold within the specified time window. 3. **Constraints**: * The input logs are not necessarily ordered by timestamp. * Timestamps are in ISO 8601 format. * Ensure efficient processing given that the number of logs can be large. 4. **Performance**: * Implement the solution with optimal time and space complexity. * Utilize appropriate data structures to manage and query the logs efficiently. Example: ```python logs = [ (\'192.168.1.1\', \'2023-10-12T08:12:23Z\'), (\'192.168.1.2\', \'2023-10-12T08:15:30Z\'), (\'192.168.1.1\', \'2023-10-12T08:22:45Z\'), (\'192.168.1.2\', \'2023-10-12T08:25:10Z\'), (\'192.168.1.1\', \'2023-10-12T08:27:00Z\'), (\'192.168.1.3\', \'2023-10-12T08:30:00Z\') ] threshold = 2 window = 1200 # 20 minutes print(frequent_access_detector(logs, threshold, window)) # Output: [\'192.168.1.1\'] ``` Notes: * Ensure your implementation correctly parses and handles timestamps. * Consider edge cases such as logs with identical timestamps or logs exactly at the threshold boundaries. * Write clean and readable code with adequate comments, ensuring proper error handling and input validation.","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime, timedelta def frequent_access_detector(logs: List[Tuple[str, str]], threshold: int, window: int) -> List[str]: Identifies and returns a list of IP addresses that accessed the website more than a given threshold within a specified time window. :param logs: List of tuples where each tuple contains an IP address and a corresponding timestamp (ISO 8601 format). :param threshold: The minimum number of accesses within the time window to consider an IP address as a frequent visitor. :param window: The time window in seconds. :return: List of IP addresses that accessed the website more than the given threshold within the specified time window. # Convert logs to datetime and group by IP logs_by_ip = defaultdict(list) for ip, timestamp in logs: datetime_obj = datetime.fromisoformat(timestamp.replace(\'Z\', \'+00:00\')) logs_by_ip[ip].append(datetime_obj) result = [] for ip, access_times in logs_by_ip.items(): # Sort access times for each IP access_times.sort() # Sliding window approach to count windowed accesses start = 0 for end in range(len(access_times)): while access_times[end] - access_times[start] > timedelta(seconds=window): start += 1 # Number of accesses in the given window if end - start + 1 > threshold: result.append(ip) break return result"},{"question":"# Running Median You are required to implement a data structure that calculates the median of a stream of integers in real-time. Your class `MedianFinder` should support the following operations: 1. **addNum(num: int) -> None**: Inserts an integer `num` into the data structure. 2. **findMedian() -> float**: Returns the median of all integers inserted so far. The median is defined as follows: - If there are an odd number of elements, the median is the middle element. - If there are an even number of elements, the median is the average of the two middle elements. Constraints: - The operations of the data structure should be optimized for efficiency. Example: ```python medianFinder = MedianFinder() medianFinder.addNum(1) medianFinder.addNum(2) print(medianFinder.findMedian()) # Output: 1.5 medianFinder.addNum(3) print(medianFinder.findMedian()) # Output: 2 ``` Note: - Optimize the `addNum` and `findMedian` methods to operate in logarithmic time complexity. - Consider using two heaps (a max-heap and a min-heap) to keep track of the lower and upper halves of the numbers. Here is a minimal skeleton of the class: ```python import heapq class MedianFinder: def __init__(self): self.minHeap = [] self.maxHeap = [] def addNum(self, num: int) -> None: # Implement the function to add number to the data structure. pass def findMedian(self) -> float: # Implement the function to find the median. pass # Example usage medianFinder = MedianFinder() medianFinder.addNum(1) medianFinder.addNum(2) print(medianFinder.findMedian()) # Output: 1.5 medianFinder.addNum(3) print(medianFinder.findMedian()) # Output: 2 ```","solution":"import heapq class MedianFinder: def __init__(self): self.minHeap = [] # Min-heap for the larger half self.maxHeap = [] # Max-heap for the smaller half (we store negative values for max-heap) def addNum(self, num: int) -> None: # Insert into maxHeap (inverted to function as a max-heap) heapq.heappush(self.maxHeap, -num) # Balance between maxHeap and minHeap if self.maxHeap and self.minHeap and (-self.maxHeap[0] > self.minHeap[0]): val = -heapq.heappop(self.maxHeap) heapq.heappush(self.minHeap, val) # Balance the sizes if len(self.maxHeap) > len(self.minHeap) + 1: val = -heapq.heappop(self.maxHeap) heapq.heappush(self.minHeap, val) elif len(self.minHeap) > len(self.maxHeap): val = heapq.heappop(self.minHeap) heapq.heappush(self.maxHeap, -val) def findMedian(self) -> float: if len(self.maxHeap) > len(self.minHeap): return -self.maxHeap[0] else: return (-self.maxHeap[0] + self.minHeap[0]) / 2.0"},{"question":"# Question: Implement a Custom Data Structure to Simulate a Deque with Variables **Scenario**: In many programming scenarios, you might encounter the need to have a flexible structure that allows fast additions and removals from both ends. A `deque` (double-ended queue) is a classic data structure that serves this purpose. Your task is to simulate a `deque` using two stacks. You are required to create a class called `SimulatedDeque`, which should support the following operations: 1. `add_to_front(element)`: Add an element at the front of the deque. 2. `add_to_rear(element)`: Add an element at the rear of the deque. 3. `remove_from_front() -> element`: Remove and return the element from the front of the deque. If the deque is empty, raise an `IndexError`. 4. `remove_from_rear() -> element`: Remove and return the element from the rear of the deque. If the deque is empty, raise an `IndexError`. 5. `peek_front() -> element`: Return the element from the front without removing it. If the deque is empty, raise an `IndexError`. 6. `peek_rear() -> element`: Return the element from the rear without removing it. If the deque is empty, raise an `IndexError`. # Requirements: * **Class Name**: `SimulatedDeque` * **Methods**: - `add_to_front(element)`: Adds `element` to the front. - `add_to_rear(element)`: Adds `element` to the rear. - `remove_from_front() -> element`: Removes and returns the front element. - `remove_from_rear() -> element`: Removes and returns the rear element. - `peek_front() -> element`: Returns the front element without removing it. - `peek_rear() -> element`: Returns the rear element without removing it. # Implementation Details: - Internally, use two stacks (`list` in Python) to manage the elements of the deque. - Ensure operations are efficient. Average time complexity for each operation should be (O(1)). # Function Signature: ```python class SimulatedDeque: def __init__(self): pass def add_to_front(self, element): pass def add_to_rear(self, element): pass def remove_from_front(self): pass def remove_from_rear(self): pass def peek_front(self): pass def peek_rear(self): pass ``` # Example: ```python deque = SimulatedDeque() # Adding elements to front and rear deque.add_to_front(10) # Deque: [10] deque.add_to_rear(20) # Deque: [10, 20] deque.add_to_front(5) # Deque: [5, 10, 20] deque.add_to_rear(25) # Deque: [5, 10, 20, 25] # Peeking elements print(deque.peek_front()) # Output: 5 print(deque.peek_rear()) # Output: 25 # Removing elements from front and rear print(deque.remove_from_front()) # Output: 5 print(deque.remove_from_rear()) # Output: 25 print(deque.remove_from_front()) # Output: 10 print(deque.remove_from_front()) # Output: 20 # Testing error situations try: print(deque.remove_from_front()) # Should raise IndexError except IndexError: print(\\"Deque is empty\\") ``` # Constraints: 1. Handle edge cases where the deque is empty appropriately by raising `IndexError`.","solution":"class SimulatedDeque: def __init__(self): self.front_stack = [] self.rear_stack = [] def add_to_front(self, element): self.front_stack.append(element) def add_to_rear(self, element): self.rear_stack.append(element) def remove_from_front(self): if not self.front_stack: while self.rear_stack: self.front_stack.append(self.rear_stack.pop()) if not self.front_stack: raise IndexError(\\"Deque is empty\\") return self.front_stack.pop() def remove_from_rear(self): if not self.rear_stack: while self.front_stack: self.rear_stack.append(self.front_stack.pop()) if not self.rear_stack: raise IndexError(\\"Deque is empty\\") return self.rear_stack.pop() def peek_front(self): if not self.front_stack: while self.rear_stack: self.front_stack.append(self.rear_stack.pop()) if not self.front_stack: raise IndexError(\\"Deque is empty\\") return self.front_stack[-1] def peek_rear(self): if not self.rear_stack: while self.front_stack: self.rear_stack.append(self.front_stack.pop()) if not self.rear_stack: raise IndexError(\\"Deque is empty\\") return self.rear_stack[-1]"},{"question":"Question: Implement a Custom Data Logger You are tasked with creating a custom data logger that records and manages logs. The logs will be classified into three different levels: `INFO`, `WARNING`, and `ERROR`. Implement a class `DataLogger` that provides the functionality to add logs, retrieve logs of a specified level, and retrieve all logs. **Class Definition**: `DataLogger` **Attributes**: 1. `logs`: A dictionary where the keys are log levels (`INFO`, `WARNING`, `ERROR`) and the values are lists of log messages. **Methods**: 1. `__init__()`: Initializes an empty log dictionary with keys `INFO`, `WARNING`, and `ERROR`. 2. `add_log(level: str, message: str) -> None`: Adds a log message under the specified level. 3. `get_logs(level: str) -> list`: Retrieves all logs of the specified level. Returns an empty list if there are no logs of the specified level. 4. `get_all_logs() -> dict`: Retrieves all logs categorized by levels. Returns the dictionary with all logs. **Input**: - All methods take strings as input for level (`INFO`, `WARNING`, `ERROR`) and message. - Ensures that the log levels are strictly one of the three specified levels. **Output**: - `add_log` does not return anything. - `get_logs(level)` returns a list of log messages. - `get_all_logs()` returns a dictionary with log levels as keys and lists of log messages as values. # Example ```python logger = DataLogger() logger.add_log(\'INFO\', \'System startup\') logger.add_log(\'WARNING\', \'Low disk space\') logger.add_log(\'ERROR\', \'File not found\') logger.add_log(\'INFO\', \'User logged in\') print(logger.get_logs(\'INFO\')) # Output: [\'System startup\', \'User logged in\'] print(logger.get_logs(\'WARNING\')) # Output: [\'Low disk space\'] print(logger.get_logs(\'ERROR\')) # Output: [\'File not found\'] print(logger.get_logs(\'DEBUG\')) # Output: [] print(logger.get_all_logs()) # Output: { # \'INFO\': [\'System startup\', \'User logged in\'], # \'WARNING\': [\'Low disk space\'], # \'ERROR\': [\'File not found\'] # } ``` # Constraints: - The log levels will be provided as valid strings (`INFO`, `WARNING`, `ERROR`). - Messages will be non-empty strings. - Handle edge cases where no logs of a specified level exist. Implement the `DataLogger` class ensuring all constraints are respected and functionality is accurate.","solution":"class DataLogger: def __init__(self): Initializes an empty log dictionary with keys `INFO`, `WARNING`, and `ERROR`. self.logs = {\\"INFO\\": [], \\"WARNING\\": [], \\"ERROR\\": []} def add_log(self, level, message): Adds a log message under the specified level. Assumes `level` is one of \'INFO\', \'WARNING\', \'ERROR\'. if level in self.logs: self.logs[level].append(message) def get_logs(self, level): Retrieves all logs of the specified level. Returns an empty list if there are no logs of the specified level. return self.logs.get(level, []) def get_all_logs(self): Retrieves all logs categorized by levels. Returns the dictionary with all logs. return self.logs"},{"question":"# Matrix Properties Verification Problem Statement: In linear algebra, matrices have various properties, such as being symmetric or orthogonal, that are crucial in computational mathematics and data science applications. A matrix is symmetric if it is equal to its transpose, and orthogonal if the product of the matrix and its transpose is the identity matrix. You are required to implement two functions, `is_symmetric` and `is_orthogonal`, in Python, adhering to the following specifications: 1. `is_symmetric(matrix: List[List[float]]) -> bool`: This function should take a square matrix (a list of lists of floats) as input and return `True` if the matrix is symmetric, and `False` otherwise. Raise a `ValueError` if the matrix is not square. - A matrix is symmetric if it is equal to its transpose. 2. `is_orthogonal(matrix: List[List[float]]) -> bool`: This function should take a square matrix (a list of lists of floats) as input and return `True` if the matrix is orthogonal, and `False` otherwise. Raise a `ValueError` if the matrix is not square. - A matrix is orthogonal if the product of the matrix and its transpose is the identity matrix. Input and Output 1. `is_symmetric(matrix: List[List[float]]) -> bool` - **Input**: `matrix` (a list of lists of floats representing a square matrix) - **Output**: A boolean `True` if the matrix is symmetric, `False` otherwise. 2. `is_orthogonal(matrix: List[List[float]]) -> bool` - **Input**: `matrix` (a list of lists of floats representing a square matrix) - **Output**: A boolean `True` if the matrix is orthogonal, `False` otherwise. Constraints - The input matrix should be square (i.e., the number of rows should be equal to the number of columns). Examples: ```python # Example usage: matrix1 = [ [1, 2, 3], [2, 5, 6], [3, 6, 9] ] matrix2 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] matrix3 = [ [0.6, 0.8], [0.8, -0.6] ] print(is_symmetric(matrix1)) # Expected output: False print(is_symmetric(matrix2)) # Expected output: True print(is_orthogonal(matrix2)) # Expected output: True print(is_orthogonal(matrix3)) # Expected output: True # Non-square matrix input example: matrix4 = [ [1, 2], [3, 4], [5, 6] ] print(is_symmetric(matrix4)) # Expected output: ValueError: Matrix must be square print(is_orthogonal(matrix4)) # Expected output: ValueError: Matrix must be square ``` ```python # Implementation of functions from typing import List import numpy as np def is_symmetric(matrix: List[List[float]]) -> bool: rows = len(matrix) for row in matrix: if len(row) != rows: raise ValueError(\\"Matrix must be square.\\") for i in range(rows): for j in range(rows): if matrix[i][j] != matrix[j][i]: return False return True def is_orthogonal(matrix: List[List[float]]) -> bool: rows = len(matrix) for row in matrix: if len(row) != rows: raise ValueError(\\"Matrix must be square.\\") nparr = np.array(matrix) identity = np.identity(rows) product = np.matmul(nparr, nparr.T) return np.allclose(product, identity) ```","solution":"from typing import List import numpy as np def is_symmetric(matrix: List[List[float]]) -> bool: rows = len(matrix) for row in matrix: if len(row) != rows: raise ValueError(\\"Matrix must be square.\\") for i in range(rows): for j in range(rows): if matrix[i][j] != matrix[j][i]: return False return True def is_orthogonal(matrix: List[List[float]]) -> bool: rows = len(matrix) for row in matrix: if len(row) != rows: raise ValueError(\\"Matrix must be square.\\") nparr = np.array(matrix) identity = np.identity(rows) product = np.matmul(nparr, nparr.T) return np.allclose(product, identity)"},{"question":"# Question: Implementing a Simplified Pathfinding Algorithm **Context**: Pathfinding is a common problem in algorithms, especially pertinent to areas such as game development, robotics, and network routing. One popular algorithm for pathfinding is A*. In this task, we will simplify the problem to a grid-based pathfinding where we want to find the shortest path between two points while avoiding obstacles. **Task**: Write a Python function `shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int` that computes the minimum number of steps required to reach the `end` point from the `start` point on a 2D grid. You can only move up, down, left, or right. Obstacles are represented by `1`s in the grid, while open spaces are represented by `0`s. # Input * `grid` — A 2D list of integers where `0` represents an open cell and `1` represents an obstacle. The dimensions of the grid are at most `100x100`. * `start` — A tuple `(x1, y1)` representing the starting coordinates in the grid. * `end` — A tuple `(x2, y2)` representing the destination coordinates in the grid. # Output * An integer representing the minimum number of steps required to reach the `end` point from the `start` point, or `-1` if there is no valid path. # Constraints * The function should complete in a reasonable time frame for grids up to `100x100`. * `start` and `end` are always within the bounds of the grid and on open cells (i.e., `grid[start[0]][start[1]] == 0` and `grid[end[0]][end[1]] == 0`). # Example ```python # Example 1: # Given grid: # 0 1 0 0 0 # 0 1 0 1 0 # 0 0 0 1 0 # 0 1 0 0 0 # Start: (0, 0) # End: (3, 4) # The shortest path requires 7 steps. grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0] ] start = (0, 0) end = (3, 4) print(shortest_path(grid, start, end)) # Output: 7 # Example 2: # Given grid: # 0 1 0 # 1 1 0 # 0 0 0 # Start: (0, 0) # End: (2, 2) # There is no valid path to the end. grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) print(shortest_path(grid, start, end)) # Output: -1 ``` # Implementation Details 1. Use a Breadth-First Search (BFS) approach to explore the shortest path in the grid. 2. Maintain a queue to store the current cell and the number of steps taken to reach that cell. 3. Use a set to keep track of visited cells to avoid revisiting them. 4. If you reach the `end` cell, return the number of steps taken. 5. If all possible paths are exhausted and the `end` cell is not reached, return -1.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path from start to end in a 2D grid. Parameters: - grid: 2D list of integers where 0 represents open cells and 1 represents obstacles. - start: Tuple representing the starting coordinates (x1, y1). - end: Tuple representing the destination coordinates (x2, y2). Returns: - The minimum number of steps required to reach the end point from the start point, or -1 if there is no valid path. # Directions for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x: int, y: int) -> bool: Check if the cell (x, y) is within the grid bounds and is not an obstacle. return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 queue = deque([(start, 0)]) # Store the current cell position and the number of steps visited = set(start) # Set of visited cells while queue: (x, y), steps = queue.popleft() # Check if we have reached the end if (x, y) == end: return steps # Explore the neighboring cells for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), steps + 1)) # If all possible paths are exhausted and end is not reached return -1"},{"question":"# Coding Question Context Graph traversal algorithms are crucial for solving numerous problems in computer science. One common algorithm is Breadth-First Search (BFS), which explores all the neighbor nodes at the present depth level before moving on to nodes at the next depth level. Task Implement a BFS algorithm in a class `GraphTraversal` that: 1. Initializes a graph using an adjacency list. 2. Performs a BFS traversal from a given starting node. 3. Returns the order of nodes visited during the BFS traversal. Class Interface ```python class GraphTraversal: def __init__(self, graph: dict): Initialize the graph with an adjacency list. def bfs(self, start_node: int) -> list: Perform a BFS traversal starting from the `start_node` and return the order of nodes visited. ``` Input - Initialize the `GraphTraversal` with: * `graph`: A dictionary representing an adjacency list, where keys are node integers and values are lists of adjacent nodes. - `bfs(start_node: int)`: The integer `start_node` from which the BFS traversal starts. Output - The `bfs` method should return a list of node integers in the order they were visited. Example Usage ```python # Graph represented as adjacency list graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1, 4], 4: [1, 2, 3] } # Initialize GraphTraversal traversal = GraphTraversal(graph) # Perform BFS starting from node 0 print(traversal.bfs(0)) # Output: [0, 1, 2, 3, 4] or any order reflecting BFS ``` Constraints - The graph is undirected. - All nodes are connected. - The graph contains no cycles. - Each node value is a non-negative integer. - The graph contains at least one node.","solution":"class GraphTraversal: def __init__(self, graph: dict): Initialize the graph with an adjacency list. self.graph = graph def bfs(self, start_node: int) -> list: Perform a BFS traversal starting from the `start_node` and return the order of nodes visited. visited = [] queue = [start_node] while queue: node = queue.pop(0) if node not in visited: visited.append(node) neighbors = [n for n in self.graph.get(node, []) if n not in visited] queue.extend(neighbors) return visited"},{"question":"# Context: You are working on a system to manage documents and their revisions. The system needs a feature to check if a set of documents contains any duplicates after a series of operations. Each document can be represented by a unique ID and the operations can either add a new document to the set or check if a document with a specific ID already exists. # Task: Implement a function `manage_document_set(operations: List[Tuple[str, int]]) -> List[bool]` that processes a list of operations. Each operation is a tuple containing: - An operation type: \\"add\\" or \\"check\\" - An integer representing the document ID involved in the operation For \\"add\\" operation, you should add the document ID to the set. For \\"check\\" operation, you should check if the document ID is already in the set. The function should return a list of booleans corresponding to each \\"check\\" operation. If the document ID is in the set, return `True`, otherwise `False`. # Input: - `operations`: List of tuples where each tuple is of the form (operation_type, document_id). # Output: - A list of booleans representing the result of each \\"check\\" operation. # Constraints: - The document IDs are non-negative integers. - document_id in each operation is valid. # Example: ```python operations = [ (\\"add\\", 101), (\\"add\\", 102), (\\"check\\", 101), (\\"check\\", 103), (\\"add\\", 103), (\\"check\\", 103) ] Output = [True, False, True] ``` # Implementation Notes: 1. Use a set to store document IDs. 2. Implement the `manage_document_set` function to handle the operations as per the requirements. Good luck!","solution":"def manage_document_set(operations): Processes a list of operations to manage a set of document IDs. Parameters: operations (List[Tuple[str, int]]): List of tuples containing operations. Returns: List[bool]: List of booleans corresponding to the result of each \\"check\\" operation. document_set = set() results = [] for op, doc_id in operations: if op == \\"add\\": document_set.add(doc_id) elif op == \\"check\\": results.append(doc_id in document_set) return results"},{"question":"# Coding Assessment Question Background An e-commerce platform maintains a product inventory database, which includes the name, price, and quantity of each product available for sale. Occasionally, the platform needs to update the inventory with new shipments, restock quantities for existing products, or even remove discontinued products. Objective Create a class named `ProductInventory` which provides methods to manage the inventory effectively. This class should allow adding new products, updating the quantity of existing products, removing products, and printing the current inventory in a sorted manner by product name. Class Signature ```python class ProductInventory: def __init__(self): # Initialize the inventory dictionary. pass def add_product(self, name: str, price: float, quantity: int) -> None: # Add a new product to the inventory. # If the product already exists, update its quantity. pass def remove_product(self, name: str) -> None: # Remove a product from the inventory. pass def update_quantity(self, name: str, quantity: int) -> None: # Update the quantity of an existing product. pass def print_inventory(self) -> None: # Print the inventory sorted by product name. pass ``` Input - `name` (str): The name of the product. - `price` (float): The price of the product. - `quantity` (int): The quantity of the product. Output - `print_inventory`: Should print the inventory in the format: ``` Product: <name>, Price: <price>, Quantity: <quantity> ``` Constraints 1. The product name, price, and quantity must be valid according to their respective data types. 2. The quantity of any product must be a non-negative integer. Example ```python inventory = ProductInventory() inventory.add_product(\\"Apples\\", 1.2, 150) inventory.add_product(\\"Oranges\\", 0.8, 100) inventory.add_product(\\"Bananas\\", 0.5, 200) inventory.update_quantity(\\"Apples\\", 50) inventory.remove_product(\\"Oranges\\") inventory.print_inventory() ``` Output: ``` Product: Apples, Price: 1.2, Quantity: 200 Product: Bananas, Price: 0.5, Quantity: 200 ``` Notes - Ensure the class methods handle edge cases such as attempting to update the quantity of a non-existent product or attempting to add a product with invalid data types. - Careful consideration is needed for managing and updating the product inventory while maintaining an efficient search and sort mechanism.","solution":"class ProductInventory: def __init__(self): self.inventory = {} def add_product(self, name: str, price: float, quantity: int) -> None: if name in self.inventory: self.inventory[name][\'quantity\'] += quantity else: self.inventory[name] = {\'price\': price, \'quantity\': quantity} def remove_product(self, name: str) -> None: if name in self.inventory: del self.inventory[name] def update_quantity(self, name: str, quantity: int) -> None: if name in self.inventory and quantity >= 0: self.inventory[name][\'quantity\'] = quantity def print_inventory(self) -> None: for name in sorted(self.inventory.keys()): product = self.inventory[name] print(f\\"Product: {name}, Price: {product[\'price\']}, Quantity: {product[\'quantity\']}\\")"},{"question":"# String Permutation Challenge Problem Statement You are given two strings, `s1` and `s2`. You need to implement a function that determines if `s2` contains a permutation of `s1`. In other words, one of the first string\'s permutations is the substring of the second string. Function Signature ```python def check_inclusion(s1: str, s2: str) -> bool: pass ``` Input - `s1` (str): A string of lowercase English letters with a length between 1 and 100. - `s2` (str): A string of lowercase English letters with a length between 1 and 10000. Output - `bool`: Return `True` if `s2` contains a permutation of `s1`, otherwise return `False`. Example ```python assert check_inclusion(\\"ab\\", \\"eidbaooo\\") == True assert check_inclusion(\\"ab\\", \\"eidboaoo\\") == False assert check_inclusion(\\"abc\\", \\"ccccbbbbaaaa\\") == False assert check_inclusion(\\"\\", \\"\\") == True # Both strings are empty ``` Constraints 1. Both input strings `s1` and `s2` contain only lowercase English letters. 2. The length of `s1` will always be less than or equal to the length of `s2`. # Requirements 1. Implement the function to handle the input sizes efficiently. 2. Address edge cases like empty strings and strings with repeated characters.","solution":"def check_inclusion(s1: str, s2: str) -> bool: from collections import Counter len1, len2 = len(s1), len(s2) if len1 > len2: return False s1_count = Counter(s1) s2_count = Counter(s2[:len1]) if s1_count == s2_count: return True for i in range(len1, len2): s2_count[s2[i]] += 1 s2_count[s2[i - len1]] -= 1 if s2_count[s2[i - len1]] == 0: del s2_count[s2[i - len1]] if s1_count == s2_count: return True return False"},{"question":"# Question **Context**: You are a software engineer at a logistics company that ensures timely delivery of packages across various cities. Your manager has assigned you the task of optimizing the delivery routes to minimize the total delivery time while ensuring all cities are connected. Daily, you receive a list of direct routes between cities with the corresponding travel time and it\'s imperative to find the most efficient way to connect all the cities. **Task**: Implement Kruskal\'s algorithm to find the minimum spanning tree (MST) given a list of routes and travel times between cities. **Function Signature**: ```python def kruskal_mst(n: int, edges: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]: Args: - n: An integer representing the number of cities (nodes). - edges: A list of tuples, where each tuple consists of three integers (u, v, w) representing a direct route between cities u and v with travel time w. Returns: - A list of tuples, each containing three integers (u, v, w), representing the edges in the MST. ``` **Requirements**: 1. Implement the function `kruskal_mst` that takes in: * `n`: An integer representing the number of cities. * `edges`: A list of tuples, where each tuple `(u, v, w)` represents a direct route between cities `u` and `v` with travel time `w`. 2. The function should return a list of tuples. Each tuple should contain exactly three integers `(u, v, w)` representing an edge in the MST of the graph. 3. Ensure that all cities are connected in the most efficient way (minimum total travel time). **Examples**: ```python >>> n = 4 >>> edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] >>> kruskal_mst(n, edges) [(2, 3, 4), (0, 3, 5), (0, 1, 10)] >>> n = 3 >>> edges = [(0, 1, 1), (1, 2, 4), (0, 2, 3)] >>> kruskal_mst(n, edges) [(0, 1, 1), (0, 2, 3)] ``` **Constraints**: * The number of cities ( n ) is between 1 and ( 10^5 ). * The number and travel time of routes (edges) ( m ) is between 1 and ( 10^6 ). * Each route is a tuple of three integers `(u, v, w)` where: * ( 0 leq u, v < n ) (cities are represented as integers from 0 to ( n-1 )) * ( 1 leq w leq 10^5 ) (travel time is a positive integer) Good luck, and happy coding!","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): # Initializing result array result = [] # Sorting edges based on the weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) e = 0 # Initialize count of edges in result array i = 0 # Index to iterate through sorted edges while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) return result # Example usage: # n = 4 # edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] # print(kruskal_mst(n, edges))"},{"question":"# Longest Substring with Exactly `k` Distinct Characters Context You are tasked with providing insights into customer behavior on an e-commerce platform. One useful metric is the diversity of product categories visited by customers. Given a string representing product categories visited by a customer, you need to analyze it to find the longest contiguous substring that contains exactly `k` distinct product categories. Problem Statement Write a function `longest_substring_with_k_distinct` that takes in a string `s` and an integer `k`, and returns the length of the longest substring that contains exactly `k` distinct characters. Input Format - A string `s` consisting of lowercase English letters, where `1 <= len(s) <= 10^6`. - An integer `k`, where `1 <= k <= 26`. Output Format - An integer representing the length of the longest substring containing exactly `k` distinct characters. If no such substring exists, return 0. Constraints - The input string may contain repeated characters. - Ensure the solution is efficient with respect to time complexity. Performance Requirements - The solution should have a time complexity of O(n), where `n` is the length of the string `s`. - The space complexity should be O(k), handling the frequency count of distinct characters. Function Signature ```python def longest_substring_with_k_distinct(s: str, k: int) -> int: pass ``` Example ```python # Example 1 s = \\"eceba\\" k = 2 # The longest substring with exactly 2 distinct characters is \\"ece\\" with length 3. assert longest_substring_with_k_distinct(s, k) == 3 # Example 2 s = \\"aa\\" k = 1 # The longest substring with exactly 1 distinct character is \\"aa\\" with length 2. assert longest_substring_with_k_distinct(s, k) == 2 # Example 3 s = \\"abaccc\\" k = 2 # The longest substring with exactly 2 distinct characters is \\"accc\\" with length 4. assert longest_substring_with_k_distinct(s, k) == 4 ``` Solution ```python def longest_substring_with_k_distinct(s: str, k: int) -> int: from collections import defaultdict if k == 0 or not s: return 0 char_frequency = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_frequency[s[right]] += 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 if len(char_frequency) == k: max_length = max(max_length, right - left + 1) return max_length ``` Write unit tests to verify the correctness of the implementation across various edge cases and scenarios.","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: from collections import defaultdict if k == 0 or not s: return 0 char_frequency = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_frequency[s[right]] += 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 if len(char_frequency) == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem: Transforming Strings with Conditional Replacements You are tasked with creating a function `transform_string` which will take a string and transform it based on the following rules: - Replace each vowel in the string with its uppercase equivalent. - Replace each consonant in the string with its lowercase equivalent. - Ignore non-alphabetical characters and leave them unchanged. Function Signature: ```python def transform_string(input_str: str) -> str: :param input_str: str The string to be transformed based on the rules specified. :return: str A new string where: * Each vowel is converted to its uppercase equivalent. * Each consonant is converted to its lowercase equivalent. * Non-alphabetical characters remain unchanged. Example: >>> transform_string(\\"Hello! How are you?\\") \'hEllO! hOw ArE yOU?\' >>> transform_string(\\"Programming123\\") \'prOgrAmmIng123\' >>> transform_string(\\"Data Science\\") \'dAtA scIEncE\' ``` # Constraints: * The input string length will be between 1 and 1000 characters. * The function must handle both uppercase and lowercase letters in the input string. * The function must preserve any non-alphabetical characters such as numbers, punctuation, and spaces. Inputs: * **input_str**: A string containing alphabetic and non-alphabetic characters. Outputs: * A new string where vowels are transformed to uppercase, consonants to lowercase, and non-alphabetical characters remain unchanged. # Example: Input: `\\"Hello! How are you?\\"` Output: `\'hEllO! hOw ArE yOU?\'` Input: `\\"Programming123\\"` Output: `\'prOgrAmmIng123\'` Input: `\\"Data Science\\"` Output: `\'dAtA scIEncE\'` # Be sure to: * Consider both uppercase and lowercase letters in the transformation process. * Optimize for readability and maintainability of code. --- This question aligns with the coding style, complexity, and scope of the original set, and it tests the candidate\'s ability to manipulate strings while handling specific conditional transformations.","solution":"def transform_string(input_str: str) -> str: vowels = \\"aeiouAEIOU\\" result = [] for char in input_str: if char.isalpha(): if char in vowels: result.append(char.upper()) else: result.append(char.lower()) else: result.append(char) return \\"\\".join(result)"},{"question":"# Prime Anagram Pair Checker Problem Statement: An anagram pair of two numbers is formed when one number can be rearranged to produce the other number. A pair of numbers is termed an anagram prime pair if both numbers are prime and are anagrams of each other. Your task is to implement a function that verifies whether two given numbers form a prime anagram pair. Input: - Two integers `number1` and `number2` (2 <= number1, number2 <= 10^6). Output: - Return `True` if the numbers form a prime anagram pair, otherwise return `False`. Example: ```python is_prime_anagram_pair(13, 31) # Output: True is_prime_anagram_pair(17, 71) # Output: True is_prime_anagram_pair(23, 32) # Output: False ``` Constraints: - Ensure the function efficiently checks for both prime nature and anagram condition. - Consider cases where the numbers might be identical or not prime. Implementation Requirements: - Utilize a precomputed list or an efficient algorithm to check for prime numbers. - Use a string manipulation technique to check for the anagram condition. Starter Code: ```python def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_anagram_pair(number1: int, number2: int) -> bool: Determine if the given numbers form a prime anagram pair. :param number1: int: the first number to check :param number2: int: the second number to check :return: bool: True if the numbers form a prime anagram pair, False otherwise if not (is_prime(number1) and is_prime(number2)): return False return sorted(str(number1)) == sorted(str(number2)) # Example usage: if __name__ == \\"__main__\\": number1 = int(input(\\"Enter first number: \\").strip()) number2 = int(input(\\"Enter second number: \\").strip()) result = is_prime_anagram_pair(number1, number2) print(f\\"{number1} and {number2} are {\'a\' if result else \'not a\'} prime anagram pair.\\") ```","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_anagram_pair(number1: int, number2: int) -> bool: Determine if the given numbers form a prime anagram pair. :param number1: int: the first number to check :param number2: int: the second number to check :return: bool: True if the numbers form a prime anagram pair, False otherwise if not (is_prime(number1) and is_prime(number2)): return False return sorted(str(number1)) == sorted(str(number2))"},{"question":"In this task, you are required to implement a function that transposes a given matrix. The transpose of a matrix is obtained by swapping the rows and columns of the original matrix. Implement a function `transpose(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list of integers representing the matrix and returns the transposed matrix. # Function Signature ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - `matrix`: A 2D list of integers where each sublist represents a row of the matrix. # Output - A 2D list of integers representing the transposed matrix, where element at position `matrix[i][j]` in the original matrix appears at position `matrix[j][i]` in the transposed matrix. # Constraints - The input matrix will have dimensions m x n where 1 <= m, n <= 1000. - The elements of the matrix will be integers in the range `[-10^6, 10^6]`. # Example ```python >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1]]) [[1]] >>> transpose([[3, 5, 7], [1, 4, 9]]) [[3, 1], [5, 4], [7, 9]] ``` # Requirements - The function should handle matrices of varying dimensions efficiently. - Ensure that the function correctly swaps row and column indices to produce the transposed matrix. - Performance should be optimized for larger matrices, adhering to an overall complexity of O(m*n). This question tests your understanding of data structure manipulation and efficient algorithm implementation.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. This function takes a matrix (a list of lists) and returns a new matrix that is the transpose of the original. The transpose of a matrix is obtained by swapping the rows and columns. Args: matrix: List[List[int]] - A 2D list where each sublist represents a row of the matrix. Returns: List[List[int]] - The transposed matrix. # Number of rows in the original matrix rows = len(matrix) # Number of columns in the original matrix cols = len(matrix[0]) # Initialize the transposed matrix with empty lists transposed_matrix = [[0] * rows for _ in range(cols)] # Iterate over the rows and columns to swap indices for i in range(rows): for j in range(cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"# Coding Assessment Question: Find Longest Harmonious Subsequence **Objective:** Write a function, `find_LHS(nums: List[int]) -> int`, to find the length of the longest harmonious subsequence of an array. A harmonious subsequence is one where the difference between the maximum and minimum values is exactly 1. **Input:** - A list of integers `nums`. **Output:** - An integer representing the length of the longest harmonious subsequence in the array. **Constraints:** - The length of `nums` will be in the range 0 leq |nums| leq 10^5. - The values in `nums` will be integers in the range -10^9 leq nums[i] leq 10^9. - The function should handle both small and large datasets efficiently. **Performance Requirements:** - Emphasize efficiency to ensure the function performs well on larger datasets. - Utilize appropriate data structures to aid in the quick calculation of frequencies and subsequence validation. **Scenario/Context:** Envision providing a solution tool for data analysts to interpret large datasets. Your function will contribute to identifying patterns within numerical sequences, specifically focusing on finding subsets with tightly constrained values. **Function Signature:** ```python def find_LHS(nums: List[int]) -> int: pass ``` **Example:** ```python # Example 1 print(find_LHS([1,3,2,2,5,2,3,7])) # Expected output: 5 # Example 2 print(find_LHS([1,2,3,4])) # Expected output: 2 # Example 3 print(find_LHS([1,1,1,1])) # Expected output: 0 ``` **Explanation:** For the input `[1,3,2,2,5,2,3,7]`, the longest harmonious subsequence is `[3,2,2,2,3]` as the difference between maximum and minimum values is exactly 1, and the length of this subsequence is 5. For the input `[1,2,3,4]`, the longest harmonious subsequence can be `[1,2]`, `[2,3]`, or `[3,4]`, but all of them have a length of 2. For the input `[1,1,1,1]`, there\'s no subsequence with minimum and maximum values differing by exactly 1, so the output is 0. Your task is to generalize this approach to any given list of integers.","solution":"from typing import List from collections import Counter def find_LHS(nums: List[int]) -> int: # Use a Counter to keep track of the frequency of each element freq_map = Counter(nums) max_length = 0 # Iterate through each element in the frequency map for num in freq_map: # Check if the consecutive element exists if num + 1 in freq_map: # Calculate the length of the harmonious subsequence current_length = freq_map[num] + freq_map[num + 1] # Update max_length if the current_length is greater max_length = max(max_length, current_length) return max_length"},{"question":"# Event Time Overlap You are creating a function to determine the overlapping duration between two events. Each event is characterized by a start time and an end time. The times are given in 24-hour format (HH:MM), and you need to implement a function that returns the total overlapping duration in minutes. You must write a function `event_overlap(event1: Tuple[str, str], event2: Tuple[str, str]) -> int` that takes two events as input. Each event is represented as a tuple of two strings (start time, end time). The function should return the duration in minutes of the overlapping time between the two events. If there is no overlap, return 0. # Function Signature ```python def event_overlap(event1: Tuple[str, str], event2: Tuple[str, str]) -> int: pass ``` # Input - `event1`: A tuple containing the start and end times of the first event (`\\"HH:MM\\"`, `\\"HH:MM\\"`). - `event2`: A tuple containing the start and end times of the second event (`\\"HH:MM\\"`, `\\"HH:MM\\"`). # Output - An integer representing the duration in minutes of the overlap between the two events. # Examples ```python print(event_overlap((\\"10:00\\", \\"12:30\\"), (\\"11:00\\", \\"13:00\\"))) # Expected output: 90 print(event_overlap((\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"))) # Expected output: 0 print(event_overlap((\\"14:00\\", \\"15:00\\"), (\\"13:30\\", \\"14:30\\"))) # Expected output: 30 ``` # Constraints - The times will always be valid and in the correct format. - Both events\' start and end times follow the proper chronological order, i.e., start <= end. - Assume that the times are all on the same day. # Notes - Consider converting the time strings to a more manageable numerical representation (e.g., minutes from midnight) to simplify calculations. - Focus on the overlap logic to ensure accurate determination of overlapping periods.","solution":"from typing import Tuple def time_to_minutes(time: str) -> int: Convert time in \\"HH:MM\\" format to minutes since midnight. hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes def event_overlap(event1: Tuple[str, str], event2: Tuple[str, str]) -> int: Calculate the overlap duration in minutes between two events. start1, end1 = event1 start2, end2 = event2 start1_min = time_to_minutes(start1) end1_min = time_to_minutes(end1) start2_min = time_to_minutes(start2) end2_min = time_to_minutes(end2) overlap_start = max(start1_min, start2_min) overlap_end = min(end1_min, end2_min) if overlap_start < overlap_end: return overlap_end - overlap_start else: return 0"},{"question":"# Problem Statement You are given an inventory system of a warehouse that categorizes items based on their type. Each item has a unique identifier, type, and a price. Your task is to implement a system that can identify the most expensive item of each type from the inventory. # Task Implement a function `find_most_expensive(items: List[Tuple[str, str, float]]) -> Dict[str, str]` that takes a list of tuples as input, where each tuple represents an item with its unique identifier, type, and price. The function should return a dictionary with the item types as keys and the identifiers of the most expensive items as values. Input Format - `items`: A list of tuples, where each tuple contains three elements: - A string representing the unique identifier of the item. - A string representing the type of the item. - A float representing the price of the item. Output Format - The function should return a dictionary where: - The keys are strings representing the item types. - The values are strings representing the identifiers of the most expensive items for each type. # Constraints - The input list will contain at most 100 different items. - There will be at least one item of each type in the input list. - The prices will be positive numbers. # Example ```python def find_most_expensive(items: List[Tuple[str, str, float]]) -> Dict[str, str]: # Your code here # Example Usage: items = [ (\\"item1\\", \\"typeA\\", 29.99), (\\"item2\\", \\"typeA\\", 45.50), (\\"item3\\", \\"typeB\\", 10.00), (\\"item4\\", \\"typeB\\", 15.75), (\\"item5\\", \\"typeC\\", 5.00) ] print(find_most_expensive(items)) # Expected output: {\'typeA\': \'item2\', \'typeB\': \'item4\', \'typeC\': \'item5\'} ``` *Note*: Ensure that your implementation correctly identifies the most expensive item for each type, considering the constraints and handling edge cases where multiple items have the same price.","solution":"from typing import List, Tuple, Dict def find_most_expensive(items: List[Tuple[str, str, float]]) -> Dict[str, str]: Finds the most expensive item of each type from the inventory. Parameters: items (List[Tuple[str, str, float]]): List of tuples containing item identifier, type, and price. Returns: Dict[str, str]: A dictionary where keys are item types and values are the identifiers of the most expensive items. most_expensive = {} for identifier, type_, price in items: if type_ not in most_expensive: most_expensive[type_] = (identifier, price) else: if price > most_expensive[type_][1]: most_expensive[type_] = (identifier, price) # Extracting only the identifiers for the return dictionary return {type_: identifier for type_, (identifier, price) in most_expensive.items()}"},{"question":"Task Scheduling You are tasked with implementing a basic task scheduling algorithm to determine the minimum time required to complete all given tasks with the provision of cooling periods between identical tasks. **Objective**: Write a Python function `least_interval(tasks: list, n: int) -> int` that returns the minimum intervals required to execute all the tasks with the given cooling period, where \'tasks\' is a list of characters representing tasks and \'n\' is a non-negative integer representing the cooling period. Input - `tasks`: A list of characters where each character represents a task. The same task can appear multiple times. - `n`: An integer representing the cooling period between the same tasks. Output - Returns an integer representing the minimum time required to complete all the tasks. Constraints - Each task is represented by a single uppercase English letter. - The list of tasks can be empty. Example ```python >>> least_interval([\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], 2) 8 >>> least_interval([\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], 0) 6 >>> least_interval([\'A\', \'B\', \'C\', \'A\', \'B\', \'C\'], 1) 6 >>> least_interval([], 2) 0 ``` Edge Cases 1. When the list of tasks is empty, return 0. 2. When the cooling period is zero, the minimum time is simply the number of tasks. Implementation ```python def least_interval(tasks: list, n: int) -> int: from collections import Counter if not tasks: return 0 task_counts = list(Counter(tasks).values()) max_count = max(task_counts) max_count_tasks = task_counts.count(max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles ``` Test your implementation using various test cases including the examples and edge cases provided.","solution":"def least_interval(tasks: list, n: int) -> int: from collections import Counter if not tasks: return 0 task_counts = list(Counter(tasks).values()) max_count = max(task_counts) max_count_tasks = task_counts.count(max_count) part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"# Movie Rating System Scenario You are tasked with developing a movie rating system where users can submit their ratings for various movies. The goal is to store the user\'s ratings and calculate the average rating for each movie, while handling various edge cases such as non-existent movies and invalid ratings. Task Implement a class `MovieRatingSystem` that: 1. Allows users to submit their rating for a movie. 2. Stores ratings in an efficient data structure. 3. Provides a method to calculate the average rating for a given movie. 4. Handles invalid ratings and non-existent movies gracefully. Requirements 1. **Class Methods**: * `add_rating(movie: str, rating: float) -> None`: Adds a rating for the given movie. Ratings should be between 0 and 5 (inclusive). * `get_average_rating(movie: str) -> float`: Returns the average rating for the given movie. If the movie has no ratings, return `None`. 2. **Input Format**: * `movie`: `str` - Movie title. * `rating`: `float` - Rating value between 0 and 5 (inclusive). 3. **Output Format**: * `float` - The average rating for the given movie. If no ratings exist for the movie, return `None`. 4. **Constraints**: * The rating value must be between 0 and 5 (inclusive). Handle invalid ratings by ignoring them and logging or printing a relevant message. * Handle cases where the movie does not exist or has no ratings by returning `None`. 5. **Performance**: * Efficiently manage ratings to ensure quick addition and retrieval. Example ```python class MovieRatingSystem: def __init__(self): # Your implementation here pass def add_rating(self, movie: str, rating: float) -> None: # Your implementation here pass def get_average_rating(self, movie: str) -> float: # Your implementation here pass # Sample Usage movie_system = MovieRatingSystem() movie_system.add_rating(\\"Inception\\", 4.5) movie_system.add_rating(\\"Inception\\", 5.0) average = movie_system.get_average_rating(\\"Inception\\") print(f\\"Average rating for Inception: {average}\\") movie_system.add_rating(\\"Titanic\\", 3.0) average = movie_system.get_average_rating(\\"Titanic\\") print(f\\"Average rating for Titanic: {average}\\") # Invalid rating movie_system.add_rating(\\"Avatar\\", 10) average = movie_system.get_average_rating(\\"Avatar\\") print(f\\"Average rating for Avatar: {average}\\") # Should handle invalid rating gracefully ``` Implement the class following the requirements, ensuring error handling for invalid inputs and non-existent movies.","solution":"class MovieRatingSystem: def __init__(self): self.ratings = {} def add_rating(self, movie: str, rating: float) -> None: if 0 <= rating <= 5: if movie not in self.ratings: self.ratings[movie] = [] self.ratings[movie].append(rating) else: print(f\\"Invalid rating of {rating} for movie: {movie}. Rating should be between 0 and 5.\\") def get_average_rating(self, movie: str) -> float: if movie in self.ratings and self.ratings[movie]: return sum(self.ratings[movie]) / len(self.ratings[movie]) return None"},{"question":"# Coding Question Scenario In computer graphics, manipulating colors is a common task, especially when generating gradients or blending images. You are required to create a function to generate a color gradient given a start and end color, the number of steps in the gradient, and whether the colors should be blended linearly or logarithmically. Task Implement the function `generate_gradient` to generate a list of colors forming a gradient between the given start and end colors. # Function Signature ```python def generate_gradient(start_color: tuple[int, int, int], end_color: tuple[int, int, int], steps: int, mode: str) -> list[tuple[int, int, int]]: ``` # Input * `start_color`: A tuple of three integers (R, G, B) each between 0 and 255 representing the starting color. * `end_color`: A tuple of three integers (R, G, B) each between 0 and 255 representing the ending color. * `steps`: An integer representing the number of colors in the gradient. * `mode`: A string either \\"linear\\" or \\"logarithmic\\", specifying the blending mode. # Output * A list of tuples, each containing three integers (R, G, B), representing the colors in the gradient. # Constraints * `steps` will be between 2 and 1000. * Each color component in `start_color` and `end_color` will be between 0 and 255. * `mode` will be either \\"linear\\" or \\"logarithmic\\". # Requirements 1. If `steps` is less than 2, the function should raise a `ValueError`. 2. Ensure color values remain within valid RGB ranges (0 to 255) throughout the calculations. # Example ```python # Input start_color = (255, 0, 0) end_color = (0, 0, 255) steps = 5 mode = \\"linear\\" # Output [(255, 0, 0), (191, 0, 64), (128, 0, 128), (64, 0, 191), (0, 0, 255)] ``` **Notes:** - For the \\"linear\\" mode, interpolate each color component linearly between the start and end values. - For the \\"logarithmic\\" mode, use a logarithmic scale for interpolation, ensuring the sequence is perceived as exponential by the human eye. - Ensure the gradient includes the exact start and end colors. **Edge cases to consider:** - When `steps` is 2, the output should just be the `start_color` and `end_color`. - When the start and end colors are the same. - Proper handling of rounding errors to ensure valid RGB values.","solution":"import math def generate_gradient(start_color: tuple[int, int, int], end_color: tuple[int, int, int], steps: int, mode: str) -> list[tuple[int, int, int]]: if steps < 2: raise ValueError(\\"Steps must be 2 or greater.\\") def interpolate(start, end, factor): return round(start + (end - start) * factor) def linear_interpolation(): return [ tuple(interpolate(start_color[i], end_color[i], j / (steps - 1)) for i in range(3)) for j in range(steps) ] def logarithmic_interpolation(): return [ tuple(interpolate(start_color[i], end_color[i], math.log1p(j) / math.log1p(steps - 1)) for i in range(3)) for j in range(steps) ] if mode == \'linear\': return linear_interpolation() elif mode == \'logarithmic\': return logarithmic_interpolation() else: raise ValueError(\\"Mode must be \'linear\' or \'logarithmic\'.\\")"},{"question":"# Coding Question: Spiral Matrix Application Scenario A team is developing a graphical application that requires rendering a matrix of data on a screen in a specific spiral order. Your task is to implement a function that, given a matrix, outputs the values in a spiral order. Requirements - Implement a function `spiral_order` that takes a 2D matrix (a list of lists) of integers and returns a list of integers representing the matrix values in spiral order. - Start from the top-left corner of the matrix and proceed in a spiral (clockwise) order. - Ensure the function works efficiently even for larger matrices. Expected Format ```python def spiral_order(matrix: list[list[int]]) -> list[int]: # your implementation here pass ``` Constraints 1. The matrix will be non-empty, but it may not necessarily be square. 2. The number of rows and columns will not exceed 1000. 3. Operate within O(m*n) time complexity, where m is the number of rows and n is the number of columns. Examples Suppose the following examples are given: ```python print(spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] print(spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])) # Output: [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] ``` Use these examples to verify your implementation.","solution":"def spiral_order(matrix: list[list[int]]) -> list[int]: if not matrix: return [] res = [] while matrix: res += matrix.pop(0) if matrix and matrix[0]: for row in matrix: res.append(row.pop()) if matrix: res += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: res.append(row.pop(0)) return res"},{"question":"# Problem Description You need to design a system that schedules and manages tasks based on priority. Each task has a priority level and a description. The system should be able to add tasks, remove tasks, and retrieve the highest priority task. Write a class that implements this functionality using a max-heap data structure. # Function Signature ```python class TaskScheduler: def __init__(self): # Initialize the task scheduler pass def add_task(self, priority: int, description: str) -> None: # Add a task with a given priority and description pass def remove_task(self, description: str) -> bool: # Remove the task with the given description, return True if successful, False if not found pass def get_highest_priority_task(self) -> dict[str, str]: # Retrieve the highest priority task without removing it pass def __str__(self) -> str: # Return all tasks in the scheduler as a string pass ``` # Methods - **add_task(priority: int, description: str) -> None**: Adds a task to the scheduler with the specified priority and description. - **remove_task(description: str) -> bool**: Removes the task matching the given description from the scheduler. Returns `True` if the task was successfully removed, or `False` if the task was not found. - **get_highest_priority_task() -> dict[str, str]**: Returns the highest priority task as a dictionary with keys `\'priority\'` and `\'description\'`, without removing the task from the scheduler. - **__str__() -> str**: Returns a string representation of all tasks in the scheduler, sorted by priority in descending order. # Constraints - The priorities are integers where a higher number signifies a higher priority. - Task descriptions will be unique strings. - You are allowed to use the `heapq` module in the standard library for your heap implementation. # Examples ```python scheduler = TaskScheduler() scheduler.add_task(1, \\"Wash dishes\\") scheduler.add_task(3, \\"Write report\\") scheduler.add_task(2, \\"Call mom\\") print(scheduler.get_highest_priority_task()) # Output: {\'priority\': 3, \'description\': \'Write report\'} print(scheduler.remove_task(\\"Write report\\")) # Output: True print(scheduler.get_highest_priority_task()) # Output: {\'priority\': 2, \'description\': \'Call mom\'} print(scheduler.remove_task(\\"Non-existent task\\")) # Output: False print(scheduler) # Output: # 2: Call mom # 1: Wash dishes ``` # Additional Notes - Ensure that the add, remove, and retrieve operations are efficient and handle edge cases gracefully. - Implement comprehensive error handling and input validation where appropriate. - Focus on using a max-heap data structure to maintain task priorities effectively.","solution":"import heapq class TaskScheduler: def __init__(self): self.tasks = [] self.entry_finder = {} self.REMOVED = \'<removed-task>\' self.counter = 0 def add_task(self, priority: int, description: str) -> None: if description in self.entry_finder: self.remove_task(description) count = self.counter entry = [-priority, count, description] self.entry_finder[description] = entry heapq.heappush(self.tasks, entry) self.counter += 1 def remove_task(self, description: str) -> bool: entry = self.entry_finder.pop(description, None) if entry: entry[-1] = self.REMOVED return True return False def get_highest_priority_task(self) -> dict: while self.tasks: priority, count, description = heapq.heappop(self.tasks) if description is not self.REMOVED: self.entry_finder.pop(description) return {\'priority\': -priority, \'description\': description} return {} def __str__(self) -> str: valid_tasks = [] temp_heap = self.tasks[:] while temp_heap: priority, count, description = heapq.heappop(temp_heap) if description != self.REMOVED: valid_tasks.append({\'priority\': -priority, \'description\': description}) valid_tasks.sort(key=lambda x: (-x[\'priority\'], x[\'description\'])) return \'n\'.join(f\\"{task[\'priority\']}: {task[\'description\']}\\" for task in valid_tasks)"},{"question":"# Coding Assessment Task Context You are developing a simple recommendation system for a video streaming service. The service provides users with a list of available videos, along with metadata including genre, rating, and duration. Your task is to implement a recommendation class that can suggest videos to users based on similarities in their watch history and ratings they have given. Objective Implement a class `VideoRecommender` that processes user watch history and recommends videos. Your implementation should include: 1. **Loading metadata**: Load video metadata from a data source. 2. **Track user interactions**: Maintain a record of each user\'s watched videos and their ratings. 3. **Recommend videos**: Suggest videos based on the similarity of genres and user ratings. Requirements - Use Python standard libraries for data management. - Implement methods to load metadata, track watch history and ratings, and recommend videos. - Consider edge cases such as new users with no watch history. - Employ a simple similarity metric (e.g., genre match) for recommendations. # Function Specifications `VideoRecommender` * **Attributes**: - `video_metadata`: Dictionary or DataFrame containing video metadata (e.g., genres, rating, duration). - `user_history`: Dictionary where keys are user IDs and values are dictionaries containing watched videos and their ratings. * **Methods**: - `__init__(self, metadata_source)`: Initialize the recommender with video metadata. - `load_metadata(self, metadata_source)`: Load video metadata from the given source. - `add_watch_history(self, user_id, video_id, rating)`: Add a video watched by a user along with their rating. - `recommend_videos(self, user_id, top_n=5)`: Recommend the top N videos to a user based on their watch history. # Constraints - Video metadata source can be a dictionary, JSON file, or a DataFrame. - Use a string match or simple heuristic for genre-based similarity. - Handle cases where a user\'s history is empty by recommending top-rated videos. Example Usage ```python metadata = { \\"1\\": {\\"title\\": \\"Video A\\", \\"genre\\": \\"Action\\", \\"rating\\": 4.5, \\"duration\\": 120}, \\"2\\": {\\"title\\": \\"Video B\\", \\"genre\\": \\"Comedy\\", \\"rating\\": 4.0, \\"duration\\": 90}, \\"3\\": {\\"title\\": \\"Video C\\", \\"genre\\": \\"Action\\", \\"rating\\": 5.0, \\"duration\\": 110}, # additional video metadata entries... } recommender = VideoRecommender(metadata) recommender.add_watch_history(user_id=1001, video_id=\\"1\\", rating=4.0) recommender.add_watch_history(user_id=1001, video_id=\\"3\\", rating=5.0) recommendations = recommender.recommend_videos(user_id=1001, top_n=3) ``` # Hints - Utilize dictionary or pandas DataFrame methods for data loading and lookup. - Consider several strategies for generating recommendations, such as genre matching and average rating of watched videos. - To simplify, assume metadata provides reliable and complete information for all videos available.","solution":"class VideoRecommender: def __init__(self, metadata_source): self.video_metadata = self.load_metadata(metadata_source) self.user_history = {} def load_metadata(self, metadata_source): Load video metadata from the given source. The source can be a dictionary or a DataFrame. # Assuming metadata_source is a dictionary for simplicity. return metadata_source def add_watch_history(self, user_id, video_id, rating): Add a video watched by a user along with their rating. if user_id not in self.user_history: self.user_history[user_id] = {} self.user_history[user_id][video_id] = rating def recommend_videos(self, user_id, top_n=5): Recommend the top N videos to a user based on their watch history. if user_id not in self.user_history: # If user has no history, recommend top-rated videos top_videos = sorted(self.video_metadata.items(), key=lambda x: -x[1][\'rating\']) else: # Get user\'s watched genres and their average rating watched_videos = self.user_history[user_id] genre_ratings = {} for video_id, rating in watched_videos.items(): video = self.video_metadata[video_id] genre = video[\\"genre\\"] if genre not in genre_ratings: genre_ratings[genre] = [] genre_ratings[genre].append(rating) for genre in genre_ratings: genre_ratings[genre] = sum(genre_ratings[genre]) / len(genre_ratings[genre]) # Recommend videos based on the genres and ratings recommended_videos = [] for video_id, details in self.video_metadata.items(): if video_id not in watched_videos and details[\\"genre\\"] in genre_ratings: details[\\"similarity_score\\"] = genre_ratings[details[\\"genre\\"]] recommended_videos.append((video_id, details)) recommended_videos = sorted(recommended_videos, key=lambda x: (-x[1][\'similarity_score\'], -x[1][\'rating\'])) top_videos = recommended_videos return [video[0] for video in top_videos[:top_n]]"},{"question":"# Scenario A digital advertisement company wants to track the most frequently visited pages on its clients\' websites. They collect data continuously and can receive multiple requests for the same page. The company needs a system that can process this continuous stream of page requests and provide the top `k` most visited pages at any given time. # Task Write a class `PageTracker` that efficiently tracks page visits and provides the top `k` most visited pages. The class should include the following methods: - `visit(page: str) -> None`: Records a visit to the given page URL. - `top(k: int) -> list[str]`: Returns a list of the top `k` most visited page URLs, ordered by visit frequency in descending order. If there are ties, return the URLs in lexicographical order. # Input * The `page` parameter in the `visit` method is a string representing the URL of the page being visited. * The `k` parameter in the `top` method is an integer representing the number of top pages to return. # Output * The `visit` method outputs nothing, it only tracks the visits. * The `top` method outputs a list of strings representing the top `k` most visited page URLs. # Constraints 1. The length of the `page` URL will be between 1 and 100 characters. 2. The `k` parameter will always be a positive integer and will not exceed the number of unique pages visited. 3. Assume that the pages are visited frequently, and the tracker needs to efficiently maintain the counts. 4. The `visit` method might be called several million times, so it should be optimized for frequent updates. # Example ```python # Example Usage tracker = PageTracker() tracker.visit(\\"https://example.com/home\\") tracker.visit(\\"https://example.com/about\\") tracker.visit(\\"https://example.com/home\\") tracker.visit(\\"https://example.com/contact\\") tracker.visit(\\"https://example.com/about\\") tracker.visit(\\"https://example.com/about\\") top_2_pages = tracker.top(2) print(top_2_pages) # Output: [\\"https://example.com/about\\", \\"https://example.com/home\\"] ``` # Note Ensure to handle cases where the same page URL is visited multiple times correctly and efficiently. The `top` method should return the top `k` pages, even if they were tied in number of visits. For ties, the URLs should be sorted lexicographically.","solution":"from collections import Counter class PageTracker: def __init__(self): self.visits = Counter() def visit(self, page: str) -> None: self.visits[page] += 1 def top(self, k: int) -> list[str]: sorted_pages = sorted(self.visits.items(), key=lambda item: (-item[1], item[0])) return [page for page, count in sorted_pages[:k]]"},{"question":"# Question: Implement Matrix Transposition Matrix transposition is a common operation in linear algebra. It involves swapping the rows and columns of the matrix. A matrix of dimensions m x n when transposed results in a matrix of dimensions n x m. Your task is to implement a function that takes a 2D list (matrix) and returns its transpose. # Function Signature ```python def transpose(matrix: list) -> list: Arguments: matrix: A 2D list representing the matrix to be transposed. Returns: A 2D list representing the transposed matrix. ``` # Expected Input and Output * **Input**: * `matrix`: A 2D list of dimensions m x n (m rows and n columns). * **Output**: * A 2D list of dimensions n x m (n rows and m columns) representing the transposed matrix. * **Constraints**: * The matrix can have dimensions up to 1000 x 1000. # Example ```python >>> matrix = [[1, 2, 3], [4, 5, 6]] >>> transpose(matrix) [[1, 4], [2, 5], [3, 6]] ``` # Performance Your implementation should efficiently handle matrices of the maximum permissible size (1000 x 1000). # Notes * Describe the algorithmic steps in your function. * Ensure your implementation handles edge cases effectively, such as empty matrices or matrices with varying inner list lengths (if applicable).","solution":"def transpose(matrix: list) -> list: Transposes the given matrix. Arguments: matrix: A 2D list representing the matrix to be transposed. Returns: A 2D list representing the transposed matrix. # If the matrix is empty, return it as is if not matrix or not matrix[0]: return matrix # Get the number of rows and columns m, n = len(matrix), len(matrix[0]) # Initialize the transposed matrix with dimensions n x m transposed = [[0]*m for _ in range(n)] # Fill in the transposed matrix by swapping rows and columns for i in range(m): for j in range(n): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Background: Sorting algorithms are fundamental concepts in computer science, and they are often used to arrange elements in a particular order. One common sorting algorithm is the Merge Sort, which is a divide-and-conquer algorithm. It recursively splits the list into increasingly smaller halves until the sub-lists consist of individual elements and then merges those sub-lists back together in sorted order. # Task: Write a function that performs the Merge Sort algorithm on a list of integers. Your implementation should be efficient and correctly handle lists of varying lengths, including edge cases such as an empty list or a list with one element. # Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr`: A list of integers to be sorted. # Output: - Returns a new list with the elements of `arr` sorted in ascending order. # Constraints: - The input list can be of any length, including 0 (an empty list). # Examples: ```python print(merge_sort([3, 1, 4, 1, 5, 9])) # Expected: [1, 1, 3, 4, 5, 9] print(merge_sort([])) # Expected: [] print(merge_sort([1])) # Expected: [1] print(merge_sort([5, 2, 8, 6, 3])) # Expected: [2, 3, 5, 6, 8] print(merge_sort([-3, -1, -2, -5, -4])) # Expected: [-5, -4, -3, -2, -1] ``` # Scenario: You are developing a feature for a data analytics application that sorts user data records. Efficient sorting is a core requirement for the feature to ensure rapid data querying and visualization. Guarantee that your merge sort implementation is robust and capable of handling edge cases and performance considerations when working with large datasets.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Perform merge sort on the input list. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_idx, right_idx = 0, 0 # Merge the two lists while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 # Add remaining elements from left (if any) while left_idx < len(left): merged.append(left[left_idx]) left_idx += 1 # Add remaining elements from right (if any) while right_idx < len(right): merged.append(right[right_idx]) right_idx += 1 return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Directory Synchronization Tool You are tasked with creating a command-line tool that synchronizes the contents of two directories. This tool should ensure that the destination directory is updated with any new or modified files from the source directory while preserving the directory structure. Function Specification: Implement the function `sync_directories(source: str, destination: str) -> None`. This function should: 1. Traverse the source directory and identify all files and subdirectories. 2. For each file in the source directory, check if it exists in the destination directory. 3. If the file does not exist or the source file is more recent, copy the file from the source to the destination directory. 4. Ensure that the directory structure of the source is maintained in the destination. 5. Implement error handling to manage file access errors and interruptions. 6. Include logging to track the synchronization process (e.g., files copied, any errors encountered). Input: - `source` (str): The path to the source directory. - `destination` (str): The path to the destination directory. Constraints: - The tool should handle deeply nested directories. - The tool should efficiently manage the file copying process and should not unnecessarily copy files that are already up-to-date. - Pay attention to performance and error handling. - Ensure the tool can handle interruptions gracefully and possibly resume the synchronization. Example Usage: ```python if __name__ == \\"__main__\\": sync_directories(\\"/path/to/source\\", \\"/path/to/destination\\") ``` In this example, the tool will synchronize the contents of `/path/to/source` with `/path/to/destination`, ensuring that the destination contains all files from the source, with the same directory structure. Notes: - Use Python\'s `os` and `shutil` modules for file and directory operations. - Consider using file modification timestamps to determine if a file in the source is more recent than the one in the destination. - Ensure the tool handles symlinks and special files appropriately. - Ensure proper management of file permissions and ownership where applicable.","solution":"import os import shutil import logging from datetime import datetime def sync_directories(source: str, destination: str) -> None: Synchronize the contents of the source directory to the destination directory. if not os.path.exists(destination): os.makedirs(destination) for root, dirs, files in os.walk(source): # Create the corresponding directories in the destination for dir in dirs: dest_dir_path = os.path.join(destination, os.path.relpath(os.path.join(root, dir), source)) if not os.path.exists(dest_dir_path): os.makedirs(dest_dir_path) for file in files: src_file_path = os.path.join(root, file) rel_path = os.path.relpath(src_file_path, source) dest_file_path = os.path.join(destination, rel_path) copy_file = True if os.path.exists(dest_file_path): src_mtime = os.path.getmtime(src_file_path) dest_mtime = os.path.getmtime(dest_file_path) if dest_mtime >= src_mtime: copy_file = False if copy_file: shutil.copy2(src_file_path, dest_file_path) logging.info(f\\"Copied: {src_file_path} to {dest_file_path}\\") # Setting up basic logging configuration logging.basicConfig(level=logging.INFO, format=\\"%(asctime)s - %(levelname)s - %(message)s\\")"},{"question":"**Problem Statement**: You are given a string consisting of lowercase alphabets and the task is to determine the smallest window (substring) in the given string containing all the unique characters of the string itself. **Function Signature**: ```python def smallest_window(s: str) -> str: ``` **Inputs**: - `s`: A string of lowercase alphabets (a-z). The length of the string is between 1 and 10^5. **Outputs**: - Return the smallest window in the input string that contains all the unique characters of the string. **Constraints**: - Ensure the solution is optimized for both time and space complexity. - Handle edge cases such as repeated characters and minimum length strings. **Scenario**: Suppose you are working on a text processing tool and need to find the smallest segment of text that includes all the different characters present in the input. This is critical for highlighting text regions with maximum information density. **Examples**: ```python >>> smallest_window(\\"aabcbcdbca\\") \\"dbca\\" >>> smallest_window(\\"aa\\") \\"a\\" >>> smallest_window(\\"abcd\\") \\"abcd\\" ``` **Requirements**: - The function should handle strings with all unique characters gracefully. - The solution should be efficient, preferably using a sliding window approach or a similar strategy to ensure optimal performance on large inputs.","solution":"def smallest_window(s: str) -> str: from collections import defaultdict n = len(s) if n == 0: return \\"\\" unique_char_count = len(set(s)) min_len = float(\'inf\') start = 0 char_frequency = defaultdict(int) left = 0 count = 0 # to keep track of unique characters in current window for right in range(n): char_frequency[s[right]] += 1 if char_frequency[s[right]] == 1: count += 1 while count == unique_char_count: if right - left + 1 < min_len: min_len = right - left + 1 start = left char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: count -= 1 left += 1 return s[start:start + min_len]"},{"question":"# Sentence Correction You are tasked with creating a Python function to correct spelling mistakes in sentences using a predefined dictionary of correct words. Your function should take a sentence as input, split it into words, check each word against the dictionary, and replace it with the correct word if needed. The dictionary will be passed as a parameter to the function. **Objective**: Write a Python function named `correct_sentence` that corrects spelling mistakes in a given sentence based on a provided dictionary of correct words. **Function Signature**: ```python def correct_sentence(sentence: str, dictionary: dict) -> str: pass ``` **Input**: - `sentence` (str): The input sentence to be corrected. - `dictionary` (dict): A dictionary where keys are incorrect words and values are their corresponding correct words. **Output**: - A corrected sentence as a string. **Example**: ```python sentence = \\"Ths is a smple snetence with sme mstakes.\\" dictionary = { \\"Ths\\": \\"This\\", \\"smple\\": \\"simple\\", \\"snetence\\": \\"sentence\\", \\"sme\\": \\"some\\", \\"mstakes\\": \\"mistakes\\" } print(correct_sentence(sentence, dictionary)) # Output: \\"This is a simple sentence with some mistakes.\\" ``` **Constraints**: - Do not assume any particular form or structure for the input sentence. - The function should handle both lowercase and uppercase versions of words gracefully. - Maintain the original spacing and punctuation of the input sentence. **Performance**: - Aim for a time complexity of O(N), where N is the number of words in the sentence. - Space complexity should be minimized, ideally only requiring additional space proportional to the number of unique words in the sentence. **Python Libraries**: - Only base Python libraries should be needed for this task. # Context: Spelling correction is an essential feature in text editors, search engines, and applications involving natural language processing. This helps enhance readability and understanding of text by automatically correcting common spelling errors.","solution":"def correct_sentence(sentence: str, dictionary: dict) -> str: Corrects spelling mistakes in a sentence based on a provided dictionary. Parameters: sentence (str): The input sentence to be corrected. dictionary (dict): A dictionary where keys are incorrect words and values are their corresponding correct words. Returns: str: A corrected sentence. words = sentence.split() corrected_words = [] for word in words: # Remove punctuation from the word for checking stripped_word = \'\'.join(char for char in word if char.isalnum() or char == \\"\'\\") if stripped_word in dictionary: # Replace the word, but preserve original punctuation corrected_word = dictionary[stripped_word] for char in word: if not char.isalnum() and char != \\"\'\\": corrected_word += char corrected_words.append(corrected_word) else: corrected_words.append(word) return \' \'.join(corrected_words)"},{"question":"# String Manipulations and Transformations In this programming task, you will work with a custom `StringManipulator` class that performs various string operations. Your goal is to implement a specific method and verify its correctness. Problem Statement You are given the `StringManipulator` class with its current functionalities as defined in the code snippet provided. Implement the following additional feature: # Method: `reverse_words()` Reverse the order of words in a given string while maintaining the order of characters within each word and return the transformed string. # Expected Input and Output Formats * **Input**: The method will be called on a `StringManipulator` instance with a string containing words separated by single spaces. * **Output**: A transformed string where the order of words is reversed, but the characters within each word remain unchanged. # Constraints and Limitations: 1. The input string will only contain alphabetic characters and single spaces between words. 2. The method should handle input strings up to 1000 characters efficiently. 3. Minimize the space complexity of the solution. Example Scenario ```python >>> s = StringManipulator(\\"hello world from openai\\") >>> reversed_s = s.reverse_words() >>> reversed_s \\"openai from world hello\\" ``` Use this function implementation to verify the correctness of your transformations. Ensure accuracy and performance by avoiding unnecessary computations. # Implementation Complete the following method within the `StringManipulator` class: ```python def reverse_words(self) -> str: # Your code here ``` Ensure your tested implementation handles edge cases such as single word inputs or multiple spaces between words correctly. Evaluation Criteria * **Correctness**: The function should return the correctly transformed string. * **Efficiency**: The solution should handle the given constraints. * **Readability**: The code should be clean, and well-documented.","solution":"class StringManipulator: def __init__(self, text): self.text = text def reverse_words(self): Reverse the order of words in the given string while maintaining the order of characters within each word. Returns: str: Transformed string with words\' order reversed. # Split the string by spaces to separate the words words = self.text.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a space and return return \' \'.join(reversed_words) # Example usage: # s = StringManipulator(\\"hello world from openai\\") # reversed_s = s.reverse_words() # print(reversed_s) # Output: \\"openai from world hello\\""},{"question":"# Sum of Unique Elements Context: You are tasked with writing a function to calculate the sum of all unique elements in an input list. Identifying unique elements and summing them up can have applications in data analysis, statistical computations, and financial algorithms. Problem Statement: Write a function `sum_of_unique_elements(lst: List[int]) -> int` to calculate the sum of the unique elements in the provided list `lst`. The function should return the sum of elements that appear exactly once in the list. Input: - A list of integers `lst`. Output: - An integer representing the sum of the unique elements in the list. Constraints: - All elements in the list are integers within the range `[-10^4, 10^4]`. - The function should consider both positive and negative integers. - The list can have up to `10^5` elements. Examples: ``` >>> sum_of_unique_elements([1, 2, 3, 2, 4]) 8 >>> sum_of_unique_elements([0, 0, 0]) 0 >>> sum_of_unique_elements([-1, 1, 2, -1, 3, 4]) 10 >>> sum_of_unique_elements([5]) 5 >>> sum_of_unique_elements([10, 10, 10]) 0 ``` Performance Requirements: - The solution should be efficient with respect to both time and space complexities. - Aim for a solution that operates in O(n) time complexity, where n is the number of elements in the input list. Implementation Challenge: Implement the function `sum_of_unique_elements` ensuring that it handles edge cases such as an empty list and lists with repeating elements effectively.","solution":"from collections import Counter def sum_of_unique_elements(lst): Returns the sum of unique elements in the list, where unique means the element appears exactly once. # Create a Counter dictionary to count the occurrences of each element count = Counter(lst) # Extract elements that appear exactly once and sum them up unique_sum = sum(k for k, v in count.items() if v == 1) return unique_sum"},{"question":"# Scenario Imagine you are working on a data analytics platform that processes real-time data streams from various sensors. The data from each sensor is sent as character-separated values (CSV) to ensure compatibility with legacy systems. However, some sensors have reported data intermittently, resulting in missing values. Your task is to implement functions to normalize the data by replacing missing values with the mean of their respective columns. # Task 1. **Implement `normalize_data` function** - Input: A list of strings, each representing a line of CSV data from sensors. - Output: A list of strings with normalized data, where missing values are replaced by the mean of their respective columns. - Constraints: - Missing values are represented by empty strings. - Columns may contain floating-point numbers. - Assume all rows have the same number of columns; any non-numeric columns are ignored. # Requirements - Ensure your solution handles small and large datasets efficiently. - Utilize built-in Python libraries effectively to compute means and manage data replacements. - Your implementation should match the given doctest examples. # Function Specifications # `normalize_data(data: List[str]) -> List[str]` - **Input**: A list of strings. - **Output**: A list of strings. # Example Usage ```python data = [ \\"27.1,2.3,3.8\\", \\"23.4,,3.2\\", \\"21.9,18.2,\\" ] normalized_data = normalize_data(data) for line in normalized_data: print(line) # Output: # \\"27.1,2.3,3.8\\" # \\"23.4,10.25,3.2\\" # \\"21.9,18.2,3.5\\" ``` # Additional Considerations - Ensure that your solution correctly calculates the mean excluding missing values. - The replacement with the mean should happen only in numeric columns and skip non-numeric columns. - Pay attention to edge cases such as all values missing in a column or an empty dataset. - Implement error handling for edge cases in data formats.","solution":"from typing import List def normalize_data(data: List[str]) -> List[str]: if not data: return [] # Split each row into columns and parse floats; track indices of empty cells columns = [row.split(\',\') for row in data] num_cols = len(columns[0]) # Initialize sums and counts for calculating column means sums = [0.0] * num_cols counts = [0] * num_cols # Sum up values and count non-missing entries for each column for row in columns: for i in range(num_cols): if row[i] != \'\': try: value = float(row[i]) sums[i] += value counts[i] += 1 except ValueError: continue # Ignore non-numeric columns # Calculate the mean for each column means = [sums[i] / counts[i] if counts[i] > 0 else None for i in range(num_cols)] # Replace missing values with the computed column mean for row in columns: for i in range(num_cols): if row[i] == \'\' and means[i] is not None: row[i] = str(means[i]) # Join rows back together and return the normalized data return [\',\'.join(row) for row in columns]"},{"question":"**Context**: Develop a module that processes a given text corpus and provides key insights about the most common words. The primary aim is to identify the top-k most frequent words and output them in a sorted order based on their frequencies. **Task**: 1. Implement a class `TextAnalyzer` that processes a text corpus and efficiently tracks word frequencies. 2. Implement a function `get_top_k_frequent_words` which utilizes `TextAnalyzer` to return the top-k most frequent words. # Class Definition ```python class TextAnalyzer: def __init__(self): Initializes a text analyzer with an empty frequency dictionary. self.word_freq = {} def process_text(self, text: str) -> None: Processes the input text, updates the frequency of each word. :param text: The text corpus to be processed. words = text.split() for word in words: if word in self.word_freq: self.word_freq[word] += 1 else: self.word_freq[word] = 1 def get_word_frequency(self, word: str) -> int: Returns the frequency of a given word. :param word: The word whose frequency is to be fetched. :return: Frequency of the word. return self.word_freq.get(word, 0) ``` # Function Definition ```python def get_top_k_frequent_words(text: str, k: int) -> list[str]: Returns the top-k most frequent words in the text. :param text: The text corpus to analyze. :param k: The number of top frequent words to return. :return: A list of the top-k frequent words. analyzer = TextAnalyzer() analyzer.process_text(text) freq_items = list(analyzer.word_freq.items()) freq_items.sort(key=lambda x: (-x[1], x[0])) top_k_words = [item[0] for item in freq_items[:k]] return top_k_words ``` # Constraints: 1. Words are case-sensitive. 2. The length of the text, `L`, will not exceed 10^5 characters. 3. The number of unique words, `N`, will not exceed 10^4. 4. The value of `k` will be between 1 and `N` inclusive. # Example: ```python text = \\"the quick brown fox jumps over the lazy dog the quick brown\\" result = get_top_k_frequent_words(text, 3) ``` **Output**: `[\'the\', \'brown\', \'quick\']` **Note**: The output should be a list of top-k most frequent words sorted first by frequency in descending order, and then alphabetically in ascending order when frequencies are tied.","solution":"class TextAnalyzer: def __init__(self): Initializes a text analyzer with an empty frequency dictionary. self.word_freq = {} def process_text(self, text: str) -> None: Processes the input text, updates the frequency of each word. :param text: The text corpus to be processed. words = text.split() for word in words: if word in self.word_freq: self.word_freq[word] += 1 else: self.word_freq[word] = 1 def get_word_frequency(self, word: str) -> int: Returns the frequency of a given word. :param word: The word whose frequency is to be fetched. :return: Frequency of the word. return self.word_freq.get(word, 0) def get_top_k_frequent_words(text: str, k: int) -> list[str]: Returns the top-k most frequent words in the text. :param text: The text corpus to analyze. :param k: The number of top frequent words to return. :return: A list of the top-k frequent words. analyzer = TextAnalyzer() analyzer.process_text(text) freq_items = list(analyzer.word_freq.items()) freq_items.sort(key=lambda x: (-x[1], x[0])) top_k_words = [item[0] for item in freq_items[:k]] return top_k_words"},{"question":"# Factorial Calculation with Performance Considerations Context When dealing with combinatorial problems or probabilistic algorithms, calculating the factorial of a number frequently comes up. Given the potentially large outputs and iterative nature of factorial computation, it\'s crucial to design a function that is both efficient in terms of time and space. Problem Statement Implement a function in Python to compute the factorial of a non-negative integer using an iterative approach. Given a non-negative integer ( n ), return ( n! ). Function Signature ```python def iterative_factorial(n: int) -> int: Computes the factorial of a non-negative integer iteratively. Parameters: n: int - A non-negative integer. Returns: int - The factorial of the given integer. ``` Input/Output Formats - **Input**: A non-negative integer `n`. - **Output**: An integer representing ( n! ). Constraints - The input integer will be in the range 0 ≤ n ≤ 20. - Resultant factorial values may be large, so ensure the implementation can handle big integers. - The function should avoid recursion to prevent stack overflow issues with larger values of ( n ). Examples ```python >>> iterative_factorial(5) 120 >>> iterative_factorial(0) 1 >>> iterative_factorial(10) 3628800 ``` Scenarios to Consider - Lower boundary case with ( n = 0 ), which by definition ( 0! = 1 ). - Typical small values to ensure correctness, e.g., ( n = 5 ). - Edge case for upper limit boundary, ( n = 20 ), verifying performance and handling of large integers. - Single-element edge case ( n = 1 ), which should return 1. Implement the `iterative_factorial` function iteratively for performance and test it across the provided cases to ensure accuracy and robustness.","solution":"def iterative_factorial(n: int) -> int: Computes the factorial of a non-negative integer iteratively. Parameters: n: int - A non-negative integer. Returns: int - The factorial of the given integer. if n == 0: return 1 factorial = 1 for i in range(1, n + 1): factorial *= i return factorial"},{"question":"# Coding Question: Identifying Armstrong Numbers Within a Range An Armstrong number (also known as a narcissistic number, pluperfect, or pluperfect digit) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, 153 is an Armstrong number because: [ 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153 ] # Task Write a Python function to list all Armstrong numbers within a given range `[low, high]`. # Function Signature ```python def find_armstrong_numbers(low: int, high: int) -> List[int]: pass ``` # Input - Integer `low` (constraint (1 leq low < high leq 10^6)). - Integer `high` (constraint (1 leq low < high leq 10^6)). # Output - List of integers, each representing an Armstrong number within the given range `[low, high]`. # Constraints - The function should return the Armstrong numbers in increasing order. - The range `[low, high]` can contain up to (10^6) numbers. # Examples ```python >>> find_armstrong_numbers(100, 1000) [153, 370, 371, 407] >>> find_armstrong_numbers(1, 500) [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] ``` # Guidelines - Ensure the function handles the lower and upper boundaries correctly. - Optimize the computation to handle large ranges efficiently. - The function should properly handle cases where there are no Armstrong numbers in the given range. # Performance Requirement - Aim for an efficient solution, considering the function may be required to process a full range up to (10^6).","solution":"from typing import List def find_armstrong_numbers(low: int, high: int) -> List[int]: def is_armstrong_number(num: int) -> bool: digits = list(map(int, str(num))) power = len(digits) armstrong_sum = sum(d ** power for d in digits) return armstrong_sum == num armstrong_numbers = [] for number in range(low, high + 1): if is_armstrong_number(number): armstrong_numbers.append(number) return armstrong_numbers"},{"question":"# Problem Statement You are provided with a string consisting of lowercase alphabets and an integer `n`. Your task is to determine if the string can be transformed into a palindrome by rearranging its characters and repeating some characters at most `n` times. # Input * A string `s` where `1 <= len(s) <= 10^5` consisting of lowercase alphabets. * An integer `n` where `0 <= n <= 10^5`. # Output * Return `True` if the string can be transformed into a palindrome by rearranging its characters and repeating some characters at most `n` times, otherwise return `False`. # Implementation Implement the following function: ```python def can_form_palindrome(s: str, n: int) -> bool: Determine if a string can be rearranged to form a palindrome with character repetitions allowed up to `n` times. :param s: The input string :param n: Maximum repetitions allowed for any character :return: Boolean indicating if the string can form a palindrome >>> can_form_palindrome(\\"aabb\\", 0) True >>> can_form_palindrome(\\"abc\\", 1) False >>> can_form_palindrome(\\"aaabbb\\", 1) True >>> can_form_palindrome(\\"abcdcba\\", 2) True >>> can_form_palindrome(\\"a\\", 0) True pass ``` # Constraints * The string length is at least 1 and at most `10^5`. * The integer `n` ranges from 0 to `10^5`. # Edge Cases * A single character string is always a palindrome. * A string where `n` is large enough to allow any character to be repeated sufficiently. # Example ```python print(can_form_palindrome(\\"aabb\\", 0)) # Output: True print(can_form_palindrome(\\"abc\\", 1)) # Output: False print(can_form_palindrome(\\"aaabbb\\", 1)) # Output: True print(can_form_palindrome(\\"abcdcba\\", 2)) # Output: True print(can_form_palindrome(\\"a\\", 0)) # Output: True ```","solution":"def can_form_palindrome(s: str, n: int) -> bool: Determine if a string can be rearranged to form a palindrome with character repetitions allowed up to `n` times. :param s: The input string :param n: Maximum repetitions allowed for any character :return: Boolean indicating if the string can form a palindrome >>> can_form_palindrome(\\"aabb\\", 0) True >>> can_form_palindrome(\\"abc\\", 1) False >>> can_form_palindrome(\\"aaabbb\\", 1) True >>> can_form_palindrome(\\"abcdcba\\", 2) True >>> can_form_palindrome(\\"a\\", 0) True from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count if odd_count <= 1: return True # If there are more characters with odd counts than n can cover if odd_count - 1 <= n: return True return False"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the factorial of a non-negative integer using an iterative approach. # Functional Requirements Implement a function `iterative_factorial(n: int) -> int` that: - Computes the factorial of a given non-negative integer `n` without using recursion. - Takes the following parameter: * `n` (int): The non-negative integer for which the factorial is to be computed. Must be non-negative. # Constraints - The parameter `n` must be a non-negative integer. - The function should be implemented iteratively using loops rather than recursively. # Error Handling - If `n` is negative, raise a `ValueError` with the message \\"n must be a non-negative integer\\". # Example ```python def iterative_factorial(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") result = 1 for i in range(2, n + 1): result *= i return result # Test cases print(iterative_factorial(0)) # 1 print(iterative_factorial(1)) # 1 print(iterative_factorial(5)) # 120 print(iterative_factorial(10)) # 3628800 # print(iterative_factorial(-1)) # Raises ValueError: n must be a non-negative integer ``` # Your Task Implement the `iterative_factorial` function according to the specifications above. Ensure proper error handling and validate the inputs before performing calculations. **Note**: Use the provided test cases to verify your implementation.","solution":"def iterative_factorial(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Coding Assessment Question Description: Create a function that simulates the behavior of a simple load balancer. You will implement a Round Robin load balancing algorithm to distribute incoming requests evenly across a given number of servers. Function Signature: ```python def round_robin_load_balancer(requests: list[str], servers: int) -> list[list[str]]: ``` Parameters: 1. **requests** (list[str]): A list of incoming request identifiers, represented as strings. 2. **servers** (int): The number of available servers. Behavior: - Distribute the incoming requests to the servers using the Round Robin method. - Distribute the requests in equal turn among the servers. - Return a list of lists, where each sublist represents the requests assigned to a particular server. Example: ```python requests = [\\"req1\\", \\"req2\\", \\"req3\\", \\"req4\\", \\"req5\\", \\"req6\\"] servers = 3 result = round_robin_load_balancer(requests, servers) # Expected output: # [ # [\\"req1\\", \\"req4\\"], # [\\"req2\\", \\"req5\\"], # [\\"req3\\", \\"req6\\"] # ] ``` Constraints: - `1 <= len(requests) <= 10^5` - `1 <= servers <= 1000` - Each server should handle approximately the same number of requests. - Server indices in the output list should match the order in the Round Robin distribution. Additional Requirements: - Document the main function and any helper functions. - Ensure code clarity and proper formatting. - Handle invalid inputs gracefully, including scenarios where the number of servers is zero or negative. - Include meaningful error messages as needed.","solution":"def round_robin_load_balancer(requests: list[str], servers: int) -> list[list[str]]: Distribute incoming requests to servers using Round Robin method. Parameters: requests (list[str]): A list of request identifiers. servers (int): The number of available servers. Returns: list[list[str]]: A list of lists where each sublist contains requests assigned to a particular server. if servers <= 0: raise ValueError(\\"Number of servers must be greater than 0\\") result = [[] for _ in range(servers)] for i, request in enumerate(requests): server_index = i % servers result[server_index].append(request) return result"},{"question":"# Coding Question You are tasked with developing a small module to manage a parking lot system that operates on a first-come, first-served basis. The module should handle vehicle entries, exits, and maintain records of all parked vehicles along with their entry times. Objective Build functionalities to efficiently manage the vehicle parking operations and ensure proper validations. 1. **Implement Core Functions**: - Create a function `vehicle_entry` to register a vehicle entry, capturing the vehicle number and entry time. - Develop a function `vehicle_exit` to remove a vehicle from the parking lot, calculating the duration of stay and the parking fee based on a predetermined rate. 2. **Enhance Functionalities**: - Ensure the `vehicle_entry` function validates vehicle numbers to follow a specific format (e.g., XX-1234 where X is an uppercase letter and 1-4 are digits). - Implement functionality within `vehicle_exit` to handle cases where the vehicle number provided is not found in the parking lot. Function Implementations - **vehicle_entry(vehicle_number: str, entry_time: str, parking_lot: dict[str, str]) -> None**: - Input: Vehicle number (string), entry time (string in \\"HH:MM\\" format), parking lot (dict storing vehicle number and entry time). - Output: Registers the vehicle in the parking lot dict after validation. - **vehicle_exit(vehicle_number: str, exit_time: str, parking_lot: dict[str, str], rate_per_hour: float) -> str**: - Input: Vehicle number (string), exit time (string in \\"HH:MM\\" format), parking lot (dict storing vehicle number and entry time), rate per hour (float). - Output: Returns a string indicating total parking duration and fee, removes the vehicle from the parking lot; raises error if vehicle not found. - **validate_vehicle_number(vehicle_number: str) -> bool**: - Input: Vehicle number (string). - Output: Returns `True` if the vehicle number is valid, otherwise `False`. Example ```python >>> parking_lot = {} >>> vehicle_entry(\\"AB-1234\\", \\"09:15\\", parking_lot) >>> vehicle_entry(\\"CD-5678\\", \\"09:45\\", parking_lot) >>> print(parking_lot) {\'AB-1234\': \'09:15\', \'CD-5678\': \'09:45\'} >>> vehicle_exit(\\"AB-1234\\", \\"12:30\\", parking_lot, 10) \'Vehicle AB-1234 stayed for 3:15 hours. Total fee: 32.50\' >>> print(parking_lot) {\'CD-5678\': \'09:45\'} ```","solution":"from datetime import datetime def validate_vehicle_number(vehicle_number: str) -> bool: Validate the vehicle number to match format XX-1234. import re pattern = r\\"^[A-Z]{2}-d{4}\\" if re.match(pattern, vehicle_number): return True return False def vehicle_entry(vehicle_number: str, entry_time: str, parking_lot: dict[str, str]) -> None: Register the vehicle in the parking lot dict after validation. if not validate_vehicle_number(vehicle_number): raise ValueError(\\"Invalid vehicle number format. Expected format: XX-1234\\") if vehicle_number in parking_lot: raise ValueError(\\"Vehicle already in the parking lot.\\") parking_lot[vehicle_number] = entry_time def vehicle_exit(vehicle_number: str, exit_time: str, parking_lot: dict[str, str], rate_per_hour: float) -> str: Calculate the parking duration and fee, remove the vehicle from the parking lot. if vehicle_number not in parking_lot: raise ValueError(\\"Vehicle not found in the parking lot.\\") entry_time_str = parking_lot.pop(vehicle_number) entry_time = datetime.strptime(entry_time_str, \\"%H:%M\\") exit_time_obj = datetime.strptime(exit_time, \\"%H:%M\\") duration = exit_time_obj - entry_time duration_hours = duration.seconds / 3600 fee = duration_hours * rate_per_hour return f\\"Vehicle {vehicle_number} stayed for {duration}. Total fee: {fee:.2f}\\""},{"question":"# Question: Implement an Efficient Path-Finding Algorithm Scenario You are tasked with finding the shortest path in a labyrinth represented by a 2D grid. The grid consists of walls, open spaces, a start point, and an end point. Your goal is to return the shortest path from the start to the end if it exists. The grid may contain dead ends, and not all paths are guaranteed to lead to the end. Function Implementation Your task is to implement the `find_shortest_path` function, which computes the shortest path from the start point to the end point in the given grid. Function Signature ```python def find_shortest_path(grid: list[list[str]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: ``` Input - `grid`: a 2D list of strings, where: - `\'S\'` represents the starting point, - `\'E\'` represents the ending point, - `\'O\'` represents an open space, - `\'#\'` represents a wall. - `start`: a tuple `(x, y)` indicating the starting point coordinates on the grid. - `end`: a tuple `(x, y)` indicating the ending point coordinates on the grid. Output - Returns a list of tuples, where each tuple represents the coordinates `(x, y)` of a point along the shortest path from the start to the end, inclusive. - If no path exists, return an empty list. Constraints - The grid size can be up to `500x500`. - Ensure that any algorithm optimizations maintain pathfinding correctness. - Only traverse open spaces (\'O\'), and starting and ending points (\'S\' and \'E\'). Example ```python grid = [ [\'S\', \'O\', \'O\', \'#\', \'O\', \'O\'], [\'#\', \'#\', \'O\', \'#\', \'O\', \'O\'], [\'O\', \'O\', \'O\', \'#\', \'O\', \'O\'], [\'O\', \'#\', \'O\', \'O\', \'O\', \'E\'], ] start = (0, 0) end = (3, 5) path = find_shortest_path(grid, start, end) # Expected output would be a possible shortest path: # [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (3, 3), (3, 4), (3, 5)] ``` # Considerations - Make sure your code is efficient, especially for larger grids. Breadth-first search (BFS) is a suitable algorithm for unweighted grids. - Ensure boundary conditions (edges of the grid) are handled correctly. - Any algorithm or data structure optimizations should not sacrifice the correctness of the result.","solution":"from collections import deque def find_shortest_path(grid, start, end): Find the shortest path from start to end in a 2D grid. :param grid: List[List[str]] - the labyrinth represented by a 2D grid :param start: Tuple[int, int] - starting point coordinates (x, y) :param end: Tuple[int, int] - ending point coordinates (x, y) :return: List[Tuple[int, int]] - the shortest path from start to end rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up def in_bounds(x, y): return 0 <= x < rows and 0 <= y < cols def is_open_space(x, y): return grid[x][y] in (\'O\', \'S\', \'E\') queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (x, y), path = queue.popleft() if (x, y) == end: return path for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and is_open_space(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"# Scenario You are developing a data analysis tool that requires efficient computation of the moving average over a list of numbers. The goal is to calculate the simple moving average (SMA) for a given list and window size. # Task Implement a function `moving_average` that computes the simple moving average for a specified window size over a list of numeric values. # Function Signature ```python def moving_average(data: List[float], window_size: int) -> List[float]: ``` # Input * `data`: A list of float numbers. * `window_size`: An integer representing the size of the moving window. # Output * Returns a list of float numbers representing the moving averages. # Constraints * 1 ≤ `window_size` ≤ len(`data`) * The function must handle input lists of size up to (10^6) efficiently. * You should not use any external libraries for the moving average computation. # Example ```python >>> moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> moving_average([10.0, 20.0, 30.0, 40.0, 50.0], 2) [15.0, 25.0, 35.0, 45.0] ``` # Performance Requirements * The solution should run in optimal time for the given input constraints. # Edge Cases * Ensure your function correctly handles window sizes equal to 1 and the length of the `data` list.","solution":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: Computes the simple moving average for a specified window size over a list of numeric values. Args: - data: A list of float numbers. - window_size: An integer representing the size of the moving window. Returns: - A list of float numbers representing the moving averages. if not data or window_size <= 0 or window_size > len(data): return [] averages = [] window_sum = sum(data[:window_size]) averages.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] averages.append(window_sum / window_size) return averages"},{"question":"# Merge K Sorted Arrays Context You are required to merge `k` sorted arrays into one sorted array. This task will allow you to demonstrate your understanding of efficient sorting and merging algorithms, particularly when handling multiple lists. Problem Statement 1. **Merge K Sorted Arrays**: Implement a method `merge_k_sorted_arrays(self, arrays: List[List[int]]) -> List[int]` that takes a list of `k` sorted arrays and merges them into a single sorted array. * **Input**: A list of `k` sorted arrays, where each array contains `int` values. * **Output**: A single sorted list containing all the elements from the `k` input arrays. # Implementation Details * Implement the following method inside a class of your choice: ```python class Solution: def merge_k_sorted_arrays(self, arrays: List[List[int]]) -> List[int]: # Your implementation here ``` # Example Usage ```python sol = Solution() arrays = [ [1, 5, 9], [2, 6, 8], [3, 7, 10] ] result = sol.merge_k_sorted_arrays(arrays) print(result) # Should print: [1, 2, 3, 5, 6, 7, 8, 9, 10] ``` Constraints - Arrays are individually sorted in increasing order. - The total number of elements across all `k` arrays will not exceed `10^5`. Submission Requirements - The method should efficiently merge the `k` arrays into one sorted list. - Explain your approach briefly after implementing the method, focusing on the algorithm and its time complexity. Approach To tackle the problem efficiently, you may consider using a priority queue (min-heap) to keep track of the smallest elements from each array. This approach helps maintain an optimal time complexity.","solution":"from heapq import heappush, heappop from typing import List class Solution: def merge_k_sorted_arrays(self, arrays: List[List[int]]) -> List[int]: min_heap = [] result = [] # Initialize the heap with the first element of each array for i, array in enumerate(arrays): if array: heappush(min_heap, (array[0], i, 0)) # Extract the smallest items and add the next item of that array to the heap while min_heap: val, array_idx, element_idx = heappop(min_heap) result.append(val) if element_idx + 1 < len(arrays[array_idx]): next_tuple = (arrays[array_idx][element_idx + 1], array_idx, element_idx + 1) heappush(min_heap, next_tuple) return result"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},F={class:"card-container"},R={key:0,class:"empty-state"},N=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,N)):u("",!0)])}const j=h(O,[["render",D],["__scopeId","data-v-127f6bfe"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/47.md","filePath":"library/47.md"}'),Y={name:"library/47.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,V as default};
