import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-69e24e7c"]]),S=JSON.parse('[{"question":"# New Question: String Formatting Utility Design and implement a class `StringFormatter` that provides several utility methods for common string manipulation tasks. Your class should offer methods to format the strings in different ways. **Class Definition**: `StringFormatter` **Methods**: 1. `to_title_case(text: str) -> str`: Converts the input text to title case (first letter of each word capitalized). 2. `to_snake_case(text: str) -> str`: Converts the input text to snake case (words are lowercased and separated by underscores). 3. `to_caps_lock(text: str) -> str`: Converts the input text to all uppercase letters. 4. `to_lower_case(text: str) -> str`: Converts the input text to all lowercase letters. 5. `reverse(text: str) -> str`: Reverses the characters in the input text. **Input**: - All methods take a single string (`text`). **Output**: - Each method returns a single string representing the transformed version of the input text. **Constraints**: - The input string can contain alphabets, numbers, spaces, and punctuation. # Example ```python formatter = StringFormatter() print(formatter.to_title_case(\\"hello world\\")) # Output: \\"Hello World\\" print(formatter.to_snake_case(\\"Hello World\\")) # Output: \\"hello_world\\" print(formatter.to_caps_lock(\\"Hello World\\")) # Output: \\"HELLO WORLD\\" print(formatter.to_lower_case(\\"Hello World\\")) # Output: \\"hello world\\" print(formatter.reverse(\\"Hello World\\")) # Output: \\"dlroW olleH\\" ``` # Performance Requirements: - The methods should handle strings of length up to `10^6` efficiently. Implement the `StringFormatter` class ensuring all transformations are correctly handled and edge cases (like empty strings or excessive spaces) are properly managed.","solution":"import re class StringFormatter: @staticmethod def to_title_case(text: str) -> str: Converts the input text to title case (first letter of each word capitalized). return text.title() @staticmethod def to_snake_case(text: str) -> str: Converts the input text to snake case (words are lowercased and separated by underscores). text = re.sub(r\'[W_]+\', \' \', text) return \'_\'.join(text.lower().split()) @staticmethod def to_caps_lock(text: str) -> str: Converts the input text to all uppercase letters. return text.upper() @staticmethod def to_lower_case(text: str) -> str: Converts the input text to all lowercase letters. return text.lower() @staticmethod def reverse(text: str) -> str: Reverses the characters in the input text. return text[::-1]"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to analyze and implement efficient data structures and algorithms for solving real-world problems. **Background**: In a vast and interconnected city, the delivery company wants to streamline its delivery routes. The city is represented as a grid, and each point on the grid may have different elevations, making some routes more costly in terms of travel effort. Your task is to implement an algorithm that calculates the minimum cost to travel from the top-left corner to the bottom-right corner of the grid, only moving right or down. The cost of entering each cell is defined by its elevation. **Task**: 1. **Function Implementation**: Implement a function called `min_travel_cost` that: - Accepts a 2D list `grid` representing the elevations of each point in the city. - Returns the minimum cost to travel from the top-left corner to the bottom-right corner. 2. **Constraints**: - You may travel right or down at each step. - The grid size can be up to 1000x1000. 3. **Edge Cases**: Handle possible edge cases such as: - Minimal grid size of 1x1. - Grids where all elevations are the same. **Input/Output**: - Input: `min_travel_cost(grid: List[List[int]]) -> int` - `grid`: A 2D list of integers representing the elevation costs. - Output: Returns the minimum travel cost from the top-left to the bottom-right. **Constraints**: - 1 ≤ len(grid), len(grid[0]) ≤ 1000 - 0 ≤ elevation value in `grid` ≤ 10000 **Performance Requirements**: - Your solution should execute efficiently within time and space constraints for the upper limit of grid size 1000x1000. # Example ```python def min_travel_cost(grid: List[List[int]]) -> int: pass # Example Usage assert min_travel_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 assert min_travel_cost([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 assert min_travel_cost([[1]]) == 1 assert min_travel_cost([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 ``` Provide a well-commented and efficient solution to this problem.","solution":"from typing import List def min_travel_cost(grid: List[List[int]]) -> int: Calculate the minimum travel cost to move from the top-left corner to the bottom-right corner of the grid, only allowing moves to the right or down. rows, cols = len(grid), len(grid[0]) # Create a dp table to store the minimum cost to reach each cell dp = [[0] * cols for _ in range(rows)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[rows-1][cols-1]"},{"question":"# Coding Assessment Question **Context:** You are developing a utility module for managing game scores. One of the functionalities required is to compute the rank of a particular score in a list of scores. The rank should be determined based on the highest scores, with 1 being the highest rank. The ranking should handle ties by assigning the same rank to equal scores and skipping the next ranks accordingly. # Task: Implement a function `rank_scores(scores: List[int], target: int) -> int` that computes the rank of a given `target` score in a list of `scores`. Function Signature: ```python def rank_scores(scores: List[int], target: int) -> int: pass ``` # Input: - A list of integers `scores`. - An integer `target`. # Output: - Return the rank (an integer) of the `target` score in the list of `scores`. If the `target` does not appear in the list, return `-1`. # Constraints: - The input `scores` list will have the following properties: * The length of `scores` will be between 0 and (10^5). * Each score in `scores` and the `target` score will be between (-10^9) and (10^9). - You should handle cases where the input types are not as expected by raising a `TypeError`. # Example: ```python >>> rank_scores([100, 200, 50, 100, 75], 100) 2 >>> rank_scores([100, 200, 50, 100, 75], 200) 1 >>> rank_scores([100, 200, 50, 100, 75], 50) 4 >>> rank_scores([100, 200, 50, 100, 75], 300) -1 >>> rank_scores([], 100) -1 >>> rank_scores([100, 200, 50, 100, 75], -100) -1 >>> rank_scores(\\"invalid input\\", 100) Traceback (most recent call last): ... TypeError: \'scores\' should be a list of integers >>> rank_scores(None, 100) Traceback (most recent call last): ... TypeError: \'scores\' should be a list of integers >>> rank_scores([100, 200, 50, 100, 75], \\"invalid target\\") Traceback (most recent call last): ... TypeError: \'target\' should be an integer ``` **Note:** You should ensure your function handles edge cases like an empty list and invalid input types providing meaningful error messages.","solution":"from typing import List def rank_scores(scores: List[int], target: int) -> int: if not isinstance(scores, list) or not all(isinstance(score, int) for score in scores): raise TypeError(\\"\'scores\' should be a list of integers\\") if not isinstance(target, int): raise TypeError(\\"\'target\' should be an integer\\") if target not in scores: return -1 sorted_unique_scores = sorted(set(scores), reverse=True) rank = sorted_unique_scores.index(target) + 1 return rank"},{"question":"# Problem Statement A security system has been implemented to monitor temperature fluctuations in a server room. The system records the temperature once every minute, and stores these readings in an array. Your task is to create a function that will determine the number of times a certain temperature threshold is exceeded for a given consecutive number of minutes. **Function Signature:** ```python def count_exceedances(temperature_readings: List[int], threshold: int, duration: int) -> int: pass ``` # Inputs: 1. **temperature_readings (List[int]):** An array representing the temperature readings taken each minute (1 ≤ len(temperature_readings) ≤ 10^5). 2. **threshold (int):** An integer representing the temperature threshold. 3. **duration (int):** An integer representing the number of consecutive minutes to check the temperature readings (1 ≤ duration ≤ len(temperature_readings)). # Outputs: - **Returns (int):** The number of times the temperature exceeded the threshold consecutively for the given number of minutes. # Example: ```python print(count_exceedances([70, 72, 68, 65, 74, 75, 76, 70, 69, 71], 72, 3)) # Output: 1 ``` Explanation: In the given example, the only consecutive sequence of 3 temperatures where all readings exceed 72 is [74, 75, 76]. The function thus returns `1` for this single exceedance. --- By maintaining a consistent format, scope, and difficulty as the sample question, this new question integrates seamlessly into the original set. The focus on list manipulation and loop-based logic provides a challenge of similar complexity, targeting proficiency in handling arrays.","solution":"from typing import List def count_exceedances(temperature_readings: List[int], threshold: int, duration: int) -> int: Counts the number of times the temperature exceeds the threshold for at least the given number of consecutive minutes. :param temperature_readings: List of temperature readings. :param threshold: The temperature threshold. :param duration: Number of consecutive minutes to consider. :return: The number of exceedances. if len(temperature_readings) < duration: return 0 exceedances_count = 0 consecutive_count = 0 for i in range(len(temperature_readings)): if temperature_readings[i] > threshold: consecutive_count += 1 if consecutive_count >= duration: exceedances_count += 1 else: consecutive_count = 0 return exceedances_count"},{"question":"# Scenario You are working as a software developer for an e-commerce company. The company has a vast, dynamic inventory of products, and they are interested in tracking product trends over a window of time. Specifically, they want to keep a running track of the top K most frequently accessed products in a stream of product IDs. # Problem Statement Write a Python function to implement a dynamic tracking system that continuously updates the top K most frequently accessed products from a stream of product IDs. Whenever a new product ID is accessed, the system should update and reflect the top K results. # Function Signature ```python def top_k_products(stream: List[int], k: int) -> List[int]: pass ``` # Input - `stream`: A list of integers representing the product IDs accessed in the order they were accessed. - `k`: An integer representing the number of top frequently accessed products to track. # Output - A list of integers representing the top K most frequently accessed product IDs sorted in descending order of their frequency. In case of a tie, the product with the smaller ID should appear first. # Constraints - The length of `stream` will be between 1 and 10^6. - The product IDs in `stream` will be non-negative integers. - `k` will be a positive integer less than or equal to the total number of distinct product IDs in `stream`. # Example ```python stream = [1, 2, 3, 2, 1, 2, 4, 1, 3, 1, 5, 2] k = 2 print(top_k_products(stream, k)) # Expected Output: [1, 2] ``` # Notes - You may assume that the stream is not empty and the value of k is always valid. - Ensure your solution handles continuous updates efficiently as the stream can be quite large. - The result should always reflect the top K most frequently accessed products based on the complete stream read up to that point. # Additional Example If `stream = [5, 5, 4, 4, 4, 3, 3, 2, 1, 3]` and `k = 3`, then `top_k_products(stream, k)` should return `[3, 4, 5]`. This indicates that product ID 3 has been accessed the most, followed by product IDs 4 and 5. Ensure your solution effectively handles edge cases such as when all product IDs are unique or when multiple products have the same access frequency.","solution":"from collections import Counter import heapq from typing import List def top_k_products(stream: List[int], k: int) -> List[int]: Keeps track and returns the top K most frequently accessed product IDs from a stream. counter = Counter(stream) heap = [] for product, freq in counter.items(): heapq.heappush(heap, (-freq, product)) top_k = [] for _ in range(k): top_k.append(heapq.heappop(heap)[1]) return top_k"},{"question":"# Word Frequency Analysis You are asked to implement a function that analyzes the frequency of each word in a given string. The goal is to return a dictionary where the keys are the words and the values are their corresponding frequencies. 1. **`word_frequency_analysis(text: str) -> Dict[str, int]`**: - Takes a string input `text` and computes the frequency of each word. - Words are defined as sequences of characters separated by whitespace. - Punctuation should be ignored (e.g., \\"hello,\\" and \\"hello\\" should be counted as the same word). - The function should be case-insensitive (e.g., \\"Hello\\" and \\"hello\\" should be counted as the same word). # Function Signature ```python from typing import Dict import string def word_frequency_analysis(text: str) -> Dict[str, int]: Analyze the frequency of each word in the given text. :param text: str, the input text to analyze. :return: dict, a dictionary where keys are words and values are their frequencies. pass ``` # Constraints - The input string `text` can be of any length, including an empty string. - Assume the input text only contains printable ASCII characters. # Performance Requirements - The function should handle large texts efficiently. - Aim for a linear time complexity with respect to the number of characters in the input text. # Example ```python if __name__ == \\"__main__\\": text = \\"Hello, World! Hello world. This is a word frequency analysis example. Example, example.\\" word_frequencies = word_frequency_analysis(text) print(word_frequencies) # Expected Output: {\'hello\': 2, \'world\': 2, \'this\': 1, \'is\': 1, \'a\': 1, \'word\': 1, \'frequency\': 1, \'analysis\': 1, \'example\': 3} ``` Write your code to implement the `word_frequency_analysis` function.","solution":"from typing import Dict import string def word_frequency_analysis(text: str) -> Dict[str, int]: Analyze the frequency of each word in the given text. :param text: str, the input text to analyze. :return: dict, a dictionary where keys are words and values are their frequencies. # Normalize the text to lowercase text = text.lower() # Remove punctuation using str.translate translator = str.maketrans(\'\', \'\', string.punctuation) text = text.translate(translator) # Split the text into words words = text.split() # Calculate frequencies frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Problem Statement You are given a list of tasks, each represented by an interval `[start, end]` where `start` represents the start time and `end` represents the finish time. Your task is to implement a function that finds the maximum number of non-overlapping intervals you can schedule. The function should implement a greedy algorithm to solve the problem. # Function Signature ```python def max_non_overlapping_intervals(intervals): :param intervals: List[Tuple[int, int]] - A list of intervals represented as tuples of (start, end) :return: int - The maximum number of non-overlapping intervals that can be scheduled ``` # Constraints & Input Format - The input list `intervals` will contain intervals represented as tuples `(start, end)`. - The length of `intervals` (denoted as `n`) will be in the range `0 <= n <= 10^4`. - Each tuple contains two integers `0 <= start < end <= 10^6`. # Example ```python intervals = [(1, 3), (2, 4), (3, 5), (5, 7), (6, 8)] max_non_overlapping_intervals(intervals) # Expected output: 3 ``` # Explanation - Sort the intervals based on their end times. - Initialize the end time of the last added interval to negative infinity and a counter to zero. - Iterate through the sorted intervals: - If the start time of the current interval is greater than or equal to the end time of the last added interval, add the current interval and update the end time. - Increment the counter each time you add a new interval. - Return the counter as the maximum number of non-overlapping intervals. # Solution Approach 1. **Sorting**: Sort the given intervals by their end times. 2. **Initialization**: Initialize a variable to track the end time of the last added interval and a count. 3. **Iteration**: Loop through the sorted intervals, and for each interval, if its start time is greater than or equal to the end time of the last added one, update the end time and increment the count. 4. **Result**: Return the final count of non-overlapping intervals.","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals that can be scheduled. :param intervals: List[Tuple[int, int]] - A list of intervals represented as tuples of (start, end) :return: int - The maximum number of non-overlapping intervals that can be scheduled if not intervals: return 0 # Sort intervals by their end times intervals.sort(key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a list of integers and a certain number of operations you must perform on it. Each operation consists of choosing any two integers from the list, removing them, and inserting their sum back into the list. Your task is to minimize the final integer left in the list after all operations are performed. Write a function `minimize_final_integer(nums: List[int], operations: int) -> int` that takes a list of integers and the number of operations to perform, and returns the smallest possible final integer left in the list after performing all operations. # Input Formate: - `nums` : A list of integers. - `operations`: An integer representing the number of operations to perform. # Output Format: - A single integer representing the smallest possible final integer left in the list. # Constraints: - The length of `nums` is at least `2`. - `1 <= numbers of operations <= len(nums) - 1`. # Example ```python def test_minimize_final_integer(): assert minimize_final_integer([4, 3, 1, 2], 2) == 10 assert minimize_final_integer([1, 2, 3, 4, 5], 3) == 6 assert minimize_final_integer([5, 9, 3, 1], 1) == 14 test_minimize_final_integer() ``` *Note*: Assume the resulting integer list should be the result of performing `operations` number of operations. For example, if you have integers `4, 3, 1, 2` and you need to perform `2` operations: 1. Choose `1` and `2` to get `3` -> `4, 3, 3` 2. Choose any `3` and `3` to get `6` -> `4, 6` 3. The final integer left will be `10`.","solution":"from typing import List import heapq def minimize_final_integer(nums: List[int], operations: int) -> int: Returns the smallest possible final integer left in the list after performing the given number of operations. Each operation consists of choosing any two integers from the list, removing them, and inserting their sum back into the list. # Convert nums list to a min-heap heapq.heapify(nums) # Perform the given number of operations for _ in range(operations): # Extract the two smallest elements smallest = heapq.heappop(nums) second_smallest = heapq.heappop(nums) # Insert their sum back into the heap heapq.heappush(nums, smallest + second_smallest) # After all operations, the smallest possible final integer left in the list is the sum of all remaining elements return sum(nums)"},{"question":"# Problem Statement You are tasked with helping a logistics company optimize their delivery system. They need to be able to determine the earliest time by which all of their delivery vehicles can meet at a particular stop, given their respective schedules. Write a function `find_earliest_meeting_time(schedules)` that takes a list of schedules, where each schedule represents the time intervals (in minutes) that deliveries are made. The function should calculate the earliest time (in minutes) at which all deliveries can meet at the same stop, considering their given time intervals. If it is impossible to find such a time within a reasonable limit (e.g., 10^6 minutes), return `-1`. # Function Signature ```python def find_earliest_meeting_time(schedules: List[int]) -> int: ``` # Input * `schedules` (a list of integers where `1 <= len(schedules) <= 10^5` and `1 <= schedules[i] <= 10^5`): The interval times for different delivery vehicles. # Output * Return the earliest meeting time (in minutes) for all schedules. If it is not possible within a reasonable time limit, return `-1`. # Constraints * The function should efficiently handle large values and lists. * Assume interval times are positive integers. # Performance Requirements * Must run within reasonable time limits for the maximum input sizes. # Example ```python print(find_earliest_meeting_time([3, 7, 11])) # Output: 231 # Explanation: The times at which all schedules meet is the least common multiple (LCM) of 3, 7, and 11, which is 231. print(find_earliest_meeting_time([5, 10, 15])) # Output: 30 # Explanation: The times at which all schedules meet is the LCM of 5, 10, and 15, which is 30. print(find_earliest_meeting_time([2, 3, 5, 7])) # Output: 210 # Explanation: The times at which all schedules meet is the LCM of 2, 3, 5, and 7, which is 210. ``` # Additional Notes Considerations: 1. Your implementation should minimize computational overhead, potentially using mathematical properties like the Least Common Multiple (LCM). 2. Edge cases such as very large intervals should be expected and handled efficiently. 3. Avoid unnecessary calculations that could lead to exceeding time limits for large inputs.","solution":"from math import gcd from functools import reduce from typing import List def lcm(a, b): return a * b // gcd(a, b) def find_earliest_meeting_time(schedules: List[int]) -> int: def lcm_multiple(numbers): return reduce(lcm, numbers, 1) lcm_time = lcm_multiple(schedules) return lcm_time if lcm_time <= 10**6 else -1"},{"question":"# Problem Statement Write a function `find_first_non_repeating_char(s: str) -> str` that finds the first non-repeating character in a given string `s` and returns it. If there is no non-repeating character, return an empty string `\'\'`. # Input - A string `s` composed of any printable ASCII characters. The length of the string can range from `1` to `10^5`. # Output - A single character string that represents the first non-repeating character in the input string. - If no such character exists, return an empty string `\'\'`. # Constraints - The string `s` can include digits, letters, punctuation marks, and whitespace characters. - The string can be assumed to be non-empty. # Performance Requirements - The algorithm should efficiently handle strings up to the maximum length constraint. # Example Usage ```python >>> find_first_non_repeating_char(\'abcdcaf\') \'b\' >>> find_first_non_repeating_char(\'aabbcc\') \'\' >>> find_first_non_repeating_char(\'swiss\') \'w\' >>> find_first_non_repeating_char(\'hello world\') \'h\' >>> find_first_non_repeating_char(\'a\') \'a\' ``` # Additional Notes - Assume ASCII characters range from 0 to 127. - Consider edge cases such as all characters repeating or only one character in the string. - Aim to solve this problem in linear time complexity with respect to the length of the string.","solution":"def find_first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in string s. If there is no such character, returns an empty string. from collections import Counter # Count the occurrences of each character count = Counter(s) # Find the first character with a count of 1 for char in s: if count[char] == 1: return char # If no non-repeating character is found, return an empty string return \'\'"},{"question":"# Question Description You are given a list of integers where each element appears exactly twice, except for one element which appears exactly once. Your task is to write a Python function that finds and returns the element that appears only once. Your implementation should have a linear runtime complexity and use constant extra space. # Function Signature ```python def find_single_element(nums: list[int]) -> int: Finds the element that appears exactly once in a list where all other elements appear twice. Parameters: nums (list[int]): A list of integers where every integer appears twice except for one which appears once. Returns: int: The integer that appears only once in the list. Constraints: - 1 <= len(nums) <= 10^5 - Each element in the list is an integer between -10^6 and 10^6. ``` # Input - A list of integers `nums` where each integer appears exactly twice, except for one integer which appears exactly once. List length is between 1 and (10^5). # Output - An integer that appears only once in the list. # Example ```python >>> find_single_element([2, 2, 3, 4, 4]) 3 >>> find_single_element([1, 1, 2, 2, 3]) 3 >>> find_single_element([-1, -1, 0, 1, 1]) 0 >>> find_single_element([5, 4, 3, 3, 4]) 5 ``` # Constraints - The list will always contain at least one element that appears exactly once. - The function should run in (O(n)) time complexity. - The function should use (O(1)) extra space complexity. # Notes - Using bitwise XOR is an optimal approach to solve the problem. Remember that XORing a number with itself results in 0 and XORing any number with 0 results in the number itself.","solution":"def find_single_element(nums: list[int]) -> int: Finds the element that appears exactly once in a list where all other elements appear twice. Parameters: nums (list[int]): A list of integers where every integer appears twice except for one which appears once. Returns: int: The integer that appears only once in the list. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Problem Statement You are given the task of analyzing a dataset containing the duration (in minutes) that different customers spend on a website along with their respective satisfaction ratings (on a scale from 1 to 10). The objective is to implement a polynomial regression model to predict satisfaction based on the time spent on the website. Your function needs to: 1. Implement polynomial regression using gradient descent. 2. Output the learned polynomial coefficients after a fixed number of iterations. 3. Calculate and return the Root Mean Squared Error (RMSE) on a provided test dataset. # Function Signature ```python def polynomial_regression_predict(train_X, train_Y, test_X, test_Y, degree=2, iterations=1000, alpha=0.01): :param train_X: List[float] - Duration feature for training :param train_Y: List[float] - Satisfaction target for training :param test_X: List[float] - Duration feature for testing :param test_Y: List[float] - Satisfaction target for testing :param degree: int - Degree of the polynomial features :param iterations: int - Number of iterations for gradient descent :param alpha: float - Learning rate for gradient descent :return: Tuple[List[float], float] - Trained polynomial coefficients and root mean squared error on test data ``` # Constraints & Input Format - train_X and train_Y are lists where `len(train_X) == len(train_Y)` and `len(train_X) > 0`. - test_X and test_Y are lists where `len(test_X) == len(test_Y)` and `len(test_X) > 0`. - Each element in train_X, train_Y, test_X, and test_Y is a non-negative float. - The duration values in train_X and test_X are scaled between 0 and 180 (minutes). - The satisfaction values in train_Y and test_Y are scaled between 1 and 10. # Example ```python train_X = [5, 15, 30, 45, 60] train_Y = [2, 4, 6, 7, 8] test_X = [10, 50, 70] test_Y = [3, 6, 8] coefficients, rmse = polynomial_regression_predict(train_X, train_Y, test_X, test_Y, degree=2) print(coefficients) # Expected output: approximately [intercept, coeff_1, coeff_2] print(rmse) # Expected output: a float value representing the root mean squared error ``` # Explanation 1. **Data Preparation**: Convert lists to numpy arrays and generate polynomial features up to the specified degree. 2. **Initialization**: Polynomial coefficients (theta) initialized to zero. 3. **Gradient Descent**: Perform parameter updates for the specified iterations using the computed gradient based on mean squared error. 4. **Prediction & RMSE Calculation**: Use the learned polynomial coefficients to make predictions on the test set and calculate RMSE. By the end of this problem, you will have implemented a polynomial regression model capable of predicting customer satisfaction based on their time spent on a website, providing insights into customer behavior and satisfaction trends.","solution":"import numpy as np def polynomial_regression_predict(train_X, train_Y, test_X, test_Y, degree=2, iterations=1000, alpha=0.01): def create_polynomial_features(X, degree): X_poly = np.ones((len(X), degree + 1)) for i in range(1, degree + 1): X_poly[:, i] = np.power(X, i) return X_poly def compute_rmse(predictions, targets): return np.sqrt(np.mean((predictions - targets) ** 2)) # Converting lists to numpy arrays train_X = np.array(train_X) train_Y = np.array(train_Y) test_X = np.array(test_X) test_Y = np.array(test_Y) # Creating polynomial features train_X_poly = create_polynomial_features(train_X, degree) test_X_poly = create_polynomial_features(test_X, degree) # Initialize theta (coefficients) with zeros theta = np.zeros(degree + 1) # Gradient Descent m = len(train_X) for _ in range(iterations): predictions = np.dot(train_X_poly, theta) errors = predictions - train_Y gradients = np.dot(train_X_poly.T, errors) / m theta = theta - alpha * gradients # Make predictions on test set test_predictions = np.dot(test_X_poly, theta) # Calculate RMSE rmse = compute_rmse(test_predictions, test_Y) return theta.tolist(), rmse"},{"question":"# Question In this task, you are required to implement the `unique_combinations` function which generates all unique combinations of k numbers that sum up to n, given the range of integers from 1 to 9. The combinations should be returned in lexicographical order. Function Signature ```python def unique_combinations(k: int, n: int) -> List[List[int]]: ... ``` # Input - `k` (int): The number of elements in each combination. - `n` (int): The target sum. # Output - `List[List[int]]`: A list of all unique combinations of k numbers that add up to n. # Constraints - `1 <= k <= 9` - `1 <= n <= 45` Example ```python res = unique_combinations(3, 7) # Expected output: [[1, 2, 4]] print(res) # Should return [[1, 2, 4]] res = unique_combinations(3, 9) # Expected output: [[1, 2, 6], [1, 3, 5], [2, 3, 4]] print(res) # Should return [[1, 2, 6], [1, 3, 5], [2, 3, 4]] ``` # Requirements 1. Use depth-first search (DFS) or backtracking to explore possible combinations. 2. Ensure that the solutions are returned in lexicographical order. 3. Avoid duplicate combinations by enforcing constraints on the range of numbers and their usage. 4. Write efficient code to handle the given constraints.","solution":"from typing import List def unique_combinations(k: int, n: int) -> List[List[int]]: def dfs(start, remaining, path, result): if remaining == 0 and len(path) == k: result.append(path[:]) return for i in range(start, 10): if i > remaining: # early termination break path.append(i) dfs(i + 1, remaining - i, path, result) path.pop() result = [] dfs(1, n, [], result) return result"},{"question":"# Product of Array Except Self You are given an array of integers. Your task is to construct a new array where each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`. Implement this in such a way that it runs in O(n) time and uses O(1) additional space. --- # Function Specification **Function Name**: `product_except_self` **Input**: - One list of integers, `nums` with length n (1 <= n <= 10^5). **Output**: - List of integers where each element is the product of all elements in the input list except the one at the corresponding index. # Example ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] ``` # Constraints - Do not use division in your solution. - The algorithm should have a time complexity of O(n). - The solution should use O(1) additional space, not counting the space needed for the output array. # Performance Requirements - Ensure that your solution handles large inputs efficiently. - Utilize a single pass approach (or minimal passes) for optimal performance. --- # Implementation Task Write a function `product_except_self(nums: List[int]) -> List[int]` that adheres to the specifications and passes all the given test cases. The solution should avoid division and focus on achieving the specified time and space complexities.","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element at index `i` is the product of all elements in the list except the one at `i`. length = len(nums) # Step 1: Create an output array initialized to 1 output = [1] * length # Step 2: Calculate left cumulative product for each index left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Step 3: Calculate right cumulative product for each index and multiply with the left product right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"# Coding Exercise: Find the Start of the Cycle in a Linked List Context In some linked list problems, a cycle (loop) might be present, creating various challenges for processing. A cycle means that some node in the list points back to a previous node instead of pointing to `None`, causing an infinite loop during traversal. One of the critical tasks in such cases is to identify the node where the cycle begins. Problem Write a function `detect_cycle_start(head: Optional[ListNode]) -> Optional[ListNode]` that determines the node where the cycle begins in a linked list. If there is no cycle, return `None`. Input & Output Format * **Input**: A singly linked list represented by the head node (`head`). Each node in the linked list is of type `ListNode` with two attributes: `val` (an integer) and `next` (a reference to the next node or `None`). * **Output**: The node where the cycle begins, or `None` if there is no cycle. Constraints * The function should have a time complexity of O(n) and a space complexity of O(1). Examples ```python class ListNode: def __init__(self, val: int = 0, next: Optional[ListNode] = None): self.val = val self.next = next # Example 1: Cycle begins at node with value 2 # Input: head = [3, 2, 0, -4], pos = 1 (position of the cycle start in the provided linked list) # Output: The node with value 2 # Example 2: No cycle # Input: head = [1, 2], pos = -1 (no cycle in the linked list) # Output: None # Example 3: Cycle begins at node with value 1 # Input: head = [1], pos = 0 (single node with cycle to itself) # Output: The node with value 1 ``` Additional Instructions 1. You are expected to use Floyd\'s Tortoise and Hare algorithm or a similar method to detect the cycle. 2. Make sure to handle edge cases such as an empty list and a list with a single node. 3. The ListNode class may have additional attributes or methods as needed but maintain the primary `val` and `next` structure.","solution":"class ListNode: def __init__(self, val: int = 0, next: \'Optional[ListNode]\' = None): self.val = val self.next = next def detect_cycle_start(head: \'Optional[ListNode]\') -> \'Optional[ListNode]\': if not head or not head.next: return None slow = head fast = head # Phase 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Phase 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Problem Statement You are assigned the task of simulating the spread of a disease in a population over `d` days, given initial conditions. The population is modeled as a grid where each cell can be either infected or healthy. Each day, the disease spreads to adjacent cells (up, down, left, right) from any infected cell. Implement a function that predicts the state of the population after `d` days. # Objective Write a function `simulate_disease_spread(grid: list, days: int) -> list` that returns the grid state after `d` days. # Input * **`grid`**: A 2D list representing the initial state of the population, where `grid[r][c]` is either `0` (healthy) or `1` (infected). The list is guaranteed to be rectangular and non-empty. * **`days`**: An integer (0 leq days leq 10^3) representing the number of days to simulate. # Output The function should return a 2D list representing the state of the population after `d` days. # Example 1 ```python grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 0] ] days = 1 output = simulate_disease_spread(grid, days) print(output) # Expected output: [[1, 1, 1], [0, 1, 0], [0, 0, 0]] ``` # Example 2 ```python grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] days = 2 output = simulate_disease_spread(grid, days) print(output) # Expected output: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] ``` # Constraints * **Grid Size**: (1 leq text{len(grid)}, text{len(grid[0])} leq 100) * **Cell Values**: Each cell in `grid` is either `0` or `1`. # Notes * You may want to use a breadth-first search (BFS) to simulate the daily spread of the disease efficiently. * Ensure that the state transition is handled correctly for each day until the specified number of days is reached. * Consider edge cases, such as when no cells are initially infected or when `days` is zero.","solution":"def simulate_disease_spread(grid, days): Returns the state of the population grid after a given number of days, where the disease spreads to adjacent cells from any infected cell. rows = len(grid) cols = len(grid[0]) def is_valid(r, c): return 0 <= r < rows and 0 <= c < cols directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for _ in range(days): # Copy the grid to avoid modifications during iteration new_grid = [row[:] for row in grid] for r in range(rows): for c in range(cols): if grid[r][c] == 1: for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and grid[nr][nc] == 0: new_grid[nr][nc] = 1 grid = new_grid return grid"},{"question":"Scenario: You are tasked with designing a simple File System Manager that allows users to create, read, and list files in a virtual directory structure. # Task: Implement a File System Manager class that enables file creation, content retrieval, and listing of files within a predefined directory structure. # Requirements: 1. **Initialization**: Initialize the file system manager with a given root directory. 2. **Methods**: * `create_file(path, content)`: Create a new file at the specified path with the provided content. * `read_file(path)`: Retrieve the content of the file located at the specified path. * `list_files(directory)`: List all files and directories within the specified directory. 3. **Constraints**: * Paths and filenames are strings, and directory separators are forward slashes (`/`). * Ensure proper handling of nested directories. * Validate paths to ensure they follow the virtual directory structure. * Handle edge cases, such as reading from non-existent files or creating files in non-existent directories. # Input Format: - Initialization parameters: * `root_directory`: The root directory path as a string. - For `create_file` method: * `path`: The full path (including filename) where the file should be created. * `content`: The content of the file as a string. - For `read_file` method: * `path`: The full path of the file to read. - For `list_files` method: * `directory`: The directory path to list files and directories from. # Output Format: - `create_file`: No return value. - `read_file`: String content of the file. - `list_files`: List of file and directory names within the specified directory as strings. # Example: ```python # Initializing the file system manager with root directory \\"/\\" fs_manager = FileSystemManager(\\"/\\") # Creating files fs_manager.create_file(\\"/dir1/file1.txt\\", \\"Hello, world!\\") fs_manager.create_file(\\"/dir1/dir2/file2.txt\\", \\"Nested file content\\") # Reading files print(fs_manager.read_file(\\"/dir1/file1.txt\\")) # Expected output: \\"Hello, world!\\" print(fs_manager.read_file(\\"/dir1/dir2/file2.txt\\")) # Expected output: \\"Nested file content\\" # Listing files print(fs_manager.list_files(\\"/\\")) # Expected output: [\\"dir1\\"] print(fs_manager.list_files(\\"/dir1\\")) # Expected output: [\\"file1.txt\\", \\"dir2\\"] ``` Implement the `FileSystemManager` class in Python with the above specifications.","solution":"import os class FileSystemManager: def __init__(self, root_directory): # Ensure the root directory path is an absolute path self.root = os.path.abspath(root_directory) if not os.path.exists(self.root): os.makedirs(self.root) def create_file(self, path, content): full_path = os.path.join(self.root, path.lstrip(\'/\')) # Ensure the directories exist file_directory = os.path.dirname(full_path) if not os.path.exists(file_directory): os.makedirs(file_directory) with open(full_path, \'w\') as f: f.write(content) def read_file(self, path): full_path = os.path.join(self.root, path.lstrip(\'/\')) if not os.path.exists(full_path): raise FileNotFoundError(f\\"No such file: \'{path}\'\\") with open(full_path, \'r\') as f: return f.read() def list_files(self, directory): full_directory = os.path.join(self.root, directory.lstrip(\'/\')) if not os.path.exists(full_directory): raise FileNotFoundError(f\\"No such directory: \'{directory}\'\\") return os.listdir(full_directory)"},{"question":"# CSV Data Summarization You are tasked with writing a utility that processes CSV (Comma-Separated Values) files to produce a summary. The summary should include the count of rows, the number of columns, the column headers, and some basic statistics for numerical columns. Implement the following two functions: 1. **summarize_csv**: This function reads a CSV file and provides a summary including the count of rows, the number of columns, and the column headers. * **Input**: A string representing the file path of the CSV file. * **Output**: A dictionary containing: - \\"row_count\\": The number of rows in the CSV file (int). - \\"column_count\\": The number of columns in the CSV file (int). - \\"columns\\": A list of column headers (list of str). * **Constraints**: - Handle any errors related to file access or reading. - Assume the first row of the CSV contains the headers. 2. **numerical_statistics**: This function computes basic statistics (mean, minimum, maximum) for numerical columns in the CSV file. * **Input**: A string representing the file path of the CSV file. * **Output**: A dictionary where keys are column headers and values are another dictionary with \\"mean\\", \\"min\\", and \\"max\\" statistics. * **Constraints**: - Handle cases where columns might not be numerical. - Properly handle empty CSV files or columns with non-numeric values. - Use the appropriate numeric type to calculate summary statistics. # Example ```python import csv import os def summarize_csv(file_path): try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.reader(file) headers = next(reader) row_count = sum(1 for row in reader) column_count = len(headers) return { \\"row_count\\": row_count, \\"column_count\\": column_count, \\"columns\\": headers } except Exception as e: print(f\\"Error: {e}\\") return None def numerical_statistics(file_path): try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) stats = {} numeric_columns = {header: [] for header in reader.fieldnames if reader.fieldnames} for row in reader: for col, value in row.items(): if col in numeric_columns: try: numeric_columns[col].append(float(value)) except ValueError: numeric_columns[col].append(None) for col, values in numeric_columns.items(): numeric_values = [v for v in values if v is not None] if numeric_values: stats[col] = { \\"mean\\": sum(numeric_values) / len(numeric_values), \\"min\\": min(numeric_values), \\"max\\": max(numeric_values) } return stats except Exception as e: print(f\\"Error: {e}\\") return None # Example usage if __name__ == \\"__main__\\": csv_summary = summarize_csv(\\"sample.csv\\") stats = numerical_statistics(\\"sample.csv\\") print(csv_summary) print(stats) ``` # Notes - Ensure robust error handling and consider edge cases such as missing files or empty datasets. - Test the functions with various CSV files to verify correctness. - Focus on performance for large files, avoiding unnecessary memory usage or computations.","solution":"import csv import os def summarize_csv(file_path): Summarizes the CSV file. Args: - file_path (str): The file path of the CSV file. Returns: - dict: A dictionary containing row_count, column_count, and columns. try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.reader(file) headers = next(reader) row_count = sum(1 for row in reader) column_count = len(headers) return { \\"row_count\\": row_count, \\"column_count\\": column_count, \\"columns\\": headers } except Exception as e: print(f\\"Error: {e}\\") return None def numerical_statistics(file_path): Computes basic statistics (mean, min, max) for numerical columns in CSV. Args: - file_path (str): The file path of the CSV file. Returns: - dict: A dictionary with column headers as keys and another dictionary with \\"mean\\", \\"min\\", and \\"max\\". try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file) if not reader.fieldnames: return {} stats = {} numeric_columns = {header: [] for header in reader.fieldnames} for row in reader: for col, value in row.items(): try: numeric_columns[col].append(float(value)) except ValueError: numeric_columns[col].append(None) for col, values in numeric_columns.items(): numeric_values = [v for v in values if v is not None] if numeric_values: stats[col] = { \\"mean\\": sum(numeric_values) / len(numeric_values), \\"min\\": min(numeric_values), \\"max\\": max(numeric_values) } return stats except Exception as e: print(f\\"Error: {e}\\") return None"},{"question":"# Coding Assessment Question **Title**: Longest Increasing Subsequence **Problem Statement**: Given an array of integers, write a function `longest_increasing_subsequence(nums: list[int]) -> int` that calculates the length of the longest increasing subsequence in the array. **Input**: - A list of integers `nums` that contains at least one integer. **Output**: - An integer representing the length of the longest increasing subsequence. **Constraints**: - The length of `nums` will not exceed 1000. - The elements of `nums` will be between -10,000 and 10,000. **Performance Requirements**: - The solution should work efficiently for input close to the constraint limits. **Examples**: ```python nums1 = [10, 9, 2, 5, 3, 7, 101, 18] print(longest_increasing_subsequence(nums1)) # Expected output: 4 (subsequence: [2, 3, 7, 18]) nums2 = [0, 1, 0, 3, 2, 3] print(longest_increasing_subsequence(nums2)) # Expected output: 4 (subsequence: [0, 1, 2, 3]) nums3 = [7, 7, 7, 7, 7, 7, 7] print(longest_increasing_subsequence(nums3)) # Expected output: 1 (subsequence: [7]) ``` **Scenario**: Imagine you are designing a recommendation system where you need to identify trends in user ratings over time. To analyze the changes, you need to compute the longest sequence of continually increasing ratings. Implement the `longest_increasing_subsequence` function to help in this task. **Additional Notes**: - Consider using dynamic programming to achieve a solution with a time complexity of ( O(n^2) ) or better, using patience sorting which can achieve ( O(n log n) ). - Ensure that your solution handles arrays with duplicate values effectively.","solution":"def longest_increasing_subsequence(nums): Finds the length of the longest increasing subsequence in the given list of integers. Parameters: nums (list[int]): A list of integers Returns: int: Length of the longest increasing subsequence if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question: Reversing a Doubly Linked List in-place Given a doubly linked list, implement a function to reverse the list in-place. The function should modify the list such that its nodes are in the opposite order. Ensure that your solution handles edge cases such as an empty list or a list with a single node. **Function Signature:** ```python class ListNode: def __init__(self, value=0, next=None, prev=None): self.value = value self.next = next self.prev = prev def reverse_doubly_linked_list(head: ListNode) -> ListNode: pass ``` **Input:** * `head`: The head node of a doubly linked list. **Output:** * Return the new head node of the reversed doubly linked list. **Constraints:** * Do not use any additional data structures. * The solution should modify the list in-place. **Examples:** ```python # Example 1: # Original List: 1 <-> 2 <-> 3 <-> 4 # Reversed List: 4 <-> 3 <-> 2 <-> 1 node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 node3.next = node4 node4.prev = node3 new_head = reverse_doubly_linked_list(node1) # The new_head should be node4, and traversing the list from new_head should give 4 <-> 3 <-> 2 <-> 1 # Example 2: # Original List: (empty list) # Reversed List: (empty list) new_head = reverse_doubly_linked_list(None) # The new_head should be None # Example 3: # Original List: 1 # Reversed List: 1 single_node = ListNode(1) new_head = reverse_doubly_linked_list(single_node) # The new_head should still be single_node ```","solution":"class ListNode: def __init__(self, value=0, next=None, prev=None): self.value = value self.next = next self.prev = prev def reverse_doubly_linked_list(head: ListNode) -> ListNode: Reverses a doubly linked list in place and returns the new head of the list. if not head: return None current = head new_head = None while current: # Swap the next and prev pointers temp = current.next current.next = current.prev current.prev = temp # Update the new_head to the current node new_head = current # Move to the next node in the original list current = temp return new_head"},{"question":"# Fibonacci Sequence Generator with Memory Efficiency The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes as: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on. Your task is to write a function `nth_fibonacci` that efficiently calculates the nth Fibonacci number, where n is provided as an input. Aim for a solution that uses constant space, i.e., O(1) space complexity. # Function Signature ```python def nth_fibonacci(n: int) -> int: ``` # Parameters - `n (int)`: The position in the Fibonacci sequence (1-indexed). # Returns - `int`: The nth Fibonacci number. # Constraints - ( 1 leq n leq 10^7 ) # Examples ```python >>> nth_fibonacci(1) 0 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(10) 34 >>> nth_fibonacci(50) 7778742049 ``` # Hints 1. Iterative methods are more memory efficient compared to recursive methods with memoization. 2. Consider using variables to keep track of just the last two Fibonacci numbers as you iterate up to n. Write your implementation of the function `nth_fibonacci`, ensuring it handles the given examples and edge cases efficiently.","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number (1-indexed). Args: n (int): The position in the Fibonacci sequence (1-indexed). Returns: int: The nth Fibonacci number. if n == 1: return 0 elif n == 2: return 1 prev, curr = 0, 1 for _ in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Find Missing Number in a Sequence You are given an array of integers representing a sequence of consecutive numbers with one missing element. Your task is to identify and return the missing number in the sequence. Task: Implement the function `find_missing_number(sequence)` that takes in an array `sequence` of length `n` (where `n >= 1`) containing a sequence of consecutive integers starting from an integer `a` with one integer missing. The sequence does not contain any duplicate numbers. Function Signature: ```python def find_missing_number(sequence: List[int]) -> int: pass ``` Constraints: * The array `sequence` will contain integers such that `sequence` is of length `n` and each integer in the array is unique. * The array will always contain integers from a sequence of consecutive numbers with exactly one missing. * The length of `sequence` is guaranteed to be at least 1 and no larger than `1000`. Examples: 1. `find_missing_number([1, 2, 4, 5]) -> 3` 2. `find_missing_number([3, 4, 5, 7]) -> 6` 3. `find_missing_number([10, 11, 13, 14, 15]) -> 12` 4. `find_missing_number([101, 102, 103, 104, 106]) -> 105` # Requirements: * Implement the `find_missing_number` function that correctly identifies the missing integer element in the given sequence. * The implementation should be efficient and work within the constraints provided. * Do not use external libraries; use basic operations and constructs available in the language.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Given a list of consecutive numbers with one missing number, this function returns the missing number. n = len(sequence) + 1 total_sum = sum(range(min(sequence), min(sequence) + n)) actual_sum = sum(sequence) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Scenario You are required to implement a function that calculates the product of all elements in a list except the element at the current index, without using division. Optimize the function for a time complexity of O(n) and a space complexity of O(n). # Requirements **Function Signature**: ```python def product_except_self(nums: list[int]) -> list[int]: pass ``` # Input & Output Formats * **Input**: A list `nums` containing `n` integers where `n >= 2`. * **Output**: A new list `result` of size `n`, where `result[i]` contains the product of all elements in `nums` except `nums[i]`. # Constraints * Do not use the division operation. * The input list will always have at least 2 integers and at most 10,000 integers. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) # Example ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] ```","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Fill the result array for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Question You are given a list of words and a pattern string. Each letter in the pattern corresponds to a unique transformation into the letters of a word in the given list. Determine all the words that follow the same letter transformation pattern as the pattern string. Task Write a function named `find_and_replace_pattern(words: List[str], pattern: str) -> List[str]` that returns a list of words that match the given transformation pattern. Input - `words` (List[str]): A list of words (strings) containing between 1 and 50 words, where each word has a length between 1 and 20. - `pattern` (str): A string representing the pattern to compare words against, having the same constraints (length between 1 and 20). Output - (List[str]): A list of words from the input `words` that match the transformation pattern of `pattern`. Constraints - All words in the input list and the given pattern will consist only of lowercase English letters (\'a\' to \'z\'). # Example ```python words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" ``` The function call `find_and_replace_pattern(words, pattern)` should return `[\\"mee\\", \\"aqq\\"]`. # Explanation - For \\"mee\\", \'m\' -> \'a\', \'e\' -> \'b\', and \'e\' -> \'b\', which matches the pattern \\"abb\\". - For \\"aqq\\", \'a\' -> \'a\', \'q\' -> \'b\', and \'q\' -> \'b\', which also matches the pattern \\"abb\\". - Other words do not match the pattern.","solution":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: def matches(word: str, pattern: str) -> bool: if len(word) != len(pattern): return False char_to_pattern = {} pattern_to_char = {} for w_char, p_char in zip(word, pattern): if w_char in char_to_pattern and char_to_pattern[w_char] != p_char: return False if p_char in pattern_to_char and pattern_to_char[p_char] != w_char: return False char_to_pattern[w_char] = p_char pattern_to_char[p_char] = w_char return True return [word for word in words if matches(word, pattern)]"},{"question":"# Coding Assessment Question Problem Statement You are tasked with writing a function to determine the next lexicographical permutation of an input integer array, if possible. If the array is already at its highest possible permutation, it should rearrange it to the lowest permutation (i.e., sorted in ascending order). Function Requirements: Write a function `next_permutation(arr: List[int]) -> List[int]` that takes a list of integers `arr` and returns the next lexicographical permutation of the list. Parameters: - `arr` (List[int]): A list of integers representing the permutation. The length of the list can be between 1 and 10^5, inclusive. Return: - A list of integers representing the next lexicographical permutation of the input list. Constraints: - Your solution must be efficient to handle the list length up to 10^5. Examples: ```python >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1]) [1] ``` # Additional Context: You can assume valid input as per the constraints. Note: - Be sure to return a new list rather than modifying the input list in-place. - The function should return the smallest permutation if the input list is already at its highest permutation.","solution":"from typing import List def next_permutation(arr: List[int]) -> List[int]: This function computes the next lexicographical permutation of the provided list of integers. If the array is already at its highest permutation, it rearranges it to the lowest permutation. # Find the largest index k such that arr[k] < arr[k + 1]. If no such index exists, the permutation is the last permutation. k = len(arr) - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # If no such index found, reverse the array to obtain the lowest permutation. return arr[::-1] # Find the largest index l greater than k such that arr[k] < arr[l]. l = len(arr) - 1 while arr[k] >= arr[l]: l -= 1 # Swap the value of arr[k] with that of arr[l]. arr[k], arr[l] = arr[l], arr[k] # Reverse the sequence from arr[k + 1] up to the last element. arr = arr[:k + 1] + arr[k + 1:][::-1] return arr"},{"question":"# Problem Statement Given a string representing a paragraph of text, your task is to identify the most frequently occurring word in the paragraph. In case of a tie, return the word that appears first in the paragraph among the tied words. Words are separated by spaces and may contain punctuation marks which should be ignored while counting. Consider words to be case insensitive. # Function Signature ```python def most_frequent_word(paragraph: str) -> str: Returns the most frequently occurring word in the paragraph. In case of a tie, returns the word that appears first among the tied words. Parameters: ----------- paragraph: str A string representing a paragraph of text. Returns: -------- str: The most frequently occurring word in the paragraph. ``` # Input * A string representing a paragraph of text of length ( 1 leq text{len(paragraph)} leq 10^4 ). # Output * A single string representing the most frequently occurring word in the paragraph. # Constraints * Words are separated by spaces and may include punctuation marks. * The evaluation of words should be case insensitive. * You may assume that the paragraph contains at least one word. # Examples ```python assert most_frequent_word(\\"Hello, world! Hello, everyone. Hello world!\\") == \\"hello\\" assert most_frequent_word(\\"This is a test. This test is only a test.\\") == \\"test\\" assert most_frequent_word(\\"To be or not to be, that is the question.\\") == \\"to\\" assert most_frequent_word(\\"Data science is fun. Data is powerful.\\") == \\"data\\" assert most_frequent_word(\\"A quick brown fox jumps over the lazy dog.\\") == \\"a\\" ``` # Notes * Ignore punctuation marks and consider words to be case insensitive. * Ensure the function is efficient and handles edge cases effectively. * Consider how you will handle ties in the frequency of words. # Additional Considerations * You might benefit from using regular expressions to handle punctuation removal. * Think about maintaining the order of words to resolve ties accurately.","solution":"import re from collections import defaultdict def most_frequent_word(paragraph: str) -> str: Returns the most frequently occurring word in the paragraph. In case of a tie, returns the word that appears first among the tied words. Parameters: ----------- paragraph: str A string representing a paragraph of text. Returns: -------- str: The most frequently occurring word in the paragraph. # Remove punctuation and convert to lowercase paragraph_cleaned = re.sub(r\'[^ws]\', \'\', paragraph).lower() words = paragraph_cleaned.split() # Dictionary to store the frequency of each word word_count = defaultdict(int) # Dictionary to remember the first occurrence index of each word word_first_occurrence = {} for idx, word in enumerate(words): word_count[word] += 1 if word not in word_first_occurrence: word_first_occurrence[word] = idx # Find the word with the highest frequency max_frequency = 0 most_frequent = \'\' for word, count in word_count.items(): if count > max_frequency or (count == max_frequency and word_first_occurrence[word] < word_first_occurrence[most_frequent]): max_frequency = count most_frequent = word return most_frequent"},{"question":"# Context In the context of creating an efficient file handling system, one common task involves processing and transforming data from different files. You need to implement a function that reads data from a file, processes it accordingly, and writes the processed data to another file. This will especially be useful in scenarios where data needs to be sanitized or converted before further use. # Task Implement the function `process_file` that reads lines from an input file, reverses the content of each line, converts it to uppercase, and writes the processed lines to an output file. Function Signature ```python def process_file(input_file: str, output_file: str) -> None: pass ``` Input - `input_file` (str): the path to the input file containing text data. - `output_file` (str): the path to the output file where the processed data will be written. Output - None. (The function should perform its operations and directly write to the output file). # Requirements - The function must read the input file line by line. - Each line of the input file should be reversed and converted to uppercase before writing it to the output file. - The output file must have the same number of lines as the input file. # Example Given an input file, `input.txt`, with the following content: ``` Hello World Python Coding File Handling ``` After running the function `process_file(\'input.txt\', \'output.txt\')`, the `output.txt` should contain: ``` DLROW OLLEH GNIDOC NOHTYP GNILDNAH ELIF ``` # Hints - Use file handling (`open`, `readlines`, `writelines`) in Python to implement the function. - Loop through the lines of the input file, process each line, and write to the output file. - Ensure to handle file opening and closing properly (use context managers for better practice).","solution":"def process_file(input_file: str, output_file: str) -> None: Reads lines from an input file, reverses the content of each line, converts it to uppercase, and writes the processed lines to an output file. with open(input_file, \'r\') as infile: lines = infile.readlines() processed_lines = [line.strip()[::-1].upper() + \'n\' for line in lines] with open(output_file, \'w\') as outfile: outfile.writelines(processed_lines)"},{"question":"# Binary Search Tree Operations You are given the task of enhancing a Binary Search Tree (BST) implementation in Python. The current implementation includes basic functionalities such as insertion, search, and in-order traversal. Your task is to add the following additional features: 1. **Delete Node (`delete_node`)**: Implement a method to delete a node with a given value from the BST. 2. **Find Kth Smallest Element (`find_kth_smallest`)**: Implement a method to find the k-th smallest element in the BST. 3. **Find Depth (`find_depth`)**: Implement a method to find the depth of the tree. Constraints * Ensure that the deletion operation maintains the properties of the BST. * Handle edge cases appropriately, such as deleting a node that does not exist. * The depth of the tree must be calculated based on the longest path from the root to any leaf node. Function Signatures ```python class BSTNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): # Implement insert here def search(self, key): # Implement search here def in_order_traversal(self): # Implement in-order traversal here def delete_node(self, key): # Implement delete_node here def find_kth_smallest(self, k): # Implement find_kth_smallest here def find_depth(self): # Implement find_depth here ``` Example Usage ```python # Example usage bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) bst.insert(4) print(bst.find_kth_smallest(2)) # Output: 3 print(bst.find_depth()) # Output: 2 bst.delete_node(3) print(bst.in_order_traversal()) # Output: [1, 4, 5, 7] ```","solution":"class BSTNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = BSTNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.val: if node.left is None: node.left = BSTNode(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = BSTNode(key) else: self._insert_rec(node.right, key) def search(self, key): return self._search_rec(self.root, key) def _search_rec(self, node, key): if node is None or node.val == key: return node if key < node.val: return self._search_rec(node.left, key) return self._search_rec(node.right, key) def in_order_traversal(self): result = [] self._in_order_rec(self.root, result) return result def _in_order_rec(self, node, result): if node is not None: self._in_order_rec(node.left, result) result.append(node.val) self._in_order_rec(node.right, result) def delete_node(self, key): self.root = self._delete_rec(self.root, key) def _delete_rec(self, node, key): if node is None: return node if key < node.val: node.left = self._delete_rec(node.left, key) elif key > node.val: node.right = self._delete_rec(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._min_value_node(node.right) node.val = min_larger_node.val node.right = self._delete_rec(node.right, min_larger_node.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find_kth_smallest(self, k): stack = [] current = self.root while True: while current is not None: stack.append(current) current = current.left current = stack.pop() k -= 1 if k == 0: return current.val current = current.right def find_depth(self): return self._find_depth_rec(self.root) def _find_depth_rec(self, node): if node is None: return -1 left_depth = self._find_depth_rec(node.left) right_depth = self._find_depth_rec(node.right) return max(left_depth, right_depth) + 1"},{"question":"# List Element Frequencies You have been given a list of integers. Your task is to implement a function that returns a dictionary where each key is an element from the list and the corresponding value is the frequency of that element in the list. **Function Signature**: ```python def element_frequencies(arr: list) -> dict: pass ``` **Input**: * `arr`: A list of integers. **Output**: * A dictionary with integer keys and their frequencies as values. **Constraints**: * The length of the list (len(arr)) is between (0) and (10^6). * The elements in the list are integers that can range from (-10^9) to (10^9). # Example: ```python >>> element_frequencies([1, 2, 2, 3, 3, 3, -1, -1]) {1: 1, 2: 2, 3: 3, -1: 2} >>> element_frequencies([4, 4, 4, 4]) {4: 4} >>> element_frequencies([]) {} ``` # Requirements: - Ensure the function efficiently computes the frequencies, even for large input sizes. - The implementation should handle large and negative integer values correctly. - Utilize Python\'s built-in data structures effectively to achieve the desired functionality. # Hints: - Consider using a dictionary or collections.Counter to store and count the frequencies of elements. - Loop through the list, updating the frequency count for each element encountered.","solution":"def element_frequencies(arr: list) -> dict: Returns a dictionary where each key is an element from the list `arr` and the corresponding value is the frequency of that element in the list. frequency_dict = {} for num in arr: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 return frequency_dict"},{"question":"# Array Rotation Checker **Scenario**: You are given an array of distinct integers that has been rotated at some unknown pivot. A rotation means taking some part of the array and moving it to the beginning while shifting the rest to the right. Your task is to determine if the array is a rotated version of a sorted array. This function can be crucial in optimizing search algorithms, particularly with modified or corrupted datasets. **Task**: Implement a function `is_rotated_sorted_array` that checks if the given array is a rotated version of a sorted array. **Specifications**: * You will write a function `is_rotated_sorted_array(arr: List[int]) -> bool`. * `arr`: A list of distinct integers. **Constraints**: * The list will contain integers only. * The length of `arr` will be in the range `[1, 10^5]`. **Expected Output**: * Return `True` if `arr` is a rotated version of a sorted array. * Return `False` otherwise. **Examples**: ```python # Example 1: Rotated sorted array rotated_array = [4, 5, 6, 1, 2, 3] print(is_rotated_sorted_array(rotated_array)) # Expected: True # Example 2: Not a rotated sorted array not_rotated_array = [1, 3, 2, 4, 5] print(is_rotated_sorted_array(not_rotated_array)) # Expected: False # Example 3: Single element array single_element_array = [10] print(is_rotated_sorted_array(single_element_array)) # Expected: True # Example 4: Fully sorted array fully_sorted_array = [1, 2, 3, 4, 5] print(is_rotated_sorted_array(fully_sorted_array)) # Expected: True ``` Implement the `is_rotated_sorted_array` function to meet these requirements.","solution":"from typing import List def is_rotated_sorted_array(arr: List[int]) -> bool: Checks if the given array is a rotated version of a sorted array. # An empty array or single element array is trivially a rotated sorted array if len(arr) <= 1: return True # Check the number of \\"drops\\" in the array (i.e., where arr[i-1] > arr[i]) drops = 0 for i in range(1, len(arr)): if arr[i - 1] > arr[i]: drops += 1 # More than one drop indicates it\'s not a rotated sorted array if drops > 1: return False # Check for the drop across the boundary (from last element to first element) if drops == 1 and arr[-1] > arr[0]: return False return True"},{"question":"# Context You are developing a system that processes customer orders and needs to keep track of the quantities of each item being ordered. To ensure that your inventory management is accurate, you need to implement a function that helps to update and maintain the inventory levels based on incoming orders. # Problem Statement Implement a function `update_inventory(inventory: dict[str, int], orders: list[tuple[str, int]]) -> dict[str, int]` that takes in a dictionary representing the current inventory levels and a list of orders where each order is a tuple containing an item name and the quantity ordered. The function should return the updated inventory levels after processing all orders. # Input - `inventory`: A dictionary where keys are item names (strings) and values are integers representing the current quantity of each item in stock. - `orders`: A list of tuples where each tuple contains an item name (string) and the quantity ordered (integer). # Output - A dictionary representing the updated inventory levels post-processing of all orders. # Constraints 1. The item names in the orders list will be valid and will exist in the inventory dictionary. 2. Inventory quantities and order quantities will be non-negative integers. 3. If an order quantity is greater than the available inventory, the item quantity should be set to 0 (indicating the item is out of stock). # Examples ```python >>> inventory = {\'apple\': 10, \'banana\': 5, \'orange\': 8} >>> orders = [(\'apple\', 3), (\'banana\', 6), (\'orange\', 2)] >>> update_inventory(inventory, orders) {\'apple\': 7, \'banana\': 0, \'orange\': 6} >>> inventory = {\'laptop\': 4, \'mouse\': 10} >>> orders = [(\'laptop\', 1), (\'mouse\', 5)] >>> update_inventory(inventory, orders) {\'laptop\': 3, \'mouse\': 5} >>> inventory = {\'book\': 0, \'pen\': 12} >>> orders = [(\'book\', 2), (\'pen\', 3)] >>> update_inventory(inventory, orders) {\'book\': 0, \'pen\': 9} >>> inventory = {\'phone\': 15} >>> orders = [(\'phone\', 20)] >>> update_inventory(inventory, orders) {\'phone\': 0} ``` # Notes - For the example with the inventory `{\'apple\': 10, \'banana\': 5, \'orange\': 8}` and orders `[(\'apple\', 3), (\'banana\', 6), (\'orange\', 2)]`, the updated inventory levels should be `{\'apple\': 7, \'banana\': 0, \'orange\': 6}`. - If the quantity ordered of any item exceeds the available inventory, set that item\'s quantity to 0. For example, ordering 6 bananas when the inventory has only 5 should result in `{\'banana\': 0}`. - The function should be efficient and handle large inventories and order lists effectively.","solution":"def update_inventory(inventory, orders): Updates the inventory levels based on incoming orders. Parameters: inventory (dict[str, int]): The current inventory levels. orders (list[tuple[str, int]]): List of orders where each order is a tuple (item_name, quantity_ordered). Returns: dict[str, int]: Updated inventory levels after processing all orders. for item, quantity in orders: if inventory[item] >= quantity: inventory[item] -= quantity else: inventory[item] = 0 return inventory"},{"question":"# Context You are engaged in designing a simplified file system simulation to perform basic directory and file manipulations based on a series of commands. # Description Implement a class `FileSystem` that allows creating directories and files, listing contents of a directory, and reading from files. The file system starts with a single root directory (`\\"/\\"`). # Class Signature ```python class FileSystem: def __init__(self): pass def mkdir(self, path: str) -> None: pass def add_content_to_file(self, file_path: str, content: str) -> None: pass def read_content_from_file(self, file_path: str) -> str: pass def ls(self, path: str) -> List[str]: pass ``` # Input - `mkdir(path: str)`: Creates a directory at the specified path. - `add_content_to_file(file_path: str, content: str)`: Appends content to the file at the specified path, creating the file if it does not exist. - `read_content_from_file(file_path: str)`: Reads the content from the file at the specified path. - `ls(path: str)`: Lists the contents of the directory at the specified path, sorted in lexicographical order. # Output - `mkdir(path)`: No return value. - `add_content_to_file(file_path, content)`: No return value. - `read_content_from_file(file_path)`: Returns the content of the specified file as a string. - `ls(path)`: Returns a list of names (files or directories) in lexicographical order. # Constraints - All paths are absolute, and start with `/`. - Path and directory names consist of alphanumeric characters and `/` only. - Commands are valid and always refer to existing directories unless creating a new one using `mkdir`. # Example ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.add_content_to_file(\\"/a/b/c/d\\", \\"hello\\") print(fs.read_content_from_file(\\"/a/b/c/d\\")) # Output: \\"hello\\" print(fs.ls(\\"/\\")) # Output: [\\"a\\"] print(fs.ls(\\"/a/b\\")) # Output: [\\"c\\"] ``` # Notes * Ensure that the output of the `ls` method returns the directory and file names in lexicographical order. * Handle nested directory and file creation properly as per the provided examples.","solution":"class FileSystem: def __init__(self): self.fs = {\\"\\": {}} def mkdir(self, path: str) -> None: dirs = path.split(\'/\') cur = self.fs[\\"\\"] for d in filter(bool, dirs): if d not in cur: cur[d] = {} cur = cur[d] def add_content_to_file(self, file_path: str, content: str) -> None: *dirs, file_name = file_path.split(\'/\') cur = self.fs[\\"\\"] for d in filter(bool, dirs): if d not in cur: cur[d] = {} cur = cur[d] if file_name not in cur: cur[file_name] = \\"\\" cur[file_name] += content def read_content_from_file(self, file_path: str) -> str: *dirs, file_name = file_path.split(\'/\') cur = self.fs[\\"\\"] for d in filter(bool, dirs): cur = cur[d] return cur[file_name] def ls(self, path: str) -> list: if path == \\"/\\": return sorted(self.fs[\\"\\"].keys()) parts = path.split(\'/\') cur = self.fs[\\"\\"] for part in filter(bool, parts): cur = cur[part] if isinstance(cur, str): return [parts[-1]] return sorted(cur.keys())"},{"question":"Red-Black Tree Implementation and Operations A Red-Black Tree is a self-balancing binary search tree where each node has an extra bit for denoting the color of the node, either red or black. Your task is to implement a Red-Black Tree (RBT) and perform basic operations such as insertion, deletion, and search efficiently. # Function Definitions Implement the following functions: 1. **`insert`**: Inserts a value into the Red-Black Tree. ```python def insert(root: Optional[\'Node\'], value: int) -> \'Node\': Inserts a value into the Red-Black Tree and returns the new root. :param root: The root node of the Red-Black Tree. :param value: The integer value to insert into the tree. :return: The new root node of the Red-Black Tree after insertion. pass ``` 2. **`delete`**: Deletes a value from the Red-Black Tree. ```python def delete(root: Optional[\'Node\'], value: int) -> \'Node\': Deletes a value from the Red-Black Tree and returns the new root. :param root: The root node of the Red-Black Tree. :param value: The integer value to delete from the tree. :return: The new root node of the Red-Black Tree after deletion. pass ``` 3. **`search`**: Searches for a value in the Red-Black Tree. ```python def search(root: Optional[\'Node\'], value: int) -> Optional[\'Node\']: Searches for a value in the Red-Black Tree. :param root: The root node of the Red-Black Tree. :param value: The integer value to search for in the tree. :return: The node containing the value, or None if the value is not found. pass ``` # Red-Black Tree Properties 1. Each node is either red or black. 2. The root is always black. 3. All leaves (NIL nodes) are black. 4. If a node is red, then both its children are black (no two red nodes can be adjacent). 5. Every path from a given node to its descendant NIL nodes has the same number of black nodes. # Requirements 1. **Performance**: * Ensure the insertion, deletion, and search operations run in **O(log n)** time. 2. **Edge Cases**: * Handle cases where the tree is empty. * Handle cases with duplicate values. * Ensure that the tree remains balanced after every insertion and deletion. # Input and Output * **Input**: A series of insertions, deletions, and searches. * **Output**: The nodes of the tree after each operation and the results of search operations. # Example ```python # Example Red-Black Tree operations root = None # Insert values root = insert(root, 10) root = insert(root, 20) root = insert(root, 30) root = insert(root, 15) root = insert(root, 25) # Search values node = search(root, 15) print(node.value if node else \\"Not found\\") node = search(root, 40) print(node.value if node else \\"Not found\\") # Delete values root = delete(root, 20) # Verify tree structure and properties def inorder_traversal(node): if node: inorder_traversal(node.left) print(node.value, node.color, end=\' \') inorder_traversal(node.right) inorder_traversal(root) print() ``` *Expected Output*: ```python 15 Not found 10 Black 15 Black 25 Red 30 Black ```","solution":"class Node: def __init__(self, value, color, left=None, right=None, parent=None): self.value = value self.color = color self.left = left self.right = right self.parent = parent class RedBlackTree: def __init__(self): self.TNULL = Node(0, \'black\') self.root = self.TNULL def insert(self, key): node = Node(key, \'red\', left=self.TNULL, right=self.TNULL, parent=None) y = None x = self.root while x != self.TNULL: y = x if node.value < x.value: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.value < y.value: y.left = node else: y.right = node if node.parent == None: node.color = \'black\' return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == \'red\': if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \'red\': u.color = \'black\' k.parent.color = \'black\' k.parent.parent.color = \'red\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \'black\' k.parent.parent.color = \'red\' self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = \'black\' def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def search_tree(self, k, key): if k == self.TNULL or key == k.value: return k if key < k.value: return self.search_tree(k.left, key) return self.search_tree(k.right, key) def search(self, key): return self.search_tree(self.root, key) def balance_delete(self, x): while x != self.root and x.color == \'black\': if x == x.parent.left: s = x.parent.right if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.left_rotate(x.parent) s = x.parent.right if s.left.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.right.color == \'black\': s.left.color = \'black\' s.color = \'red\' self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \'black\' s.right.color = \'black\' self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \'red\': s.color = \'black\' x.parent.color = \'red\' self.right_rotate(x.parent) s = x.parent.left if s.left.color == \'black\' and s.right.color == \'black\': s.color = \'red\' x = x.parent else: if s.left.color == \'black\': s.right.color = \'black\' s.color = \'red\' self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \'black\' s.left.color = \'black\' self.right_rotate(x.parent) x = self.root x.color = \'black\' def __rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.value == key: z = node if node.value <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.__rb_transplant(z, z.right) elif (z.right == self.TNULL): x = z.left self.__rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.__rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.__rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \'black\': self.balance_delete(x) def delete_node(self, data): self.delete_node_helper(self.root, data) def minimum(self, node): while node.left != self.TNULL: node = node.left return node def inorder_helper(self, node): if node != self.TNULL: self.inorder_helper(node.left) print(node.value, node.color) self.inorder_helper(node.right) def inorder(self): self.inorder_helper(self.root) def insert(root, value): if root is None or root == tree.TNULL: root = value else: tree.insert(value) return tree.root def delete(root, value): tree.delete_node(value) return tree.root def search(root, value): node = tree.search(value) if node and node.value != 0: return node return None # Initialize RBT tree = RedBlackTree()"},{"question":"Binary Search on a Sorted Array Problem Statement Context You are implementing a function to perform a binary search on a sorted array. Binary search is an efficient algorithm for finding an item from a sorted list of items by repeatedly dividing the search interval in half. Function Signature ```python def binary_search(arr: list[int | float], target: int | float) -> int: ``` Input 1. `arr (list[int | float])`: A list of sorted integers or floating-point numbers, either in ascending or descending order. The list can be empty. 2. `target (int | float)`: The target value to search for within the list. Output * Returns the index of the target value in the sorted list if found. If the target is not found, return -1. Constraints * The implementation must handle both ascending and descending orders. * The function should work efficiently, with a time complexity of O(log n). * Handle edge cases such as empty input list or single-element list. Examples ```python >>> binary_search([1, 2, 3, 4, 5], 3) 2 >>> binary_search([5, 4, 3, 2, 1], 3) 2 >>> binary_search([1, 2, 3, 4, 5], 6) -1 >>> binary_search([], 3) -1 >>> binary_search([42], 42) 0 >>> binary_search([-10, -5, 0, 5, 10], -5) 1 ``` Additional Requirements: 1. Ensure the function can handle both integer and floating-point values appropriately. 2. Use the binary search algorithm to minimize the number of comparisons. # Solution ```python def binary_search(arr, target): if not arr: return -1 left, right = 0, len(arr) - 1 ascending = arr[left] < arr[right] while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif ascending: if target < arr[mid]: right = mid - 1 else: left = mid + 1 else: if target > arr[mid]: right = mid - 1 else: left = mid + 1 return -1 ```","solution":"def binary_search(arr, target): if not arr: return -1 left, right = 0, len(arr) - 1 ascending = arr[left] < arr[right] while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif ascending: if target < arr[mid]: right = mid - 1 else: left = mid + 1 else: if target > arr[mid]: right = mid - 1 else: left = mid + 1 return -1"},{"question":"# Task Write a function `find_first_non_repeating` that finds the first non-repeating character in a given string. # Input * The input is a single string `s` containing only lowercase Latin letters. # Output * The function should return the first non-repeating character in the string. If all characters are repeating, return an underscore (\\"_\\"). # Constraints * The input string may have a length ranging from 1 to 100,000 characters. * The function should have a time complexity of O(n) and a space complexity of O(1), utilizing a fixed-size array for character counts. # Function Signature ```python def find_first_non_repeating(s: str) -> str: # your implementation here ``` # Example Example Function Call 1 ```python find_first_non_repeating(\\"abracadabra\\") ``` Expected Output 1 ```python \'c\' ``` # Explanation In the string \\"abracadabra\\", the first non-repeating character is \'c\'. Example Function Call 2 ```python find_first_non_repeating(\\"aabbcc\\") ``` Expected Output 2 ```python \'_\' ``` # Explanation In the string \\"aabbcc\\", all characters repeat, so the function returns \'_\'. # Notes 1. Ensure to handle strings where no characters are non-repeating. 2. Optimize your solution to handle large strings efficiently.","solution":"def find_first_non_repeating(s: str) -> str: from collections import OrderedDict counts = OrderedDict() # First pass: count all characters for ch in s: if ch in counts: counts[ch] += 1 else: counts[ch] = 1 # Second pass: find the first non-repeating character for ch in counts: if counts[ch] == 1: return ch return \\"_\\""},{"question":"# Question: Implement Dijkstra\'s Shortest Path Algorithm with Priority Queue Optimization You are tasked with implementing Dijkstra\'s algorithm to find the shortest path from a given source node to all other nodes in a graph. Optimize your implementation using a priority queue for efficient extraction of the minimum distance node. # Requirements: 1. The graph is represented using an adjacency list. 2. Your implementation should handle cases where some nodes are not reachable from the source. 3. Include input validations to ensure the graph is valid and handle erroneous or unexpected inputs. # Function Signature: ```python from typing import Dict, Tuple, List def optimized_dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: pass ``` # Input: - **graph (Dict[int, List[Tuple[int, int]]]):** The graph represented as a dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple contains a neighboring node and the edge weight (integer). - **source (int):** The starting node for the shortest path algorithm. # Output: - Returns a dictionary where keys are node identifiers and values are the shortest distance from the source node to that node. Nodes that are not reachable should have a distance of `float(\'inf\')`. # Constraints: - All edge weights are non-negative integers. - The graph must contain at least one node. - Ensure that the source node exists in the graph. # Example Usage: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 shortest_paths = optimized_dijkstra(graph, source) print(shortest_paths) ``` # Expected Output: For the given `graph` and `source`, the output should be ``` {0: 0, 1: 3, 2: 1, 3: 4} ``` # Additional Test Cases: 1. `optimized_dijkstra({0: [(1, 10)], 1: [(2, 20)], 2: [(0, 30)]}, 0)` should yield `{0: 0, 1: 10, 2: 30}` 2. `optimized_dijkstra({0: [(1, 5)], 1: [(3, 10)], 2: [(3, 15)], 3: [(4, 5)], 4: []}, 0)` should yield `{0: 0, 1: 5, 2: inf, 3: 15, 4: 20}` 3. Invalid graph representation should raise appropriate exceptions. 4. Handling a disconnected graph with multiple components: `optimized_dijkstra({0: [(1, 6)], 1: [], 2: [(3, 4)], 3: [(0, 3)]}, 0)` should produce distances with infinite values for disconnected nodes.","solution":"import heapq from typing import Dict, List, Tuple def optimized_dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Returns the shortest path from the source node to all other nodes in the graph using Dijkstra\'s algorithm with priority queue optimization. if source not in graph: raise ValueError(\\"The source node must be in the graph.\\") # Initialize distances with infinity distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Priority queue to select the node with the smallest distance priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip processing if we\'ve found a shorter way to the current node if current_distance > distances[current_node]: continue # Check neighbours and update distances for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Anagram Verification - In-Depth Check Scenario An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. You are tasked with implementing a function that verifies whether two strings are anagrams of each other, considering specific constraints to handle different scenarios. Task Write a function `are_anagrams(str1: str, str2: str) -> bool` that: - Returns `True` if `str1` and `str2` are anagrams of each other. - Ignores case differences (case insensitive). - Ignores spaces and punctuation marks, considering only alphabetic characters. - Ensures linear time complexity O(n) for efficiency. Input Format - Two non-empty strings `str1` and `str2`. Output Format - Returns a boolean value indicating if the two input strings are anagrams of each other. Constraints - Both input strings will not be empty but may contain spaces and punctuation marks that should be ignored. - The function must be optimized for performance with a time complexity of O(n). Examples ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"conversation\\", \\"voices rant on\\") True >>> are_anagrams(\\"hello\\", \\"bye\\") False >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"a!b@c#1\\", \\"c1@b!a\\") True ``` Use this function signature and provide a solution that meets the criteria above.","solution":"import re from collections import Counter def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams, ignoring case, spaces, and punctuation. def preprocess(s: str) -> str: # Remove all non-alphabet characters and convert to lower case return \'\'.join(re.findall(r\'[a-z]+\', s.lower())) str1_processed = preprocess(str1) str2_processed = preprocess(str2) return Counter(str1_processed) == Counter(str2_processed)"},{"question":"**Implement a Thread-Safe Bounded Blocking Queue** Using the given concept of a bounded blocking queue, your task is to implement a thread-safe bounded blocking queue that supports the following: 1. **Class Definition & Initialization**: - Define `BoundedBlockingQueue` with a given capacity. - Include methods `enqueue`, `dequeue`, and `size`. 2. **Thread Safety Requirement**: - Ensure thread-safe operations for both enqueue and dequeue methods (consider using synchronization primitives such as locks, condition variables, or semaphores). - Protect against race conditions and maintain data consistency, especially under concurrent accesses. 3. **Input and Output Formats**: - **enqueue(element)**: Should add the element to the queue if there is space, otherwise block until space becomes available. - **dequeue()**: Should remove and return the front element from the queue if there are elements present, otherwise block until an element becomes available. - **size()**: Should return the current number of elements in the queue. 4. **Constraints**: - The queue capacity will range from 1 to 10^4. - All elements will be integers. - Ensure maximum concurrent threads: 1000. 5. **Concurrency Performance Requirement**: - Ensure that the queue operations perform efficiently even under high contention, utilizing appropriate synchronization techniques to avoid unnecessary performance bottlenecks. # Example ```python import threading class BoundedBlockingQueue: def __init__(self, capacity: int): # Initialization logic to set up the queue with given capacity pass def enqueue(self, element: int): # Logic to add the element to the queue, blocking if necessary pass def dequeue(self) -> int: # Logic to remove and return the front element, blocking if necessary pass def size(self) -> int: # Logic to return the current size of the queue pass # Example usage with multithreading queue = BoundedBlockingQueue(3) def producer(): for i in range(5): queue.enqueue(i) print(f\\"Produced {i}\\") def consumer(): for i in range(5): item = queue.dequeue() print(f\\"Consumed {item}\\") # Create threads for producing and consuming producer_thread = threading.Thread(target=producer) consumer_thread = threading.Thread(target=consumer) # Start threads producer_thread.start() consumer_thread.start() # Join threads to wait for completion producer_thread.join() consumer_thread.join() # Check the size of the queue print(queue.size()) # Expected output: The size should eventually be 0 after all operations ``` This question assesses the candidate’s ability to handle concurrency in programming, particularly dealing with synchronization and resource sharing among threads.","solution":"import threading class BoundedBlockingQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [] self.lock = threading.Lock() self.not_full = threading.Condition(self.lock) self.not_empty = threading.Condition(self.lock) def enqueue(self, element: int): with self.not_full: while len(self.queue) == self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: with self.lock: return len(self.queue)"},{"question":"# Question: You are developing a feature for a social networking platform that involves creating friend circles. A friend circle is a group of people who are all directly or indirectly friends. Given a list of friendships, your task is to determine the number of separate friend circles. # Function Signature ```python def count_friend_circles(friendships: List[List[int]]) -> int: pass ``` # Input * **friendships**: a list of lists, where each inner list contains exactly two integers `[a, b]` indicating that person `a` is friends with person `b`. Each person is represented by a unique integer. # Output * **Returns**: an integer representing the number of separate friend circles. # Constraints * 1 ≤ `number of people` ≤ 10^4 * Each person can have at most 1000 friends. * You can assume that the friendships are bidirectional; if `[a, b]` is present, implying `a` is friends with `b`, then `[b, a]` will not be present separately. * Optimize for large number of people and friendships. # Example ```python >>> count_friend_circles([[1, 2], [2, 3], [4, 5]]) 2 >>> count_friend_circles([[1, 2], [2, 3], [3, 4], [5, 6]]) 2 ``` # Explanation * In the first example, there are two separate friend circles: {1, 2, 3} and {4, 5}. * In the second example, there are two separate friend circles: {1, 2, 3, 4} and {5, 6}. # Notes * Use a graph traversal algorithm such as Depth First Search (DFS) or Breadth First Search (BFS) to identify connected components in the graph formed by friendships. * Ensure efficient handling of input size constraints to meet performance requirements.","solution":"from typing import List from collections import defaultdict, deque def count_friend_circles(friendships: List[List[int]]) -> int: def bfs(start, visited, adj_list): Helper function to perform BFS on the graph starting from \'start\' queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if not friendships: return 0 # Creating adjacency list adj_list = defaultdict(list) for a, b in friendships: adj_list[a].append(b) adj_list[b].append(a) visited = set() num_circles = 0 for person in adj_list: if person not in visited: visited.add(person) bfs(person, visited, adj_list) num_circles += 1 return num_circles"},{"question":"# Matrix Rotation: Image Transformation Context: As a software engineer working on an image processing application, you need to implement a function that rotates a given NxN matrix representing an image by 90 degrees clockwise. This transformation is commonly used in various applications, such as photo editing tools and computer vision systems. Problem: Write a method `rotate_matrix` that takes an NxN matrix (a list of lists) and rotates it by 90 degrees clockwise. Specifications: 1. **Function Signature:** ```python def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in-place. :param matrix: A list of lists representing the NxN matrix. ``` 2. **Input:** - `matrix`: A list of lists, where each internal list represents a row of the NxN matrix. 3. **Output:** - None, the function should modify the matrix in-place. 4. **Constraints:** - The matrix dimensions are guaranteed to be N x N, where 1 <= N <= 10. - The matrix contains integer values. Example Usage: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] another_matrix = [ [1, 2], [3, 4] ] rotate_matrix(another_matrix) print(another_matrix) # Output: # [ # [3, 1], # [4, 2] # ] ``` **Important:** - The function should rotate the matrix in place without using any extra matrix for the transformation. - Ensure the rotated matrix maintains the original values in their new positions correctly.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in-place. :param matrix: A list of lists representing the NxN matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are tasked with implementing a function to determine if a given undirected graph contains a cycle using Depth-First Search (DFS). The graph is represented as an adjacency list, and you should return `True` if there is a cycle, and `False` otherwise. # Function Signature ```python def has_cycle(num_vertices: int, edges: List[Tuple[int, int]]) -> bool: ``` # Input - `num_vertices` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples, each representing an edge in the graph, where the first and second elements are the vertices connected by the edge. # Output - Return a boolean value, `True` if there is at least one cycle in the graph, `False` otherwise. # Constraints - The number of vertices (1 leq num_vertices leq 10^4). - The number of edges (0 leq edges leq 2 times 10^4). - Vertices are indexed from 0. # Example ```python num_vertices = 5 edges = [ (0, 1), (1, 2), (2, 3), (3, 4), (1, 4) ] print(has_cycle(num_vertices, edges)) # Expected output: True num_vertices = 3 edges = [ (0, 1), (1, 2) ] print(has_cycle(num_vertices, edges)) # Expected output: False ``` # Requirements 1. Implement the function `has_cycle(num_vertices: int, edges: List[Tuple[int, int]]) -> bool` that detects cycles in an undirected graph using Depth-First Search (DFS). 2. Ensure the implementation handles large inputs efficiently. # Tips - Utilize a parent-check mechanism to avoid considering the immediate parent of a vertex as a back edge. - Use a recursive DFS approach with a visited set to detect back edges indicating a cycle.","solution":"from typing import List, Tuple def has_cycle(num_vertices: int, edges: List[Tuple[int, int]]) -> bool: def dfs(node, parent): visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor]: if dfs(neighbor, node): return True elif neighbor != parent: return True return False adj_list = [[] for _ in range(num_vertices)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * num_vertices for v in range(num_vertices): if not visited[v]: if dfs(v, -1): return True return False"},{"question":"# Subject: String Manipulation and Pattern Matching You are tasked with implementing a string manipulation algorithm that detects repeated patterns in a given string and returns the smallest repeating unit. For example, the string `abcabcabcabc` has the smallest repeating unit `abc`, which repeats 4 times. # Description A string can sometimes be composed of a smaller repeating substring. Write a function that identifies the smallest repeating unit of the given string. If no such unit exists (i.e., the string does not have a repeating pattern), the unit should be the string itself. # Implementation Functions 1. **`smallest_repeating_unit(s: str) -> str`**: - **Input**: A string ( s ) (where (1 leq text{len}(s) leq 10000)) - **Output**: Returns the smallest repeating unit of the string. # Function Definition ```python def smallest_repeating_unit(s: str) -> str: Determine the smallest repeating unit of the string. Args: s (str): The input string to analyze. Returns: str: The smallest repeating unit of the string if found; otherwise, the string itself. pass ``` # Requirements - Do not use any external libraries except for standard Python libraries. - Ensure your code is efficient and handles edge cases appropriately. # Examples ```python # Example 1 print(smallest_repeating_unit(\\"ababab\\")) # Should return \'ab\' # Example 2 print(smallest_repeating_unit(\\"abcabcabcabc\\")) # Should return \'abc\' # Example 3 print(smallest_repeating_unit(\\"aaaaaa\\")) # Should return \'a\' # Example 4 print(smallest_repeating_unit(\\"abcdef\\")) # Should return \'abcdef\' ``` Ensure your code passes these tests and handles edge cases elegantly (e.g., strings with one character, strings without any repeating units). # Constraints - Your solution should aim for clarity and efficiency, ensuring it runs within a reasonable time for input size up to 10000.","solution":"def smallest_repeating_unit(s: str) -> str: Determine the smallest repeating unit of the string. Args: s (str): The input string to analyze. Returns: str: The smallest repeating unit of the string if found; otherwise, the string itself. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return s[:i] return s"},{"question":"**Problem Statement**: Write a function to determine if a string is a valid shuffle of two other strings. A string is a valid shuffle of two other strings if it can be formed by interleaving the characters of the two strings while maintaining the sequence of characters in each string. For instance, given strings \\"abc\\" and \\"def\\", some valid shuffles could be \\"abcdef\\", \\"abdcef\\", \\"abdecf\\", etc., but \\"adbcef\\" would not be a valid shuffle since it does not maintain the original sequence of the characters. **Function Signature**: ```python def is_valid_shuffle(s1: str, s2: str, target: str) -> bool: pass ``` **Parameters**: - `s1` (str): The first input string. - `s2` (str): The second input string. - `target` (str): The target string to be validated as a valid shuffle of `s1` and `s2`. **Returns**: - `bool`: Returns `True` if `target` is a valid shuffle of `s1` and `s2`, otherwise returns `False`. **Constraints**: - All strings will consist of lowercase alphabetical characters. - The lengths of `s1`, `s2`, and `target` will be between `0` and `100`, inclusive. **Examples**: ```python assert is_valid_shuffle(\\"abc\\", \\"def\\", \\"adbcef\\") == True assert is_valid_shuffle(\\"abc\\", \\"def\\", \\"abdecf\\") == True assert is_valid_shuffle(\\"abc\\", \\"def\\", \\"abcdef\\") == True assert is_valid_shuffle(\\"abc\\", \\"def\\", \\"abdfec\\") == False assert is_valid_shuffle(\\"abc\\", \\"def\\", \\"abcddef\\") == False ``` **Notes**: - Consider using dynamic programming or other efficient algorithms to check if the `target` string is a valid shuffle of `s1` and `s2`. - Make sure to account for edge cases, such as empty strings for `s1`, `s2`, or `target`.","solution":"def is_valid_shuffle(s1: str, s2: str, target: str) -> bool: Determine if the target string is a valid shuffle of s1 and s2. len1, len2, len_target = len(s1), len(s2), len(target) # If lengths don\'t add up, it can\'t be a valid shuffle if len1 + len2 != len_target: return False # Create a DP table to store the results of subproblems dp = [[False] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the DP table dp[0][0] = True # Empty s1 and s2 form empty target # Fill the first row (only s2 contributing to target) for j in range(1, len2 + 1): dp[0][j] = dp[0][j - 1] and s2[j - 1] == target[j - 1] # Fill the first column (only s1 contributing to target) for i in range(1, len1 + 1): dp[i][0] = dp[i - 1][0] and s1[i - 1] == target[i - 1] # Fill the rest of the table for i in range(1, len1 + 1): for j in range(1, len2 + 1): dp[i][j] = (dp[i - 1][j] and s1[i - 1] == target[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == target[i + j - 1]) return dp[len1][len2]"},{"question":"# Problem Statement You are given a string consisting of only characters \'A\' and \'B\'. Your task is to develop a function `longest_ab_substring` that finds the longest substring where the number of \'A\'s is equal to the number of \'B\'s. # Function Signature ```python def longest_ab_substring(s: str) -> str: pass ``` # Input * **s**: A string consisting only of the characters \'A\' and \'B\'. # Output * A substring of `s` where the number of \'A\'s is equal to the number of \'B\'s and is the longest such substring in `s`. # Constraints * The length of the input string will be less than or equal to 10^5. # Performance Requirements * The solution must run within a reasonable time and space constraints for the input limits. # Example ```python >>> longest_ab_substring(\\"AABB\\") \\"AABB\\" >>> longest_ab_substring(\\"ABAB\\") \\"ABAB\\" >>> longest_ab_substring(\\"AAABBB\\") \\"AAABBB\\" >>> longest_ab_substring(\\"AAAABBBB\\") \\"AAAABBBB\\" >>> longest_ab_substring(\\"ABBA\\") \\"ABBA\\" >>> longest_ab_substring(\\"A\\") \\"\\" >>> longest_ab_substring(\\"AAABB\\") \\"ABB\\" ``` # Edge Cases To Consider * Strings with no equal number of \'A\'s and \'B\'s should return an empty string. * Strings where the entire string itself is already balanced. * Strings with consecutive \'A\'s or \'B\'s. # Hints 1. Use a sliding window approach to efficiently find the longest balanced substring. 2. Consider keeping track of the balances using a hashmap to identify previously seen balances.","solution":"def longest_ab_substring(s: str) -> str: Returns the longest substring where the number of \'A\'s is equal to the number of \'B\'s. balance_map = {0: -1} balance = 0 max_len = 0 start_idx = -1 for idx, char in enumerate(s): if char == \'A\': balance += 1 elif char == \'B\': balance -= 1 if balance in balance_map: prev_idx = balance_map[balance] if idx - prev_idx > max_len: max_len = idx - prev_idx start_idx = prev_idx + 1 else: balance_map[balance] = idx return s[start_idx:start_idx + max_len] if max_len > 0 else \\"\\""},{"question":"# Context: You are developing a data visualization tool that includes a feature for simplifying large datasets using a clustering algorithm. Your task is to implement a function that uses the K-Means algorithm to reduce the dataset by finding `k` representative points (centroids) that summarize the data. # Problem: Given a `DataPoints` class representation and a K-Means clustering function, create an extended function that not only clusters data points but also ensures the resulting centroids are unique and handles possible edge cases such as empty datasets or impossible values for `k`. # Function Signature: ```python def k_means_clustering(data: DataPoints, k: int) -> DataPoints | None: Applies the K-Means clustering algorithm to find `k` unique centroids. :param data: `DataPoints` object representing a dataset of n-dimensional points. :param k: Integer representing the number of clusters. :return: `DataPoints` representing the centroids of the clusters, or `None` if the operation is invalid. ``` # Input: - `data`: A list of `DataPoints` objects representing the dataset. `[DataPoints]` - `k`: An integer representing the number of desired clusters. `int` # Output: - A new `DataPoints` object representing the centroids of the clusters. Return `None` if clustering assumptions fail (e.g. `k` is greater than the number of data points or non-positive). # Constraints: 1. `DataPoints` instances should be non-empty. 2. Ensure `k` is a valid integer (1 ≤ `k` ≤ number of data points). 3. Handle edge cases such as empty datasets or invalid values for `k`. 4. Ensure the returned centroids are unique. # Examples: ```python >>> data = DataPoints([(1.0, 2.0), (2.0, 3.0), (4.0, 5.0), (8.0, 9.0)]) >>> k = 2 >>> k_means_clustering(data, k) DataPoints consist of 2 points [ (2.5, 3.5), (8.0, 9.0) ] ``` # Notes: - Ensure that you validate the input to check for edge cases. - Implement or use an existing K-Means clustering function to perform the clustering. - Ensure points are stored in a `DataPoints` object and validate their uniqueness.","solution":"from typing import List, Tuple, Optional import numpy as np from collections import Counter import random class DataPoints: def __init__(self, points: List[Tuple[float, ...]]): self.points = points def k_means_clustering(data: DataPoints, k: int) -> Optional[DataPoints]: def distance(p1, p2): return np.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2))) def assign_clusters(data_points, centroids): clusters = [[] for _ in centroids] for point in data_points: distances = [distance(point, c) for c in centroids] closest_centroid = distances.index(min(distances)) clusters[closest_centroid].append(point) return clusters def calculate_centroids(clusters): return [tuple(np.mean(cluster, axis=0)) for cluster in clusters if cluster] if not data.points: return None if k <= 0 or k > len(data.points): return None # Initialize centroids randomly from data points centroids = random.sample(data.points, k) old_centroids = [] while old_centroids != centroids: old_centroids = centroids clusters = assign_clusters(data.points, centroids) centroids = calculate_centroids(clusters) # Ensure centroids are unique centroids = list(set(centroids)) # If reducing centroids reduces it less than k, return None if len(centroids) < k: return None return DataPoints(centroids)"},{"question":"# Problem Statement Implement a function `unique_paths(m: int, n: int) -> int` that determines the number of unique paths from the top-left corner to the bottom-right corner of an `m x n` grid. You can only move either down or right at any point in time. # Context This problem falls under the category of combinatorial problems and dynamic programming. It tests your ability to compute combinations and utilize efficient techniques to solve lattice path problems. # Input * `m` - An integer representing the number of rows in the grid (1 <= m <= 100). * `n` - An integer representing the number of columns in the grid (1 <= n <= 100). # Output * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Constraints * The solution should handle large values of `m` and `n` efficiently, considering potential time and space complexities. # Example ```python assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(7, 3) == 28 assert unique_paths(3, 3) == 6 ``` # Hints 1. Consider using dynamic programming or combinatorial mathematics to derive the number of unique paths. 2. The number of unique paths to reach a cell can be derived from the sum of the unique paths to the cell directly above and to the left of it.","solution":"def unique_paths(m: int, n: int) -> int: Determines the number of unique paths in an m x n grid from the top-left corner to the bottom-right corner. :param m: Number of rows in the grid :param n: Number of columns in the grid :return: Number of unique paths # Create a 2D list with all elements initialized to 1 dp = [[1] * n for _ in range(m)] # Populate the table using dynamic programming for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"# Missing Integer in Array Context You are given an array of n unique integers where each integer is in the range from 1 to n+1 (inclusive). This implies that exactly one integer is missing from the array. Your task is to write a function that finds and returns the missing integer. Objective Implement the `find_missing_integer` function to efficiently determine the missing integer in the array. Requirements - **Input/Output Specifications**: * The `find_missing_integer` function should take a list of integers as input. * It should return the missing integer. - **Constraints**: * The input list will contain n unique integers where each integer is between 1 and n+1 (inclusive). * The input list will be well-formed with no duplicates and exactly one integer missing. - **Performance**: * Aim for a time complexity of O(n). * Ensure a space complexity of O(1) beyond the input storage. Implementation Assuming the list is named `nums`, here\'s how you can implement the `find_missing_integer` function: ```python def find_missing_integer(nums): n = len(nums) # Calculate the expected sum of numbers from 1 to n+1 expected_sum = (n + 1) * (n + 2) // 2 # Calculate the actual sum of numbers present in the array actual_sum = sum(nums) # The missing number is the difference return expected_sum - actual_sum ``` Example Usage: ```python # Example 1 nums = [1, 2, 4, 5, 6] print(find_missing_integer(nums)) # Output: 3 # Example 2 nums = [2, 3, 4, 5, 6, 7, 8, 9, 10, 1] print(find_missing_integer(nums)) # Output: 11 # Example 3 nums = [3, 7, 1, 2, 8, 4, 5] print(find_missing_integer(nums)) # Output: 6 ``` Ensure the function runs correctly with various test cases, including edge cases where the smallest or largest number is missing.","solution":"def find_missing_integer(nums): Function to find the missing integer in an array of unique integers ranging from 1 to n+1. :param nums: List[int] :return: int n = len(nums) # Calculate the expected sum of numbers from 1 to n+1 expected_sum = (n + 1) * (n + 2) // 2 # Calculate the actual sum of numbers present in the array actual_sum = sum(nums) # The missing number is the difference return expected_sum - actual_sum"},{"question":"# Coding Question: Simulating Brownian Motion in One-Dimensional Space Background Brownian motion describes the random movement of particles suspended in a fluid, resulting from collisions with fast atoms or molecules in the gas or liquid. In one-dimensional space, the position of a particle undergoing Brownian motion can be modeled as a sequence of random steps. Objective Implement a function to simulate the path of a particle undergoing Brownian motion in one-dimensional space. Given the number of steps and the size of each step, compute the positions of the particle at each step. Function Signature ```python def brownian_motion(steps: int, step_size: float) -> List[float]: ``` Input 1. **steps**: An integer representing the number of steps the particle will take. * Constraints: 1 ≤ steps ≤ 10^6 2. **step_size**: A float representing the size of each step. * Constraints: 0 < step_size ≤ 1 Output Return a list of floats representing the position of the particle at each step, starting from the origin (0.0). Examples ```python >>> brownian_motion(5, 0.5) [0.0, 0.5, 1.0, 0.5, 0.0, 0.5] >>> brownian_motion(3, 1.0) [0.0, -1.0, 0.0, 1.0] >>> brownian_motion(7, 0.1) [0.0, -0.1, -0.2, -0.1, -0.2, -0.1, -0.2, -0.1] ``` Note * Use a random number generator to determine the direction (positive or negative) of each step. * The function should start the simulation from position `0.0`. * Ensure to handle edge cases and constraints.","solution":"import random from typing import List def brownian_motion(steps: int, step_size: float) -> List[float]: Simulate the path of a particle undergoing Brownian motion in one-dimensional space. Args: steps: int - the number of steps the particle will take. step_size: float - the size of each step. Returns: List[float] - the positions of the particle at each step, starting from the origin (0.0). positions = [0.0] current_position = 0.0 for _ in range(steps): direction = random.choice([-1, 1]) current_position += direction * step_size positions.append(current_position) return positions"},{"question":"# Coding Assessment Question: **Context**: You are developing a function for a software application that needs to analyze user activity data. Specifically, you will implement a function that calculates the maximum number of posts made by a user in any given month. **Task**: Write a Python function `max_posts_in_month` that takes a list of dates (in \'YYYY-MM-DD\' format) representing the dates when posts were made by a user, and returns the maximum number of posts made in any single calendar month. **Specifications**: * Function name: `max_posts_in_month` * Input: * A list of strings `dates` where each string represents a date in the format \'YYYY-MM-DD\'. * Output: * An integer representing the maximum number of posts made in any single calendar month. **Constraints**: * The input list can be empty, meaning the user made no posts. In such a case, the function should return `0`. * The dates within the list are unique and there are no duplicate entries. **Example**: ```python def max_posts_in_month(dates: [str]) -> int: Calculate the maximum number of posts made in any single calendar month. Parameters: dates (list of str): A list of dates in \'YYYY-MM-DD\' format. Returns: int: Maximum number of posts made in any single calendar month. Examples: >>> max_posts_in_month([\'2023-01-15\', \'2023-01-23\', \'2023-01-29\', \'2023-02-05\', \'2023-02-10\']) 3 >>> max_posts_in_month([\'2022-08-17\', \'2022-09-01\', \'2022-09-15\', \'2022-09-30\', \'2022-10-10\']) 3 >>> max_posts_in_month([\'2020-11-11\']) 1 >>> max_posts_in_month([]) 0 pass ``` **Notes**: * Be sure to handle cases where the input list is empty. * Properly parse the input date strings to identify and count the number of posts in each calendar month. * Test your function with a variety of test cases, including edge cases with sparse and dense date distributions.","solution":"from collections import Counter def max_posts_in_month(dates): Calculate the maximum number of posts made in any single calendar month. Parameters: dates (list of str): A list of dates in \'YYYY-MM-DD\' format. Returns: int: Maximum number of posts made in any single calendar month. if not dates: return 0 # Dictionary to count the number of posts in each month-year combination month_count = Counter() for date in dates: year_month = date[:7] # Extract the \'YYYY-MM\' part of the date month_count[year_month] += 1 # Return the maximum number of posts in any single month return max(month_count.values())"},{"question":"# Problem Statement Implement a function that compresses a given string using the Run-Length Encoding (RLE) algorithm. Additionally, implement a function that decodes a string encoded with RLE back to its original form. # Function 1: `rle_encode(s: str) -> str` * **Input Parameters**: - `s` (str): An input string consisting of alphanumeric characters. * **Output**: - Returns a string representing the run-length encoded version of the input string. # Function 2: `rle_decode(s: str) -> str` * **Input Parameters**: - `s` (str): A run-length encoded string. * **Output**: - Returns the original string after decoding the run-length encoded input. * **Constraints**: - The input string for encoding (`s`) has a maximum length of 10^4. - The encoded string for decoding (`s`) is guaranteed to be a valid RLE format with a length not exceeding 10^5. # Requirements: 1. Implement `rle_encode(s: str) -> str`. 2. Implement `rle_decode(s: str) -> str`. 3. Ensure efficient computation with consideration of time complexity O(n) for both functions, where n is the length of the input string. # Examples: Example 1 ```python >>> rle_encode(\\"aaabbbccc\\") \\"a3b3c3\\" ``` Example 2 ```python >>> rle_decode(\\"a3b3c3\\") \\"aaabbbccc\\" ``` Example 3 ```python >>> rle_encode(\\"aabccccaaa\\") \\"a2b1c4a3\\" ``` Example 4 ```python >>> rle_decode(\\"a2b1c4a3\\") \\"aabccccaaa\\" ``` # Explanation: 1. `rle_encode(\\"aaabbbccc\\")` returns \\"a3b3c3\\" because the input can be compressed into three counts of \'a\', three counts of \'b\', and three counts of \'c\'. 2. `rle_decode(\\"a3b3c3\\")` returns \\"aaabbbccc\\" by reversing the encoded string \\"a3b3c3\\". 3. `rle_encode(\\"aabccccaaa\\")` returns \\"a2b1c4a3\\" by compressing two \'a\', one \'b\', four \'c\', and three \'a\'. 4. `rle_decode(\\"a2b1c4a3\\")` returns \\"aabccccaaa\\" correctly converting the run-length encoded string back to its original form.","solution":"def rle_encode(s: str) -> str: if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(s[i - 1] + str(count)) count = 1 encoded_str.append(s[-1] + str(count)) return \'\'.join(encoded_str) def rle_decode(s: str) -> str: if not s: return \\"\\" decoded_str = [] i = 0 while i < len(s): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decoded_str.append(char * count) return \'\'.join(decoded_str)"},{"question":"# Problem Statement Your task is to detect all the unique words in a given text that can be formed by re-arranging the characters of any valid English word in a specified dictionary. You will implement a function that adheres to the constraints and efficiently handles large inputs through appropriate data structures. # Function Signature ```python def detect_anagrams(text: str, dictionary: List[str]) -> List[str]: ``` # Input - **text**: A string representing the input text containing words separated by spaces. - **dictionary**: A list of strings representing valid English words. # Output - Returns a list of strings containing all unique words from the text that can be formed by re-arranging the characters of any word in the dictionary. # Constraints - The length of **text** can be up to `100,000` characters. - The number of words in **dictionary** can be up to `50,000`. - Each word in **dictionary** has a maximum length of `20`. - Words in **text** are separated by a single space and contain only lowercase English letters. # Example ```python print(detect_anagrams(\\"listen silent enlist stop pots tops\\", [\\"listen\\", \\"enlist\\", \\"stop\\"])) # Output: [\\"listen\\", \\"silent\\", \\"enlist\\", \\"stop\\", \\"pots\\", \\"tops\\"] ``` # Requirements 1. **Preprocessing**: Efficiently handle large inputs and preprocess the dictionary to allow O(1) lookups for anagram detection. 2. **Anagram Detection**: Ensure that each word in the text is checked against the dictionary to determine if it is an anagram of any dictionary word. 3. **Uniqueness**: Maintain unique detection results and avoid duplicates in the output list. 4. **Optimization**: Implement the solution in a manner that ensures optimal performance, considering the constraints on input size. **Note**: Clear usage of data structures such as sets or dictionaries for efficient lookups and ensuring uniqueness in the output is critical. Robust handling of large inputs while maintaining optimal performance should be evident in your implementation.","solution":"from typing import List def detect_anagrams(text: str, dictionary: List[str]) -> List[str]: def sorted_word(word): return \'\'.join(sorted(word)) # Create a set of sorted words from the dictionary dict_set = set(sorted_word(word) for word in dictionary) # Split the text into words words = text.split() # Create a set for unique anagram words from the text unique_anagrams = set() # Check each word in the text to see if its sorted form is in the dictionary set for word in words: if sorted_word(word) in dict_set: unique_anagrams.add(word) return list(unique_anagrams)"},{"question":"# Coding Assessment Question: Scenario: As part of your role in teaching data structures and algorithms, you have designed a task to assess the students\' understanding of binary search trees (BST). The task involves implementing functions to insert elements into the BST and finding the lowest common ancestor (LCA) of two given nodes. Task: Write the three functions `insert_node`, `find_lca`, and `create_bst` to handle insertion into a BST and finding the lowest common ancestor of two nodes. Function Specifications: 1. **Function**: insert_node - **Input**: - `root` (TreeNode): The root of the binary search tree. - `value` (int): The integer value to be inserted into the tree. - **Output**: - (TreeNode): The new root of the binary search tree with the value inserted. 2. **Function**: find_lca - **Input**: - `root` (TreeNode): The root of the binary search tree. - `p` (int): The value of the first node. - `q` (int): The value of the second node. - **Output**: - (TreeNode): The lowest common ancestor of the nodes with values p and q. 3. **Function**: create_bst - **Input**: - `values` (List[int]): A list of integers to be inserted into an initially empty BST. - **Output**: - (TreeNode): The root of the binary search tree constructed using the input list. Constraints: - `1 <= len(values) <= 10^5` - `1 <= value, p, q <= 10^5` - The list `values` may contain duplicate values, but the BST should only allow unique values. - The solution should handle large input sizes efficiently. Example: ```python values = [20, 10, 30, 5, 15, 25, 35] root = create_bst(values) # The BST should be constructed with 20 as the root. p, q = 5, 15 lca_node = find_lca(root, p, q) print(lca_node.value) # Output should be 10, since 10 is the LCA of 5 and 15. # Insert a new value into the BST root = insert_node(root, 12) # The BST should now include 12 as a node under 15. ``` Note: Pay special attention to efficiently managing tree balance and preventing unnecessary operations. Your solution should handle various edge cases such as extremely large trees, values not found in the tree, and ensure that the tree operations are conducted optimally.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_node(root, value): if root is None: return TreeNode(value) if value < root.val: root.left = insert_node(root.left, value) elif value > root.val: root.right = insert_node(root.right, value) return root def find_lca(root, p, q): while root: if p < root.val and q < root.val: root = root.left elif p > root.val and q > root.val: root = root.right else: return root def create_bst(values): root = None for value in values: root = insert_node(root, value) return root"},{"question":"# Coding Question Context In a matrix traversal problem, you often need to start at a given cell and explore all connected components—cells that form a contiguous block horizontally or vertically. This traversal is similar to a flood fill algorithm used in image processing. Task Implement a function `flood_fill` that: 1. Takes a matrix of `0`s and `1`s, and a starting cell\'s row and column indices. 2. Changes all `1`s connected to the starting cell to `2`s. 3. Returns the updated matrix. Function Interface ```python def flood_fill(matrix: list[list[int]], start_row: int, start_col: int) -> list[list[int]]: Perform flood fill on the matrix starting from the given cell. ``` Input - `matrix` (list of list of int): A non-empty 2D list where each element is either `0` or `1`. - `start_row` (int): The row index to start the flood-fill. - `start_col` (int): The column index to start the flood-fill. Output - Return the modified matrix after performing the flood fill. Example Usage ```python matrix = [ [1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1], [1, 1, 1, 0] ] start_row = 0 start_col = 0 new_matrix = flood_fill(matrix, start_row, start_col) print(new_matrix) ``` Expected output: ``` [ [2, 2, 0, 0], [2, 0, 0, 1], [0, 0, 1, 1], [1, 1, 1, 0] ] ``` Constraints - The input matrix will have at most 1000 rows and 1000 columns. - The starting cell will always contain a `1`. - Contiguous cells are those that are horizontally or vertically adjacent (no diagonals).","solution":"def flood_fill(matrix: list[list[int]], start_row: int, start_col: int) -> list[list[int]]: Perform flood fill on the matrix starting from the given cell. rows, cols = len(matrix), len(matrix[0]) starting_value = 1 new_value = 2 def dfs(r, c): # If out of bounds or the cell is not part of the contiguous block anymore if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] != starting_value: return # Fill the cell matrix[r][c] = new_value # Recursively fill the adjacent cells dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right # Start flood fill from the starting cell dfs(start_row, start_col) return matrix"},{"question":"# Summing Multiples of 3 and 5 You are tasked with creating a function that calculates the sum of all multiples of 3 and 5 up to and including a given number `n`. Your function should be able to handle large numbers efficiently and return the appropriate sum. Implement the function `sum_multiples_3_and_5(n: int) -> int` that: * Takes an integer `n` as input. * Returns the sum of all multiples of 3 and 5 from 1 to `n`. Function Signature ```python def sum_multiples_3_and_5(n: int) -> int: pass ``` # Input * `n`: An integer (1 ≤ n ≤ 10^6) # Output * Returns an integer representing the sum of all multiples of 3 and 5 from 1 to `n`. # Examples Here are some sample test cases for your implementation: ```python assert sum_multiples_3_and_5(10) == 33 # 3 + 5 + 6 + 9 + 10 assert sum_multiples_3_and_5(15) == 60 # 3 + 5 + 6 + 9 + 10 + 12 + 15 assert sum_multiples_3_and_5(1) == 0 # There are no multiples of 3 or 5 less than or equal to 1 assert sum_multiples_3_and_5(0) == 0 # Edge case, `n` is 0 assert sum_multiples_3_and_5(20) == 98 # 3 + 5 + 6 + 9 + 10 + 12 + 15 + 18 + 20 assert sum_multiples_3_and_5(1000) == 234168 # Large case to check efficiency ```","solution":"def sum_multiples_3_and_5(n: int) -> int: Returns the sum of all multiples of 3 and 5 up to and including n. total_sum = 0 for i in range(1, n + 1): if i % 3 == 0 or i % 5 == 0: total_sum += i return total_sum"},{"question":"# Problem Statement You are tasked with writing a function to validate and extract data from a URL query string. The function should be able to parse the query string parameters and return them as key-value pairs in a dictionary. It must also handle cases where certain parameters are not present or have no value assigned. # Requirements Write a function `parse_query_string(query_string)` that takes a URL query string and returns a dictionary of parameters and their corresponding values. Function Signature ```python def parse_query_string(query_string): pass ``` Expected Input and Output - **Input**: - `query_string`: A string representing the URL query string, which may be empty. - **Output**: - A dictionary containing key-value pairs extracted from the query string. Keys are the parameter names, and values are their respective parameter values. Example ```python query_string1 = \\"name=John&age=25&city=New%20York\\" result1 = parse_query_string(query_string1) print(result1) # Output should be: {\'name\': \'John\', \'age\': \'25\', \'city\': \'New York\'} query_string2 = \\"name=&age=25&city=\\" result2 = parse_query_string(query_string2) print(result2) # Output should be: {\'name\': \'\', \'age\': \'25\', \'city\': \'\'} query_string3 = \\"name=John&age=25&city=New%20York&country\\" result3 = parse_query_string(query_string3) print(result3) # Output should be: {\'name\': \'John\', \'age\': \'25\', \'city\': \'New York\', \'country\': \'\'} ``` Constraints 1. The query string may include any valid URL-encoded characters as parameter names or values. 2. If a parameter appears more than once, the function should include only the last occurrence in the dictionary. 3. If a parameter has no value (e.g., `country` in the third example), it should be included with an empty string as its value. 4. The function should handle an empty query string by returning an empty dictionary. # Notes - Consider using the `urllib.parse` module for handling URL encoding/decoding. - Optimize the function to handle large query strings efficiently. - Ensure your function handles edge cases, such as missing values and repeated parameters correctly. - Validate the input to ensure it conforms to the constraints. - Prioritize readability and maintainability of the code.","solution":"from urllib.parse import parse_qs, unquote def parse_query_string(query_string): Parses a URL query string into a dictionary of key-value pairs. Keys are parameter names, and values are their respective parameter values. if not query_string: return {} params = parse_qs(query_string, keep_blank_values=True) result = {k: unquote(v[-1]) for k, v in params.items()} return result"},{"question":"# Coding Challenge: String Compression and Decompression Objective Develop a set of functions to compress and decompress strings using a simple Run-Length Encoding (RLE) technique. Your implementation should cover the following functionalities: 1. **String Compression**: Implement a function to compress a given string. The function should replace sequences of the same character with a single character followed by the count of repetitions. 2. **String Decompression**: Implement a function to decompress a previously compressed string back to its original form. 3. **Edge Case Handling**: Ensure that your functions correctly handle edge cases such as empty strings and strings without any repetitive characters. Function Signatures 1. **String Compression**: ```python def compress_string(input_string: str) -> str: Compresses the given string using Run-Length Encoding (RLE). Parameters: input_string: str - The string to be compressed. Returns: str - The compressed string. ``` 2. **String Decompression**: ```python def decompress_string(compressed_string: str) -> str: Decompresses a given RLE-compressed string back to its original form. Parameters: compressed_string: str - The compressed string to be decompressed. Returns: str - The original uncompressed string. ``` Constraints * **Input Format**: * **compress_string**: `input_string` as a string. * **decompress_string**: `compressed_string` as a string. * **Output Format**: * **compress_string**: Compressed string following the RLE encoding technique. * **decompress_string**: The original string decompressed from its RLE form. # Example ``` python >>> compress_string(\'aaabbcccc\') \'a3b2c4\' >>> compress_string(\'abcd\') \'a1b1c1d1\' >>> decompress_string(\'a3b2c4\') \'aaabbcccc\' >>> decompress_string(\'a1b1c1d1\') \'abcd\' ``` Additional Notes * Ensure all functions have proper docstrings and error handling capabilities. * Tests for various edge cases must be included along with the main implementation. * The input strings will only contain alphabetic characters, both upper and lower case.","solution":"def compress_string(input_string: str) -> str: Compresses the given string using Run-Length Encoding (RLE). Parameters: input_string: str - The string to be compressed. Returns: str - The compressed string. if not input_string: return \\"\\" compressed_parts = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed_parts.append(f\\"{input_string[i - 1]}{count}\\") count = 1 compressed_parts.append(f\\"{input_string[-1]}{count}\\") return \\"\\".join(compressed_parts) def decompress_string(compressed_string: str) -> str: Decompresses a given RLE-compressed string back to its original form. Parameters: compressed_string: str - The compressed string to be decompressed. Returns: str - The original uncompressed string. if not compressed_string: return \\"\\" decompressed_parts = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = 0 i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 decompressed_parts.append(char * count) return \\"\\".join(decompressed_parts)"},{"question":"# Problem Description You are tasked with implementing a multidimensional array flattener. Given a potentially nested list of integers, your goal is to write two functions that flatten the list into a single list of integers. Function 1: Iterative Flattening Implement `flatten_iterative(nested_list: List[Union[int, List]]) -> List[int]`: * **Input**: - `nested_list`: A potentially deeply nested list containing integers and/or other nested lists of integers. * **Output**: A single list of integers in the same order as they appear in the `nested_list`. Function 2: Recursive Flattening Implement `flatten_recursive(nested_list: List[Union[int, List]]) -> List[int]`: * **Input**: - `nested_list`: As described above. * **Output**: As described above. # Constraints 1. The depth of nesting in the input list will not exceed 10^6. 2. The input list will contain at most 10^6 integers. # Example ```python nested_list = [1, [2, [3, 4]], [5, [6, [7]]]] assert flatten_iterative(nested_list) == [1, 2, 3, 4, 5, 6, 7] assert flatten_recursive(nested_list) == [1, 2, 3, 4, 5, 6, 7] ``` Your task is to ensure both implementation methods produce the same results correctly for the given input.","solution":"from typing import List, Union def flatten_iterative(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers iteratively. flat_list = [] stack = [nested_list] while stack: current = stack.pop() if isinstance(current, list): stack.extend(reversed(current)) else: flat_list.append(current) return flat_list def flatten_recursive(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers recursively. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten_recursive(element)) else: flat_list.append(element) return flat_list"},{"question":"# Problem Statement You are tasked with creating a `FullBinaryTree` class that allows for construction and manipulation of a full binary tree. A full binary tree is a tree in which every node other than the leaves has two children. Your class should provide methods to add nodes, determine the depth of the tree, perform various traversals (in-order, pre-order, post-order, and level-order), and check whether the tree is full. # Requirements FullBinaryTree Class - Implement a `Node` class to represent each node in the tree. - Implement methods to add nodes such that the tree maintains its property of being a full binary tree. - Implement methods for in-order, pre-order, post-order, and level-order traversals. - Implement a method to check if the tree is a full binary tree. # Function Signatures 1. `add_node(self, value: int) -> None`: - Adds a node to the tree, preserving the full binary tree structure. - Nodes should be added level-wise from left to right. 2. `is_full_binary_tree(self) -> bool`: - Returns `True` if the tree is a full binary tree, otherwise `False`. 3. `get_depth(self) -> int`: - Returns the depth of the tree (the number of levels in the tree). 4. `traversal(self, order: str) -> List[int]`: - Returns a list of node values in the specified traversal order. - `order` can be one of `\\"inorder\\"`, `\\"preorder\\"`, `\\"postorder\\"`, or `\\"levelorder\\"`. # Constraints - All node values will be integers and unique. - Tree can initially start empty. - The methods should efficiently preserve the properties of the tree. # Example Usage ```python tree = FullBinaryTree() # Adding nodes tree.add_node(1) # Root node tree.add_node(2) tree.add_node(3) tree.add_node(4) tree.add_node(5) tree.add_node(6) tree.add_node(7) # Check if it is a full binary tree assert tree.is_full_binary_tree() == True # Get tree depth assert tree.get_depth() == 3 # Perform traversals assert tree.traversal(\\"inorder\\") == [4, 2, 5, 1, 6, 3, 7] assert tree.traversal(\\"preorder\\") == [1, 2, 4, 5, 3, 6, 7] assert tree.traversal(\\"postorder\\") == [4, 5, 2, 6, 7, 3, 1] assert tree.traversal(\\"levelorder\\") == [1, 2, 3, 4, 5, 6, 7] # Ensure all methods integrate smoothly with each other without breaking the full binary tree properties. if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure the class and methods maintain the properties of a full binary tree. - The traversal methods should output node values in the respective order correctly. - Write thorough tests to cover all possible scenarios and edge cases. By adhering to these guidelines, your implementation should facilitate a comprehensive and functional `FullBinaryTree` class that aligns with the existing problem complexity and scope.","solution":"from typing import Any, List, Optional class Node: def __init__(self, value: int): self.value = value self.left: Optional[Node] = None self.right: Optional[Node] = None class FullBinaryTree: def __init__(self): self.root: Optional[Node] = None self.queue: List[Node] = [] def add_node(self, value: int) -> None: new_node = Node(value) if not self.root: self.root = new_node self.queue.append(new_node) else: while self.queue: parent = self.queue[0] if not parent.left: parent.left = new_node self.queue.append(new_node) break elif not parent.right: parent.right = new_node self.queue.append(new_node) self.queue.pop(0) break def is_full_binary_tree(self) -> bool: if not self.root: return True queue = [self.root] while queue: node = queue.pop(0) if node.left and node.right: queue.append(node.left) queue.append(node.right) elif not node.left and not node.right: continue else: return False return True def get_depth(self) -> int: def depth(node: Optional[Node]) -> int: if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root) def traversal(self, order: str) -> List[int]: result = [] if order == \\"inorder\\": self._inorder_traversal(self.root, result) elif order == \\"preorder\\": self._preorder_traversal(self.root, result) elif order == \\"postorder\\": self._postorder_traversal(self.root, result) elif order == \\"levelorder\\": self._levelorder_traversal(self.root, result) return result def _inorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def _preorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: result.append(node.value) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) def _postorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.value) def _levelorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if not node: return queue = [node] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right)"},{"question":"# Problem Scenario A company\'s e-commerce website maintains a log of all purchases made on the platform. Each purchase log entry contains an order ID, a customer ID, and the amount spent. They want to identify the top-spending customers in a given timeframe. To achieve this, you need to process a list of purchase log entries to determine the top `N` customers based on the total amount spent. # Problem Statement Write a function `top_n_customers(purchases: List[Tuple[int, int, float]], N: int) -> List[int]` that processes a list of purchases and returns the customer IDs of the top `N` spenders. # Input * `purchases` - A list of tuples where each tuple contains: * an `orderId` (int) - The order ID. * a `customerId` (int) - The customer ID. * an `amount` (float) - The amount spent in that purchase. * `N` (1 ≤ `N` ≤ 1000) - The number of top customers to return. If there are fewer than `N` unique customers in the purchases list, return all unique customer IDs sorted by their total spending in descending order. # Output * A list of the top `N` customer IDs based on their total spending, sorted in descending order of spending. * If customers have the same total spending, their IDs should be sorted in ascending order. # Example ```python purchases = [ (1, 101, 250.0), (2, 102, 100.0), (3, 101, 150.0), (4, 103, 200.0), (5, 104, 50.0) ] assert top_n_customers(purchases, 2) == [101, 103] assert top_n_customers(purchases, 3) == [101, 103, 102] assert top_n_customers(purchases, 5) == [101, 103, 102, 104] ``` # Constraints * Implement the function efficiently to handle large lists of purchases. * Ensure that the function correctly handles cases where multiple customers have the same total spending. # Function Signature ```python def top_n_customers(purchases: List[Tuple[int, int, float]], N: int) -> List[int]: pass ```","solution":"from typing import List, Tuple from collections import defaultdict def top_n_customers(purchases: List[Tuple[int, int, float]], N: int) -> List[int]: Identifies the top N customers by total amount spent. customer_spendings = defaultdict(float) # Accumulate total spending for each customer for order_id, customer_id, amount in purchases: customer_spendings[customer_id] += amount # Sort customers by total spending first (descending) and then by customer ID (ascending) sorted_customers = sorted(customer_spendings.items(), key=lambda x: (-x[1], x[0])) # Get the top N customerIds top_customers = [customer_id for customer_id, _ in sorted_customers[:N]] return top_customers"},{"question":"# Question: Implement Quicksort Algorithm You are tasked with implementing the Quicksort sorting algorithm. Quicksort is a divide-and-conquer algorithm that works by selecting a \'pivot\' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. # The Quicksort Function Implement the function `quicksort` with the following signature: ```python def quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the Quicksort algorithm. Parameters: - arr (List[int]): The list of integers to be sorted. Returns: - List[int]: The sorted list of integers. pass ``` # Requirements 1. **Partitioning**: Implement the partitioning logic that reorders the array\'s elements according to the pivot. 2. **Recursive Sorting**: The function should recursively sort the sub-arrays produced by the partition. 3. **In-place Sorting**: Aim to sort the array in place to achieve the best space complexity. # Example Usage Sort an array using Quicksort: ```python if __name__ == \\"__main__\\": arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = quicksort(arr) print(sorted_arr) # Output should be [1, 1, 2, 3, 6, 8, 10] ``` # Constraints * The array length is a positive integer, typically in the range of [0, 10000]. * Array elements are integers, potentially including duplicates and ranging from -1000000 to 1000000. # Performance Considerations Efficiency is crucial. Aim to optimize the implementation, particularly for handling large arrays efficiently. Consider the average and worst-case time complexity of Quicksort and investigate strategies to mitigate the latter, such as using random pivots or median-of-three technique.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the Quicksort algorithm. Parameters: - arr (List[int]): The list of integers to be sorted. Returns: - List[int]: The sorted list of integers. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] # Choosing the middle element as pivot left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# Scenario A software development firm is working on a feature to dynamically generate and validate structured product codes. Each product code follows a specific pattern and the validation needs to check if the given code conforms to the pattern. They need a function to help them create and validate these codes efficiently. # Problem Statement Implement the function `validate_product_code(code: str) -> bool` which returns a boolean indicating whether the given product code is valid according to the predefined pattern rules. The pattern for a valid product code is described as follows: - It starts with two uppercase letters. - Followed by a hyphen (`-`). - Then six digits. - Ends with an uppercase letter. # Function Signature ```python def validate_product_code(code: str) -> bool: ``` # Input - `code` (str): The product code to be validated. # Output - `bool`: A boolean value indicating whether the given product code is valid. # Constraints - The input `code` will be a non-empty string with a maximum length of 20 characters. # Examples ```python validate_product_code(\\"AB-123456C\\") -> True validate_product_code(\\"XY-987654Z\\") -> True validate_product_code(\\"A1-123456B\\") -> False validate_product_code(\\"AB-12345B\\") -> False validate_product_code(\\"AB-123456-C\\") -> False validate_product_code(\\"abcdefg\\") -> False ``` # Guidelines 1. Use regular expressions (regex) to define and check the pattern in a concise manner. 2. Ensure the function efficiently handles strings at the edge of the maximum length constraint. 3. Consider edge cases like incorrect formatting or missing components of the code. # Hints - Utilize the `re` library in Python for regex-based pattern matching. - A valid product code pattern can be represented as `^[A-Z]{2}-d{6}[A-Z]`","solution":"import re def validate_product_code(code: str) -> bool: Validates the product code according to predefined pattern rules. Pattern: Starts with two uppercase letters, followed by a hyphen, then six digits, and ends with an uppercase letter. Parameters: - code (str): The product code to be validated. Returns: - bool: True if the code is valid, False otherwise. pattern = r\'^[A-Z]{2}-d{6}[A-Z]\' return bool(re.match(pattern, code))"},{"question":"Binary Tree Depth Sum You are required to implement a function that calculates the depth-sum of a binary tree. The depth-sum of a tree is defined as the sum of all node values multiplied by the depth of their respective nodes. The depth of the root node is 1, the depth of its children is 2, and so on. Function Signature ```python def depth_sum(root: Optional[TreeNode]) -> int: pass ``` Input 1. `root`: The root node of a binary tree, where each node contains an integer value and two children (left and right). `TreeNode` is a class defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Output The function should return an integer, which is the total depth-sum of the tree. If the tree is empty (`root` is `None`), return 0. Constraints - The number of nodes in the binary tree is between 1 and 1000. - Node values will always be integers, and can be negative or positive. Example ```python # Binary tree: # 1 # / # 2 3 # / / # 4 5 6 root = TreeNode(1) root.left = TreeNode(2, TreeNode(4)) root.right = TreeNode(3, TreeNode(5), TreeNode(6)) depth_sum(root) # Output: 1*1 + 2*2 + 3*2 + 4*3 + 5*3 + 6*3 = 1 + 4 + 6 + 12 + 15 + 18 = 56 ``` Doctests The following doctests should also pass: ```python def test_depth_sum(): root1 = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6))) assert depth_sum(root1) == 56 root2 = TreeNode(-1, TreeNode(2), TreeNode(-3, TreeNode(4), TreeNode(-5))) assert depth_sum(root2) == -1*1 + 2*2 - 3*2 + 4*3 - 5*3 = -1 + 4 - 6 + 12 - 15 = -6 assert depth_sum(None) == 0 ``` Notes - Implement the `depth_sum` function using a recursive or iterative approach. - Use a helper function if needed to maintain the depth level. - Ensure your function handles edge cases such as an empty tree appropriately.","solution":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_sum(root: Optional[TreeNode]) -> int: def helper(node, depth): if not node: return 0 return depth * node.value + helper(node.left, depth + 1) + helper(node.right, depth + 1) return helper(root, 1)"},{"question":"# Question Context Graphs are fundamental data structures in computer science, used to represent various types of networks. One crucial problem in graph theory is finding the shortest path between nodes. The Dijkstra algorithm is a well-known method for this purpose, relying on a priority queue to ensure efficient pathfinding. Imagine you are building a city navigation app that provides the shortest path between different locations in the city. Your task is to implement a simplified version of the Dijkstra algorithm to compute the shortest path between two given nodes in a graph representing the city\'s road network. Problem Statement Implement a function `dijkstra_shortest_path` to find the shortest path from a source node to a target node in a weighted, undirected graph. 1. **dijkstra_shortest_path(graph: dict, start: int, end: int) -> list[int]** - **Input**: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of tuples. Each tuple represents a neighboring node and the weight (distance) of the edge connecting them. - `start`: An integer representing the starting node. - `end`: An integer representing the destination node. - **Output**: - A list of integers representing the sequence of nodes in the shortest path from `start` to `end`. If no path exists, return an empty list. - **Example**: ```python >>> graph = { 0: [(1, 2), (2, 4)], 1: [(0, 2), (2, 1), (3, 7)], 2: [(0, 4), (1, 1), (3, 3)], 3: [(1, 7), (2, 3)] } >>> dijkstra_shortest_path(graph, 0, 3) [0, 1, 2, 3] ``` 2. **Constraints**: - `1 <= len(graph) <= 10^3` - `0 <= start, end < len(graph)` - All node identifiers are unique. - The graph is connected and all distances are positive integers. Additional Requirements - Your implementation should handle edge cases such as: - The graph with a single node. - The graph with varying edge weights. - No available path between the start and end nodes. - Aim for a time complexity efficient solution using appropriate data structures to handle the upper input limits gracefully.","solution":"import heapq def dijkstra_shortest_path(graph, start, end): Finds the shortest path from start to end in a weighted undirected graph using Dijkstra\'s algorithm. :param graph: A dictionary representing the graph. Keys are node identifiers and values are lists of tuples, each representing a neighboring node and the weight of the edge. :param start: The starting node identifier. :param end: The destination node identifier. :return: A list of integers representing the sequence of nodes in the shortest path from start to end. If no path exists, returns an empty list. # Priority queue to store (cost, node, path) pq = [(0, start, [])] visited = set() while pq: (cost, current_node, path) = heapq.heappop(pq) # Avoid revisiting nodes if current_node in visited: continue visited.add(current_node) # Path to the current node path = path + [current_node] # If reached the end node, return the path if current_node == end: return path # Explore neighbors for neighbor, weight in graph.get(current_node, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) # If the end node cannot be reached return []"},{"question":"# Coding Assessment Question Scenario You are hired by a logistics company to develop an algorithm that finds the shortest path in a warehouse grid. The task is to ensure that a worker can efficiently navigate from the entrance to the exit, avoiding obstacles. Function to Implement Implement the function `shortest_path(grid: list) -> int` which computes the shortest path from the top-left corner (`grid[0][0]`) to the bottom-right corner (`grid[n-1][n-1]`), avoiding obstacles. Input 1. `grid`: A list of lists where `grid[i][j]` is either 0 (an empty space) or 1 (an obstacle). Output The function should return an integer representing the length of the shortest path from the entrance (top-left corner) to the exit (bottom-right corner). If no such path exists, return -1. Constraints 1. The dimensions of the grid (n x n) are between 1 and 1000. 2. Each cell in the grid contains either a 0 or 1. 3. Ensure the algorithm efficiently handles edge cases such as blocked paths or completely open grids. Performance Requirements - Aim for a time complexity of O(n^2), where n is the dimension of the grid. Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path(grid) == 9 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path(grid) == -1 ``` **Note**: You can assume that the start point (top-left corner) and the end point (bottom-right corner) will always be empty spaces (0).","solution":"from collections import deque def shortest_path(grid): def inside_grid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # (x, y, distance) seen = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if inside_grid(nx, ny) and (nx, ny) not in seen and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) seen.add((nx, ny)) return -1"},{"question":"# Intermediate Problem: Implementing a Custom Caching System Scenario You are required to create a custom caching system that efficiently manages the storage and retrieval of frequent data requests. We will base the system on the Least Recently Used (LRU) eviction policy, where the least recently accessed items are removed first when the cache reaches its capacity limit. # Problem Statement Write a Python class `LRUCache` that implements an LRU cache. This class should store key-value pairs and allow for retrieval and insertion while adhering to the constraints of the LRU policy. Requirements: 1. **Methods**: - `__init__(self, capacity: int) -> None`: Initializes the cache with a specified capacity. - `get(self, key: int) -> int`: Retrieves the value associated with the key if it exists in the cache or returns -1 if the key is not found. - `put(self, key: int, value: int) -> None`: Inserts or updates the key-value pair in the cache. If the insertion exceeds the cache\'s capacity, it should evict the least recently used item. 2. **Input**: - For the `__init__` method: an integer `capacity` which is the maximum number of key-value pairs the cache can hold. - For the `get` method: an integer `key` for which the value is to be fetched. - For the `put` method: two integers, `key` and `value`, representing the key-value pair to insert or update. 3. **Output**: - The `get` method should return the value associated with the key or -1 if the key is not present. - The `put` method should not return any value. 4. **Constraints**: - Assume all input keys and values are non-negative integers. - The maximum capacity of the cache is guaranteed to be a positive integer. - Cache operations (`get` and `put`) should run in O(1) time on average. # Example: ```python # Initialize cache with capacity 2 cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Returns -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` # Additional Notes: - Use a combination of a dictionary and a doubly linked list to achieve the O(1) time complexity for the cache operations. - Ensure proper updates to the LRU order after each `get` or `put` operation.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] def _remove(self, node: Node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node): prev_node = self.tail.prev prev_node.next = node node.prev = prev_node node.next = self.tail self.tail.prev = node"},{"question":"# Coding Question: Implement a Dynamic Expression Evaluator with Variable Support **Context**: An expression evaluator is a system that computes the result of mathematical expressions. A dynamic expression evaluator can handle variables and update their values at runtime. This allows for more complex calculations and interactions within the same environment. **Challenge**: Your task is to create a `DynamicEvaluator` class that: 1. Evaluates mathematical expressions with support for dynamically defined variables. 2. Supports basic arithmetic operations: addition, subtraction, multiplication, and division. 3. Allows for the definition and redefinition of variables, which can then be used in subsequent expressions. **Function Signature**: ```python class DynamicEvaluator: def __init__(self) -> None: pass def define_variable(self, name: str, value: float) -> None: pass def evaluate_expression(self, expression: str) -> float: pass ``` **Detailed Requirements**: 1. **Initialization**: The constructor should set up any necessary data structures to store variable definitions. 2. **Defining Variables**: - The `define_variable` method should accept a variable name (string) and a value (float). - It should store the variable so that it can be used in the evaluation of subsequent expressions. - If a variable with the same name is redefined, the new value should overwrite the old value. 3. **Evaluating Expressions**: - The `evaluate_expression` method should accept an expression (string) and return its evaluated result (float). - The expressions may contain variables, numbers, and arithmetic operators: `+`, `-`, `*`, `/`. - Expressions should respect standard operator precedence. - Raise an error if an undefined variable is used in the expression. **Constraints**: - Variable names will consist of alphanumeric characters and underscores only. - Variables and their values will be stored and accessed in a case-sensitive manner. - Division by zero should raise a `ZeroDivisionError`. **Example Usage**: ```python >>> evaluator = DynamicEvaluator() >>> evaluator.define_variable(\\"x\\", 10.0) >>> evaluator.define_variable(\\"y\\", 20.0) >>> evaluator.evaluate_expression(\\"x + y\\") 30.0 >>> evaluator.evaluate_expression(\\"x * 2 + y / 2\\") 25.0 >>> evaluator.evaluate_expression(\\"x / 0\\") ZeroDivisionError: division by zero >>> evaluator.define_variable(\\"x\\", 5.0) >>> evaluator.evaluate_expression(\\"x + y\\") 25.0 ``` **Performance Expectations**: - The `evaluate_expression` method should effectively process expressions in a reasonable time frame for typical use cases, including expressions up to 100 characters long. - Memory usage should be managed appropriately to handle the storage of variables and their values.","solution":"import operator import re class DynamicEvaluator: def __init__(self) -> None: self.variables = {} def define_variable(self, name: str, value: float) -> None: self.variables[name] = value def evaluate_expression(self, expression: str) -> float: def tokenize(expr): tokens = re.findall(r\'bw+b|[+*/()-]\', expr) return tokens def shunting_yard(tokens): precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] operators = [] for token in tokens: if token.isalnum(): output.append(token) elif token in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[token]): output.append(operators.pop()) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if token.isalnum(): try: stack.append(float(token)) except ValueError: if token in self.variables: stack.append(self.variables[token]) else: raise ValueError(f\\"Undefined variable: {token}\\") else: b = stack.pop() a = stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': if b == 0: raise ZeroDivisionError(\\"division by zero\\") result = a / b stack.append(result) return stack[0] tokens = tokenize(expression) rpn = shunting_yard(tokens) return evaluate_rpn(rpn)"},{"question":"# Question Context Working with strings, particularly when parsing nested structures like HTML or JSON, often involves managing and validating parenthesis or bracket pairings. One important task is to detect the depth of nested brackets in a string. This has applications in compilers, interpreters, and data validation processes. Task Your task is to implement a function `max_nested_depth` that takes a string consisting of characters `(` and `)` and returns the maximum depth of nested parentheses. The depth of nested parentheses is the maximum level of nested `(` and `)` pairs. Ensure that your solution handles edge cases and provides validation for the input string. Function Signature ```python def max_nested_depth(s: str) -> int: Determine the maximum depth of nested parentheses in the given string. :param s: The input string containing only \'(\' and \')\' :return: An integer representing the maximum depth of nested parentheses Raises: ValueError: If the input string contains characters other than \'(\' and \')\'. Examples: >>> max_nested_depth(\\"((()))\\") 3 >>> max_nested_depth(\\"(())\\") 2 >>> max_nested_depth(\\"()()\\") 1 >>> max_nested_depth(\\"\\") 0 >>> max_nested_depth(\\"()(()))(\\") 2 ``` Constraints - The input string will only contain the characters `(` and `)` or be empty. - The function should return 0 if the input string is empty. - The function must raise a `ValueError` if the input string contains any character other than `(` and `)`. Requirements - Include proper validations to handle invalid inputs. - Handle edge cases such as empty strings and unbalanced parentheses. Example ```python s = \\"((()))\\" # Maximum depth of nested parentheses is 3 print(max_nested_depth(s)) # Output: 3 ``` Notes - Include proper docstrings and comments in your implementation. - Ensure to handle invalid inputs gracefully.","solution":"def max_nested_depth(s: str) -> int: Determine the maximum depth of nested parentheses in the given string. :param s: The input string containing only \'(\' and \')\' :return: An integer representing the maximum depth of nested parentheses Raises: ValueError: If the input string contains characters other than \'(\' and \')\'. if not all(char in \'()\' for char in s): raise ValueError(\\"Input string contains characters other than \'(\' and \')\'.\\") max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 # This condition is to check if the parentheses are unbalanced if current_depth < 0: raise ValueError(\\"Input string is unbalanced.\\") if current_depth != 0: raise ValueError(\\"Input string is unbalanced.\\") return max_depth"},{"question":"# Binary Counter Analysis You are tasked with developing a Python function that counts the number of times a given bit (0 or 1) appears consecutively in a binary string. The function should return the length of the longest sequence of consecutive occurrences of the specified bit. Function Signature ```python def longest_consecutive_bits(binary_string: str, bit: str) -> int: ``` Input - `binary_string`: A string consisting only of characters \'0\' and \'1\'. The length of the string will be between 1 and 100, inclusive. - `bit`: A single character \'0\' or \'1\' representing the bit whose consecutive occurrence we need to count. Output - Return an integer representing the length of the longest sequence of consecutive occurrences of the specified bit in the binary string. Constraints - The binary_string parameter will always be a valid non-empty string composed only of \'0\' and \'1\'. - The bit parameter will be either \'0\' or \'1\'. Example ```python >>> longest_consecutive_bits(\\"11011101111\\", \'1\') 4 >>> longest_consecutive_bits(\\"001100\\", \'0\') 2 >>> longest_consecutive_bits(\\"101010101010\\", \'1\') 1 >>> longest_consecutive_bits(\\"1111100000\\", \'0\') 5 ``` Explanation - In the first example, the longest sequence of consecutive \'1\'s is \\"1111\\", so the function returns 4. - In the second example, the longest sequence of consecutive \'0\'s is \\"00\\", so the function returns 2. - In the third example, the longest sequence of consecutive \'1\'s is \\"1\\", so the function returns 1. - In the fourth example, the longest sequence of consecutive \'0\'s is \\"00000\\", so the function returns 5.","solution":"def longest_consecutive_bits(binary_string: str, bit: str) -> int: Returns the length of the longest sequence of consecutive occurrences of the specified bit in the binary string. max_count = 0 current_count = 0 for char in binary_string: if char == bit: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"**Scenario**: A software company is developing a recommendation system that can suggest the next most viewed item given a sequence of items that a user has interacted with. You are tasked with implementing a function that uses the Markov Chain model to predict the next item in the sequence. # Problem Statement You need to implement a function with the following specifications: # Function Signature ```python def predict_next_item( item_sequence: list, transition_matrix: dict, item_space: list ) -> str: pass ``` # Input Format 1. **item_sequence (list)**: A list of items (strings) that represent the sequence of items a user has interacted with. 2. **transition_matrix (dict)**: A nested dictionary where the outer keys represent the current items, inner keys represent the next possible items, and values are the probabilities of transitioning from the current item to the next item. 3. **item_space (list)**: A list of all possible items that can be recommended. # Output Format **Returns (str)**: The predicted next most viewed item. # Constraints - All probabilities in the transition_matrix are valid (i.e., between 0 and 1) and each set of transitions from one item sums to 1. - The item_sequence list contains only string elements and is non-empty. - The item_space list contains distinct string elements. - The transition_matrix is properly formatted with correct keys and value types as described. # Performance Requirements - Your function should be efficient enough to handle large sequences and large item spaces. # Examples ```python # Example 1 sequence = [\\"item1\\", \\"item2\\", \\"item3\\"] trans_matrix = { \\"item1\\": {\\"item2\\": 0.8, \\"item3\\": 0.2}, \\"item2\\": {\\"item1\\": 0.6, \\"item3\\": 0.4}, \\"item3\\": {\\"item1\\": 0.3, \\"item2\\": 0.7}, } items = [\\"item1\\", \\"item2\\", \\"item3\\"] assert predict_next_item(sequence, trans_matrix, items) == \\"item2\\" # Example 2 sequence = [\\"bookA\\", \\"bookB\\", \\"bookC\\"] trans_matrix = { \\"bookA\\": {\\"bookB\\": 0.5, \\"bookD\\": 0.5}, \\"bookB\\": {\\"bookA\\": 0.4, \\"bookC\\": 0.6}, \\"bookC\\": {\\"bookA\\": 0.3, \\"bookB\\": 0.7}, } items = [\\"bookA\\", \\"bookB\\", \\"bookC\\", \\"bookD\\"] assert predict_next_item(sequence, trans_matrix, items) == \\"bookC\\" ``` You are required to implement the given function according to the above specifications, ensuring to handle all the edge cases and input constraints properly.","solution":"def predict_next_item(item_sequence, transition_matrix, item_space): Predicts the next most viewed item using the given item sequence and a transition matrix based on the Markov Chain model. Args: item_sequence (list): A list of items that represent the sequence of items a user has interacted with. transition_matrix (dict): A nested dictionary where the outer keys represent the current items, inner keys represent the next possible items, and values are the probabilities of transitioning from the current item to the next item. item_space (list): A list of all possible items that can be recommended. Returns: str: The predicted next most viewed item. if not item_sequence: raise ValueError(\\"The item_sequence list is empty.\\") last_item = item_sequence[-1] if last_item not in transition_matrix: raise ValueError(f\\"The last item {last_item} is not in the transition matrix.\\") next_items_probabilities = transition_matrix[last_item] # Find the item with the highest transition probability from the last item next_item = max(next_items_probabilities, key=next_items_probabilities.get) return next_item"},{"question":"# Weather Data Aggregator You have been assigned to create an enhanced weather data aggregator. This system should fetch the current weather data from a public API and process it efficiently. Requirements: 1. **Function `fetch_weather_data`**: - Takes an API key and a list of city names (strings) as inputs. - Asynchronously fetches the current weather data for each city using the OpenWeatherMap API. - Includes error handling for API request failures and missing data fields. - Validates the JSON response to ensure it contains the expected structure. - Returns a dictionary where the keys are city names and values are their corresponding weather descriptions. 2. **Function `write_weather_to_file`**: - Takes the dictionary of weather data and a filename (string). - Writes the weather descriptions to the specified file, each city\'s weather on a new line formatted as `<city>: <description>`. 3. **Constraints**: - You must use the `aiohttp` library for making asynchronous requests. - Timeout for each HTTP request should be 5 seconds. - Ensure efficient use of resources and handle potential exceptions gracefully. Input & Output Formats: * The `fetch_weather_data` function should return a dictionary with city names as keys and weather descriptions as values. * The `write_weather_to_file` function should not return anything, but must write the data to a file. Example: Given a hypothetical API key `\\"test_api_key\\"` and a list of cities `[\\"London\\", \\"Paris\\"]`, the script should: 1. Fetch the weather data for each city. 2. Handle any potential errors gracefully. 3. Write the weather data to a file named `weather_data.txt`. ```python import aiohttp import asyncio import json _WEATHER_API = \\"http://api.openweathermap.org/data/2.5/weather?q={}&appid={}\\" async def fetch_weather_data(api_key: str, cities: list) -> dict: async with aiohttp.ClientSession() as session: weather_data = {} for city in cities: try: async with session.get(_WEATHER_API.format(city, api_key), timeout=5) as response: if response.status != 200: raise Exception(f\\"Error fetching data for {city}: {response.status}\\") json_response = await response.json() weather_description = json_response.get(\'weather\', [])[0].get(\'description\', \'No description\') weather_data[city] = weather_description except Exception as e: print(f\\"An error occurred for city {city}: {e}\\") weather_data[city] = \'Could not fetch data\' return weather_data def write_weather_to_file(weather_data: dict, filename: str) -> None: try: with open(filename, \'w\') as file: for city, description in weather_data.items(): file.write(f\\"{city}: {description}n\\") except IOError as e: print(f\\"File operation error: {e}\\") if __name__ == \\"__main__\\": api_key = \\"<Your OpenWeatherMap API key goes here>\\" cities = [\\"London\\", \\"Paris\\", \\"New York\\"] weather_data = asyncio.run(fetch_weather_data(api_key, cities)) write_weather_to_file(weather_data, \'weather_data.txt\') ```","solution":"import aiohttp import asyncio import json from aiohttp import ClientTimeout _WEATHER_API = \\"http://api.openweathermap.org/data/2.5/weather?q={}&appid={}\\" async def fetch_weather_data(api_key: str, cities: list) -> dict: async with aiohttp.ClientSession(timeout=ClientTimeout(total=5)) as session: weather_data = {} for city in cities: try: async with session.get(_WEATHER_API.format(city, api_key)) as response: if response.status != 200: raise Exception(f\\"Error fetching data for {city}: {response.status}\\") json_response = await response.json() weather_description = json_response.get(\'weather\', [])[0].get(\'description\', \'No description\') weather_data[city] = weather_description except Exception as e: print(f\\"An error occurred for city {city}: {e}\\") weather_data[city] = \'Could not fetch data\' return weather_data def write_weather_to_file(weather_data: dict, filename: str) -> None: try: with open(filename, \'w\') as file: for city, description in weather_data.items(): file.write(f\\"{city}: {description}n\\") except IOError as e: print(f\\"File operation error: {e}\\")"},{"question":"# Genetic Algorithm for Course Schedule Optimization **Context**: A university wants to optimize the course schedule for the next semester to balance student preferences and the availability of professors. They have decided to use a genetic algorithm to find the optimal schedule. # Task: Implement the `genetic_algorithm` function to optimize the course schedule. You are given a `CourseSchedule` class with the following attributes: ```python class CourseSchedule: def __init__(self, schedule): self.schedule = schedule # A dictionary mapping course names to time slots and professors def fitness(self) -> float: Returns a float representing the fitness score of the schedule. Higher scores indicate better overall satisfaction with the schedule. pass # Defined elsewhere def crossover(self, other) -> list: Performs crossover operation with another CourseSchedule instance and returns a list of two offspring CourseSchedule instances. pass # Defined elsewhere def mutate(self, mutation_rate: float) -> None: Mutates the schedule based on the `mutation_rate`. pass # Defined elsewhere ``` # Function Signature: ```python def genetic_algorithm( initial_population: list, population_size: int, mutation_rate: float, crossover_rate: float, generations: int ) -> CourseSchedule: pass ``` # Input: - `initial_population (list)`: A list of `CourseSchedule` instances representing the starting population. - `population_size (int)`: The size of the population in each generation. - `mutation_rate (float)`: The probability of mutation for each schedule. - `crossover_rate (float)`: The probability of performing crossover between two schedules. - `generations (int)`: The number of generations to run the algorithm. # Output: - A `CourseSchedule` instance representing the optimal schedule with the highest fitness score. # Constraints: - Ensure the algorithm properly handles the crossover and mutation processes. - Optimize for the best possible schedule within the given number of generations. - Handle cases where the initial population may contain schedules with low fitness. # Example: ```python # Assume we have a proper implementation of `CourseSchedule` class initial_population = [CourseSchedule({...}), CourseSchedule({...}), CourseSchedule({...})] optimized_schedule = genetic_algorithm(initial_population, population_size=50, mutation_rate=0.05, crossover_rate=0.7, generations=100) print(f\\"Optimized Schedule: {optimized_schedule.schedule} with Fitness Score: {optimized_schedule.fitness()}\\") ``` **Expectation**: A solution that demonstrates your understanding of genetic algorithms, effectively balancing mutation and crossover to optimize a course schedule.","solution":"import random class CourseSchedule: def __init__(self, schedule): self.schedule = schedule # A dictionary mapping course names to time slots and professors def fitness(self) -> float: Returns a float representing the fitness score of the schedule. Higher scores indicate better overall satisfaction with the schedule. # This is a stub and should be replaced with actual fitness calculation logic. return random.uniform(0, 1) def crossover(self, other): Performs crossover operation with another CourseSchedule instance and returns a list of two offspring CourseSchedule instances. # This should be replaced with actual crossover logic. offspring1_schedule = {k: (self.schedule[k] if random.random() < 0.5 else other.schedule[k]) for k in self.schedule} offspring2_schedule = {k: (other.schedule[k] if random.random() < 0.5 else self.schedule[k]) for k in self.schedule} return [CourseSchedule(offspring1_schedule), CourseSchedule(offspring2_schedule)] def mutate(self, mutation_rate: float) -> None: Mutates the schedule based on the `mutation_rate`. # This should be replaced with actual mutation logic. for course in self.schedule: if random.random() < mutation_rate: # Perform some mutation; here simply randomize a new timeslot/professor self.schedule[course] = (\'new_time\', \'new_professor\') def genetic_algorithm( initial_population: list, population_size: int, mutation_rate: float, crossover_rate: float, generations: int ) -> CourseSchedule: population = initial_population for generation in range(generations): # Evaluate fitness population_fitness = [(schedule, schedule.fitness()) for schedule in population] # Select the best individuals (elitism) population_fitness.sort(key=lambda x: x[1], reverse=True) population = [x[0] for x in population_fitness[:population_size]] # Generate new offsprings new_population = [] while len(new_population) < population_size: parent1, parent2 = random.choices(population, k=2) if random.random() < crossover_rate: offspring = parent1.crossover(parent2) else: offspring = [parent1, parent2] new_population.extend(offspring) # Mutate the new population for schedule in new_population: schedule.mutate(mutation_rate) # Replace population with new_generation population = new_population[:population_size] # Evaluate fitness one last time and return the best schedule best_schedule = max(population, key=lambda schedule: schedule.fitness()) return best_schedule"},{"question":"# Context You are developing a software that processes financial transactions. Part of this involves ensuring the integrity of transaction IDs, which must be unique and consist of alphanumeric characters. # Task Write a function `generate_transaction_id` that generates a unique alphanumeric transaction ID of a specified length. Additionally, implement a validation function `is_valid_transaction_id` that checks if the given transaction ID meets the required criteria of being unique and only containing alphanumeric characters. # Requirements * The `generate_transaction_id` function should: - Take one parameter: an integer `length` representing the desired length of the transaction ID. - Return a unique alphanumeric transaction ID of the specified length. * The `is_valid_transaction_id` function should: - Take one parameter: a string `transaction_id`. - Return `True` if the `transaction_id` is unique and consists only of alphanumeric characters. - Return `False` otherwise. * Ensure that IDs generated by `generate_transaction_id` are always unique within the scope of the program. * Add docstrings and appropriate error handling to both functions. # Function Signatures ```python import random import string def generate_transaction_id(length: int) -> str: pass def is_valid_transaction_id(transaction_id: str) -> bool: pass ``` # Example Usage ```python >>> transaction_id1 = generate_transaction_id(10) >>> transaction_id2 = generate_transaction_id(10) >>> transaction_id1 \'4f9Dk2L8rT\' >>> transaction_id2 \'7s5GkL8hZ2\' >>> is_valid_transaction_id(transaction_id1) True >>> is_valid_transaction_id(\\"123456789\\") False >>> transaction_id1 == transaction_id2 False ``` # Constraints and Considerations * The `generate_transaction_id` function should ensure that the IDs are random yet unique. * The `is_valid_transaction_id` function should check that the ID contains only alphanumeric characters (both uppercase and lowercase) and is unique. * Use a set to store generated transaction IDs to ensure uniqueness. * Handle possible edge cases, such as invalid length for `generate_transaction_id` (e.g., non-positive integer values). * Handle possible edge cases for `is_valid_transaction_id`, such as empty strings or non-string inputs.","solution":"import random import string # A set to keep track of generated transaction IDs to ensure uniqueness. generated_ids = set() def generate_transaction_id(length: int) -> str: Generates a unique alphanumeric transaction ID of the specified length. Args: length (int): Desired length of the transaction ID. Returns: str: A unique alphanumeric transaction ID. Raises: ValueError: If length is not a positive integer. if not isinstance(length, int) or length <= 0: raise ValueError(\\"Length must be a positive integer.\\") while True: transaction_id = \'\'.join(random.choices(string.ascii_letters + string.digits, k=length)) if transaction_id not in generated_ids: generated_ids.add(transaction_id) return transaction_id def is_valid_transaction_id(transaction_id: str) -> bool: Validates if the transaction ID is unique and consists only of alphanumeric characters. Args: transaction_id (str): The transaction ID to validate. Returns: bool: True if the ID is unique and alphanumeric, False otherwise. if not isinstance(transaction_id, str) or not transaction_id.isalnum(): return False if transaction_id in generated_ids: return True return False"},{"question":"# Problem Statement Given a list of integers, your task is to identify any values that are missing from the sequence from the minimum value to the maximum value in the list. Once identified, return these missing values in a sorted list. # Function Signature ```python def find_missing_elements(arr: [int]) -> [int]: pass ``` # Input - A list of integers `arr` where 1 <= len(arr) <= 100 and each integer `-1000 <= arr[i] <= 1000`. # Output - A sorted list of integers representing the missing values from the sequence from `min(arr)` to `max(arr)`. # Example ```python assert find_missing_elements([-2, -1, 1, 3, 4]) == [0, 2] assert find_missing_elements([1, 2, 4, 6]) == [3, 5] assert find_missing_elements([10, 7, 6, 2]) == [3, 4, 5, 8, 9] ``` # Constraints - You must not use external libraries or built-in functions designed specifically for finding sets or computing missing elements. - Ensure your solution is efficient and capable of handling the upper limits of input size. # Performance - Aim for a time complexity of O(n + m) where `n` is the length of the input list and `m` is the range from the minimum to the maximum value in the list. - Space complexity should be O(m) for the storage of possible missing elements where `m` represents the count of numbers in the range from `min(arr)` to `max(arr)`. # Example Execution ```python find_missing_elements([-2, -1, 1, 3, 4]) # Output: [0, 2] find_missing_elements([1, 2, 4, 6]) # Output: [3, 5] find_missing_elements([10, 7, 6, 2]) # Output: [3, 4, 5, 8, 9] ``` # Context This problem tests your ability to manipulate and analyze ranges within a list of numbers. It requires a solid understanding of lists and range operations. Missing elements in sequences are commonly addressed in data quality analysis, sequence validations, and various algorithmic solutions involving continuity of numerical series.","solution":"def find_missing_elements(arr): Returns a sorted list of the missing numbers in the range from min(arr) to max(arr). if not arr: # Edge case for empty list return [] min_val = min(arr) max_val = max(arr) actual_set = set(arr) expected_set = set(range(min_val, max_val + 1)) missing_elements = list(expected_set - actual_set) missing_elements.sort() # Ensure the result is sorted return missing_elements"},{"question":"# Problem Statement You are tasked with creating a utility for managing user tasks stored in a JSON file. The JSON file contains an array of tasks, each with a title, description, and status (either \\"completed\\" or \\"pending\\"). Your module should provide functionalities to list, add, delete, and update tasks, as well as to filter tasks by their status. # Requirements 1. **Listing Tasks**: Implement a function to list all tasks, optionally filtered by status. 2. **Adding a Task**: Implement a function to add a new task to the JSON file. 3. **Deleting a Task**: Implement a function to delete a task by its title. 4. **Updating a Task**: Implement a function to update the details of a task. 5. **Error Handling**: Handle errors gracefully, such as handling nonexistent tasks or issues with reading/writing the JSON file. # Constraints - You can use standard Python libraries for handling JSON files. - Assume a maximum of 100 tasks. # JSON File Structure Here is an example of the JSON file structure: ```json [ {\\"title\\": \\"Task 1\\", \\"description\\": \\"Description 1\\", \\"status\\": \\"completed\\"}, {\\"title\\": \\"Task 2\\", \\"description\\": \\"Description 2\\", \\"status\\": \\"pending\\"} ] ``` # Function Signatures ```python import json class TaskManager: def __init__(self, file_path: str): self.file_path = file_path def list_tasks(self, status: str = None) -> list[dict]: # Implement this function pass def add_task(self, title: str, description: str, status: str = \\"pending\\"): # Implement this function pass def delete_task(self, title: str): # Implement this function pass def update_task(self, title: str, new_title: str = None, new_description: str = None, new_status: str = None): # Implement this function pass ``` # Example Usage ```python # Initialize the task manager with the path to your JSON file task_manager = TaskManager(\\"tasks.json\\") # Add a new task task_manager.add_task(\\"New Task\\", \\"This is a new task\\", \\"pending\\") # List all tasks print(task_manager.list_tasks()) # List only completed tasks print(task_manager.list_tasks(status=\\"completed\\")) # Update an existing task task_manager.update_task(\\"New Task\\", new_title=\\"Updated Task\\", new_status=\\"completed\\") # Delete a task task_manager.delete_task(\\"Updated Task\\") ``` # Expected Behavior 1. **Input**: Task details and commands (add, list, delete, update). 2. **Output**: Print the list of tasks based on the operations performed. # Example ```python task_manager = TaskManager(\\"tasks.json\\") task_manager.add_task(\\"Read Book\\", \\"Read \'Sapiens\' by Yuval Noah Harari\\", \\"pending\\") task_manager.update_task(\\"Read Book\\", new_status=\\"completed\\") print(task_manager.list_tasks(status=\\"completed\\")) ``` Example output: ```json [ {\\"title\\": \\"Read Book\\", \\"description\\": \\"Read \'Sapiens\' by Yuval Noah Harari\\", \\"status\\": \\"completed\\"} ] ```","solution":"import json import os class TaskManager: def __init__(self, file_path: str): self.file_path = file_path self._ensure_file() def _ensure_file(self): if not os.path.exists(self.file_path): with open(self.file_path, \'w\') as f: json.dump([], f) def _read_tasks(self): with open(self.file_path, \'r\') as f: return json.load(f) def _write_tasks(self, tasks): with open(self.file_path, \'w\') as f: json.dump(tasks, f, indent=4) def list_tasks(self, status: str = None) -> list[dict]: tasks = self._read_tasks() if status: return [task for task in tasks if task.get(\'status\') == status] return tasks def add_task(self, title: str, description: str, status: str = \\"pending\\"): tasks = self._read_tasks() if any(task[\'title\'] == title for task in tasks): raise ValueError(\\"Task with this title already exists\\") tasks.append({\\"title\\": title, \\"description\\": description, \\"status\\": status}) self._write_tasks(tasks) def delete_task(self, title: str): tasks = self._read_tasks() tasks = [task for task in tasks if task[\'title\'] != title] self._write_tasks(tasks) def update_task(self, title: str, new_title: str = None, new_description: str = None, new_status: str = None): tasks = self._read_tasks() for task in tasks: if task[\'title\'] == title: if new_title: task[\'title\'] = new_title if new_description: task[\'description\'] = new_description if new_status: task[\'status\'] = new_status break else: raise ValueError(\\"Task with this title does not exist\\") self._write_tasks(tasks)"},{"question":"# Coding Assessment Question Context You are working with a team of developers to create a new sorting feature for an e-commerce platform. The goal of this feature is to sort a list of product prices in ascending order. However, there is a twist: the list includes several \\"outlier\\" prices that should not influence the sort order. Specifically, prices that are less than 0 (negative values indicating potential data errors) and prices that are more than 10,000 (potential outlier mistakes) should be excluded from the sorting process. Objective Write a function `filter_and_sort_prices(prices: list[float]) -> list[float]` that filters out the outlier prices and returns the remaining prices sorted in ascending order. Input and Output - **Input**: A list of float values `prices` representing product prices which may include negative values and values exceeding 10,000. - **Output**: A list of float values representing the filtered and sorted prices. Constraints - The length of `prices` will be between 0 and 1,000 inclusive. - Prices can range from floating point numbers around -10,000 to 20,000 inclusive. - The solution should aim for a time complexity of O(n log n) where n is the number of elements in `prices`. Example ```python def filter_and_sort_prices(prices: list[float]) -> list[float]: Filter out prices that are less than 0 or more than 10,000, and sort the remaining prices. Args: - prices (list[float]): List of product prices. Returns: - list[float]: Filtered and sorted prices. pass # Your implementation goes here # Example Usage prices = [150.5, -20.0, 5000.0, 10500.0, 750.25] print(filter_and_sort_prices(prices)) # Output: [150.5, 750.25, 5000.0] prices = [0.0, 12000.0, 150.0, -5.0, 8000.0] print(filter_and_sort_prices(prices)) # Output: [0.0, 150.0, 8000.0] ``` Notes Ensure that your implementation can efficiently handle lists of varying lengths and mixed values, and that you thoroughly handle edge cases such as empty lists and lists with all outliers.","solution":"def filter_and_sort_prices(prices: list[float]) -> list[float]: Filter out prices that are less than 0 or more than 10,000, and sort the remaining prices. Args: - prices (list[float]): List of product prices. Returns: - list[float]: Filtered and sorted prices. filtered_prices = [price for price in prices if 0 <= price <= 10000] return sorted(filtered_prices)"},{"question":"# Managing an Employee Hierarchy Context Many organizations use hierarchical systems to manage their workforce. Representing an organizational hierarchy as a tree structure where each node represents an employee and the edges represent the reporting relationship is a common practice. Traversing such data structures is critical to analyze organizational workflows and reporting chains. Task Given a list of tuples representing the manager-employee relationships in an organization, implement a function to construct the organizational hierarchy and determine the longest reporting chain (i.e., the distance from the root to the deepest node in the tree). Function Signature ```python def find_longest_reporting_chain(relations: list[tuple[int, int]]) -> int: Given a list of tuples where each tuple (manager, employee) represents a reporting relationship, construct the organizational hierarchy and return the length of the longest reporting chain. :param relations: List of tuples where each tuple (manager, employee) represents a direct reporting relationship. :return: Integer representing the longest reporting chain in the organization. Constraints: - The length of the relations list will be at most 1000. - All employee and manager IDs will be unique integers in the range [1, 1000]. - There will always be exactly one root, i.e., a single top-level manager. ``` Explanation **Input:** 1. `relations` list of tuples, where each tuple contains two integers representing a manager-employee relationship. **Output:** - Return the length of the longest reporting chain in the constructed organization hierarchy. **Example:** ```python assert find_longest_reporting_chain([(1, 2), (1, 3), (3, 4), (3, 5), (2, 6)]) == 3 assert find_longest_reporting_chain([(1, 2), (1, 3), (2, 4)]) == 2 ``` Constraints - You can assume there will always be a valid hierarchy with exactly one root manager who doesn\'t report to anyone else. - The input tuples are guaranteed to form a valid tree structure with no cycles. Hints - Use a tree-building approach similar to that used for binary trees, but adapted for this generic, non-binary tree structure. - Perform a depth-first search (DFS) or breadth-first search (BFS) traversal to determine the height of the tree once constructed.","solution":"from collections import defaultdict def find_longest_reporting_chain(relations): Given a list of tuples where each tuple (manager, employee) represents a reporting relationship, construct the organizational hierarchy and return the length of the longest reporting chain. :param relations: List of tuples where each tuple (manager, employee) represents a direct reporting relationship. :return: Integer representing the longest reporting chain in the organization. def dfs(node, depth): nonlocal max_depth max_depth = max(max_depth, depth) for subordinate in tree[node]: dfs(subordinate, depth + 1) # Build an adjacency list for the tree tree = defaultdict(list) all_employees = set() all_managers = set() for manager, employee in relations: tree[manager].append(employee) all_employees.add(employee) all_managers.add(manager) # Find the root (top-level manager) who is not anyone\'s employee root = (all_managers - all_employees).pop() # Perform DFS to determine the height of the tree max_depth = 0 dfs(root, 1) return max_depth"},{"question":"# Coding Question: Temperature Conversion with Heat Energy Calculation You are developing a program that calculates the heat energy required to raise the temperature of a given mass of water. Given the existing conversion from Celsius to Fahrenheit, extend the function to compute the heat energy needed to raise the temperature of the water and return the final temperature in both Celsius and Fahrenheit. **Problem Statement**: Extend the function to include the calculation of the heat energy required and return the final temperature in both Celsius and Fahrenheit. Function Signature ```python def temperature_conversion_and_energy(mass: float, initial_temp_celsius: float, final_temp_celsius: float) -> Tuple[float, float, float]: Computes the final temperature in Fahrenheit and the heat energy required. Args: mass (float): mass of water in kilograms. initial_temp_celsius (float): initial temperature of the water in Celsius. final_temp_celsius (float): final temperature of the water in Celsius. Returns: Tuple[float, float, float]: Returns a tuple with: - final_temp_celsius (float): final temperature in Celsius. - final_temp_fahrenheit (float): final temperature in Fahrenheit. - heat_energy (float): heat energy required in Joules. Raises: ValueError: if any of the input values are negative or if final_temp_celsius is less than initial_temp_celsius. ``` Inputs: |Name | Units | Type | |--------------------|-------------|-------| |mass | (in kg) | float | |initial_temp_celsius| (in °C) | float | |final_temp_celsius | (in °C) | float | Outputs: |Name | Units | Type | |---------------------|-------------|-------| |final_temp_celsius | (in °C) | float | |final_temp_fahrenheit| (in °F) | float | |heat_energy | (in Joules) | float | Constraints: 1. All inputs must be non-negative. 2. The final temperature in Celsius must be greater than or equal to the initial temperature in Celsius. 3. The specific heat capacity of water is 4184 J/(kg*°C). 4. Use the formula `heat_energy = mass * specific_heat_capacity * (final_temp_celsius - initial_temp_celsius)` to compute heat energy. 5. Use the formula `final_temp_fahrenheit = (final_temp_celsius * 9/5) + 32` to convert Celsius to Fahrenheit. Example: ```python >>> temperature_conversion_and_energy(2, 25, 75) (75.0, 167.0, 418400.0) >>> temperature_conversion_and_energy(0.5, 20, 30) (30.0, 86.0, 20920.0) ``` **Note**: Ensure robust handling of invalid inputs by raising `ValueError` if negative values are provided or if final_temp_celsius is less than initial_temp_celsius. **Performance Requirements**: * The time complexity should remain O(1), as both heat energy and temperature conversions are computed using constant-time operations.","solution":"from typing import Tuple def temperature_conversion_and_energy(mass: float, initial_temp_celsius: float, final_temp_celsius: float) -> Tuple[float, float, float]: Computes the final temperature in Fahrenheit and the heat energy required. Args: mass (float): mass of water in kilograms. initial_temp_celsius (float): initial temperature of the water in Celsius. final_temp_celsius (float): final temperature of the water in Celsius. Returns: Tuple[float, float, float]: Returns a tuple with: - final_temp_celsius (float): final temperature in Celsius. - final_temp_fahrenheit (float): final temperature in Fahrenheit. - heat_energy (float): heat energy required in Joules. Raises: ValueError: if any of the input values are negative or if final_temp_celsius is less than initial_temp_celsius. # Error checking for invalid inputs if mass < 0 or initial_temp_celsius < 0 or final_temp_celsius < 0: raise ValueError(\\"Negative values are not allowed.\\") if final_temp_celsius < initial_temp_celsius: raise ValueError(\\"Final temperature must not be less than initial temperature.\\") # Constants specific_heat_capacity = 4184 # J/(kg*°C) # Calculating heat energy heat_energy = mass * specific_heat_capacity * (final_temp_celsius - initial_temp_celsius) # Converting final temperature to Fahrenheit final_temp_fahrenheit = (final_temp_celsius * 9/5) + 32 return final_temp_celsius, final_temp_fahrenheit, heat_energy"},{"question":"# Question You are tasked with implementing a function to determine the top N most frequent words in a given text. Words are defined as contiguous sequences of alphabetic characters and should be treated case-insensitively (i.e., \\"Word\\" is the same as \\"word\\"). Exclude common stopwords (e.g., \\"the\\", \\"is\\", \\"in\\", etc.) from the frequency count. The stopwords given are: [\\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"by\\", \\"for\\", \\"from\\", \\"has\\", \\"he\\", \\"in\\", \\"is\\", \\"it\\", \\"its\\", \\"of\\", \\"on\\", \\"that\\", \\"the\\", \\"to\\", \\"was\\", \\"were\\", \\"will\\", \\"with\\"]. Your task is to write a function `top_n_frequent_words(text: str, n: int) -> List[str]:` that takes a string representing the text and an integer `n` representing the number of top frequent words to return. The function should return a list of the top `n` most frequent words, sorted by frequency in descending order. If two words have the same frequency, they should be sorted lexicographically. # Examples ```python >>> top_n_frequent_words(\\"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing.\\", 3) [\'lance\', \'a\', \'an\'] >>> top_n_frequent_words(\\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness.\\", 4) [\'age\', \'it\', \'times\', \'was\'] >>> top_n_frequent_words(\\"To be or not to be, that is the question.\\", 2) [\'be\', \'not\'] ``` # Constraints 1. The text string can be of any length, but it will not contain more than 10,000 words. 2. The input `n` will be a positive integer less than or equal to the number of unique words in the text. 3. The function should ignore punctuation and treat words case-insensitively. # Notes: - Use regular expressions to identify and extract words from the text. - Utilize a collections data structure to keep track of word frequencies. - You may assume that the input text will always contain at least one valid word that is not a stopword.","solution":"import re from collections import Counter from typing import List STOPWORDS = set([ \\"a\\", \\"an\\", \\"and\\", \\"are\\", \\"as\\", \\"at\\", \\"be\\", \\"by\\", \\"for\\", \\"from\\", \\"has\\", \\"he\\", \\"in\\", \\"is\\", \\"it\\", \\"its\\", \\"of\\", \\"on\\", \\"that\\", \\"the\\", \\"to\\", \\"was\\", \\"were\\", \\"will\\", \\"with\\" ]) def top_n_frequent_words(text: str, n: int) -> List[str]: # Convert the text to lowercase and use regex to find all words words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Filter out stopwords words = [word for word in words if word not in STOPWORDS] # Use Counter to count the frequency of each word word_counts = Counter(words) # Get the most common words most_common = word_counts.most_common() # Sort by frequency (descending) and then alphabetically (ascending) most_common.sort(key=lambda x: (-x[1], x[0])) # Get the top N frequent words return [word for word, _ in most_common[:n]]"},{"question":"# Binary Search Tree Insertion and Search Context: Binary Search Trees (BSTs) are a fundamental data structure used for efficient searching, insertion, and deletion operations. For this challenge, you will implement a BST with functionalities to insert new elements and search for elements. Task: Write a class `BinarySearchTree` that supports insertion of elements and searching for a specific element. Implement the `insert` and `search` methods as described below: Class and Method Signatures: ```python class BinarySearchTree: def __init__(self): self.root = None class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key: int) -> None: pass def search(self, key: int) -> bool: pass ``` Input: * `insert(key: int)`: Inserts the given integer key into the BST. * `search(key: int)`: Searches for the given integer key in the BST and returns `True` if found, otherwise `False`. Output: * `insert` does not return any value. * `search` returns a boolean indicating whether the key exists in the BST. Constraints: * All keys are integers. * Multiple insertions of the same key are not allowed. * The BST should handle up to 10^5 insertions and searches in any combination efficiently. Example: ```python # Example to outline usage of BinarySearchTree bst = BinarySearchTree() # Inserting keys bst.insert(50) bst.insert(30) bst.insert(20) bst.insert(40) bst.insert(70) bst.insert(60) bst.insert(80) # Searching for keys assert bst.search(50) == True # Element is present assert bst.search(25) == False # Element is not present ``` Notes: - Ensure proper insertions and search operations maintain the BST properties. - Consider edge cases such as attempts to insert duplicate keys and searches in an empty tree.","solution":"class BinarySearchTree: def __init__(self): self.root = None class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key: int) -> None: if self.root is None: self.root = self.TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = self.TreeNode(key) else: self._insert_recursive(node.left, key) elif key > node.val: if node.right is None: node.right = self.TreeNode(key) else: self._insert_recursive(node.right, key) def search(self, key: int) -> bool: return self._search_recursive(self.root, key) def _search_recursive(self, node, key): if node is None: return False if node.val == key: return True elif key < node.val: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key)"},{"question":"# Question: Implementing Zeros and Ones Counter from Matrix You\'re tasked with implementing a function that takes a matrix (a list of lists) as input and returns a tuple containing two elements: the count of zeros and the count of ones in the matrix. The input matrix consists only of zeros and ones. # Function Signature ```python def count_zeros_ones(matrix: List[List[int]]) -> Tuple[int, int]: Count the number of zeros and ones in the given binary matrix. :param matrix: List[List[int]] - A binary matrix with only 0s and 1s. :return: Tuple[int, int] - A tuple with two integers: count of zeros and count of ones. >>> count_zeros_ones([[0, 1, 0], [1, 1, 0], [0, 0, 1]]) (5, 4) >>> count_zeros_ones([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) (0, 9) ``` # Input - `matrix`: A list of lists, where each inner list represents a row of the matrix and contains binary values (0s and 1s). # Output - A tuple containing two integers: - The first integer is the count of zeros in the matrix. - The second integer is the count of ones in the matrix. # Constraints - The matrix can have up to 100 rows and each row can have up to 100 columns. - The matrix contains only binary values (0s and 1s). # Example ```python matrix = [ [0, 1, 0], [1, 1, 0], [0, 0, 1] ] output = count_zeros_ones(matrix) # Expected output: (5, 4) matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] output = count_zeros_ones(matrix) # Expected output: (0, 9) ``` # Notes: - Ensure the function handles both empty matrices and large matrices correctly. - You can assume that the input is always a well-formed matrix of binary values. ```python from typing import List, Tuple def count_zeros_ones(matrix: List[List[int]]) -> Tuple[int, int]: zero_count = 0 one_count = 0 for row in matrix: for value in row: if value == 0: zero_count += 1 elif value == 1: one_count += 1 return zero_count, one_count ```","solution":"from typing import List, Tuple def count_zeros_ones(matrix: List[List[int]]) -> Tuple[int, int]: zero_count = 0 one_count = 0 for row in matrix: for value in row: if value == 0: zero_count += 1 elif value == 1: one_count += 1 return zero_count, one_count"},{"question":"# Question You are tasked with developing a utility for handling a list of integers. Your utility should include functionalities for calculating statistical metrics and searching through the list efficiently. # Function Specification **Task**: * Write a function `calculate_statistics` that calculates and returns the mean, median, and mode of the list of integers. * Write another function `binary_search` that performs a binary search on the sorted list of integers. **Functions to Implement**: ```python def calculate_statistics(numbers: List[int]) -> Dict[str, float]: pass def binary_search(numbers: List[int], target: int) -> int: pass ``` **Parameters**: * `calculate_statistics`: * `numbers` (List[int]): A list of integers. * `binary_search`: * `numbers` (List[int]): A sorted list of integers. * `target` (int): The integer value to search for. **Returns**: * `calculate_statistics` should return a dictionary with the keys \\"mean\\", \\"median\\", \\"mode\\", and their corresponding values. * `binary_search` should return the index of the `target` if it exists in the list and -1 if it does not. # Constraints: * The list of integers can be very large. * The list passed to `binary_search` is always sorted in non-decreasing order. * If there is more than one mode, return any one of them. * Implement searching efficiently using the binary search algorithm. # Examples: ```python numbers = [4, 2, 5, 1, 2, 7, 1, 2, 3] statistics = calculate_statistics(numbers) print(statistics) # Output: {\\"mean\\": 3.0, \\"median\\": 2, \\"mode\\": 2} sorted_numbers = [1, 2, 3, 4, 5, 6, 7] index = binary_search(sorted_numbers, 5) print(index) # Output: 4 index = binary_search(sorted_numbers, 8) print(index) # Output: -1 ``` # Implementation Notes: * For `calculate_statistics`, use appropriate libraries if needed for efficient computation. * For `binary_search`, follow the standard binary search algorithm, ensuring efficient execution, especially for large lists. # Performance Considerations: * Optimize the calculation of statistical metrics to handle very large lists. * Ensure the binary search is implemented in a time complexity of O(log n).","solution":"from typing import List, Dict from collections import Counter import statistics def calculate_statistics(numbers: List[int]) -> Dict[str, float]: Calculates the mean, median, and mode of the list of integers. Args: numbers (List[int]): A list of integers. Returns: Dict[str, float]: A dictionary with keys \\"mean\\", \\"median\\", \\"mode\\". mean = statistics.mean(numbers) median = statistics.median(numbers) mode = statistics.mode(numbers) return {\\"mean\\": mean, \\"median\\": median, \\"mode\\": mode} def binary_search(numbers: List[int], target: int) -> int: Performs a binary search on the sorted list of integers. Args: numbers (List[int]): A sorted list of integers. target (int): The integer value to search for. Returns: int: The index of the target if it exists in the list, otherwise -1. left, right = 0, len(numbers) - 1 while left <= right: mid = (left + right) // 2 if numbers[mid] == target: return mid elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Problem Statement: You are required to implement a function that takes an integer `n` and returns the `n`th number in the sequence of Fibonacci numbers. However, to optimize the computation for large values of `n`, you need to use matrix exponentiation method. Fibonacci sequence is defined as: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)`, for `n > 1` # Function Signature: ``` def fibonacci(n: int) -> int: ``` # Input: - `n`: an integer representing the position in the Fibonacci sequence. # Output: - An integer which is the `n`th Fibonacci number. # Constraints: * The input `n` will be an integer in the range [0, 10^9]. # Example: Example 1: ``` Input: n = 0 Output: 0 ``` Example 2: ``` Input: n = 1 Output: 1 ``` Example 3: ``` Input: n = 10 Output: 55 ``` # Requirements: - Optimize for both time and space complexity. - Use an iterative approach with matrix exponentiation to handle very large values of `n`. - Ensure the solution handles edge cases such as `n = 0` and `n = 1` efficiently. # Hint: Consider representing the Fibonacci sequence using a transformation matrix and then raising the matrix to the power of `n-1` to determine the `n`th Fibonacci number efficiently.","solution":"def matrix_multiply(A, B): Multiplies two 2x2 matrices A and B return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, n): Performs matrix exponentiation result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) n //= 2 return result def fibonacci(n): Returns the nth Fibonacci number using matrix exponentiation if n == 0: return 0 if n == 1: return 1 transformation_matrix = [ [1, 1], [1, 0] ] result_matrix = matrix_power(transformation_matrix, n-1) return result_matrix[0][0]"},{"question":"# Sum of Unique Elements In this task, you will write a function to calculate the sum of unique elements in a list. The function should iterate through the list and sum only the elements that appear exactly once. # Function Signature ```python def sum_unique_elements(nums: List[int]) -> int: A function that returns the sum of unique elements in a list. Parameters: nums (List[int]): A list of integers. Returns: int: The sum of unique elements in the list. # Your implementation here ``` # Constraints: * The length of the list `nums` will be between 1 and 10^5. * The elements in the list `nums` will be integers between `-10^4` and `10^4`. # Input Format: * A single list of integers `nums`. # Output Format: * An integer representing the sum of the unique elements. # Example ```python >>> sum_unique_elements([1, 2, 3, 2, 1, 4]) 7 >>> sum_unique_elements([10, 20, 10, 30, 40, 50, 30]) 110 ``` Implement the function `sum_unique_elements` where you identify and sum the elements in the list that do not have duplicates.","solution":"from typing import List def sum_unique_elements(nums: List[int]) -> int: Returns the sum of unique elements in a list. Parameters: nums (List[int]): A list of integers. Returns: int: The sum of unique elements in the list. # Count the occurrences of each element in the list count = {} for num in nums: if num in count: count[num] += 1 else: count[num] = 1 # Sum the elements that appear exactly once total = 0 for num, cnt in count.items(): if cnt == 1: total += num return total"},{"question":"# Coding Question: Find the Missing Number in Fibonacci-like Sequence Problem Statement: You are given a sequence of `n` integers where all but one number form a strictly increasing Fibonacci-like sequence. In a Fibonacci-like sequence, each number is the sum of the two preceding ones. Your task is to find and return the missing number in the sequence that would make the entire sequence a valid Fibonacci-like sequence. Write a function `find_missing(sequence: List[int]) -> int` where: - **Input**: - `sequence` (a list of integers) - the given sequence of integers. - **Output**: Output the missing number that would make the sequence a valid Fibonacci-like sequence. Function Signature: `def find_missing(sequence: List[int]) -> int` **Examples**: ```python assert find_missing([1, 1, 2, 3, 5, 8, 13, 21]) == 0 assert find_missing([1, 1, 2, 3, 5, 13, 21, 34]) == 8 assert find_missing([2, 3, 5, 8, 13, 21, 34, 55, 144]) == 89 assert find_missing([1, 4, 5, 9, 14]) == 0 ``` Constraints: - The sequence has at least 5 elements and at most 30 elements. - At most one number is missing from the Fibonacci-like sequence. - The sequence is zero-indexed. - The value of the numbers in the sequence are positive integers. Performance Requirements: - The solution should efficiently find and return the missing number. - Ensure the solution handles sequences up to the given length limit effectively. **Hint**: Consider the nature of the Fibonacci sequence and how the relationship between consecutive terms can help deduce the missing number.","solution":"from typing import List def find_missing(sequence: List[int]) -> int: Finds the missing number in a Fibonacci-like sequence. n = len(sequence) for i in range(2, n): # If the sequence is correct up to i-1 elements, find if the current element fits the pattern if sequence[i] != sequence[i-1] + sequence[i-2]: # Found a discrepancy; now determine which number is missing # Case 1: The missing number is between (i-2) and (i-1) if i-2 > 0 and sequence[i] == sequence[i-2] + sequence[i-1] + sequence[i-3]: return sequence[i-2] + sequence[i-1] # Case 2: The missing number is at position i (sequence[i] should be sequence[i-1] + sequence[i-2]) else: return sequence[i-1] + sequence[i-2] # If no missing number is found, return 0 (which means sequence is actually correct) return 0"},{"question":"# Matrix Traversal Paths Given an `N x M` matrix filled with non-negative integers, you need to determine the number of distinct paths in the matrix from the top-left corner to the bottom-right corner. You are only allowed to move either right or down at any point in time. Write a function that returns the number of distinct paths. # Function Signature ```python def count_paths(matrix: List[List[int]]) -> int: pass ``` # Input * `matrix` (List[List[int]]): A 2D list of non-negative integers representing the grid. * For example: * `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` represents a 3x3 matrix. # Output * Returns (int): The number of distinct paths from the top-left to the bottom-right cell. # Constraints * 1 <= len(matrix) <= 100 * 1 <= len(matrix[0]) <= 100 # Example ```python assert count_paths([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 6 assert count_paths([[1, 0], [0, 1]]) == 2 ``` # Explanation For the provided examples: - In the first example, there are 6 distinct paths: * Right, Right, Down, Down * Right, Down, Right, Down * Right, Down, Down, Right * Down, Right, Right, Down * Down, Right, Down, Right * Down, Down, Right, Right - In the second example, there are 2 distinct paths: * Right, Down * Down, Right # Notes * The problem can be efficiently solved using dynamic programming. * Consider edge cases such as extremely narrow or extremely tall matrices.","solution":"def count_paths(matrix): Returns the number of distinct paths in the matrix from the top-left corner to the bottom-right corner, moving only right or down. if not matrix or not matrix[0]: return 0 rows = len(matrix) columns = len(matrix[0]) # Initialize the dp array dp = [[0] * columns for _ in range(rows)] # There\'s exactly one way to reach any cell in the first row: only by going right for col in range(columns): dp[0][col] = 1 # There\'s exactly one way to reach any cell in the first column: only by going down for row in range(rows): dp[row][0] = 1 # Fill the dp array for row in range(1, rows): for col in range(1, columns): dp[row][col] = dp[row - 1][col] + dp[row][col - 1] return dp[rows - 1][columns - 1]"},{"question":"# Coding Assessment Question Context: Fibonacci sequences are a classic example in many algorithmic challenges. The recursive approach for generating the Fibonacci sequence is straightforward but inefficient. In this task, you will implement an efficient iterative solution and compare its performance with the recursive approach. Task: Implement a function to generate the first `n` numbers of the Fibonacci sequence using an iterative approach. Compare its efficiency with the recursive method for large values of `n`. Function Signature: ```python def fibonacci_iterative(n: int) -> List[int]: pass ``` Input & Output: - **Input**: An integer `n` (0 <= n <= 50). - **Output**: A list containing the first `n` numbers of the Fibonacci sequence. Constraints: - If `n` is 0, return an empty list. - Implement the iterative logic without using any built-in Fibonacci functions. - Compare both time and space performance for `n = 50`. Examples: ```python assert fibonacci_iterative(0) == [] assert fibonacci_iterative(1) == [0] assert fibonacci_iterative(5) == [0, 1, 1, 2, 3] assert fibonacci_iterative(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` Additional Challenge: Implement the Fibonacci sequence generation using a recursive approach with memoization and compare the execution time for `n = 50` between the iterative and recursive methods. Document the time taken for both approaches.","solution":"from typing import List def fibonacci_iterative(n: int) -> List[int]: if n == 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2]) return fib_sequence def fibonacci_recursive(n: int, memo={}) -> int: if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo) return memo[n] def generate_fibonacci_recursive(n: int) -> List[int]: return [fibonacci_recursive(i) for i in range(n)]"},{"question":"# Problem Statement **Uniqueness of Strings** You are tasked with writing a function that determines if a given string consists of all unique characters. Your challenge is to accomplish this with O(n) time complexity and O(1) space complexity without using any additional data structures like arrays, lists, or sets. # Task Write a function `is_unique(string: str) -> bool` that takes a string as input and returns `True` if all characters in the string are unique, and `False` otherwise. # Input Format * A string `string` containing only ASCII characters, where 0 ≤ length of `string` ≤ 128. # Output Format * A boolean value (`True` or `False`). # Constraints * The implementation must have O(n) time complexity. * The implementation must use O(1) space complexity. * The string can include lowercase and uppercase letters, digits, and special characters. # Example 1 Input: ``` string = \\"abcdef\\" ``` Output: ``` True ``` # Example 2 Input: ``` string = \\"aabbcc\\" ``` Output: ``` False ``` # Notes * The input string `string` will only contain ASCII characters. * The implementation should not use additional data structures such as dictionaries or sets. Implement the function `is_unique` as specified: ```python def is_unique(string: str) -> bool: pass ```","solution":"def is_unique(string: str) -> bool: Determines if the given string consists of all unique characters. Args: string (str): The input string containing only ASCII characters. Returns: bool: True if all characters are unique, False otherwise. if len(string) > 128: # There are only 128 unique ASCII characters return False checker = 0 for char in string: val = ord(char) if (checker & (1 << val)) > 0: return False checker |= (1 << val) return True"},{"question":"# Text File Search Enhancement You are given a basic utility function that searches for a specific word in a given text file and prints the line numbers where the word appears. Currently, this function: 1. Reads the entire file content at once into memory. 2. Searches for the word and prints line numbers if found. Your task is to enhance this utility with the following features: * **Memory Optimization**: Modify the function to handle large files efficiently by reading one line at a time instead of loading the entire file into memory. * **Case-Insensitive Search**: Ensure that the search is case-insensitive. * **Contextual Output**: For each line where the word is found, print the line number and the line itself, highlighting the word. # Input - A string representing the file path. - A string representing the word to search for. # Output - Print the line numbers and corresponding lines with the word highlighted for each occurrence. - If the word is not found, print \\"Word not found.\\" # Constraints - Ensure memory efficiency by processing one line at a time. - The highlighting should make the found word distinct but avoid using external libraries for this purpose. - Consider common edge cases such as an empty file or a word not present in the text. # Example ```python # Example main invocation if __name__ == \\"__main__\\": file_path = \\"sample-text.txt\\" search_word = \\"example\\" search_file(file_path, search_word) ``` **Note**: Assume that the file handling imports and other required libraries are appropriately managed.","solution":"def search_file(file_path, search_word): Searches for the specified word in the file at the given file path and prints the line numbers and lines where the word is found, highlighting the word. :param file_path: Path to the text file. :param search_word: The word to search for. search_word = search_word.lower() found = False with open(file_path, \'r\') as file: for line_number, line in enumerate(file, start=1): if search_word in line.lower(): highlighted_line = line.lower().replace(search_word, f\'033[1;31m{search_word}033[0m\') print(f\\"Line {line_number}: {highlighted_line.strip()}\\") found = True if not found: print(\\"Word not found.\\")"},{"question":"String Permutation Check Write a function that determines whether two given strings are permutations of each other. Two strings are considered permutations of each other if they contain the same characters with the same frequencies. Function Signature ```python def are_permutations(s1: str, s2: str) -> bool: ``` # Input - `s1` (str): The first string to compare. - `s2` (str): The second string to compare. # Output - (bool): Returns `True` if the strings are permutations of each other, otherwise `False`. # Implementation Steps 1. **Length Check**: First, check if the lengths of both strings are the same. If not, they cannot be permutations of each other. 2. **Frequency Count**: Count the frequency of each character in both strings. 3. **Comparison**: Compare the frequency counts of both strings. If they match, the strings are permutations of each other. # Constraints - The lengths of the input strings `s1` and `s2` will be in the range [1, 1000]. # Example ```python # Test case 1 s1 = \\"listen\\" s2 = \\"silent\\" print(are_permutations(s1, s2)) # Expected output: True # Test case 2 s1 = \\"apple\\" s2 = \\"pale\\" print(are_permutations(s1, s2)) # Expected output: False # Test case 3 s1 = \\"abc\\" s2 = \\"bac\\" print(are_permutations(s1, s2)) # Expected output: True # Test case 4 s1 = \\"aabbcc\\" s2 = \\"abcabc\\" print(are_permutations(s1, s2)) # Expected output: True ``` # Hints - You may use Python\'s `collections.Counter` for a concise and efficient solution to count character frequencies. - Be mindful of the function’s time complexity, especially given the constraint on string lengths.","solution":"from collections import Counter def are_permutations(s1: str, s2: str) -> bool: Determines if two strings are permutations of each other. Args: s1 (str): The first string to compare. s2 (str): The second string to compare. Returns: bool: True if the strings are permutations of each other, otherwise False. # If lengths are not the same, they cannot be permutations if len(s1) != len(s2): return False # Count character frequencies for both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Compare the frequency counts return counter_s1 == counter_s2"},{"question":"# Problem: Find the Longest Substring with Distinct Characters You are tasked with implementing a Python function that finds the length of the longest substring with all distinct characters within a given string. Function Signature ```python def longest_distinct_substring(s: str) -> int: pass ``` # Description Given: - `s`: A string of lowercase English letters. Your implementation should: 1. Return the length of the longest substring of `s` in which all the characters are distinct. 2. Assume the input string `s` has a length `n`, where `1 <= n <= 10^5`. # Constraints - The input string consists only of lowercase English letters. # Input/Output Example ```python # Example 1 s = \\"abcabcbb\\" print(longest_distinct_substring(s)) # Output: 3 (The longest substring is \\"abc\\" with length 3) # Example 2 s = \\"bbbbb\\" print(longest_distinct_substring(s)) # Output: 1 (The longest substring is \\"b\\" with length 1) # Example 3 s = \\"pwwkew\\" print(longest_distinct_substring(s)) # Output: 3 (The longest substring is \\"wke\\" with length 3) # Example 4 s = \\"abcdabc\\" print(longest_distinct_substring(s)) # Output: 4 (The longest substring is \\"abcd\\" with length 4) ``` # Edge Cases to Consider - If the string contains only one character, the result should be 1. - Consider cases with repeated characters. - Handle large input sizes efficiently without causing a timeout. # Important Notes - Use a sliding window approach to optimize the search for the longest substring. - Ensure the solution runs in linear time, O(n), to handle the maximum input size efficiently.","solution":"def longest_distinct_substring(s: str) -> int: max_length = 0 start = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map: # Move the start position to the right of the last occurrence of the current character start = max(start, char_index_map[s[end]] + 1) # Update the last seen index of the current character char_index_map[s[end]] = end # Calculate the maximum length of substring seen so far max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Coding Question: Sequence Transformation with Constraints Given a sequence of integers, you need to transform it into another sequence using a set of allowed operations. The allowed operations are: 1. Increment an element by 1. 2. Decrement an element by 1. 3. Swap two elements. Your task is to determine the minimum number of operations required to transform the initial sequence into the target sequence. # Requirements: - Implement the function `min_operations(initial: List[int], target: List[int]) -> int` that returns the minimum number of operations needed. - Each operation (increment, decrement, swap) counts as one step. # Input: - `initial`: List of integers representing the initial sequence. - `target`: List of integers representing the target sequence. # Output: - An integer representing the minimum number of operations required to transform the initial sequence into the target sequence. # Constraints: - Both the `initial` and `target` lists will have the same length (1 leq n leq 10^4). - The elements of both lists will be positive integers in the range (1 leq element leq 10^4). - Handle edge cases such as already identical sequences efficiently. # Example: ```python def min_operations(initial: List[int], target: List[int]) -> int: # Your implementation here. pass # Example Usages: print(min_operations([1, 2, 3], [3, 2, 1])) # Example Output: 2 print(min_operations([4, 5, 6], [1, 2, 3])) # Example Output: 9 print(min_operations([7, 8, 9], [7, 8, 9])) # Example Output: 0 print(min_operations([1, 1, 1], [1, 1, 2])) # Example Output: 1 print(min_operations([1, 3, 5], [5, 3, 1])) # Example Output: 2 ``` # Additional Context: This problem tests your understanding of sequence manipulation under constraints and finding optimal algorithms for sequence transformation. Consider efficiency and optimal use of operations to minimize the overall steps required. Your solution should account for different possible sequences and edge cases where sequences may already be closely aligned.","solution":"from typing import List def min_operations(initial: List[int], target: List[int]) -> int: if initial == target: return 0 n = len(initial) operations = 0 diffs = [target[i] - initial[i] for i in range(n)] for diff in diffs: operations += abs(diff) return operations"},{"question":"# Linked List Operations Assessment You are required to perform fundamental operations on singly linked lists in Python. Linked lists are essential data structures used in various algorithms and applications. # Problem Description **Class 1: ListNode** Define a class `ListNode` to represent a node in a singly linked list. * Each node has two attributes: `val` (an integer) and `next` (reference to the next node, or `None` if it\'s the end of the list). **Function 1: reverse_linked_list** Implement a function `reverse_linked_list(head: ListNode) -> ListNode` that reverses a singly linked list. * Your implementation should return the new head of the reversed list. **Function 2: detect_cycle** Implement a function `detect_cycle(head: ListNode) -> bool` that checks whether a singly linked list has a cycle. * A list has a cycle if some node in the list can be reached again by continuously following the `next` pointers. **Function 3: merge_two_lists** Implement a function `merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode` that merges two sorted singly linked lists into one sorted list. * Your function should return the head of the newly merged list. # Expected Input and Output 1. **reverse_linked_list Function** * Input: `head` - The head node of a singly linked list. * Output: The new head node of the reversed list. 2. **detect_cycle Function** * Input: `head` - The head node of a singly linked list. * Output: Boolean value `True` if the linked list has a cycle, `False` otherwise. 3. **merge_two_lists Function** * Input: `l1` and `l2` - Head nodes of two sorted singly linked lists. * Output: The head node of the merged and sorted singly linked list. # Constraints * The length of each linked list will not exceed 1000 nodes. * Node values will be integers in the range -1000 to 1000. # Performance Requirements Ensure your solution to each function operates efficiently within the given constraints. # Example Use Case ```python # Define the ListNode class class ListNode: def __init__(self, value=0, next_node=None): self.val = value self.next = next_node # Example list: 1 -> 4 -> 5 head1 = ListNode(1, ListNode(4, ListNode(5))) # Example list: 1 -> 2 -> 3 head2 = ListNode(1, ListNode(2, ListNode(3))) # reverse_linked_list new_head1 = reverse_linked_list(head1) # Now new_head1 is 5 -> 4 -> 1 # detect_cycle assert detect_cycle(head2) == False # merge_two_lists merged_head = merge_two_lists(head1, head2) # Now merged_head is 1 -> 1 -> 2 -> 3 -> 4 -> 5 ``` Write and test your implementations to demonstrate their correctness and efficiency.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def detect_cycle(head: ListNode) -> bool: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode(-1) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next"},{"question":"**Scenario**: Imagine you work for a social media platform that tracks the activity levels of users. As part of the analytics team, you need to analyze user activity data to generate periodic reports. One key metric you want to calculate is the average session duration of users over a defined period. **Task**: Write a function `average_session_duration(sessions: list[dict]) -> float` that takes a list of dictionaries, where each dictionary represents a user session with two keys: `\'start_time\'` and `\'end_time\'`. Both values are strings in the ISO 8601 format: `YYYY-MM-DDTHH:MM:SS` (e.g., `2023-01-01T12:00:00`). The function should calculate the average session duration in minutes, rounding to two decimal places. If there are no sessions in the input list, the function should return `0.0`. # Functional Requirements 1. **Input**: - A list of dictionaries, where each dictionary has the keys `\'start_time\'` and `\'end_time\'`. 2. **Output**: - A float representing the average duration of user sessions in minutes, rounded to two decimal places. # Constraints & Performance - Handle up to 10,000 sessions efficiently. - Assume all session end times are later than start times. - The function should gracefully handle time conversion and any potential edge cases such as empty input lists. # Example ```python input_sessions = [ {\\"start_time\\": \\"2023-01-01T12:00:00\\", \\"end_time\\": \\"2023-01-01T12:30:00\\"}, {\\"start_time\\": \\"2023-01-02T14:00:00\\", \\"end_time\\": \\"2023-01-02T15:00:00\\"}, {\\"start_time\\": \\"2023-01-03T09:00:00\\", \\"end_time\\": \\"2023-01-03T09:45:00\\"} ] expected_output = 45.00 ``` # Notes - Utilize the `datetime` module for time calculations. - Focus on clear and concise error handling to ensure robustness. You may start by using the given example to test and verify the function’s correctness.","solution":"from datetime import datetime def average_session_duration(sessions): Calculate the average session duration in minutes from a list of session dictionaries. Each session dictionary contains \'start_time\' and \'end_time\' as ISO 8601 format strings. Args: sessions (list of dict): List of session dictionaries. Returns: float: Average session duration in minutes, rounded to two decimal places. total_duration = 0 session_count = len(sessions) if session_count == 0: return 0.0 for session in sessions: start_time = datetime.fromisoformat(session[\'start_time\']) end_time = datetime.fromisoformat(session[\'end_time\']) duration = (end_time - start_time).total_seconds() / 60 total_duration += duration average_duration = total_duration / session_count return round(average_duration, 2)"},{"question":"# Coding Task: Implement a Mini Batch Gradient Descent for Linear Regression Description You are given a dataset with multiple features and a target variable. Your task is to implement a linear regression model utilizing the Mini Batch Gradient Descent (MBGD) optimization technique. The aim is to predict the target variable based on the input features. Requirements 1. Implement the `MiniBatchLinearRegression` class. 2. The class should contain methods to fit the model to the training data using mini batches. 3. Implement a prediction method to generate outputs for new data points based on the trained model. 4. Include a method to calculate and return the Mean Squared Error (MSE) of the model. Input Format 1. Training data as a numpy ndarray `X_train` where rows represent samples and columns represent features. Another ndarray `y_train` represents the target variables. 2. Test data as a numpy ndarray `X_test` where rows represent samples and columns represent features. Output Format An array of predictions for the given test samples. Constraints 1. Ensure numerical stability in calculations. 2. Batch size for the mini batch gradient descent should be a tunable parameter. 3. Convergence criteria should be based on a specified tolerance level or a fixed number of iterations. Example ```python import numpy as np # Training data (features and target) X_train = np.array([ [1, 2], [2, 3], [3, 4], [4, 5] ]) y_train = np.array([5, 7, 9, 11]) # Test data (features only) X_test = np.array([ [5, 6], [6, 7] ]) # Linear Regression Model Initialization lr_model = MiniBatchLinearRegression( learning_rate=0.01, batch_size=2, tolerance=0.0001, max_iterations=1000 ) # Fitting the model lr_model.fit(X_train, y_train) # Predicting predictions = lr_model.predict(X_test) print(predictions) # Expected Output: array([13, 15]) # Calculating Mean Squared Error on training data mse = lr_model.calculate_mse(X_train, y_train) print(mse) # Output: Mean squared error value ``` Implement the `MiniBatchLinearRegression` class based on the given example above.","solution":"import numpy as np class MiniBatchLinearRegression: def __init__(self, learning_rate=0.01, batch_size=32, tolerance=1e-4, max_iterations=1000): self.learning_rate = learning_rate self.batch_size = batch_size self.tolerance = tolerance self.max_iterations = max_iterations self.weights = None def fit(self, X_train, y_train): # Initialize weights self.weights = np.zeros(X_train.shape[1] + 1) # Add a column of ones to X_train for the bias term X_train = np.c_[np.ones(X_train.shape[0]), X_train] n_samples = X_train.shape[0] previous_cost = float(\'inf\') for iteration in range(self.max_iterations): # Create mini batches indices = np.random.permutation(n_samples) X_train_shuffled = X_train[indices] y_train_shuffled = y_train[indices] for start in range(0, n_samples, self.batch_size): end = start + self.batch_size X_batch = X_train_shuffled[start:end] y_batch = y_train_shuffled[start:end] # Predictions predictions = np.dot(X_batch, self.weights) # Errors errors = predictions - y_batch # Gradient descent update gradient = np.dot(X_batch.T, errors) / X_batch.shape[0] self.weights -= self.learning_rate * gradient # Compute cost cost = np.mean(errors ** 2) # Check for convergence if np.abs(previous_cost - cost) < self.tolerance: break previous_cost = cost def predict(self, X_test): # Add a column of ones to X_test for the bias term X_test = np.c_[np.ones(X_test.shape[0]), X_test] return np.dot(X_test, self.weights) def calculate_mse(self, X_test, y_test): predictions = self.predict(X_test) errors = predictions - y_test mse = np.mean(errors ** 2) return mse"},{"question":"# Coding Assessment Question Description: You are tasked with implementing a function to implement a variant of the well-known \\"Run-Length Encoding\\" algorithm, but with a twist. Instead of simply compressing consecutive characters, you will use a delimiter to separate the counts and characters, ensuring a more readable compressed format. Function Signature: ```python def custom_run_length_encoding(input_string: str, delimiter: str = \'|\') -> str: ``` Parameters: 1. **input_string** (str): The plain-text string that needs to be compressed. 2. **delimiter** (str, optional): The delimiter used to separate counts and characters in the compressed string. Defaults to \'|\'. Behavior: - Traverse the input_string and count consecutive occurrences of each character. - Append the count, then the delimiter, followed by the character to the result string. - If the delimiter appears in the input, preserve it in the output instead of encoding it. Example: ```python # Example: input_string = \\"aaabbcaaa\\" delimiter = \\"|\\" result = custom_run_length_encoding(input_string, delimiter) print(result) # Expected output: \\"3|a2|b1|c3|a\\" # Example with custom delimiter input_string = \\"aaabbcaaa\\" delimiter = \\"-\\" result = custom_run_length_encoding(input_string, delimiter) print(result) # Expected output: \\"3-a2-b1-c3-a\\" ``` Constraints: - Ensure all characters and their counts are correctly represented in the output. - The input string can be of arbitrary length. - Suitable performance for inputs up to length 10^5. Additional Requirements: - Documentation for the main function and helper functions, if any. - Code should be clean, properly formatted, and include comments explaining each major step. - Handle invalid inputs (such as an empty delimiter) gracefully and provide meaningful error messages.","solution":"def custom_run_length_encoding(input_string: str, delimiter: str = \'|\') -> str: Compresses the input_string using a modified run-length encoding algorithm with a custom delimiter. Parameters: input_string (str): The plain-text string that needs to be compressed. delimiter (str, optional): The delimiter used to separate counts and characters in the compressed string. Defaults to \'|\'. Returns: str: The compressed string with counts and characters separated by the delimiter. if not delimiter: raise ValueError(\\"Delimiter cannot be empty\\") if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{count}{delimiter}{current_char}\\") current_char = char count = 1 # Don\'t forget to append the last sequence encoded_string.append(f\\"{count}{delimiter}{current_char}\\") return \'\'.join(encoded_string)"},{"question":"# Question You are developing a real-time data processing system that processes incoming sensor readings from multiple devices and combines them into a single coherent dataset. Each sensor device sends readings in a specific format, which need to be parsed and merged. The `parse_and_merge_readings` function should take a list of readings from multiple devices and perform the following tasks: 1. Parse each reading to extract the `device_id`, `timestamp`, and `value`. 2. Merge the parsed readings into a single dataset that aggregates the values for each device over time. 3. For each unique `device_id`, sort the readings by `timestamp`. Note: Each reading comes in a string format that follows this regex pattern: `r\\"device(?P<device_id>d+):(?P<timestamp>d+);(?P<value>.+)\\"`. Function Signature ```python def parse_and_merge_readings(readings: list[str]) -> dict[int, list[tuple[int, float]]]: Parses and merges sensor readings from multiple devices. Parameters: readings: List of sensor readings in the format: \\"device<device_id>:<timestamp>;<value>\\" Returns: Dictionary where keys are `device_id` and values are lists of tuples (timestamp, value). ``` Constraints * The `readings` list can have up to `10,000` elements. * Each `device_id` is a positive integer. * Each `timestamp` is a non-negative integer. * Each `value` is a floating-point number. * The `value` for each `device_id` must be sorted by `timestamp`. Input/Output Format - **Input**: - `readings`: List of strings - **Output**: - Dictionary where keys are `device_id` (int) and values are lists of tuples (timestamp (int), value (float)). Example ```python readings = [ \\"device1:1617551245;12.5\\", \\"device2:1617551247;10.2\\", \\"device1:1617551246;13.7\\", \\"device2:1617551248;10.5\\", \\"device3:1617551280;8.0\\" ] expected_output = { 1: [(1617551245, 12.5), (1617551246, 13.7)], 2: [(1617551247, 10.2), (1617551248, 10.5)], 3: [(1617551280, 8.0)] } output = parse_and_merge_readings(readings) assert output == expected_output ``` Note Ensure that your implementation properly parses the `device_id`, `timestamp`, and `value`, and merges the readings efficiently, considering constraints.","solution":"import re from collections import defaultdict def parse_and_merge_readings(readings): Parses and merges sensor readings from multiple devices. Parameters: readings: List of sensor readings in the format: \\"device<device_id>:<timestamp>;<value>\\" Returns: Dictionary where keys are `device_id` and values are lists of tuples (timestamp, value). pattern = re.compile(r\\"device(?P<device_id>d+):(?P<timestamp>d+);(?P<value>.+)\\") data = defaultdict(list) for reading in readings: match = pattern.match(reading) if match: device_id = int(match.group(\\"device_id\\")) timestamp = int(match.group(\\"timestamp\\")) value = float(match.group(\\"value\\")) data[device_id].append((timestamp, value)) # Sort the readings for each device by timestamp for device_id in data: data[device_id].sort(key=lambda x: x[0]) return dict(data)"},{"question":"Implementing a Budget Calculator Context You are developing a budgeting application that helps users manage their monthly expenses. The user inputs several expenses and their amounts across various categories, and the application needs to generate a summary of the total spending per category. Objective * Write a function `summarize_expenses` that takes a list of expenses, where each expense is represented as a tuple containing the category and the amount. * The function should return a dictionary where the keys are expense categories, and the values are the total amounts spent in each category. * Include error handling to ensure invalid inputs, such as negative amounts, are properly managed. Function Signature ```python def summarize_expenses(expenses: List[Tuple[str, float]]) -> Dict[str, float]: Summarize monthly expenses by category. Parameters: expenses (List[Tuple[str, float]]): A list of tuples, each containing a category (str) and an amount (float). Returns: Dict[str, float]: A dictionary where categories are keys and total amounts are values. Example: >>> summarize_expenses([(\'groceries\', 100.0), (\'entertainment\', 50.5), (\'groceries\', 25.3)]) {\'groceries\': 125.3, \'entertainment\': 50.5} ``` Constraints and Requirements * **Input Constraints**: - Each tuple in the expenses list contains a category (as a string) and an amount (as a float). - Amounts must be non-negative values. * **Output**: - The function should return a dictionary with summed amounts per category. * **Error Handling**: - If an amount is negative, add this entry to an \\"errors\\" key in the dictionary, along with details of the invalid entry. - Ensure the function does not crash due to invalid inputs. * **Performance**: The function should operate efficiently, ideally with a time complexity of O(n) for n input tuples. ```python # Example Function def summarize_expenses(expenses: List[Tuple[str, float]]) -> Dict[str, float]: Summarize monthly expenses by category. Parameters: expenses (List[Tuple[str, float]]): A list of tuples, each containing a category (str) and an amount (float). Returns: Dict[str, float]: A dictionary where categories are keys and total amounts are values, along with an \\"errors\\" key for invalid entries. Example: >>> summarize_expenses([(\'groceries\', 100.0), (\'entertainment\', 50.5), (\'groceries\', 25.3), (\'utilities\', -20.0)]) {\'groceries\': 125.3, \'entertainment\': 50.5, \'errors\': [(\'utilities\', -20.0)]} if not all(isinstance(category, str) and isinstance(amount, (int, float)) for category, amount in expenses): raise ValueError(\\"Each entry must contain a string category and a numeric amount.\\") summary = {} for category, amount in expenses: if amount < 0: if \\"errors\\" not in summary: summary[\\"errors\\"] = [] summary[\\"errors\\"].append((category, amount)) else: if category in summary: summary[category] += amount else: summary[category] = amount return summary ``` You are tasked to write and thoroughly test your solution, ensuring to cover normal and edge cases.","solution":"from typing import List, Tuple, Dict def summarize_expenses(expenses: List[Tuple[str, float]]) -> Dict[str, float]: Summarize monthly expenses by category. Parameters: expenses (List[Tuple[str, float]]): A list of tuples, each containing a category (str) and an amount (float). Returns: Dict[str, float]: A dictionary where categories are keys and total amounts are values, along with an \\"errors\\" key for invalid entries. Example: >>> summarize_expenses([(\'groceries\', 100.0), (\'entertainment\', 50.5), (\'groceries\', 25.3), (\'utilities\', -20.0)]) {\'groceries\': 125.3, \'entertainment\': 50.5, \'errors\': [(\'utilities\', -20.0)]} if not all(isinstance(category, str) and isinstance(amount, (int, float)) for category, amount in expenses): raise ValueError(\\"Each entry must contain a string category and a numeric amount.\\") summary = {} for category, amount in expenses: if amount < 0: if \\"errors\\" not in summary: summary[\\"errors\\"] = [] summary[\\"errors\\"].append((category, amount)) else: if category in summary: summary[category] += amount else: summary[category] = amount return summary"},{"question":"# Counting Occurrences of Each Character in a String You are tasked with creating a function that takes a string as input and returns a dictionary where the keys are the unique characters from the string, and the values are the count of occurrences of each character. Ensure that your implementation is efficient and handles edge cases properly. Function Signature: ```python def count_characters(input_string: str) -> Dict[str, int]: pass ``` Input: * `input_string` (str): A string consisting of ASCII characters. Output: * `Dict[str, int]`: A dictionary where each key is a character from the input string and the corresponding value is the count of occurrences of that character. Constraints: * The input string can include any printable ASCII characters. * The input string can be empty. * The function should handle both uppercase and lowercase characters as distinct characters. Example: ```python >>> count_characters(\\"Hello, World!\\") {\'H\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \',\': 1, \' \': 1, \'W\': 1, \'r\': 1, \'d\': 1, \'!\': 1} >>> count_characters(\\"aaaaBBBcc\\") {\'a\': 4, \'B\': 3, \'c\': 2} >>> count_characters(\\"\\") {} ``` Scenario: You are working on a text processing application and need to analyze the frequency of each character in various input strings. This function will help in identifying character distributions which is crucial for tasks like data compression or encoding schemes.","solution":"from typing import Dict def count_characters(input_string: str) -> Dict[str, int]: Count the occurrences of each character in a given string. Parameters: input_string (str): The input string consisting of ASCII characters. Returns: Dict[str, int]: A dictionary with characters as keys and their counts as values. char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Problem Description You are tasked with implementing a Depth-First Search (DFS) traversal algorithm for a given directed graph. The algorithm should return the order of nodes visited during the traversal starting from a specified node. # Requirements - Implement the core functionalities of DFS from scratch without using any built-in library methods specific to DFS. - Ensure the traversal handles cycles and disconnected components gracefully. # Constraints - Nodes will be labeled with integers. - The graph might not be fully connected. - The graph will contain up to 10<sup>4</sup> nodes. - Edge weights are not present, only connectivity information is needed. # Input The input is provided as two elements: 1. A list of tuples representing the directed edges in the form (node1, node2). 2. An integer value representing the starting node for the DFS traversal. For example: ``` edges = [ (1, 2), (2, 3), (1, 4), ... ] start_node = 1 ``` # Output The output should be a list of integers representing the order of nodes visited by the DFS traversal starting from the given starting node. For example: ``` [1, 2, 3, 4] ``` # Example Given the input edges and starting node: ``` edges = [ (1, 2), (2, 3), (1, 4) ] start_node = 1 ``` The DFS traversal output in a valid visiting order could be: ``` [1, 2, 3, 4] ``` # Implementation Details 1. **Graph Class**: - Implement a method to add edges to the graph. - Implement a method to perform the DFS traversal and return the visited order. # Code Template ```python from typing import List, Tuple class GraphDirected: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int) -> None: if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def dfs(self, start: int) -> List[int]: visited = set() order = [] def dfs_util(v: int): visited.add(v) order.append(v) for neighbour in self.graph.get(v, []): if neighbour not in visited: dfs_util(neighbour) dfs_util(start) return order def compute_dfs_traversal(edges: List[Tuple[int, int]], start_node: int) -> List[int]: Compute DFS Traversal starting from the given node :param edges: A list of tuples where each tuple represents a directed edge (node1, node2) :param start_node: The starting node for the DFS traversal :return: A list of nodes in the order they were visited during DFS graph = GraphDirected() for u, v in edges: graph.add_edge(u, v) return graph.dfs(start_node) # Example usage: # edges = [(1, 2), (2, 3), (1, 4)] # start_node = 1 # assert compute_dfs_traversal(edges, start_node) == [1, 2, 3, 4] ``` This problem requires you to demonstrate an understanding of graph traversal concepts, recursion, and handling edge cases related to graph connectivity and cycles. The solution should be efficient and correctly handle large graphs within the given constraints.","solution":"from typing import List, Tuple class GraphDirected: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int) -> None: if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def dfs(self, start: int) -> List[int]: visited = set() order = [] def dfs_util(v: int): visited.add(v) order.append(v) for neighbour in self.graph.get(v, []): if neighbour not in visited: dfs_util(neighbour) dfs_util(start) return order def compute_dfs_traversal(edges: List[Tuple[int, int]], start_node: int) -> List[int]: Compute DFS Traversal starting from the given node :param edges: A list of tuples where each tuple represents a directed edge (node1, node2) :param start_node: The starting node for the DFS traversal :return: A list of nodes in the order they were visited during DFS graph = GraphDirected() for u, v in edges: graph.add_edge(u, v) return graph.dfs(start_node)"},{"question":"# Matrix Rotation Query You are given a square matrix of integers and need to implement functionality to rotate any sub-matrix 90 degrees clockwise. You will then need to provide the sum of elements within a specified range of rows and columns from the rotated matrix. 1. **Rotate Sub-matrix**: Add a method `rotate_submatrix(top: int, left: int, bottom: int, right: int) -> None` which rotates the specified sub-matrix 90 degrees clockwise within the main matrix. 2. **Range Sum Query**: Add a method `range_query(row_start: int, row_end: int, col_start: int, col_end: int) -> int` which returns the sum of elements within the specified range of rows and columns. Input and Output Formats * **Input**: * For the `rotate_submatrix` method: * `top` and `left` - integers specifying the start row and column of the sub-matrix. * `bottom` and `right` - integers specifying the end row and column of the sub-matrix. * For the `range_query` method: * `row_start` and `row_end` - integers denoting the range of rows. * `col_start` and `col_end` - integers denoting the range of columns. * **Output**: * For the `rotate_submatrix` method: No output (modify in-place). * For the `range_query` method: An integer representing the sum of elements in the specified range. Constraints * `0 <= top <= bottom < n` * `0 <= left <= right < n` * `0 <= row_start <= row_end < n` * `0 <= col_start <= col_end < n` * `matrix elements are integers` * Assume the matrix is reasonably sized, i.e., `n x n` where `n <= 100`. Performance Requirements * Ensure that the rotation and query operations are efficient, i.e., avoid excessive nested loops or redundant calculations to comply with reasonable performance expectations given the constraints. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_ops = MatrixOperations(matrix) matrix_ops.rotate_submatrix(0, 0, 2, 2) # 90 degrees clockwise: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] print(matrix_ops.range_query(0, 1, 0, 1)) # Output: 24 (because the sum of elements in the new top-left 2x2 sub-matrix is 7+4+8+5) ``` # Implementation Implement a `MatrixOperations` class with the `rotate_submatrix` and `range_query` methods as described.","solution":"class MatrixOperations: def __init__(self, matrix): self.matrix = matrix self.n = len(matrix) def rotate_submatrix(self, top, left, bottom, right): temp_matrix = [row[left:right+1] for row in self.matrix[top:bottom+1]] m, n = bottom - top + 1, right - left + 1 for i in range(m): for j in range(n): self.matrix[top + j][left + n - i - 1] = temp_matrix[i][j] def range_query(self, row_start, row_end, col_start, col_end): total_sum = 0 for r in range(row_start, row_end + 1): for c in range(col_start, col_end + 1): total_sum += self.matrix[r][c] return total_sum"},{"question":"# Context You are developing a program that involves calculations with prime numbers. One useful component of your program is a function that checks whether a given number is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Task Implement a Python function called `is_prime` that determines if a given number is prime. Your function should satisfy the following requirements: # Requirements * Define the function as `is_prime(number: int) -> bool`. * If the `number` is less than or equal to 1, return `False` since these numbers are not considered prime. * For any other number greater than 1, the function should return `True` if the number is a prime number, `False` otherwise. # Example Usage ```python >>> is_prime(2) True >>> is_prime(15) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(-5) False ``` # Constraints * The function should handle both positive and negative integers. * Focus on the correctness and efficiency of the prime-checking algorithm. * Assume that inputs will be of type `int`. # Performance Requirements * Optimize the function to run in O(√n) time complexity, where n is the value of the input number. * The function should perform minimal checks to determine if a number is not prime, enhancing performance for large input values. # Additional Notes * Utilize efficient mathematical techniques and ensure that your function is easy to understand and maintain. * Consider typical edge cases, such as very small numbers and negative numbers, in your implementation.","solution":"def is_prime(number): Determines if the given number is a prime number. Parameters: number (int): The number to check. Returns: bool: True if the number is prime, False otherwise. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True"},{"question":"# Weighted Graph Shortest Path Implement a class `WeightedGraph` that represents a weighted, undirected graph and can efficiently compute the shortest path between two nodes using Dijkstra\'s Algorithm. The graph should be represented by an adjacency matrix to ensure efficient edge weight access. Class Definition Your task is to implement the `WeightedGraph` class with the following methods: - `add_edge(vertex1: int, vertex2: int, weight: int)`: Adds an edge to the graph with a specified weight. - `shortest_path(source: int, target: int) -> List[int]`: Computes and returns the shortest path from a source vertex to a target vertex. If no path exists, return an empty list. - `__str__() -> str`: Returns a string representation of the adjacency matrix. Requirements: 1. The graph can handle up to 100 vertices. 2. The `add_edge` method should correctly update the adjacency matrix with the provided weight. 3. The `shortest_path` method should utilize Dijkstra\'s Algorithm to ensure the shortest path computation. 4. If a vertex or edge specified in `add_edge` or `shortest_path` is out of bounds, raise a `ValueError`. Constraints: - Weights are non-negative integers. - Vertices are represented by integers starting from 0 up to 99. - Ensure that the algorithm efficiently handles the graph constraints. ```python import heapq from typing import List class WeightedGraph: def __init__(self): self.n = 100 self.graph = [[float(\'inf\')] * self.n for _ in range(self.n)] for i in range(self.n): self.graph[i][i] = 0 def add_edge(self, vertex1: int, vertex2: int, weight: int) -> None: if vertex1 >= self.n or vertex2 >= self.n or vertex1 < 0 or vertex2 < 0: raise ValueError(\\"Vertex out of bounds\\") self.graph[vertex1][vertex2] = weight self.graph[vertex2][vertex1] = weight def shortest_path(self, source: int, target: int) -> List[int]: if source >= self.n or target >= self.n or source < 0 or target < 0: raise ValueError(\\"Vertex out of bounds\\") dist = [float(\'inf\')] * self.n dist[source] = 0 pq = [(0, source)] parent = [-1] * self.n while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v in range(self.n): if self.graph[u][v] != float(\'inf\'): distance = current_dist + self.graph[u][v] if distance < dist[v]: dist[v] = distance parent[v] = u heapq.heappush(pq, (distance, v)) if dist[target] == float(\'inf\'): return [] # Reconstruct path path = [] current = target while current != -1: path.append(current) current = parent[current] return path[::-1] def __str__(self) -> str: result = [] for row in self.graph: result.append(\\" \\".join(map(lambda x: str(x) if x != float(\'inf\') else \\"inf\\", row))) return \\"n\\".join(result) # Example usage: # wg = WeightedGraph() # wg.add_edge(0, 1, 4) # wg.add_edge(0, 2, 1) # wg.add_edge(2, 1, 2) # wg.add_edge(1, 3, 1) # wg.add_edge(2, 3, 5) # print(wg) # print(wg.shortest_path(0, 3)) # Output: # 0 4 1 inf inf ... etc # [0, 2, 1, 3] ``` The above class definition includes part of the structure. Implement the methods to satisfy the described functionality and ensure robustness against mentioned edge cases. Complete the methods as described to handle edge cases and ensure correctness.","solution":"import heapq from typing import List class WeightedGraph: def __init__(self): self.n = 100 self.graph = [[float(\'inf\')] * self.n for _ in range(self.n)] for i in range(self.n): self.graph[i][i] = 0 def add_edge(self, vertex1: int, vertex2: int, weight: int) -> None: if vertex1 >= self.n or vertex2 >= self.n or vertex1 < 0 or vertex2 < 0: raise ValueError(\\"Vertex out of bounds\\") self.graph[vertex1][vertex2] = weight self.graph[vertex2][vertex1] = weight def shortest_path(self, source: int, target: int) -> List[int]: if source >= self.n or target >= self.n or source < 0 or target < 0: raise ValueError(\\"Vertex out of bounds\\") dist = [float(\'inf\')] * self.n dist[source] = 0 pq = [(0, source)] parent = [-1] * self.n while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v in range(self.n): if self.graph[u][v] != float(\'inf\'): distance = current_dist + self.graph[u][v] if distance < dist[v]: dist[v] = distance parent[v] = u heapq.heappush(pq, (distance, v)) if dist[target] == float(\'inf\'): return [] # Reconstruct path path = [] current = target while current != -1: path.append(current) current = parent[current] return path[::-1] def __str__(self) -> str: result = [] for row in self.graph: result.append(\\" \\".join(map(lambda x: str(x) if x != float(\'inf\') else \\"inf\\", row))) return \\"n\\".join(result)"},{"question":"# Problem Statement You are given a class `MatrixManipulator` designed to handle a 2D matrix. Your task is to extend this class by adding two additional methods with the following functionalities: 1. `rotate_layer_clockwise(self, layer: int) -> None` 2. `find_max_sum_submatrix(self, k: int) -> int` 1. The method `rotate_layer_clockwise` should rotate the elements of the specified layer of the matrix by one position in a clockwise direction. **Input**: - `layer` (int): The layer of the matrix to be rotated. Layers are zero-indexed, meaning layer 0 refers to the outermost layer. **Output**: - None. The function modifies the matrix in place. 2. The method `find_max_sum_submatrix` should return the maximum sum of any submatrix that has its sum less than or equal to a given value `k`. **Input**: - `k` (int): The maximum allowed sum for the submatrix. **Output**: - (int): The maximum sum of any submatrix with sum less than or equal to `k`. # Constraints * The matrix dimensions and values are within: - Number of rows and columns is up to 300. - Matrix values are between -10^5 and 10^5. - The maximum allowed sum `k` is within integer range. # Example ```python # Example usage of the methods: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mm = MatrixManipulator(matrix) # Method: rotate_layer_clockwise(layer) mm.rotate_layer_clockwise(0) print(mm.matrix) # Output should be: # [ # [4, 1, 2], # [7, 5, 3], # [8, 9, 6] # ] # Method: find_max_sum_submatrix(k) submatrix_sum = mm.find_max_sum_submatrix(15) print(submatrix_sum) # Output should be 15 ``` You need to add the above methods in the given `MatrixManipulator` class and ensure all the provided examples work correctly.","solution":"class MatrixManipulator: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def rotate_layer_clockwise(self, layer: int) -> None: if self.rows == 0 or self.cols == 0: return r1, c1 = layer, layer r2, c2 = self.rows - layer - 1, self.cols - layer - 1 if r1 >= r2 or c1 >= c2: return elements = [] for c in range(c1, c2 + 1): elements.append(self.matrix[r1][c]) for r in range(r1 + 1, r2 + 1): elements.append(self.matrix[r][c2]) for c in range(c2 - 1, c1 - 1, -1): elements.append(self.matrix[r2][c]) for r in range(r2 - 1, r1, -1): elements.append(self.matrix[r][c1]) elements = [elements[-1]] + elements[:-1] idx = 0 for c in range(c1, c2 + 1): self.matrix[r1][c] = elements[idx] idx += 1 for r in range(r1 + 1, r2 + 1): self.matrix[r][c2] = elements[idx] idx += 1 for c in range(c2 - 1, c1 - 1, -1): self.matrix[r2][c] = elements[idx] idx += 1 for r in range(r2 - 1, r1, -1): self.matrix[r][c1] = elements[idx] idx += 1 def find_max_sum_submatrix(self, k: int) -> int: import bisect def max_sum_subarray(arr, k): max_sum = float(\'-inf\') curr_sum = 0 prefix_sums = [0] for num in arr: curr_sum += num target = curr_sum - k idx = bisect.bisect_left(prefix_sums, target) if idx < len(prefix_sums): max_sum = max(max_sum, curr_sum - prefix_sums[idx]) bisect.insort(prefix_sums, curr_sum) return max_sum max_sum = float(\'-inf\') for left in range(self.cols): row_sums = [0] * self.rows for right in range(left, self.cols): for i in range(self.rows): row_sums[i] += self.matrix[i][right] max_sum = max(max_sum, max_sum_subarray(row_sums, k)) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"# Unique Elements Determination Given a list of integers, implement a function `find_unique_elements` that returns a list of unique elements from the input list in the order they first appear. # Function Signature ```python def find_unique_elements(arr: list) -> list: pass ``` # Input * `arr`: A list of integers, where 0 ≤ len(arr) ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. # Output * A list of unique integers, preserving their order of first appearance in the input list. # Example ```python >>> find_unique_elements([4, 5, 6, 4, 5, 6, 7]) [4, 5, 6, 7] >>> find_unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_elements([]) [] >>> find_unique_elements([-1, -2, -3, -1, -2, -3, 0]) [-1, -2, -3, 0] ``` # Constraints * The function should have linear O(n) time complexity. * The order of the first appearance of unique integers must be preserved in the output list. * Handle edge cases, such as empty lists, correctly.","solution":"def find_unique_elements(arr: list) -> list: Returns a list of unique elements in the order they first appear in the input list. seen = set() unique_elements = [] for elem in arr: if elem not in seen: seen.add(elem) unique_elements.append(elem) return unique_elements"},{"question":"# Question Context A library management system needs to keep track of checkout durations for borrowed books. Each book has a default checkout duration, but some members have special statuses that allow them extensions. You are to implement a function to determine the correct number of days a book can be borrowed. Task Write a function `get_checkout_duration` that computes the total number of days a book can be borrowed based on its default duration and the member\'s status. Function Signature ```python def get_checkout_duration(default_days: int, member_status: str) -> int: ``` Input * `default_days` (int): The default number of days a book can be borrowed. (1 <= default_days <= 30) * `member_status` (str): The status of the member. It can be one of the following: * `\'regular\'`: No extension. * `\'premium\'`: Additional 7 days. * `\'vip\'`: Additional 14 days. Output * (int): The total number of days the book can be borrowed. Example ```python >>> get_checkout_duration(21, \'regular\') 21 >>> get_checkout_duration(14, \'premium\') 21 >>> get_checkout_duration(10, \'vip\') 24 ``` Constraints * Validate the input values: * `1 <= default_days <= 30` * `member_status` must be one of `\'regular\'`, `\'premium\'`, or `\'vip\'`. * Ensure the function handles different types of membership statuses appropriately. Edge Cases * When `default_days` is at its minimum (1), the function should still return valid durations based on member status. * When `default_days` is at its maximum (30), the function should correctly calculate the extensions for different member statuses accordingly.","solution":"def get_checkout_duration(default_days: int, member_status: str) -> int: if not (1 <= default_days <= 30): raise ValueError(\\"default_days must be between 1 and 30\\") if member_status not in [\'regular\', \'premium\', \'vip\']: raise ValueError(\\"member_status must be one of \'regular\', \'premium\', or \'vip\'\\") if member_status == \'regular\': return default_days elif member_status == \'premium\': return default_days + 7 elif member_status == \'vip\': return default_days + 14"},{"question":"# Word Ladder Transformation Problem Statement You are tasked with implementing a function that finds the shortest transformation sequence from a start word to a target word by changing only one letter at a time, with each transformed word needing to exist in a given dictionary. If no such transformation is possible, return an empty list. Function Signature ```python def word_ladder(start: str, target: str, word_list: List[str]) -> List[str]: ``` Input - `start`: A string representing the starting word. - `target`: A string representing the target word. - `word_list`: A list of strings representing the dictionary of allowable words. Output - Returns a list of strings representing the sequence of transformations from `start` to `target`, inclusive. If no transformation is possible, returns an empty list. Constraints - The starting word and target word are non-empty strings of the same length. - All words in the word list and the start target are lowercase. - The word list contains no duplicates. - The word list contains at least one word. - The length of each word is at most 20. Example ```python start = \\"hit\\" target = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] ``` The output might be: ```python [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` Instructions 1. Implement the function `word_ladder` using a breadth-first search (BFS) approach to find the shortest transformation sequence. 2. Validate that each transformation results in a valid word from the word list. 3. Ensure the sequence transformations are all stored and returned in the correct order. 4. Handle cases where no transformation path exists. Additional Notes - You may import standard Python libraries such as `collections` for convenience. - Consider edge cases such as the start word being the same as the target word or the target not existing in the word list.","solution":"from collections import deque from typing import List def word_ladder(start: str, target: str, word_list: List[str]) -> List[str]: def get_neighbours(word): neighbours = [] for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': if c != word[i]: neighbour = word[:i] + c + word[i+1:] if neighbour in word_set: neighbours.append(neighbour) return neighbours if target not in word_list: return [] word_set = set(word_list) queue = deque([(start, [start])]) visited = set() while queue: current_word, path = queue.popleft() if current_word == target: return path for neighbour in get_neighbours(current_word): if neighbour not in visited: visited.add(neighbour) queue.append((neighbour, path + [neighbour])) return []"},{"question":"# Question: Matrix Diagonal Sum Calculator You are tasked with implementing two functions to calculate the sum of the main diagonal elements in a square matrix. The goal is to assess your understanding of array manipulation and recursion in Python. Implement the following two functions according to the specifications given: 1. **sum_main_diagonal_iterative** - **Input**: A square matrix represented as a list of lists, where each sub-list is a row of the matrix and each element of the sub-list is an integer. - **Output**: The sum of the elements on the main diagonal of the matrix. - **Constraints**: The function must raise a `ValueError` if the matrix is not square or if it is empty. 2. **sum_main_diagonal_recursive** - **Input**: 1. A square matrix represented as a list of lists, where each sub-list is a row of the matrix and each element of the sub-list is an integer. 2. An index `i` which starts at 0 for the initial call. - **Output**: The sum of the elements on the main diagonal of the matrix. - **Constraints**: 1. The function must raise a `ValueError` if the matrix is not square or if it is empty. 2. This function must be recursive, using the given index parameter to traverse the matrix diagonally. **Function Definitions**: ```python def sum_main_diagonal_iterative(matrix: list[list[int]]) -> int: # Your code here def sum_main_diagonal_recursive(matrix: list[list[int]], i: int = 0) -> int: # Your code here ``` **Example Test Cases**: ```python assert sum_main_diagonal_iterative([[1, 2], [3, 4]]) == 5 assert sum_main_diagonal_iterative([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) == 15 assert sum_main_diagonal_iterative([[7]]) == 7 try: sum_main_diagonal_iterative([[1, 2, 3], [4, 5], [6, 7, 8]]) except ValueError: print(\\"Caught ValueError as expected\\") try: sum_main_diagonal_iterative([]) except ValueError: print(\\"Caught ValueError as expected\\") assert sum_main_diagonal_recursive([[1, 2], [3, 4]]) == 5 assert sum_main_diagonal_recursive([[5, 0, 0], [0, 5, 0], [0, 0, 5]]) == 15 assert sum_main_diagonal_recursive([[7]]) == 7 try: sum_main_diagonal_recursive([[1, 2, 3], [4, 5], [6, 7, 8]]) except ValueError: print(\\"Caught ValueError as expected\\") try: sum_main_diagonal_recursive([]) except ValueError: print(\\"Caught ValueError as expected\\") ``` **Requirements**: - Ensure your functions handle edge cases appropriately. - Keep the code concise and optimized, especially the recursive function. - Follow the provided function signatures and constraints. Good luck!","solution":"def sum_main_diagonal_iterative(matrix): if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") size = len(matrix) diagonal_sum = 0 for i in range(size): diagonal_sum += matrix[i][i] return diagonal_sum def sum_main_diagonal_recursive(matrix, i=0): if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") if i == len(matrix): return 0 return matrix[i][i] + sum_main_diagonal_recursive(matrix, i + 1)"},{"question":"# Question **Prime Factorization and Pie Chart Visualization** In this challenge, you will implement a function that performs prime factorization of a given integer and then plots the result as a pie chart. This problem tests your ability to implement basic number theory algorithms and visualize the results using plotting libraries. Problem Statement: 1. **Function to Implement**: Implement the function `prime_factor_pie_chart(number: int) -> None`. 2. **Function Signature**: The function signature should be `def prime_factor_pie_chart(number: int) -> None:` 3. **Input**: - `number` (integer): The integer to be factorized. Constraints: `2 <= number <= 1000000`. 4. **Output**: - The function does not return any value. Instead, it plots a pie chart of the prime factors. Requirements Implement your function to adhere to the following steps: 1. **Prime Factorization**: - Decompose the input number into its prime factors. - Keep track of the frequency of each prime factor. 2. **Plotting**: - Use Matplotlib to plot a pie chart where each section represents a prime factor proportionate to its frequency in the factorization. - Each section should be labeled with the corresponding prime factor. Example ```python # Example call prime_factor_pie_chart(360) ``` This should generate and plot a pie chart with the prime factors of 360: 2, 3, and 5. Specifically, 360 = 2^3 * 3^2 * 5, so the chart should have three sections with the proportions reflecting the factors\' frequencies. Additional Information - You may use the sympy library for generating prime numbers and factorization, but it is not mandatory. - Ensure the pie chart is correctly labeled and proportional to the factors. Testing Your implementation will be tested using different values such as 360, 128, 10007, and 999983. Make sure your solution handles the edge cases effectively and plots the pie chart accurately. ```python # Including the import statements for the necessary libraries import matplotlib.pyplot as plt from collections import Counter def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def prime_factor_pie_chart(number: int) -> None: factors = prime_factors(number) counter = Counter(factors) labels = list(counter.keys()) sizes = list(counter.values()) plt.figure(figsize=(8, 8)) plt.pie(sizes, labels=labels, autopct=\'%1.1f%%\', startangle=90) plt.title(f\'Prime Factorization of {number}\') plt.show() ```","solution":"import matplotlib.pyplot as plt from collections import Counter def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def prime_factor_pie_chart(number: int) -> None: factors = prime_factors(number) counter = Counter(factors) labels = list(counter.keys()) sizes = list(counter.values()) plt.figure(figsize=(8, 8)) plt.pie(sizes, labels=labels, autopct=\'%1.1f%%\', startangle=90) plt.title(f\'Prime Factorization of {number}\') plt.show()"},{"question":"# Coding Question Given a dictionary mapping each student to a list of their grades, your task is to create a function that computes the average grade for each student and then returns a dictionary mapping each student to their average grade, rounded to two decimal places. # Function Signature ```python def compute_student_averages(grades_dict: dict) -> dict: pass ``` # Input Format - `grades_dict`: A dictionary where keys are student names (strings) and values are lists of integers representing their grades. # Output Format - Returns a dictionary where each key is a student name and each value is the average grade of that student rounded to two decimal places. # Constraints - The grades list for each student will contain at least one grade. - Grades are integers between 0 and 100 inclusive. # Examples ```python >>> compute_student_averages({ ... \\"Alice\\": [90, 80, 70], ... \\"Bob\\": [100, 95], ... \\"Charlie\\": [60, 70, 60, 70] ... }) {\'Alice\': 80.0, \'Bob\': 97.5, \'Charlie\': 65.0} >>> compute_student_averages({ ... \\"David\\": [88], ... \\"Eva\\": [100, 100, 100], ... \\"Fiona\\": [50, 55, 60] ... }) {\'David\': 88.0, \'Eva\': 100.0, \'Fiona\': 55.0} ``` # Explanation For each student, compute the average of their grades, and round it to two decimal places before adding it to the resultant dictionary. **Hint**: You might find Python\'s built-in `sum()` and `len()` functions useful for computing the average.","solution":"def compute_student_averages(grades_dict: dict) -> dict: Computes the average grade for each student. Args: grades_dict (dict): A dictionary where keys are student names and values are lists of grades. Returns: dict: A dictionary where each key is a student name and each value is the average grade of that student. averages_dict = {} for student, grades in grades_dict.items(): average_grade = sum(grades) / len(grades) averages_dict[student] = round(average_grade, 2) return averages_dict"},{"question":"# Objective: Implement a function in Python to determine the longest contiguous sublist within a list of integers that sums to a given value, including validation for input types and ranges. # Problem Statement: You are tasked with implementing a function that identifies the longest contiguous sublist within a list of integers that sums to a specified target value. The function should validate the inputs and return the longest sublist that meets the criteria. If multiple sublists have the same length, return the first one encountered. If no such sublist exists, return an empty list. # Function Signature: ```python def longest_sublist_with_sum(nums: list[int], target: int) -> list[int]: ``` # Input: - `nums`: a list of integers representing the sequence of numbers. - `target`: an integer representing the target sum. # Output: - A list of integers representing the longest contiguous sublist that sums to the target value. Return an empty list if no such sublist exists. # Constraints: - `nums` must be a list of integers. - `target` must be an integer. - The length of `nums` will be at most 10^4. # Examples: ```python >>> longest_sublist_with_sum([1, 2, 3, 4, 5], 9) [2, 3, 4] >>> longest_sublist_with_sum([1, 2, 3, 4, 5], 15) [1, 2, 3, 4, 5] >>> longest_sublist_with_sum([1, -1, 5, -2, 3], 3) [1, -1, 5, -2] >>> longest_sublist_with_sum([1, 2, 3, 4, 5], 7) [3, 4] >>> longest_sublist_with_sum([1, 2, 3], 7) [] >>> longest_sublist_with_sum([], 1) [] >>> longest_sublist_with_sum([1, 2, 3], \\"7\\") Traceback (most recent call last): ... ValueError: Expected int for target, found <class \'str\'> >>> longest_sublist_with_sum(\\"12345\\", 9) Traceback (most recent call last): ... ValueError: Expected list of int for nums, found <class \'str\'> ``` # Requirements: - Implement the function adhering to the signature and constraints. - Handle invalid input types by raising appropriate exceptions with informative messages. - Ensure the function effectively finds and returns the longest contiguous sublist or an empty list if no such sublist exists.","solution":"def longest_sublist_with_sum(nums: list[int], target: int) -> list[int]: Find the longest contiguous sublist that sums to the target value. Args: nums (list[int]): The list of integers. target (int): The target sum. Returns: list[int]: The longest sublist that sums to the target or an empty list if no such sublist exists. # Validate input types if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(f\\"Expected list of int for nums, found {type(nums)}\\") if not isinstance(target, int): raise ValueError(f\\"Expected int for target, found {type(target)}\\") max_len = 0 best_sublist = [] for start in range(len(nums)): cum_sum = 0 for end in range(start, len(nums)): cum_sum += nums[end] if cum_sum == target: current_sublist = nums[start:end+1] if len(current_sublist) > max_len: max_len = len(current_sublist) best_sublist = current_sublist break return best_sublist"},{"question":"# Sum of All Unique Elements in a List You are given a list of integers. Your task is to find the sum of all unique elements in the list. An element is considered unique if it appears exactly once in the list. # Function Signature ```python def sum_of_unique_elements(arr: List[int]) -> int: pass ``` # Input - `arr`: A list of integers representing the input list, where `arr[i]` is the integer at position `i`. # Output - An integer representing the sum of all unique elements in the input list. # Constraints - The length of the list is within the range `1 <= length <= 1000`. - Each integer value in the list is within the range `-1000 <= value <= 1000`. # Example ```python arr = [1, 2, 3, 2, 4, 1, 5] print(sum_of_unique_elements(arr)) # Output: 12 ``` # Explanation In the given example, the unique elements are `[3, 4, 5]` because every other element appears more than once. The sum of these unique elements is `3 + 4 + 5 = 12`. # Notes - Ensure your function handles cases where no elements are unique, in which case the sum should be `0`. - Optimize your implementation to handle lists efficiently.","solution":"from typing import List def sum_of_unique_elements(arr: List[int]) -> int: Returns the sum of all unique elements in the list. element_count = {} # Count occurrence of each element for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 # Sum only the elements that appear exactly once unique_sum = sum(num for num, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Minimum Absolute Difference You are given a list of integers. Your task is to implement a function that finds the pair of elements that have the smallest absolute difference between them and returns this minimum absolute difference. Write a function `minimum_absolute_difference` that accepts a list of integers and returns an integer representing the minimum absolute difference between any two elements in the list. Function Signature ```python def minimum_absolute_difference(arr: list[int]) -> int: ``` # Input - `arr`: A list of integers. This list can include negative numbers and duplicates. # Output - An integer representing the minimum absolute difference between any two elements in the list. # Constraints - The list will contain at least two elements and at most 10^6 elements. - The integers in the list will be within the range of -10^9 to 10^9. # Examples ```python print(minimum_absolute_difference([3, -7, 0])) # Output: 3 print(minimum_absolute_difference([1, -3, 71, 68, 17])) # Output: 3 print(minimum_absolute_difference([-1, -2, -3, -4, -5, -6, -7])) # Output: 1 print(minimum_absolute_difference([5, 8, 17, 12])) # Output: 3 ``` # Constraints and Performance Expectations - The implementation must efficiently handle large lists of up to 10^6 elements. - Aim to achieve a time complexity better than O(n^2), as a naive comparison approach may not perform well on large inputs. Provide a complete implementation within the `minimum_absolute_difference` function that adheres to the above specifications and constraints.","solution":"def minimum_absolute_difference(arr: list[int]) -> int: Finds the minimum absolute difference between any two elements in the list. Args: arr: A list of integers. Returns: An integer representing the minimum absolute difference. # Sort the array arr.sort() # Initialize the minimum difference as a large number min_diff = float(\'inf\') # Iterate through the sorted array to find the minimum difference for i in range(len(arr) - 1): min_diff = min(min_diff, arr[i+1] - arr[i]) return min_diff"},{"question":"# Binary Search Tree (BST) Validation and Modification Context You are tasked with working on a Binary Search Tree (BST). You will implement functions to build the tree, validate if the tree is a valid BST, and insert new elements while maintaining the BST properties. Task Implement the following functions: 1. **Insert**: Inserts a new element into the BST. 2. **IsValidBST**: Validates if a given binary tree is a valid BST. Input and Output Define a BinarySearchTree class with the following methods: 1. `__init__(self, elements: List[int])` - Initializes the BST with elements from the provided list. 2. `insert(self, value: int) -> None` - Inserts `value` into the BST. 3. `isValidBST(self) -> bool` - Checks if the current tree structure is a valid BST. Example: ```python bst = BinarySearchTree([10, 5, 15, 3, 7, 12, 18]) print(bst.isValidBST()) # Outputs: True (since it\'s a valid BST) bst.insert(6) print(bst.isValidBST()) # Outputs: True (still a valid BST after insertion) bst.root.left.left.left = TreeNode(20) # Manually altering the tree to invalidate BST print(bst.isValidBST()) # Outputs: False (invalid BST due to manual alteration) ``` Constraints - The number of elements in the list will not exceed 10^4. - The values of the elements will be between -10^6 and 10^6. **Performance Requirements**: Your implementation should efficiently handle operations within the expected input constraints. Note Ensure: - The `insert` method maintains the BST properties. - The `isValidBST` method accurately validates the tree structure according to BST rules.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self, elements): self.root = None for element in elements: self.insert(element) def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def isValidBST(self): def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if node.value <= low or node.value >= high: return False return (validate(node.left, low, node.value) and validate(node.right, node.value, high)) return validate(self.root)"},{"question":"# Coding Assessment Question: Background In computer science, particularly in graph theory, the concept of a \\"connected component\\" is fundamental. A connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths and which is connected to no additional vertices in the supergraph. Task Implement a function `count_connected_components(graph)` that calculates the number of connected components in an undirected graph. - **Input**: A dictionary `graph` where the keys represent node labels and the values are lists of nodes to which the key node is directly connected. Each node label is an integer, and the graph can have up to 10^3 nodes. - **Output**: Return an integer representing the number of connected components in the graph. - **Constraints**: Assume that the input graph is always valid and does not contain any isolated nodes (i.e., each node has at least one connection). Function Signature ```python def count_connected_components(graph: dict) -> int: pass ``` Examples ```python assert count_connected_components({ 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3] }) == 2 assert count_connected_components({ 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] }) == 1 assert count_connected_components({ 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2], 4: [5], 5: [4] }) == 2 ``` Additional Notes - Nodes in the input graph are labeled with non-negative integers. - The graph is undirected, which means that if node `a` is connected to node `b`, then node `b` is also connected to node `a`. - You may assume that there are no self-loops or multiple edges between the same pair of nodes. - Implement typical graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS) to solve the problem.","solution":"def count_connected_components(graph: dict) -> int: Returns the number of connected components in an undirected graph. :param graph: A dictionary where keys represent node labels and values are lists of nodes to which the key node is directly connected. :return: Integer representing the number of connected components in the graph. # Initialize visited set to keep track of visited nodes visited = set() def dfs(node): Depth-First Search (DFS) to traverse and mark all nodes connected to the given node. stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) # Count the number of connected components connected_components = 0 for node in graph: if node not in visited: # Found an unvisited node, increment the connected component count connected_components += 1 # Perform DFS from this node dfs(node) return connected_components"},{"question":"# Memory Management in Linked Lists Background: Memory management is an essential aspect of data structures like linked lists. A common task is to remove all nodes having a specific value from a linked list and ensure that no memory leaks occur. Task: You are required to implement the function `remove_nodes` as described in the code snippet provided to delete nodes with a given value from a singly linked list. Your function should ensure that no memory leaks occur and that the resulting linked list is correctly formed. Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nodes(head: ListNode, value: int) -> ListNode: Remove all nodes with the specified value from the linked list. Input Parameters: head (ListNode): The head of the singly linked list. value (int): The value to be removed from the list. Returns: ListNode: The head of the modified linked list. Raises: TypeError: If the \'head\' is not of type ListNode. ``` Example Tests: ```python # Example 1 node3 = ListNode(2) node2 = ListNode(1, node3) node1 = ListNode(1, node2) head = node1 new_head = remove_nodes(head, 1) current = new_head while current: print(current.value, end=\\" \\") # should output: 2 current = current.next # Example 2 node5 = ListNode(6) node4 = ListNode(5, node5) node3 = ListNode(4, node4) node2 = ListNode(3, node3) node1 = ListNode(2, node2) head = node1 new_head = remove_nodes(head, 4) current = new_head while current: print(current.value, end=\\" \\") # should output: 2, 3, 5, 6 current = current.next # Example 3 node5 = ListNode(6) node4 = ListNode(6, node5) node3 = ListNode(6, node4) node2 = ListNode(6, node3) node1 = ListNode(6, node2) head = node1 new_head = remove_nodes(head, 6) current = new_head while current: print(current.value, end=\\" \\") # should output nothing (empty list) current = current.next # Example 4 import sys try: remove_nodes(123, 1) # passing an invalid type instead of ListNode except TypeError as e: print(e) # should raise TypeError ``` Constraints: * The ListNode class should be used as provided in the function signature. * Ensure that the linked list modifications and deletions are performed in an efficient manner. * Raise a `TypeError` if the `head` is not an instance of `ListNode`. * Nodes should be properly deleted to avoid memory leaks. * The function should handle cases where no nodes or all nodes need to be removed.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nodes(head: ListNode, value: int) -> ListNode: if not isinstance(head, (ListNode, type(None))): raise TypeError(\\"head must be a ListNode instance or None\\") # Create a dummy node to handle edge cases when the head itself needs to be removed dummy = ListNode(0) dummy.next = head current = dummy while current and current.next: if current.next.value == value: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"# Sum of Digits Objective You are required to write a Python function that calculates the sum of the digits of a given positive integer. Implement this function using both iterative and recursive approaches for practice, but submit the iterative version for the assessment. Problem Statement Given a positive integer `n`, implement a function `sum_of_digits(n: int) -> int` that returns the sum of the digits of `n`. You should also write a test suite to verify your implementation handles various cases correctly. Input and Output Format * **Input**: A positive integer `n`, where (1 <= n <= 10^9). * **Output**: An integer representing the sum of the digits of `n`. Constraints * The input value `n` will be a positive integer within the specified range. * The solution should handle large integer values efficiently. Performance Requirements * Time Complexity: O(log(n)) * Space Complexity: O(1) for iterative approach. Example 1 * **Input**: `n = 1234` * **Output**: `10` (1 + 2 + 3 + 4) Example 2 * **Input**: `n = 8675309` * **Output**: `38` (8 + 6 + 7 + 5 + 3 + 0 + 9) Example 3 * **Input**: `n = 1000000001` * **Output**: `2` (1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 1) Tasks 1. Implement the function `sum_of_digits(n: int) -> int` using an iterative approach. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases and large values. Notes * Focus on the efficiency of your solution, especially when dealing with the upper limits of the input range. * Ensure your function is well-tested for correctness and performance limits. Use both small and very large numbers in your test cases.","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given positive integer n. sum_d = 0 while n > 0: sum_d += n % 10 n //= 10 return sum_d"},{"question":"# Background Fibonacci numbers form a sequence, called the Fibonacci sequence, in which each number is the sum of the two preceding ones. This sequence starts with 0 and 1. The nth Fibonacci number is denoted as (F(n)). # Problem Statement Write a function `nth_fibonacci(n: int) -> int` that returns the nth Fibonacci number. # Input - `n`: A non-negative integer representing the position in the Fibonacci sequence. # Output - An integer representing the nth Fibonacci number. # Constraints - (0 leq n leq 30) # Example ```python print(nth_fibonacci(0)) # Output: 0 print(nth_fibonacci(1)) # Output: 1 print(nth_fibonacci(2)) # Output: 1 print(nth_fibonacci(10)) # Output: 55 ``` # Notes - Pay attention to the base cases: `F(0) = 0` and `F(1) = 1`. - Consider an iterative approach to avoid the drawbacks of recursion for the given constraint. # Hints - You can use a loop to calculate Fibonacci numbers up to the nth position. - Maintain only the last two Fibonacci numbers to save on space. For instance, in each iteration, update only the two most recent Fibonacci numbers.","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Objective Create a function to solve linear equations of the form `ax + b = c` and return the solution. # Problem Statement You are given three coefficients `a`, `b`, and `c` of a linear equation of the form `ax + b = c`. Your task is to implement the `solve_linear_equation` function that returns the value of `x` which satisfies the equation. Specifications - **Function Signature**: ```python def solve_linear_equation(a: float, b: float, c: float) -> float: ``` - **Parameters**: - `a` (float): The coefficient of the variable `x`. - `b` (float): The constant term. - `c` (float): The term on the right-hand side of the equation. - **Returns**: - A float representing the value of `x` that satisfies the equation `ax + b = c`. Constraints - The coefficient `a` should not be zero. - `a`, `b`, and `c` can be any real numbers. Examples ```python >>> solve_linear_equation(2, 3, 7) 2.0 >>> solve_linear_equation(-1, 5, 2) 3.0 >>> solve_linear_equation(0.5, 1.5, 3) 3.0 ``` Notes - Ensure that the function raises an `AssertionError` with an appropriate message if the coefficient `a` is zero. - Implement the function considering the basic algebra to isolate `x` in the equation `ax + b = c`.","solution":"def solve_linear_equation(a: float, b: float, c: float) -> float: Solves the linear equation ax + b = c for x. Parameters: a (float) : The coefficient of the variable x. b (float) : The constant term. c (float) : The term on the right-hand side of the equation. Returns: float : The value of x that satisfies the equation. Raises: AssertionError : If the coefficient a is zero. assert a != 0, \\"Coefficient a cannot be zero\\" return (c - b) / a"},{"question":"# Context: String processing is a fundamental part of computer science, and manipulating strings efficiently is a key skill. In this task, you will create a function that counts the frequency of each word in a given text and returns the words sorted by their frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. # Task: Write a function `word_frequency_analysis` that receives a string `text` and returns a list of tuples, where each tuple contains a word and its corresponding frequency. The list should be sorted by frequency in descending order and then alphabetically for words with the same frequency. # Function Signature: ```python def word_frequency_analysis(text: str) -> list: pass ``` # Input: * `text` (str): a string containing words separated by whitespace. # Output: * A list of tuples, where each tuple consists of: - a word (str) - its frequency (int) # Example: ```python assert word_frequency_analysis(\\"the quick brown fox jumps over the lazy dog the dog was not amused\\") == [(\'the\', 3), (\'dog\', 2), (\'amused\', 1), (\'brown\', 1), (\'fox\', 1), (\'jumps\', 1), (\'lazy\', 1), (\'not\', 1), (\'over\', 1), (\'quick\', 1), (\'was\', 1)] ``` # Constraints: * The `text` can be assumed to be a non-empty string with words separated by single spaces. * Words are case-sensitive, i.e., \'The\' and \'the\' are considered different words. * The text will only contain alphabetical characters and spaces. # Notes: * Ensure that the words in the result are presented in the correct order as specified. * Provide a solution that handles large text inputs efficiently. * Handle edge cases such as an empty string input or text with repeated words. # Guidelines: * Utilize collections or dictionary data structures to map words to their frequencies. * Ensure thorough testing of input strings to validate the correctness of your solution.","solution":"from collections import Counter def word_frequency_analysis(text: str) -> list: Analyzes word frequency in the given text and returns a sorted list of tuples. Each tuple contains a word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they are sorted alphabetically. # Split the text into words words = text.split() # Count the frequency of each word frequency_counter = Counter(words) # Sort primarily by frequency (descending) and then by word (alphabetically) sorted_words = sorted(frequency_counter.items(), key=lambda x: (-x[1], x[0])) return sorted_words"},{"question":"# Coding Problem: Reservoir Water Balance Calculation **Context**: You have been hired by a water resources management company. They frequently need to calculate the water balance of a reservoir for operational management and planning. The water balance calculation considers inflows, outflows, direct precipitation, and evaporation. You need to provide them with a reliable function that computes the water balance given specific parameters. **Task**: Implement a function `reservoir_water_balance` that calculates the water balance of a reservoir using the following formula: [ W_B = (I + P) - (O + E) ] Where: * (W_B) = Water balance of the reservoir [cubic meters] * (I) = Inflow into the reservoir [cubic meters] * (O) = Outflow from the reservoir [cubic meters] * (P) = Direct precipitation on the reservoir [cubic meters] * (E) = Evaporation from the reservoir [cubic meters] # Function Signature ```python def reservoir_water_balance( inflow: float, outflow: float, precipitation: float, evaporation: float ) -> float: pass ``` # Input format * `inflow`: A non-negative float representing inflow into the reservoir in cubic meters. * `outflow`: A non-negative float representing outflow from the reservoir in cubic meters. * `precipitation`: A non-negative float representing direct precipitation on the reservoir in cubic meters. * `evaporation`: A non-negative float representing evaporation from the reservoir in cubic meters. # Output format * Return a float representing the water balance of the reservoir in cubic meters. # Constraints * All input parameters should be non-negative. # Performance Requirements * The function must operate in constant time (O(1)). # Examples ```python assert reservoir_water_balance(500, 300, 100, 50) == 250 assert reservoir_water_balance(1000, 800, 400, 200) == 400 assert reservoir_water_balance(200, 150, 50, 25) == 75 ``` # Notes * If any input parameter is negative, raise a `ValueError` with the message: \\"All parameters must be non-negative.\\"","solution":"def reservoir_water_balance(inflow: float, outflow: float, precipitation: float, evaporation: float) -> float: Calculate the water balance of a reservoir. Args: inflow (float): Non-negative inflow into the reservoir in cubic meters. outflow (float): Non-negative outflow from the reservoir in cubic meters. precipitation (float): Non-negative direct precipitation on the reservoir in cubic meters. evaporation (float): Non-negative evaporation from the reservoir in cubic meters. Returns: float: Water balance of the reservoir in cubic meters. Raises: ValueError: If any of the input parameters is negative. if inflow < 0 or outflow < 0 or precipitation < 0 or evaporation < 0: raise ValueError(\\"All parameters must be non-negative.\\") water_balance = (inflow + precipitation) - (outflow + evaporation) return water_balance"},{"question":"# Problem Statement Given an integer array `arr` and an integer `x`, your task is to find the shortest subarray whose sum is at least `x`. If no such subarray exists, return -1. # Function Signature ```python def shortest_subarray_with_sum_at_least_x(arr: list[int], x: int) -> int: ``` # Input * **arr** (*List[int]*): The list of integers ( -10^4 <= element <= 10^4 ). * **x** (*int*): The target sum (0 <= x <= 10^9). # Output * **int**: The length of the shortest subarray with sum at least x, or -1 if no such subarray exists. # Constraints * The length of the array will not exceed 10^5. * Handle edge cases where the array contains negative numbers or all zeros. * The sum of any elements of the array (including the maximum sum) can be very large (up to 10^9). # Example ```python >>> shortest_subarray_with_sum_at_least_x([2, 3, 1, 2, 4, 3], 7) 2 >>> shortest_subarray_with_sum_at_least_x([1, 4, 4], 8) 2 >>> shortest_subarray_with_sum_at_least_x([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 >>> shortest_subarray_with_sum_at_least_x([-1, 1, 1, 1, 1], 3) 3 ``` # Requirements * Your solution should be efficient and preferably run in linear or O(n log n) time. * Ensure that your solution handles arrays with negative integers gracefully. * Be prepared to handle very large sums due to high sum constraints.","solution":"from collections import deque def shortest_subarray_with_sum_at_least_x(arr: list[int], x: int) -> int: n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] deque_index = deque() min_length = float(\'inf\') for i in range(n + 1): while deque_index and prefix_sums[i] - prefix_sums[deque_index[0]] >= x: min_length = min(min_length, i - deque_index.popleft()) while deque_index and prefix_sums[i] <= prefix_sums[deque_index[-1]]: deque_index.pop() deque_index.append(i) return min_length if min_length != float(\'inf\') else -1"},{"question":"# Problem Description Write a function named `substring_indices` that takes two strings as arguments, `main_string` and `sub_string`, and returns a list of starting indices of all occurrences of `sub_string` in `main_string`. The output list should be in ascending order. If `sub_string` is not found in `main_string`, return an empty list. # Input - `main_string` (str): The string in which to search for the substring. - `sub_string` (str): The substring to search for within `main_string`. # Output - A list of integers representing the starting indices of each occurrence of `sub_string` in `main_string`. # Constraints - The length of `main_string` and `sub_string` can be different. - Both `main_string` and `sub_string` can be empty. - The function should be case-sensitive. # Example ```python >>> substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> substring_indices(\\"hello world\\", \\"o\\") [4, 7] >>> substring_indices(\\"mississippi\\", \\"iss\\") [1, 4] >>> substring_indices(\\"abcdef\\", \\"gh\\") [] ``` # Requirements * Implement the function `substring_indices` that meets the specifications. * Ensure the code passes all edge cases, including the non-overlapping occurrences of the `sub_string` in `main_string`.","solution":"def substring_indices(main_string, sub_string): Returns the starting indices of all occurrences of sub_string in main_string. if not main_string or not sub_string: return [] indices = [] start = 0 while start < len(main_string): start = main_string.find(sub_string, start) if start == -1: break indices.append(start) start += 1 return indices"},{"question":"# Question: Matrix Region Sum You are given a `m x n` matrix of integers and a list of queries. Each query contains four integers: `row1`, `col1`, `row2`, `col2`, which specify the top-left and bottom-right coordinates of a rectangular submatrix. Write a function that returns the sum of elements inside each submatrix for all queries. Function Signature ```python def matrix_region_sum(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Calculates the sum of elements within the specified submatrices defined by each query. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. queries (List[Tuple[int, int, int, int]]): A list of tuples where each tuple has four integers (row1, col1, row2, col2). Returns: List[int]: A list of integers, where each integer is the sum of elements for the corresponding query. ``` Input - `matrix`: A list of `m` rows and `n` columns of integers (1 ≤ m, n ≤ 100). - `queries`: A list of tuples, each containing four integers `(row1, col1, row2, col2)`. The list can contain up to 50 queries. - `row1`, `col1`: The top-left coordinates of the submatrix (0 ≤ row1 ≤ row2 < m, 0 ≤ col1 ≤ col2 < n). - `row2`, `col2`: The bottom-right coordinates of the submatrix (0 ≤ row1 ≤ row2 < m, 0 ≤ col1 ≤ col2 < n). Output - A list of integers, where each integer is the sum of elements inside the submatrix defined by the query\'s four integers. Example ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] queries = [ (1, 1, 2, 2), (0, 0, 1, 1), (2, 2, 3, 3) ] print(matrix_region_sum(matrix, queries)) # Output: [28, 14, 54] ``` Notes - Consider precomputing sums to handle multiple queries efficiently. - Ensure your implementation is optimized for space and time complexity, utilizing techniques such as prefix sums or integral image if necessary. - Edge cases may include submatrices that span the entire region, just one element, or multiple small areas spread across the matrix.","solution":"def matrix_region_sum(matrix, queries): Calculates the sum of elements within the specified submatrices defined by each query. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. queries (List[Tuple[int, int, int, int]]): A list of tuples where each tuple has four integers (row1, col1, row2, col2). Returns: List[int]: A list of integers, where each integer is the sum of elements for the corresponding query. if not matrix or not matrix[0] or not queries: return [] m, n = len(matrix), len(matrix[0]) # Precompute the prefix sums matrix prefix_sums = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sums[i][j] = matrix[i-1][j-1] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] # Initialize answer list result = [] # Process each query using the prefix sums matrix for row1, col1, row2, col2 in queries: submatrix_sum = (prefix_sums[row2+1][col2+1] - prefix_sums[row1][col2+1] - prefix_sums[row2+1][col1] + prefix_sums[row1][col1]) result.append(submatrix_sum) return result"},{"question":"**Graph Traversal Challenge: Shortest Path with Constraints** # Problem Statement: You are given a weighted, directed graph represented by an adjacency matrix and a constraint on the number of edges that can be utilized in the path. Implement a function `constrained_shortest_path(adj_matrix: List[List[int]], max_edges: int) -> Tuple[int, List[int]]` that finds the shortest path from node `0` to node `n-1` using at most `max_edges` edges. # Input - A 2D list `adj_matrix` representing the adjacency matrix of the graph, where `adj_matrix[i][j]` is the weight of the edge from node `i` to node `j`. If there is no direct edge, the weight is represented as `float(\'inf\')`. - An integer `max_edges` (1 ≤ `max_edges` ≤ 100), which is the maximum number of edges that can be used in the path. # Output - A tuple containing two elements: - An integer representing the shortest path cost from node `0` to node `n-1` using at most `max_edges` edges. If no such path exists, return `float(\'inf\')`. - A list of integers representing the nodes in the shortest path (including the start and end nodes). If no such path exists, return an empty list. # Example ```python >>> adj_matrix = [ ... [0, 10, 20, float(\'inf\'), float(\'inf\')], ... [float(\'inf\'), 0, 5, 1, float(\'inf\')], ... [float(\'inf\'), float(\'inf\'), 0, 2, 10], ... [float(\'inf\'), float(\'inf\'), float(\'inf\'), 0, 3], ... [float(\'inf\'), float(\'inf\'), float(\'inf\'), float(\'inf\'), 0] ... ] >>> max_edges = 3 >>> constrained_shortest_path(adj_matrix, max_edges) (14, [0, 1, 3, 4]) >>> max_edges = 1 >>> constrained_shortest_path(adj_matrix, max_edges) (float(\'inf\'), []) ``` # Constraints - You must use a dynamic programming approach to solve this problem. - Optimize your implementation to handle graphs efficiently. - You may assume that the graph does not contain negative weight cycles. Write your code below: ```python from typing import List, Tuple def constrained_shortest_path(adj_matrix: List[List[int]], max_edges: int) -> Tuple[int, List[int]]: n = len(adj_matrix) dp = [[[float(\'inf\'), []] for _ in range(max_edges + 1)] for _ in range(n)] dp[0][0] = [0, [0]] for e in range(1, max_edges + 1): for u in range(n): for v in range(n): if adj_matrix[u][v] < float(\'inf\') and dp[u][e-1][0] < float(\'inf\'): new_cost = dp[u][e-1][0] + adj_matrix[u][v] if new_cost < dp[v][e][0]: dp[v][e][0] = new_cost dp[v][e][1] = dp[u][e-1][1] + [v] min_cost = float(\'inf\') path = [] for e in range(max_edges + 1): if dp[-1][e][0] < min_cost: min_cost = dp[-1][e][0] path = dp[-1][e][1] return (min_cost, path) # Example usage if __name__ == \\"__main__\\": adj_matrix = [ [0, 10, 20, float(\'inf\'), float(\'inf\')], [float(\'inf\'), 0, 5, 1, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 0, 2, 10], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 0, 3], [float(\'inf\'), float(\'inf\'), float(\'inf\'), float(\'inf\'), 0] ] print(constrained_shortest_path(adj_matrix, 3)) print(constrained_shortest_path(adj_matrix, 1)) ```","solution":"from typing import List, Tuple def constrained_shortest_path(adj_matrix: List[List[int]], max_edges: int) -> Tuple[int, List[int]]: n = len(adj_matrix) dp = [[[float(\'inf\'), []] for _ in range(max_edges + 1)] for _ in range(n)] dp[0][0] = [0, [0]] for e in range(1, max_edges + 1): for u in range(n): for v in range(n): if adj_matrix[u][v] < float(\'inf\') and dp[u][e-1][0] < float(\'inf\'): new_cost = dp[u][e-1][0] + adj_matrix[u][v] if new_cost < dp[v][e][0]: dp[v][e][0] = new_cost dp[v][e][1] = dp[u][e-1][1] + [v] min_cost = float(\'inf\') path = [] for e in range(max_edges + 1): if dp[-1][e][0] < min_cost: min_cost = dp[-1][e][0] path = dp[-1][e][1] return (min_cost, path)"},{"question":"# Problem: Optimized Fibonacci Sequence Calculator You need to create a function that calculates the nth Fibonacci number using matrix exponentiation to optimize the computation. This method significantly improves performance for large values of n compared to the naive recursive or iterative methods. Function Specification: - **Function Name**: `optimized_fibonacci` - **Input**: - `n`: An integer, the position in the Fibonacci sequence (1-indexed, n ≥ 1). - **Output**: - An integer, the nth Fibonacci number. Constraints: 1. The function should handle large values of `n` efficiently, specifically up to (10^{18}). 2. Ensure the function operates within a reasonable time frame for the given constraint. 3. Use the method of matrix exponentiation for the implementation. 4. Handle edge cases such as the first few Fibonacci numbers correctly. # Task Description: Implement the `optimized_fibonacci` function that uses matrix exponentiation to calculate the nth Fibonacci number. The Fibonacci sequence is defined as: - (F(1) = 1) - (F(2) = 1) - (F(n) = F(n-1) + F(n-2)) for (n > 2) To use matrix exponentiation, you can represent the Fibonacci sequence transformation as follows: [ begin{pmatrix} F(n+1) F(n) end{pmatrix} = begin{pmatrix} 1 & 1 1 & 0 end{pmatrix} ^ n begin{pmatrix} F(1) F(0) end{pmatrix} ] Where, [ F(n) = begin{pmatrix} 1 & 1 1 & 0 end{pmatrix} ^ {n-1} begin{pmatrix} 1 0 end{pmatrix} ] Example: ```python def optimized_fibonacci(n: int) -> int: # Implementation here ``` Examples of how the function should behave: ```python assert optimized_fibonacci(1) == 1 # F(1) = 1 assert optimized_fibonacci(2) == 1 # F(2) = 1 assert optimized_fibonacci(3) == 2 # F(3) = 2 assert optimized_fibonacci(10) == 55 # F(10) = 55 assert optimized_fibonacci(50) == 12586269025 # F(50) = 12586269025 assert optimized_fibonacci(100) == 354224848179261915075 # F(100) assert optimized_fibonacci(1000) # large Fibonacci number should be calculated efficiently ``` # Requirements - Develop a function using matrix exponentiation to compute Fibonacci numbers up to position (10^{18}). - Ensure the function is optimized for performance and correctly handles edge cases including the smallest positions. - Provide thorough testing for various scenarios including small, large, and boundary values. Good luck and happy coding!","solution":"def optimized_fibonacci(n): Returns the nth Fibonacci number using matrix exponentiation. if n <= 0: raise ValueError(\\"n should be a positive integer\\") if n == 1 or n == 2: return 1 # Matrix multiplication utility def multiply_matrices(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] # Matrix exponentiation utility def matrix_power(matrix, power): result = [[1, 0], [0, 1]] base = matrix while power: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_power(F, n-1) return result_matrix[0][0]"},{"question":"# Linked List Reversal in Groups of K Given a singly linked list, your task is to implement a method that reverses the linked list in groups of size k. Requirements: 1. **Implement a `reverse_k_group` method**: This method should receive the head of the linked list and an integer k, and return the head of the modified linked list with every k nodes reversed. If the number of nodes is not a multiple of k, leave the remaining nodes as is. 2. **Implement a `print_list` method**: This method should print all the elements of the linked list from head to the end. # Input: 1. **Input linked list**: A singly linked list where each node contains an integer value. 2. **Input integer k**: The size of the groups for reversal. # Output: 1. **Output for `reverse_k_group` method**: The head of the modified linked list. 2. **Output for `print_list` method**: A space-separated string of integers representing the linked list from head to the end. # Constraints: - The size of the linked list will not exceed 10^4. - The integer values in the nodes are between -10^3 and 10^3. - 1 ≤ k ≤ length of linked list. Example: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head, k): if not head or k == 1: return head dummy = ListNode(0) dummy.next = head curr, nxt, prev = dummy, dummy, dummy count = 0 while curr.next: curr = curr.next count += 1 while count >= k: curr = prev.next nxt = curr.next for _ in range(1, k): curr.next = nxt.next nxt.next = prev.next prev.next = nxt nxt = curr.next prev = curr count -= k return dummy.next def print_list(head): result = [] while head: result.append(str(head.value)) head = head.next print(\' \'.join(result)) # Example usage head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))) new_head = reverse_k_group(head, 2) print_list(new_head) # Output: \\"2 1 4 3 6 5\\" new_head = reverse_k_group(new_head, 3) print_list(new_head) # Output: \\"4 1 2 5 6 3\\" ``` Ensure that your implementation is efficient and handles edge cases properly, such as when the length of the list is not a multiple of k.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head, k): if not head or k == 1: return head dummy = ListNode(0) dummy.next = head curr, nxt, prev = dummy, dummy, dummy count = 0 while curr.next: curr = curr.next count += 1 while count >= k: curr = prev.next nxt = curr.next for _ in range(1, k): curr.next = nxt.next nxt.next = prev.next prev.next = nxt nxt = curr.next prev = curr count -= k return dummy.next def print_list(head): result = [] while head: result.append(str(head.value)) head = head.next return \' \'.join(result)"},{"question":"# Problem Statement: Implement a function to merge two pre-sorted arrays into one sorted array. The function should take in two lists of integers that are already sorted in non-decreasing order and combine them into a single list that remains sorted in non-decreasing order. # Constraints: * Each of the input lists will contain at most 10^5 integers. * The integers in the input lists will be in the range from -10^9 to 10^9. * The combined length of both input lists will be at most 2 * 10^5. # Sample Input/Output: ```plaintext merge_sorted_arrays([1, 3, 5], [2, 4, 6]) Returns: [1, 2, 3, 4, 5, 6] merge_sorted_arrays([-5, 0, 3], [-4, -1, 2, 10]) Returns: [-5, -4, -1, 0, 2, 3, 10] merge_sorted_arrays([], [1, 2, 3]) Returns: [1, 2, 3] ``` # Function Signature: ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: pass ``` # Requirements: 1. Initialize an empty list for the merged output. 2. Use two pointers to iterate through each of the input lists. 3. Compare the current elements of both lists and append the smaller element to the merged list. 4. Increment the pointer of the list from which the element was chosen. 5. If one list is exhausted before the other, append the remaining elements of the other list to the merged list. 6. Return the sorted merged list. # Explanation: 1. Start with two pointers at the beginning of each input list. 2. Compare the elements pointed to by the pointers and add the smaller one to the merged list. 3. Move the pointer in the list where the element was taken from. 4. Continue until all elements from both lists have been processed. 5. Ensure the final merged list is sorted in non-decreasing order by appending any remaining elements from either list. # Edge Cases: * Handle cases where one or both of the input lists are empty, ensuring the function returns the non-empty list or an empty list as appropriate. * Consider lists with duplicate elements, making sure all duplicates are included in the final merged list. # Notes: * The approach should have a time complexity of O(n + m), where n and m are the lengths of the input lists, respectively. * Optimize for memory and speed, taking advantage of the already sorted nature of the input lists.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"# Coding Assessment Question: Sublist Sum Checker Context: Given a list of integers and an integer `target_sum`, you need to determine if there is a sublist (continuous segment of the list) whose sum equals `target_sum`. Task: Write a Python function `sublist_sum_checker` that takes a list of integers `numbers` and an integer `target_sum` and returns `True` if there exists at least one sublist with a sum equal to `target_sum`, and `False` otherwise. Input: * A list of integers `numbers` containing at least one element. * An integer `target_sum` representing the desired sum of the sublist. Output: * A boolean value: `True` if a sublist with a sum equal to `target_sum` exists, otherwise `False`. Constraints: * The length of the list `numbers` can be up to (10^5). * Elements in `numbers` can be both positive and negative. * `target_sum` is an integer which can be positive, negative or zero. Example: ```python >>> sublist_sum_checker([1, 2, 3, 4, 5], 9) True >>> sublist_sum_checker([1, 2, 3, 4, 5], 15) True >>> sublist_sum_checker([1, 2, 3, 4, 5], 20) False >>> sublist_sum_checker([-1, 2, 3, -2, 5], 4) True >>> sublist_sum_checker([1, 2, 3], -1) False ``` Requirements: 1. The function should efficiently check for any sublist sum matching the target. 2. Optimize your code for readability and efficiency. 3. Ensure that the function handles both positive and negative values. Performance: * The function should run in linear time ( O(n) ) using a sliding window or prefix sum technique. * Memory usage should be optimized. This question aligns with the complexity and style of the given questions, requires error handling, and incorporates fundamental programming skills and mathematical concepts.","solution":"def sublist_sum_checker(numbers, target_sum): Checks if there exists a sublist in numbers that sums to target_sum. current_sum = 0 prefix_sums = {0: -1} # prefix_sums dictionary to store (current_sum: index) for i, num in enumerate(numbers): current_sum += num # Check if there is any sublist which sums to target_sum if (current_sum - target_sum) in prefix_sums: return True if current_sum not in prefix_sums: prefix_sums[current_sum] = i return False"},{"question":"# Question: Evaluating Balanced Binary Search Trees You are given a binary search tree (BST) and need to determine whether the tree is balanced. A balanced binary search tree is defined as a tree where the height of the left and right subtrees of every node differ by no more than 1. Function Signature ```python def is_balanced(root: TreeNode) -> bool: ``` Input * The `root` of the binary search tree (which is a `TreeNode` object or `None`). Output * Return `True` if the binary search tree is balanced; otherwise, return `False`. Constraints * The number of nodes in the tree will not exceed (10^4). * The node values are arbitrary but follow the BST properties where left child < parent and right child > parent. Examples ```python # Example 1: # Creating a balanced binary search tree # 4 # / # 2 6 # / / # 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(6, TreeNode(5), TreeNode(7)) print(is_balanced(root)) # Output: True # Example 2: # Creating an unbalanced binary search tree # 1 # / # 2 3 # / # 4 # / # 5 root = TreeNode(1) root.left = TreeNode(2, TreeNode(4, TreeNode(5)), None) root.right = TreeNode(3) print(is_balanced(root)) # Output: False # Example 3: # Empty tree print(is_balanced(None)) # Output: True # Example 4: # Creating a tree with one node root = TreeNode(1) print(is_balanced(root)) # Output: True ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a binary search tree is balanced. A binary tree is balanced if the height of the left and right subtrees of every node differ by no more than 1. def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return height, balanced _, result = height_and_balance(root) return result"},{"question":"# Question: Find the Missing Number Context: You are working on a project involving data validation and correction. One of the datasets you\'re working with is supposed to contain a list of consecutive integers, but you suspect that one number might be missing. Your task is to identify the missing number in a list of consecutive integers. Problem Statement: Write a function `find_missing_number(nums: list) -> int` that finds the missing number from a list of consecutive integers starting from 1 to `n`. The list contains integers from 1 to `n` with exactly one number missing. Function Signature: ```python def find_missing_number(nums: list) -> int: ``` Input: - A list of integers `nums` representing a sequence of consecutive integers from 1 to `n` with one number missing. Output: - An integer representing the missing number in the list. Constraints: - The length of the list `nums` will be `n - 1`, where `1 <= n <= 10^6`. - The sequence will contain unique integers and exactly one integer will be missing. - The list may be provided in any order. Example: ```python print(find_missing_number([1, 2, 4, 5, 6])) # Output: 3 print(find_missing_number([9, 7, 6, 5, 8, 3, 2, 1])) # Output: 4 print(find_missing_number([1, 3])) # Output: 2 ``` Explanation: For the input `[1, 2, 4, 5, 6]`: - The full sequence should be `[1, 2, 3, 4, 5, 6]`. - We can see that `3` is missing from the provided list. For the input `[9, 7, 6, 5, 8, 3, 2, 1]`: - The full sequence should be `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. - We can see that `4` is missing from the provided list. **Your task** is to implement the function `find_missing_number` following the guidelines provided.","solution":"def find_missing_number(nums): Finds the missing number from a list of consecutive integers starting from 1 to n. Args: nums (list): A list of integers representing a sequence of consecutive integers from 1 to n with one number missing. Returns: int: The missing number in the list. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum # Examples: # print(find_missing_number([1, 2, 4, 5, 6])) # Output: 3 # print(find_missing_number([9, 7, 6, 5, 8, 3, 2, 1])) # Output: 4 # print(find_missing_number([1, 3])) # Output: 2"},{"question":"# Stack Sequence Validation In this challenge, you will implement a function that checks if a given sequence of integers can represent a series of push and pop operations on a stack, starting with an empty stack. # Requirements 1. Implement a function `validate_stack_sequences(pushed: List[int], popped: List[int]) -> bool` that returns `True` if the given sequence of operations can be performed on a stack, and `False` otherwise. # Function Signature ```python def validate_stack_sequences(pushed: List[int], popped: List[int]) -> bool: pass ``` # Input * `pushed`: A list of integers representing the sequence in which numbers are pushed onto the stack. * `popped`: A list of integers representing the sequence in which numbers are popped off the stack. # Output * Returns a boolean indicating whether the given sequences of operations are valid. # Constraints * (1 leq len(pushed) leq 1000) * (len(pushed) == len(popped)) * The integers in the input lists are unique. # Example ```python pushed = [1, 2, 3, 4, 5] popped = [4, 5, 3, 2, 1] print(validate_stack_sequences(pushed, popped)) # Output: True pushed = [1, 2, 3, 4, 5] popped = [4, 3, 5, 1, 2] print(validate_stack_sequences(pushed, popped)) # Output: False ``` # Explanation In the first example, the sequence of operations is valid: 1. Push 1 onto the stack. 2. Push 2 onto the stack. 3. Push 3 onto the stack. 4. Push 4 onto the stack. 5. Pop 4 from the stack. 6. Push 5 onto the stack. 7. Pop 5 from the stack. 8. Pop 3 from the stack. 9. Pop 2 from the stack. 10. Pop 1 from the stack. In the second example, the sequence of operations is not valid because it\'s impossible to pop 1 before popping 2 according to the sequence of pushes and pops.","solution":"def validate_stack_sequences(pushed, popped): stack = [] j = 0 for x in pushed: stack.append(x) while stack and stack[-1] == popped[j]: stack.pop() j += 1 return not stack"},{"question":"# Problem Statement Write a function that merges two sorted arrays into a single sorted array. The merging process should maintain the non-decreasing order of the elements. You have to complete the function `merge_sorted_arrays` which takes two sorted arrays as inputs and returns a single merged sorted array. # Function Signature ```python def merge_sorted_arrays(arr1: list, arr2: list) -> list: Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): A list of integers sorted in non-decreasing order arr2 (list): A list of integers sorted in non-decreasing order Returns: list: A list containing all elements from arr1 and arr2 in non-decreasing order Raises: TypeError: If either input is not a list or contains non-integer elements. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([-1, 0, 1], [-2, 2]) [-2, -1, 0, 1, 2] >>> merge_sorted_arrays([1, 2], [3, \\"4\\"]) Traceback (most recent call last): ... TypeError: Both arrays MUST only contain integers! >>> merge_sorted_arrays(\\"1, 2\\", [3, 4]) Traceback (most recent call last): ... TypeError: Inputs MUST be lists! pass ``` # Requirements * The arrays may contain duplicate elements. * Both inputs must be validated to only contain integers, raising a `TypeError` if they contain any non-integer elements or if the inputs themselves are not lists. * Your function should handle edge cases such as empty arrays. * The function should be efficient, with a linear time complexity in relation to the total number of elements in both arrays. # Constraints * The number of elements in each array will be within the range of typical array sizes in practical scenarios (i.e., up to 10^4 elements per array). # Testing Ensure your solution is thoroughly tested with a wide range of array sizes and scenarios, including arrays that are already in a fully merged state, completely disjoint arrays, and arrays with overlapping values. Check for type validation with incorrect input types such as nested lists, strings, or mixed data types within arrays.","solution":"def merge_sorted_arrays(arr1: list, arr2: list) -> list: Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): A list of integers sorted in non-decreasing order arr2 (list): A list of integers sorted in non-decreasing order Returns: list: A list containing all elements from arr1 and arr2 in non-decreasing order Raises: TypeError: If either input is not a list or contains non-integer elements. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([-1, 0, 1], [-2, 2]) [-2, -1, 0, 1, 2] >>> merge_sorted_arrays([1, 2], [3, \\"4\\"]) Traceback (most recent call last): ... TypeError: Both arrays MUST only contain integers! >>> merge_sorted_arrays(\\"1, 2\\", [3, 4]) Traceback (most recent call last): ... TypeError: Inputs MUST be lists! if not isinstance(arr1, list) or not isinstance(arr2, list): raise TypeError(\\"Inputs MUST be lists!\\") if not all(isinstance(x, int) for x in arr1) or not all(isinstance(x, int) for x in arr2): raise TypeError(\\"Both arrays MUST only contain integers!\\") merged = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"# Adjacency List Creation You are given a list of edges representing an undirected graph. Your task is to implement a function that converts this edge list into an adjacency list. An adjacency list is a dictionary where the key is a node and the value is a list of nodes that are directly connected to the key node. # Input 1. **edges**: A list of tuples, where each tuple (u, v) represents an undirected edge between node u and node v. Each node is an integer. # Output * Return a dictionary representing the adjacency list of the graph. # Constraints * There can be up to 10,000 edges in the list. * The node values will be non-negative integers and will fit within a standard 32-bit integer. # Example ```python edges = [ (0, 1), (0, 2), (1, 2), (2, 3) ] # After converting to an adjacency list, the output should be: # { # 0: [1, 2], # 1: [0, 2], # 2: [0, 1, 3], # 3: [2] # } ``` # Implementation Hints * You may find it useful to iterate through the edges and populate the dictionary accordingly. * Remember that since the graph is undirected, for each edge (u, v), both u and v should have each other in their respective adjacency lists. * Ensure your function can handle the scenario where there are nodes without edges (i.e., nodes that are isolated). Write a function `create_adjacency_list(edges)` that takes a list of graph edges `edges` and returns the adjacency list as a dictionary.","solution":"def create_adjacency_list(edges): Converts a list of edges into an adjacency list. Parameters: edges (list of tuples): A list of tuples where each tuple represents an edge in the graph. Returns: dict: An adjacency list representation of the graph. adjacency_list = {} for u, v in edges: if u not in adjacency_list: adjacency_list[u] = [] if v not in adjacency_list: adjacency_list[v] = [] adjacency_list[u].append(v) adjacency_list[v].append(u) return adjacency_list"},{"question":"# Matrix Spiral Traversal **Context**: You are working with two-dimensional data structures and often need to convert them into one-dimensional representations for analysis. A common way to traverse and flatten a matrix is by following a spiral order. **Task**: Implement a function to traverse a given `m x n` matrix in spiral order and return all elements of the matrix in a single, flattened list. Function Signature ```python def spiral_order(matrix: list[list[int]]) -> list[int]: pass ``` Input * A two-dimensional list of integers representing an `m x n` matrix. Output * A one-dimensional list of integers representing the elements of the matrix traversed in spiral order. Constraints * The function should raise a `ValueError` if the input matrix is empty or any row in the matrix does not have the same number of columns. Examples ```python >>> spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([[1]]) [1] >>> spiral_order([]) Traceback (most recent call last): ... ValueError: Input matrix must not be empty >>> spiral_order([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: All rows in the matrix must have the same number of columns ``` **Performance Requirements**: * Your implementation should handle matrices with up to 1000 rows and 1000 columns efficiently. * Aim for a time complexity of O(m * n), where `m` is the number of rows and `n` is the number of columns in the matrix. **Edge Cases**: * Handle empty matrices or matrices with inconsistent row lengths by raising appropriate exceptions. * Ensure that matrices of various dimensions (including 1x1, 1xN, and Mx1) are correctly handled. Please implement the function `spiral_order` as described above.","solution":"def spiral_order(matrix): Traverse and return the elements of a matrix in spiral order. Args: matrix (list[list[int]]): 2D list representing the matrix. Returns: list[int]: List of elements in the matrix in spiral order. Raises: ValueError: If matrix is empty or rows have inconsistent lengths. if not matrix: raise ValueError(\\"Input matrix must not be empty\\") rows = len(matrix) cols = len(matrix[0]) for row in matrix: if len(row) != cols: raise ValueError(\\"All rows in the matrix must have the same number of columns\\") result = [] left, right, top, bottom = 0, cols - 1, 0, rows - 1 while left <= right and top <= bottom: # Traverse from left to right for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse from top to bottom for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Question: Efficient Matrix Transposition and Summation Context You are part of a data processing team tasked with handling large matrices for a machine learning application. One operation that needs optimization is the transposition of a matrix followed by the summation of its rows. This operation is frequently used in preprocessing and model evaluation steps. Task Implement a function that efficiently transposes a given **mxn** matrix and then computes the sum of each row of the transposed matrix. # Requirements 1. **Function Signature**: `def transpose_and_sum(matrix: List[List[int]]) -> List[int]:` 2. **Input**: - A 2D list of integers, `matrix`, representing an **mxn** matrix. - Example: ```python [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` 3. **Output**: - A list of integers representing the sum of each row in the transposed matrix. - Example: ```python [12, 15, 18] ``` 4. **Constraints**: - The matrix will have at least 1 row and 1 column. - Each row in the input matrix will have the same number of columns. - The matrix can be large (up to **1000x1000** elements). # Performance Expectations - The solution should be optimized for large matrices. - Aim for time complexity no worse than **O(m*n)** and space complexity no worse than **O(m*n)**. Example ```python >>> transpose_and_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [12, 15, 18] >>> transpose_and_sum([ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8] ... ]) [16, 20] ```","solution":"from typing import List def transpose_and_sum(matrix: List[List[int]]) -> List[int]: Transposes the given mxn matrix and returns a list containing the sums of each row of the transposed matrix. if not matrix or not matrix[0]: return [] # Transpose the matrix transposed = list(zip(*matrix)) # Calculate the sum of each row in the transposed matrix result = [sum(row) for row in transposed] return result"},{"question":"# Inventory Management System Context As a logistics manager, you need an efficient system to track the inventory levels of various items in a warehouse. Your task is to develop a function that manages the addition, removal, and querying of item quantities in the inventory. Problem Statement You will write a function `inventory_manager` which takes a list of operations and processes them to maintain the current state of the inventory. Input * `operations`: A list of strings where each string represents an operation to be performed on the inventory. The operations can be of three types: - `\\"ADD item_name quantity\\"`: Add the specified quantity of the item to the inventory. - `\\"REMOVE item_name quantity\\"`: Remove the specified quantity of the item from the inventory. The quantity to be removed will not exceed the current quantity of the item. - `\\"QUERY item_name\\"`: Return the current quantity of the specified item in the inventory. Output * A list of integers corresponding to the results of the QUERY operations in the order they appear. Constraints 1. The item names will be non-empty strings containing only alphanumeric characters and underscores. 2. Quantities are non-negative integers. 3. The `operations` list will have at least one operation and no more than 1000 operations. Example Usage ```python operations = [ \\"ADD apple 50\\", \\"ADD banana 30\\", \\"REMOVE apple 10\\", \\"QUERY apple\\", \\"QUERY banana\\", \\"ADD banana 10\\", \\"REMOVE banana 20\\", \\"QUERY banana\\" ] assert inventory_manager(operations) == [40, 30, 20] ``` Function Signature ```python def inventory_manager(operations: List[str]) -> List[int]: pass ``` Notes Your task is to handle the operations efficiently and maintain an up-to-date inventory based on the operations provided. Ensure the function returns the correct results for QUERY operations while accurately updating the inventory for ADD and REMOVE operations.","solution":"def inventory_manager(operations): inventory = {} results = [] for operation in operations: parts = operation.split() action = parts[0] item_name = parts[1] if action == \\"ADD\\": quantity = int(parts[2]) if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity elif action == \\"REMOVE\\": quantity = int(parts[2]) if item_name in inventory: inventory[item_name] -= quantity elif action == \\"QUERY\\": if item_name in inventory: results.append(inventory[item_name]) else: results.append(0) return results"},{"question":"List Permutations with Constraints # Problem Statement: In combinatorics, permutations refer to all possible arrangements of a set of objects. Sometimes, there are constraints that must be respected. For this problem, you are given a list of unique integers and a set of constraints in the form of pairs. Each pair indicates that one integer must come before another in the permutation. Your task is to generate all possible valid permutations given these constraints. Write a function `valid_permutations(arr: List[int], constraints: List[Tuple[int, int]]) -> List[List[int]]` that: - Takes a list of unique integers `arr` representing the set of objects to permute. - Takes a list of pairs `constraints` where each pair (a, b) indicates that `a` must appear before `b` in any valid permutation. - Returns a list of all possible valid permutations, where each permutation is a list of integers. # Function Signature: ```python from typing import List, Tuple def valid_permutations(arr: List[int], constraints: List[Tuple[int, int]]) -> List[List[int]]: pass ``` # Input: - A list of unique integers `arr` where ( 1 leq text{len(arr)} leq 8 ). - A list of pairs `constraints` where ( 0 leq text{len(constraints)} leq 28 ). # Output: - A list of lists, where each list represents a valid permutation adhering to the given constraints. # Constraints: - The integers in `arr` are unique. - Each pair (a, b) in `constraints` ensures that `a` must appear before `b` in any valid permutation. # Examples: ```python assert valid_permutations([1, 2, 3], [(1, 2)]) == [[1, 2, 3], [1, 3, 2]] assert valid_permutations([1, 2, 3], [(1, 2), (2, 3)]) == [[1, 2, 3]] assert valid_permutations([3, 1, 2], []) == [[3, 1, 2], [3, 2, 1], [1, 3, 2], [1, 2, 3], [2, 3, 1], [2, 1, 3]] ``` # Implementation Guidance: - Consider using backtracking or a topological sort approach to generate permutations that respect the constraints. - Ensure that all constraints are checked and respected before concluding a permutation is valid.","solution":"from typing import List, Tuple from itertools import permutations def valid_permutations(arr: List[int], constraints: List[Tuple[int, int]]) -> List[List[int]]: def respects_constraints(p): for a, b in constraints: if p.index(a) > p.index(b): return False return True all_perms = permutations(arr) valid_perms = [list(p) for p in all_perms if respects_constraints(p)] return valid_perms"},{"question":"# Data Compression with Run-Length Encoding Problem Statement The task is to implement a function that takes in a string and returns its run-length encoded form. Run-length encoding (RLE) is a simple form of data compression in which consecutive occurrences of the same character are replaced by a single character followed by the number of occurrences. If the compressed string is not smaller than the original string, the original string should be returned. Function Specifications ```python def run_length_encode(s: str) -> str: Encodes the given string using run-length encoding. :param s: The input string :return: The run-length encoded string or the original string if compression does not reduce the size pass # To be implemented by the student ``` Input and Output * **Input**: A string ( s ) consisting of uppercase and lowercase letters (a-z, A-Z). * **Output**: A string representing the run-length encoded version of `s` or the original string if the encoded version is not smaller. Constraints * The input string length should be between 1 and ( 10^5 ). Example ```python >>> run_length_encode(\\"aaabccddd\\") \\"a3b1c2d3\\" >>> run_length_encode(\\"abcd\\") \\"abcd\\" ``` Edge Cases 1. Strings with only one character. 2. Strings where no compression is possible. 3. Very long strings with varying character frequency patterns. Notes 1. The function should efficiently handle large strings within the given constraints. 2. Ensure that the encoding correctly groups and counts character sequences. 3. Consider edge cases where the encoded string might not be shorter than the original.","solution":"def run_length_encode(s: str) -> str: Encodes the given string using run-length encoding. :param s: The input string :return: The run-length encoded string or the original string if compression does not reduce the size if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_str.append(f\\"{current_char}{count}\\") encoded_result = \'\'.join(encoded_str) if len(encoded_result) >= len(s): return s return encoded_result"},{"question":"# Coding Assessment Question Context You have been assigned a task to assist a team of archaeologists in mapping out a treasure hunt expedition. The treasure map is represented as a binary grid where \'1\' indicates a cell that can be traversed, and \'0\' indicates an impassable cell. The archaeologists need to find the size of the largest cluster of connected travesable cells to focus their search in those areas. The cells are connected if they are directly adjacent horizontally or vertically (but not diagonally). Problem Statement Implement the function `largest_cluster_size` to find the size of the largest connected cluster of traversable cells in a given binary grid. Function Signature ```python from typing import List def largest_cluster_size(grid: List[List[int]]) -> int: ``` Input * `grid` (List[List[int]]): A 2D list of integers where 1 represents a traversable cell, and 0 represents an impassable cell. Output * An integer representing the size of the largest connected cluster of traversable cells. Constraints * The grid will always be non-empty with (1 leq rows times cols leq 1000). * All elements within the grid are either 0 or 1. Example ```python >>> grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 1, 1, 0], [0, 1, 1, 0, 0] ] >>> largest_cluster_size(grid) 6 >>> grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] >>> largest_cluster_size(grid) 1 >>> grid = [ [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] >>> largest_cluster_size(grid) 3 ``` Notes - Ensure to test the function thoroughly with edge cases. - Consider the potential for large grids and the impact on the performance. - The cells are considered connected if they are adjacent horizontally or vertically.","solution":"from typing import List def largest_cluster_size(grid: List[List[int]]) -> int: def dfs(x, y): # Check for out-of-bounds or if the cell is not traversable if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited grid[x][y] = 0 # Initialize cluster size size = 1 # Explore all four possible directions (up, down, left, right) size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_cluster_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: cluster_size = dfs(i, j) max_cluster_size = max(max_cluster_size, cluster_size) return max_cluster_size"},{"question":"# Coding Assessment Question **Context**: You are developing an e-commerce website with a functionality for customers to track their order status. Orders can have multiple statuses like \'Processing\', \'Shipped\', \'Out for Delivery\', \'Delivered\', etc. To assist customers efficiently, one of your tasks is to create a module that tracks and updates the status of a list of orders in bulk. **Task**: Implement a function `update_order_status` that takes in a list of order dictionaries and updates their status based on the current date compared to the order\'s estimated delivery date. The statuses are pre-defined as follows: - If the current date is less than the estimated delivery date, the status should be \'Shipped\'. - If the current date is exactly the estimated delivery date, the status should be \'Out for Delivery\'. - If the current date is greater than the estimated delivery date, the status should be \'Delivered\'. # Function Signature ```python def update_order_status(orders: list, current_date: str) -> list: ``` # Input * `orders` (list): A list of dictionaries, each containing: * `order_id` (str): The unique identifier for the order. * `estimated_delivery_date` (str): The estimated delivery date in \'YYYY-MM-DD\' format. * `status` (str): The current status of the order (\'Processing\', \'Shipped\', \'Out for Delivery\', \'Delivered\'). * `current_date` (str): The current date in \'YYYY-MM-DD\' format. # Output * Returns the updated list `orders` after modifying the `status` of each order based on the given rules. # Constraints * The `orders` list is not empty and contains valid order dictionaries. * Each date string is guaranteed to be a valid date in the \'YYYY-MM-DD\' format. * The `current_date` is a valid date in the \'YYYY-MM-DD\' format. # Example ```python orders = [ {\\"order_id\\": \\"1001\\", \\"estimated_delivery_date\\": \\"2023-11-05\\", \\"status\\": \\"Processing\\"}, {\\"order_id\\": \\"1002\\", \\"estimated_delivery_date\\": \\"2023-10-14\\", \\"status\\": \\"Processing\\"}, {\\"order_id\\": \\"1003\\", \\"estimated_delivery_date\\": \\"2023-10-11\\", \\"status\\": \\"Processing\\"}, ] current_date = \\"2023-10-14\\" updated_orders = update_order_status(orders, current_date) # Expected Output # [ # {\\"order_id\\": \\"1001\\", \\"estimated_delivery_date\\": \\"2023-11-05\\", \\"status\\": \\"Shipped\\"}, # {\\"order_id\\": \\"1002\\", \\"estimated_delivery_date\\": \\"2023-10-14\\", \\"status\\": \\"Out for Delivery\\"}, # {\\"order_id\\": \\"1003\\", \\"estimated_delivery_date\\": \\"2023-10-11\\", \\"status\\": \\"Delivered\\"}, # ] ``` # Notes 1. Use the `datetime` module to handle date comparisons. 2. Ensure the function processes each order independently and updates their statuses accurately. 3. Consider edge cases such as handling orders with past, present, and future delivery dates in relation to the current date.","solution":"from datetime import datetime def update_order_status(orders, current_date): Updates the status of orders based on the given current date. Args: orders (list): A list of dictionaries where each dictionary contains order_id, estimated_delivery_date, and status. current_date (str): The current date in \'YYYY-MM-DD\' format. Returns: list: The updated list of orders with their statuses changed appropriately. current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") for order in orders: estimated_delivery_date = datetime.strptime(order[\\"estimated_delivery_date\\"], \\"%Y-%m-%d\\") if current_date < estimated_delivery_date: order[\\"status\\"] = \\"Shipped\\" elif current_date == estimated_delivery_date: order[\\"status\\"] = \\"Out for Delivery\\" else: order[\\"status\\"] = \\"Delivered\\" return orders"},{"question":"# Polynomial Roots Finder Problem Description You are required to compute the real roots of a quadratic polynomial. The polynomial is represented as `ax^2 + bx + c = 0`, and its real roots can be found using the quadratic formula: [ x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ] Task Requirements Implement the function `find_roots(a: float, b: float, c: float) -> dict[str, float]` that takes: - `a` (coefficient of (x^2)) in the quadratic polynomial - `b` (coefficient of (x)) in the quadratic polynomial - `c` (constant term) in the quadratic polynomial The function must compute and return a dictionary containing the real roots of the polynomial. If the polynomial has two distinct real roots, return a dictionary with keys `\'root1\'` and `\'root2\'`, where the values are the respective roots. If the polynomial has one real root (when the discriminant ((b^2 - 4ac)) is zero), return a dictionary with a single key `\'root\'` and the corresponding value. If the polynomial has no real roots, return an empty dictionary. Input and Output - **Input**: Three float values for coefficients `a`, `b`, and `c` respectively. - **Output**: A dictionary containing the real roots of the polynomial. Constraints - If `a` is zero, raise a `ValueError` with the message: `\\"Coefficient \'a\' cannot be zero\\"` - Real roots only; imaginary roots should result in an empty dictionary. - For valid inputs, return the roots in ascending order if there are two distinct roots. Example ```python >>> find_roots(1, -3, 2) {\'root1\': 1.0, \'root2\': 2.0} >>> find_roots(1, 2, 1) {\'root\': -1.0} >>> find_roots(1, 1, 1) {} ``` Function Signature ```python def find_roots(a: float, b: float, c: float) -> dict[str, float]: pass ```","solution":"import math def find_roots(a: float, b: float, c: float) -> dict[str, float]: Given the coefficients of a quadratic polynomial, find its real roots. Args: a (float): Coefficient of x^2 b (float): Coefficient of x c (float): Constant term Returns: dict: A dictionary containing the real roots with keys \'root1\' and \'root2\' if there are two distinct real roots, \'root\' if there is one real root, or an empty dictionary if there are no real roots. Raises: ValueError: If the coefficient \'a\' is zero. if a == 0: raise ValueError(\\"Coefficient \'a\' cannot be zero\\") discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b - math.sqrt(discriminant)) / (2 * a) root2 = (-b + math.sqrt(discriminant)) / (2 * a) return {\'root1\': min(root1, root2), \'root2\': max(root1, root2)} elif discriminant == 0: root = -b / (2 * a) return {\'root\': root} else: return {}"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the frequency of each unique word in a given list of sentences. The function should ignore case (i.e., treat \'Word\' and \'word\' as the same word) and return a dictionary where the keys are the words and the values are their respective frequencies. # Function Signature ```python def word_frequency(sentences: List[str]) -> Dict[str, int]: pass ``` # Input/Output Requirements * **Input**: A single argument: - `sentences` (List[str]): A list of strings, where each string is a sentence consisting of words separated by spaces. * **Output**: - Returns a dictionary where the keys are words (in lowercase) and the values are their corresponding frequencies in the input sentences. # Constraints - Each sentence will have a length of at most 10^5. - The list will contain at most 1000 sentences. - Words are defined as sequences of alphabetic characters, possibly followed by digits. - Sentences may contain punctuation and special characters which should be ignored. # Performance Requirements - The function should have a time complexity of O(n) where n is the cumulative length of all sentences. - The space complexity should not exceed O(n). # Scenario Imagine you are developing a text analysis tool for processing large volumes of text data. This tool will help in generating word frequency statistics, which are crucial for tasks such as keyword extraction and trend analysis. # Example ```python >>> word_frequency([\\"Hello world!\\", \\"World of PYTHON.\\", \\"hello WORLD of code\\"]) {\'hello\': 2, \'world\': 3, \'of\': 2, \'python\': 1, \'code\': 1} >>> word_frequency([\\"Data, Science!\\", \\"Machine-learning AI.\\", \\"Data AI\\"]) {\'data\': 2, \'science\': 1, \'machine\': 1, \'learning\': 1, \'ai\': 2} ``` # Solution Requirements - Implement the `word_frequency` function following the above specifications. - Ensure the solution is efficient and can handle edge cases effectively. - Use appropriate data structures to manage word counting and case normalization.","solution":"import re from typing import List, Dict from collections import defaultdict def word_frequency(sentences: List[str]) -> Dict[str, int]: word_count = defaultdict(int) for sentence in sentences: # Convert to lower case and find all words ignoring punctuation words = re.findall(r\'bw+b\', sentence.lower()) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Question Title: Weather Data Analyzer with Safe Dictionary Access # Scenario You have been tasked with developing a script that processes weather data from a JSON API response. This data includes details such as temperature, humidity, and weather conditions. Your script needs to handle missing keys gracefully and provide sensible default values when needed. # Requirements 1. **Data Fetching**: - Use the `requests` library to fetch JSON content from the URL `https://api.mockweather.com/data`. - Consider that the API may intermittently provide incomplete data or missing keys. 2. **Safe Dictionary Access**: - Implement a helper function `safe_get` that retrieves data from a dictionary safely, returning a default value if the key does not exist. - Use this helper function to extract the temperature, humidity, and condition from the JSON response. 3. **WeatherData Named Tuple**: - Organize the extracted data into a named tuple `WeatherData` with fields `temperature`, `humidity`, and `condition`. - Use default values: `temperature` should default to `0.0`, `humidity` to `0`, and `condition` to `\\"Unknown\\"`. 4. **Error Handling**: - Handle potential HTTP errors (e.g., 404, 500) and network issues (e.g., timeouts). - Print an appropriate message if the fetched JSON structure does not match the expected format. # Function Signature Implement the following functions: ```python from typing import Any, Dict from collections import namedtuple WeatherData = namedtuple(\'WeatherData\', [\'temperature\', \'humidity\', \'condition\']) def safe_get(d: Dict[str, Any], key: str, default: Any) -> Any: pass def fetch_weather_data(url: str = \\"https://api.mockweather.com/data\\") -> WeatherData: pass ``` # Input The main function `fetch_weather_data` uses a default URL, but you can override it if desired. # Output The function should return a `WeatherData` named tuple containing: - `temperature`: The current temperature (default to `0.0` if missing). - `humidity`: The current humidity level (default to `0` if missing). - `condition`: The current weather condition (default to `\\"Unknown\\"` if missing). # Constraints - Use the `requests` library for fetching data. - Manage missing keys in the JSON response with the `safe_get` helper function. - Implement error handling for network reliability and JSON parsing. # Example Usage ```python weather = fetch_weather_data() print(f\\"Temperature: {weather.temperature}°C\\") print(f\\"Humidity: {weather.humidity}%\\") print(f\\"Condition: {weather.condition}\\") ``` Expected output (subject to current weather data): ``` Temperature: 22.5°C Humidity: 56% Condition: Clear ``` Write your implementation of `fetch_weather_data` and ensure it meets the requirements specified above. Utilize the `safe_get` helper function within your implementation to access dictionary keys safely.","solution":"import requests from typing import Any, Dict from collections import namedtuple # Define the WeatherData named tuple WeatherData = namedtuple(\'WeatherData\', [\'temperature\', \'humidity\', \'condition\']) def safe_get(d: Dict[str, Any], key: str, default: Any) -> Any: Safely returns the value for the given key from the dictionary. If the key does not exist, returns the provided default value. return d.get(key, default) def fetch_weather_data(url: str = \\"https://api.mockweather.com/data\\") -> WeatherData: Fetches weather data from the given URL and returns it as a WeatherData named tuple. If keys are missing in the JSON response, provides sensible defaults. try: response = requests.get(url) response.raise_for_status() data = response.json() # Extract data using safe_get with defaults temperature = safe_get(data, \'temperature\', 0.0) humidity = safe_get(data, \'humidity\', 0) condition = safe_get(data, \'condition\', \\"Unknown\\") return WeatherData(temperature=temperature, humidity=humidity, condition=condition) except requests.exceptions.RequestException as e: print(f\\"HTTP error occurred: {e}\\") return WeatherData(temperature=0.0, humidity=0, condition=\\"Unknown\\") except ValueError as e: print(f\\"JSON decoding failed: {e}\\") return WeatherData(temperature=0.0, humidity=0, condition=\\"Unknown\\")"},{"question":"# Context You are developing an e-commerce platform that handles customer orders. One key feature involves predicting the minimum time required to fulfill an order based on a set of ongoing tasks (representing stages in order processing) and their respective dependencies. # Task Implement the `OrderFulfillment` class. This class will help determine the minimum time needed to complete all tasks in order to fulfill an order. Method Details 1. **`__init__(self, tasks: list[tuple[str, int]], dependencies: list[tuple[str, str]])`**: * Initializes the class with a list of tasks and their respective duration times (in minutes). * Initializes the class with a list of dependencies, each represented by a tuple where the first task depends on the completion of the second task. * Constructs the necessary graph structures and metadata for tracking task durations and dependencies. 2. **`get_minimum_time(self) -> int`**: * Computes and returns the minimum time required to complete all tasks, considering dependencies. * Uses topological sorting to resolve the order of task execution and calculates the total time considering task durations. # Requirement Ensure your implementation of the `OrderFulfillment` class: * **Handles edge cases**: such as circular dependencies. * **Efficiently computes**: the minimum fulfillment time, even for large sets of tasks and complex dependency graphs. * **Produces accurate predictions**: conforming to the provided task durations and dependencies. # Input and Output * Input: * A list of tuples `tasks`, where each tuple contains a task label (string) and its duration (integer). * A list of tuples `dependencies`, where each tuple contains two task labels, indicating a dependency. * Output: * An integer value representing the minimum time required to complete all tasks. # Example ```python tasks = [(\\"A\\", 3), (\\"B\\", 2), (\\"C\\", 1), (\\"D\\", 4), (\\"E\\", 6)] dependencies = [(\\"B\\", \\"A\\"), (\\"C\\", \\"B\\"), (\\"D\\", \\"A\\"), (\\"E\\", \\"D\\")] order_fulfillment = OrderFulfillment(tasks, dependencies) print(order_fulfillment.get_minimum_time()) # Output: 13 ``` # Constraints * Number of tasks: (1 leq |tasks| leq 10^4) * Duration of each task: (1 leq text{duration} leq 10^2) * Number of dependencies: (0 leq |dependencies| leq 5 times 10^4) **Note**: Make sure to handle edge cases effectively and optimize the solution for performance with respect to time and space complexity.","solution":"from collections import defaultdict, deque class OrderFulfillment: def __init__(self, tasks: list[tuple[str, int]], dependencies: list[tuple[str, str]]): self.tasks = {task: duration for task, duration in tasks} self.graph = defaultdict(list) self.in_degree = {task: 0 for task, _ in tasks} for task, dep in dependencies: self.graph[dep].append(task) self.in_degree[task] += 1 def get_minimum_time(self) -> int: zero_in_degree_queue = deque([task for task in self.tasks if self.in_degree[task] == 0]) total_time = {task: self.tasks[task] for task in self.tasks} completed_tasks = 0 while zero_in_degree_queue: current = zero_in_degree_queue.popleft() completed_tasks += 1 for neighbor in self.graph[current]: self.in_degree[neighbor] -= 1 total_time[neighbor] = max(total_time[neighbor], total_time[current] + self.tasks[neighbor]) if self.in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if completed_tasks != len(self.tasks): raise ValueError(\\"There is a circular dependency among tasks.\\") return max(total_time.values())"},{"question":"# Scenario You are given a database of student records, including their IDs, names, and grades for various courses. Your task is to create a command-line interface (CLI) tool that allows a user to interact with this database to add, remove, update, and query student records. # Problem Statement Implement a CLI tool in Python called `StudentRecords` that allows a user to manage student records. The tool should support the following commands: 1. `add_student <ID> <name>`: Adds a new student with the given ID and name. 2. `remove_student <ID>`: Removes the student with the given ID. 3. `update_grade <ID> <course> <grade>`: Updates the grade for the given course of the student with the given ID. If the course does not exist for that student, it should be added. 4. `query_student <ID>`: Prints the details (ID, name, and all courses with grades) of the student with the given ID. # Specifications * **Input**: Commands are provided through the command line as strings. * **Output**: The CLI should print appropriate messages confirming actions or displaying queried information. * **Constraints**: * Student IDs are unique integers. * Names are non-empty strings. * Grades are integers between 0 and 100. * Courses are non-empty strings. * **Data Storage**: * Use a dictionary to store the student records, where the key is the student ID and the value is another dictionary containing the student\'s name and another dictionary for their courses and grades. # Example ```python # Example commands and expected output > add_student 1 \\"Alice\\" Student 1 added: Alice > add_student 2 \\"Bob\\" Student 2 added: Bob > update_grade 1 \\"Math\\" 95 Updated grade for student 1: Math = 95 > update_grade 2 \\"Science\\" 85 Updated grade for student 2: Science = 85 > query_student 1 ID: 1, Name: Alice, Grades: {\'Math\': 95} > query_student 2 ID: 2, Name: Bob, Grades: {\'Science\': 85} > remove_student 1 Student 1 removed > query_student 1 Student with ID 1 not found ``` # Bonus Enhance the CLI to support multi-word course names and implement additional commands such as `list_students` to print all student IDs and names in the database. Additionally, consider adding validation to ensure valid input formats before processing commands.","solution":"class StudentRecords: def __init__(self): self.records = {} def add_student(self, student_id, name): if student_id in self.records: return f\\"Student with ID {student_id} already exists.\\" self.records[student_id] = {\\"name\\": name, \\"grades\\": {}} return f\\"Student {student_id} added: {name}\\" def remove_student(self, student_id): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" del self.records[student_id] return f\\"Student {student_id} removed\\" def update_grade(self, student_id, course, grade): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" self.records[student_id][\\"grades\\"][course] = grade return f\\"Updated grade for student {student_id}: {course} = {grade}\\" def query_student(self, student_id): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" student = self.records[student_id] return f\\"ID: {student_id}, Name: {student[\'name\']}, Grades: {student[\'grades\']}\\" # Example usage: # sr = StudentRecords() # print(sr.add_student(1, \\"Alice\\")) # print(sr.add_student(2, \\"Bob\\")) # print(sr.update_grade(1, \\"Math\\", 95)) # print(sr.query_student(1)) # print(sr.remove_student(1)) # print(sr.query_student(1))"},{"question":"# Problem Statement Write a function `transpose_matrix` that transposes a given matrix. The transpose of a matrix is achieved by swapping rows with columns. # Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input * `matrix` (List[List[int]]): A 2-dimensional list representing the matrix to be transposed. # Output * Returns a List[List[int]] representing the transposed matrix. # Constraints * The matrix can be empty (i.e., `[]`). * All rows in the matrix will have the same length. * Each element in the matrix is an integer. * The total number of elements in the matrix will not exceed 10^4. # Examples ```python print(transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] print(transpose_matrix([[1, 2], [3, 4], [5, 6]])) # Output: [[1, 3, 5], [2, 4, 6]] print(transpose_matrix([])) # Output: [] print(transpose_matrix([[1]])) # Output: [[1]] ``` # Explanation of Examples 1. `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` is transposed by swapping rows and columns, resulting in `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]`. 2. `[[1, 2], [3, 4], [5, 6]]` is transposed to `[[1, 3, 5], [2, 4, 6]]`. 3. An empty matrix `[]` remains empty after transposition. 4. A single-element matrix `[[1]]` remains `[[1]]` after transposition. # Instructions * Implement the function `transpose_matrix`. * Ensure the function handles empty matrices and preserves the integrity of single-element matrices. * Optimally manage memory and processing within given constraints.","solution":"def transpose_matrix(matrix): Transpose the given matrix by swapping rows with columns. :param matrix: List of lists representing the matrix. :return: Transposed matrix as a list of lists. if not matrix: return [] # number of rows and columns in the original matrix rows, cols = len(matrix), len(matrix[0]) # initialize the transposed matrix with the shape of (cols, rows) transposed = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Coding Assessment Question You are given an integer array `nums` and a positive integer `k`. Your task is to determine if you can partition the array into exactly `k` subsets such that the sum of elements in each subset is equal. Write a function `can_partition_k_subsets(nums: List[int], k: int) -> bool` that returns `True` if you can partition the array into exactly `k` subsets with equal sums, otherwise return `False`. Input - `nums` (1 <= |nums| <= 16): An array of integers. - `k` (1 <= k <= |nums|): A positive integer. Output - Return `True` if the array can be partitioned into exactly `k` subsets with equal sums, otherwise return `False`. Constraints - The array may contain positive, negative, and zero values. - Use recursive backtracking to solve this problem. Example ```python def can_partition_k_subsets(nums: List[int], k: int) -> bool: if k == 1: return True if sum(nums) % k != 0: return False target = sum(nums) // k nums.sort(reverse=True) subsets = [0] * k def backtrack(index): if index == len(nums): return all(x == target for x in subsets) for i in range(k): if subsets[i] + nums[index] <= target: subsets[i] += nums[index] if backtrack(index + 1): return True subsets[i] -= nums[index] if subsets[i] == 0: break return False return backtrack(0) # Examples print(can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4)) # Output: True (subsets are [5], [1, 4], [2, 3], [2, 3]) print(can_partition_k_subsets([1, 2, 3, 4], 3)) # Output: False print(can_partition_k_subsets([1, 1, 1, 1], 2)) # Output: True (subsets are [1, 1], [1, 1]) print(can_partition_k_subsets([2, 2, 2, 2, 3, 4], 2)) # Output: False print(can_partition_k_subsets([2, 2, 2, 2, 2, 2], 3)) # Output: True (subsets are [2, 2], [2, 2], [2, 2]) ```","solution":"from typing import List def can_partition_k_subsets(nums: List[int], k: int) -> bool: if k == 1: return True if sum(nums) % k != 0: return False target = sum(nums) // k nums.sort(reverse=True) subsets = [0] * k def backtrack(index): if index == len(nums): return all(x == target for x in subsets) for i in range(k): if subsets[i] + nums[index] <= target: subsets[i] += nums[index] if backtrack(index + 1): return True subsets[i] -= nums[index] if subsets[i] == 0: break return False return backtrack(0)"},{"question":"# Scenario You are developing a command-line application that processes log files to extract meaningful statistics. One of the features you need to implement is calculating the average response time from the log entries. The log files contain multiple lines, each representing a log entry with a response time in milliseconds. # Task 1. Implement a function `calculate_average_response_time` that takes a file path as an argument and returns the average response time rounded to two decimal places. 2. Write unit tests to validate your function\'s correctness. # Requirements **Function Signature**: ```python def calculate_average_response_time(file_path: str) -> float: # Your implementation here ``` # Example Assume the following content in `log.txt`: ``` INFO 2023-01-01 12:00:00 Request processed in 150ms INFO 2023-01-01 12:01:00 Request processed in 200ms INFO 2023-01-01 12:02:00 Request processed in 100ms ``` ```python # Example of function call calculate_average_response_time(\\"log.txt\\") # Expected output: 150.00 ``` # Constraints - The log file consists of lines in the format \\"INFO <timestamp> Request processed in <response_time>ms\\". - If the log file is empty, the function should return 0.00. - Handle potential issues such as file not found or improperly formatted lines gracefully by raising appropriate exceptions. # Testing - Create mock log files with varying numbers of entries, including edge cases such as an empty file or a file with some improperly formatted lines. - Use the `pytest` framework to validate that the function correctly computes the average response time and handles errors appropriately. # Additional Information - You may use the `with open` statement for reading the file content. - Ensure to write comprehensive tests to cover typical use cases, edge cases, and error scenarios.","solution":"def calculate_average_response_time(file_path: str) -> float: total_time = 0 count = 0 try: with open(file_path, \'r\') as file: for line in file: if \\"Request processed in\\" in line: parts = line.split() time_part = parts[-1] # e.g., \\"150ms\\" response_time = int(time_part[:-2]) # Convert \\"150ms\\" to 150 total_time += response_time count += 1 if count == 0: return 0.00 average = total_time / count return round(average, 2) except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} does not exist.\\") except Exception as e: raise ValueError(f\\"An error occurred while processing the file: {e}\\")"},{"question":"# Markdown Parser Context You\'re designing a lightweight Markdown parser for a text editor. The goal is to parse specific Markdown elements and convert them into HTML. The elements to be supported are headers (using `#`), bold text (using `**` on either side), and italic text (using `_` on either side). Problem Statement Write a function `markdown_to_html` that takes in a `markdown_text` string and returns an HTML formatted string. The function should convert headers, bold, and italic text from Markdown to their respective HTML tags. Input Format - A single string `markdown_text` containing the markdown formatted text. Output Format - A single string containing the HTML formatted text. Constraints - You may assume that the input string will be well-formed Markdown. - There will not be nested Markdown elements (e.g., bold text within a header). - The maximum length of `markdown_text` will not exceed `10^6` characters. Performance Requirements - The time complexity should be linear with respect to the length of `markdown_text`, ensuring efficient parsing and conversion. - The space complexity should be optimized for minimal overhead in the conversion process. Function Signature ```python def markdown_to_html(markdown_text: str) -> str: pass ``` Example ```python # Example input markdown_text = # Header 1 This is a paragraph with **bold text** and _italic text_. Header 2 Another line with **bold and _italic_ text** combined. # Example output html_output = <h1>Header 1</h1> <p>This is a paragraph with <b>bold text</b> and <i>italic text</i>.</p> <h2>Header 2</h2> <p>Another line with <b>bold and <i>italic</i> text</b> combined.</p> ``` This parser should handle the following conversions: - Headers: Convert lines starting with `#` into `<h1>`, lines with `` into `<h2>`, and so on (up to `` for `<h6>`). - Bold text: Convert text surrounded by `**` into `<b>`. - Italic text: Convert text surrounded by `_` into `<i>`. Ensure to write comprehensive tests to validate the functionality of the `markdown_to_html` function, covering cases with various combinations of headers, bold, and italic text.","solution":"import re def markdown_to_html(markdown_text: str) -> str: Converts markdown text to HTML format. def replace_headers(line): match = re.match(r\'^(#+)s*(.*)\', line) if match: header_level = len(match.group(1)) header_text = match.group(2) return f\'<h{header_level}>{header_text}</h{header_level}>\' return line def replace_bold(text): return re.sub(r\'**(.*?)**\', r\'<b>1</b>\', text) def replace_italic(text): return re.sub(r\'_(.*?)_\', r\'<i>1</i>\', text) # Split the input by lines and process each line lines = markdown_text.split(\'n\') html_lines = [] for line in lines: if line.strip() == \'\': continue # Handle headers line = replace_headers(line) # Handle bold text line = replace_bold(line) # Handle italic text line = replace_italic(line) # If the line is not a header, wrap it in a <p> tag if not line.startswith(\'<h\'): line = f\'<p>{line}</p>\' html_lines.append(line) # Join the processed lines back together with newline characters return \'n\'.join(html_lines) # Test example markdown_text = # Header 1 This is a paragraph with **bold text** and _italic text_. Header 2 Another line with **bold and _italic_ text** combined. html_output = markdown_to_html(markdown_text) print(html_output)"},{"question":"# Scenario You are working on a project that involves processing a large number of text documents. Each document consists of a series of words, and you need to analyze the text by performing various statistical computations. One common operation is finding the longest word in each document and the frequency of each word in that document. # Task Write a function called `analyze_document` that reads the content of a document and returns the longest word in the document and a dictionary of word frequencies. If there are multiple words with the same maximum length, return the first one to appear in the document. # Function Signature ```python def analyze_document(file_path: str) -> tuple: ``` # Input 1. `file_path` (str): The file path to the document that needs to be analyzed. # Output The function should return a tuple containing: 1. The longest word in the document (str). 2. A dictionary where the keys are words and the values are their respective frequencies in the document. # Constraints * The document will be a plain text file with words separated by spaces, and may include punctuation marks. * The words should be considered case-insensitive, and punctuation should be ignored. * The document may be large, so your solution should be efficient in both time and space. * Assume the document contains at least one word. # Example Assume a document located at `document.txt` contains the following text: ``` Hello, there! This document contains some sample text. This document is used to demonstrate text processing. ``` ```python >>> analyze_document(\'document.txt\') (\'demonstrate\', {\'hello\': 1, \'there\': 1, \'this\': 2, \'document\': 2, \'contains\': 1, \'some\': 1, \'sample\': 1, \'text\': 2, \'is\': 1, \'used\': 1, \'to\': 1, \'demonstrate\': 1, \'processing\': 1}) ``` # Important Note Ensure your function handles punctuation properly, and converts all words to lowercase before processing. # Hint You may use regular expressions to aid in removing punctuation and splitting the text into words.","solution":"import re from collections import defaultdict def analyze_document(file_path: str) -> tuple: with open(file_path, \'r\') as file: text = file.read() # Remove punctuation text = re.sub(r\'[^ws]\', \'\', text) words = text.lower().split() # Find the longest word longest_word = \'\' word_frequencies = defaultdict(int) for word in words: word_frequencies[word] += 1 if len(word) > len(longest_word): longest_word = word return longest_word, dict(word_frequencies)"},{"question":"# Sum of Digits in a String **Context:** You are tasked with creating a function that processes a given string consisting of both characters and digits. Your function should calculate the sum of all the numerical digits present in the string. This function is useful in various applications such as extracting numerical information from alphanumeric data. **Objective:** Write a function `sum_of_digits` that takes a string as input and returns the sum of all digits found in the string. **Function Signature:** ```python def sum_of_digits(s: str) -> int: ``` **Inputs:** * `s (str)`: a string containing alphanumeric characters. **Outputs:** * An `int` representing the sum of all digits in the input string. **Examples:** ```python assert sum_of_digits(\\"abc123\\") == 6 # 1+2+3 assert sum_of_digits(\\"4score7years\\") == 11 # 4+7 assert sum_of_digits(\\"no_digits\\") == 0 # No digits present assert sum_of_digits(\\"999\\") == 27 # 9+9+9 ``` **Constraints:** * The input string `s` will have a length 0 ≤ len(s) ≤ 1000. * Only the digits [0-9] should be summed, ignore any other characters. **Notes:** * You may use Python\'s `str.isdigit()` method to check if a character is a digit. * Ensure your function handles the case when no digits are present by returning 0.","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all numerical digits present in the input string s. return sum(int(char) for char in s if char.isdigit())"},{"question":"# Context Sorting is a fundamental concept in computer science. One common task is to sort arrays of integers. There are various sorting algorithms, and each has its advantages in terms of time complexity, space complexity, and the nature of the dataset. One classical and efficient sorting algorithm is Merge Sort. Merge Sort follows the divide and conquer paradigm and performs well on large datasets. # Problem Statement Write a function `merge_sort(arr: List[int]) -> List[int]` that implements Merge Sort to sort an input array of integers in non-decreasing order. # Input - `arr`: a list of integers to be sorted. # Output - A list of integers sorted in non-decreasing order. # Constraints - The input list `arr` length will not exceed 10^5. - The integers in the list will be in the range of -10^9 to 10^9. # Example ```python >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> merge_sort([10, -1, 2, 5]) [-1, 2, 5, 10] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([]) [] >>> merge_sort([-5, -9, -3, -1, -2]) [-9, -5, -3, -2, -1] ``` # Notes - Remember that Merge Sort has a time complexity of O(n log n) and a space complexity of O(n). - You must implement the Merge Sort algorithm; using built-in sorting functions is not allowed.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts the input list of integers using the Merge Sort algorithm and returns the sorted list. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] left_index = right_index = 0 # Compare elements from both lists and merge them in sorted order while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in left or right, extend the sorted_list with them if left_index < len(left): sorted_list.extend(left[left_index:]) if right_index < len(right): sorted_list.extend(right[right_index:]) return sorted_list # Divide the array into two halves and sort them recursively mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves and return return merge(left_half, right_half)"},{"question":"# Coding Assessment Question Scenario You have been given a rectangular grid representing a garden. Each cell in the grid has a specific cost associated with it, which represents the difficulty of planting a tree in that cell. Starting from the top-left corner of the grid, your task is to find the path to the bottom-right corner with the minimum total planting difficulty. Each move can either go right or down to an adjacent cell. Problem Statement Implement a function, `min_planting_difficulty(grid: List[List[int]]) -> int`, which returns the minimum total planting difficulty from the top-left to the bottom-right of a given grid. Constraints * `1 <= len(grid), len(grid[0]) <= 50` * `0 <= grid[i][j] <= 100` Input * A 2D list `grid` with integers representing the planting difficulty. Output * An integer representing the minimum total planting difficulty to reach the bottom-right corner. Example ```python def min_planting_difficulty(grid: List[List[int]]) -> int: # Your implementation here # Example Usages: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_planting_difficulty(grid)) # Output: 7 grid = [ [1, 2], [1, 1] ] print(min_planting_difficulty(grid)) # Output: 3 ``` Requirements Consider dynamic programming to achieve an efficient solution.","solution":"from typing import List def min_planting_difficulty(grid: List[List[int]]) -> int: rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Word Frequency Counter Write a program to analyze the frequency of words in a given text. The program should count the number of occurrences of each unique word, ignoring case and punctuation, and then print the top `N` most frequent words in descending order of frequency. You must implement two functions: 1. `count_word_frequencies(text: str) -> dict`: This function will take a string `text` as input and return a dictionary where keys are the words and values are their respective frequencies. 2. `print_top_n_words(frequency_dict: dict, N: int) -> None`: This function will take the frequency dictionary and an integer `N`, and print the top `N` frequent words along with their frequencies. Input and Output Formats **`count_word_frequencies` function:** * Input: `text` (str) - The input text to analyze. * Output: A dictionary representing word frequencies. **`print_top_n_words` function:** * Input: `frequency_dict` (dict) - The dictionary containing word frequencies. `N` (int) - The number of top frequent words to print. * Output: None. This function should print the words and their frequencies in descending order of frequency. Constraints * Words in the text are separated by whitespace or punctuation. * The function should ignore case. * If multiple words have the same frequency, they should be sorted alphabetically. * If `N` is greater than the number of unique words, print all words sorted by frequency and then alphabetically if necessary. Examples ```python >>> count_word_frequencies(\\"Hello world! Hello everyone. Meet the new world.\\") { \'hello\': 2, \'world\': 2, \'everyone\': 1, \'meet\': 1, \'the\': 1, \'new\': 1 } >>> print_top_n_words({\'hello\': 2, \'world\': 2, \'everyone\': 1, \'meet\': 1, \'the\': 1, \'new\': 1}, 3) hello: 2 world: 2 everyone: 1 >>> print_top_n_words({\'hello\': 2, \'world\': 2, \'everyone\': 1, \'meet\': 1, \'the\': 1, \'new\': 1}, 10) hello: 2 world: 2 everyone: 1 meet: 1 new: 1 the: 1 ``` Ensure the output is properly formatted and handle all edge cases as required by typical text processing scenarios in Python.","solution":"import re from collections import Counter def count_word_frequencies(text: str) -> dict: Count the frequency of each word in the given text. # Remove punctuation and convert to lower case words = re.findall(r\'bw+b\', text.lower()) # Use Counter to count the frequency of each word return dict(Counter(words)) def print_top_n_words(frequency_dict: dict, N: int) -> None: Prints the top N most frequent words from the frequency dictionary. sorted_words = sorted(frequency_dict.items(), key=lambda x: (-x[1], x[0])) for word, freq in sorted_words[:N]: print(f\\"{word}: {freq}\\")"},{"question":"# Coding Assessment Question You are required to implement a function that, given an integer `n`, computes the total number of unique ways to express `n` as a sum of two or more *consecutive* positive integers. # Function Signature ```python def count_consecutive_sum_ways(n: int) -> int: pass ``` # Input * `n` (int): A positive integer `n` (1 ≤ n ≤ 10^9). # Output * Return the total number of unique ways to express `n` as a sum of two or more consecutive positive integers. # Constraints * The input integer `n` will always be a positive integer. # Example ```python assert count_consecutive_sum_ways(15) == 3 # (1+2+3+4+5, 4+5+6, 7+8) assert count_consecutive_sum_ways(9) == 2 # (2+3+4, 4+5) assert count_consecutive_sum_ways(8) == 0 # No consecutive sum ``` # Explanation Given `n = 15`: - The integer `15` can be expressed as the sum of consecutive positive integers in the following ways: `1+2+3+4+5`, `4+5+6`, `7+8`. Hence, the total number of ways is 3. For `n = 9`: - The integer `9` can be expressed as the sum of consecutive positive integers in the following ways: `2+3+4`, `4+5`. Hence, the total number of ways is 2. For `n = 8`: - The integer `8` cannot be expressed as the sum of two or more consecutive positive integers. Hence, the total number of ways is 0. # Notes * Ensure to avoid brute-force solutions that do not scale well with larger values of `n`. * Consider mathematical properties and formulae to optimize the solution.","solution":"def count_consecutive_sum_ways(n: int) -> int: count = 0 k = 1 # Trying to find the values for which `n` can be expressed as a sum of `k` consecutive integers while (k * (k + 1)) // 2 < n: if (n - (k * (k + 1)) // 2) % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"# Graph Algorithm: Minimum Spanning Tree with Kruskal\'s Algorithm Given an undirected graph with `N` nodes and `M` edges, where each edge has a specific weight associated with it, your task is to find the Minimum Spanning Tree (MST) of this graph using Kruskal’s algorithm. The graph is represented as a list of edges, and each edge is a tuple `(u, v, w)` where `u` and `v` are the nodes connected by the edge, and `w` is the weight of the edge. # Task 1. Implement the `find` and `union` methods for the Disjoint Set Union (DSU) or Union-Find data structure to help manage connected components. 2. Create the `kruskal` method which uses these helper methods to construct the MST. Function Signature ```python def kruskal(edges: List[Tuple[int, int, int]], N: int) -> List[Tuple[int, int, int]]: Find the Minimum Spanning Tree using Kruskal\'s algorithm. :param edges: List of edges represented as tuples (u, v, w) :param N: Number of nodes in the graph :return: List of edges in the Minimum Spanning Tree ``` Input and Output Specifications: - **Input**: A list of tuples where each tuple represents an edge in the format `(u, v, w)` and an integer `N` which denotes the number of nodes in the graph. - **Output**: A list of tuples representing the edges included in the MST. Constraints: - Each edge and node is non-negative and within the range of `0` to `N-1`. - The graph may not be connected, but in such a case, it is guaranteed that every node is part of at least one component, and each component should be handled separately. - You must use Kruskal\'s algorithm, which includes sorting the edges and using the union-find data structure. # Example 1. Given edges and number of nodes: ```python edges = [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 4)] N = 4 ``` 2. Find MST: ```python mst = kruskal(edges, N) # Expected Output: [(1, 2, 1), (1, 3, 2), (0, 2, 3)] # Multiple valid MSTs may exist; ensure your result is one correctly constructed MST. ``` # Additional Notes - Ensure to optimize the union-find operations with union by rank and path compression. - Sorting of edges must be done efficiently to ensure Kruskal’s algorithm performs optimally. - This exercise tests knowledge of sorting, data structures (disjoint set), and greedy algorithms typically used for MST problems. Good luck!","solution":"from typing import List, Tuple def find(parent, i): Function to find the set of an element i (uses path compression) if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): Function to do union of two sets of x and y (uses union by rank) root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(edges: List[Tuple[int, int, int]], N: int) -> List[Tuple[int, int, int]]: Function to construct the Minimum Spanning Tree (MST) using Kruskal\'s algorithm # Sort all the edges in non-decreasing order of their weight edges = sorted(edges, key=lambda item: item[2]) # Create parent and rank arrays for the union-find structure parent = [] rank = [] # Initialize parent and rank arrays for disjoint sets for node in range(N): parent.append(node) rank.append(0) mst = [] # List to store the resultant MST # Iterate through all sorted edges for edge in edges: u, v, w = edge # Find the sets (or subsets) of the vertices u and v root_u = find(parent, u) root_v = find(parent, v) # If including this edge doesn\'t cause a cycle, include it in the result # and take the union of the sets. if root_u != root_v: mst.append((u, v, w)) union(parent, rank, root_u, root_v) return mst"},{"question":"Coding Question: Count Increasing Subsequences # Context: Combinatorial problems often involve finding specific types of sequences or subsequences within a given list. One such problem is counting the number of increasing subsequences of a certain length. This has applications in data analysis, genetic research, and more. # Problem Statement: Implement a function `count_increasing_subsequences(arr: List[int], k: int) -> int` that returns the number of strictly increasing subsequences of length `k` that can be found in the given array `arr`. Input: - `arr`: A list of integers. - `k`: An integer (0 <= k <= len(arr)) representing the length of increasing subsequences to count. Output: - Returns an integer indicating the number of strictly increasing subsequences of the specified length. # Constraints: - The input list can have up to 1000 elements. - The elements of the list are in the range of -1000 to 1000. - If `k` is 0, the result should be 1 (as there is one way to choose nothing). - If `k` exceeds the length of `arr`, return 0. # Examples: Example 1: ```python arr = [1, 2, 3, 4] k = 2 assert count_increasing_subsequences(arr, 2) == 6 # {12, 13, 14, 23, 24, 34} ``` Example 2: ```python arr = [2, 1, 3, 2, 4] k = 3 assert count_increasing_subsequences(arr, 3) == 3 # {124, 134, 234} ``` # Notes: 1. Consider edge cases such as an empty array and k = 0. 2. Optimize for larger inputs where brute force enumeration of subsequences is infeasible.","solution":"from typing import List def count_increasing_subsequences(arr: List[int], k: int) -> int: Returns the number of strictly increasing subsequences of length k that can be found in arr. if k == 0: return 1 if k > len(arr): return 0 # Create a 2D dp array, where dp[i][j] represents the number of increasing subsequences # of length j+1 ending with arr[i]. dp = [[0] * k for _ in range(len(arr))] # Initialize dp for subsequences of length 1 for i in range(len(arr)): dp[i][0] = 1 # Fill the dp array for j in range(1, k): for i in range(j, len(arr)): # i needs to be at least j (to have enough elements before) for p in range(i): # Consider all previous elements arr[p] < arr[i] if arr[p] < arr[i]: dp[i][j] += dp[p][j-1] # Sum up all the ways to end a subsequence of length k result = 0 for i in range(len(arr)): result += dp[i][k-1] return result"},{"question":"# Problem Statement: File Deduplicator You work for a data storage company that frequently deals with large amounts of data. A significant challenge is ensuring that redundant files are not stored multiple times, saving both space and costs. You\'ve been tasked with creating a solution that can identify and remove duplicate files based on their content. **Objective:** Implement two functions, `find_duplicates` and `remove_duplicates`, that identify and remove duplicate files in a provided directory. # Function 1: find_duplicates **Input:** - `directory: str` - A string representing the path to the directory to be scanned for duplicates. **Output:** - `duplicates: list` - A list of lists, where each sublist contains paths to files that are duplicates of each other. # Function 2: remove_duplicates **Input:** - `directory: str` - A string representing the path to the directory to be scanned for duplicates. - `retain: str` - A string representing the criterion for retaining one of the duplicate files. Can be one of \\"largest\\", \\"smallest\\", \\"first\\", \\"last\\". **Output:** - `count: int` - The number of duplicate files removed. # Constraints: 1. All files within the specified directory should be considered. 2. Subdirectories should be scanned recursively. 3. Use file content to determine duplicates, not file names. 4. `retain` criterion specifies which file to keep among duplicates: - \\"largest\\" - Retain the largest file (by size). - \\"smallest\\" - Retain the smallest file (by size). - \\"first\\" - Retain the first file found (based on directory traversal order). - \\"last\\" - Retain the last file found (based on directory traversal order). 5. Your implementation should handle edge cases like empty directories and large numbers of files gracefully. # Example: ```python def find_duplicates(directory: str) -> list: # Your implementation here pass def remove_duplicates(directory: str, retain: str) -> int: # Your implementation here pass # Example Directory Structure: # /example-directory/ # ├── file1.txt # ├── file2.txt (duplicate of file1.txt) # ├── file3.txt # ├── subdir/ # │ ├── file4.txt (duplicate of file1.txt) # │ └── file5.txt # Test cases: # Find duplicates assert find_duplicates(\'/example-directory/\') == [[\'/example-directory/file1.txt\', \'/example-directory/file2.txt\', \'/example-directory/subdir/file4.txt\']] # Remove duplicates assert remove_duplicates(\'/example-directory/\', \'first\') == 2 # file2.txt and file4.txt removed, file1.txt retained assert remove_duplicates(\'/example-directory/\', \'largest\') == 2 # file2.txt and file4.txt removed, largest file retained # After removing, running find_duplicates should return an empty list assert find_duplicates(\'/example-directory/\') == [] ``` Your solution should be efficient, handling large directories and many files gracefully, and must include proper handling of edge cases such as empty directories and varying file sizes. **Good Luck!**","solution":"import os import hashlib def hash_file(filepath): Generate MD5 hash for the content of the file. hash_md5 = hashlib.md5() with open(filepath, \\"rb\\") as f: for chunk in iter(lambda: f.read(4096), b\\"\\"): hash_md5.update(chunk) return hash_md5.hexdigest() def find_duplicates(directory): Find duplicates in a specified directory. file_hashes = {} for root, _, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) file_hash = hash_file(filepath) if file_hash in file_hashes: file_hashes[file_hash].append(filepath) else: file_hashes[file_hash] = [filepath] duplicates = [paths for paths in file_hashes.values() if len(paths) > 1] return duplicates def remove_duplicates(directory, retain): Remove duplicates in a specified directory based on the retain criterion. duplicates = find_duplicates(directory) def get_file_size(filename): return os.path.getsize(filename) count = 0 for paths in duplicates: if retain == \\"largest\\": paths.sort(key=get_file_size, reverse=True) elif retain == \\"smallest\\": paths.sort(key=get_file_size) elif retain == \\"first\\": paths.sort() elif retain == \\"last\\": paths.sort(reverse=True) for filepath in paths[1:]: os.remove(filepath) count += 1 return count"},{"question":"# Question: Binary Search with Insertion Index Scenario: You are developing a utility function for a database system that leverages binary search. The system needs not only to find if an element exists in a sorted list but also determine the position where the element should be inserted if it doesn\'t already exist. This dual functionality ensures efficient search and insertion operations. Task: Write a function `binary_search_with_insertion_index(lst: list, x: int) -> tuple`, which performs a binary search on the list. If the element `x` is found, the function should return `(True, index)` where `index` is the position of `x` in the list. If the element `x` is not found, the function should return `(False, insertion_index)` where `insertion_index` is the position where `x` would fit in the sorted order of the list. Function Signature: ```python def binary_search_with_insertion_index(lst: list, x: int) -> tuple: pass ``` Input: * `lst` (list): A sorted list of integers. * `x` (int): The integer element to search for in the list. Output: * Returns: A tuple where the first element is a boolean indicating whether `x` was found, and the second element is either the index of `x` or the insertion index where `x` would be placed. Constraints: * The input list `lst` is sorted in ascending order. * The list may contain negative or positive integers. * The solution should make use of binary search to ensure O(log n) time complexity for the search/insert determination. Example: ```python >>> binary_search_with_insertion_index([1, 3, 5, 7, 9], 5) (True, 2) >>> binary_search_with_insertion_index([1, 3, 5, 7, 9], 4) (False, 2) >>> binary_search_with_insertion_index([-10, -5, 0, 5, 10], -6) (False, 1) >>> binary_search_with_insertion_index([], 3) (False, 0) ``` Hints: * Implement the binary search algorithm. * Use the search results to determine the appropriate return value when the element is not found.","solution":"def binary_search_with_insertion_index(lst, x): Performs a binary search to find the element x in the sorted list lst. If the element is found, returns (True, index). If the element is not found, returns (False, insertion_index). left, right = 0, len(lst) - 1 while left <= right: mid = (left + right) // 2 if lst[mid] == x: return True, mid elif lst[mid] < x: left = mid + 1 else: right = mid - 1 return False, left"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with designing a warehouse management system that efficiently handles stock levels of various items. One of the key requirements is to quickly process batch updates and queries about stock levels using a Fenwick Tree (also known as a Binary Indexed Tree). **Task**: Implement the `FenwickTree` class by completing the following methods: 1. **build**: ```python def build(self, a: list[int]) -> None: ``` - **Input**: - `a` (list[int]): The list of initial stock levels for the items in the warehouse. - **Output**: None 2. **update**: ```python def update(self, idx: int, delta: int) -> None: ``` - **Input**: - `idx` (int): Index of the item in the array (1-based index). - `delta` (int): Value to update the stock level by (can be positive or negative). - **Output**: None 3. **query**: ```python def query(self, idx: int) -> int: ``` - **Input**: - `idx` (int): Index of the item up to which the cumulative stock level is to be calculated (1-based index). - **Output**: Return the cumulative stock level from the beginning of the array up to index `idx`. 4. **range_query**: ```python def range_query(self, left: int, right: int) -> int: ``` - **Input**: - `left` (int): Left boundary of the range (1-based index). - `right` (int): Right boundary of the range (1-based index). - **Output**: Return the cumulative stock level within the range `[left, right]`. **Constraints**: - You may assume that the input array size will not exceed `10^5`. - The values in the input array will be within the range `[-10^6, 10^6]`. **Example**: ```python A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(10) fenwick_tree.build(A) print(fenwick_tree.query(5)) # Output: 150 (10 + 20 + 30 + 40 + 50) fenwick_tree.update(3, 10) print(fenwick_tree.query(5)) # Output: 160 (10 + 20 + 40 + 40 + 50) print(fenwick_tree.range_query(3, 6)) # Output: 180 (40 + 40 + 50 + 50) fenwick_tree.update(6, -20) print(fenwick_tree.range_query(4, 6)) # Output: 110 (40 + 40 + 30) ``` Implementing the `FenwickTree` class with these functions will enable efficient batch updates and queries, ensuring smooth management of the warehouse stock levels.","solution":"class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: for idx, val in enumerate(a, 1): self.update(idx, val) def update(self, idx: int, delta: int) -> None: while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_query(self, left: int, right: int) -> int: return self.query(right) - self.query(left - 1)"},{"question":"# Coding Question: You are given a list of students, each with their name and a sequence of grades they have received throughout the term. The task is to write a function `calculate_final_grades` that computes the final grade for each student using a weighted average method and the letter grade corresponding to that final grade. A student is represented as a tuple `(name, [(grade, weight)])`: * `name` (str): The name of the student. * `grade` (float): The grade a student received, between 0 and 100. * `weight` (float): The weight of the grade, a float between 0 and 1 where the sum of weights for each student must be 1. The letter grade should correspond to the final grade as follows: - 90 <= final grade <= 100: \\"A\\" - 80 <= final grade < 90: \\"B\\" - 70 <= final grade < 80: \\"C\\" - 60 <= final grade < 70: \\"D\\" - final grade < 60: \\"F\\" Input: * A list of tuples, each representing a student. Output: * A list of tuples with each student\'s name, final numeric grade rounded to two decimal places, and the letter grade. Constraints: * If any student has an empty list of grades or the weights do not sum up to 1, raise a `ValueError` with the message \\"Invalid grades or weights for student: [name]\\", where `[name]` is the respective student\'s name. * If no students are provided, raise a `ValueError` with the message \\"No students provided\\". **Examples:** ```python >>> calculate_final_grades([(\'Alice\', [(90, 0.5), (80, 0.5)]), (\'Bob\', [(70, 0.3), (85, 0.7)])]) [(\'Alice\', 85.00, \'B\'), (\'Bob\', 80.50, \'B\')] >>> calculate_final_grades([(\'Alice\', [(90, 0.6), (80, 0.4)]), (\'Bob\', [(50, 0.5), (70, 0.5)])]) [(\'Alice\', 86.00, \'B\'), (\'Bob\', 60.00, \'D\')] >>> calculate_final_grades([(\'Alice\', [(90, 0.5), (80, 0.5)]), (\'Bob\', [(70, 0.5), (85, 0.6)])]) Traceback (most recent call last): ... ValueError: Invalid grades or weights for student: Bob >>> calculate_final_grades([]) Traceback (most recent call last): ... ValueError: No students provided >>> calculate_final_grades([(\'Alice\', [])]) Traceback (most recent call last): ... ValueError: Invalid grades or weights for student: Alice ``` Write the implementation of the function `calculate_final_grades(students: list[tuple[str, list[tuple[float, float]]]]) -> list[tuple[str, float, str]]` below.","solution":"def calculate_final_grades(students): if len(students) == 0: raise ValueError(\\"No students provided\\") def calculate_letter_grade(grade): if 90 <= grade <= 100: return \\"A\\" elif 80 <= grade < 90: return \\"B\\" elif 70 <= grade < 80: return \\"C\\" elif 60 <= grade < 70: return \\"D\\" else: return \\"F\\" final_grades = [] for student in students: name, grades_weights = student if len(grades_weights) == 0: raise ValueError(f\\"Invalid grades or weights for student: {name}\\") total_weight = sum(weight for _, weight in grades_weights) if total_weight != 1: raise ValueError(f\\"Invalid grades or weights for student: {name}\\") final_grade = sum(grade * weight for grade, weight in grades_weights) final_grade = round(final_grade, 2) letter_grade = calculate_letter_grade(final_grade) final_grades.append((name, final_grade, letter_grade)) return final_grades"},{"question":"# Multi-Level Inheritance and Method Overriding In object-oriented programming, multi-level inheritance allows a derived class to inherit properties and behaviors from another derived class. Additionally, method overriding is a feature that enables a subclass to provide a specific implementation of a method that is already defined in its superclass. You are required to create a class hierarchy representing different types of vehicles where methods such as `display_info` are overridden to provide specific information about each vehicle type. # Class Specifications **Base Class: `Vehicle`** ```python class Vehicle: def __init__(self, make: str, model: str): self.make = make self.model = model def display_info(self) -> str: return f\\"Vehicle Make: {self.make}, Model: {self.model}\\" ``` * **Initialization**: Initializes the vehicle with a make and model. * **Method**: `display_info()` - Returns a string containing the make and model of the vehicle. **Derived Class: `Car(Vehicle)`** ```python class Car(Vehicle): def __init__(self, make: str, model: str, doors: int): super().__init__(make, model) self.doors = doors def display_info(self) -> str: return f\\"Car Make: {self.make}, Model: {self.model}, Doors: {self.doors}\\" ``` * **Initialization**: Initializes the car with make, model, and number of doors. * **Method**: `display_info()` - Returns a string containing the make, model, and the number of doors of the car. **Derived Class: `ElectricCar(Car)`** ```python class ElectricCar(Car): def __init__(self, make: str, model: str, doors: int, range_per_charge: float): super().__init__(make, model, doors) self.range_per_charge = range_per_charge def display_info(self) -> str: return f\\"Electric Car Make: {self.make}, Model: {self.model}, Doors: {self.doors}, Range per Charge: {self.range_per_charge} miles\\" ``` * **Initialization**: Initializes the electric car with make, model, doors, and range per charge. * **Method**: `display_info()` - Returns a string containing the make, model, doors, and range per charge of the electric car. # Example Usage ```python vehicle = Vehicle(\\"General\\", \\"Veh\\") print(vehicle.display_info()) # Expected: \\"Vehicle Make: General, Model: Veh\\" car = Car(\\"Toyota\\", \\"Corolla\\", 4) print(car.display_info()) # Expected: \\"Car Make: Toyota, Model: Corolla, Doors: 4\\" electric_car = ElectricCar(\\"Tesla\\", \\"Model S\\", 4, 370.0) print(electric_car.display_info()) # Expected: \\"Electric Car Make: Tesla, Model: Model S, Doors: 4, Range per Charge: 370.0 miles\\" ``` # Requirements 1. Implement all classes and methods as described. 2. Ensure proper initialization and method overriding. 3. The `display_info` method in each derived class should provide additional specific information relevant to that vehicle type (e.g., doors for cars, range per charge for electric cars). Ensure your implementation adheres to proper object-oriented principles and accurately overrides the methods to provide the correct output for different types of vehicles.","solution":"class Vehicle: def __init__(self, make: str, model: str): self.make = make self.model = model def display_info(self) -> str: return f\\"Vehicle Make: {self.make}, Model: {self.model}\\" class Car(Vehicle): def __init__(self, make: str, model: str, doors: int): super().__init__(make, model) self.doors = doors def display_info(self) -> str: return f\\"Car Make: {self.make}, Model: {self.model}, Doors: {self.doors}\\" class ElectricCar(Car): def __init__(self, make: str, model: str, doors: int, range_per_charge: float): super().__init__(make, model, doors) self.range_per_charge = range_per_charge def display_info(self) -> str: return f\\"Electric Car Make: {self.make}, Model: {self.model}, Doors: {self.doors}, Range per Charge: {self.range_per_charge} miles\\""},{"question":"Write a function `is_subsequence(s: str, t: str) -> bool` that determines if the string `s` is a subsequence of string `t`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. # Example ```python >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"ace\\", \\"abcde\\") True ``` # Constraints * The length of string `s` will be between 0 and 100. * The length of string `t` will be between 0 and 100,000. # Requirements 1. Implement the function in a way that efficiently handles the given constraints. 2. The function should return `True` if `s` is a subsequence of `t`, otherwise `False`. # Performance Expectations * The solution should have a time complexity of O(n + m), where `n` is the length of `s` and `m` is the length of `t`. * The solution should have a space complexity of O(1), i.e., constant additional space usage.","solution":"def is_subsequence(s, t): Determines if string s is a subsequence of string t. Parameters: s (str): The potentially subsequential string. t (str): The string which may contain s as a subsequence. Returns: bool: True if s is a subsequence of t, otherwise False. # Pointers for both strings s and t s_index, t_index = 0, 0 # While there are characters left to check in t while t_index < len(t): # If characters match, move to next character in s if s_index < len(s) and s[s_index] == t[t_index]: s_index += 1 # Move to the next character in t t_index += 1 # If we\'ve gone through all characters in s, it\'s a subsequence return s_index == len(s)"},{"question":"# Coding Question: Balance Adjacent Sums You are given a list of integers. Determine if the list can be completely traversed by stepping through adjacent elements, where the sum of every two consecutive steps is non-decreasing. Implement the function `can_traverse(arr: list[int]) -> bool` which returns `True` if the list can be traversed under the given condition, and `False` otherwise. Input - `arr`: A list of integers `arr[0], arr[1], ..., arr[n-1]`, where `1 <= n <= 100` and `-10^5 <= arr[i] <= 10^5`. Output - Return a boolean indicating whether the list can be fully traversed based on the described condition. Constraints - The sum of every pair of adjacent elements you move through must be non-decreasing. - Take into account edge cases such as single-element lists and lists with both positive and negative numbers. Examples ```python >>> can_traverse([1, 2, 3, 4, 5]) True >>> can_traverse([5, 4, 3, 2, 1]) False >>> can_traverse([1, 2, 2, 3, 4]) True >>> can_traverse([-1, 0, -3, -2]) False >>> can_traverse([5]) True >>> can_traverse([-1, -1, 0, 0, 1]) True ``` Performance Considerations The function should efficiently determine if the condition holds throughout the entire array, ensuring minimal computation time for large inputs while handling edge cases properly. Detailed Explanation: 1. Iterate through the array and check the sum condition for each pair of adjacent elements. 2. For each step from the beginning of the array, ensure that the sum of the current element and the next element is no less than the sum of the previous element and the current element. 3. Return `True` if all adjacent sums are non-decreasing, otherwise return `False`.","solution":"def can_traverse(arr): Determines if the list can be completely traversed where the sum of every two consecutive steps is non-decreasing. Args: arr (list[int]): List of integers to be traversed. Returns: bool: True if the list can be traversed based on the described condition, False otherwise. for i in range(1, len(arr) - 1): if arr[i] + arr[i-1] > arr[i] + arr[i+1]: return False return True"},{"question":"# Library Management System In a Library Management System, books are categorized by genre and each book has an ID, title, author, and status (available or checked out). The library can perform several operations like adding a new book, removing a book, lending a book, returning a book, and retrieving a list of all available books by genre. **Objective**: Design a class `Library` that allows managing the collection of books and add the following methods: 1. `add_book(book_id: int, title: str, author: str, genre: str)`: Adds a new book to the library. 2. `remove_book(book_id: int) -> bool`: Removes a book with the specified id from the library. Returns `True` if the book was removed, `False` if the book was not found. 3. `lend_book(book_id: int) -> bool`: Changes the status of the book to \'checked out\'. Returns `True` if the book was successfully lent, `False` if the book was not available. 4. `return_book(book_id: int) -> bool`: Changes the status of the book to \'available\'. Returns `True` if the book was successfully returned, `False` if the book was not found or was not checked out. 5. `get_available_books(genre: str) -> List[str]`: Returns a list of titles of all available books in the specified genre. **Class Definition**: ```python class Library: def __init__(self): # Initialize the library with necessary data structures pass def add_book(self, book_id: int, title: str, author: str, genre: str): # Adds a new book to the library pass def remove_book(self, book_id: int) -> bool: # Removes a book by id pass def lend_book(self, book_id: int) -> bool: # Lends a book by id pass def return_book(self, book_id: int) -> bool: # Returns a book by id pass def get_available_books(self, genre: str) -> List[str]: # Returns a list of available books by specified genre pass ``` **Input/Output Requirements**: 1. The `book_id` is assumed to be unique for each book in the system. 2. The `title` and `author` are strings that represent the book\'s title and author respectively. 3. The `genre` is a string representing the book\'s genre (e.g., \\"Fiction\\", \\"Science Fiction\\", \\"Non-Fiction\\"). 4. If there are no available books in a genre, `get_available_books` should return an empty list. **Usage Example**: ```python library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") library.add_book(2, \\"1984\\", \\"George Orwell\\", \\"Fiction\\") library.add_book(3, \\"Brief Answers to the Big Questions\\", \\"Stephen Hawking\\", \\"Science\\") print(library.remove_book(2)) # True print(library.lend_book(1)) # True print(library.get_available_books(\\"Fiction\\")) # [] print(library.return_book(1)) # True print(library.get_available_books(\\"Fiction\\")) # [\'The Great Gatsby\'] ``` # Constraints: - The number of books in the library (`n`) can range from `1` to `10000`. - The length of `title`, `author`, or `genre` will not exceed `100` characters. # Notes: - Ensure that methods handle cases where the book is not found or already in the desired state (`lend_book` on an unavailable book or `return_book` on an already available book). - Use appropriate data structures to efficiently manage and retrieve book data.","solution":"class Library: def __init__(self): self.books = {} self.genres = {} def add_book(self, book_id: int, title: str, author: str, genre: str): book_info = { \'title\': title, \'author\': author, \'genre\': genre, \'status\': \'available\' } self.books[book_id] = book_info if genre not in self.genres: self.genres[genre] = [] self.genres[genre].append(book_id) def remove_book(self, book_id: int) -> bool: if book_id in self.books: book = self.books[book_id] genre = book[\'genre\'] self.genres[genre].remove(book_id) if not self.genres[genre]: del self.genres[genre] del self.books[book_id] return True return False def lend_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id][\'status\'] == \'available\': self.books[book_id][\'status\'] = \'checked out\' return True return False def return_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id][\'status\'] == \'checked out\': self.books[book_id][\'status\'] = \'available\' return True return False def get_available_books(self, genre: str) -> list: if genre in self.genres: available_books = [self.books[book_id][\'title\'] for book_id in self.genres[genre] if self.books[book_id][\'status\'] == \'available\'] return available_books return []"},{"question":"# Coding Assessment Question: Balanced Parentheses Checker with Nested Tags You are building a parser for a simple markup language in which text can be wrapped in nested tags. Each tag consists of an opening tag `<tag>` and a corresponding closing tag `</tag>`. You need to verify that the document is properly structured with balanced tags and parentheses. Your task is to implement a function that checks whether a given string contains properly nested tags and balanced parentheses. The function should handle the following requirements: 1. The input should be a string containing any characters. 2. Tags and parentheses must be correctly nested and balanced. 3. Ignore any other characters that are not part of tags or parentheses. 4. Input strings that are empty should be considered valid. **Function Specification** ```python def is_valid_structure(document: str) -> bool: Check if the given document contains properly nested and balanced tags and parentheses. Parameters: document (str): The document to be checked. Returns: bool: True if the document is properly structured, otherwise False. ``` # Input * A string `document` representing the document text. The string can contain tags, parentheses, and other characters. # Output * Return `True` if the document has a valid structure with balanced and nested tags and parentheses. * Return `False` if the tags or parentheses are not properly structured. # Constraints * The function should handle strings of arbitrary length. * Focus on correctness and simplicity, even if the performance is not optimal for extremely large inputs. # Example ```python print(is_valid_structure(\\"<tag>(content)</tag>\\")) # True print(is_valid_structure(\\"<tag>(content<tag>)</tag></tag>\\")) # False print(is_valid_structure(\\"((<tag>text</tag>))\\")) # True print(is_valid_structure(\\"(<tag>text<tag>)\\")) # False ``` # Notes - Ensure your function correctly identifies improperly nested structures. - Provide comments explaining your logic for detecting balanced and nested tags and parentheses.","solution":"def is_valid_structure(document: str) -> bool: Check if the given document contains properly nested and balanced tags and parentheses. Parameters: document (str): The document to be checked. Returns: bool: True if the document is properly structured, otherwise False. stack = [] tag_start = False i = 0 while i < len(document): char = document[i] if char == \'<\': tag_start = i elif char == \'>\' and tag_start is not False: tag = document[tag_start:i+1] tag_start = False if tag.startswith(\'</\'): tag_name = tag[2:-1] if not stack or stack[-1] != tag_name: return False stack.pop() else: tag_name = tag[1:-1] stack.append(tag_name) elif char == \'(\': stack.append(\'(\') elif char == \')\': if not stack or stack[-1] != \'(\': return False stack.pop() i += 1 return len(stack) == 0"},{"question":"# Question You are tasked with developing a program for an e-commerce application where users can list items for sale and search for available items based on various criteria. Implement a search feature that allows users to filter items based on multiple attributes such as category, price range, and condition. Your task is to implement the `filter_items` function which filters items from a given dataset according to specified criteria. The `filter_items` function should take a list of dictionaries representing the items and a dictionary of criteria, and return a list of items matching all the criteria. Function Signature ```python from typing import List, Dict, Any def filter_items( items: List[Dict[str, Any]], criteria: Dict[str, Any] ) -> List[Dict[str, Any]]: Filters items based on given criteria. Parameters: items: List of dictionaries where each dictionary represents an item with attributes \'category\', \'price\', \'condition\', etc. criteria: Dictionary with keys as attribute names and values as the criteria for filtering. Criteria can be a specific value, a tuple for a range, or a list of acceptable values. Returns: A list of dictionaries where each dictionary is an item that matches all the filtering criteria. ``` Constraints * Each item in the `items` list is a dictionary with various attributes (\'category\', \'price\', \'condition\', etc.). * The `criteria` dictionary contains keys corresponding to item attributes and values which could be: - A specific value (e.g., `{\\"category\\": \\"electronics\\"}`) - A tuple representing a range (e.g., `{\\"price\\": (50, 100)}`) - A list of acceptable values (e.g., `{\\"condition\\": [\\"new\\", \\"like new\\"]}`). Input/Output Format - **Input**: - `items`: List of dictionaries, each representing an item. Example: ```python items = [ {\\"category\\": \\"electronics\\", \\"price\\": 99.99, \\"condition\\": \\"new\\"}, {\\"category\\": \\"clothing\\", \\"price\\": 19.99, \\"condition\\": \\"used\\"}, {\\"category\\": \\"electronics\\", \\"price\\": 199.99, \\"condition\\": \\"used\\"} ] ``` - `criteria`: Dictionary containing attribute keys and filtering criteria. Example: ```python criteria = {\\"category\\": \\"electronics\\", \\"price\\": (50, 150), \\"condition\\": [\\"new\\", \\"like new\\"]} ``` - **Output**: - List of dictionaries representing items that match all the criteria. Example: ```python filtered_items = [ {\\"category\\": \\"electronics\\", \\"price\\": 99.99, \\"condition\\": \\"new\\"} ] ``` Example ```python items = [ {\\"category\\": \\"electronics\\", \\"price\\": 99.99, \\"condition\\": \\"new\\"}, {\\"category\\": \\"clothing\\", \\"price\\": 19.99, \\"condition\\": \\"used\\"}, {\\"category\\": \\"electronics\\", \\"price\\": 199.99, \\"condition\\": \\"used\\"} ] criteria = {\\"category\\": \\"electronics\\", \\"price\\": (50, 150), \\"condition\\": [\\"new\\", \\"like new\\"]} filtered_items = filter_items(items, criteria) print(filtered_items) # Output: [{\\"category\\": \\"electronics\\", \\"price\\": 99.99, \\"condition\\": \\"new\\"}] ``` Note Ensure that your implementation efficiently checks all criteria and returns only items that fully match the given filtering conditions. Consider edge cases where no items match the criteria or some criteria are not provided.","solution":"from typing import List, Dict, Any def filter_items( items: List[Dict[str, Any]], criteria: Dict[str, Any] ) -> List[Dict[str, Any]]: Filters items based on given criteria. Parameters: items: List of dictionaries where each dictionary represents an item with attributes \'category\', \'price\', \'condition\', etc. criteria: Dictionary with keys as attribute names and values as the criteria for filtering. Criteria can be a specific value, a tuple for a range, or a list of acceptable values. Returns: A list of dictionaries where each dictionary is an item that matches all the filtering criteria. filtered_items = [] for item in items: match = True for key, value in criteria.items(): if key in item: if isinstance(value, tuple): # Handle range criteria if not (value[0] <= item[key] <= value[1]): match = False elif isinstance(value, list): # Handle list of acceptable values if item[key] not in value: match = False else: # Handle exact match criteria if item[key] != value: match = False else: match = False if not match: break if match: filtered_items.append(item) return filtered_items"},{"question":"# Problem Description You are provided with a binary tree class that includes functionality to add nodes and traverse the tree in various orders (pre-order, in-order, post-order). Your task is to implement an additional function that checks if the binary tree is a valid binary search tree (BST). A binary search tree is defined as a binary tree where for every node, the left subtree of that node contains only values less than the node’s value, and the right subtree only values greater than the node\'s value. Here are the requirements: 1. **Function Signature**: ```python def is_valid_bst(root: TreeNode) -> bool: ``` 2. **Parameters**: - `root`: The root node of the binary tree. # Constraints - The number of nodes in the tree can be between 1 and 100. - The value of each node is unique and can be any integer. 3. **Output**: - Returns a boolean value `True` if the binary tree is a valid BST; otherwise, returns `False`. # Implementation Details - You may assume that the TreeNode class has been defined with attributes `val`, `left`, and `right`. - Optimize the function to execute in O(n) time complexity with O(h) space complexity, where `n` is the number of nodes and `h` is the height of the tree. # Example ```python >>> class TreeNode: >>> def __init__(self, val=0, left=None, right=None): >>> self.val = val >>> self.left = left >>> self.right = right >>> def add_node(root, val): >>> if root is None: >>> return TreeNode(val) >>> if val < root.val: >>> root.left = add_node(root.left, val) >>> else: >>> root.right = add_node(root.right, val) >>> return root >>> root = None >>> root = add_node(root, 4) >>> root = add_node(root, 2) >>> root = add_node(root, 6) >>> root = add_node(root, 1) >>> root = add_node(root, 3) >>> root = add_node(root, 5) >>> root = add_node(root, 7) >>> is_valid_bst(root) True >>> root = None >>> root = add_node(root, 4) >>> root = add_node(root, 2) >>> root = add_node(root, 6) >>> root = add_node(root, 1) >>> root = add_node(root, 3) >>> root = add_node(root, 7) >>> root.right.left = TreeNode(3) # This node violates the BST property >>> is_valid_bst(root) False ``` # Hints 1. Consider implementing a helper function that checks the validity of BST by ensuring that all nodes fall within a specified range. 2. Use an in-order traversal approach to ensure that all values are in ascending order in a valid BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_node(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = add_node(root.left, val) else: root.right = add_node(root.right, val) return root def is_valid_bst(root: TreeNode) -> bool: def helper(node, lower=float(\'-inf\'), upper=float(\'inf\')): if not node: return True val = node.val if val <= lower or val >= upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root)"},{"question":"# Problem Statement Create a function that simulates a simplified version of the classic minesweeper game. The grid in minesweeper is represented by a 2D list, where each cell can either be a mine (`\'*\'`) or an empty cell (`\'.\'`). Your goal is to determine the number of mines surrounding each empty cell and represent this information in a new grid. Write a function `minesweeper(grid: List[List[str]]) -> List[List[str]]` that takes a 2D list `grid` and returns a new 2D list of the same dimensions where each empty cell is replaced by a digit (`\'0\'` to `\'8\'`) indicating the number of mines in the adjacent cells. Mines (`\'*\'`) remain unchanged. # Input * `grid` (1 ≤ len(grid), len(grid[0]) ≤ 100): a 2D list containing only the characters `\'*\'` and `\'.\'`. # Output * A 2D list of the same dimensions with each empty cell containing a digit representing the count of adjacent mines. # Constraints * The function should handle grids of varying sizes efficiently. * The counting of adjacent mines includes all 8 possible neighboring cells around a given cell. # Example ```python >>> grid = [ ... [\'*\', \'.\', \'.\', \'.\'], ... [\'.\', \'.\', \'.\', \'.\'], ... [\'.\', \'*\', \'.\', \'.\'], ... [\'.\', \'.\', \'.\', \'.\'] ... ] >>> minesweeper(grid) [ [\'*\', \'1\', \'0\', \'0\'], [\'2\', \'2\', \'1\', \'0\'], [\'1\', \'*\', \'1\', \'0\'], [\'1\', \'1\', \'1\', \'0\'] ] >>> grid = [ ... [\'*\', \'.\', \'*\'], ... [\'.\', \'*\', \'.\'], ... [\'*\', \'.\', \'.\'] ... ] >>> minesweeper(grid) [ [\'*\', \'3\', \'*\'], [\'3\', \'*\', \'2\'], [\'*\', \'2\', \'1\'] ] ``` # Notes * You may assume that the input grid is not empty and contains at least one cell. * Your implementation should handle edge cases where cells are at the borders or corners of the grid.","solution":"from typing import List def minesweeper(grid: List[List[str]]) -> List[List[str]]: Returns a new 2D list where empty cells (\'.\') are replaced by the number of adjacent mines (\'*\'). rows = len(grid) cols = len(grid[0]) result = [[None] * cols for _ in range(rows)] def count_mines(r, c): # Lambda to check the valid neighbors within the grid limits is_valid = lambda x, y: 0 <= x < rows and 0 <= y < cols # Directions array to navigate to all 8 possible neighbors directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] mine_count = 0 for dr, dc in directions: if is_valid(r + dr, c + dc) and grid[r + dr][c + dc] == \'*\': mine_count += 1 return mine_count for r in range(rows): for c in range(cols): if grid[r][c] == \'*\': result[r][c] = \'*\' else: result[r][c] = str(count_mines(r, c)) return result"},{"question":"# Scenario and Task As part of a data analysis team, one of your tasks involves implementing various statistical functions to better understand your datasets. You are required to implement a function that finds all modes of a given list of integers. # Problem Statement Implement a function `find_modes` that identifies all the modes (most frequently occurring elements) in a given list of integers. # Function Signature ```python def find_modes(nums: list) -> list: Identify all modes in the given list of integers. Parameters: nums (list): A list of integers which can contain duplicate elements. Returns: list: A list containing all modes of the input list in ascending order. pass ``` # Input - `nums`: A list of integers which can contain duplicate elements. # Output - Returns a list of integers representing the mode(s) of the input data; the list should contain all modes found and be sorted in ascending order. # Constraints - The input list `nums` can be empty or contain up to 10^5 elements. - Each element in the input list can be between -10^6 and 10^6. # Example ```python # Example input nums = [1, 3, 3, 7, 5, 3, 1, 5, 5] output = find_modes(nums) # Expected output: [3, 5] nums = [4, 4, 1, 1, 2, 2, 3, 3] output = find_modes(nums) # Expected output: [1, 2, 3, 4] nums = [10] output = find_modes(nums) # Expected output: [10] nums = [] output = find_modes(nums) # Expected output: [] ```","solution":"def find_modes(nums: list) -> list: from collections import Counter if not nums: return [] # Count occurrences of each number num_counts = Counter(nums) # Find the maximum occurrence max_count = max(num_counts.values()) # Gather all numbers that have that maximum occurrence modes = [num for num, count in num_counts.items() if count == max_count] return sorted(modes)"},{"question":"# Coding Exercise: Implement a Function to Compute the Moving Average Context The moving average, also known as a rolling mean, is frequently used in time series analysis to smooth out short-term fluctuations and highlight longer-term trends or cycles. It computes the average of a subset of data points within a specified window as it moves along the data set. Task Write a Python function `moving_average` that computes the moving average of a given list of numbers using a specified window size. The function should handle edge cases cleanly and provide efficient performance. Requirements 1. **Function Name**: `moving_average` 2. **Expected Input and Output**: - Input: A list of real numbers and an integer window size. - Output: A list of real numbers representing the moving averages. 3. **Constraints**: - The input list can have at least one element and at most 10,000 elements. - The window size will be a positive integer less than or equal to the length of the input list. 4. **Performance Requirements**: Ensure the function runs efficiently even for large input lists with maximum window size. Example Scenarios ```python >>> moving_average([1, 2, 3, 4, 5, 6], 2) [1.5, 2.5, 3.5, 4.5, 5.5] >>> moving_average([10, 20, 10, 30, 20], 3) [13.333333333333334, 20.0, 20.0] >>> moving_average([7, 1, 4, 5, 6], 1) [7, 1, 4, 5, 6] >>> moving_average([1], 1) [1] ``` Instructions - Your function should be implemented using core Python libraries. - Ensure the function handles various edge cases gracefully, including very small and very large lists, and window sizes that are 1 or equal to the length of the list. - Provide test cases to verify the correctness of your solution. --- You might use the following skeleton as a starting point: ```python def moving_average(numbers, window_size): if not numbers or window_size <= 0 or window_size > len(numbers): raise ValueError(\\"Invalid input\\") moving_averages = [] window_sum = sum(numbers[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(numbers)): window_sum += numbers[i] - numbers[i - window_size] moving_averages.append(window_sum / window_size) return moving_averages # Test cases print(moving_average([1, 2, 3, 4, 5, 6], 2)) print(moving_average([10, 20, 10, 30, 20], 3)) print(moving_average([7, 1, 4, 5, 6], 1)) print(moving_average([1], 1)) ```","solution":"def moving_average(numbers, window_size): Compute the moving average using a specified window size. Args: numbers (list of float): The list of numbers to compute the moving average on. window_size (int): The size of the window to use for the moving average computation. Returns: list of float: The computed moving averages. if not numbers or window_size <= 0 or window_size > len(numbers): raise ValueError(\\"Invalid input\\") moving_averages = [] window_sum = sum(numbers[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(numbers)): window_sum += numbers[i] - numbers[i - window_size] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# Coding Assessment Question Context: A magic square is a 2D square grid filled with distinct positive integers in the range from 1 to ( n^2 ) such that each cell\'s value is unique, and the sums of the integers in each row, each column, and both main diagonals are equal. Problem Statement: Given an integer `n`, generate the ( text{n} times text{n} ) magic square. Function Signature: ```python def generate_magic_square(n: int) -> List[List[int]]: pass ``` Input: - An integer `n` (3 ≤ n ≤ 15), the size of the magic square. Output: - A 2D list of integers, representing the generated magic square. Example: 1. **Input**: `n = 3` **Output**: ```python [ [8, 1, 6], [3, 5, 7], [4, 9, 2] ] ``` 2. **Input**: `n = 5` **Output**: ```python [ [17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9] ] ``` Constraints: - The magic square should be generated using an efficient algorithm, typically taking advantage of known techniques specifically optimized for this purpose. Note: - There are established algorithms for generating magic squares of a given size, such as the Siamese method for odd-sized magic squares. Consider such methods to ensure efficiency and correctness in your implementation. Write the Python function to solve this problem.","solution":"from typing import List def generate_magic_square(n: int) -> List[List[int]]: if n % 2 == 0: raise ValueError(\\"Only odd lengths are supported by this algorithm.\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 newi, newj = (i - 1) % n, (j + 1) % n if magic_square[newi][newj]: i += 1 else: i, j = newi, newj return magic_square"},{"question":"# Problem Statement You have been tasked with implementing a function to determine if a given string is a \\"valid\\" word chain. A word chain is a sequence of words where each word differs from the previous word by only one letter. The letters can be changed, added, or removed, but only one such operation is allowed between adjacent words in the sequence. # Function Signature ```python def is_valid_word_chain(word_chain: list[str]) -> bool: ... ``` # Input: 1. `word_chain` (list[str]): A list of strings representing the word chain. # Output: * Returns `True` if the word chain is valid, otherwise returns `False`. # Constraints: * Each word in the word chain will have a length between 1 and 20 characters. * The length of the word chain will be between 1 and 10^5 words. * Words will only consist of lowercase English letters (a-z). # Requirements: * Your solution should evaluate the validity of the word chain efficiently. * Consider performance optimizations to handle large inputs within the constraints. # Examples: ```python print(is_valid_word_chain([\'cat\', \'bat\', \'bet\', \'bed\'])) # Expected output: True print(is_valid_word_chain([\'cat\', \'bat\', \'bets\', \'best\'])) # Expected output: True print(is_valid_word_chain([\'cat\', \'bat\', \'beam\', \'bean\'])) # Expected output: False print(is_valid_word_chain([\'cat\', \'cats\', \'catsy\', \'cat\'])) # Expected output: False ``` # Notes: 1. Two words are considered one transformation apart (or \\"neighbors\\") if you can change exactly one letter, add one letter, or remove one letter to/from the first word to form the second word. 2. Carefully consider edge cases such as single-word chains, the presence of non-alphabetic characters (though within constraints this should not occur), and words with maximum or minimum lengths.","solution":"def is_valid_word_chain(word_chain: list[str]) -> bool: def is_neighbor(w1, w2): len1, len2 = len(w1), len(w2) # Case when lengths differ by more than 1 if abs(len1 - len2) > 1: return False # Case when lengths are equal if len1 == len2: diff_count = sum(1 for a, b in zip(w1, w2) if a != b) return diff_count == 1 # Case when one word is longer by exactly one character if len1 > len2: longer, shorter = w1, w2 else: longer, shorter = w2, w1 # Trying to remove one character for i in range(len(longer)): if longer[:i] + longer[i+1:] == shorter: return True return False for i in range(len(word_chain) - 1): if not is_neighbor(word_chain[i], word_chain[i+1]): return False return True"},{"question":"# Pathfinding in a Grid with Obstacles An essential problem in robotics and game development is finding a path between two points in a grid while avoiding obstacles. One common method for solving this problem is using the A* search algorithm, which is an informed search algorithm that uses a heuristic to improve performance over other search algorithms. Your task is to implement the A* search algorithm to find the shortest path from a start position to an end position in a grid that contains obstacles. # Function Signature ```python def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` # Input - `grid`: A 2D list of integers representing the grid. - `0` represents an open cell. - `1` represents an obstacle. - `start`: A tuple representing the starting cell `(x, y)` in the grid. - `goal`: A tuple representing the goal cell `(x, y)` in the grid. # Output - A list of tuples representing the cells `(x, y)` that form the path from start to goal (inclusive). - If no path is found, return an empty list. # Constraints - The grid dimensions are at most 100x100. - The start and goal positions will always be valid and open (i.e., not obstacles). - You can move in 4 directions (up, down, left, right). # Example ```python # Example input grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) # Expected output result = a_star_search(grid, start, goal) # Result might be: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` # Notes - The heuristic function to use for A* should be the Manhattan distance. - Ensure the implementation efficiently handles the search space to find the shortest path. - If multiple shortest paths exist, any one of them is a valid output.","solution":"from heapq import heappop, heappush from typing import List, Tuple def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance heuristic. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Perform A* search to find the shortest path from start to goal in a grid with obstacles. rows, cols = len(grid), len(grid[0]) open_set = [(0, start)] # Priority queue: (f_score, position) came_from = {} # Path dictionary g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heappop(open_set)[1] if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Isogram Checker: An isogram is a word in which no letter occurs more than once. Write a function `is_isogram(word: str) -> bool` that takes a word as input and returns `True` if it is an isogram, and `False` otherwise. # Input * A string `word` (1 ≤ len(word) ≤ 10000), which can contain both letters and digits. # Output * A boolean value, `True` if the word is an isogram, and `False` otherwise. # Constraints * The input string may only contain alphanumeric characters (both upper and lower case letters, digits). * Treat uppercase and lowercase letters as the same character, i.e., \\"a\\" and \\"A\\" are considered duplicates. * The function should be case-insensitive. * The function should handle edge cases like an empty string or strings with special characters. If such a case is encountered, raise a `ValueError`. # Example ```python assert is_isogram(\\"Dermatoglyphics\\") == True assert is_isogram(\\"aba\\") == False assert is_isogram(\\"moOse\\") == False assert is_isogram(\\"12345\\") == True assert is_isogram(\\"123451\\") == False ``` # Notes * Consider converting the input to lowercase before performing any operations. * Ensure that you are treating characters from \'a\'-\'z\' and digits from \'0\'-\'9\' as valid inputs. * Handle edge cases such as an empty string or strings containing special characters by raising a `ValueError`.","solution":"def is_isogram(word: str) -> bool: Checks if the input word is an isogram. Args: word (str): The input word to check. Returns: bool: True if the word is an isogram, False otherwise. Raises: ValueError: If the input word contains non-alphanumeric characters. if not word.isalnum(): raise ValueError(\\"The input word contains non-alphanumeric characters.\\") word = word.lower() return len(word) == len(set(word))"},{"question":"# Coding Assessment Question Scenario You are developing software to handle processing requests for a networked application. Each request has a unique identifier and an execution duration. The system can only process one request at a time, and requests come in at specific time points. Your goal is to simulate the execution of these requests and determine the completion time of each request. Problem Statement Implement a function `process_requests(requests: list[tuple[int, int]]) -> list[int]` that takes a list of requests where each request is represented as a tuple `(start_time, duration)`. The function should return a list of completion times for each request in the same order they were received. # Input: * A list of tuples `requests` where each tuple consists of two integers: - `start_time`: the time at which the request arrives. - `duration`: the time required to process the request. # Output: * A list of integers representing the completion times of the requests in the order they were received. # Constraints: * (1 leq text{number of requests} leq 10^5) * (0 leq text{start_time} leq 10^9) * (1 leq text{duration} leq 10^9) # Example: ```python requests_1 = [(2, 3), (4, 2), (6, 1)] # Request 1 starts at time 2 and lasts for 3 units assert process_requests(requests_1) == [5, 7, 8] requests_2 = [(1, 5), (2, 2), (3, 3)] assert process_requests(requests_2) == [6, 8, 11] ``` Function Signature ```python def process_requests(requests: list[tuple[int, int]]) -> list[int]: pass ``` # Notes: * Requests are always processed in the order they arrive. * The processing of a request starts as soon as the processor is free, even if that means starting a request after its arrival time if the processor is already busy. * Efficient handling of the requests and time simulation is necessary to ensure performance within the provided constraints.","solution":"def process_requests(requests: list[tuple[int, int]]) -> list[int]: Calculate the completion times for a list of requests. Each request is represented as a tuple (start_time, duration). :param requests: List of tuples where each tuple contains start_time and duration. :return: List of completion times for each request in the order they were received. completion_times = [] current_time = 0 for start_time, duration in requests: # If the request arrives after the current time, we need to wait until the request starts if current_time < start_time: current_time = start_time # Process the request current_time += duration # Append the completion time of the request completion_times.append(current_time) return completion_times"},{"question":"# Coding Challenge: Optimal Path Finder in a Grid Context In grid-based pathfinding problems, it\'s crucial to determine the optimal path from a start point to an end point. This is common in robotics and game development, where navigating through a grid efficiently can save time and resources. Task Write a function `find_optimal_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]` that finds the shortest path in a rectangular grid from the `start` point to the `end` point. The path cannot go through cells with a value of 0 (representing obstacles). The function should return the list of coordinates representing the path from start to end. Input * A 2D grid where each element is an integer (0 or 1), where 0 indicates an obstacle and 1 indicates a free cell. * A `tuple` representing the starting coordinate (row, col). * A `tuple` representing the ending coordinate (row, col). Output * A list of `tuples` representing the coordinates (row, col) of the optimal path from start to end. If no path exists, return an empty list. Constraints * The `grid` will have at least one row and one column. * All coordinates are valid and within the grid bounds. * There is no diagonal movement, only up, down, left, or right moves are allowed. * The time complexity must not exceed O(n * m) where n and m are the dimensions of the grid. Example ```python >>> find_optimal_path([ [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1] ], (0, 0), (3, 3)) [(0, 0), (1, 0), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3)] >>> find_optimal_path([ [1, 1, 0], [0, 1, 1], [1, 1, 1] ], (0, 0), (2, 2)) [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)] >>> find_optimal_path([ [1, 1, 0], [0, 0, 1], [1, 1, 1] ], (0, 0), (2, 2)) [] # No path exists ``` Problem Solving Strategy 1. Use breadth-first search (BFS) to explore all possible paths in the grid. 2. Use a queue to track the current path and explore all valid moves from the current position. 3. Maintain the visited nodes to avoid reprocessing the same cell and to prevent cycles. Good luck and ensure that your pathfinding algorithm is both optimal and correct!","solution":"from collections import deque def find_optimal_path(grid, start, end): Finds the shortest path in a rectangular grid from the start point to the end point. rows, cols = len(grid), len(grid[0]) queue = deque([(start, [start])]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: (current_row, current_col), path = queue.popleft() if (current_row, current_col) == end: return path for d_row, d_col in directions: new_row, new_col = current_row + d_row, current_col + d_col if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: queue.append(((new_row, new_col), path + [(new_row, new_col)])) visited.add((new_row, new_col)) return []"},{"question":"# Matrix Rotation Checker You are given a square matrix of integers. Your task is to determine if one matrix is a 90-degree rotation of another matrix. If matrix `B` is a 90-degree rotation of matrix `A`, return `True`, otherwise return `False`. Function Signature ```python def is_rotation_90(A: list[list[int]], B: list[list[int]]) -> bool: ``` # Input * Two square matrices `A` and `B` of size `n x n` (2 ≤ n ≤ 1000). * Each matrix element will be an integer in the range -10^9 to 10^9. # Output * Return `True` if `B` is a 90-degree rotation of `A`, otherwise `False`. # Example ```python print(is_rotation_90([[1, 2], [3, 4]], [[3, 1], [4, 2]])) # Output: True print(is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]])) # Output: True print(is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]])) # Output: False ``` # Edge Cases to Consider * Matrices of smallest size (2 times 2). * Elements ranging from negative to positive extremes to ensure robustness. * Handling when input matrices are already 90-degree rotations of each other or not.","solution":"def is_rotation_90(A: list[list[int]], B: list[list[int]]) -> bool: Determines if matrix B is a 90-degree rotation of matrix A. n = len(A) # Check if B is a 90-degree rotation of A for i in range(n): for j in range(n): if A[i][j] != B[j][n - 1 - i]: return False return True"},{"question":"# Problem Summary Write a function that takes a sentence and a set of banned words, then returns the most frequent word that is not banned. The function should ignore punctuation and assume that words are case insensitive. # Function Definition Write a function `most_frequent_word(sentence: str, banned: List[str]) -> str` that accepts the following parameters: * `sentence` (str): A string representing the input sentence. * `banned` (List[str]): A list of strings representing the banned words. # Output * The function should return a string representing the most frequent, non-banned word. # Constraints * The sentence will have at most 10^4 words. * The words in the sentence will consist of only lowercase and uppercase English letters and punctuations. * The set of banned words will have at most 1000 words. * Case sensitivity should be ignored, meaning \\"word\\" and \\"Word\\" should be treated as the same word. * It is guaranteed that there is at least one word that is not banned. # Example Suppose the input is: ``` sentence = \\"Bob hit a ball, the hit BALL flew far after it was hit.\\" banned = [\\"hit\\"] ``` Calling `most_frequent_word(sentence, banned)` should return `\\"ball\\"` because \\"ball\\" appears twice (case insensitive) and is not in the banned list. # Implementation Guidelines 1. Parse the sentence, removing any punctuations and converting all words to lowercase. 2. Create a frequency dictionary to count occurrences of each word. 3. Exclude the words present in the banned list while counting. 4. Identify the word with the highest frequency among the non-banned words. 5. Return the most frequent non-banned word. # Additional Notes Consider edge cases such as: * Sentences with no punctuation. * All words being banned except one. * Proper handling of different punctuation marks in multiple positions. * Mixed-case words appearing in the sentence.","solution":"import re from collections import Counter from typing import List def most_frequent_word(sentence: str, banned: List[str]) -> str: Returns the most frequent word in the sentence that is not in the banned list. :param sentence: The input sentence string. :param banned: A list of banned words. :return: The most frequent word that is not banned. banned_set = set(banned) # Normalize the sentence by making it lowercase and remove punctuations words = re.findall(r\'w+\', sentence.lower()) # Filter out banned words and count the frequency of each word word_counts = Counter(word for word in words if word not in banned_set) # Return the word with the highest frequency return word_counts.most_common(1)[0][0]"},{"question":"# Question: Calculate the Running Average Statement: Implement a function that calculates the running average of integers in a list. The function should return a list containing the running average at each position. Function Signature: ```python def running_average(numbers: list[int]) -> list[float]: ``` Input: - `numbers` (list of int): A list of integers, where (1 leq len(numbers) leq 10^3). Output: - A list of floats representing the running average at each position of the input list. Constraints: - You are only allowed to use built-in functions and standard libraries. - Handle edge cases appropriately (e.g., an empty list or single-element list). Example: ```python >>> running_average([2, 4, 6, 8, 10]) [2.0, 3.0, 4.0, 5.0, 6.0] >>> running_average([1]) [1.0] >>> running_average([1, 3, -2, 8, 5]) [1.0, 2.0, 0.6666666666666666, 2.5, 3.0] >>> running_average([-1, -2, -3, -4, -5]) [-1.0, -1.5, -2.0, -2.5, -3.0] ``` Notes: - The running average at index (i) is defined as the sum of all elements from index 0 to (i) divided by (i + 1). - Ensure precise floating-point arithmetic to avoid rounding issues.","solution":"def running_average(numbers: list[int]) -> list[float]: Calculates the running average of integers in a list. Args: numbers: A list of integers. Returns: A list of floats representing the running average at each position. result = [] running_sum = 0 for i, num in enumerate(numbers): running_sum += num result.append(running_sum / (i + 1)) return result"},{"question":"# Question: Implement a Balanced Binary Search Tree Insertion Context You are tasked with implementing a balanced binary search tree (BST) to ensure efficient data retrieval and storage. The main function should insert a new value into the BST while maintaining its balanced property using AVL (Adelson-Velsky and Landis) tree rotations. Objective Write a Python class `BalancedBST` that supports insertion and maintenance of the AVL tree properties. The tree should automatically balance itself after each insertion by performing necessary rotations. Class Definition and Methods 1. `BalancedBST`: The main class with methods for insertion and balancing. 2. `insert(self, key)`: Inserts a new integer key into the BST and balances the tree if necessary. 3. `height(self, node)`: Returns the height of the given node. 4. `get_balance(self, node)`: Computes and returns the balance factor of the given node. 5. `left_rotate(self, z)`: Performs a left rotation on the given node. 6. `right_rotate(self, z)`: Performs a right rotation on the given node. Constraints - Implement the BST node as a nested class `Node` within `BalancedBST`, with attributes `key`, `left`, `right`, and `height`. - The insertion method should ensure the AVL tree properties are restored by checking balance factors and performing rotations. - The height of each node must be accurately updated after any insertion or rotation. Example ```python # Define the BalancedBST class class BalancedBST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def insert(self, key): def _insert(root, key): if not root: return self.Node(key) elif key < root.key: root.left = _insert(root.left, key) else: root.right = _insert(root.right, key) root.height = 1 + max(self.height(root.left), self.height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root self.root = _insert(self.root, key) # Usage example: bst = BalancedBST() values = [10, 20, 30, 40, 50, 25] for value in values: bst.insert(value) ``` In this question, develop a `BalancedBST` class that ensures operations maintain the AVL tree\'s balanced property, allowing efficient insertion and tree rotation.","solution":"class BalancedBST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.height(z.left), self.height(z.right)) y.height = 1 + max(self.height(y.left), self.height(y.right)) return y def insert(self, key): def _insert(root, key): if not root: return self.Node(key) elif key < root.key: root.left = _insert(root.left, key) else: root.right = _insert(root.right, key) root.height = 1 + max(self.height(root.left), self.height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root self.root = _insert(self.root, key)"},{"question":"# Dijkstra\'s Algorithm with Priority Queue # Implement the Dijkstra\'s algorithm to find the shortest path in a weighted graph, using a priority queue for efficient distance updates. # Problem Given a directed graph represented as an adjacency list where each edge has a non-negative weight, you are to find the shortest path from a start vertex to all other vertices in the graph. # Function Signature ```python def dijkstra( graph: dict[int, list[tuple[int, int]]], start: int, ) -> dict[int, int]: ``` # Input * `graph` (`dict[int, list[tuple[int, int]]]`): A dictionary representing the adjacency list of the graph. The key is a node, and the value is a list of tuples (neighbour, weight), representing the connected node and the edge weight. * `start` (`int`): The starting node for the algorithm. # Output * Returns a dictionary (`dict[int, int]`) where the key is a node and the value is the shortest distance from the start node to that node. # Constraints * All weights are non-negative integers. * The graph is connected. * The number of nodes is represented within the adjacency list. # Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 result = dijkstra(graph, start) print(result) # Output: {0: 0, 1: 3, 2: 1, 3: 4} ``` # Notes 1. Use a priority queue to ensure efficient updates of the shortest distances. 2. Return the shortest distance to each node from the start node. If a node is unreachable, it does not appear in the output dictionary. The distance to the start node itself is `0`. 3. Remember to handle edge cases such as when there are no edges or when all nodes are directly connected.","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra\'s algorithm to find shortest paths from start to all other nodes. Parameters: graph: dict[int, list[tuple[int, int]]] -- The adjacency list representing the graph. start: int -- The starting node for the algorithm. Returns: dict[int, int] -- A dictionary with the shortest distance to each node. distances = {node: float(\'inf\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Task: Evaluating Arithmetic Expression Objective Write a function `evaluate_expression` that takes a single string argument representing a mathematical expression and outputs the evaluated result as an integer. Scenario Suppose you are implementing a basic calculator that can parse and evaluate simple arithmetic expressions containing addition and subtraction. Your task is to build the evaluator for this calculator. Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` Input 1. `expression` - A string representing a mathematical expression containing integers and the operators `+` and `-`. There will be no spaces in the expression. Output - An integer representing the result of evaluating the expression. Constraints - The expression will only contain valid integers and operators `+`, `-`. - The expression will be non-empty and will always start with an integer. - Integers in the expression will be in the range `-10^9` to `10^9`. Examples ```python assert evaluate_expression(\\"3+5-2\\") == 6 assert evaluate_expression(\\"10-4+3\\") == 9 assert evaluate_expression(\\"100-200+50\\") == -50 ``` # Requirements 1. Ensure to correctly handle both addition and subtraction operations. 2. The function should parse and evaluate the expression in a single pass through the string. 3. Return the final result as an integer. # Approach - Initialize a variable to store the current result and another to store the current number being parsed. - Traverse through each character in the expression, updating the current number or applying the operation to the current result whenever an operator is encountered. - At the end of the traversal, apply any remaining operation and return the final result.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression with addition and subtraction. Args: expression (str): a string representing the arithmetic expression. Returns: int: the evaluated result of the expression. result = 0 current_number = 0 current_sign = 1 # 1 means positive, -1 means negative for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: # Apply the current number with its sign to the result result += current_number * current_sign current_number = 0 if char == \'+\': current_sign = 1 elif char == \'-\': current_sign = -1 # Apply the last number result += current_number * current_sign return result"},{"question":"Question: Implement a Multiplexer # Scenario In digital circuit design, a multiplexer (MUX) is an essential component that selects one of several input signals and forwards the selected input to a single output line. You need to simulate a 2-to-1 multiplexer in software to verify its behavior. # Task Write a function `multiplexer` that simulates the behavior of a 2-to-1 multiplexer using the given truth table: ``` ------------------------------------ | Select | Input 0 | Input 1 | Output | ------------------------------------ | 0 | 0 | X | 0 | | 0 | 1 | X | 1 | | 1 | X | 0 | 0 | | 1 | X | 1 | 1 | ------------------------------------ ``` # Function Signature ```python def multiplexer(select: int, input_0: int, input_1: int) -> int: ``` # Input * `select` (int): A binary integer (0 or 1) that determines which input to forward. * `input_0` (int): A binary integer (0 or 1) that represents the first input signal. * `input_1` (int): A binary integer (0 or 1) that represents the second input signal. # Output * Returns the selected input signal based on the value of `select`. # Constraints * `select`, `input_0`, and `input_1` are guaranteed to be 0 or 1. # Example ```python print(multiplexer(0, 0, 1)) # Output: 0 print(multiplexer(0, 1, 0)) # Output: 1 print(multiplexer(1, 0, 1)) # Output: 1 print(multiplexer(1, 1, 0)) # Output: 0 ``` # Notes * Consider all edge cases and ensure your function adheres to the given truth table.","solution":"def multiplexer(select: int, input_0: int, input_1: int) -> int: Simulates a 2-to-1 multiplexer. Returns the value of input_0 if select is 0, otherwise returns the value of input_1 if select is 1. if select == 0: return input_0 else: return input_1"},{"question":"During a code review, you\'ve noticed that a function in the codebase is not handling errors effectively when making calls to an external service. The function attempts to retrieve user details from a third-party API using the `requests.get` method. To ensure reliability, you decide to write unit tests to mock the API responses and handle various edge cases, including timeouts, invalid responses, and successful data retrievals. # Task Write a Python function, `test_get_user_details`, that uses mocking to simulate the API response for a GET request using the `requests.get` method. The test should simulate different scenarios such as successful data retrieval, invalid data response, and request timeout. Requirements: - Create a class `FakeResponse` that mimics the real responses from `requests.get`. - Mock the `requests.get` method to simulate the following scenarios: - Successful data retrieval returning `{\\"status\\":\\"success\\",\\"user\\":{\\"id\\":123,\\"name\\":\\"Alice\\"}}`. - Invalid data response returning `{\\"status\\":\\"error\\",\\"message\\":\\"Invalid user\\"}`. - Simulate a request timeout. - Use the `monkeypatch` fixture to apply the mock. - Verify that the function handles each scenario correctly. - Ensure appropriate exception handling within the function being tested. - Validate the response content and status in the mock test function. Input and Output: - You don’t need to worry about the input and output format as it\'s a unit test configuration. - If the setup is correct, the unit test should pass without making real GET requests. Constraints: - Assume the API endpoint URL is `USER_DETAILS_ENDPOINT`. - The function to test can be named `get_user_details`, which sends a GET request. - Network operations should be fully mocked. # Example: ```python def get_user_details(user_id): try: response = requests.get(f\\"{USER_DETAILS_ENDPOINT}/{user_id}\\") response.raise_for_status() return response.json() except requests.exceptions.Timeout: return {\\"status\\": \\"error\\", \\"message\\": \\"Request timed out\\"} except requests.exceptions.RequestException as e: return {\\"status\\": \\"error\\", \\"message\\": str(e)} def test_get_user_details(monkeypatch): class FakeResponse: def __init__(self, json_data, status_code): self.json_data = json_data self.status_code = status_code def json(self): return self.json_data def raise_for_status(self): if self.status_code != 200: raise requests.exceptions.RequestException(self.json_data[\\"message\\"]) def mock_get(url): if \\"timeout\\" in url: raise requests.exceptions.Timeout elif \\"invalid\\" in url: return FakeResponse({\\"status\\":\\"error\\",\\"message\\":\\"Invalid user\\"}, 400) else: return FakeResponse({\\"status\\":\\"success\\",\\"user\\":{\\"id\\":123,\\"name\\":\\"Alice\\"}}, 200) monkeypatch.setattr(requests, \\"get\\", mock_get) # Test successful data retrieval response = get_user_details(\\"123\\") assert response[\\"status\\"] == \\"success\\" assert response[\\"user\\"][\\"name\\"] == \\"Alice\\" # Test invalid data response response = get_user_details(\\"invalid\\") assert response[\\"status\\"] == \\"error\\" assert response[\\"message\\"] == \\"Invalid user\\" # Test request timeout response = get_user_details(\\"timeout\\") assert response[\\"status\\"] == \\"error\\" assert response[\\"message\\"] == \\"Request timed out\\" ```","solution":"import requests USER_DETAILS_ENDPOINT = \\"http://example.com/api/users\\" def get_user_details(user_id): try: response = requests.get(f\\"{USER_DETAILS_ENDPOINT}/{user_id}\\") response.raise_for_status() return response.json() except requests.exceptions.Timeout: return {\\"status\\": \\"error\\", \\"message\\": \\"Request timed out\\"} except requests.exceptions.RequestException as e: return {\\"status\\": \\"error\\", \\"message\\": str(e)}"},{"question":"# Calendar Day Calculator You are required to implement a function that calculates the day of the week for a given date. The function should be based on Zeller\'s Congruence algorithm which is a well-known algorithm to solve such problems. Function Signature: ```python def day_of_week(day: int, month: int, year: int) -> str: ``` Inputs: - `day` (int): The day of the month. - `month` (int): The month of the year (1 for January, 2 for February, etc.). - `year` (int): The full year (e.g., 2023). Outputs: - `str`: The day of the week for the given date, e.g., \'Monday\', \'Tuesday\', etc. Constraints: 1. The date must be a valid Gregorian calendar date. 2. `1 <= day <= 31` 3. `1 <= month <= 12` 4. `1 <= year <= 9999` Example: ```python assert day_of_week(15, 8, 2023) == \'Tuesday\' assert day_of_week(1, 1, 2000) == \'Saturday\' assert day_of_week(29, 2, 2020) == \'Saturday\' assert day_of_week(31, 12, 1999) == \'Friday\' ``` Requirements: - Implement the function to determine the day of the week using Zeller\'s Congruence algorithm. - Ensure that your implementation correctly handles leap years. - The function should handle dates from all four-digit years efficiently. - Remember to include adjustments for months January and February as per the algorithm’s specifications. Use this algorithm to calculate the day of the week: ```python h = (q + (13(m + 1)) // 5 + K + K // 4 + J // 4 + 5 * J) % 7 ``` Where: - `q` is the day of the month. - `m` is the month (3 for March, 4 for April, 5 for May, ..., 12 for December. January and February are counted as months 13 and 14 of the previous year). - `K` is the year of the century (i.e., year % 100). - `J` is the zero-based century (i.e., year // 100).","solution":"def day_of_week(day: int, month: int, year: int) -> str: if month in [1, 2]: month += 12 year -= 1 q = day m = month K = year % 100 J = year // 100 h = (q + (13 * (m + 1)) // 5 + K + K // 4 + J // 4 + 5 * J) % 7 days = [\\"Saturday\\", \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\"] return days[h]"},{"question":"# Context In programming, a linked list is a linear data structure in which elements are not stored at contiguous memory locations. Instead, each element (node) points to the next one, forming a chain. A doubly linked list (DLL) is a type of linked list where each node points to both its next and previous nodes, allowing for bidirectional traversal. # Task You need to write a function that takes the head of a doubly linked list and an integer `k`, and rearranges the list such that the node at the `k`-th position (1-based index) becomes the new head of the list. If `k` is greater than the length of the list, the list should remain unchanged. # Function Signature: ```python class Node: def __init__(self, data): self.data = data self.next = None self.prev = None def rotate_doubly_linked_list(head: Node, k: int) -> Node: pass ``` # Input - `head`: The head node of a doubly linked list. - `k`: An integer representing the 1-based index position to which the list should be rotated. # Output - The head node of the rearranged doubly linked list. # Constraints 1. `k` should be a positive integer. 2. The nodes of the linked list contain integer data values. 3. You may assume that the given doubly linked list will not contain cycles. # Example ```python # Helper function to create a list from elements def create_doubly_linked_list(arr): if not arr: return None head = Node(arr[0]) current = head for value in arr[1:]: new_node = Node(value) current.next = new_node new_node.prev = current current = new_node return head # Helper function to convert linked list to Python list (for verification) def to_list(head): result = [] current = head while current: result.append(current.data) current = current.next return result head = create_doubly_linked_list([1, 2, 3, 4, 5]) new_head = rotate_doubly_linked_list(head, 3) print(to_list(new_head)) # Output: [3, 4, 5, 1, 2] head = create_doubly_linked_list([1, 2, 3, 4, 5]) new_head = rotate_doubly_linked_list(head, 6) print(to_list(new_head)) # Output: [1, 2, 3, 4, 5] (unchanged) head = create_doubly_linked_list([1, 2, 3]) new_head = rotate_doubly_linked_list(head, 1) print(to_list(new_head)) # Output: [1, 2, 3] (unchanged) ``` # Notes - Ensure that the links between nodes are correctly updated such that the list is still valid after the rotation. - You can assume that the function signature and the `Node` class are provided as described.","solution":"class Node: def __init__(self, data): self.data = data self.next = None self.prev = None def rotate_doubly_linked_list(head: Node, k: int) -> Node: if not head or k <= 1: return head current = head length = 1 # Find the length of the list and the last node while current.next: current = current.next length += 1 # If k is greater than the length, no rotation is needed if k > length: return head # Find the new head which is the k-th node new_head = head for _ in range(k-1): new_head = new_head.next # Adjust the previous and last node pointers for new head if new_head.prev: new_head.prev.next = None if current: current.next = head head.prev = current new_head.prev = None head = new_head return head # Helper function to create a doubly linked list from an array def create_doubly_linked_list(arr): if not arr: return None head = Node(arr[0]) current = head for value in arr[1:]: new_node = Node(value) current.next = new_node new_node.prev = current current = new_node return head # Helper function to convert doubly linked list to a list (for testing) def to_list(head): result = [] current = head while current: result.append(current.data) current = current.next return result"},{"question":"# Context: You are a software developer tasked with implementing a function that checks if a given string contains a unique set of characters, meaning no character repeats. The function should handle various input scenarios, including invalid inputs. # Task: Write a function `has_unique_chars` that determines if a string has all unique characters. # Specifications: * **Input**: A single argument `s`, which is expected to be a string. * **Output**: Boolean; `True` if the string has all unique characters, `False` otherwise. # Constraints: 1. The input should be validated to: - Be a string. - Raise a `TypeError` for any non-string input. 2. If the input string is empty, return `True`. # Performance: - Optimize for efficiency to handle large strings. # Function Signature: ```python def has_unique_chars(s: str) -> bool: # Implement the function that meets the outlined specifications ``` # Examples: ```python assert has_unique_chars(\\"abcdef\\") == True assert has_unique_chars(\\"aabcdef\\") == False assert has_unique_chars(\\"AaBbCc\\") == True assert has_unique_chars(\\"\\") == True try: has_unique_chars(1234) except TypeError as e: assert str(e) == \\"input must be a string\\" try: has_unique_chars(None) except TypeError as e: assert str(e) == \\"input must be a string\\" ``` # Additional Notes: - Address edge cases, such as strings with mixed case characters. - Focus on performance to handle the potential size of the input efficiently.","solution":"def has_unique_chars(s: str) -> bool: Determines if the input string has all unique characters. Args: s (str): The input string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"input must be a string\\") return len(set(s)) == len(s)"},{"question":"# Problem Statement A company wants to automate the process of calculating bonuses for its employees based on their performance scores. They need a function that will compute the bonus amounts according to specified rules. # Task Implement a function `calculate_bonus` that calculates an employee\'s bonus based on their performance score, the base bonus, and special multipliers for different performance tiers. Function Signature ```python def calculate_bonus( score: float, base_bonus: float, excellent_multiplier: float, good_multiplier: float, satisfactory_multiplier: float ) -> float: ``` Input * `score` (float): The performance score of the employee (on a scale of 0 to 10). * `base_bonus` (float): The base bonus amount. * `excellent_multiplier` (float): The multiplier for scores in the excellent range (8-10). * `good_multiplier` (float): The multiplier for scores in the good range (5-7). * `satisfactory_multiplier` (float): The multiplier for scores in the satisfactory range (3-4). Output * (float): The final bonus amount for the employee. Constraints * The values for `score`, `base_bonus`, `excellent_multiplier`, `good_multiplier`, and `satisfactory_multiplier` must all be non-negative. # Rules * Scores from 8 to 10: The bonus is `base_bonus` multiplied by `excellent_multiplier`. * Scores from 5 to 7: The bonus is `base_bonus` multiplied by `good_multiplier`. * Scores from 3 to 4: The bonus is `base_bonus` multiplied by `satisfactory_multiplier`. * Scores below 3: No bonus is awarded. # Example ```python final_bonus = calculate_bonus( 8.5, 1000.0, 2.0, 1.5, 1.2 ) print(final_bonus) # Output should be 2000.0 since the score is in the excellent range with a multiplier of 2.0 final_bonus = calculate_bonus( 6.0, 1000.0, 2.0, 1.5, 1.2 ) print(final_bonus) # Output should be 1500.0 since the score is in the good range with a multiplier of 1.5 final_bonus = calculate_bonus( 4.0, 1000.0, 2.0, 1.5, 1.2 ) print(final_bonus) # Output should be 1200.0 since the score is in the satisfactory range with a multiplier of 1.2 final_bonus = calculate_bonus( 2.0, 1000.0, 2.0, 1.5, 1.2 ) print(final_bonus) # Output should be 0.0 since the score is below 3 ``` # Notes 1. Ensure to validate the input values. 2. Document any assumptions or additional considerations in your solution.","solution":"def calculate_bonus( score: float, base_bonus: float, excellent_multiplier: float, good_multiplier: float, satisfactory_multiplier: float ) -> float: Calculate an employee\'s bonus based on their performance score. Parameters: score (float): The performance score of the employee (on a scale of 0 to 10). base_bonus (float): The base bonus amount. excellent_multiplier (float): The multiplier for scores in the excellent range (8-10). good_multiplier (float): The multiplier for scores in the good range (5-7). satisfactory_multiplier (float): The multiplier for scores in the satisfactory range (3-4). Returns: float: The final bonus amount for the employee. if score < 0 or base_bonus < 0 or excellent_multiplier < 0 or good_multiplier < 0 or satisfactory_multiplier < 0: raise ValueError(\\"One or more inputs are negative, which is not allowed.\\") if 8 <= score <= 10: return base_bonus * excellent_multiplier elif 5 <= score <= 7: return base_bonus * good_multiplier elif 3 <= score <= 4: return base_bonus * satisfactory_multiplier else: return 0.0"},{"question":"# List Intersection Problem You are tasked with developing part of a data processing tool that requires finding the intersection of two lists of integers. The intersection should be returned as a list in ascending order, without duplicates. You need to implement two functions according to the specifications: 1. **find_intersection(list1: list[int], list2: list[int]) -> list[int]** This function computes the intersection of two lists of integers. The resulting list should contain only the unique elements that are present in both input lists, sorted in ascending order. 2. **test_intersection() -> None** This function runs a set of test cases to ensure the correctness and efficiency of the `find_intersection` function. It prints the result of each test, indicating whether the function passed or failed. # Input 1. `find_intersection`: - `list1`: First list of integers. - `list2`: Second list of integers. 2. `test_intersection`: No input parameters. # Output 1. `find_intersection`: A sorted list of integers representing the intersection of the two input lists. 2. `test_intersection`: No output, but it should print the results of the test cases. # Example Usage ```python result = find_intersection([1, 2, 3, 4], [3, 4, 5, 6]) print(result) # Output: [3, 4] test_intersection() ``` # Debugging Constraints 1. Ensure the function handles edge cases such as empty lists and lists with no common elements. 2. Validate that the output list contains no duplicate elements and is sorted in ascending order. 3. Ensure efficiency by considering the time complexity of the implemented function. Aim to achieve better than O(n^2) time complexity, where n is the length of the lists. # Example Test Cases for `test_intersection` - Intersection of empty lists: `[], []` should return `[]` - Intersection of lists with no common elements: `[1, 2, 3], [4, 5, 6]` should return `[]` - Intersection of lists with duplicate elements: `[1, 1, 2, 3], [2, 2, 3, 3]` should return `[2, 3]` - Intersection of identical lists: `[1, 2, 3], [1, 2, 3]` should return `[1, 2, 3]` ```python def find_intersection(list1: list[int], list2: list[int]) -> list[int]: set1 = set(list1) set2 = set(list2) intersection = sorted(set1 & set2) return list(intersection) def test_intersection() -> None: assert find_intersection([], []) == [], \\"Failed on empty lists\\" assert find_intersection([1, 2, 3], [4, 5, 6]) == [], \\"Failed on non-intersecting lists\\" assert find_intersection([1, 1, 2, 3], [2, 2, 3, 3]) == [2, 3], \\"Failed on lists with duplicates\\" assert find_intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3], \\"Failed on identical lists\\" assert find_intersection([4, 5, 6], [5, 6, 7]) == [5, 6], \\"Failed on simple intersection\\" print(\\"All test cases passed!\\") # Example Usage result = find_intersection([1, 2, 3, 4], [3, 4, 5, 6]) print(result) # Output: [3, 4] test_intersection() ```","solution":"def find_intersection(list1: list[int], list2: list[int]) -> list[int]: Computes the intersection of two lists of integers. The resulting list is sorted in ascending order and contains no duplicates. set1 = set(list1) set2 = set(list2) intersection = sorted(set1 & set2) return list(intersection)"},{"question":"# Implementing a Mini Blockchain System In this task, you are required to implement a simplified version of a Blockchain system. Your implementation should include functionalities for creating and managing blocks, validating the blockchain, and adding transactions. # Requirements: 1. **Block Structure**: - Implement a block structure that includes an index, a timestamp, a list of transactions, a proof (or nonce), and the hash of the previous block. 2. **Blockchain Creation**: - Define the Blockchain class to initialize the blockchain with a genesis block and manage the chain. 3. **Proof of Work**: - Implement the proof of work algorithm that finds a number (nonce) such that the hash of the block meets a specified difficulty level (e.g., starts with four leading zeros). 4. **Blockchain Validation**: - Add a method to validate the blockchain ensuring each block’s hash is correct and the chain is unbroken. 5. **Transaction Management**: - Implement functions to create and add transactions to the blockchain. 6. **Documentation**: - Thoroughly document the code with detailed comments on each class, method, and step involved. # Specification: - Input: Transactions in the form of dictionaries containing sender, receiver, and amount. - Output: A list representing the state of the blockchain; New blocks for valid transactions. - Constraints: - Ensure that each block\'s timestamp is accurate. - The blockchain should maintain integrity and prevent tampering. - Efficiency: Focus on efficient transaction management and block creation. # Deliverables: - Complete the implementation based on the template provided. - Demonstrate the blockchain functionalities by creating blocks and adding transactions. - Provide a brief report, including the challenges faced, design decisions for implementations, and the results obtained. ```python Mini Blockchain System Implementation import hashlib import json from time import time class Block: def __init__(self, index, timestamp, transactions, proof, previous_hash): self.index = index self.timestamp = timestamp self.transactions = transactions self.proof = proof self.previous_hash = previous_hash class Blockchain: def __init__(self): self.chain = [] self.current_transactions = [] self.new_block(previous_hash=\'1\', proof=100) # Genesis block def new_block(self, proof, previous_hash=None): Create a new Block in the Blockchain :param proof: The proof given by the Proof of Work algorithm :param previous_hash: Hash of previous Block :return: New Block object block = Block( index=len(self.chain) + 1, timestamp=time(), transactions=self.current_transactions, proof=proof, previous_hash=previous_hash or self.hash(self.chain[-1]), ) self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): Creates a new transaction to go into the next mined Block :param sender: Address of the sender :param recipient: Address of the recipient :param amount: Amount to send :return: Index of the Block that will hold this transaction self.current_transactions.append({ \'sender\': sender, \'recipient\': recipient, \'amount\': amount, }) return self.last_block.index + 1 @staticmethod def hash(block): Creates a SHA-256 hash of a Block :param block: Block :return: The hashed string block_string = json.dumps(block.__dict__, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): return self.chain[-1] def proof_of_work(self, last_proof): Proof of Work algorithm :param last_proof: <int> :return: <int> the new proof proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): Validates the Proof :param last_proof: <int> Previous Proof :param proof: <int> Current Proof :return: <bool> True if valid, False if not. guess = f\'{last_proof}{proof}\'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \\"0000\\" def valid_chain(self, chain): Determine if a given blockchain is valid :param chain: <list> A blockchain :return: <bool> True if valid, False if not last_block = chain[0] current_index = 1 while current_index < len(chain): block = chain[current_index] if block.previous_hash != self.hash(last_block): return False if not self.valid_proof(last_block.proof, block.proof): return False last_block = block current_index += 1 return True if __name__ == \'__main__\': # Test the Blockchain implementation blockchain = Blockchain() # Add some transactions blockchain.new_transaction(\'A\', \'B\', 1) blockchain.new_transaction(\'C\', \'D\', 2) # Mine a block last_proof = blockchain.last_block.proof proof = blockchain.proof_of_work(last_proof) previous_hash = blockchain.hash(blockchain.last_block) blockchain.new_block(proof, previous_hash) # Display the blockchain for block in blockchain.chain: print(f\'Index: {block.index}\') print(f\'Timestamp: {block.timestamp}\') print(f\'Transactions: {block.transactions}\') print(f\'Proof: {block.proof}\') print(f\'Previous Hash: {block.previous_hash}\') print(f\'Hash: {blockchain.hash(block)}n\') ```","solution":"Mini Blockchain System Implementation import hashlib import json from time import time class Block: def __init__(self, index, timestamp, transactions, proof, previous_hash): self.index = index self.timestamp = timestamp self.transactions = transactions self.proof = proof self.previous_hash = previous_hash class Blockchain: def __init__(self): self.chain = [] self.current_transactions = [] self.new_block(previous_hash=\'1\', proof=100) # Genesis block def new_block(self, proof, previous_hash=None): Create a new Block in the Blockchain :param proof: The proof given by the Proof of Work algorithm :param previous_hash: Hash of previous Block :return: New Block object block = Block( index=len(self.chain) + 1, timestamp=time(), transactions=self.current_transactions, proof=proof, previous_hash=previous_hash or self.hash(self.chain[-1]), ) self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): Creates a new transaction to go into the next mined Block :param sender: Address of the sender :param recipient: Address of the recipient :param amount: Amount to send :return: Index of the Block that will hold this transaction self.current_transactions.append({ \'sender\': sender, \'recipient\': recipient, \'amount\': amount, }) return self.last_block.index + 1 @staticmethod def hash(block): Creates a SHA-256 hash of a Block :param block: Block :return: The hashed string block_string = json.dumps(block.__dict__, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() @property def last_block(self): return self.chain[-1] def proof_of_work(self, last_proof): Proof of Work algorithm :param last_proof: <int> :return: <int> the new proof proof = 0 while not self.valid_proof(last_proof, proof): proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): Validates the Proof :param last_proof: <int> Previous Proof :param proof: <int> Current Proof :return: <bool> True if valid, False if not. guess = f\'{last_proof}{proof}\'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \\"0000\\" def valid_chain(self, chain): Determine if a given blockchain is valid :param chain: <list> A blockchain :return: <bool> True if valid, False if not last_block = chain[0] current_index = 1 while current_index < len(chain): block = chain[current_index] if block.previous_hash != self.hash(last_block): return False if not self.valid_proof(last_block.proof, block.proof): return False last_block = block current_index += 1 return True if __name__ == \'__main__\': # Test the Blockchain implementation blockchain = Blockchain() # Add some transactions blockchain.new_transaction(\'A\', \'B\', 1) blockchain.new_transaction(\'C\', \'D\', 2) # Mine a block last_proof = blockchain.last_block.proof proof = blockchain.proof_of_work(last_proof) previous_hash = blockchain.hash(blockchain.last_block) blockchain.new_block(proof, previous_hash) # Display the blockchain for block in blockchain.chain: print(f\'Index: {block.index}\') print(f\'Timestamp: {block.timestamp}\') print(f\'Transactions: {block.transactions}\') print(f\'Proof: {block.proof}\') print(f\'Previous Hash: {block.previous_hash}\') print(f\'Hash: {blockchain.hash(block)}n\')"},{"question":"# Context You are part of a software development team working on an automated notification system. One of the required components is a utility that determines the optimal schedule for sending out notifications. You are tasked with developing an algorithm that, given a list of notification requests, finds the maximum number of non-overlapping notifications that can be scheduled. # Problem Statement Write a Python function that receives a list of tuples, each representing a notification with a start time and an end time. Your task is to determine the maximum number of non-overlapping notifications that can be scheduled. # Function Signature ```python def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Parameters: intervals: List[Tuple[int, int]] -> A list of tuples where each tuple contains two integers (start, end) Returns: int -> Maximum number of non-overlapping intervals ``` # Input and Output - **Input**: - `intervals`: A list of `(start, end)` tuples, where `start` and `end` are integers representing the start and end times of a notification. The intervals are unsorted and there can be overlapping intervals. - **Output**: - An integer representing the maximum number of non-overlapping intervals that can be scheduled. # Constraints - All start times are unique. - Start times and end times are non-negative integers and can be large. # Example ```python intervals = [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)] max_count = max_non_overlapping_intervals(intervals) print(max_count) # Example output: 3 ``` # Test Case Validate your solution by: 1. Testing with a small toy dataset. 2. Ensuring the intervals are correctly parsed and non-overlapping intervals are identified. 3. Handling edge cases like intervals with the same start and end times, very small or very large ranges, and completely overlapping intervals. # Solution Outline 1. **Sorting**: Sort the intervals based on their end times. 2. **Iterative Selection**: Use a greedy algorithm to iteratively select the next interval that starts after the end of the last selected interval. 3. **Count**: Keep a count of the selected non-overlapping intervals and return this count as the result.","solution":"from typing import List, Tuple def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Parameters: intervals: List[Tuple[int, int]] -> A list of tuples where each tuple contains two integers (start, end) Returns: int -> Maximum number of non-overlapping intervals if not intervals: return 0 # Sort intervals based on ending times intervals.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping intervals count = 0 current_end = -1 for interval in intervals: start, end = interval if start > current_end: # Select this interval count += 1 current_end = end return count"},{"question":"# Reverse Level Order Traversal You are given a binary tree structure where each node contains an integer data value, and pointers to its left and right child nodes. Your task is to write a function that performs a reverse level-order traversal on the given binary tree and returns a list of node values in reverse level order. Reverse level-order traversal means you visit the nodes on the last level first, then the nodes on the second last level, and so on, until you reach the root node. Implement the following function: - `reverse_level_order(root: TreeNode) -> List[int]`: This function takes the root of a binary tree and returns a list of node values in reverse level order. # Example: Given the binary tree: ``` 1 / 2 3 / 4 5 ``` The reverse level order traversal should return: ``` [4, 5, 2, 3, 1] ``` Function Signature: ```python def reverse_level_order(root: TreeNode) -> List[int]: pass ``` Constraints: * The number of nodes in the tree is in the range [0, 1000]. * -100 <= Node.data <= 100 # Implementation Details: 1. Use a queue or deque to facilitate level order traversal from bottom to top. 2. Traversal must maintain the reverse level order sequence. 3. Write necessary helper functions if required. # Example Usage: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root: TreeNode) -> List[int]: from collections import deque if not root: return [] queue = deque([root]) result = deque() while queue: node = queue.popleft() # Add the current node\'s value at the front of the result deque result.appendleft(node.val) # Add the children of the current node to the queue: # Note that right child is added before left child if node.right: queue.append(node.right) if node.left: queue.append(node.left) return list(result) # Test Case root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(reverse_level_order(root)) # Output should be: [4, 5, 2, 3, 1] ``` # Constraints: - The number of nodes in the tree is in the range [0, 1000]. - -100 <= Node.data <= 100","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root: TreeNode) -> List[int]: if not root: return [] queue = deque([root]) result = deque() while queue: node = queue.popleft() # Add the current node\'s value at the front of the result deque result.appendleft(node.val) # Add the children of the current node to the queue: # Note that right child is added before left child if node.right: queue.append(node.right) if node.left: queue.append(node.left) return list(result)"},{"question":"Binary Search with Iterative Approach Binary search is a classic algorithm used to find the position of a target value within a sorted array. The iterative approach is often preferred as it avoids the overhead of recursive function calls and can be more memory efficient. # Problem Statement You are required to implement the binary search algorithm using an iterative approach to find the position of a specified element in a sorted list. # Input * A sorted list `arr` of `n` integers. * An integer `val` which is the value to be searched within the list. # Output * Return the index of the `val` in the list. * Return `-1` if the value is not found in the list. # Constraints * The elements of the list can be any type that supports comparison operators. * The list `arr` can be of size `0 <= len(arr) <= 10^6`. * Be prepared to handle both positive and negative integers. # Example: ```python >>> binary_search([2, 3, 5, 6, 8, 9], 5) 2 >>> binary_search([2, 3, 5, 6, 8, 9], 1) -1 >>> binary_search([], 4) -1 >>> binary_search([-10, -5, 0, 3, 8, 12], 3) 3 ``` # Task Implement the `binary_search` function using the iterative approach as described.","solution":"def binary_search(arr, val): Perform binary search to find the index of val in the sorted list arr. Return -1 if val is not found in arr. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == val: return mid elif arr[mid] < val: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Check if a Directed Graph Contains a Cycle **Context**: Understanding the properties of graphs can be crucial in various fields such as computer networks, operations research, and artificial intelligence. One critical property is whether a directed graph contains a cycle, which can have significant implications for processes like deadlock detection in operating systems. **Problem Statement**: Write a Python function `contains_cycle(graph: DirectedGraph) -> bool` that checks if a given directed graph contains a cycle, using the provided `DirectedGraph` and `Node` classes. **Input Format**: - A directed graph represented by an instance of the `DirectedGraph` class. **Output Format**: - Return `True` if the directed graph contains a cycle. - Return `False` otherwise. **Constraints**: - A non-empty directed graph will be provided as input. - You can assume that the graph nodes have integer identifiers. **Performance Requirements**: - The solution should have O(V + E) time complexity, where V is the number of vertices and E is the number of edges in the graph. - Utilize O(V) space complexity for visited tracking. # Function Signature ```python def contains_cycle(graph: DirectedGraph) -> bool: pass ``` # Example Consider the following directed graph: ``` 1 → 2 → 3 ↑ ↓ | | 4 ← 5 | | 7 ← 6 ← | ``` - Input: `DirectedGraph` with this structure. - Output: `True` because the graph contains a cycle (1 → 2 → 4 → 5 → 3 → 1). Additional Example: Consider the following directed graph: ``` 1 → 2 → 3 ↓ 4 ← 5 | 6 ``` - Input: `DirectedGraph` with this structure. - Output: `False` because the graph does not contain any cycles.","solution":"class Node: def __init__(self, identifier): self.id = identifier self.edges = [] class DirectedGraph: def __init__(self): self.nodes = {} def add_node(self, identifier): if identifier not in self.nodes: self.nodes[identifier] = Node(identifier) def add_edge(self, from_id, to_id): if from_id in self.nodes and to_id in self.nodes: self.nodes[from_id].edges.append(self.nodes[to_id]) def contains_cycle(graph: DirectedGraph) -> bool: visited = set() rec_stack = set() def visit(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in node.edges: if visit(neighbor): return True rec_stack.remove(node) return False for node in graph.nodes.values(): if visit(node): return True return False"},{"question":"# Problem Statement You are given two strings, `s1` and `s2`, and you need to determine if `s1` can be transformed into `s2` using a series of operations. An operation is defined as either inserting, deleting, or replacing a single character. Your task is to implement a function `can_transform(s1, s2)` that returns the minimum number of operations required to transform `s1` into `s2`. # Function Signature ```python def can_transform(s1: str, s2: str) -> int: ... ``` # Input * `s1`: A string containing between 0 and 1000 characters. * `s2`: A string containing between 0 and 1000 characters. # Output * An integer representing the minimum number of operations required to transform `s1` into `s2`. # Constraints * Both `s1` and `s2` consist of only lowercase alphabetic characters. # Example ```python print(can_transform(\\"kitten\\", \\"sitting\\")) # Output: 3 print(can_transform(\\"flaw\\", \\"lawn\\")) # Output: 2 print(can_transform(\\"\\", \\"abc\\")) # Output: 3 print(can_transform(\\"a\\", \\"a\\")) # Output: 0 ``` # Guidelines * The solution should efficiently handle edge cases, such as one or both strings being empty. * Consider using dynamic programming to find the optimal solution. * Validate that the function handles up to the maximum constraint of 1000 characters effectively. --- # Explanation: To solve this problem, you\'ll need to use the dynamic programming approach to calculate the minimum number of edit operations required. The function `can_transform(s1, s2)` should build a table where each cell `[i][j]` represents the minimum number of operations needed to transform the first `i` characters of `s1` into the first `j` characters of `s2`.","solution":"def can_transform(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. Operations include inserting, deleting, or replacing a single character. m, n = len(s1), len(s2) # Create the DP table dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Replacement ) return dp[m][n]"},{"question":"# Context: You are developing a utility function to help manage a list of tasks. Each task is represented by a dictionary with a unique identifier, a description, a status, and a priority level. The status can either be \\"completed\\" or \\"pending,\\" and the priority can range from 1 (lowest) to 5 (highest). The function should filter and sort the tasks based on specific criteria. # Task: Write a function `filter_and_sort_tasks` that filters the tasks based on their status and then sorts them by their priority level. # Specifications: * **Input**: A list of task dictionaries `tasks` and a status string `status`. * **Output**: A list of task dictionaries that match the given status, sorted in descending order of priority. # Constraints: 1. Validate the input to ensure: - `tasks` is a list of dictionaries with the keys: \'id\', \'description\', \'status\', \'priority\'. - Each dictionary contains the correct data types: \'id\' (int), \'description\' (str), \'status\' (str), \'priority\' (int). - If the input is invalid, the function should raise a `ValueError`. 2. The valid statuses are \\"completed\\" and \\"pending\\". If an invalid status is provided, raise a `ValueError`. 3. Return an empty list if no tasks match the given criteria. # Performance: - Ensure the function handles a large number of tasks efficiently. # Function Signature: ```python def filter_and_sort_tasks(tasks: list, status: str) -> list: # Implement the function that meets the outlined specifications ``` # Examples: ```python tasks = [ {\'id\': 1, \'description\': \\"Write report\\", \'status\': \\"pending\\", \'priority\': 3}, {\'id\': 2, \'description\': \\"Read book\\", \'status\': \\"completed\\", \'priority\': 4}, {\'id\': 3, \'description\': \\"Buy groceries\\", \'status\': \\"pending\\", \'priority\': 5}, {\'id\': 4, \'description\': \\"Clean room\\", \'status\': \\"completed\\", \'priority\': 1} ] assert filter_and_sort_tasks(tasks, \\"pending\\") == [ {\'id\': 3, \'description\': \\"Buy groceries\\", \'status\': \\"pending\\", \'priority\': 5}, {\'id\': 1, \'description\': \\"Write report\\", \'status\': \\"pending\\", \'priority\': 3} ] assert filter_and_sort_tasks(tasks, \\"completed\\") == [ {\'id\': 2, \'description\': \\"Read book\\", \'status\': \\"completed\\", \'priority\': 4}, {\'id\': 4, \'description\': \\"Clean room\\", \'status\': \\"completed\\", \'priority\': 1} ] try: filter_and_sort_tasks(tasks, \\"in-progress\\") except ValueError as e: assert str(e) == \\"Invalid status provided\\" try: filter_and_sort_tasks(\\"invalid input\\", \\"pending\\") except ValueError as e: assert str(e) == \\"Invalid tasks list provided\\" ``` # Additional Notes: - Ensure the function validates the structure and types of the input data before processing. - Consider edge cases such as empty lists or lists without matching tasks.","solution":"def filter_and_sort_tasks(tasks, status): # Validate status if status not in [\\"completed\\", \\"pending\\"]: raise ValueError(\\"Invalid status provided\\") # Validate tasks if not isinstance(tasks, list): raise ValueError(\\"Invalid tasks list provided\\") for task in tasks: if not isinstance(task, dict): raise ValueError(\\"Invalid task entry found\\") if not all(key in task for key in [\'id\', \'description\', \'status\', \'priority\']): raise ValueError(\\"Task dictionary missing required keys\\") if not isinstance(task[\'id\'], int): raise ValueError(\\"Task \'id\' must be an integer\\") if not isinstance(task[\'description\'], str): raise ValueError(\\"Task \'description\' must be a string\\") if not isinstance(task[\'status\'], str): raise ValueError(\\"Task \'status\' must be a string\\") if not isinstance(task[\'priority\'], int): raise ValueError(\\"Task \'priority\' must be an integer\\") # Filter tasks by status filtered_tasks = [task for task in tasks if task[\'status\'] == status] # Sort by priority in descending order sorted_tasks = sorted(filtered_tasks, key=lambda x: x[\'priority\'], reverse=True) return sorted_tasks"},{"question":"# String Anagram Check Problem Statement You are given two strings, and you need to determine if one string is an anagram of the other. Two strings are anagrams if they contain the same characters with the same frequency, but possibly in a different order. To enhance robustness, add functionality to ensure: 1. The function handles case insensitivity. 2. Non-alphabetic characters (e.g., spaces, punctuation) should be ignored during comparison. 3. Provide comprehensive error handling for invalid inputs (e.g., non-string types, None). Functional Specification 1. **Function Name**: `are_anagrams` 2. **Input**: Two strings `str1` and `str2`. 3. **Output**: A boolean indicating whether the two strings are anagrams. 4. **Exceptions**: - Raise a `TypeError` if any input is not a string or is None. Constraints 1. Ignore case while comparing the two strings. 2. Ignore non-alphabetic characters. Examples ```python >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Hello, World!\\", \\"Dolor, Whlle!\\") True >>> are_anagrams(\\"Anagram\\", \\"Nagaram\\") True >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"Astronomer\\", None) Traceback (most recent call last): ... TypeError: Both inputs must be non-null strings >>> are_anagrams(\\"Data\\", 12345) Traceback (most recent call last): ... TypeError: Both inputs must be non-null strings ``` Implementation Implement the function according to the specifications, ensuring it handles all provided use cases and edge cases. ```python def are_anagrams(str1, str2): Determine if two strings are anagrams, ignoring case and non-alphabetic characters. Args: str1: First input string. str2: Second input string. Returns: Boolean indicating whether the two strings are anagrams. Raises: TypeError: If either of the inputs is not a string or is None. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Both inputs must be non-null strings\\") # Helper function to filter and normalize a string def normalize(s): return \'\'.join(filter(str.isalpha, s)).lower() return sorted(normalize(str1)) == sorted(normalize(str2)) if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` This question aligns with the existing set, ensuring matching complexity, scope, and style.","solution":"def are_anagrams(str1, str2): Determine if two strings are anagrams, ignoring case and non-alphabetic characters. Args: str1: First input string. str2: Second input string. Returns: Boolean indicating whether the two strings are anagrams. Raises: TypeError: If either of the inputs is not a string or is None. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Both inputs must be non-null strings\\") # Helper function to filter and normalize a string def normalize(s): return \'\'.join(filter(str.isalpha, s)).lower() return sorted(normalize(str1)) == sorted(normalize(str2))"},{"question":"# Context Sorted arrays are common in various algorithmic problems, and being able to effectively merge and process multiple sorted arrays is a valuable skill in programming. This task involves merging two sorted arrays into a single sorted array while eliminating any duplicate elements. # Problem Statement Write a function, `merge_sorted_arrays(arr1, arr2)`, that takes two sorted arrays of integers `arr1` and `arr2` and returns a new sorted array containing all the elements from both input arrays, but without any duplicates. The output array should also be sorted. # Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: pass ``` # Input * `arr1`: A list of integers sorted in ascending order. * `arr2`: A list of integers sorted in ascending order. # Output * A list of integers sorted in ascending order, containing all unique elements from both `arr1` and `arr2`. # Constraints * Each input list will have a length between 0 and 1000 (inclusive). * The integers in the input lists will range from -10000 to 10000. # Example ```python # Example 1: arr1 = [1, 3, 5, 7] arr2 = [2, 3, 6, 7, 8] result = merge_sorted_arrays(arr1, arr2) print(result) # Output: [1, 2, 3, 5, 6, 7, 8] # Example 2: arr1 = [1, 2, 3] arr2 = [1, 1, 2, 4] result = merge_sorted_arrays(arr1, arr2) print(result) # Output: [1, 2, 3, 4] # Example 3: arr1 = [] arr2 = [1, 2, 3] result = merge_sorted_arrays(arr1, arr2) print(result) # Output: [1, 2, 3] ``` # Explanation In Example 1, the merged array contains all unique elements from `arr1` and `arr2` in sorted order. Duplicates like `3` and `7` are included only once in the result array. Example 2 shows merging with duplicates in one of the arrays. Example 3 demonstrates merging when one array is empty.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted lists into one sorted list without duplicates. Parameters: arr1 (List[int]): The first sorted list. arr2 (List[int]): The second sorted list. Returns: List[int]: A merged and deduplicated sorted list. merged_set = set(arr1).union(arr2) merged_list = sorted(merged_set) return merged_list"},{"question":"Data Preprocessing and Simple Linear Regression Implementation In this task, you need to implement a data preprocessing module and a simple linear regression model. The aim is to accurately predict a target variable based on a single feature from the given dataset. # Task 1. **Complete the `preprocess_data` function**: This function should handle missing values in the dataset by either removing rows with missing values or imputing them with the mean of the column. It should also normalize the feature to have a mean of 0 and a standard deviation of 1. 2. **Complete the `fit` method**: The `fit` method will perform linear regression by computing the optimal values of the parameters (intercept and coefficient). 3. **Complete the `predict` method**: The `predict` method will use the computed parameters to predict the target variable based on the input feature. 4. **Implement Error Checking** in the preprocessing and regression methods to handle invalid input data and ensure robust behavior given constraints or unexpected input. # Input and Output Input * `preprocess_data` function: - `data`: Pandas DataFrame containing the dataset with one feature column and one target column. - `strategy`: String indicating the missing value handling strategy (\\"mean\\" for imputation, \\"drop\\" for removing rows). * `fit` method: - `X`: NumPy array representing the feature values. - `y`: NumPy array representing the target values. * `predict` method: - `X_new`: NumPy array representing the new feature values for prediction. Output * `preprocess_data` function: Pandas DataFrame with missing values handled and feature normalized. * `fit` method: None. This method trains the linear regression model and stores the parameters. * `predict` method: NumPy array representing the predicted target values. # Constraints 1. Ensure the `preprocess_data` function handles missing values according to the specified strategy and normalizes the feature. 2. The `fit` method should calculate the intercept and coefficient using the least squares method. 3. The `predict` method should produce correct outputs for up to 10,000 observations with minimal latency. # Example Here\'s an example usage of the completed module and methods: ```python import pandas as pd import numpy as np # Sample data for testing data = pd.DataFrame({ \'feature\': [1.0, 2.0, np.nan, 4.0, 5.0], \'target\': [1.5, 2.0, 2.5, 3.5, 4.0] }) # Preprocessing the data preprocessed_data = preprocess_data(data, strategy=\'mean\') # Extracting features and target X = preprocessed_data[\'feature\'].values.reshape(-1, 1) y = preprocessed_data[\'target\'].values # Linear Regression initialization and training lr = LinearRegression() lr.fit(X, y) # Predicting new target values X_new = np.array([[3.0], [6.0]]) predictions = lr.predict(X_new) print(predictions) # Expected output: array with two predicted values based on the trained model ``` Be sure to implement the necessary preprocessing steps and linear regression calculations correctly. Ensure your code handles edge cases gracefully. # Submission Guidelines For your submission, provide the complete implementation of the `preprocess_data` function and the `LinearRegression` class with its methods. Ensure comprehensive testing for all implemented functions and methods. Do not include example code or tests in your final submission, but ensure the module is capable of handling the above example correctly.","solution":"import pandas as pd import numpy as np def preprocess_data(data, strategy=\'mean\'): Preprocess the dataset by handling missing values and normalizing the feature column. Parameters: data (pd.DataFrame): The dataset containing one feature column and one target column. strategy (str): Strategy to handle missing values. Options are \'mean\' for imputation and \'drop\' for removing rows. Returns: pd.DataFrame: The preprocessed dataset with missing values handled and feature normalized. if strategy not in [\'mean\', \'drop\']: raise ValueError(\\"Invalid strategy; use \'mean\' or \'drop\'\\") # Handle missing values if strategy == \'mean\': data[\'feature\'].fillna(data[\'feature\'].mean(), inplace=True) elif strategy == \'drop\': data.dropna(inplace=True) # Normalize the feature data[\'feature\'] = (data[\'feature\'] - data[\'feature\'].mean()) / data[\'feature\'].std() return data class LinearRegression: def __init__(self): self.intercept = 0 self.coefficient = 0 def fit(self, X, y): Train the linear regression model by finding the optimal parameters. Parameters: X (np.ndarray): Feature values. y (np.ndarray): Target values. if len(X) != len(y): raise ValueError(\\"X and y must have the same length\\") # Adding a column of ones to include the intercept in the regression model X_b = np.c_[np.ones((X.shape[0], 1)), X] # Compute the optimal parameters using the normal equation theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y) self.intercept = theta_best[0] self.coefficient = theta_best[1:] def predict(self, X_new): Predict the target variable using the trained linear regression model. Parameters: X_new (np.ndarray): New feature values for prediction. Returns: np.ndarray: The predicted target values. return X_new.dot(self.coefficient) + self.intercept"},{"question":"# **Coding Assessment Question** **Vector Norms and Similarity Measures** In this task, you will implement and test additional functionalities for the `Vector` class. The objective is to demonstrate your understanding of vector properties and operations by completing the methods as specified below. **Task** 1. **L2 Norm Method**: Implement a method `l2_norm` to return the Euclidean (L2) norm of the vector. ```python def l2_norm(self) -> float: Return the Euclidean (L2) norm of the vector. >>> Vector([3, 4]).l2_norm() 5.0 >>> Vector([1, 2, 2]).l2_norm() 3.0 >>> Vector([0]).l2_norm() 0.0 >>> Vector([]).l2_norm() Traceback (most recent call last): ... ValueError: L2 norm requires a non-empty vector # Implement the method here ``` 2. **Dot Product Method**: Implement a method `dot_product` to return the dot product of the vector with another vector. ```python def dot_product(self, other: Vector) -> float: Return the dot product of the self vector and another vector. >>> Vector([1, 2]).dot_product(Vector([3, 4])) 11 >>> Vector([1, 1, 1]).dot_product(Vector([2, 2, 2])) 6 >>> Vector([1]).dot_product(Vector([4])) 4 >>> Vector([1, 2]).dot_product(Vector([3, 4, 5])) Traceback (most recent call last): ... ValueError: Dot product requires vectors of the same length # Implement the method here ``` 3. **Cosine Similarity Method**: Implement a method `cosine_similarity` to return the cosine similarity between the vector and another vector. ```python def cosine_similarity(self, other: Vector) -> float: Return the cosine similarity between the self vector and another vector. >>> Vector([1, 0, 0]).cosine_similarity(Vector([1, 0, 0])) 1.0 >>> Vector([1, 0, 0]).cosine_similarity(Vector([0, 1, 0])) 0.0 >>> Vector([1, 1, 0]).cosine_similarity(Vector([1, -1, 0])) 0.0 >>> Vector([]).cosine_similarity(Vector([])) Traceback (most recent call last): ... ValueError: Cosine similarity requires non-empty vectors # Implement the method here ``` **Function Signature** ```python class Vector: # Existing methods def l2_norm(self) -> float: # Implement here pass def dot_product(self, other: Vector) -> float: # Implement here pass def cosine_similarity(self, other: Vector) -> float: # Implement here pass ``` **Input and Output Formats** * The `l2_norm` method should return a float representing the Euclidean (L2) norm of the vector or raise a `ValueError` if the vector is empty. * The `dot_product` method should return a float representing the dot product of the two vectors or raise a `ValueError` if the vectors are of different lengths. * The `cosine_similarity` method should return a float representing the cosine similarity between the two vectors or raise a `ValueError` if the vectors are empty. **Constraints/Limitations** * Vectors can have zero or more elements. * All entries of vectors in operations are integers or floats. * Ensure handling of exceptions and invalid inputs appropriately.","solution":"import math from typing import List class Vector: def __init__(self, values: List[float]): self.values = values def l2_norm(self) -> float: if not self.values: raise ValueError(\\"L2 norm requires a non-empty vector\\") return math.sqrt(sum(x ** 2 for x in self.values)) def dot_product(self, other: \'Vector\') -> float: if len(self.values) != len(other.values): raise ValueError(\\"Dot product requires vectors of the same length\\") return sum(x * y for x, y in zip(self.values, other.values)) def cosine_similarity(self, other: \'Vector\') -> float: if not self.values or not other.values: raise ValueError(\\"Cosine similarity requires non-empty vectors\\") dot_prod = self.dot_product(other) norm_self = self.l2_norm() norm_other = other.l2_norm() if norm_self == 0 or norm_other == 0: raise ValueError(\\"Cosine similarity cannot be computed if either vector\'s norm is zero\\") return dot_prod / (norm_self * norm_other)"},{"question":"# Question Scenario As part of a data pipeline, you need to preprocess raw textual data by tokenizing sentences. Tokenization involves splitting a sentence into individual words, while removing any leading or trailing punctuation. Task Implement a function that tokenizes a given sentence. Write a function that takes a sentence string and returns a list of words. Words should be split by spaces, and any leading or trailing punctuation should be removed. Function Signature ```python def tokenize(sentence: str) -> List[str]: ``` Input - `sentence` (str): A string containing a sentence, which may include punctuation marks. Output - `List[str]`: A list of words with leading or trailing punctuation removed. Constraints - The length of the input sentence will be between 1 and (10^5) characters. Examples ```python >>> tokenize(\\"Hello, world! This is a test.\\") [\'Hello\', \'world\', \'This\', \'is\', \'a\', \'test\'] >>> tokenize(\\"High-quality, efficient code!\\") [\'High-quality\', \'efficient\', \'code\'] >>> tokenize(\\"Let\'s, tokenize: this sentence correctly.\\") [\'Let\'s\', \'tokenize\', \'this\', \'sentence\', \'correctly\'] ``` Additional Notes - Punctuation includes: `. , ! ? : ; \' \\"` - Do not remove internal punctuation (e.g., don\'t split \\"high-quality\\" into \\"high\\" and \\"quality\\"). - You may assume all inputs are valid and no input validation is required.","solution":"from typing import List import re def tokenize(sentence: str) -> List[str]: Tokenizes a given sentence into words, removing leading or trailing punctuation. # Define a regex pattern to match words, including internal punctuation pattern = r\'bw[w\'-]*w?b\' # Find all words using the regex pattern words = re.findall(pattern, sentence) return words"},{"question":"# Problem Statement: Write a function to simulate a variation of the classic \\"Rock, Paper, Scissors\\" game called \\"Rock, Paper, Scissors, Lizard, Spock,\\" which adds two new moves: \\"Lizard\\" and \\"Spock.\\" In this game, the rules for winning are as follows: - Rock crushes Scissors - Scissors cuts Paper - Paper covers Rock - Rock crushes Lizard - Lizard poisons Spock - Spock smashes Scissors - Scissors decapitates Lizard - Lizard eats Paper - Paper disproves Spock - Spock vaporizes Rock # Requirements: 1. Implement the function `rpsls(player1: str, player2: str) -> str` that determines the outcome of a game between two players. 2. The function should: - Take two string inputs, `player1` and `player2`, representing the moves of two players. The possible moves are \\"Rock\\", \\"Paper\\", \\"Scissors\\", \\"Lizard\\", or \\"Spock\\". - Return a string indicating the result of the game: - \\"Player 1 wins\\" if player1\'s move wins against player2\'s move. - \\"Player 2 wins\\" if player2\'s move wins against player1\'s move. - \\"Tie\\" if both players choose the same move. # Input: - Two string values, each representing the move of a player. The possible values are \\"Rock\\", \\"Paper\\", \\"Scissors\\", \\"Lizard\\", \\"Spock\\". # Output: - A string indicating the result of the game: - \\"Player 1 wins\\" - \\"Player 2 wins\\" - \\"Tie\\" # Constraints: - The inputs will always be one of the valid move strings: \\"Rock\\", \\"Paper\\", \\"Scissors\\", \\"Lizard\\", \\"Spock\\". # Example: ```plaintext rpsls(\\"Rock\\", \\"Scissors\\") Expected Output: \\"Player 1 wins\\" rpsls(\\"Lizard\\", \\"Spock\\") Expected Output: \\"Player 1 wins\\" rpsls(\\"Paper\\", \\"Paper\\") Expected Output: \\"Tie\\" rpsls(\\"Spock\\", \\"Rock\\") Expected Output: \\"Player 1 wins\\" rpsls(\\"Scissors\\", \\"Lizard\\") Expected Output: \\"Player 1 wins\\" rpsls(\\"Scissors\\", \\"Spock\\") Expected Output: \\"Player 2 wins\\" ``` # Notes: - The function should handle all valid inputs and correctly determine the winner according to the specified rules. - Ensure the function has minimal complexity and checks for all possible winning and tie scenarios. - Consider using a dictionary to map winning configurations for easy lookup and comparison.","solution":"def rpsls(player1: str, player2: str) -> str: Determines the outcome of the game \\"Rock, Paper, Scissors, Lizard, Spock\\" between two players. Parameters: player1 (str): The move of player 1. player2 (str): The move of player 2. Returns: str: The result of the game, which can be \\"Player 1 wins\\", \\"Player 2 wins\\", or \\"Tie\\". winning_combinations = { \'Rock\': [\'Scissors\', \'Lizard\'], \'Paper\': [\'Rock\', \'Spock\'], \'Scissors\': [\'Paper\', \'Lizard\'], \'Lizard\': [\'Spock\', \'Paper\'], \'Spock\': [\'Scissors\', \'Rock\'] } if player1 == player2: return \\"Tie\\" elif player2 in winning_combinations[player1]: return \\"Player 1 wins\\" else: return \\"Player 2 wins\\""},{"question":"Write a function `is_valid_graph_coloring(graph: Dict[int, List[int]], coloring: Dict[int, int]) -> bool` that determines whether a given coloring of a graph is valid. Each node in the graph must be assigned a color such that no two adjacent nodes share the same color. # Function Signature ```python def is_valid_graph_coloring(graph: Dict[int, List[int]], coloring: Dict[int, int]) -> bool: ``` # Input * `graph` (Dict[int, List[int]]): A dictionary where keys represent nodes and values are lists of adjacent nodes, representing an undirected graph. * `coloring` (Dict[int, int]): A dictionary where keys are nodes and values are colors represented by integers. # Output * A boolean value indicating whether the given coloring is a valid graph coloring. # Constraints * The graph will have between 1 and 100 nodes. * Each list of adjacent nodes will contain between 0 and 99 nodes. * The `coloring` dictionary will contain colors for all nodes in the graph. # Examples ```python >>> graph = { 1: [2, 3], 2: [1, 3], 3: [1, 2, 4], 4: [3] } >>> coloring = { 1: 1, 2: 2, 3: 3, 4: 1 } >>> is_valid_graph_coloring(graph, coloring) True >>> graph = { 1: [2, 3], 2: [1, 3], 3: [1, 2, 4], 4: [3] } >>> coloring = { 1: 1, 2: 1, 3: 2, 4: 1 } >>> is_valid_graph_coloring(graph, coloring) False >>> graph = { 1: [], 2: [3], 3: [2] } >>> coloring = { 1: 1, 2: 1, 3: 2 } >>> is_valid_graph_coloring(graph, coloring) True >>> graph = { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3] } >>> coloring = { 1: 1, 2: 1, 3: 2, 4: 2 } >>> is_valid_graph_coloring(graph, coloring) False ``` # Notes * Ensure that the function checks every edge in the graph to confirm that the nodes on either end of each edge are colored differently. * The function should handle graphs of varying sizes and degrees of connectivity efficiently.","solution":"def is_valid_graph_coloring(graph, coloring): Determines if the given coloring of the graph is valid. Parameters: - graph (Dict[int, List[int]]): A dictionary representing the graph - coloring (Dict[int, int]): A dictionary representing the coloring of the graph Returns: - bool: True if the coloring is valid, False otherwise for node in graph: for neighbor in graph[node]: if coloring[node] == coloring.get(neighbor, coloring[node]): return False return True"},{"question":"# Customer Churn Prediction using Random Forest As a data scientist at a telecommunications company, you are provided with customer data containing multiple attributes. Your task is to predict customer churn using the Random Forest classifier. Predicting churn helps the company retain customers by understanding the reasons for leaving. # Problem Statement Given a dataset `churn_data.csv` which contains customer data with various features, write a Python function `predict_churn` that: 1. Loads and preprocesses the data. 2. Splits the data into training and testing sets. 3. Trains a Random Forest classifier using the training set. 4. Evaluates the model on the test set and returns the accuracy. The dataset is a CSV file containing various customer attributes, and the last column (`churn`) represents whether the customer churned (1) or not (0). You should: - Handle missing values if any. - Encode categorical features using OneHotEncoder or similar methods. - Scale numerical features using StandardScaler. - Split the data into training and testing sets. - Train a Random Forest classifier and evaluate its performance. # Function Signature ```python def predict_churn(file_path: str, test_size: float, random_state: int, n_estimators: int, max_depth: int) -> float: Trains a Random Forest classifier on customer data to predict churn and evaluates its accuracy. Args: - file_path (str): Path to the CSV file containing customer data. - test_size (float): Proportion of the dataset to include in the test split. - random_state (int): Random seed for reproducibility. - n_estimators (int): Number of trees in the forest. - max_depth (int): Maximum depth of the trees. Returns: - float: Accuracy of the model on the test set. pass ``` # Input - `file_path` : A string representing the path to the CSV file with customer data. - `test_size` : A float representing the proportion of the dataset to include in the test split. - `random_state` : An integer representing the random seed for reproducibility. - `n_estimators` : An integer representing the number of trees in the forest. - `max_depth` : An integer representing the maximum depth of the trees. # Output - A float representing the accuracy of the model on the test set. # Constraints - The target column `churn` contains binary values (0 or 1). - The dataset contains at least 100 rows. - `test_size` is between 0.1 and 0.5. - `n_estimators` and `max_depth` are positive integers. # Example Usage ```python # Example usage: accuracy = predict_churn(\\"churn_data.csv\\", 0.3, 42, 100, 10) print(f\\"Model Accuracy: {accuracy}\\") ``` Implement the function `predict_churn` to solve the given problem. Make sure to handle the preprocessing, encoding, scaling, model training, and evaluation properly within the function.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.preprocessing import OneHotEncoder, StandardScaler from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.metrics import accuracy_score def predict_churn(file_path: str, test_size: float, random_state: int, n_estimators: int, max_depth: int) -> float: # Load the dataset data = pd.read_csv(file_path) # Separate features and target X = data.drop(columns=[\\"churn\\"]) y = data[\\"churn\\"] # Identify numerical and categorical columns numerical_cols = X.select_dtypes(include=[\\"int64\\", \\"float64\\"]).columns categorical_cols = X.select_dtypes(include=[\\"object\\"]).columns # Preprocessing for numerical data numerical_transformer = Pipeline(steps=[ (\\"imputer\\", SimpleImputer(strategy=\\"median\\")), (\\"scaler\\", StandardScaler()) ]) # Preprocessing for categorical data categorical_transformer = Pipeline(steps=[ (\\"imputer\\", SimpleImputer(strategy=\\"most_frequent\\")), (\\"onehot\\", OneHotEncoder(handle_unknown=\\"ignore\\")) ]) # Bundle preprocessing for numerical and categorical data preprocessor = ColumnTransformer( transformers=[ (\\"num\\", numerical_transformer, numerical_cols), (\\"cat\\", categorical_transformer, categorical_cols) ] ) # Create the random forest model model = RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth, random_state=random_state) # Create a pipeline that first preprocesses the data, then trains the model clf = Pipeline(steps=[ (\\"preprocessor\\", preprocessor), (\\"classifier\\", model) ]) # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state) # Train the model clf.fit(X_train, y_train) # Predict on the test set y_pred = clf.predict(X_test) # Evaluate the model accuracy accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"# Scenario: You are working on a text searching application. One of the features requires you to find whether a given pattern exists within a string. You have decided to use the Rabin-Karp algorithm for efficient search. # Task: Write a function `rabin_karp_search` that takes two strings, `text` and `pattern`, and returns a boolean indicating whether the pattern is found within the text. # Expected Function: ```python def rabin_karp_search(text: str, pattern: str) -> bool: ``` # Input Format: * A string `text` of length `n` where `0 <= n <= 10^5`. * A string `pattern` of length `m` where `0 <= m <= 10^5`. # Output Format: * A boolean value: `True` if the pattern is found within the text, `False` otherwise. # Constraints: * The algorithm should have a best-case time complexity of O(n + m). * Avoid unnecessary recomputation by using an efficient hashing mechanism. # Example: ```python >>> rabin_karp_search(\\"hello world\\", \\"world\\") True >>> rabin_karp_search(\\"data structures\\", \\"algorithm\\") False >>> rabin_karp_search(\\"abracadabra\\", \\"cad\\") True ``` # Notes: 1. Handle edge cases such as empty strings for both text and pattern. 2. Ensure that your implementation is efficient and correct for large inputs.","solution":"def rabin_karp_search(text: str, pattern: str) -> bool: Returns True if the pattern is found within the text using the Rabin-Karp algorithm; otherwise False. if not text or not pattern: return False n = len(text) m = len(pattern) if m > n: return False base = 256 prime = 101 def hash_value(s, end, base, prime): h = 0 for i in range(end): h = (h * base + ord(s[i])) % prime return h def recalculate_hash(old_hash, old_char, new_char, base, prime, h_base): new_hash = (old_hash - ord(old_char) * h_base) * base + ord(new_char) new_hash %= prime return new_hash h_pattern = hash_value(pattern, m, base, prime) h_text = hash_value(text, m, base, prime) h_base = pow(base, m - 1, prime) for i in range(n - m + 1): if h_pattern == h_text: if text[i:i+m] == pattern: return True if i < n - m: h_text = recalculate_hash(h_text, text[i], text[i + m], base, prime, h_base) return False"},{"question":"# Maximum Subarray Sum with K Elements Context You need to find the maximum sum of any subarray of exactly ( k ) consecutive elements within a given list of integers. This problem tests your ability to handle sliding window algorithms efficiently. Task Write a function `max_subarray_sum_k(input_list: list, k: int) -> int` that finds the maximum sum of any subarray containing exactly ( k ) elements. Function Signature ```python def max_subarray_sum_k(input_list: list, k: int) -> int: pass ``` Input - `input_list`: List of integers where ( 0 leq text{len}(input_list) leq 10^6 ). - `k`: An integer ( 1 leq k leq text{len}(input_list) ). Output - Returns an integer, the maximum sum of any subarray containing exactly ( k ) elements. Constraints - List can contain both positive and negative integers. - The function should be efficient enough to handle the upper constraint on list length. Example ```python assert max_subarray_sum_k([2, 1, 5, 1, 3, 2], 3) == 9 # Subarray [5, 1, 3] has the maximum sum of 9. assert max_subarray_sum_k([4, -1, 2, 1, -5, 4], 4) == 6 # Subarray [4, -1, 2, 1] has the maximum sum of 6. assert max_subarray_sum_k([1, 2, 3, 4, 5], 2) == 9 # Subarray [4, 5] has the maximum sum of 9. assert max_subarray_sum_k([-2, -3, -4], 2) == -5 # Subarray [-2, -3] has the maximum sum of -5. ``` Requirements - Implement an efficient approach to handle large input sizes using the sliding window technique. - The function should handle typical edge cases like completely negative lists, and lists smaller or equal in length to ( k ). This question integrates sliding window techniques to find the maximum subarray sum for a given length, which complements the complexity and topic of the provided sample questions.","solution":"def max_subarray_sum_k(input_list, k): if len(input_list) == 0 or k <= 0: return 0 # Initialize the window sum with the sum of the first \'k\' elements max_sum = current_sum = sum(input_list[:k]) # Slide the window over the array, updating the window sum at each step for i in range(k, len(input_list)): current_sum += input_list[i] - input_list[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement You are given a list of integers `nums` and an integer `target`. Write a function `find_two_numbers(nums: List[int], target: int) -> Tuple[int, int]` that finds and returns a pair of integers from the list that add up to the given target. If no pair is found, return a tuple containing two `-1`s. # Requirements * **Input**: - `nums` (1 <= len(nums) <= 10^5): A list of integers. - `target` (1 <= target <= 10^9): An integer representing the target sum. * **Output**: - A tuple containing two integers from `nums` that add up to `target`, or `(-1, -1)` if no such pair exists. # Function Signature ```python def find_two_numbers(nums: List[int], target: int) -> Tuple[int, int]: ``` # Examples *Example 1*: ```python print(find_two_numbers([2, 7, 11, 15], 9)) # Output: (2, 7) or (7, 2) ``` *Example 2*: ```python print(find_two_numbers([3, 2, 4], 6)) # Output: (2, 4) or (4, 2) ``` *Example 3*: ```python print(find_two_numbers([3, 3], 6)) # Output: (3, 3) ``` *Example 4*: ```python print(find_two_numbers([1, 2, 3, 4, 5], 10)) # Output: (-1, -1) ``` # Constraints 1. Each input list will have only one unique pair summing up to the target, if a pair exists. 2. The function should handle large input sizes efficiently. # Hint Consider using a hashmap to store the differences needed to reach the target from each element as you iterate through the list.","solution":"from typing import List, Tuple def find_two_numbers(nums: List[int], target: int) -> Tuple[int, int]: Finds two numbers in `nums` that add up to the `target`. Returns a tuple of these two numbers or (-1, -1) if no such pair exists. num_map = {} for num in nums: complement = target - num if complement in num_map: return (complement, num) num_map[num] = True return (-1, -1)"},{"question":"# Knapsack Problem Context The Knapsack problem is a classic combinatorial optimization problem. It derives its name from the problem faced by someone looking to fill a knapsack with the most valuable items without exceeding the weight capacity. This is useful in many fields, such as resource allocation and logistics. Task Write a function `knapsack(capacity: int, weights: list[int], values: list[int]) -> int` that computes the maximum total value that can be obtained by selecting items without exceeding the provided capacity. Each item can be chosen only once. Input/Output Formats * **Input**: - An integer `capacity`, representing the maximum weight that the knapsack can hold. - A list of integers `weights`, where each integer represents the weight of an item. - A list of integers `values`, where each integer represents the value of an item. * Example: `capacity = 50`, `weights = [10, 20, 30]`, `values = [60, 100, 120]` * **Output**: - An integer representing the maximum total value that can be carried in the knapsack without exceeding the capacity. * Example: `220` Constraints * `1 <= capacity <= 10^3` * `1 <= len(weights) == len(values) <= 100` * `1 <= weights[i] <= 100` * `1 <= values[i] <= 1000` Performance Requirements * The function should efficiently handle edge cases and typical scenarios, maintaining a time complexity of O(n * capacity), where n is the number of items. Example Code ```python def knapsack(capacity: int, weights: list[int], values: list[int]) -> int: n = len(weights) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity] # Test Cases print(knapsack(50, [10, 20, 30], [60, 100, 120])) # Output: 220 print(knapsack(60, [1, 2, 3, 4, 5], [10, 20, 30, 40, 50])) # Output: 150 print(knapsack(8, [5, 4, 6, 3], [10, 40, 30, 50])) # Output: 90 ``` Note * Ensure the function handles edge cases such as no items or a capacity of zero. * Assume that the input weights and values are always valid and within the given constraints.","solution":"def knapsack(capacity: int, weights: list[int], values: list[int]) -> int: n = len(weights) dp = [0] * (capacity + 1) for i in range(n): for w in range(capacity, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[capacity]"},{"question":"# Product Discount Calculation You are tasked with implementing a `Product` class that represents a product in an online shop. The class should handle calculating the product\'s price after applying a discount, either as a percentage or a fixed amount. Function Signature ```python class Product: def __init__(self, name: str, price: float): pass def apply_percentage_discount(self, discount: float) -> None: pass def apply_fixed_discount(self, discount: float) -> None: pass def get_final_price(self) -> float: pass ``` Task: 1. **Initialization (Constructor)**: Initialize the product by taking a name and a price. - `name` (string): The name of the product. - `price` (float): The original price of the product. 2. **Discount Methods**: Implement methods to apply discounts to the product. - `apply_percentage_discount`: Applies a given percentage discount to the product\'s price. - `apply_fixed_discount`: Applies a fixed amount discount to the product\'s price. 3. **Price Retrieval Method**: Implement `get_final_price` method to return the product\'s final price after discounts. Input: - `name` (string): The product\'s name. - `price` (float): The original price of the product. - `discount` (float): Percentage discount (e.g., `10` for 10%) or fixed discount amount (e.g., `5` for 5 off). Output: - A class that accurately computes the final price after the discounts are applied. Constraints: - Discounts will be non-negative. - The final price should never drop below zero. - The percentage discount will be given as a value between 0 and 100. # Example ```python product = Product(\\"Laptop\\", 1000.0) product.apply_percentage_discount(10) # 10% of 1000.0 is 100.0, so price becomes 900.0 product.apply_fixed_discount(50) # Fixed discount of 50, so price becomes 850.0 assert product.get_final_price() == 850.0 product2 = Product(\\"Headphones\\", 150.0) product2.apply_fixed_discount(25) # Fixed discount of 25, so price becomes 125.0 product2.apply_percentage_discount(20) # 20% of 125.0 is 25.0, so price becomes 100.0 assert product2.get_final_price() == 100.0 ``` Your implementation should accurately compute the final price after applying the discounts, ensuring that the final price does not go below zero even if high discounts are applied.","solution":"class Product: def __init__(self, name: str, price: float): self.name = name self.price = price self.final_price = price def apply_percentage_discount(self, discount: float) -> None: discount_amount = (self.final_price * discount) / 100 self.final_price = max(0, self.final_price - discount_amount) def apply_fixed_discount(self, discount: float) -> None: self.final_price = max(0, self.final_price - discount) def get_final_price(self) -> float: return self.final_price"},{"question":"# Question: Palindrome Partitioning Count You are tasked with implementing a function that counts the number of ways to partition a given non-empty string into substrings such that every substring is a palindrome. Your function should utilize both a dynamic programming approach and a recursive approach with memoization to ensure efficiency. A palindrome is defined as a string that reads the same forward and backward. For example, `\\"madam\\"` and `\\"racecar\\"` are palindromes, whereas `\\"hello\\"` is not. Your functions should handle edge cases and input validation appropriately. **Function Signature**: ```python def count_palindrome_partitions_dp(s: str) -> int: pass def count_palindrome_partitions_recursive(s: str) -> int: pass ``` # Input - `s` (string): A non-empty string that needs to be partitioned into palindromic substrings. # Output - Returns the count of different ways to partition the string such that each substring is a palindrome. # Constraints - The function should only accept non-empty string inputs. - Should handle edge cases such as invalid data types by raising `ValueError`. - Use appropriate error messages mentioned in the given snippets. # Examples ```python assert count_palindrome_partitions_dp(\\"aab\\") == 2 assert count_palindrome_partitions_dp(\\"racecar\\") == 1 assert count_palindrome_partitions_dp(\\"aaa\\") == 4 assert count_palindrome_partitions_recursive(\\"aab\\") == 2 assert count_palindrome_partitions_recursive(\\"racecar\\") == 1 assert count_palindrome_partitions_recursive(\\"aaa\\") == 4 try: count_palindrome_partitions_dp(\\"\\") except ValueError as e: assert str(e) == \\"count_palindrome_partitions_dp() only accepts non-empty strings\\" try: count_palindrome_partitions_recursive(\\"\\") except ValueError as e: assert str(e) == \\"count_palindrome_partitions_recursive() only accepts non-empty strings\\" try: count_palindrome_partitions_dp(123) except ValueError as e: assert str(e) == \\"count_palindrome_partitions_dp() expects a string input\\" try: count_palindrome_partitions_recursive(123) except ValueError as e: assert str(e) == \\"count_palindrome_partitions_recursive() expects a string input\\" ```","solution":"def count_palindrome_partitions_dp(s: str) -> int: if not isinstance(s, str): raise ValueError(\\"count_palindrome_partitions_dp() expects a string input\\") if not s: raise ValueError(\\"count_palindrome_partitions_dp() only accepts non-empty strings\\") n = len(s) dp = [[False] * n for _ in range(n)] partitions = [0] * (n + 1) for i in range(n - 1, -1, -1): partitions[i] = float(\'inf\') for j in range(i, n): if s[i] == s[j] and (j - i < 3 or dp[i + 1][j - 1]): dp[i][j] = True partitions[i] = min(partitions[i], partitions[j + 1] + 1) return partitions[0] def count_palindrome_partitions_recursive(s: str) -> int: if not isinstance(s, str): raise ValueError(\\"count_palindrome_partitions_recursive() expects a string input\\") if not s: raise ValueError(\\"count_palindrome_partitions_recursive() only accepts non-empty strings\\") def is_palindrome(x): return x == x[::-1] memo = {} def dfs(start): if start == len(s): return 0 if start in memo: return memo[start] min_parts = float(\'inf\') for end in range(start, len(s)): if is_palindrome(s[start:end+1]): min_parts = min(min_parts, 1 + dfs(end + 1)) memo[start] = min_parts return min_parts return dfs(0)"},{"question":"# Coding Assessment Question: String Transformation Operations You are tasked with implementing two essential string transformation functions: reversing the words in a string and checking if a given string is a palindrome. - **Function 1: `reverse_words(input_str: str) -> str`** - **Description**: Reverse the words in the input string, maintaining the original order of characters within each word. - **Input**: A single string. - **Output**: A string with the words in reversed order. - **Constraints**: - The input must be a non-empty string. - **Edge Cases**: - Handle multiple spaces between words by preserving one space while reversing. - Raise a `ValueError` for non-string inputs or empty strings. - **Function 2: `is_palindrome(input_str: str) -> bool`** - **Description**: Check if the input string is a palindrome. Ignore non-alphanumeric characters and case differences. - **Input**: A single string. - **Output**: A boolean indicating if the string is a palindrome. - **Constraints**: - Input must be a valid string. - **Edge Cases**: - Raise a `ValueError` for non-string inputs. - Consider empty strings as palindromes and return `True`. Example: ```python # Example Function Call: print(reverse_words(\\"Hello world\\")) # Output: \\"world Hello\\" print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Output: True # Example Invalid Call: print(reverse_words(12345)) # Output: Raises ValueError # Empty string example: print(is_palindrome(\\"\\")) # Output: True ``` Performance Requirement: - The `reverse_words` function should operate in linear time, O(n), where n is the length of the input string. - The `is_palindrome` function should also operate in linear time, O(n), where n is the length of the input string. **Notes**: - You can assume the input string will have fewer than 10^5 characters. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"def reverse_words(input_str: str) -> str: Reverse the words in the input string, maintaining the original order of characters within each word. Preserves one space between words and raises ValueError for non-string or empty string inputs. if not isinstance(input_str, str) or input_str == \\"\\": raise ValueError(\\"Input must be a non-empty string.\\") words = input_str.split() reversed_words = \' \'.join(reversed(words)) return reversed_words def is_palindrome(input_str: str) -> bool: Check if the input string is a palindrome, ignoring non-alphanumeric characters and case differences. Consider empty strings as palindromes. Raises ValueError for non-string inputs. if not isinstance(input_str, str): raise ValueError(\\"Input must be a string.\\") # Normalize the input string filtered_str = \'\'.join(char.lower() for char in input_str if char.isalnum()) return filtered_str == filtered_str[::-1]"},{"question":"# Coding Assessment Question Scenario You are given two non-negative integers `X` and `Y`, representing the dimensions of a grid. Starting from the top-left corner of the grid (0, 0), you can move either one step right or one step down at a time. Your task is to determine how many unique paths exist to reach the bottom-right corner of the grid (X, Y). Task Implement a function `unique_paths` that computes the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (X, Y). # Function Signature ```python def unique_paths(X: int, Y: int) -> int: pass ``` # Input * `X`: An integer (0 <= X <= 100) * `Y`: An integer (0 <= Y <= 100) # Output * Returns an integer indicating the number of unique paths to reach (X, Y). # Constraints * You may not use advanced libraries; only standard Python data structures and algorithms are allowed. # Example ```python assert unique_paths(2, 2) == 6 assert unique_paths(0, 0) == 1 assert unique_paths(3, 2) == 10 ``` # Hints * Think about the problem combinatorially. Consider the number of ways to arrange right and down movements in a sequence. * Use dynamic programming to avoid recomputation and reduce time complexity.","solution":"def unique_paths(X: int, Y: int) -> int: Computes the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (X, Y) of a grid. # Create a 2D table where dp[i][j] represents the number of unique paths to (i, j) dp = [[0] * (Y + 1) for _ in range(X + 1)] # Initialize the starting point dp[0][0] = 1 # Iterate through the grid and fill the dp table for i in range(X + 1): for j in range(Y + 1): if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[X][Y]"},{"question":"# Prime Palindrome Challenge Overview: You are given a positive integer `N`. Your task is to find the smallest prime number greater than or equal to `N` that is also a palindrome. A palindrome is a number that reads the same forward and backward, such as 121 or 797. Function Signature: ```python def smallest_prime_palindrome(N: int) -> int: ``` Input: - `N`: A positive integer. Output: - Returns the smallest prime number that is greater than or equal to `N` and is also a palindrome. Constraints: - You may assume `N` is at most (10^6). Example: ```python input: 31 output: 101 input: 6 output: 7 input: 131 output: 131 ``` Requirements: 1. Write a helper function to check if a number is a palindrome. 2. Write a helper function to check if a number is prime. 3. Implement the function to find the smallest prime palindrome greater than or equal to `N`. 4. Optimize the solution to handle larger values of `N` efficiently. Scenario: A cybersecurity firm needs a method to generate prime palindromic keys for encryption that are greater than or equal to a given threshold. The unique property of the palindromic primes enhances the security and integrity of the cryptographic keys. Your solution must ensure accurate identification of the smallest such prime palindrome quickly, even for large input values.","solution":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. return str(num) == str(num)[::-1] def is_prime(num: int) -> bool: Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_palindrome(N: int) -> int: Finds the smallest prime palindrome greater than or equal to N. while True: if is_palindrome(N) and is_prime(N): return N N += 1"},{"question":"# Problem Statement You have been tasked with creating a function to compute the sum of all elements in a binary tree. The sum of the elements should be efficient, utilizing a suitable traversal algorithm to visit each node. Your task is to implement the function `sum_of_binary_tree(root: Optional[TreeNode]) -> int` which computes the sum of all nodes in the binary tree starting from the given root node. Each node in the tree contains an integer value. # Function Signature ```python def sum_of_binary_tree(root: Optional[TreeNode]) -> int: ``` # Input * `root`: The root of the binary tree, which may be `None` if the tree is empty. # Output * An integer representing the sum of all node values in the tree. # Constraints * The function should handle trees with any structure. * If the tree is empty (i.e., `root` is `None`), the function should return 0. # Examples Example 1 Input: ```python root = TreeNode(1, TreeNode(2), TreeNode(3)) sum_of_binary_tree(root) ``` Output: ```python 6 ``` Example 2 Input: ```python root = None sum_of_binary_tree(root) ``` Output: ```python 0 ``` # Notes 1. You can use Breadth-First Search (BFS) or Depth-First Search (DFS) traversal methods to implement the solution. 2. The definition of the `TreeNode` class is provided below for clarity: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Performance Requirements Your solution should ensure that each node in the tree is only visited once to calculate the sum, which guarantees a time complexity of O(n), where n is the number of nodes in the tree.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_binary_tree(root: Optional[TreeNode]) -> int: if not root: return 0 return root.val + sum_of_binary_tree(root.left) + sum_of_binary_tree(root.right)"},{"question":"# Count Distinct Elements in Every Window of Size K Problem Description You are given an array of integers `arr` and an integer `k`. Your task is to find the count of distinct elements in every window of size `k`. Function Signature ```python def count_distinct_elements_in_window(arr: List[int], k: int) -> List[int]: ``` Input Format - `arr`: A list of integers, where the values range from `-10^6` to `10^6` and the length `n` ranges from 1 to `10^5`. - `k`: An integer representing the size of the sliding window, where `1 <= k <= n`. Output Format - Return a list of integers representing the count of distinct elements in each window of size `k` in the array. Constraints - The function must process the array efficiently to handle large input sizes. - The function must handle cases where array elements have duplicates within the windows. Example ```python >>> count_distinct_elements_in_window([1, 2, 1, 3, 4, 2, 3], 4) [3, 4, 4, 3] >>> count_distinct_elements_in_window([1, 2, 4, 4], 2) [2, 2, 1] >>> count_distinct_elements_in_window([1, 2, 3], 1) [1, 1, 1] ``` Explanation 1. In the first example, the array is `[1, 2, 1, 3, 4, 2, 3]` with window size `4`. The windows and their distinct counts are: - `[1, 2, 1, 3]` -> 3 distinct elements - `[2, 1, 3, 4]` -> 4 distinct elements - `[1, 3, 4, 2]` -> 4 distinct elements - `[3, 4, 2, 3]` -> 3 distinct elements 2. In the second example, the array is `[1, 2, 4, 4]` with window size `2`. The windows and their distinct counts are: - `[1, 2]` -> 2 distinct elements - `[2, 4]` -> 2 distinct elements - `[4, 4]` -> 1 distinct element 3. In the third example, each element is its own window, thus having exactly 1 distinct element. The new question aligns with the given sample question in terms of complexity, length, and programming concepts, while focusing on a different aspect of array manipulation and using sliding window techniques to count unique elements.","solution":"from typing import List from collections import defaultdict def count_distinct_elements_in_window(arr: List[int], k: int) -> List[int]: Returns a list with the count of distinct elements in every window of size k in the array. if not arr or k <= 0: return [] n = len(arr) if k > n: return [] result = [] window_count = defaultdict(int) distinct_count = 0 # Initialize the first window for i in range(k): if window_count[arr[i]] == 0: distinct_count += 1 window_count[arr[i]] += 1 result.append(distinct_count) # Slide the window from the second element to the end for i in range(k, n): # Remove the first element of the previous window if window_count[arr[i - k]] == 1: distinct_count -= 1 window_count[arr[i - k]] -= 1 # Add the new element of the current window if window_count[arr[i]] == 0: distinct_count += 1 window_count[arr[i]] += 1 result.append(distinct_count) return result"},{"question":"# Problem Statement You are tasked with implementing a function to find the \\"longest\\" word that can be formed by deleting some characters of a given string `s`, and where the word formed must be a subsequence of a list of words `d`. If there are multiple possible results, return the longest word with the smallest lexicographical order. # Function Signature ```python def find_longest_word_in_string(s: str, d: List[str]) -> str: pass ``` # Input and Output * **Input**: * `s` (str): A string of lowercase English letters. * `d` (List[str]): A list of strings containing words composed of lowercase English letters. * **Output**: * Returns a string representing the longest word in dictionary `d` that can be formed by deleting some characters of the string `s`. # Constraints * `0 <= len(s) <= 1000` * `1 <= len(d) <= 1000` * `1 <= len(d[i]) <= 100` # Example ```python >>> find_longest_word_in_string(\\"abpcplea\\", [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"]) \\"apple\\" >>> find_longest_word_in_string(\\"abpcplea\\", [\\"a\\",\\"b\\",\\"c\\"]) \\"a\\" >>> find_longest_word_in_string(\\"\\", [\\"a\\",\\"b\\",\\"c\\"]) \\"\\" >>> find_longest_word_in_string(\\"abpcplea\\", [\\"aloha\\",\\"alps\\",\\"moor\\"]) \\"\\" >>> find_longest_word_in_string(\\"barnacle\\", [\\"barn\\",\\"bar\\",\\"bac\\"]) \\"barn\\" ``` # Performance Requirements * Your solution should be efficient in both time and space, ideally strive to keep the time complexity as close to O(n*m) as possible, where `n` is the length of the string `s` and `m` is the number of words in list `d`. # Context Understanding how to implement and optimize string manipulation to determine subsequences demonstrates strong problem-solving abilities in the context of algorithmic challenges. This question also emphasizes the importance of handling multiple conditions including lexicographical ordering while adhering to performance constraints.","solution":"from typing import List def is_subsequence(x: str, y: str) -> bool: Helper function to check if x is a subsequence of y it = iter(y) return all(c in it for c in x) def find_longest_word_in_string(s: str, d: List[str]) -> str: Returns the longest word in dictionary d that can be formed by deleting some characters of the string s. If there are multiple possible results, returns the longest word with the smallest lexicographical order. longest_word = \\"\\" for word in d: if is_subsequence(word, s): if (len(word) > len(longest_word)) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"# Scenario You have been given the task of building a real-time event scheduler named `EventScheduler`. The purpose of this scheduler is to manage events, allowing for adding, removing, and checking the next upcoming event based on their scheduled start times. # Problem Statement Implement the `EventScheduler` class that efficiently manages scheduled events. Your implementation should support the following methods: - `add_event(event_name: str, start_time: int) -> None`: Add a new event with a given start time. - `remove_event(event_name: str) -> None`: Remove an event by its name. - `next_event() -> str`: Retrieve the name of the event with the nearest start time. - `__str__() -> str`: Return string representation of the events sorted by their start times. # Input and Output Formats add_event - **Input**: event_name (str), start_time (int) - **Output**: None remove_event - **Input**: event_name (str) - **Output**: None next_event - **Output**: event_name (str) __str__ - **Output**: str, representing the events in the format \\"Event Start Time x: [event_names]\\" # Constraints - The start time is given as an integer and represents the number of seconds from the start of the epoch. - Initial default event queue size is unlimited, but it can store up to 5000 events. - Event names are unique strings. # Example ```python scheduler = EventScheduler() scheduler.add_event(\\"EventA\\", 100) scheduler.add_event(\\"EventB\\", 50) scheduler.add_event(\\"EventC\\", 150) print(scheduler) # Event Start Time 50: [\'EventB\'], Event Start Time 100: [\'EventA\'], Event Start Time 150: [\'EventC\'] print(scheduler.next_event()) # \\"EventB\\" scheduler.remove_event(\\"EventB\\") print(scheduler) # Event Start Time 100: [\'EventA\'], Event Start Time 150: [\'EventC\'] print(scheduler.next_event()) # \\"EventA\\" ``` # Performance Requirements - The implementation should efficiently handle adding and removing events, aiming for O(log n) performance on these operations if possible.","solution":"import heapq class EventScheduler: def __init__(self): self.events = [] # This will be a min-heap self.event_map = {} # This keeps track of events by their names def add_event(self, event_name: str, start_time: int) -> None: if event_name in self.event_map: self.remove_event(event_name) entry = [start_time, event_name] heapq.heappush(self.events, entry) self.event_map[event_name] = entry def remove_event(self, event_name: str) -> None: if event_name in self.event_map: entry = self.event_map.pop(event_name) entry[-1] = None # Mark as removed def next_event(self) -> str: while self.events: start_time, event_name = heapq.heappop(self.events) if event_name is not None: del self.event_map[event_name] return event_name return None def __str__(self) -> str: return \', \'.join(f\\"Event Start Time {start_time}: [\'{event_name}\']\\" for start_time, event_name in sorted((e for e in self.events if e[1] is not None))) # Example usage: # scheduler = EventScheduler() # scheduler.add_event(\\"EventA\\", 100) # scheduler.add_event(\\"EventB\\", 50) # scheduler.add_event(\\"EventC\\", 150) # print(scheduler) # Event Start Time 50: [\'EventB\'], Event Start Time 100: [\'EventA\'], Event Start Time 150: [\'EventC\'] # print(scheduler.next_event()) # \\"EventB\\" # scheduler.remove_event(\\"EventB\\") # print(scheduler) # Event Start Time 100: [\'EventA\'], Event Start Time 150: [\'EventC\'] # print(scheduler.next_event()) # \\"EventA\\""},{"question":"# Problem Statement You need to implement a function `normalize_min_max` that normalizes the values in a given numpy array to a specified range [min_val, max_val]. This technique, often called Min-Max Scaling, adjusts the distribution of the array\'s values to the defined range. It is frequently used in data preprocessing to standardize the features in machine learning pipelines. # Function Signature ```python def normalize_min_max( array: np.ndarray, min_val: float = 0.0, max_val: float = 1.0 ) -> np.ndarray: ``` # Input 1. `array` (np.ndarray): A numpy array containing N real numbers. 2. `min_val` (float): The minimum value of the normalized range with a default value of 0.0. 3. `max_val` (float): The maximum value of the normalized range with a default value of 1.0. # Output - Returns a numpy array of the same shape and type as the input array, but with values scaled to the range [min_val, max_val]. # Constraints - The input array can be of any size, including zero. - The min_val and max_val parameters are real numbers. - Ensure that min_val < max_val. # Example ```python # Example 1 array = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) print(normalize_min_max(array)) # Output: array([0.0, 0.25, 0.5, 0.75, 1.0]) # Example 2 array = np.array([-10.0, 0.0, 10.0]) print(normalize_min_max(array, -1, 1)) # Output: array([-1.0, 0.0, 1.0]) ``` # Notes - Ensure your implementation efficiently handles arrays of varying sizes. - The normalization formula for each element x in the array `arr` is defined as: - `x_norm = (x - min(arr)) / (max(arr) - min(arr)) * (max_val - min_val) + min_val` - Handle the case when `min(arr) == max(arr)` by returning an array where all elements are equal to `min_val`. # Edge Cases to Consider - An empty input array. - An array where all values are the same. - Arrays of varying lengths and compositions (negative and positive values). - `min_val` and `max_val` that result in negative ranges or non-standard ranges. # Testing - Include tests to cover typical use cases and edge cases. - Utilize the `doctest` library to verify your solution.","solution":"import numpy as np def normalize_min_max(array: np.ndarray, min_val: float = 0.0, max_val: float = 1.0) -> np.ndarray: Normalizes the values in the given numpy array to the range [min_val, max_val]. Parameters: array (np.ndarray): Array containing N real numbers. min_val (float): Minimum value of the normalized range. max_val (float): Maximum value of the normalized range. Returns: np.ndarray: Array with normalized values. if array.size == 0: # Handle empty array return np.array([]) arr_min = np.min(array) arr_max = np.max(array) if arr_min == arr_max: # Handle case where all values are the same return np.full(array.shape, min_val) normalized_array = (array - arr_min) / (arr_max - arr_min) * (max_val - min_val) + min_val return normalized_array"},{"question":"# Binary Search Tree Implementation with Traversal Methods Problem Statement: You are tasked with implementing a Binary Search Tree (BST) that supports insertion, deletion, search, and various traversal methods. The BST should be able to handle integer values and maintain the properties of a binary search tree. Requirements: 1. **Function Signature**: ```python class TreeNode: def __init__(self, value: int) -> None: class BinarySearchTree: def __init__(self) -> None: def insert(self, value: int) -> None: def delete(self, value: int) -> None: def search(self, value: int) -> bool: def inorder_traversal(self) -> List[int]: def preorder_traversal(self) -> List[int]: def postorder_traversal(self) -> List[int]: def __repr__(self) -> str: ``` 2. **Input and Output Format**: - `TreeNode.__init__(self, value: int)` initializes a tree node with a given integer value. - `BinarySearchTree.__init__(self)` initializes an empty tree. - `insert(self, value: int)`: Inserts a value into the BST while maintaining BST properties. - `delete(self, value: int)`: Deletes a value from the BST while maintaining BST properties. - `search(self, value: int)`: Searches for a value in the BST. Returns `True` if found, else `False`. - `inorder_traversal(self)`: Returns a list of elements in in-order (left-root-right) traversal. - `preorder_traversal(self)`: Returns a list of elements in pre-order (root-left-right) traversal. - `postorder_traversal(self)`: Returns a list of elements in post-order (left-right-root) traversal. - `__repr__(self)`: Returns a string representation of the BST. 3. **Constraints**: - The tree can handle up to 10^4 nodes. - Ensure efficient insertion, deletion, and search operations with average complexity of O(log n). 4. **Performance Requirements**: - The BST should efficiently handle updates and allow for traversal within reasonable time limits. - Implementations should handle all edge cases, including duplication and deletion of non-existent nodes. Example Usage: ```python # Initializing binary search tree bst = BinarySearchTree() # Inserting elements bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # Searching elements print(bst.search(4)) # Output: True print(bst.search(9)) # Output: False # Traversing elements in different orders print(bst.inorder_traversal()) # Output: [2, 3, 4, 5, 6, 7, 8] print(bst.preorder_traversal()) # Output: [5, 3, 2, 4, 7, 6, 8] print(bst.postorder_traversal()) # Output: [2, 4, 3, 6, 8, 7, 5] # Deleting elements bst.delete(7) # Checking tree after deletion print(bst.inorder_traversal()) # Output: [2, 3, 4, 5, 6, 8] # String representation of BST print(bst) # Output: BinarySearchTree(2, 3, 4, 5, 6, 8) ``` Implement the `TreeNode` and `BinarySearchTree` classes to fulfill the above specifications.","solution":"class TreeNode: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node: TreeNode, value: int) -> TreeNode: if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if not node.left: return node.right if not node.right: return node.left temp = self._find_min(node.right) node.value = temp.value node.right = self._delete_recursive(node.right, temp.value) return node def _find_min(self, node: TreeNode) -> TreeNode: while node.left: node = node.left return node def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: TreeNode, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def inorder_traversal(self) -> list[int]: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result) def preorder_traversal(self) -> list[int]: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: result.append(node.value) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder_traversal(self) -> list[int]: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.value) def __repr__(self) -> str: return f\\"BinarySearchTree({\', \'.join(map(str, self.inorder_traversal()))})\\""},{"question":"# Objective Write a function `unique_elements` that takes a list of integers and returns a new list containing only the unique elements from the original list, preserving their original order of first appearance. # Input & Output * **Input**: A list of integers `lst`. * **Output**: A new list of integers containing only the unique elements from `lst`, with the first occurrence of each element kept in their initial order. # Constraints 1. The input list `lst` can have up to `10^5` elements. 2. The integers in `lst` can range between `-10^9` and `10^9`. 3. Optimize the function to be as efficient as possible in terms of time and space complexity. # Example ```python # Example 1 # Input: [4, 5, 6, 7, 8, 5, 6, 7] # Output: [4, 5, 6, 7, 8] # Example 2 # Input: [1, 2, 2, 3, 4, 1, 5] # Output: [1, 2, 3, 4, 5] # Example 3 # Input: [100, 200, 100, 300, 200] # Output: [100, 200, 300] ``` # Scenario Imagine you are developing a feature for a recommendation system where duplicate recommendations must be removed to avoid repetition for users. By implementing the `unique_elements` function, you can ensure that each recommended item is presented only once in the order they were first encountered. # Function Signature ```python def unique_elements(lst: list[int]) -> list[int]: pass ```","solution":"def unique_elements(lst): Returns a list containing only the unique elements of the input list, preserving their original order. seen = set() unique_list = [] for item in lst: if item not in seen: unique_list.append(item) seen.add(item) return unique_list"},{"question":"# Problem Statement You are tasked with implementing a simplified version of a social network\'s friend recommendation system. This system will be based on a mutual friends approach. Specifically, you will: 1. Implement a `SocialNetwork` class to manage users and their connections. 2. Provide methods to: - Add a user to the network. - Add a friendship between two users. - Recommend friends to a user based on the highest number of mutual friends. # Requirements - Design a `SocialNetwork` class with the ability to manage users and their connections. - Implement the following methods in the class: * `add_user` to add a new user to the network. * `add_friendship` to establish a friendship between two users. * `recommend_friends` to recommend friends to a particular user based on mutual friends. # Function Implementation Method Header 1. **Adding a user**: ```python def add_user(self, user: str) -> None: ``` - **user**: The username of the new user. Usernames are unique. 2. **Adding a friendship**: ```python def add_friendship(self, user1: str, user2: str) -> None: ``` - **user1**: The username of the first user. - **user2**: The username of the second user. - This method creates a bidirectional friendship between `user1` and `user2`. 3. **Recommending friends**: ```python def recommend_friends(self, user: str) -> List[Tuple[str, int]]: ``` - **user**: The username for whom the friend recommendations are to be generated. - **returns**: A list of tuples, where each tuple contains a recommended friend\'s username and the number of mutual friends. The list should be sorted by number of mutual friends in descending order. If there is a tie, sort alphabetically by username. # Input and Output Formats - Usernames are strings consisting of alphanumeric characters. - Ensure no duplicate friendships are added. # Constraints - Assume a maximum of 1000 users in the network. - A user can have up to 100 friends. - Friend recommendations should not include users who are already friends. # Example ```python # Example usage of the SocialNetwork class network = SocialNetwork() network.add_user(\\"Alice\\") network.add_user(\\"Bob\\") network.add_user(\\"Charlie\\") network.add_user(\\"David\\") network.add_friendship(\\"Alice\\", \\"Bob\\") network.add_friendship(\\"Alice\\", \\"Charlie\\") network.add_friendship(\\"Bob\\", \\"Charlie\\") network.add_friendship(\\"Charlie\\", \\"David\\") print(network.recommend_friends(\\"Alice\\")) # Expected Output: [(\'David\', 1)] ``` # Notes - In the example provided, since David is not a friend of Alice but has 1 mutual friend (Charlie) with her, he is recommended. - If there are no mutual friends, the recommendation list should be empty for that particular user.","solution":"from typing import List, Tuple, Dict, Set from collections import defaultdict, Counter class SocialNetwork: def __init__(self): self.users = set() self.friendships = defaultdict(set) def add_user(self, user: str) -> None: self.users.add(user) def add_friendship(self, user1: str, user2: str) -> None: if user1 in self.users and user2 in self.users: self.friendships[user1].add(user2) self.friendships[user2].add(user1) def recommend_friends(self, user: str) -> List[Tuple[str, int]]: if user not in self.users: return [] mutual_friends_count = Counter() current_friends = self.friendships[user] for friend in current_friends: for potential_friend in self.friendships[friend]: if potential_friend != user and potential_friend not in current_friends: mutual_friends_count[potential_friend] += 1 recommendations = sorted(mutual_friends_count.items(), key=lambda x: (-x[1], x[0])) return recommendations"},{"question":"# Scenario You are designing an inventory tracking system for a retail company. The system needs to keep track of items and their attributes, such as item ID, name, quantity in stock, and price. One of the key features is the ability to search for items within a certain price range. # Problem Statement Write a program to implement a search function that allows users to find items within a specified price range. The function should return a list of items sorted by their IDs in ascending order. # Function Signature ```python def search_items_in_price_range(items: List[Dict[str, Union[int, str, float]]], price_range: Tuple[float, float]) -> List[Dict[str, Union[int, str, float]]]: pass ``` # Input - `items`: A list of dictionaries, where each dictionary represents an item with the following keys: - `id`: An integer representing the unique ID of the item. - `name`: A string representing the name of the item. - `quantity`: An integer representing the quantity of the item in stock. - `price`: A float representing the price of the item. - `price_range`: A tuple of two floats representing the minimum and maximum price range (inclusive). # Output - A list of dictionaries representing the items that fall within the specified price range, sorted by their IDs in ascending order. # Constraints - `items` will be a non-empty list of dictionaries. - Each dictionary will have exactly the keys `id`, `name`, `quantity`, and `price`. - The price range will be valid with the first value being less than or equal to the second value. # Example ```python items = [ {\\"id\\": 4, \\"name\\": \\"item4\\", \\"quantity\\": 8, \\"price\\": 15.5}, {\\"id\\": 2, \\"name\\": \\"item2\\", \\"quantity\\": 5, \\"price\\": 10.0}, {\\"id\\": 1, \\"name\\": \\"item1\\", \\"quantity\\": 10, \\"price\\": 5.0}, {\\"id\\": 3, \\"name\\": \\"item3\\", \\"quantity\\": 2, \\"price\\": 25.0}, {\\"id\\": 5, \\"name\\": \\"item5\\", \\"quantity\\": 20, \\"price\\": 7.5} ] price_range = (5.0, 15.0) print(search_items_in_price_range(items, price_range)) # Expected Output: [ # {\\"id\\": 1, \\"name\\": \\"item1\\", \\"quantity\\": 10, \\"price\\": 5.0}, # {\\"id\\": 2, \\"name\\": \\"item2\\", \\"quantity\\": 5, \\"price\\": 10.0}, # {\\"id\\": 5, \\"name\\": \\"item5\\", \\"quantity\\": 20, \\"price\\": 7.5} # ] ``` # Notes - Ensure your solution handles edge cases, such as having no items within the specified price range. - Consider efficiency when sorting the items, especially with a large number of items. - The search should be inclusive of the boundary values specified in the price range.","solution":"from typing import List, Dict, Union, Tuple def search_items_in_price_range(items: List[Dict[str, Union[int, str, float]]], price_range: Tuple[float, float]) -> List[Dict[str, Union[int, str, float]]]: Returns a list of items within the specified price range, sorted by item ID in ascending order. Parameters: items (List[Dict[str, Union[int, str, float]]]): List of items with attributes id, name, quantity, and price. price_range (Tuple[float, float]): Tuple containing minimum and maximum price (inclusive). Returns: List[Dict[str, Union[int, str, float]]]: List of items within the specified price range, sorted by id. min_price, max_price = price_range # Filtering the items within the price range filtered_items = [item for item in items if min_price <= item[\'price\'] <= max_price] # Sorting the filtered items by item ID in ascending order sorted_items = sorted(filtered_items, key=lambda item: item[\'id\']) return sorted_items"},{"question":"**Scenario**: A travel agency is analyzing the movement patterns of their customers to optimize their recommendation systems. They need an algorithm to identify the highest earning trip based on the series of bookings made by the customers. # Problem Statement You need to implement a function with the following specifications: # Function Signature ```python def max_earning_trip( trips: list, earnings: dict ) -> int: pass ``` # Input Format 1. **trips (list)**: A list of tuples where each tuple contains two elements, the starting and ending cities (strings) of a trip. 2. **earnings (dict)**: A dictionary where keys are tuples representing a trip (start city, end city) and values are the earnings associated with the trip (integer). # Output Format **Returns (int)**: The maximum possible earnings by selecting one trip from the list. # Constraints - All cities in the trips list are valid strings. - The earnings dictionary has valid tuples as keys and integer values representing the earnings. - The length of the trips list will be at least one. # Examples ```python # Example 1 trips = [(\\"New York\\", \\"Los Angeles\\"), (\\"Chicago\\", \\"Houston\\"), (\\"Dallas\\", \\"New York\\")] earnings = { (\\"New York\\", \\"Los Angeles\\"): 300, (\\"Chicago\\", \\"Houston\\"): 150, (\\"Dallas\\", \\"New York\\"): 200 } assert max_earning_trip(trips, earnings) == 300 # Example 2 trips = [(\\"San Francisco\\", \\"Seattle\\"), (\\"Austin\\", \\"Denver\\"), (\\"Boston\\", \\"Miami\\")] earnings = { (\\"San Francisco\\", \\"Seattle\\"): 180, (\\"Austin\\", \\"Denver\\"): 250, (\\"Boston\\", \\"Miami\\"): 220 } assert max_earning_trip(trips, earnings) == 250 # Example 3 trips = [(\\"Atlanta\\", \\"Orlando\\")] earnings = { (\\"Atlanta\\", \\"Orlando\\"): 120 } assert max_earning_trip(trips, earnings) == 120 ``` You are required to implement the given function according to the above specifications, ensuring to handle all the edge cases and input constraints properly.","solution":"def max_earning_trip(trips, earnings): Returns the maximum possible earnings by selecting one trip. Args: trips (list): A list of tuples where each tuple contains two elements, the starting and ending cities (strings) of a trip. earnings (dict): A dictionary where keys are tuples representing a trip (start city, end city) and values are the earnings associated with the trip (integer). Returns: int: The maximum possible earnings by selecting one trip from the list. max_earning = 0 for trip in trips: if trip in earnings: max_earning = max(max_earning, earnings[trip]) return max_earning"},{"question":"# Question: Sum of Unique Array Elements Background: Develop a function to find the sum of all unique elements in an array. In this context, an element is considered unique if it appears exactly once in the array. This function is crucial in scenarios where unique data points need to be isolated and processed separately, such as in data analysis and reporting. Requirements: 1. Implement a function `sum_of_unique_elements(arr: List[int]) -> int` that calculates the sum of all unique elements in the input array. 2. The function should handle arrays containing integers. 3. Ensure the function performs efficiently even with large arrays. Input: - A list of integers `arr` where each integer `-10^6 <= arr[i] <= 10^6` and `0 <= len(arr) <= 10^5`. Output: - Return an integer representing the sum of all unique elements in the array. Constraints: - The function should handle edge cases, such as an empty array or arrays with no unique elements. Examples: ```python assert sum_of_unique_elements([1, 2, 3, 2, 4, 5]) == 13 # Unique elements are 1, 3, 4, 5 assert sum_of_unique_elements([1, 1, 1, 1]) == 0 # No unique elements assert sum_of_unique_elements([]) == 0 # Empty array assert sum_of_unique_elements([10, 20, 30, 10, 20, 50]) == 80 # Unique elements are 30, 50 ``` Hints: - Consider using a dictionary or a counter to track the occurrences of each element. - Iterate through the array to identify and sum the elements that appear exactly once. - Special care must be taken to handle efficiency given the potential size of the array.","solution":"from typing import List from collections import Counter def sum_of_unique_elements(arr: List[int]) -> int: Calculates the sum of all unique elements in the input array. An element is considered unique if it appears exactly once in the array. # Count the occurrences of each element element_counts = Counter(arr) # Calculate the sum of elements that appear exactly once unique_sum = sum(element for element, count in element_counts.items() if count == 1) return unique_sum"},{"question":"# Question: Collatz Sequence Length The Collatz sequence is a sequence of numbers produced from a starting number ( n ) following three rules: 1. If ( n ) is 1, the sequence ends. 2. If ( n ) is even, the next number is ( n / 2 ). 3. If ( n ) is odd, the next number is ( 3n + 1 ). Write a function `collatz_sequence_length(n: int) -> int` that calculates the length of the Collatz sequence for a given starting number ( n ). **Function Signature**: ```python def collatz_sequence_length(n: int) -> int: ``` **Input**: - `n`: an integer (1 ≤ n ≤ 10^6) **Output**: - the length of the Collatz sequence starting from ( n ). **Constraints**: - The input value of ( n ) will be a positive integer. - The function should be efficient and handle the given range effectively. **Examples**: ```python >>> collatz_sequence_length(1) 1 >>> collatz_sequence_length(6) 9 >>> collatz_sequence_length(19) 21 ``` # Explanation The Collatz sequence is also known as the \\"3n + 1\\" problem. The sequence always reaches the number 1, regardless of which positive integer starts the sequence. The challenge is to compute the number of steps required to reach 1 from ( n ), efficiently handling large values of ( n ) within the given constraints.","solution":"def collatz_sequence_length(n: int) -> int: Calculates the length of the Collatz sequence for a given starting number n. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"Question # Problem Statement: You have been given an array of integers. Your task is to write a function `non_repeating_element(nums: List[int]) -> int` that finds the first non-repeating element in the array and returns it. If all elements are repeating, return `-1`. # Function Signature: ```python def non_repeating_element(nums: List[int]) -> int: pass ``` # Input: - A list of integers `nums` where each integer is in the range `-10^9 <= nums[i] <= 10^9`. - List length will be between `1` and `10^5`. # Output: - An integer representing the first non-repeating element, or `-1` if all elements are repeating. # Constraints: - The function should handle both positive and negative integers. - The function must perform efficiently for large input sizes. # Examples: ```python assert non_repeating_element([4, 5, 1, 2, 0, 4]) == 5 assert non_repeating_element([1, 2, 2, 1, 3, 3]) == -1 assert non_repeating_element([7]) == 7 assert non_repeating_element([3, 3, 5, 5, 1]) == 1 assert non_repeating_element([]) == -1 assert non_repeating_element([10, 20, 30, 20, 10, 40]) == 30 assert non_repeating_element([-1, -1, -2, -3, -2]) == -3 ``` # Additional Instructions: - Ensure the function handles edge cases such as when the array is empty. - Consider using optimal data structures to ensure efficient time complexity. - Make sure to test with both small and large arrays to verify performance.","solution":"from typing import List from collections import Counter def non_repeating_element(nums: List[int]) -> int: Returns the first non-repeating element in the list. If all elements are repeating, returns -1. count = Counter(nums) for num in nums: if count[num] == 1: return num return -1"},{"question":"# Maximum Subarray Sum with Divide and Conquer You are given an array of integers, and you need to find the contiguous subarray with the largest sum. Implement a function that uses the Divide and Conquer approach to achieve this. # Required Function ```python def max_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: Find the contiguous subarray with the largest sum using Divide and Conquer. Args: - arr (List[int]): The input array of integers. Returns: - Tuple (max_sum, start_index, end_index) where: - max_sum (int): The maximum sum of the contiguous subarray. - start_index (int): The starting index of the subarray with the maximum sum. - end_index (int): The ending index (inclusive) of the subarray with the maximum sum. pass ``` # Constraints and Details * The array can contain both positive and negative integers. * The length of the array (`n`) is determined by the number of elements in the array. * Ensure your implementation handles edge cases such as: * Empty array, in which case `max_sum` should be `0`, and both `start_index` and `end_index` should be `-1`. * Array with all negative numbers. * Array with a single element. # Input * The array `arr` of integers. # Output * `max_sum`: The maximum sum of the contiguous subarray. * `start_index`: The starting index of the subarray with the maximum sum. * `end_index`: The ending index (inclusive) of the subarray with the maximum sum. # Example ```python def max_subarray_sum(arr): if not arr: return 0, -1, -1 def find_max_subarray(arr, left, right): if left == right: return arr[left], left, right mid = (left + right) // 2 left_max_sum, left_start, left_end = find_max_subarray(arr, left, mid) right_max_sum, right_start, right_end = find_max_subarray(arr, mid + 1, right) cross_max_sum, cross_start, cross_end = find_max_crossing_sum(arr, left, mid, right) if left_max_sum >= right_max_sum and left_max_sum >= cross_max_sum: return left_max_sum, left_start, left_end elif right_max_sum >= left_max_sum and right_max_sum >= cross_max_sum: return right_max_sum, right_start, right_end else: return cross_max_sum, cross_start, cross_end def find_max_crossing_sum(arr, left, mid, right): left_sum = -float(\'inf\') total = 0 max_left = mid for i in range(mid, left-1, -1): total += arr[i] if total > left_sum: left_sum = total max_left = i right_sum = -float(\'inf\') total = 0 max_right = mid + 1 for i in range(mid + 1, right + 1): total += arr[i] if total > right_sum: right_sum = total max_right = i return left_sum + right_sum, max_left, max_right return find_max_subarray(arr, 0, len(arr) - 1) arr = [-2,1,-3,4,-1,2,1,-5,4] result = max_subarray_sum(arr) # Expected result should be (6, 3, 6), since the maximum subarray sum is [4, -1, 2, 1] which sums to 6 print(result) ``` Implement the `max_subarray_sum` function to complete the task described.","solution":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: if not arr: return 0, -1, -1 def find_max_subarray(arr, left, right): if left == right: return arr[left], left, right mid = (left + right) // 2 left_max_sum, left_start, left_end = find_max_subarray(arr, left, mid) right_max_sum, right_start, right_end = find_max_subarray(arr, mid + 1, right) cross_max_sum, cross_start, cross_end = find_max_crossing_sum(arr, left, mid, right) if left_max_sum >= right_max_sum and left_max_sum >= cross_max_sum: return left_max_sum, left_start, left_end elif right_max_sum >= left_max_sum and right_max_sum >= cross_max_sum: return right_max_sum, right_start, right_end else: return cross_max_sum, cross_start, cross_end def find_max_crossing_sum(arr, left, mid, right): left_sum = -float(\'inf\') total = 0 max_left = mid for i in range(mid, left-1, -1): total += arr[i] if total > left_sum: left_sum = total max_left = i right_sum = -float(\'inf\') total = 0 max_right = mid + 1 for i in range(mid + 1, right + 1): total += arr[i] if total > right_sum: right_sum = total max_right = i return left_sum + right_sum, max_left, max_right return find_max_subarray(arr, 0, len(arr) - 1)"},{"question":"# Problem Statement: You are a software engineer tasked with designing a parking software system for a multi-level parking garage. Each parking spot can accommodate a car of various sizes: small (S), medium (M), or large (L). The idea is to maximize the utilization of parking spots. You need to implement a system that keeps track of available spots and allocates them based on the size of the incoming vehicle and the current occupancy. # Requirements: 1. **Input**: * A list of parking spots, each described by a tuple: (spot_id, size), where `size` is \'S\', \'M\', or \'L\'. * A list of incoming vehicles, each described by a tuple: (vehicle_id, size), where `size` is \'S\', \'M\', or \'L\'. 2. **Output**: * A mapping of vehicle_id to spot_id indicating where each vehicle is parked or `None` if a vehicle cannot be accommodated. * A list of remaining available spots after all vehicles have been processed. # Constraints: * The list of parking spots will have a length between 1 to 1000. * The list of incoming vehicles will have a length between 1 to 1000. * A vehicle can only occupy a spot that is equal to or larger than its size. # Instructions: 1. Implement a `ParkingSpot` class to encapsulate the attributes and behaviors of a parking spot. 2. Create a function `allocate_spots` that takes the list of `ParkingSpot` objects and the list of vehicles, and returns a dictionary of parking allocations and the list of remaining available spots. 3. Write test cases to verify the implementation. # Function Signatures: ```python class ParkingSpot: def __init__(self, spot_id, size): pass def allocate_spots(spots, vehicles): pass ``` # Example: ```python if __name__ == \\"__main__\\": spots = [(\\"spot1\\", \\"S\\"), (\\"spot2\\", \\"M\\"), (\\"spot3\\", \\"L\\"), (\\"spot4\\", \\"S\\"), (\\"spot5\\", \\"L\\")] vehicles = [(\\"vehicle1\\", \\"S\\"), (\\"vehicle2\\", \\"L\\"), (\\"vehicle3\\", \\"M\\"), (\\"vehicle4\\", \\"S\\")] allocations, remaining_spots = allocate_spots(spots, vehicles) print(allocations) # {\'vehicle1\': \'spot1\', \'vehicle2\': \'spot3\', \'vehicle3\': \'spot2\', \'vehicle4\': \'spot4\'} print(remaining_spots) # [(\'spot5\', \'L\')] ```","solution":"class ParkingSpot: def __init__(self, spot_id, size): self.spot_id = spot_id self.size = size self.is_occupied = False def allocate_spots(spots, vehicles): # Initialize the parking spots parking_spots = [ParkingSpot(spot_id, size) for spot_id, size in spots] # Map to hold the allocations allocations = {} # Allocate each vehicle to an appropriate spot for vehicle_id, vehicle_size in vehicles: allocated = False for spot in parking_spots: if not spot.is_occupied: if (vehicle_size == \'S\' and spot.size in [\'S\', \'M\', \'L\']) or (vehicle_size == \'M\' and spot.size in [\'M\', \'L\']) or (vehicle_size == \'L\' and spot.size == \'L\'): allocations[vehicle_id] = spot.spot_id spot.is_occupied = True allocated = True break if not allocated: allocations[vehicle_id] = None # Prepare the list of available spots remaining_spots = [(spot.spot_id, spot.size) for spot in parking_spots if not spot.is_occupied] return allocations, remaining_spots"},{"question":"# Number Frequency in a List You are required to write a function that counts the frequency of each number in a list and then returns a list of tuples sorted by the frequency of numbers in descending order. If two numbers have the same frequency, they should be sorted in ascending order by the number value. Implementation Details: Implement a function `count_frequency(nums: List[int]) -> List[Tuple[int, int]]` with the following specifications: - The function takes a list of integers `nums` as input. - The function returns a list of tuples, where each tuple contains a number and its frequency, sorted by frequency in descending order, and by number in ascending order for ties. Input: - A list `nums` of integers. The length of the list will not exceed 10^5 elements. Output: - A sorted list of tuples. Each tuple contains an integer and its frequency in the input list `nums`. Constraints: - The elements of the input list can be negative, zero, or positive integers. - The length of the list `nums` will be between 0 and 10^5. Example: ```python assert count_frequency([1, 1, 2, 2, 2, 3]) == [(2, 3), (1, 2), (3, 1)] assert count_frequency([4, 4, 1, 2, 2, 3, 3, 3, 3]) == [(3, 4), (4, 2), (2, 2), (1, 1)] assert count_frequency([]) == [] assert count_frequency([1, 2, 3, 4, 5]) == [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] ``` Points to Consider: - Utilize a dictionary or a similar data structure to count the frequency of each number. - Make use of sorting functions with custom comparators to achieve the required sorting order. - Handle edge cases such as an empty list gracefully.","solution":"from typing import List, Tuple from collections import Counter def count_frequency(nums: List[int]) -> List[Tuple[int, int]]: Count the frequency of each number in the list and return a list of tuples sorted by frequency in descending order, and by number in ascending order for ties. # Count the frequency using Counter frequency_counter = Counter(nums) # Create a list of tuples (number, frequency) frequency_list = [(num, freq) for num, freq in frequency_counter.items()] # Sort the list by frequency in descending order, and by number in ascending order for ties frequency_list.sort(key=lambda x: (-x[1], x[0])) return frequency_list"},{"question":"# Question: Book Borrowing System Simulation You are asked to develop a system that simulates the process of borrowing and returning books in a library. To simplify, consider that each book is represented by its unique ID (a positive integer). This system should efficiently manage book states and operations using a stack for storing returned books and a queue for managing borrow requests due to their FIFO nature. **Objectives:** 1. Implement a class `LibrarySystem` with the following methods: - `register_book(book_id: int) -> None`: Adds a new book to the available book stack. - `borrow_book() -> int`: Allows a user to borrow the most recently registered book (i.e., the book at the top of the stack). If no books are available, it should raise an `IndexError` with a custom message \\"No books available for borrowing\\". - `return_book(book_id: int) -> None`: Returns a book to the stack, marking it as available for future borrowing. - `queued_borrow_request(book_id: int) -> None`: Adds a borrow request to the queue for a specific book ID. This doesn\'t remove the book from the available stack immediately but records the intention to borrow. 2. When a book is returned, check if it fulfills any queued borrow requests. If it does, fulfill the earliest request by removing it from the queue. **Constraints:** - Assume book IDs are unique positive integers. - The `borrow_book()` method should handle the case of no books being available by raising an `IndexError`. - Borrow requests in the queue must be processed based on the order they were added (FIFO). **Function Signatures:** - `class LibrarySystem:` - `def __init__(self) -> None:` - `def register_book(self, book_id: int) -> None:` - `def borrow_book(self) -> int:` - `def return_book(self, book_id: int) -> None:` - `def queued_borrow_request(self, book_id: int) -> None:` **Example Usage:** ```python library = LibrarySystem() library.register_book(101) library.register_book(102) library.register_book(103) print(library.borrow_book()) # Output: 103 print(library.borrow_book()) # Output: 102 library.return_book(103) library.queued_borrow_request(101) print(library.borrow_book()) # Output: 103 (no queued request for 103) print(library.borrow_book()) # Output: 101 library.return_book(102) print(library.borrow_book()) # Raises IndexError: \\"No books available for borrowing\\" ``` Your task is to implement the `LibrarySystem` class ensuring it behaves as described, efficiently managing book availability and processing borrow requests.","solution":"from collections import deque class LibrarySystem: def __init__(self) -> None: self.available_books = [] # A stack to manage available books self.borrow_queue = deque() # A queue to manage borrow requests def register_book(self, book_id: int) -> None: Adds a new book to the available book stack. self.available_books.append(book_id) def borrow_book(self) -> int: Allows a user to borrow the most recently registered book (i.e., the book at the top of the stack). If no books are available, raises an IndexError with a custom message \\"No books available for borrowing\\". if not self.available_books: raise IndexError(\\"No books available for borrowing\\") return self.available_books.pop() def return_book(self, book_id: int) -> None: Returns a book to the stack, marking it as available for future borrowing. If there are any queued borrow requests, fulfills the earliest request with the returned book. if self.borrow_queue and self.borrow_queue[0] == book_id: self.borrow_queue.popleft() else: self.available_books.append(book_id) def queued_borrow_request(self, book_id: int) -> None: Adds a borrow request to the queue for a specific book ID. self.borrow_queue.append(book_id)"},{"question":"# Coding Challenge: K-Nearest Neighbors for Clustering Scenario You are working for a data science team that needs to classify an increasing amount of data for customer segmentation based on their purchase history. The team wants you to implement an efficient K-Nearest Neighbors algorithm for clustering purposes. Task Write a function `knn_clustering(data_points, k)` that applies the K-Nearest Neighbors algorithm for clustering a given set of data points into `k` clusters. Expected Function Signature ```python def knn_clustering(data_points: List[Tuple[float, float]], k: int) -> List[int]: data_points: is a list of tuples, where each tuple represents a point in a 2D space. Each tuple consists of two float values (x, y). k: integer representing the number of clusters to form. Returns a list of integers indicating the cluster to which each point belongs. ``` Input - `data_points`: A list of tuples representing 2D points. Each tuple contains two float values `(x, y)`. - `k`: An integer representing the number of clusters. Output - A list of integers where the `i-th` element indicates the cluster index (from 0 to `k-1`) of the `i-th` data point. Constraints - **Performance Requirement**: Your implementation should efficiently handle thousands of data points. - **Algorithm Constraints**: Use an efficient distance calculation method and ensure the clustering process converges. Example ```python data_points = [(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (6.0, 8.0), (1.0, 0.6), (9.0, 11.0)] k = 2 # Perform K-Nearest Neighbors clustering clusters = knn_clustering(data_points, k) ``` Additional Information - You may use Euclidean distance as the measure of distance between points. - Assume that input data points are sufficiently distinct to form meaningful clusters. - Make sure to handle edge cases such as `k` being greater than the number of data points gracefully.","solution":"import numpy as np from scipy.spatial.distance import cdist def knn_clustering(data_points, k): Clusters data points using the K-Means algorithm. :param data_points: List of 2D points represented as tuples (x, y). :param k: Integer representing the number of clusters. :return: List of cluster indices for each data point. if k <= 0 or k > len(data_points): raise ValueError(\\"k must be a positive integer less than or equal to the number of data points.\\") # Initialize cluster centers (randomly select k points as initial centers) np.random.seed(0) initial_centers_indices = np.random.choice(len(data_points), k, replace=False) cluster_centers = np.array([data_points[i] for i in initial_centers_indices]) def update_centers(data_points, clusters, k): new_centers = [] for cluster_idx in range(k): cluster_points = [data_points[i] for i in range(len(data_points)) if clusters[i] == cluster_idx] if cluster_points: new_centers.append(np.mean(cluster_points, axis=0)) else: new_centers.append(cluster_centers[cluster_idx]) # keep the same center if no points are assigned return np.array(new_centers) def assign_clusters(data_points, centers): distances = cdist(data_points, centers, \'euclidean\') return np.argmin(distances, axis=1) data_points = np.array(data_points) clusters = assign_clusters(data_points, cluster_centers) while True: new_centers = update_centers(data_points, clusters, k) new_clusters = assign_clusters(data_points, new_centers) if np.all(clusters == new_clusters): break cluster_centers = new_centers clusters = new_clusters return clusters.tolist()"},{"question":"# Question You are tasked with implementing a function that calculates and returns the factorial of a number, but with a twist: the function should only multiply the odd numbers in the factorial sequence. # Objective Write a function `odd_factorial(n: int) -> int` that computes the product of all odd numbers from 1 to `n` (inclusive) if `n` is odd, or from 1 to `n-1` if `n` is even. # Specifications - **Input**: - `n` (int): A positive integer where 1 ≤ n ≤ 10^3. - **Output**: - An integer representing the product of all odd numbers in the factorial sequence up to `n` or `n-1`. # Constraints - Your solution should be efficient in terms of time and space complexity. - Handle edge cases appropriately. # Example ```python >>> odd_factorial(5) 15 # (1 * 3 * 5) >>> odd_factorial(6) 15 # (1 * 3 * 5) >>> odd_factorial(1) 1 >>> odd_factorial(4) 3 # (1 * 3) >>> odd_factorial(7) 105 # (1 * 3 * 5 * 7) ``` # Notes - The multiplication operation should skip even numbers. - Ensure your solution handles the smallest input value properly.","solution":"def odd_factorial(n: int) -> int: Returns the product of all odd numbers from 1 to n if n is odd, or from 1 to n-1 if n is even. if n < 1: raise ValueError(\\"Input must be a positive integer\\") product = 1 for i in range(1, n + 1): if i % 2 != 0: product *= i return product"},{"question":"Problem Statement You need to write a function that simulates the operation of a shifting cipher for alphabetic characters. A shifting cipher, also known as Caesar\'s Cipher, replaces each letter in a given text with a letter some fixed number of positions down or up the alphabet. The shift to letters beyond \'z\' wraps around back to \'a\', and likewise in reverse for \'a\' going backward past \'z\'. # Function Signature ```python def shifting_cipher(text: str, shift: int) -> str: ``` # Input - `text`: A string containing the text to be encrypted or decrypted. The text may contain both uppercase and lowercase alphabets, spaces, and punctuation marks. - `shift`: An integer indicating the number of positions to shift each alphabetic character. A positive integer implies shifting down the alphabet, while a negative integer implies shifting up the alphabet. # Output - Returns the encrypted/decrypted text as a string. # Constraints - The `text` will have at most 10,000 characters. - The `shift` can be any integer (positive, negative, or zero). # Example ```python print(shifting_cipher(\\"Hello, World!\\", 3)) # Output: \\"Khoor, Zruog!\\" print(shifting_cipher(\\"Khoor, Zruog!\\", -3)) # Output: \\"Hello, World!\\" print(shifting_cipher(\\"abc XYZ\\", 27)) # Output: \\"bcd YZA\\" ``` # Note - Only alphabetic characters (both uppercase and lowercase) are shifted. - Spaces, punctuation marks, and other non-alphabetic characters should remain unchanged. - The function should correctly handle cases where the shift causes wrapping around the alphabet. For instance, with a shift of 3, \'z\' becomes \'c\' and \'Z\' becomes \'C\'. - A shift of 0 means the text remains unchanged.","solution":"def shifting_cipher(text: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, shift) for c in text)"},{"question":"# Coding Assessment Question Scenario A software development team is working on a user interface feature for resizing images based on user input. Each image needs to be resized proportionally, maintaining its aspect ratio, and should fit within a specified maximum width and height. Implement an algorithm that calculates the new dimensions for the image to fit within the constraints while preserving the aspect ratio. Task Write a Python function `resize_image(current_width: int, current_height: int, max_width: int, max_height: int) -> tuple` that calculates the new dimensions for the image. Function Signature ```python def resize_image(current_width: int, current_height: int, max_width: int, max_height: int) -> tuple: ``` Input - `current_width`: an integer representing the current width of the image. - `current_height`: an integer representing the current height of the image. - `max_width`: an integer representing the maximum width allowed for the new dimensions. - `max_height`: an integer representing the maximum height allowed for the new dimensions. Output - Return a tuple of two integers representing the new width and height of the image after resizing. Constraints - All input values will be positive integers. - The output dimensions must be scaled proportionally to retain the original aspect ratio. - If the current dimensions are already within the max constraints, return the original dimensions. Examples ```python >>> resize_image(1920, 1080, 800, 600) (800, 450) >>> resize_image(800, 600, 800, 600) (800, 600) >>> resize_image(300, 300, 100, 200) (100, 100) >>> resize_image(1000, 500, 600, 300) (600, 300) ``` Requirements - Your solution must correctly handle various edge cases, including scenarios where the image must be shrunk in one dimension only. - Maintain efficient performance and adherence to the outlined complexities.","solution":"def resize_image(current_width: int, current_height: int, max_width: int, max_height: int) -> tuple: Calculate the new dimensions for an image to fit within the specified maximum width and height, while maintaining the aspect ratio. Parameters: current_width (int): Current width of the image current_height (int): Current height of the image max_width (int): Maximum allowed width max_height (int): Maximum allowed height Returns: tuple: New width and height of the image as (new_width, new_height) # If the current image is already within the max constraints, return the original dimensions if current_width <= max_width and current_height <= max_height: return (current_width, current_height) # Calculate the scaling factor for both width and height width_scale = max_width / current_width height_scale = max_height / current_height # Use the smaller scaling factor to ensure both dimensions fit within the max dimensions scale = min(width_scale, height_scale) new_width = int(current_width * scale) new_height = int(current_height * scale) return (new_width, new_height)"},{"question":"# Problem: Implementing a Simplified Polynomial Calculator You are required to implement a function that takes a list of polynomials represented by their coefficients and performs operations such as addition and subtraction on them. Each polynomial is represented by a list where the i-th element is the coefficient for the x^i term. Function Signature: ```python def polynomial_operations(polynomials: List[List[int]], operation: str) -> List[int]: :param polynomials: List[List[int]] A list of polynomials, with each polynomial represented as a list of integers. Each entry represents the coefficient of the polynomial term at that index. :param operation: str A string that specifies the operation to perform. It can either be \\"add\\" for addition or \\"subtract\\" for subtraction. :return: List[int] The resulting polynomial after performing the specified operation. Example: >>> polynomial_operations([[1, 2, 3], [4, 0, -3]], \\"add\\") [5, 2, 0] >>> polynomial_operations([[5, -3, 0, 7], [3, 2, 1]], \\"subtract\\") [2, -5, -1, 7] >>> polynomial_operations([[0], [1, 1]], \\"add\\") [1, 1] ``` # Constraints: * Each polynomial will contain between 1 and 1000 coefficients. * Coefficients can be any integer from -10^6 to 10^6. * The output polynomial should include all coefficients, even if they are zero. * The input list will always contain at least one polynomial. * The operation string will always be either \\"add\\" or \\"subtract\\". Inputs: * **polynomials**: A list of lists where each sublist is a polynomial represented by its coefficients. * **operation**: A string indicating whether to add or subtract the polynomials. Outputs: * A list of coefficients representing the resulting polynomial after performing the specified operation. # Example: Input: `polynomial_operations([[1, 2, 3], [4, 0, -3]], \\"add\\")` Output: `[5, 2, 0]` Input: `polynomial_operations([[5, -3, 0, 7], [3, 2, 1]], \\"subtract\\")` Output: `[2, -5, -1, 7]` # Be sure to: * Handle cases where polynomials have different lengths by treating missing terms as having a coefficient of 0. * Optimize for common operations to ensure the function handles the maximum input size efficiently. * Think through edge cases such as zero polynomials, negative coefficients, and single term polynomials.","solution":"def polynomial_operations(polynomials, operation): Performs addition or subtraction on a list of polynomials represented by their coefficients. :param polynomials: List[List[int]] A list of polynomials, each represented as a list of integers. Each entry in a polynomial list represents the coefficient for the x^i term. :param operation: str The operation to perform: \\"add\\" for addition, \\"subtract\\" for subtraction. :return: List[int] The resulting polynomial coefficients after performing the specified operation. # Determine the length of the longest polynomial to handle different lengths max_length = max(len(poly) for poly in polynomials) # Initialize the result as a list of zeros with the same length as the longest polynomial result = [0] * max_length # If the operation is \\"add\\", we add coefficients; if \\"subtract\\", we subtract them if operation == \\"add\\": for poly in polynomials: for i in range(len(poly)): result[i] += poly[i] elif operation == \\"subtract\\": # Start by adding the first polynomial for i in range(len(polynomials[0])): result[i] = polynomials[0][i] # Subtract subsequent polynomials for poly in polynomials[1:]: for i in range(len(poly)): result[i] -= poly[i] return result"},{"question":"Question: Room Assignment Optimization # Context You are in charge of developing a system that optimally assigns students to rooms based on their preferences. Each student can indicate their top three preferences for room numbers and room assignments should aim to maximize the number of students getting one of their top three choices. # Requirements Implement a function that: 1. Takes a list of student preferences and available rooms. 2. Returns a mapping of students to their assigned rooms. 3. Maximizes the total number of students who get one of their top three preferences. 4. Ensures each room is assigned to only one student. # Input - `preferences`: A dictionary where the keys are student names (strings) and the values are lists of up to three integers, representing their top three room preferences. - `available_rooms`: A list of integers, representing the room numbers that are available. # Output - A dictionary mapping each student name to their assigned room number (int). If a student cannot be assigned to any of their top three preferences, they should not be in the resulting dictionary. # Function Signature ```python def assign_rooms(preferences: dict[str, list[int]], available_rooms: list[int]) -> dict[str, int]: ``` # Examples Input ```python preferences = { \\"Alice\\": [101, 102, 103], \\"Bob\\": [102, 104, 105], \\"Charlie\\": [101, 103, 106], \\"David\\": [105, 106, 101] } available_rooms = [101, 102, 103, 104, 105, 106] print(assign_rooms(preferences, available_rooms)) ``` Output ```python { \\"Alice\\": 101, \\"Bob\\": 102, \\"Charlie\\": 103, \\"David\\": 105 } ``` (Note: This is one of the possible optimal assignments where all students get one of their top three preferences.) Input ```python preferences = { \\"Alice\\": [101, 102, 103], \\"Bob\\": [101, 102, 103], \\"Charlie\\": [104, 105, 106] } available_rooms = [101, 102, 103, 106] print(assign_rooms(preferences, available_rooms)) ``` Output ```python { \\"Alice\\": 101, \\"Bob\\": 102, \\"Charlie\\": 106 } ``` (Note: Here, \\"Alice\\" and \\"Bob\\" got their first and second preferences respectively, and \\"Charlie\\" got their third preference.) # Constraints 1. If multiple optimal solutions exist, any can be returned. 2. Each room must be assigned to at most one student. 3. Not all students are guaranteed to get a room, especially if room numbers are fewer than students.","solution":"def assign_rooms(preferences: dict[str, list[int]], available_rooms: list[int]) -> dict[str, int]: # Create a data structure to facilitate the assignment process room_assignments = {} room_assigned = set() # Process each student and try to assign one of their preferred rooms for student, prefs in preferences.items(): assigned = False for room in prefs: if room in available_rooms and room not in room_assigned: room_assignments[student] = room room_assigned.add(room) assigned = True break # Move to the next student once the room is assigned return room_assignments"},{"question":"# Data Processing and JSON File Handling Assessment You are required to implement a Python function to process JSON data from a file and convert it to a specified CSV format. The objective is to assess your proficiency in handling JSON data, data manipulation, and file operations in Python. Context: You have a JSON file containing user information with fields such as `name`, `age`, `email`, and `address`. Your task is to extract relevant data from this JSON file and save it into a CSV file in a structured manner. Task: 1. Write a function `read_json_file(filename: str) -> list[dict]` that reads the JSON data from the specified filename and returns a list of dictionaries representing the user information. 2. Write a second function `write_users_to_csv(users: list[dict], filename: str = \\"users.csv\\") -> None` that writes the user data to a CSV file. The function should take the list of dictionaries returned by `read_json_file` and a filename, and save the data into the specified CSV file with columns for `name`, `age`, `email`, and `address`. Input: - `filename`: (str) The name of the JSON file to read the data from. - `users`: (list) List of dictionaries containing user information. - `filename`: (str) The name of the CSV file to write the data to. Default is \\"users.csv\\". Output: - For `read_json_file`: A list of dictionaries, where each dictionary contains user information as key-value pairs. - For `write_users_to_csv`: No return value, but it should create a CSV file with user information. Notes: - Assume the JSON file structure is consistent with each entry containing the keys `name`, `age`, `email`, and `address`. - Handle potential file reading or writing errors with appropriate exception handling. - Ensure the CSV file has columns: \\"Name\\", \\"Age\\", \\"Email\\", and \\"Address\\". - The functions must handle cases where the JSON file may be empty or have unexpected data formats. - Code should be written in a clear and modular manner. Constraints: - Ensure data processed is not null or empty before writing to the file. - The functions must handle potential changes in the JSON structure gracefully. - Implement data validation to ensure correct types and formats are maintained in the CSV output. Example: Here is an example of expected function usage: ```python json_filename = \\"users.json\\" users = read_json_file(json_filename) write_users_to_csv(users, \\"users.csv\\") ```","solution":"import json import csv def read_json_file(filename: str) -> list[dict]: Reads JSON data from the specified file and returns a list of dictionaries. Each dictionary contains user information. try: with open(filename, \'r\') as file: data = json.load(file) except FileNotFoundError: print(f\\"File {filename} not found.\\") return [] except json.JSONDecodeError: print(f\\"Error decoding JSON from the file {filename}.\\") return [] return data if isinstance(data, list) else [] def write_users_to_csv(users: list[dict], filename: str = \\"users.csv\\") -> None: Writes user data to a CSV file. The function takes a list of dictionaries containing user information and a filename for the CSV. try: with open(filename, \'w\', newline=\'\') as csvfile: fieldnames = [\'name\', \'age\', \'email\', \'address\'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for user in users: if all(field in user for field in fieldnames): writer.writerow({ \'name\': user[\'name\'], \'age\': user[\'age\'], \'email\': user[\'email\'], \'address\': user[\'address\'] }) except IOError as e: print(f\\"Error writing to CSV file {filename}: {e}\\")"},{"question":"Question You are provided with a list of integers representing the heights of a group of people standing in a line. The goal is to find the total number of \\"visible\\" people when looking from left to right. A person is considered \\"visible\\" if there is no taller person to their left. Implement a function to compute the total count of visible people. # Function Signature ```python def count_visible_people(heights: List[int]) -> int: pass ``` # Input - **heights**: A list of integers where each integer represents the height of a person. # Output - Returns the integer count of visible people from left to right. # Constraints - The input list `heights` will have a length between 1 and 1000 inclusive. - Each height in the list will be a positive integer between 1 and 1000 inclusive. # Example ```python count_visible_people([1, 2, 3, 2, 1]) # Output: 3 count_visible_people([4, 3, 2, 1]) # Output: 1 count_visible_people([5, 5, 5, 5]) # Output: 1 ``` # Note - In the first example, the sequence of visible people based on their heights is [1, 2, 3]. - In the second example, the first person (height 4) blocks the view of everyone else. - In the third example, only the first person is visible as they all have the same height.","solution":"from typing import List def count_visible_people(heights: List[int]) -> int: Computes the number of visible people from left to right in a line based on their heights. Parameters: heights (List[int]): A list of integers where each integer represents the height of a person. Returns: int: The count of visible people based on the given heights. if not heights: return 0 max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a list of phrases where each phrase consists of one or more words separated by spaces. Your task is to rearrange the words in each phrase such that the words are sorted in descending order based on their lengths. If two words have the same length, they should appear in their original order relative to each other. Write a function called `rearrange_phrases(phrases: List[str]) -> List[str>` which takes a list of phrases as an argument and returns a list of phrases with the words rearranged according to the specified criteria. # Input Format - A list of strings `phrases` where each string is a phrase consisting of words separated by spaces. # Output Format - Return a list of strings where each string is a phrase with words rearranged in descending order of their lengths. # Constraints - Each phrase will consist of alphanumeric words and spaces only. - The length of the input list will not exceed 10,000 phrases. - Each phrase will not exceed 100 words, and each word will not exceed 50 characters. # Example ```python def test_rearrange_phrases(): assert rearrange_phrases([\\"the quick brown fox\\", \\"jumps over the lazy dog\\"]) == [\\"quick brown the fox\\", \\"jumps over lazy the dog\\"] test_rearrange_phrases() ``` * Explanation: - In the first phrase, \\"quick\\" (5 letters) and \\"brown\\" (5 letters) are longer than \\"the\\" (3 letters) and \\"fox\\" (3 letters). \\"quick\\" and \\"brown\\" take precedence in the order they appear. - In the second phrase, \\"jumps\\" (5 letters) is longer than \\"over\\" (4 letters), and both are longer than \\"lazy\\" (4 letters), \\"the\\" (3 letters), and \\"dog\\" (3 letters). So, \\"jumps\\" comes first, followed by \\"over\\" and \\"lazy\\", with \\"the\\" and \\"dog\\" trailing. # Performance Requirements * The function should process each phrase and sort words efficiently, completing the rearrangement of all phrases within a reasonable time frame.","solution":"def rearrange_phrases(phrases): Given a list of phrases, rearrange the words in each phrase such that the words are sorted in descending order based on their lengths. If two words have the same length, they should appear in their original order relative to each other. rearranged_phrases = [] for phrase in phrases: words = phrase.split() sorted_words = sorted(words, key=lambda x: (-len(x), words.index(x))) rearranged_phrase = \' \'.join(sorted_words) rearranged_phrases.append(rearranged_phrase) return rearranged_phrases"},{"question":"# Scenario A music streaming service wants to implement a feature that allows users to create and search playlists based on certain criteria. The service maintains a database of songs, each with attributes such as genre, artist, and duration. Your task is to write a function that searches the database of songs and returns all songs that match the given criteria. # Problem Statement You are given a list of songs, where each song is represented as a dictionary with keys `title`, `genre`, `artist`, and `duration`. Implement the function **filter_songs** which takes a list of songs and a dictionary of criteria to filter the songs by. The function should return a list of songs that match all the given criteria. # Function Signature ```python def filter_songs(songs: List[Dict[str, Union[str, int]]], criteria: Dict[str, Union[str, int]]) -> List[Dict[str, Union[str, int]]]: ``` # Input - **songs**: A list of dictionaries, where each dictionary represents a song with the following keys: - `title` (string): The title of the song - `genre` (string): The genre of the song - `artist` (string): The artist of the song - `duration` (integer): The duration of the song in seconds - **criteria**: A dictionary with keys that could be any of the song attributes (`title`, `genre`, `artist`, `duration`) and values that are the desired values for those attributes. # Output - Returns a list of dictionaries representing the songs that match all the given criteria. # Constraints - The given list of songs will have at most (10^4) songs. - Each song will have the keys `title`, `genre`, `artist`, and `duration`. # Example ```python songs = [ {\\"title\\": \\"Song A\\", \\"genre\\": \\"Rock\\", \\"artist\\": \\"Artist 1\\", \\"duration\\": 210}, {\\"title\\": \\"Song B\\", \\"genre\\": \\"Pop\\", \\"artist\\": \\"Artist 2\\", \\"duration\\": 180}, {\\"title\\": \\"Song C\\", \\"genre\\": \\"Jazz\\", \\"artist\\": \\"Artist 1\\", \\"duration\\": 200}, {\\"title\\": \\"Song D\\", \\"genre\\": \\"Rock\\", \\"artist\\": \\"Artist 3\\", \\"duration\\": 240} ] criteria = {\\"genre\\": \\"Rock\\", \\"artist\\": \\"Artist 1\\"} print(filter_songs(songs, criteria)) # Expected Output: [{\\"title\\": \\"Song A\\", \\"genre\\": \\"Rock\\", \\"artist\\": \\"Artist 1\\", \\"duration\\": 210}] ``` # Constraints and Performance Notes - Make sure your solution is efficient and handles the maximum constraints smoothly. - Your solution should ideally run in (O(n cdot k)), where (n) is the number of songs and (k) is the number of criteria to filter by.","solution":"from typing import List, Dict, Union def filter_songs(songs: List[Dict[str, Union[str, int]]], criteria: Dict[str, Union[str, int]]) -> List[Dict[str, Union[str, int]]]: Filters the list of songs based on the given criteria. Parameters: - songs: List of songs, where each song is a dictionary with keys \'title\', \'genre\', \'artist\', and \'duration\'. - criteria: Dictionary of criteria to filter songs by, with keys same as song attributes. Returns: - List of songs that match all the given criteria. filtered_songs = [] for song in songs: match = True for key, value in criteria.items(): if song.get(key) != value: match = False break if match: filtered_songs.append(song) return filtered_songs"},{"question":"# Question: Efficient Subarray Sum In this task, you need to develop an efficient algorithm to find the subarray with the maximum sum within a given list of integers. This is a pivotal problem in the field of dynamic programming and is often used in financial analysis, game scoring systems, and more. **Objective**: Implement a function that computes the maximum sum of any contiguous subarray using a dynamic programming approach. # Function Signature ```python def max_subarray_sum(arr: list[int]) -> int: pass ``` # Input * `arr`: A list of integers which may include both positive and negative numbers. # Output * Returns an integer representing the maximum sum of any contiguous subarray within the input list. # Constraints 1. The input list contains at least one number. 2. The length of the list does not exceed 10,000. 3. The numbers in the list can range from -10,000 to 10,000. # Performance Requirements * The algorithm should efficiently handle the worst-case scenario with a time complexity of O(n), where n is the number of elements in the input list. # Examples ```python # Example 1 arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # Expected result: 6 (subarray [4, -1, 2, 1] has the maximum sum) # Example 2 arr = [1] # Expected result: 1 (since there\'s only one element) # Example 3 arr = [-1, -2, -3, -4] # Expected result: -1 (subarray [-1] has the maximum sum) # Example 4 arr = [5, 4, -1, 7, 8] # Expected result: 23 (the entire array is the subarray with the maximum sum) ``` # Hints 1. Utilize Kadane\'s Algorithm for an optimal O(n) solution. 2. Keep track of the current subarray sum and the maximum sum found so far. 3. Handle edge cases such as an array with all negative numbers gracefully. By creating a function that handles these conditions, you\'ll develop an efficient solution to the maximum subarray sum problem that integrates seamlessly with the existing set of questions.","solution":"def max_subarray_sum(arr: list[int]) -> int: Function to find the maximum sum of a contiguous subarray using Kadane\'s Algorithm. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement: You are given a string containing only the characters \'a\' and \'b\'. Your task is to compute the smallest number of operations required to make the string a palindrome. An operation consists of converting one character to either \'a\' or \'b\'. Each solution should be encapsulated in a function with the following specifications: Function Specification: ```python def min_operations_to_palindrome(s: str) -> int: Computes the minimum number of operations required to make the given string a palindrome. :param s: A string consisting only of characters \'a\' and \'b\'. :return: The smallest number of operations needed to make the string a palindrome. :raises ValueError: If the input string contains characters other than \'a\' or \'b\'. ``` Example: ```python >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"aa\\") 0 >>> min_operations_to_palindrome(\\"abb\\") 1 >>> min_operations_to_palindrome(\\"abab\\") 2 >>> min_operations_to_palindrome(\\"aabaa\\") 0 >>> min_operations_to_palindrome(\\"abc\\") Traceback (most recent call last): ... ValueError: the string must contain only \'a\' and \'b\' ``` Constraints: * The input string will have a length between 1 and 10^5 characters. * The string will contain only lowercase \'a\' and \'b\' characters. * Performance is crucial, so ensure your solution is efficient and runs within acceptable time limits. # Requirements: * Handle edge cases like empty strings (if you decide to extend the function to handle them) and strings that are already palindromes. * Provide an explanation of the logic behind your solution and any assumptions made. --- To solve this problem, iterate from the start of the string to the middle and compare each character with its corresponding character from the end. Count the number of mismatches, as each mismatch represents one required operation to make the string a palindrome.","solution":"def min_operations_to_palindrome(s: str) -> int: Computes the minimum number of operations required to make the given string a palindrome. :param s: A string consisting only of characters \'a\' and \'b\'. :return: The smallest number of operations needed to make the string a palindrome. :raises ValueError: If the input string contains characters other than \'a\' or \'b\'. if any(c not in \'ab\' for c in s): raise ValueError(\\"the string must contain only \'a\' and \'b\'\\") n = len(s) min_operations = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: min_operations += 1 return min_operations"},{"question":"**Question:** You are developing a text processing tool that requires finding all the starting indices of substring anagrams in a given string. An anagram is a reshuffling of characters to form a different word or phrase using exactly the same characters. **Task:** Write a Python function `find_all_anagrams(s: str, p: str) -> List[int]` that returns an array of all the starting indices of `p`\'s anagrams in `s`. Use a sliding window algorithm to optimize the search. **Input:** * `s`: A string (1 ≤ len(s) ≤ 10000) * `p`: A string (1 ≤ len(p) ≤ 1000) **Output:** * Returns a list of integers representing the starting indices of anagrams of `p` in `s`. **Example:** ```python find_all_anagrams(\\"cbaebabacd\\", \\"abc\\") ``` Output: ```python [0, 6] ``` **Constraints:** * The input strings `s` and `p` consist of lowercase English letters. **Hint:** Utilize a sliding window approach, maintaining the count of characters in the current window and comparing it with the count of characters in the string `p`.","solution":"from collections import Counter from typing import List def find_all_anagrams(s: str, p: str) -> List[int]: Find all starting indices of p\'s anagrams in s. len_s, len_p = len(s), len(p) if len_p > len_s: return [] p_count = Counter(p) s_count = Counter() result = [] for i in range(len_s): s_count[s[i]] += 1 if i >= len_p: if s_count[s[i - len_p]] == 1: del s_count[s[i - len_p]] else: s_count[s[i - len_p]] -= 1 if s_count == p_count: result.append(i - len_p + 1) return result"},{"question":"# Coding Question You are required to implement a solution that calculates the minimum number of operations needed to transform a given string `source` into another string `target` using edit operations: insertions, deletions, and substitutions. This problem is also known as computing the Levenshtein distance. Function Definition `def levenshtein_distance(source: str, target: str) -> int:` # Input - `source` (str): A string representing the initial string. - `target` (str): A string representing the desired target string. # Output - Returns (int): The minimum number of operations required to transform `source` into `target`. # Constraints - The length of both `source` and `target` will not exceed 1000 characters. - Both `source` and `target` will consist only of lowercase English letters. Example ```python # Example 1 source = \\"kitten\\" target = \\"sitting\\" print(levenshtein_distance(source, target)) # Expected output: 3 # Example 2 source = \\"flaw\\" target = \\"lawn\\" print(levenshtein_distance(source, target)) # Expected output: 2 # Example 3 source = \\"\\" target = \\"abc\\" print(levenshtein_distance(source, target)) # Expected output: 3 ``` Your task is to implement the `levenshtein_distance` function to correctly compute the minimum number of edit operations required to transform the source string into the target string.","solution":"def levenshtein_distance(source: str, target: str) -> int: Returns the minimum number of operations required to transform the source string into the target string. Operations include insertions, deletions, and substitutions. m, n = len(source), len(target) # Create a matrix to store the distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the distances for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"# Decision Tree Classifier Implementation Challenge Context You are presented with a dataset of medical records where each record contains information about patient symptoms and a binary diagnosis: healthy (0) or diseased (1). Your task is to implement a decision tree classifier from scratch in Python to predict the diagnosis based on symptoms. Task Write a function `decision_tree_classifier(X: np.ndarray, y: np.ndarray, max_depth: int = 5) -> dict` that trains a decision tree model and returns a dictionary representing the tree structure. The function should: 1. Calculate the entropy of a dataset. 2. Compute the information gain of a potential split. 3. Implement a function to split the dataset based on a given feature and threshold. 4. Recursively build the decision tree using the best splits until the max depth is reached or no further split improves the information gain. 5. The resulting tree should be represented in a nested dictionary format. Inputs and Outputs * **Input**: * `X` - A numpy array of shape (m, n) where \'m\' is the number of samples and \'n\' is the number of features. * `y` - A numpy array of shape (m,) with binary labels (0 or 1). * `max_depth` - Maximum depth of the decision tree (default is 5). * **Output**: * A nested dictionary representing the trained decision tree, where each node indicates the splitting feature and threshold, and leaf nodes contain the predicted class. Constraints * The dataset can contain up to 1000 samples with up to 10 features each. * The maximum depth `max_depth` will be a positive integer between 1 and 15. Performance Requirements * Ensure the tree-building process does not exceed a reasonable computation time even for the upper limits of the dataset size and depth. * The model should handle missing or equal splitting points effectively. Example ```python import numpy as np # Sample dataset X = np.array([[1, 0], [0, 1], [1, 1], [0, 0], [0, 1]]) y = np.array([1, 0, 1, 0, 0]) tree = decision_tree_classifier(X, y, max_depth=3) print(\\"Trained decision tree:\\", tree) ``` Expected output will display a nested dictionary representing the decision tree structure that can classify new samples based on the learned splits. Examples of tree representation: ```python { \'feature\': 0, \'threshold\': 0.5, \'left\': { \'feature\': 1, \'threshold\': 0.5, \'left\': {\'class\': 0}, \'right\': {\'class\': 1} }, \'right\': {\'class\': 1} } ```","solution":"import numpy as np def entropy(y): unique, counts = np.unique(y, return_counts=True) probabilities = counts / len(y) return -np.sum(probabilities * np.log2(probabilities)) def information_gain(y, y_left, y_right): weight_left = len(y_left) / len(y) weight_right = len(y_right) / len(y) return entropy(y) - (weight_left * entropy(y_left) + weight_right * entropy(y_right)) def split_dataset(X, y, feature, threshold): left_indices = X[:, feature] <= threshold right_indices = X[:, feature] > threshold return X[left_indices], y[left_indices], X[right_indices], y[right_indices] def best_split(X, y): best_feature = None best_threshold = None best_info_gain = -1 for feature in range(X.shape[1]): thresholds = np.unique(X[:, feature]) for threshold in thresholds: X_left, y_left, X_right, y_right = split_dataset(X, y, feature, threshold) if len(y_left) > 0 and len(y_right) > 0: gain = information_gain(y, y_left, y_right) if gain > best_info_gain: best_info_gain = gain best_feature = feature best_threshold = threshold return best_feature, best_threshold def build_tree(X, y, depth, max_depth): if len(np.unique(y)) == 1: return {\'class\': int(y[0])} if depth >= max_depth or len(y) == 0: return {\'class\': int(np.round(np.mean(y)))} feature, threshold = best_split(X, y) if feature is None: return {\'class\': int(np.round(np.mean(y)))} X_left, y_left, X_right, y_right = split_dataset(X, y, feature, threshold) left_subtree = build_tree(X_left, y_left, depth + 1, max_depth) right_subtree = build_tree(X_right, y_right, depth + 1, max_depth) return { \'feature\': feature, \'threshold\': threshold, \'left\': left_subtree, \'right\': right_subtree } def decision_tree_classifier(X: np.ndarray, y: np.ndarray, max_depth: int = 5) -> dict: tree = build_tree(X, y, depth=0, max_depth=max_depth) return tree"},{"question":"# Evaluate Network Shortest Path with Dijkstra\'s Algorithm Objective You are tasked with enhancing a network routing system. The current implementation uses unweighted edges to determine the shortest path. In real-world networks, various routes have different latencies or bandwidth costs. You need to modify the Dijkstra algorithm to account for weighted edges to determine the shortest path correctly. Task Modify the existing Dijkstra\'s algorithm implementation to handle weighted edges efficiently. You need to adapt the algorithm to correctly compute the shortest path based on these weights. Input 1. **Graph**: A dictionary where the keys are node identifiers, and the values are lists of tuples representing the neighboring nodes and the associated edge weight. ```python graph_weighted = { \'A\': [(\'B\', 2), (\'C\', 5)], \'B\': [(\'A\', 2), (\'C\', 6), (\'D\', 1)], \'C\': [(\'A\', 5), (\'B\', 6), (\'D\', 2)], \'D\': [(\'B\', 1), (\'C\', 2)], } ``` 2. **Start Node**: A string representing the identifier of the starting node. 3. **Goal Node**: A string representing the identifier of the goal node. Output A tuple containing: 1. A list of nodes representing the shortest path from the start node to the goal node, inclusive. 2. The total weight of that path. Constraints 1. The graph does not contain negative weight cycles. 2. Assume all nodes are connected in some manner. Performance Requirements * The solution should seek to achieve the best performance reliant on priority queue (min-heap). * Time complexity should optimally be O(E + V log V), where E is the number of edges and V is the number of vertices. * The handling of space complexity should focus on efficiently managing storage requirements for nodes and edge weights. Scenario In this networking example, consider that nodes represent routers, and edge weights denote the latency between them. Some paths might be faster (low latency), whereas others might be slower due to high traffic or distance. Example ```python graph_weighted = { \'A\': [(\'B\', 2), (\'C\', 5)], \'B\': [(\'A\', 2), (\'C\', 6), (\'D\', 1)], \'C\': [(\'A\', 5), (\'B\', 6), (\'D\', 2)], \'D\': [(\'B\', 1), (\'C\', 2)], } start = \'A\' goal = \'D\' # Expected output: ([\'A\', \'B\', \'D\'], 3) # The shortest path from A to D is through B with a total weight of 3. ``` Implement the modified algorithm in a class `DijkstraWeighted`.","solution":"import heapq class DijkstraWeighted: def __init__(self, graph): self.graph = graph def shortest_path(self, start, goal): heap = [(0, start, [])] visited = set() while heap: (cost, node, path) = heapq.heappop(heap) if node in visited: continue path = path + [node] if node == goal: return (path, cost) visited.add(node) for (next_node, weight) in self.graph.get(node, []): if next_node not in visited: heapq.heappush(heap, (cost + weight, next_node, path)) return ([], float(\\"inf\\"))"},{"question":"# Coding Assessment Question: Implementing the Absolute Value Function Context Understanding how to accurately determine the absolute value of a number is essential in various programming scenarios. This exercise will challenge your knowledge of number manipulation and edge case handling by asking you to implement the absolute value function. Problem Statement Write a function `absolute_value(x: int) -> int` that returns the absolute value of the integer `x`. The absolute value of a number is its non-negative value, regardless of its original sign. Input and Output * The input will be an integer `x`. * The output should be an integer which is the absolute value of `x`. Constraints * The input value `x` will be a valid integer within the range of -10^6 to 10^6. * Do not use any external libraries such as `abs`. Edge Cases * Consider how to handle negative numbers, zero, and large positive or negative numbers. * Ensure the implementation is efficient with O(1) time complexity. Example ```python def absolute_value(x: int) -> int: Return the absolute value of x. :param x: the number :return: the absolute value of x. >>> absolute_value(10) 10 >>> absolute_value(-10) 10 >>> absolute_value(0) 0 >>> absolute_value(-999999) 999999 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def absolute_value(x: int) -> int: Return the absolute value of x. :param x: the number :return: the absolute value of x. if x < 0: return -x return x"},{"question":"# Scenario You are developing a task scheduler system that must determine the minimum number of machine resources needed to execute a series of tasks based on their start and end times. To optimize the resources, you decide to implement an interval overlap detector to count the maximum number of overlapping tasks at any point in time. # Task Implement a function `min_resources(intervals: List[Tuple[int, int]]) -> int` that computes the minimum number of resources required to handle the tasks without any overlap. # Details 1. **Function `min_resources(intervals: List[Tuple[int, int]]) -> int` Implementation**: * Takes a list of tuples, where each tuple `(start, end)` represents the start and end times of a task. * Returns the minimum number of resources needed, which is equal to the maximum number of overlapping tasks. # Input * `intervals`: List of tuples, where each tuple `(int, int)` denotes the start and end times of a task. # Output * Returns an integer representing the minimum number of resources required. # Constraints * The number of intervals is between 1 and 1000. * All start and end times are integers between 0 and 10000. * Start time is always less than end time for each task. # Example ```python tasks = [(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)] print(min_resources(tasks)) # Expected output: 3 ``` # Notes 1. Perform comprehensive error checking and handle edge cases such as empty intervals or single task scenarios. 2. Optimize for efficiency to handle up to the maximum constraints smoothly.","solution":"def min_resources(intervals): Calculate the minimum number of resources required to handle all tasks without any overlap. Args: intervals (List[Tuple[int, int]]): A list of tuples, where each tuple represents the start and end times of a task. Returns: int: The minimum number of resources required. if not intervals: return 0 # Create a list of all events (start and end times) events = [] for start, end in intervals: events.append((start, \'start\')) events.append((end, \'end\')) # Sort events, breaking ties by considering \'start\' before \'end\' events.sort(key=lambda x: (x[0], x[1] == \'end\')) max_overlap = 0 current_overlap = 0 # Process events for event in events: if event[1] == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"# Coding Assessment Question: Smallest Missing Positive Integer Objective Create a function to determine the smallest positive integer that does not appear in an unsorted array of integers. Problem Statement Given an unsorted array of integers, find the smallest positive integer that is missing from the array. Write a function `smallest_missing_positive(arr: List[int]) -> int` that returns the smallest positive integer that is not present in the array. Function Signature ```python def smallest_missing_positive(arr: List[int]) -> int: pass ``` Input * `arr` (List[int]): A list of integers, which can contain both positive and negative values. The length of the list is between 1 and 10^6 inclusive. Output * Returns the smallest positive integer not present in the array. Constraints * The length of the array is between 1 and 10^6 inclusive. * The values in the array are between -10^6 and 10^6 inclusive. Examples ```python assert smallest_missing_positive([1, 2, 0]) == 3 assert smallest_missing_positive([3, 4, -1, 1]) == 2 assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 ``` # Guidelines * The optimal solution should have a linear time complexity, O(n). * Aim to solve the problem in place with O(1) extra space. **Hint**: Think about how you can use the indices of the array itself to mark the presence of numbers in the array.","solution":"from typing import List def smallest_missing_positive(arr: List[int]) -> int: n = len(arr) # Ensure all elements are within the range 1 to n for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Out of range elements set to n + 1 # Use the index as hash to record the presence of numbers for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Find the first positive index for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"# Coding Assessment Question You are tasked with creating a function that analyzes a company’s sales data to identify the best-selling products within a given time frame. The sales data is provided in the form of a CSV file with columns for date, product ID, and quantity sold. Your function must handle reading the CSV file, processing the data to accumulate sales per product, and returning a list of the top N best-selling products for the specified date range. Function Specification **Function Name**: `get_top_selling_products` **Input Parameters**: 1. `file_path`: (str) Path to the CSV file containing sales data. 2. `start_date`: (str) Start date in `YYYY-MM-DD` format. 3. `end_date`: (str) End date in `YYYY-MM-DD` format. 4. `top_n`: (int) Number of top-selling products to return. **Output**: - Returns a list of tuples, where each tuple contains the product ID and the total quantity sold, sorted in descending order of quantity. **Constraints**: - The `start_date` should not be after the `end_date`. - Only consider sales within the provided date range. - The CSV file is expected to have the following columns: `date`, `product_id`, and `quantity`. Example Usage ```python import csv from datetime import datetime def get_top_selling_products(file_path: str, start_date: str, end_date: str, top_n: int) -> list: # Your implementation here pass # Example call top_products = get_top_selling_products(\\"sales_data.csv\\", \\"2023-01-01\\", \\"2023-01-31\\", 5) for product in top_products: print(product) ``` # Requirements: 1. **Date Handling**: Ensure the function correctly parses and compares dates. 2. **CSV Parsing**: Implement robust CSV file reading to handle potential data format issues. 3. **Sorting and Aggregation**: Efficiently accumulate sales quantities by product and determine the top N products. 4. **Edge Cases**: Consider scenarios such as no sales data within the given date range, invalid date formats, and ties in sales quantities. You have 2 hours to complete this task. Good luck!","solution":"import csv from datetime import datetime from collections import defaultdict def get_top_selling_products(file_path: str, start_date: str, end_date: str, top_n: int) -> list: sales_data = defaultdict(int) start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") with open(file_path, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: sale_date = datetime.strptime(row[\'date\'], \\"%Y-%m-%d\\") if start_date <= sale_date <= end_date: product_id = row[\'product_id\'] quantity = int(row[\'quantity\']) sales_data[product_id] += quantity sorted_sales = sorted(sales_data.items(), key=lambda x: x[1], reverse=True) return sorted_sales[:top_n]"},{"question":"# Assessment Question: Context: You\'re working on a database application, and part of the task is to manage and query user information efficiently. Your goal is to implement a simple in-memory database that can store user records and perform specific queries on these records. Task: Implement the class `UserDatabase` which will allow adding new user records and querying the database based on given criteria. # Class Signature: ```python class UserDatabase: def __init__(self): pass def add_user(self, user_id: int, username: str, age: int, email: str): pass def get_users_by_age_range(self, min_age: int, max_age: int) -> list: pass def get_user_emails(self) -> list: pass ``` # Methods: - `add_user(user_id: int, username: str, age: int, email: str) -> None`: - Adds a new user record with the given parameters. - `user_id`: A unique integer identifier for the user. - `username`: A string representing the user\'s name. - `age`: An integer representing the user\'s age. - `email`: A string representing the user\'s email address. - `get_users_by_age_range(min_age: int, max_age: int) -> list`: - Returns a list of usernames of users whose ages fall within the given range, inclusive. - `get_user_emails() -> list`: - Returns a list of all user emails. # Constraints: - `user_id` will be unique and non-negative. - `username` and `email` strings will be unique for each user. - `age` will be a non-negative integer. - Users will be added before any queries occur. - The maximum number of users will not exceed 10^5. - The length of `username` and `email` will not exceed 50 characters. # Example: ```python # Example usage: db = UserDatabase() db.add_user(1, \'Alice\', 30, \'alice@example.com\') db.add_user(2, \'Bob\', 25, \'bob@example.com\') db.add_user(3, \'Charlie\', 35, \'charlie@example.com\') print(db.get_users_by_age_range(26, 35)) # Output: [\'Alice\', \'Charlie\'] print(db.get_user_emails()) # Output: [\'alice@example.com\', \'bob@example.com\', \'charlie@example.com\'] ``` Notes: - Ensure that the `add_user` method correctly stores the user information. - Implement the query methods (`get_users_by_age_range` and `get_user_emails`) to ensure efficient retrieval of data. - Assume that the initial input will be valid; you do not need to handle invalid inputs. This question assesses your ability to create classes with multiple methods, manage in-memory data, and perform searches and retrievals efficiently. Make sure your solution performs well even with the upper constraint on the number of users.","solution":"class UserDatabase: def __init__(self): self.users = {} def add_user(self, user_id: int, username: str, age: int, email: str): self.users[user_id] = { \'username\': username, \'age\': age, \'email\': email } def get_users_by_age_range(self, min_age: int, max_age: int) -> list: return [user[\'username\'] for user in self.users.values() if min_age <= user[\'age\'] <= max_age] def get_user_emails(self) -> list: return [user[\'email\'] for user in self.users.values()]"},{"question":"# Matrix Rotation by 90 Degrees Given a 2D numpy array representing an image, implement a function to rotate the image by 90 degrees clockwise. # Input Format * A 2D numpy array representing an image, with pixel values ranging from 0 to 255. # Output Format * A 2D numpy array representing the image rotated by 90 degrees clockwise. # Constraints * The input image will have dimensions m x n (1 ≤ m, n ≤ 1000). * Do not use any built-in rotation functions other than matrix operations. # Performance Requirements * Aim for an efficient implementation as the runtime should be within acceptable limits for the given constraints. # Example ```python import numpy as np def rotate_image_90_clockwise(image): m, n = image.shape rotated_image = np.zeros((n, m), dtype=image.dtype) for i in range(m): for j in range(n): rotated_image[j, m - 1 - i] = image[i, j] return rotated_image # Example usage: image = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) rotated = rotate_image_90_clockwise(image) print(rotated) ``` # Explanation Given the sample 3x3 image: ``` 1 2 3 4 5 6 7 8 9 ``` The output after rotating 90 degrees clockwise should be: ``` 7 4 1 8 5 2 9 6 3 ```","solution":"import numpy as np def rotate_image_90_clockwise(image): Rotates the given 2D numpy array image by 90 degrees clockwise. Parameters: image (np.ndarray): A 2D numpy array representing the image to rotate. Returns: np.ndarray: A 2D numpy array representing the rotated image. m, n = image.shape rotated_image = np.zeros((n, m), dtype=image.dtype) for i in range(m): for j in range(n): rotated_image[j, m - 1 - i] = image[i, j] return rotated_image"},{"question":"# Problem Statement You are provided with an integer array representing the height of mountains in a range. Your task is to identify the largest rectangular area that can be formed within the bounds of these mountains, such that the width of the rectangle is defined by the position of two different mountains and the height is defined by the shortest mountain in that range. # Function Signature Write a function: ```python def largest_rectangle_area(heights: list[int]) -> int: # Your implementation here ``` # Input and Output Input: * `heights`: A list of integers representing the height of mountains. Each element is a positive integer representing the height of the mountain at that position. Output: * An integer representing the area of the largest rectangle that can be formed within the given mountain range. # Constraints - The length of the heights list will be between 1 and 100,000. - Each value in the heights list will be a positive integer no greater than 10,000. # Examples ```python assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([1, 1, 1, 1, 1]) == 5 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([3, 1, 3, 2, 2]) == 6 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 ``` # Notes - Your function should handle edge cases such as a single element in the list, or uniform heights. - Consider the optimal algorithm for solving this problem, as the heights list can be very large.","solution":"def largest_rectangle_area(heights): Function to find the largest rectangle area in a histogram defined by heights. Uses a stack-based approach for efficient computation. # Create an empty stack. The stack holds indexes of the heights[] array. stack = [] max_area = 0 # Initialize max area as 0 # Run through all bars of input histogram index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculating the area with `heights[top_of_stack]` as the smallest height area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from the stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Return maximum area return max_area"},{"question":"# Question: Anagram Check Scenario You are tasked with developing a function to determine if two given strings are anagrams. Two strings are considered anagrams if they can be formed by rearranging the characters of each other and contain the same characters in the same frequency. Task Implement a function `are_anagrams(s1: str, s2: str) -> bool` that checks if the provided strings `s1` and `s2` are anagrams. Input * `s1` (str): The first string. Constraints: 0 ≤ len(s1) ≤ 100 * `s2` (str): The second string. Constraints: 0 ≤ len(s2) ≤ 100 Output * Returns `True` if the strings are anagrams, otherwise returns `False`. Example ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"\\", \\"\\") True ``` Constraints * Ensure the function checks all characters, including uppercase and lowercase letters. For this problem, consider the strings in a case-sensitive manner where \'A\' and \'a\' are considered different. Additional Notes * Handle edge cases such as empty strings. * Consider using efficient methods to compare character frequencies in the strings. This question assesses your ability to work with strings and implement basic algorithms for character counting and comparison.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, False otherwise. from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Question You are to implement a dynamic range sum query using a Fenwick Tree (also known as a Binary Indexed Tree). This data structure efficiently supports point updates and prefix sum queries. Objectives - Implement the `RangeSum` class to handle the required operations. - The `update` method should increment an element by a given value. - The `query` method should return the sum of elements in the specified range. Input - An initial list of integers `List[int]`. Methods to Implement 1. `__init__(self, values: List[int])` - Initializes the data structure with the given list of integers. 2. `update(self, index: int, delta: int)` - Adds `delta` to the element at the given `index`. 3. `query(self, left: int, right: int) -> int` - Returns the sum of elements in the range from `left` to `right` (inclusive). Output - The `update` method does not return anything. - The `query` method returns an integer representing the sum of elements in the specified range. Constraints - The initial list can contain up to 10^5 integers. - Each integer in the list is in the range from -10^6 to 10^6. - The number of calls to the `update` and `query` methods does not exceed 10^5. - Indices for `update` and `query` operations are 0-based. Example ```python # Sample usage values = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] range_sum = RangeSum(values) print(range_sum.query(0, 5)) # Expected: 19 (3 + 2 - 1 + 6 + 5 + 4) range_sum.update(3, 2) # Increment the 4th element (6) by 2, making it 8 print(range_sum.query(0, 5)) # Expected: 21 (3 + 2 - 1 + 8 + 5 + 4) ``` Requirements 1. Complete the implementation of the `RangeSum` class. 2. Ensure the `update` operation is performed in `O(log n)` time. 3. Ensure the `query` operation is performed in `O(log n)` time.","solution":"class RangeSum: def __init__(self, values): Initializes the data structure with the given list of integers. self.n = len(values) self.tree = [0] * (self.n + 1) self.values = [0] * self.n for i, val in enumerate(values): self.update(i, val) def update(self, index, delta): Adds `delta` to the element at the given `index`. if index < 0 or index >= self.n: return # Update values array self.values[index] += delta index += 1 # Fenwick Tree is 1-based index while index <= self.n: self.tree[index] += delta index += index & -index def prefix_sum(self, index): Helper function to get the prefix sum from 0 to index. sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def query(self, left, right): Returns the sum of elements in the range from `left` to `right` (inclusive). if left > right or left < 0 or right >= self.n: return 0 return self.prefix_sum(right + 1) - self.prefix_sum(left)"},{"question":"# Data Structures: Binary Search Tree Optimization You are required to implement an optimized version of a binary search tree (BST) that can efficiently handle dynamic insertion and inorder traversal operations. Your task is to ensure the tree balances itself upon each insertion to maintain optimal performance. Requirements: 1. **Binary Search Tree Construction and Insertion**: - Create a class `BinarySearchTree` with methods to insert elements, ensuring the tree remains balanced. - Implement the insertion method such that the tree balances itself using rotations or any self-balancing techniques, like AVL or Red-Black Trees. 2. **Inorder Traversal**: - Implement a method `inorder_traversal` that returns the elements of the tree in ascending order. Input: - A sequence of integers to be inserted into the BST. - Multiple queries to perform inorder traversal after series of insertions. Output: - For each query, return the list of elements in ascending order. Function Signature: ```python class BinarySearchTree: def __init__(self) -> None: # initializes an empty binary search tree pass def insert(self, val: int) -> None: # inserts a value into the binary search tree and balances the tree pass def inorder_traversal(self) -> List[int]: # returns a list of elements in ascending order pass ``` Constraints: 1. The number of elements to be inserted is at most 100,000. 2. Each tree node contains a unique integer. 3. Multiple (at most 1,000) traversal queries. Example: ```python bst = BinarySearchTree() values_to_insert = [50, 20, 30, 10, 40, 70, 60] for val in values_to_insert: bst.insert(val) assert bst.inorder_traversal() == [10, 20, 30, 40, 50, 60, 70] bst.insert(25) assert bst.inorder_traversal() == [10, 20, 25, 30, 40, 50, 60, 70] ``` Hints: 1. AVL Tree or Red-Black Tree properties should be used for balancing to ensure optimal insertion performance. 2. Use rotation techniques (single and double rotations) for maintaining balance. 3. Implement a recursive approach for inorder traversal for simplicity and performance.","solution":"class TreeNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right Case if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): return node.height if node else 0 def _get_balance(self, node): return self._get_height(node.left) - self._get_height(node.right) if node else 0 def inorder_traversal(self): result = [] self._inorder_traverse(self.root, result) return result def _inorder_traverse(self, node, result): if node: self._inorder_traverse(node.left, result) result.append(node.key) self._inorder_traverse(node.right, result)"},{"question":"Coding Assessment Question # Objective Write a function that implements the Connected Components Labeling algorithm for segmenting binary images. This will assess your understanding of image processing, graph algorithms, and depth-first search (DFS). # Problem Statement You are provided with a binary image represented as a two-dimensional numpy array of binary pixel values (0 for the background and 1 for the foreground). Your task is to write a function `label_connected_components` that labels the connected components in the image using the Connected Components Labeling algorithm. # Requirements 1. **Function Signature**: ```python def label_connected_components(binary_image: np.ndarray) -> np.ndarray: ``` 2. **Input Format**: - `binary_image` (numpy.ndarray): A binary image (two-dimensional array) with pixel values 0 or 1, dimensions (m, n). 3. **Output Format**: - Returns a numpy array of the same dimensions (m, n) where each connected component is marked with a unique label (positive integer). 4. **Constraints**: - The input `binary_image` will have dimensions (m, n) where 1 ≤ m, n ≤ 500. - You may assume that the binary image won\'t have noise (i.e., isolated pixels). 5. **Performance**: - Optimize the algorithm to handle images with large dimensions efficiently. - Utilize depth-first search (DFS) or breadth-first search (BFS) to traverse and label connected components effectively. # Additional Notes - You may use `scipy.ndimage.label` for validation and testing purposes, but your actual implementation must be written from scratch. - The image should be processed in a way that all eight neighboring pixels (including diagonals) are considered for connectivity. # Example ```python import numpy as np binary_image = np.array([ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1], [1, 0, 0, 0, 0] ]) labeled_image = label_connected_components(binary_image) print(\\"Labeled Image:n\\", labeled_image) ``` In the above code snippet, the function `label_connected_components` takes a binary image and returns a labeled image where each connected component is marked with a unique label. The example demonstrates a labeled image where the connected components of `1`s are uniquely labeled. # Expected Output For the provided example, one possible expected output could be: ``` Labeled Image: [[1 1 0 0 0] [0 1 0 0 2] [0 0 0 2 2] [0 0 0 2 2] [3 0 0 0 0]] ``` Here, the three connected components of the binary image have been uniquely labeled with integers 1, 2, and 3.","solution":"import numpy as np def label_connected_components(binary_image: np.ndarray) -> np.ndarray: Labels all connected components in a binary image. Parameters: binary_image (np.ndarray): A 2D binary image (0s and 1s). Returns: np.ndarray: A 2D array of the same shape as binary_image where each connected component is labeled with a unique integer. def dfs(x, y, label): # Stack for iterating through connected components stack = [(x, y)] while stack: cx, cy = stack.pop() if cx < 0 or cx >= binary_image.shape[0] or cy < 0 or cy >= binary_image.shape[1]: continue if binary_image[cx, cy] != 1 or labeled_image[cx, cy] != 0: continue # Label the current position labeled_image[cx, cy] = label # Consider all 8 neighboring positions for nx, ny in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: stack.append((cx + nx, cy + ny)) # Initialize the labeled image with zeros labeled_image = np.zeros_like(binary_image, dtype=int) current_label = 1 # Traverse the binary image for i in range(binary_image.shape[0]): for j in range(binary_image.shape[1]): if binary_image[i, j] == 1 and labeled_image[i, j] == 0: # Start a new DFS for a new component dfs(i, j, current_label) current_label += 1 return labeled_image"},{"question":"# Scrambled Sentence Unscrambler In many text processing applications, it is sometimes necessary to restore the original sentence from a scrambled one. You are tasked with writing a function `unscramble_sentence` that takes a scrambled sentence where only the words are scrambled but the letters within each word are still ordered correctly. The scrambled sentence is provided with all words in random order. Your function should return a list of all possible original sentences from the scrambled one. Consider that each scrambled sentence can result in multiple valid original sentences, and the output must reflect all valid permutations. # Function Signature ```python def unscramble_sentence(scrambled: str) -> list: pass ``` # Input * `scrambled`: A string representing the scrambled sentence, where words are separated by a single space. # Output * Returns a list of strings, each representing a possible original sentence. # Constraints * The input scrambled sentence will have between 1 and 7 words. * Each word will have between 1 and 10 lowercase letters. * The order of words is the only thing scrambled; within each word, the letters are in the correct order. # Example ```python >>> unscramble_sentence(\\"sentence this test a is\\") [\'sentence this test a is\', \'sentence this test is a\', \'sentence this a test is\', \'sentence this a is test\', \'sentence this is test a\', \'sentence this is a test\', \'sentence test this a is\', \'sentence test this is a\', \'sentence test a this is\', \'sentence test a is this\', \'sentence test is this a\', \'sentence test is a this\', \'sentence a this test is\', \'sentence a this is test\', \'sentence a test this is\', \'sentence a test is this\', \'sentence a is this test\', \'sentence a is test this\', \'sentence is this test a\', \'sentence is this a test\', \'sentence is test this a\', \'sentence is test a this\', \'sentence is a this test\', \'sentence is a test this\',...] >>> unscramble_sentence(\\"problem solve can you\\") [\'problem solve can you\', \'problem solve you can\', \'problem can solve you\', \'problem can you solve\', \'problem you solve can\', \'problem you can solve\', \'solve problem can you\', \'solve problem you can\', \'solve can problem you\', \'solve can you problem\', \'solve you problem can\', \'solve you can problem\', \'can problem solve you\', \'can problem you solve\', \'can solve problem you\', \'can solve you problem\', \'can you problem solve\', \'can you solve problem\', \'you problem solve can\', \'you problem can solve\', \'you solve problem can\', \'you solve can problem\', \'you can problem solve\', \'you can solve problem\'] ``` This new question aligns with the original set by engaging similar skills in string manipulation, algorithm design, and generating permutations efficiently. The increased complexity lies in generating permutations of strings and considering multiple outputs, seamlessly integrating with the original assessment.","solution":"from itertools import permutations def unscramble_sentence(scrambled: str) -> list: Given a scrambled sentence, return all possible original sentences. The order of words can be in any permutation. :param scrambled: A string with words in scrambled order. :return: A list of possible original sentences. words = scrambled.split() permuted_sentences = [\' \'.join(perm) for perm in permutations(words)] return permuted_sentences"},{"question":"Financial Transaction Categorizer # Context: You are provided with a dataset of financial transactions in the form of a list of dictionaries. Each transaction includes the amount, date, and description. Your task is to implement a function that categorizes these transactions based on predefined keywords found in the description. # Task: You need to write a function `categorize_transactions` that categorizes transactions into predefined categories using keywords from the description field. # Requirements: 1. **Function Signature**: ```python def categorize_transactions(transactions: list, categories: dict) -> dict: pass ``` 2. **Input**: - `transactions` (list): A list of dictionaries, where each dictionary represents a transaction with keys `amount` (float), `date` (str), and `description` (str). - `categories` (dict): A dictionary where the keys are category names (str) and the values are lists of keywords (list of str). 3. **Output**: - A dictionary where the keys are category names and the values are lists of transactions that fall under each category. # Constraints: - If a transaction matches multiple categories, it should only be added to the first matching category. - A transaction description can match a keyword partially; it does not need to be an exact match. - Transactions that do not match any category should be under the \\"Uncategorized\\" category. # Example: ```python # Sample transaction data transactions = [ {\\"amount\\": 50.0, \\"date\\": \\"2023-07-01\\", \\"description\\": \\"Grocery Store\\"}, {\\"amount\\": 15.0, \\"date\\": \\"2023-07-02\\", \\"description\\": \\"Coffee Shop\\"}, {\\"amount\\": 200.0, \\"date\\": \\"2023-07-03\\", \\"description\\": \\"Online Subscription\\"}, {\\"amount\\": 70.0, \\"date\\": \\"2023-07-04\\", \\"description\\": \\"Gas Station\\"}, ] # Sample categories categories = { \\"Food\\": [\\"Grocery\\", \\"Coffee\\"], \\"Transportation\\": [\\"Gas\\", \\"Uber\\"], \\"Entertainment\\": [\\"Subscription\\", \\"Movie\\"] } categorized_transactions = categorize_transactions(transactions, categories) print(categorized_transactions) # Expected output: # { # \\"Food\\": [ # {\\"amount\\": 50.0, \\"date\\": \\"2023-07-01\\", \\"description\\": \\"Grocery Store\\"}, # {\\"amount\\": 15.0, \\"date\\": \\"2023-07-02\\", \\"description\\": \\"Coffee Shop\\"} # ], # \\"Transportation\\": [ # {\\"amount\\": 70.0, \\"date\\": \\"2023-07-04\\", \\"description\\": \\"Gas Station\\"} # ], # \\"Entertainment\\": [ # {\\"amount\\": 200.0, \\"date\\": \\"2023-07-03\\", \\"description\\": \\"Online Subscription\\"} # ], # \\"Uncategorized\\": [] # } ``` # Hints: - Consider using string matching functions available in Python to identify keywords within the transaction descriptions. - Make sure the function can handle varying transaction sizes and keyword counts efficiently. - Validate your implementation against cases where none of the transactions match any of the predefined keywords to ensure they are properly categorized as \\"Uncategorized\\".","solution":"def categorize_transactions(transactions, categories): Categorizes bank transactions into predefined categories based on keywords in the description. Parameters: transactions (list): List of transactions. Each transaction is a dictionary with \'amount\', \'date\', and \'description\'. categories (dict): A dictionary where keys are category names and values are lists of keywords. Returns: dict: A dictionary where keys are category names and values are lists of transactions for respective categories. categorized_transactions = {category: [] for category in categories} categorized_transactions[\'Uncategorized\'] = [] for transaction in transactions: added = False for category, keywords in categories.items(): if any(keyword.lower() in transaction[\'description\'].lower() for keyword in keywords): categorized_transactions[category].append(transaction) added = True break if not added: categorized_transactions[\'Uncategorized\'].append(transaction) return categorized_transactions"},{"question":"# Coding Question - Design and Implement a Min Heap Context You are required to design and implement a Min Heap, a complete binary tree where the value of each node is less than or equal to the values of its children. The root node, therefore, contains the smallest value, making it useful for applications like priority queues. Task Implement a `MinHeap` class in Python with the following methods: 1. **`__init__(self)`**: Initializes the min heap with an empty list. 2. **`insert(self, item: int) -> None`**: Inserts an item into the heap, maintaining the min heap property. 3. **`extract_min(self) -> int`**: Removes and returns the smallest item from the heap. If the heap is empty, raise an `IndexError`. 4. **`peek_min(self) -> int`**: Returns the smallest item from the heap without removing it. If the heap is empty, raise an `IndexError`. 5. **`is_empty(self) -> bool`**: Returns `True` if the heap is empty, otherwise `False`. 6. **`__len__(self) -> int`**: Returns the number of elements in the heap. Input and Output Formats: - The constructor initialization has no parameters. - `insert` method will have an integer parameter `item`. - `extract_min` and `peek_min` will return an integer. - `is_empty` will return a boolean value. - `__len__` returns an integer representing the number of elements in the heap. Example: ```python heap = MinHeap() print(heap.is_empty()) # True heap.insert(5) heap.insert(3) heap.insert(8) print(heap.peek_min()) # 3 print(len(heap)) # 3 print(heap.extract_min()) # 3 print(len(heap)) # 2 print(heap.peek_min()) # 5 print(heap.is_empty()) # False heap.insert(2) print(heap.peek_min()) # 2 ``` Constraints: - All values inserted will be integers (1 <= value <= 10^5). - Ensure all exceptions are properly raised for invalid operations (e.g., extracting from or peeking into an empty heap). Performance Requirements: - Insertion and extraction operations should be performed in O(log n) time, where `n` is the number of elements in the heap.","solution":"class MinHeap: def __init__(self): Initializes the min heap with an empty list. self.heap = [] def is_empty(self) -> bool: Returns True if the heap is empty, otherwise False. return len(self.heap) == 0 def __len__(self) -> int: Returns the number of elements in the heap. return len(self.heap) def _heapify_up(self, index): Ensures the heap property is maintained after insertion. parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): Ensures the heap property is maintained after extraction. smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def insert(self, item: int) -> None: Inserts an item into the heap, maintaining the min heap property. self.heap.append(item) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: Removes and returns the smallest item from the heap. If the heap is empty, raise an IndexError. if self.is_empty(): raise IndexError(\\"extract_min from empty heap\\") min_item = self.heap[0] last_item = self.heap.pop() if not self.is_empty(): self.heap[0] = last_item self._heapify_down(0) return min_item def peek_min(self) -> int: Returns the smallest item from the heap without removing it. If the heap is empty, raise an IndexError. if self.is_empty(): raise IndexError(\\"peek_min from empty heap\\") return self.heap[0]"},{"question":"# Sum of Subarray Minimums **Objective**: In this task, you will implement a function that calculates the sum of the minimum values of all subarrays of a given array of integers. # Problem Statement: Given an integer array `arr` of size `n`, your task is to find the sum of the minimum value of each possible contiguous subarray of `arr`. # Your Task: 1. Implement a function `sum_of_subarray_mins(arr: List[int]) -> int` that takes an array of integers and returns the sum of the minimum values of all subarrays. # Input: - A list `arr` of integers where `1 <= len(arr) <= 30000` and `1 <= arr[i] <= 30000`. # Output: - Returns (int): The sum of the minimum values of all subarrays of the array. # Examples: Example 1: ```python arr = [3, 1, 2, 4] ``` The array has the following subarrays: - [3]: min is 3 - [1]: min is 1 - [2]: min is 2 - [4]: min is 4 - [3, 1]: min is 1 - [1, 2]: min is 1 - [2, 4]: min is 2 - [3, 1, 2]: min is 1 - [1, 2, 4]: min is 1 - [3, 1, 2, 4]: min is 1 Sum of these minimums = 1 + 3 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17. Running `sum_of_subarray_mins([3, 1, 2, 4])` should return `17`. Example 2: ```python arr = [11, 81, 94, 43, 3] ``` Running `sum_of_subarray_mins([11, 81, 94, 43, 3])` should return `444`. # Specification: ```python from typing import List def sum_of_subarray_mins(arr: List[int]) -> int: Calculate the sum of the minimum values of all subarrays of the array. ``` # Notes: - Ensure the solution is optimized to handle the upper limits of the input size effectively. - Be mindful of time complexity and aim for an optimal approach leveraging stack or dynamic programming techniques. - Implement error handling and edge case evaluation as necessary. # Testing: You should provide unit tests to validate the correctness of the `sum_of_subarray_mins` function, ensuring it handles small and large input sizes efficiently.","solution":"from typing import List def sum_of_subarray_mins(arr: List[int]) -> int: MOD = 10**9 + 7 stack = [] result = 0 curr_sum = 0 for i in range(len(arr)): count = 1 while stack and stack[-1][0] >= arr[i]: val, cnt = stack.pop() curr_sum -= val * cnt count += cnt stack.append((arr[i], count)) curr_sum += arr[i] * count result = (result + curr_sum) % MOD return result"},{"question":"# Problem Statement You are given a string which contains a complex mathematical expression containing positive integers, addition (\'+\'), subtraction (\'-\'), multiplication (\'*\'), division (\'/\'), and parentheses. Implement the function `evaluate_expression` which evaluates the given string and returns the computed result as an integer. # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input - A string `expression` containing a valid mathematical expression with the length of (1 leq len(expression) leq 10^4). - The expression will be a combination of numbers and operators ( + , - , * , / , ( , ) ). - The division \'/\' operator should perform integer division. # Output - An integer that is the result of evaluating the mathematical expression. # Examples ```python assert evaluate_expression(\\"3+(2*2)\\") == 7 assert evaluate_expression(\\" 3/2 \\") == 1 assert evaluate_expression(\\" 3 + 5 / 2 \\") == 5 assert evaluate_expression(\\"10-(2+3*2)\\") == 2 ``` # Constraints - Parenthesis are used to denote precedence and must be correctly paired. - The operators must follow the standard mathematical precedence: Parentheses > Multiplication & Division > Addition & Subtraction. - Divisions should truncate towards zero. # Notes - Ensure that your function handles spaces in the input expression correctly as given in the examples. - Any invalid input is out of the problem scope. # Edge Cases - The expression might include spaces between numbers and operators. - The input might have nested parentheses. - Division by zero is not a valid input case and can be ignored. Assume inputs will not include this scenario.","solution":"def evaluate_expression(expression: str) -> int: def helper(tokens): stack = [] num = 0 sign = \\"+\\" while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \\"(\\": num = helper(tokens) if (not token.isdigit() and token != \\" \\") or len(tokens) == 0: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = token num = 0 if token == \\")\\": break return sum(stack) tokens = [] i = 0 while i < len(expression): if expression[i].isdigit(): num_str = [] while i < len(expression) and expression[i].isdigit(): num_str.append(expression[i]) i += 1 tokens.append(\\"\\".join(num_str)) else: tokens.append(expression[i]) i += 1 return helper(tokens)"},{"question":"# Coding Assessment Question You are given a rotated sorted array of unique integers. The array is originally sorted in ascending order, but it has been rotated at some pivot unknown to you beforehand. Your task is to implement an efficient algorithm to find the index of a given target value in the array. If the target is not present, return -1. Function Signature ```python def search_rotated_array(nums: list[int], target: int) -> int: pass ``` Input - A list of integers `nums` (1 ≤ len(nums) ≤ 10^5) which is a rotated sorted array of unique elements. - An integer `target` which you need to find in the array. Output - An integer representing the index of the target in the array. If the target is not present, return -1. # Constraints 1. The array contains unique integers. 2. The array is rotated at some pivot. # Examples ```python >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_rotated_array([1], 0) -1 >>> search_rotated_array([1], 1) 0 >>> search_rotated_array([3, 4, 5, 6, 7, 1, 2], 1) 5 >>> search_rotated_array([5, 6, 7, 0, 1, 2, 3, 4], 7) 2 ``` # Notes 1. Your solution must run in O(log n) time complexity. 2. You need to handle cases where the array contains only one element. 3. You can assume that all integers in the array are unique.","solution":"def search_rotated_array(nums: list[int], target: int) -> int: Returns the index of target in a rotated sorted array or -1 if target is not present. The function runs in O(log n) time complexity. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Longest Zigzag Subsequence You are given an integer array. Your task is to find the length of the longest zigzag subsequence in the array. A sequence is called a zigzag sequence if the differences between successive elements strictly alternate between positive and negative. **Function Signature**: ```python def longest_zigzag_subsequence(arr: List[int]) -> int: pass ``` # Description: - **Input**: A list of integers `arr` with length `n` where `1 <= n <= 1000` and `-10^4 <= arr[i] <= 10^4`. - **Output**: Return the length of the longest zigzag subsequence in the given array. # Constraints: - A zigzag subsequence can start from any index within the array. - The sequence must have at least one element. - Optimize for time complexity as the array length can be up to 1000. # Examples: 1. `longest_zigzag_subsequence([1, 7, 4, 9, 2, 5])` should return `6`. (The entire array is a zigzag sequence: `1, 7, 4, 9, 2, 5`) 2. `longest_zigzag_subsequence([1, 4, 7, 2, 5])` should return `4`. (A possible zigzag sequence is `1, 4, 2, 5`) 3. `longest_zigzag_subsequence([10, 22, 9, 33, 49, 50, 31, 60])` should return `6`. (A possible zigzag sequence is `10, 22, 9, 33, 31, 60`) # Notes: - Consider how to efficiently determine if the differences alternate between positive and negative. - A dynamic programming approach may be useful to solve this problem within the constraints. - Test your function with various edge cases to ensure its correctness and efficiency. Implement the function `longest_zigzag_subsequence` that meets these requirements. Test your function to ensure it works correctly for a variety of inputs.","solution":"from typing import List def longest_zigzag_subsequence(arr: List[int]) -> int: if len(arr) == 1: return 1 # Initializing DP arrays for up and down sequences up = [1] * len(arr) down = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"# Problem Statement You are required to implement a function that finds the longest palindromic substring in a given text string using the Manacher\'s Algorithm. Your solution should be efficient and able to handle large input sizes within the constraints provided. # Function Signature ```python def longest_palindromic_substring(text: str) -> str: Finds the longest palindromic substring within the text. Parameters: text (str): The input string to search for the longest palindromic substring. Returns: str: The longest palindromic substring found in the text. pass ``` # Input - `text`: A string of length n (1 ≤ n ≤ 10^5), representing the text in which to search for the longest palindromic substring. # Output - A single string, representing the longest palindromic substring found within the input text. # Constraints 1. The text consists of only lowercase English letters. 2. If there are multiple substrings of maximum length, return the first one found. # Examples ```python # Example 1 text = \\"babad\\" assert longest_palindromic_substring(text) in [\\"bab\\", \\"aba\\"] # Example 2 text = \\"cbbd\\" assert longest_palindromic_substring(text) == \\"bb\\" # Example 3 text = \\"a\\" assert longest_palindromic_substring(text) == \\"a\\" # Example 4 text = \\"ac\\" assert longest_palindromic_substring(text) == \\"a\\" ``` # Performance Requirement The implementation should run within O(n) time complexity, making use of Manacher\'s Algorithm for finding the longest palindromic substring efficiently.","solution":"def longest_palindromic_substring(text: str) -> str: Finds the longest palindromic substring within the text using Manacher\'s Algorithm. Parameters: text (str): The input string to search for the longest palindromic substring. Returns: str: The longest palindromic substring found in the text. def preprocess(s: str) -> str: Preprocessing the string by inserting \'#\' in between each character and adding boundary characters. return \'^#\' + \'#\'.join(s) + \'#\' T = preprocess(text) n = len(T) P = [0] * n C = R = 0 for i in range(1, n - 1): mirr = 2 * C - i if i < R: P[i] = min(R - i, P[mirr]) while T[i + P[i] + 1] == T[i - P[i] - 1]: P[i] += 1 if i + P[i] > R: C = i R = i + P[i] max_len = max(P) center_index = P.index(max_len) start = (center_index - max_len) // 2 return text[start:start + max_len]"},{"question":"# Problem Statement Implement a custom data structure called `CustomQueue` that combines the properties of a queue and enables additional functionalities such as retrieving the minimum element, reversing the queue, and shuffling the elements randomly. # Requirements 1. **Class Definition**: Define the class `CustomQueue`. 2. **Enqueue Method**: Implement the `enqueue` method to add an element to the end of the queue. 3. **Dequeue Method**: Implement the `dequeue` method to remove and return the element from the front of the queue. 4. **Length Method**: Implement the `__len__` method to return the number of elements in the queue. 5. **Peek Method**: Implement a `peek` method to view the front element without removing it. 6. **Minimum Method**: Implement a `get_min` method to retrieve the minimum element in the queue. 7. **Reverse Method**: Implement a `reverse` method to reverse the order of elements in the queue. 8. **Shuffle Method**: Implement a `shuffle` method to randomly shuffle the elements in the queue. 9. **Edge Cases Handling**: Properly handle edge cases such as dequeuing from an empty queue. # Function Signature ```python import random from typing import List class CustomQueue: def __init__(self): self.queue = [] def enqueue(self, value: int) -> None: # Your code here def dequeue(self) -> int: # Your code here def peek(self) -> int: # Your code here def get_min(self) -> int: # Your code here def reverse(self) -> None: # Your code here def shuffle(self) -> None: # Your code here def __len__(self) -> int: # Your code here ``` # Input and Output * `enqueue(value: int) -> None`: Adds value to the end of the queue. * `dequeue() -> int`: Removes and returns the element from the front of the queue. * `peek() -> int`: Returns the front element without removing it. * `get_min() -> int`: Returns the minimum element in the queue. * `reverse() -> None`: Reverses the order of elements in the queue. * `shuffle() -> None`: Randomly shuffles the elements in the queue. * `__len__() -> int`: Returns the number of elements in the queue. # Example ```python queue = CustomQueue() queue.enqueue(15) queue.enqueue(34) queue.enqueue(8) queue.enqueue(22) print(queue.peek()) # Output: 15 print(queue.get_min()) # Output: 8 queue.reverse() print(queue.dequeue()) # Output: 22 (since the queue is reversed) queue.shuffle() print(len(queue)) # Output: 3 ``` # Performance Requirements * Ensure that enqueue, dequeue, peek, and length operations are performed in O(1) time complexity. * Implementing get_min, reverse, and shuffle should be efficient but can have up to O(n) time complexity. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time and space complexity of the solution must meet the requirements. * **Robustness**: Handling edge cases and constraints properly. * **Code Quality**: Clean, readable, and maintainable code.","solution":"import random from typing import List class CustomQueue: def __init__(self): self.queue = [] def enqueue(self, value: int) -> None: Add an element to the end of the queue. self.queue.append(value) def dequeue(self) -> int: Remove and return the element from the front of the queue. Raises an IndexError if the queue is empty. if not self.queue: raise IndexError(\\"dequeue from an empty queue\\") return self.queue.pop(0) def peek(self) -> int: Return the front element without removing it. Raises an IndexError if the queue is empty. if not self.queue: raise IndexError(\\"peek from an empty queue\\") return self.queue[0] def get_min(self) -> int: Retrieve the minimum element in the queue. Raises a ValueError if the queue is empty. if not self.queue: raise ValueError(\\"min from an empty queue\\") return min(self.queue) def reverse(self) -> None: Reverse the order of elements in the queue. self.queue.reverse() def shuffle(self) -> None: Randomly shuffle the elements in the queue. random.shuffle(self.queue) def __len__(self) -> int: Return the number of elements in the queue. return len(self.queue)"},{"question":"# Dynamic Programming: Coin Change Problem In this challenge, you are required to implement an algorithm that calculates the minimum number of coins needed to make a given amount of money using an unlimited supply of coins of given denominations. Implement the following function: 1. `min_coins(coins: List[int], amount: int) -> int`: Finds the minimum number of coins needed to make the specified amount. # Expected Input and Output - The function takes two parameters: - `coins`: A list of integers representing the denominations of the coins. - `amount`: An integer representing the target amount of money. - **Input constraint**: - `1 <= len(coins) <= 100` (The number of different denominations) - `1 <= coins[i] <= 1000` for each coin in `coins` - `0 <= amount <= 10,000` - The function should return an integer representing the minimum number of coins needed to make up the amount. If it is not possible to make that amount with the given denominations, return -1. # Example Example 1: ``` coins = [1, 2, 5] amount = 11 ``` - Expected output: ``` 3 (11 can be made with three coins: 5 + 5 + 1) ``` Example 2: ``` coins = [2] amount = 3 ``` - Expected output: ``` -1 (since it\'s not possible to sum up to 3 with only denomination 2) ``` Example 3: ``` coins = [1] amount = 0 ``` - Expected output: ``` 0 (0 amount of money requires 0 coins) ``` # Constraints: - You need to utilize dynamic programming to achieve efficient computation. - The solution should handle the maximum input sizes within reasonable time limits. Implement the function ensuring it adheres to the above specifications and efficiently handles the given constraints for optimal performance.","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Finds the minimum number of coins needed to make the specified amount. # Initialize the dp array with a value greater than possible maximum coins required dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float(\'inf\'): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Question You are tasked with implementing a function to calculate the determinant of a square matrix using both iterative and recursive methods. Your implementation should handle various sizes of matrices gracefully and raise errors for invalid inputs. Function Signature ```python def determinant_iterative(matrix: List[List[float]]) -> float: def determinant_recursive(matrix: List[List[float]]) -> float: ``` Requirements: 1. **Function 1**: `determinant_iterative(matrix: List[List[float]]) -> float` - Use an iterative approach (preferably Gaussian elimination). - Should raise `ValueError` if the matrix is not square. - Should handle matrices with dimensions up to `10x10` efficiently. 2. **Function 2**: `determinant_recursive(matrix: List[List[float]]) -> float` - Use recursion to calculate the determinant based on the Laplace expansion. - Should raise `ValueError` if the matrix is not square. - Should handle matrices with dimensions up to `5x5` efficiently. Input - `matrix`: A list of lists representing a square matrix, `matrix[i][j]` being the element at the i-th row and j-th column. Output - Returns a float value representing the determinant of the provided matrix. Constraints - The matrix should be a square matrix (`n x n`). - Performance should be optimized especially for large matrices up to `10x10` for the iterative approach and up to `5x5` for the recursive approach. Example ```python >>> determinant_iterative([[1, 2], [3, 4]]) -2.0 ``` ```python >>> determinant_recursive([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) 1.0 ``` Scenario Consider implementing your solution while keeping in mind numerical accuracy, edge cases like singular matrices, and performance impacts. Check for invalid matrix shapes and handle them appropriately.","solution":"from typing import List def determinant_iterative(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix using Gaussian elimination. if len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square\\") n = len(matrix) det = 1 for i in range(n): if matrix[i][i] == 0: for k in range(i + 1, n): if matrix[k][i] != 0: matrix[i], matrix[k] = matrix[k], matrix[i] det *= -1 break else: return 0 for j in range(i + 1, n): ratio = matrix[j][i] / matrix[i][i] for k in range(i, n): matrix[j][k] -= ratio * matrix[i][k] for i in range(n): det *= matrix[i][i] return det def determinant_recursive(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix using the Laplace expansion. n = len(matrix) if n != len(matrix[0]): raise ValueError(\\"Matrix must be square\\") if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): minor = [[matrix[i][j] for j in range(n) if j != c] for i in range(1, n)] det += ((-1) ** c) * matrix[0][c] * determinant_recursive(minor) return det"},{"question":"# Question: # String Reversal with Constraints You are given a string consisting of lowercase alphabets and special characters. You need to reverse the string but keep all the special characters in their original positions. Write a function `reverse_string_with_constraints(s: str) -> str` that takes a string `s` as input and returns the reversed string while maintaining the position of special characters. # Input: - `s` (str): A string containing lowercase alphabets and special characters. (1 <= len(s) <= 100) # Output: - (str): The reversed string with special characters in their original positions. # Example: ```python # Example Case 1 # Input: s = \\"a,bc\\" # Output: \\"c,ba\\" # Example Case 2 # Input: s = \\"ab!dc\\" # Output: \\"cd!ba\\" ``` # Constraints: - Keep special characters in their original positions. - Only reverse the alphabetical characters. # Performance Requirement: Ensure your algorithm runs efficiently for the maximum input size. # Hints: 1. Consider using two-pointer technique. 2. Skip special characters when swapping. Write your function implementation below: ```python def reverse_string_with_constraints(s: str) -> str: l, r = 0, len(s) - 1 s = list(s) while l < r: if not s[l].isalpha(): l += 1 elif not s[r].isalpha(): r -= 1 else: s[l], s[r] = s[r], s[l] l += 1 r -= 1 return \'\'.join(s) # Testing the function print(reverse_string_with_constraints(\\"a,bc\\")) # Output: \\"c,ba\\" print(reverse_string_with_constraints(\\"ab!dc\\")) # Output: \\"cd!ba\\" ```","solution":"def reverse_string_with_constraints(s: str) -> str: l, r = 0, len(s) - 1 s = list(s) while l < r: if not s[l].isalpha(): l += 1 elif not s[r].isalpha(): r -= 1 else: s[l], s[r] = s[r], s[l] l += 1 r -= 1 return \'\'.join(s)"},{"question":"# DNA Sequence Alignment - Dynamic Programming You are provided with a partial implementation of a dynamic programming algorithm designed for aligning two DNA sequences by minimizing the edit distance (number of operations required to transform one sequence into another). Your task is to complete the implementation to ensure it calculates the alignment correctly. **Task** Implement the `align_sequences` function using the following steps: 1. Create a 2D matrix to store the scores of alignments. 2. Initialize the first row and column of the matrix. 3. Fill the rest of the matrix with alignment scores based on given cost parameters for match, mismatch, and gap. 4. Trace back through the matrix to find the optimal alignment between the two sequences. **Function Signature** ```python def align_sequences(seq1: str, seq2: str, match: int = 1, mismatch: int = -1, gap: int = -2) -> tuple[int, str, str]: ``` # Input * `seq1` (str): The first DNA sequence to align. * `seq2` (str): The second DNA sequence to align. * `match` (int): The score for a match between two characters. * `mismatch` (int): The score for a mismatch between two characters. * `gap` (int): The penalty for introducing a gap in the alignment. # Output * A tuple containing: * The optimal alignment score. * The aligned version of the first sequence. * The aligned version of the second sequence. # Constraints * Ensure that both input sequences only contain valid DNA nucleotides (A, C, G, T). * The length of each sequence should be between 1 and 1000 characters. # Example ```python seq1 = \\"ACGT\\" seq2 = \\"ACCT\\" result = align_sequences(seq1, seq2) print(result) # Output should be a tuple like (2, \\"ACGT\\", \\"ACCT\\") ``` **Notes** * Use the provided penalty scores to calculate the alignment matrix. * Consider edge cases like: * Sequences of different lengths. * Sequences with no matching characters, requiring maximum gap penalties. # Optimizations * Consider using space-efficient techniques to handle large sequences, such as banded dynamic programming or Hirschberg\'s algorithm for optimal space usage.","solution":"def align_sequences(seq1: str, seq2: str, match: int = 1, mismatch: int = -1, gap: int = -2) -> tuple[int, str, str]: m = len(seq1) n = len(seq2) # Create a 2D matrix for the dynamic programming table dp = [[0 for j in range(n + 1)] for i in range(m + 1)] # Initialize the first row and column of the matrix for i in range(m + 1): dp[i][0] = i * gap for j in range(n + 1): dp[0][j] = j * gap # Fill the rest of the matrix with alignment scores for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i-1] == seq2[j-1]: score = match else: score = mismatch dp[i][j] = max( dp[i-1][j-1] + score, # match or mismatch dp[i-1][j] + gap, # gap in seq2 dp[i][j-1] + gap # gap in seq1 ) # Trace back through the matrix to find the optimal alignment aligned_seq1, aligned_seq2 = \\"\\", \\"\\" i, j = m, n while i > 0 and j > 0: current_score = dp[i][j] if seq1[i-1] == seq2[j-1]: score = match else: score = mismatch if current_score == dp[i-1][j-1] + score: aligned_seq1 = seq1[i-1] + aligned_seq1 aligned_seq2 = seq2[j-1] + aligned_seq2 i -= 1 j -= 1 elif current_score == dp[i-1][j] + gap: aligned_seq1 = seq1[i-1] + aligned_seq1 aligned_seq2 = \'-\' + aligned_seq2 i -= 1 else: aligned_seq1 = \'-\' + aligned_seq1 aligned_seq2 = seq2[j-1] + aligned_seq2 j -= 1 # Add remaining sequence with gaps if any while i > 0: aligned_seq1 = seq1[i-1] + aligned_seq1 aligned_seq2 = \'-\' + aligned_seq2 i -= 1 while j > 0: aligned_seq1 = \'-\' + aligned_seq1 aligned_seq2 = seq2[j-1] + aligned_seq2 j -= 1 alignment_score = dp[m][n] return alignment_score, aligned_seq1, aligned_seq2"},{"question":"# K-Nearest Neighbors (KNN) Classifier Implementation You are tasked with implementing a simple K-Nearest Neighbors (KNN) classifier from scratch to classify a given dataset into two classes. **Objective**: Write a Python function named `knn_classifier` that classifies data points based on the KNN algorithm and evaluates its performance using accuracy. **Function Signature**: ```python def knn_classifier(train_data: List[List[float]], train_labels: List[int], test_data: List[List[float]], k: int) -> float: pass ``` **Input**: - `train_data` (List[List[float]]): A list of training data points, each represented as a list of feature values (floats). - `train_labels` (List[int]): A list of integer labels corresponding to the training data. Each label is either 0 or 1. - `test_data` (List[List[float]]): A list of test data points to classify. - `k` (int): The number of nearest neighbors to consider for classification. **Output**: - Returns a float representing the accuracy of the classifier on the test data. **Constraints**: - The number of features in each data point will be between 2 and 20. - The number of training and test data points will not exceed 5000. - `k` will be a positive integer not greater than the number of training data points. - Ensure efficient handling of distance calculations. **Performance**: - Aim for a time complexity of O(MN) per test point, where M is the number of training points and N is the number of features. - Space complexity should be managed carefully to avoid excessive memory usage. **Python Libraries**: - You may use standard libraries like math and collections but should avoid using any pre-built machine learning libraries such as scikit-learn. # Context: The K-Nearest Neighbors classifier is a fundamental machine learning algorithm used for classification tasks. It is easy to implement and understand but requires optimization for efficient large-scale usage. This exercise will help in understanding data classification, distance metrics, and performance evaluation in machine learning.","solution":"import math from collections import Counter from typing import List def euclidean_distance(point1: List[float], point2: List[float]) -> float: Calculates the Euclidean distance between two points. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def knn_classifier(train_data: List[List[float]], train_labels: List[int], test_data: List[List[float]], k: int) -> float: def classify_point(test_point: List[float]) -> int: # Calculate distances from the test point to all training points distances = [(euclidean_distance(test_point, train_point), label) for train_point, label in zip(train_data, train_labels)] # Sort by distance and get the labels of the k nearest neighbors nearest_neighbors = sorted(distances, key=lambda x: x[0])[:k] nearest_labels = [label for _, label in nearest_neighbors] # Determine the most common label among the nearest neighbors most_common = Counter(nearest_labels).most_common(1) return most_common[0][0] correct_predictions = 0 for test_point in test_data: predicted_label = classify_point(test_point) # Here, assume that test points have associated labels for accuracy calculation actual_label = test_point[-1] if predicted_label == actual_label: correct_predictions += 1 accuracy = correct_predictions / len(test_data) return accuracy"},{"question":"# Voting System Implementation **Context:** You are a software engineer tasked with developing a simple voting system for a community website. This voting system allows users to upvote or downvote content. Each user can vote on each piece of content only once, and their vote can be either an upvote (+1) or a downvote (-1). If a user changes their vote, the previous vote should be replaced with the new vote. **Objective:** Write a class `VotingSystem` that allows managing votes for various content. This system should be able to register and update votes, calculate the total score for a given content, and get the vote details for each user. **Class Definition:** ```python class VotingSystem: def __init__(self): # Initializes the voting system pass def add_vote(self, user_id: str, content_id: str, vote: int): # Adds or updates the vote for the given user and content pass def get_score(self, content_id: str) -> int: # Returns the total score for the specified content pass def get_user_votes(self, user_id: str) -> dict: # Returns all vote details for the specified user as a dictionary pass ``` **Inputs:** * `user_id (str)`: A string representing the ID of the user. * `content_id (str)`: A string representing the ID of the content. * `vote (int)`: An integer representing the vote, which can be either 1 (upvote) or -1 (downvote). **Outputs:** * `add_vote`: No output. This method adds or updates the user\'s vote for the specified content. * `get_score`: Returns an integer representing the total score for the content (sum of upvotes and downvotes). * `get_user_votes`: Returns a dictionary where keys are `content_id`s and values are either 1 or -1 representing the user\'s votes. **Constraints:** * If a vote value other than 1 or -1 is provided, raise a `ValueError` with the message \\"vote must be 1 (upvote) or -1 (downvote)\\". * Ensure thread-safety if implemented in a multi-threaded environment. * Avoid using any external libraries for managing the state or handling votes. **Example Usage:** ```python voting_system = VotingSystem() voting_system.add_vote(\\"user1\\", \\"content1\\", 1) voting_system.add_vote(\\"user1\\", \\"content2\\", -1) voting_system.add_vote(\\"user2\\", \\"content1\\", 1) voting_system.add_vote(\\"user1\\", \\"content1\\", -1) # User1 changes their vote print(voting_system.get_score(\\"content1\\")) # Output should be 0 (1 from user2, -1 from user1) print(voting_system.get_user_votes(\\"user1\\")) # Output should be {\\"content1\\": -1, \\"content2\\": -1} ``` **Notes:** * Consider the efficiency of your solution, especially with a large number of votes and content items. * Handle potential edge cases such as invalid vote values or non-existent content/user IDs gracefully.","solution":"class VotingSystem: def __init__(self): self.votes = {} # {content_id: {user_id: vote}} self.user_votes = {} # {user_id: {content_id: vote}} def add_vote(self, user_id: str, content_id: str, vote: int): if vote not in (1, -1): raise ValueError(\\"vote must be 1 (upvote) or -1 (downvote)\\") if content_id not in self.votes: self.votes[content_id] = {} if user_id in self.votes[content_id]: old_vote = self.votes[content_id][user_id] else: old_vote = 0 self.votes[content_id][user_id] = vote if user_id not in self.user_votes: self.user_votes[user_id] = {} self.user_votes[user_id][content_id] = vote # Adjust score if the vote changes if old_vote != vote: self.votes[content_id][user_id] = vote def get_score(self, content_id: str) -> int: if content_id not in self.votes: return 0 return sum(self.votes[content_id].values()) def get_user_votes(self, user_id: str) -> dict: return self.user_votes.get(user_id, {})"},{"question":"# Sudoku Solver You are required to implement a Sudoku solver that fills in the missing numbers in a given 9x9 Sudoku grid. Your implementation will help assess your abilities to handle backtracking and constraint satisfaction problems in algorithm design. Problem Statement Create a function `solve_sudoku(grid)` that receives a partially filled 9x9 Sudoku grid and modifies it to the solution in-place. # Function Definition: 1. **`solve_sudoku(grid)`**: - **Input**: A 2D list (list of lists) of integers representing a partially filled 9x9 Sudoku grid. Empty cells are denoted by the number 0. - **Output**: The function should modify the grid in-place to solve the Sudoku puzzle. - **Constraints**: The input grid will always be a valid 9x9 grid with possible solutions. Example: ```python grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(grid) for row in grid: print(row) ``` Expected Output: ```python [5, 3, 4, 6, 7, 8, 9, 1, 2] [6, 7, 2, 1, 9, 5, 3, 4, 8] [1, 9, 8, 3, 4, 2, 5, 6, 7] [8, 5, 9, 7, 6, 1, 4, 2, 3] [4, 2, 6, 8, 5, 3, 7, 9, 1] [7, 1, 3, 9, 2, 4, 8, 5, 6] [9, 6, 1, 5, 3, 7, 2, 8, 4] [2, 8, 7, 4, 1, 9, 6, 3, 5] [3, 4, 5, 2, 8, 6, 1, 7, 9] ``` # Additional Requirements: - Implement a function to check if a given number can be placed in a specific cell without violating Sudoku rules (rows, columns, and 3x3 subgrids). - The solver should use a backtracking algorithm to ensure that it can solve any valid Sudoku puzzle successfully. - Handle edge cases such as a completely filled grid or a grid without any zeros initially. Use this problem to showcase your understanding of recursive algorithms and constraint satisfaction. Make sure to test your function with various inputs to verify its correctness.","solution":"def is_valid_move(grid, row, col, num): Check if placing num at grid[row][col] is valid according to Sudoku rules. for i in range(9): # Check the row if grid[row][i] == num: return False # Check the column if grid[i][col] == num: return False # Check the 3x3 subgrid if grid[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num: return False return True def solve_sudoku(grid): Solves the given Sudoku puzzle in-place using backtracking. for row in range(9): for col in range(9): if grid[row][col] == 0: # Find an empty cell for num in range(1, 10): # Try numbers 1 to 9 if is_valid_move(grid, row, col, num): grid[row][col] = num if solve_sudoku(grid): # Recursively solve the remaining grid return True grid[row][col] = 0 # Reset the cell for backtracking return False # If no number is valid, return False return True # If the entire grid is filled, return True"},{"question":"# Highest Occurring Character in String You are given a string of lowercase English letters. Write a function `highest_occurrence(string)` that returns the character that appears the most frequently in the string. If there is a tie, return the lexicographically smallest character among the ones that have the highest frequency. Input * `string` is a non-empty string consisting of only lowercase English letters. Output * Return a single character that appears the most frequently in the string. Constraints * The length of the string will be between `1` and `100000`. Example ```python string = \\"abbbccdeeee\\" print(highest_occurrence(string)) # Output: \\"e\\" ``` **Explanation**: The character \'e\' appears the most frequently (4 times) in the string. Even though characters \'b\' and \'c\' also appear multiple times, \'e\' has the highest frequency.","solution":"def highest_occurrence(string): Returns the character that appears the most frequently in the string. If multiple characters have the same frequency, returns the lexicographically smallest one. from collections import Counter # Count the occurrence of each character frequency = Counter(string) # Find the maximum frequency max_freq = max(frequency.values()) # Find all characters that have the maximum frequency max_chars = [char for char, freq in frequency.items() if freq == max_freq] # Return the lexicographically smallest character among them return min(max_chars)"},{"question":"# Problem Statement You have been hired to develop a small server-side application that logs and analyses web requests. Your task is to create a function that processes a list of log entries and identifies the top N IP addresses that have the most requests within a given time window. # Function Signature ```python def top_n_ips(log_entries, N, window_start, window_end): Identify the top N IP addresses with the most requests in a given time window. Parameters: log_entries -- A list of tuples, where each tuple contains (timestamp, ip_address). \'timestamp\' is a string in the format \'YYYY-MM-DD HH:MM:SS\' \'ip_address\' is a string representing the IP address N -- An integer representing the number of top IP addresses to return window_start -- A string representing the start of the time window in format \'YYYY-MM-DD HH:MM:SS\' window_end -- A string representing the end of the time window in format \'YYYY-MM-DD HH:MM:SS\' Output: A list of tuples containing the top N IP addresses and their respective request counts, sorted by request count in descending order. Raises: ValueError -- If window_start is greater than window_end. pass ``` # Example Usage ```python >>> log_entries = [ ... (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), ... (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\"), ... (\\"2023-01-01 00:02:30\\", \\"192.168.1.2\\"), ... (\\"2023-01-01 00:02:31\\", \\"192.168.1.1\\"), ... (\\"2023-01-01 00:02:31\\", \\"10.0.0.1\\"), ... (\\"2023-01-01 00:05:00\\", \\"192.168.1.3\\"), ... ] >>> N = 2 >>> window_start = \\"2023-01-01 00:00:00\\" >>> window_end = \\"2023-01-01 00:03:00\\" >>> top_n_ips(log_entries, N, window_start, window_end) [(\'192.168.1.1\', 3), (\'192.168.1.2\', 1)] ``` # Requirements 1. **Input Constraints**: - `log_entries` is a list of tuples, where each tuple contains (timestamp, ip_address), and `timestamp` is in the format \'YYYY-MM-DD HH:MM:SS\'. - `N` is a positive integer. - `window_start` and `window_end` are strings in the format \'YYYY-MM-DD HH:MM:SS\'. 2. **Output**: - The function should return a list of tuples, where each tuple contains an IP address and its respective request count within the specified time window. - The list should be sorted by request count in descending order. If multiple IPs have the same request count, sort them lexicographically by the IP address. 3. **Edge Cases**: - If `window_start` is greater than `window_end`, raise a `ValueError`. # Background Context In many web applications, analyzing web request logs is crucial for monitoring traffic, identifying suspicious activities, or understanding user behavior. Efficiently processing and summarizing this data based on varied requirements can help in optimizing server resources and enhancing security measures.","solution":"from datetime import datetime from collections import Counter def top_n_ips(log_entries, N, window_start, window_end): Identify the top N IP addresses with the most requests in a given time window. Parameters: log_entries -- A list of tuples, where each tuple contains (timestamp, ip_address). \'timestamp\' is a string in the format \'YYYY-MM-DD HH:MM:SS\' \'ip_address\' is a string representing the IP address N -- An integer representing the number of top IP addresses to return window_start -- A string representing the start of the time window in format \'YYYY-MM-DD HH:MM:SS\' window_end -- A string representing the end of the time window in format \'YYYY-MM-DD HH:MM:SS\' Output: A list of tuples containing the top N IP addresses and their respective request counts, sorted by request count in descending order. Raises: ValueError -- If window_start is greater than window_end. window_start_dt = datetime.strptime(window_start, \'%Y-%m-%d %H:%M:%S\') window_end_dt = datetime.strptime(window_end, \'%Y-%m-%d %H:%M:%S\') if window_start_dt > window_end_dt: raise ValueError(\\"window_start cannot be greater than window_end\\") filtered_ips = [ ip for timestamp, ip in log_entries if window_start_dt <= datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') <= window_end_dt ] ip_counter = Counter(filtered_ips) top_ips = ip_counter.most_common(N) return top_ips"},{"question":"# List Flattening Function Development Problem Statement You are tasked with writing a function that takes a nested list of arbitrary depth and returns a flattened version of it. The function should traverse through each level of the nested structure and collect all the elements into a single list. Additionally, the function should handle the following: 1. The input list may contain nested lists, tuples, or other types of iterables. 2. The nested elements might not be uniform; non-iterable elements should be directly added to the result list. 3. Ensure efficient traversal and flattening of deeply nested structures. Functional Specification 1. **Function Name**: `flatten_nested_list` 2. **Input**: A nested list `nested_list` 3. **Output**: A flattened list of all elements contained within `nested_list` 4. **Exceptions**: None. Assume all elements are valid and handle all types without raising exceptions. Constraints 1. Handle multiple levels of nesting. 2. Include a check to handle non-iterable elements appropriately. 3. Ensure the function is efficient even for lists with high levels of nesting. Examples ```python >>> flatten_nested_list([1, [2, 3, [4, 5]], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([\'a\', [\'b\', [\'c\', \'d\']], \'e\']) [\'a\', \'b\', \'c\', \'d\', \'e\'] >>> flatten_nested_list([1, (2, 3, [4, 5]), 6]) [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([]) [] >>> flatten_nested_list([[[[1]]]]) [1] ``` Implementation Implement the function `flatten_nested_list` according to the specifications and ensure it passes all provided test cases. ```python def flatten_nested_list(nested_list): Flattens a nested list of arbitrary depth into a single list of elements. Args: nested_list: A list potentially containing other lists, tuples, or iterables. Returns: A single flattened list containing all elements. def flatten(element): if isinstance(element, (list, tuple)): for item in element: yield from flatten(item) else: yield element return list(flatten(nested_list)) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def flatten_nested_list(nested_list): Flattens a nested list of arbitrary depth into a single list of elements. Args: nested_list: A list potentially containing other lists, tuples, or iterables. Returns: A single flattened list containing all elements. def flatten(element): if isinstance(element, (list, tuple)): for item in element: yield from flatten(item) else: yield element return list(flatten(nested_list))"},{"question":"# Planetary Weight Calculator In this task, you will implement functions to calculate the weight of an object on different planets in our solar system based on its weight on Earth. These calculations will be based on the gravitational force exerted on the object by each planet. The given gravitational constants relative to Earth are as follows: - Mercury: 0.38 - Venus: 0.91 - Mars: 0.38 - Jupiter: 2.34 - Saturn: 1.06 - Uranus: 0.92 - Neptune: 1.19 Function Specifications 1. `planetary_weight(weight_on_earth: float, planet: str) -> float` This function should compute and return the weight of an object on a given planet. - **Input**: - `weight_on_earth (float)`: Weight of the object on Earth in kilograms (must be a positive number) - `planet (str)`: Name of the target planet (must be one of the specified planets: \\"Mercury\\", \\"Venus\\", \\"Mars\\", \\"Jupiter\\", \\"Saturn\\", \\"Uranus\\", \\"Neptune\\") - **Output**: - `float`: Weight of the object on the specified planet in kilograms - **Constraints**: - Raise `ValueError` if the weight is not positive or if the planet name is invalid. Example ```python >>> planetary_weight(70, \\"Mars\\") 26.6 >>> planetary_weight(70, \\"Jupiter\\") 163.8 >>> planetary_weight(-70, \\"Mars\\") Traceback (most recent call last): ... ValueError: Weight must be a positive number. >>> planetary_weight(70, \\"Pluto\\") Traceback (most recent call last): ... ValueError: Invalid planet name. ``` Notes - The weight on each planet is calculated using the formula: [ w_p = w_e times g_p ] where ( w_e ) is the weight on Earth and ( g_p ) is the gravitational constant of the planet. - Ensure your code efficiently handles invalid inputs. - You must validate both the weight and the planet name inputs.","solution":"def planetary_weight(weight_on_earth, planet): Computes the weight of an object on a given planet based on its weight on Earth. Parameters: weight_on_earth (float): Weight of the object on Earth in kilograms. Must be positive. planet (str): Name of the target planet. Must be one of \\"Mercury\\", \\"Venus\\", \\"Mars\\", \\"Jupiter\\", \\"Saturn\\", \\"Uranus\\", \\"Neptune\\". Returns: float: Weight of the object on the specified planet in kilograms. Raises: ValueError: If weight_on_earth is not positive or planet name is invalid. gravities = { \\"Mercury\\": 0.38, \\"Venus\\": 0.91, \\"Mars\\": 0.38, \\"Jupiter\\": 2.34, \\"Saturn\\": 1.06, \\"Uranus\\": 0.92, \\"Neptune\\": 1.19 } if weight_on_earth <= 0: raise ValueError(\\"Weight must be a positive number.\\") if planet not in gravities: raise ValueError(\\"Invalid planet name.\\") return round(weight_on_earth * gravities[planet], 1)"},{"question":"# Coding Challenge: LRU Cache Implementation **Context**: An LRU (Least Recently Used) cache is a data structure that maintains a record of the keys of the cache items based on their access time. When the cache reaches its maximum capacity, the least recently used key-value pair is removed to make space for new items. # Task Implement a class `LRUCache` that simulates the Least Recently Used (LRU) cache. Your class should support the following operations: 1. **Get**: Retrieve an element from the cache. 2. **Put**: Insert or update an element in the cache. 3. **Display Cache**: Display the current state of the cache from the least recently used to the most recently used. # Input and Output - **Get Operation**: - Method: `get(key: int) -> int | None` - Input: Integer key. - Output: Integer value or None if the key is not present in the cache. - **Put Operation**: - Method: `put(key: int, value: int) -> None` - Input: Integer key and value. - Output: None. - **Display Cache**: - Method: `display_cache() -> None` - Output: Print key-value pairs from the least recently used to the most recently used. # Constraints 1. The cache will have a maximum fixed size `n` specified when the cache is created. 2. The cache operations (get, put) must be completed in O(1) time complexity. 3. If a key is already in the cache and is accessed or updated using the `get` or `put` operations, it becomes the most recently used. # Scenario Create an `LRUCache` instance with a size limit of 3. Add, update, and retrieve elements while ensuring the correct implementation of the cache\'s functionality. ```python class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node: Node) -> None: # Add new node right after head pass def _remove_node(self, node: Node) -> None: # Remove an existing node from the linked list pass def _move_to_head(self, node: Node) -> None: # Move certain node in between to the head pass def _pop_tail(self) -> Node: # Pop the current tail pass def get(self, key: int) -> int | None: node = self.cache.get(key) if not node: return None # Move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = Node(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: tail = self._pop_tail() del self.cache[tail.key] else: # Update the value node.value = value self._move_to_head(node) def display_cache(self) -> None: current = self.head.next while current != self.tail: print(f\\"({current.key}, {current.value})\\", end=\\" \\") current = current.next print() if __name__ == \\"__main__\\": lru_cache = LRUCache(3) lru_cache.put(1, 1) lru_cache.put(2, 2) lru_cache.put(3, 3) lru_cache.display_cache() # Expected Output: (1, 1) (2, 2) (3, 3) lru_cache.put(4, 4) lru_cache.display_cache() # Expected Output: (2, 2) (3, 3) (4, 4) (since 1, 1 is discarded) print(lru_cache.get(2)) # Expected Output: 2 (and (2, 2) becomes most recently used) lru_cache.put(5, 5) lru_cache.display_cache() # Expected Output: (3, 3) (4, 4) (5, 5) (since 2, 2 becomes recently used and 3, 3 becomes LRU) ``` Ensure to include edge cases such as cache size limits, accessing non-existent keys, and updating already existing keys.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node: Node) -> None: # Add new node right after head node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node: Node) -> None: # Remove an existing node from the linked list prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node: Node) -> None: # Move certain node in between to the head self._remove_node(node) self._add_node(node) def _pop_tail(self) -> Node: # Pop the current tail res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int | None: node = self.cache.get(key) if not node: return None # Move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = Node(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: tail = self._pop_tail() del self.cache[tail.key] else: # Update the value node.value = value self._move_to_head(node) def display_cache(self) -> None: current = self.head.next while current != self.tail: print(f\\"({current.key}, {current.value})\\", end=\\" \\") current = current.next print()"},{"question":"# Coding Question: Skyline Problem **Scenario**: You are given a list of buildings in a city. Each building is represented by a triplet of integers [Li, Ri, Hi], where Li is the x-coordinate of the left edge, Ri is the x-coordinate of the right edge, and Hi is the height of the building. The skyline is represented by a list of [x, y] coordinates outlining the unique shape of the city\'s skyline. Write a function `compute_skyline` that takes a list of buildings and returns the skyline formed by these buildings. Function Signature ```python def compute_skyline(buildings: list) -> list: Args: - buildings (list of tuples): A list of triplets (Li, Ri, Hi) where: - Li (int): The x-coordinate of the left edge of the building. - Ri (int): The x-coordinate of the right edge of the building. - Hi (int): The height of the building. Returns: - list: A list of [x, y] coordinates representing the skyline. ``` Inputs - `buildings`: A list of tuples, where each tuple [Li, Ri, Hi] represents a building: - Li (int): The x-coordinate of the left edge. - Ri (int): The x-coordinate of the right edge. - Hi (int): The height. Outputs - A list of [x, y] coordinates representing the skyline. Constraints - 1 ≤ buildings.length ≤ 10000 - 0 ≤ Li < Ri ≤ 2^31 - 1 - 1 ≤ Hi ≤ 2^31 - 1 # Example ```python buildings = [(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)] print(compute_skyline(buildings)) # Expected output: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` # Notes - The skyline should be represented as a list of points [x, y] so that each segment is formed by the consecutive points. - Ensure that the algorithm handles overlapping buildings appropriately by combining the heights. - If two buildings have the same left edge, the one with the greater height should be considered. This question tests the ability to understand computational geometry and use data structures efficiently to compute the skyline problem.","solution":"import heapq def compute_skyline(buildings): Args: - buildings (list of tuples): A list of triplets (Li, Ri, Hi) where: - Li (int): The x-coordinate of the left edge of the building. - Ri (int): The x-coordinate of the right edge of the building. - Hi (int): The height of the building. Returns: - list: A list of [x, y] coordinates representing the skyline. events = [(L, -H, R) for L, R, H in buildings] + [(R, 0, 0) for _, R, _ in buildings] events.sort() result = [[0, 0]] live_buildings = [(0, float(\'inf\'))] # (negative height, end time) for x, negH, R in events: while live_buildings[0][1] <= x: heapq.heappop(live_buildings) if negH: heapq.heappush(live_buildings, (negH, R)) maxH = -live_buildings[0][0] if result[-1][1] != maxH: result.append([x, maxH]) return result[1:]"},{"question":"# Prime Sequence Generator Context: You are tasked with generating the first `n` prime numbers. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. You need to write a function that, given an integer `n`, returns a list of the first `n` prime numbers. Requirements: * Write a function `generate_primes(n: int) -> list` that returns a list of the first `n` prime numbers. * The function should handle invalid inputs gracefully, returning an empty list for non-positive integers and non-integer values. * Ensure that your function can handle edge cases such as 0, negative numbers, and large values of `n`. Input: * A single integer `n` representing the number of prime numbers to generate. Output: * A list of the first `n` prime numbers, if valid. Empty list otherwise. Constraints: * `0 <= n <= 10^5` Examples: ```python # Example 1 generate_primes(5) # Output: [2, 3, 5, 7, 11] # Example 2 generate_primes(0) # Output: [] # Example 3 generate_primes(1) # Output: [2] # Example 4 generate_primes(-5) # Output: [] # Example 5 generate_primes(7) # Output: [2, 3, 5, 7, 11, 13, 17] ``` Your function should be efficient and capable of handling up to the maximum constraint effectively.","solution":"def generate_primes(n): Generate the first n prime numbers. Parameters: n (int): The number of prime numbers to generate. Returns: list: A list containing the first n prime numbers. if not isinstance(n, int) or n <= 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for p in primes: if p * p > candidate: break if candidate % p == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"# Task **Task**: Implement and validate a function to find the peak element in an unsorted array. # Scenario As part of an analytics module, you need to identify a peak element in a series of metrics recorded in an unsorted array. A peak element is defined as an element that is greater than its neighbors. For the elements at the boundaries of the array, we consider only one neighbor for comparison. The task requires the implementation of an efficient solution that finds and returns the index of a peak element. # Implementation Write a function called `find_peak` that has the following signature: ```python def find_peak(arr: list[int]) -> int: Finds the index of a peak element in the given unsorted array. Parameters: - arr (list[int]): The input array of integers. Returns: - int: The index of any one of the peak elements. Note: - An element is considered a peak if it is not smaller than its neighbors. - For elements at the boundaries of the array, we only consider one neighbor. ``` # Requirements 1. Implement an efficient algorithm to find a peak, preferably in O(log n) time complexity. 2. The function should return the index of any one peak element. 3. Handle cases where the array contains one element, in which case that element is the peak by default. 4. Ensure the function is robust and handles edge cases appropriately. # Constraints - The input array `arr` will have at least one element. - All elements in `arr` are integers and can have both positive and negative values. # Example Usage ```python print(find_peak([1, 3, 20, 4, 1, 0])) # Expected output: 2 (element at index 2 is a peak) print(find_peak([10, 20, 15, 2, 23, 90, 67])) # Expected output: 1 or 5 print(find_peak([1, 2, 3, 1])) # Expected output: 2 print(find_peak([1, 3, 2, 4, 1, 0])) # Expected output: 1 or 3 print(find_peak([10])) # Expected output: 0 ``` # Notes - Validate your code against typical and edge case scenarios to ensure correctness. - Explain any additional assumptions made in your implementation. - Make sure to document your code where necessary for clarity.","solution":"def find_peak(arr: list[int]) -> int: Finds the index of a peak element in the given unsorted array. Parameters: - arr (list[int]): The input array of integers. Returns: - int: The index of any one of the peak elements. n = len(arr) def binary_search(start, end): mid = (start + end) // 2 # Check if mid is a peak if (mid == 0 or arr[mid] >= arr[mid - 1]) and (mid == n-1 or arr[mid] >= arr[mid + 1]): return mid # If the left neighbor is greater, there must be a peak on the left side if mid > 0 and arr[mid - 1] > arr[mid]: return binary_search(start, mid - 1) # If the right neighbor is greater, there must be a peak on the right side return binary_search(mid + 1, end) return binary_search(0, n - 1)"},{"question":"# URL Domain Extraction Function Objective Write a function to extract the domain name from a given URL. The URL format follows the general rules of web addresses. Function Signature ```python def extract_domain(url: str) -> str: ``` Input * `url` (str): A string representing the URL from which to extract the domain name. Output * Returns a string representing the domain name extracted from the URL. Constraints * The input string will be a valid URL format but can have varying components like a protocol (`http`, `https`) and possible subdomains. # Examples ```python >>> extract_domain(\\"http://www.example.com/path/to/resource\\") \'example.com\' >>> extract_domain(\\"https://subdomain.domain.co.uk\\") \'domain.co.uk\' >>> extract_domain(\\"http://singleleveldomain.net\\") \'singleleveldomain.net\' >>> extract_domain(\\"https://example.org\\") \'example.org\' >>> extract_domain(\\"ftp://files.example.com/resources\\") \'example.com\' >>> extract_domain(\\"http://localhost/local/resource\\") \'localhost\' ``` # Requirements 1. You should not use any external libraries for URL parsing (like `urllib`). 2. Handle both http and https protocols, and ignore subdomains (e.g., www, sub1, sub2). 3. Performance should consider typical lengths of URLs within reasonable limits (up to 2048 characters long). # Hints - Use string operations to handle the splitting and extraction of domain parts. - Make sure to check edge cases like single-level domains, different protocols, and subdomains.","solution":"def extract_domain(url: str) -> str: Extracts the domain from the given URL. # Remove the protocol if \\"://\\" in url: url = url.split(\\"://\\")[1] # Split by path and only consider the domain part domain_part = url.split(\'/\')[0] # Split by dots and consider last two parts parts = domain_part.split(\'.\') # Handle simple cases like \'localhost\' if len(parts) == 1: return parts[0] # Regular domains and SLDs if len(parts) > 2 and parts[-2] in {\'co\', \'org\', \'net\', \'com\', \'gov\', \'edu\'}: return \'.\'.join(parts[-3:]) return \'.\'.join(parts[-2:])"},{"question":"# Problem Statement You are given a list of integers representing the weights of different items and a target weight called `W`. Your task is to determine whether it is possible to select a subset of the given weights that sum up exactly to `W`. # Function Signature ```python def can_reach_target(weights: List[int], W: int) -> bool: pass ``` # Input * `weights` (1 <= len(weights) <= 1000): A list of integers where each integer represents the weight of an item. Each weight is a positive integer no greater than 10^5. * `W` (0 <= W <= 10^5): The target weight that we need to reach using the subset of given weights. # Output * Return `True` if it\'s possible to select a subset of the given weights that sums up exactly to `W`, otherwise return `False`. # Example ```python assert can_reach_target([1, 3, 9, 5], 8) == True assert can_reach_target([1, 3, 9, 5], 2) == False ``` # Constraints * The input list contains only positive integers. * You must implement the function efficiently with regards to both time and space complexity. # Scenarios 1. For `weights = [1, 3, 9, 5]` and `W = 8`, the function returns `True` because we can select the subset `[3, 5]` which adds up to `8`. 2. For `weights = [1, 3, 9, 5]` and `W = 2`, the function returns `False` because there is no subset that adds up to `2`. # Hints - Consider using dynamic programming to solve the subset sum problem. - You may use a 1D DP array `dp` where `dp[i]` represents whether the sum `i` can be formed using elements from the list of weights.","solution":"from typing import List def can_reach_target(weights: List[int], W: int) -> bool: Determine if a subset of the given weights can sum up to the target weight W. dp = [False] * (W + 1) dp[0] = True # Base case: A sum of 0 can always be reached with the empty subset for weight in weights: for j in range(W, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[W]"},{"question":"# Merge Arrays with Custom Function You are given two sorted arrays `A` and `B` of integers. Your task is to implement a function to merge these two sorted arrays into one sorted array using a custom comparison function. This custom function, `cmp`, takes two integers as inputs and returns `True` if the first integer should come before the second in the merged array, and `False` otherwise. Constraints * The arrays `A` and `B` are sorted in non-decreasing order. * You are not allowed to use any built-in sorting functions. * The result must be a new sorted array that merges `A` and `B` according to the custom comparison function. * The merged array should not have any duplicate elements. If an element is present in both arrays, include it only once in the merged array. Function Signature ```python def merge_arrays(A: list, B: list, cmp: callable) -> list: # Implement the merge function here ``` Example Usage ```python # Example comparison function def custom_cmp(x, y): return x < y A = [1, 3, 5, 7] B = [2, 3, 6, 8] result = merge_arrays(A, B, custom_cmp) print(result) # Output: [1, 2, 3, 5, 6, 7, 8] def reverse_cmp(x, y): return x > y result = merge_arrays(A, B, reverse_cmp) print(result) # Output: [8, 7, 6, 5, 3, 2, 1] ``` Write the `merge_arrays` function that merges two sorted arrays into a single sorted array based on the custom comparison function, while ensuring no duplicates are present. Implement thorough tests to verify the functionality.","solution":"def merge_arrays(A: list, B: list, cmp: callable) -> list: # Helper function to merge without duplicates def unique_sorted(arr): unique_set = set(arr) return sorted(list(unique_set), key=lambda x: x, reverse=cmp(1, 0)) # Combine both arrays and sort them using the unique_sorted helper function combined = A + B return unique_sorted(combined) # Example comparison functions def custom_cmp(x, y): return x < y def reverse_cmp(x, y): return x > y"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a library management system. One of the key functionalities is to recommend similar books to a user based on their reading history. The recommendation is based on the genre of the books. You have a list of books with their respective genres and need to find the most frequent genre read by a user to recommend the next book from the same genre. Task Implement a function `recommend_book` that, given a list of books the user has read and a library catalog, returns a book from the most frequently read genre. If there are multiple genres with the same frequency, choose any book from the most frequent genres. If any of the books read by the user do not exist in the catalog, raise a `ValueError`. Function Signature ```python def recommend_book(user_books: List[str], catalog: List[Tuple[str, str]]) -> str: ``` Input * `user_books (List[str])`: A list of strings where each string is the title of a book read by the user. * `catalog (List[Tuple[str, str]])`: A list of tuples where each tuple contains a string (book title) and another string (book genre). Output * Returns the title of a book (str) from the most frequent genre read by the user. Constraints * All book titles are unique. * The list of `catalog` will have at least one book. * If user_books list has unique books, they will be in the catalog; otherwise, raise `ValueError`. Example ```python You have a catalog: [ (\\"The Great Gatsby\\", \\"Fiction\\"), (\\"1984\\", \\"Dystopia\\"), (\\"The Catcher in the Rye\\", \\"Fiction\\"), (\\"Brave New World\\", \\"Dystopia\\"), (\\"To Kill a Mockingbird\\", \\"Fiction\\") ] The user reads the books: [\\"1984\\", \\"The Great Gatsby\\", \\"Brave New World\\"] The most frequent genre is \\"Dystopia\\". One possible output could be \\"1984\\" or \\"Brave New World\\" if another Dystopia book exists in the catalog. catalog = [ (\\"The Great Gatsby\\", \\"Fiction\\"), (\\"1984\\", \\"Dystopia\\"), (\\"The Catcher in the Rye\\", \\"Fiction\\"), (\\"Brave New World\\", \\"Dystopia\\"), (\\"To Kill a Mockingbird\\", \\"Fiction\\") ] user_books = [\\"1984\\", \\"The Great Gatsby\\", \\"Brave New World\\"] book = recommend_book(user_books, catalog) print(book) # Output could be \\"1984\\" or \\"Brave New World\\" ``` Notes * Ensure to handle scenarios where user_books contain titles not present in the catalog. * Take into account multiple genres with the same frequency and return any one of the possible books. * Focus on the correctness and maintain efficiency. Handle potential edge cases adequately.","solution":"from typing import List, Tuple from collections import Counter def recommend_book(user_books: List[str], catalog: List[Tuple[str, str]]) -> str: # Create a lookup dictionary for book title to genre catalog_dict = {title: genre for title, genre in catalog} # Count genres for the user\'s books user_genres = [] for book in user_books: if book not in catalog_dict: raise ValueError(f\\"Book \'{book}\' not found in the catalog.\\") user_genres.append(catalog_dict[book]) # Find the most frequent genre genre_counter = Counter(user_genres) most_frequent_genre = genre_counter.most_common(1)[0][0] # Recommend a book from this genre for book, genre in catalog: if genre == most_frequent_genre: return book"},{"question":"# Problem Statement: Evaluating Expression Trees Context: An expression tree is a binary tree where the leaf nodes are operands (numbers) and the internal nodes are operators (+, -, *, /). This tree structure is used to represent arithmetic expressions. Task: Implement a function `evaluate_expression_tree` to compute the value of an expression tree. The input will be given as the root of a binary tree representing the expression. Requirements: 1. **Function Signature:** ```python def evaluate_expression_tree(root: Optional[TreeNode]) -> float: Evaluates the arithmetic expression represented by the binary tree. Leaf nodes contain integer values. Internal nodes contain operators: \'+\', \'-\', \'*\', \'/\'. Returns the computed value as a float. ``` 2. You must define a class `TreeNode` to represent each node in the tree: ```python class TreeNode: def __init__(self, value: str, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right ``` 3. Ensure that the function handles invalid or null trees appropriately by returning 0 if the tree is empty. Input: * **root** (TreeNode | None): The root node of the expression tree, or `None` if the tree is empty. Output: * Returns the evaluated result of the expression as a float. Constraints: * Leaf nodes contain integer values in string format (e.g., \\"3\\", \\"15\\"). * Non-leaf nodes contain one of the operators: \\"+\\", \\"-\\", \\"*\\", \\"/\\". * The tree will always be a valid expression tree with proper operator precedence implied by the tree structure. * Division by zero should not occur in the provided test cases. Example: ```python # Example 1: root1 = TreeNode( \\"*\\", TreeNode(\\"+\\", TreeNode(\\"3\\"), TreeNode(\\"2\\") ), TreeNode(\\"4\\") ) >>> evaluate_expression_tree(root1) 20.0 # Example 2: root2 = TreeNode( \\"/\\", TreeNode(\\"20\\"), TreeNode(\\"-\\", TreeNode(\\"6\\"), TreeNode(\\"2\\") ) ) >>> evaluate_expression_tree(root2) 5.0 # Example 3: root3 = None >>> evaluate_expression_tree(root3) 0.0 ``` Notes: * Ensure that the function can handle nested expressions and maintains appropriate operator precedence. * The function should correctly evaluate expressions containing any combination of the operations +, -, *, /. * Consider edge cases, such as trees with only a single node or imbalanced trees.","solution":"from typing import Optional class TreeNode: def __init__(self, value: str, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right def evaluate_expression_tree(root: Optional[TreeNode]) -> float: if root is None: return 0.0 # If the root is a leaf node, return its value as float if root.left is None and root.right is None: return float(root.value) # Recursively evaluate the left and right subtrees left_value = evaluate_expression_tree(root.left) right_value = evaluate_expression_tree(root.right) # Apply the operator in the current root node to the values from left and right subtrees if root.value == \'+\': return left_value + right_value elif root.value == \'-\': return left_value - right_value elif root.value == \'*\': return left_value * right_value elif root.value == \'/\': return left_value / right_value else: raise ValueError(f\\"Invalid operator {root.value}\\")"},{"question":"# Prime Sieve and Twin Primes **Objective**: Create a function to generate prime numbers using the Sieve of Eratosthenes algorithm and identify pairs of twin primes from the generated list. # Function 1: `sieve_of_eratosthenes(limit: int) -> list[int]` **Input**: - `limit`: An integer representing the upper bound up to which prime numbers are to be found (e.g., 100). **Output**: - A list of prime numbers up to the given limit. # Function 2: `find_twin_primes(primes: list[int]) -> list[tuple[int, int]]` **Input**: - `primes`: A list of prime numbers generated by the Sieve of Eratosthenes. **Output**: - A list of tuples, where each tuple contains a pair of twin primes. Twin primes are pairs of primes that differ by exactly 2 (e.g., (11, 13)). # Requirements: 1. Implement the Sieve of Eratosthenes algorithm in the function `sieve_of_eratosthenes` to generate all prime numbers up to the specified limit. 2. Implement a function `find_twin_primes` that takes a list of prime numbers and returns pairs of twin primes. 3. Ensure that the functions handle edge cases appropriately (e.g., small values of `limit`, no twin primes found). 4. Optimize for performance where possible while maintaining code clarity and correctness. # Example: ```python >>> primes = sieve_of_eratosthenes(20) >>> primes [2, 3, 5, 7, 11, 13, 17, 19] >>> twin_primes = find_twin_primes(primes) >>> twin_primes [(3, 5), (5, 7), (11, 13), (17, 19)] ``` **Note**: 1. Do not include any file handling code; focus solely on the function implementations. 2. The implementation should be suitable to be tested with standard unit tests.","solution":"def sieve_of_eratosthenes(limit): Generates a list of prime numbers up to the given limit using the Sieve of Eratosthenes algorithm. Parameters: limit (int): The upper bound to generate prime numbers (inclusive). Returns: list[int]: A list of prime numbers up to the provided limit. if limit < 2: return [] is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for number in range(2, int(limit**0.5) + 1): if is_prime[number]: for multiple in range(number*number, limit + 1, number): is_prime[multiple] = False primes = [num for num in range(limit + 1) if is_prime[num]] return primes def find_twin_primes(primes): Finds all pairs of twin primes from a list of prime numbers. Parameters: primes (list[int]): A list of prime numbers in ascending order. Returns: list[tuple[int, int]]: A list of tuples where each tuple contains twin primes. twin_primes = [] for i in range(len(primes) - 1): if primes[i + 1] - primes[i] == 2: twin_primes.append((primes[i], primes[i + 1])) return twin_primes"},{"question":"# Problem Statement Given two lists of integers, write a function to find all duplicate elements present in both lists and return them in a sorted list. # Function Specifications Implement the following function: ```python def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Find all duplicate elements present in both lists and return them in a sorted list. Parameters: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: A sorted list containing the duplicate elements present in both lists. pass ``` # Input The function `find_common_elements` takes two parameters: * `list1` (1 <= len(list1) <= 10^5): A list of integers. * `list2` (1 <= len(list2) <= 10^5): Another list of integers. # Output The function should return a list of integers: * A sorted list containing the duplicate elements present in both lists. # Examples Example 1: ```python print(find_common_elements([1, 2, 3, 4], [3, 4, 5, 6])) # Output: [3, 4] ``` Example 2: ```python print(find_common_elements([10, 20, 30, 40], [15, 25, 35, 45])) # Output: [] ``` Example 3: ```python print(find_common_elements([1, 1, 2, 2], [2, 2, 3, 3])) # Output: [2] ``` # Constraints * The integers in the lists can be positive or negative. * The output list should not contain any duplicates. * The function should aim for efficient performance considering the constraints. # Commentary This problem tests basic list operations, set operations, and sorting. It encourages efficient intersection approaches such as using set data structures to achieve optimal performance on the intersection operation.","solution":"from typing import List def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Find all duplicate elements present in both lists and return them in a sorted list. Parameters: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: List[int]: A sorted list containing the duplicate elements present in both lists. # Convert the lists to sets to find common elements common_elements = set(list1) & set(list2) # Convert the set to a sorted list return sorted(list(common_elements))"},{"question":"# **Binary Search Tree Insertion and Traversal** Scenario: You are tasked with creating a Binary Search Tree (BST) and implementing methods for inserting elements into the tree, as well as performing an in-order traversal to return the elements in a sorted order. Task: Implement a class `BinarySearchTree` with two methods: `insert` and `in_order_traversal`. The `insert` method should add a value into the BST while maintaining its properties. The `in_order_traversal` method should return a list of values in ascending order. Method Specifications: 1. **insert(value: int) -> None** - **Input**: An integer `value` to be inserted into the BST. - **Output**: None. 2. **in_order_traversal() -> list[int]** - **Input**: None. - **Output**: A list of integers representing the values in the BST, sorted in ascending order. Constraints: - The tree must maintain the property that for every node, all values in the left subtree are smaller, and all values in the right subtree are larger. - Duplicate values should not be inserted into the tree. - The methods should handle an initially empty tree. Example: ```python from binary_search_tree import BinarySearchTree # assume the code is in a file named \'binary_search_tree.py\' # Creating the BST and inserting elements bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(5) # duplicate, should not be inserted # Performing in-order traversal sorted_values = bst.in_order_traversal() # Check the result assert sorted_values == [2, 5, 10, 15] ``` Your task is to implement the `BinarySearchTree` class with the specified methods.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current_node, value): if value < current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(current_node.left, value) elif value > current_node.value: if current_node.right is None: current_node.right = Node(value) else: self._insert(current_node.right, value) # If value is equal to current node value, we do not insert duplicates. def in_order_traversal(self): return self._in_order_traversal(self.root, []) def _in_order_traversal(self, node, values): if node is not None: self._in_order_traversal(node.left, values) values.append(node.value) self._in_order_traversal(node.right, values) return values"},{"question":"Trie Dictionary Auto-Complete Scenario: You are building a predictive text feature for a search engine. Users will type a prefix, and your system should provide auto-complete suggestions by efficiently searching a dictionary of words. Question: Implement a `Trie` class and a method `autocomplete(prefix: str) -> list[str]` which returns a list of all words in the Trie that start with the given prefix. Ensure that the search operation is performed efficiently. # Class Specification: Trie - `insert(word: str) -> None`: Inserts a word into the Trie. - `autocomplete(prefix: str) -> list[str]`: Returns a list of all words in the Trie that start with the given prefix. # Constraints: - Inserting a word and searching for a prefix should each have a time complexity of roughly (O(length of the word)). - Tries can contain up to (10^5) words. - Words contain only lowercase English letters. # Example: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix): def dfs(node, prefix): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): dfs(child_node, prefix + char) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix) return results # Usage example: trie = Trie() words = [\\"cat\\", \\"car\\", \\"cart\\", \\"dog\\", \\"deal\\"] for word in words: trie.insert(word) prefix = \\"car\\" suggestions = trie.autocomplete(prefix) print(f\\"Auto-complete suggestions for \'{prefix}\': {suggestions}\\") # Output: Auto-complete suggestions for \'car\': [\'car\', \'cart\'] ``` **Note:** Ensure your implementation can handle large sets of words efficiently and returns results in lexicographical order. Optimize for both time and space complexity.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix): def dfs(node, prefix): if node.is_end_of_word: results.append(prefix) for char in sorted(node.children.keys()): dfs(node.children[char], prefix + char) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix) return results"},{"question":"# Question: Implementing a Stack with Max Operation Context: You have been provided with the core structure to create a stack that allows basic stack operations like push, pop, and peek. Your task is to extend this stack to include an additional operation to retrieve the maximum element. # Task: Implement a class `MaxStack` that supports the following operations: 1. **Push an element onto the stack**: Method `push(data)` 2. **Pop the top element from the stack**: Method `pop()` 3. **Peek the top element without removing it**: Method `peek()` 4. **Retrieve the maximum element in the stack**: Method `get_max()` # Requirements: 1. **Input/Output**: - Each method should operate on instances of `MaxStack`. - The `__repr__` method should be usable to view the current state of the stack as a list of elements from bottom to top. 2. **Constraints**: - Each operation should handle edge cases such as an empty stack. - Efficiency in retrieving the maximum element should be considered. 3. **Performance**: - Each method should have a time complexity of O(1), except for pop, which can be O(log n) or better. # Example: ```python # Initializing MaxStack max_stack = MaxStack() # Pushing elements max_stack.push(5) max_stack.push(2) max_stack.push(8) max_stack.push(1) print(max_stack) # Expected: [5, 2, 8, 1] # Getting the maximum element print(max_stack.get_max()) # Expected: 8 # Popping the top element max_stack.pop() print(max_stack) # Expected: [5, 2, 8] # Peeking the top element print(max_stack.peek()) # Expected: 8 # Getting the maximum element print(max_stack.get_max()) # Expected: 8 # Popping the top element max_stack.pop() print(max_stack) # Expected: [5, 2] # Getting the maximum element print(max_stack.get_max()) # Expected: 5 ```","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def __repr__(self): return repr(self.stack) def push(self, data): self.stack.append(data) if not self.max_stack or data >= self.max_stack[-1]: self.max_stack.append(data) def pop(self): if not self.stack: return None top = self.stack.pop() if top == self.max_stack[-1]: self.max_stack.pop() return top def peek(self): if not self.stack: return None return self.stack[-1] def get_max(self): if not self.max_stack: return None return self.max_stack[-1]"},{"question":"# Coding Assessment Question You are tasked with developing a system to manage conference room bookings. The system must handle multiple booking requests and ensure that no two bookings overlap. # Problem Statement Implement a function `can_book_all` that checks whether all given bookings can be scheduled without overlapping. # Function Signature ```python def can_book_all(bookings: list[tuple[int, int]]) -> bool: pass ``` # Input * `bookings`: A list of tuples where each tuple `(start, end)` represents a booking request. `start` and `end` are integers representing time in hours (24-hour format), with `0 <= start < end <= 24`. # Output * A boolean value `True` if all bookings can be scheduled without any overlap, otherwise `False`. # Constraints * `0 <= len(bookings) <= 1000` * `0 <= start < end <= 24` * No booking will extend beyond a single day (24 hours). * Times are provided in whole hours only. # Examples ```python bookings1 = [(9, 12), (13, 15), (16, 18)] assert can_book_all(bookings1) == True # No overlap bookings2 = [(9, 12), (11, 14), (13, 15)] assert can_book_all(bookings2) == False # Overlap between (9, 12) and (11, 14) ``` In the examples, the first list of bookings can be scheduled without any conflicts, while the second list has overlapping time slots.","solution":"def can_book_all(bookings: list[tuple[int, int]]) -> bool: Determines if all given bookings can be scheduled without overlapping. Args: - bookings (list of tuple(int, int)): A list of tuples where each tuple contains the start and end time of a booking. Returns: - bool: True if all bookings can be scheduled without overlapping, False otherwise. # Sort bookings by start time bookings.sort() # Iterate through bookings and check for overlap for i in range(1, len(bookings)): if bookings[i][0] < bookings[i - 1][1]: return False return True"},{"question":"# Find the Intersection of Two Linked Lists Problem Context: You are given two singly linked lists. Write a function to determine the node at which the two lists intersect. If the two linked lists have no intersection at all, return `None`. The linked lists are defined as follows: - Each node is a data structure with an integer value and a reference to the next node. - The intersection is defined based on reference, not value. Therefore, nodes may have the same value but do not intersect if their references are distinct. Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: ``` Input: * **headA (ListNode)**: The head node of the first singly linked list. * **headB (ListNode)**: The head node of the second singly linked list. Output: * **ListNode**: The reference to the node where the intersection begins, or `None` if there is no intersection. Constraints: 1. The linked lists must retain their original structure after the function returns. 2. No cycles anywhere in the entire linked structure. 3. Each linked list\'s length will be in the range [0, 10000]. 4. Node values are further `1 <= Node.val <= 10000`. Example: ```python # Example 1 # Intersection at node with value 8 # List A: 4 -> 1 -> # ↘ # 8 -> 4 -> 5 # ↗ # List B: 5 -> 6 -> 1 -> headA = ListNode(4, ListNode(1, ListNode(8, ListNode(4, ListNode(5))))) headB = ListNode(5, ListNode(6, ListNode(1, headA.next.next))) assert get_intersection_node(headA, headB).value == 8 # Example 2 # No Intersection # List A: 2 -> 6 -> 4 # List B: 1 -> 5 headA = ListNode(2, ListNode(6, ListNode(4))) headB = ListNode(1, ListNode(5)) assert get_intersection_node(headA, headB) == None ``` Errors: 1. Raise `ValueError` with an appropriate message if either list head is `None`. Implementation Instructions: 1. Implement the method using an efficient approach that minimizes time and space complexity. 2. Consider using the difference in length of the lists to converge at the point of intersection. 3. Validate input and implement error handling appropriately.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if headA is None or headB is None: raise ValueError(\\"List heads cannot be None\\") # Calculate the length of both lists def get_length(head): length = 0 while head: length += 1 head = head.next return length lengthA = get_length(headA) lengthB = get_length(headB) # Align heads to the same starting point while lengthA > lengthB: headA = headA.next lengthA -= 1 while lengthB > lengthA: headB = headB.next lengthB -= 1 # Traverse both lists simultaneously to find the intersection while headA and headB: if headA == headB: return headA headA = headA.next headB = headB.next return None"},{"question":"# Advanced Coding Challenge: Optimal Pathfinding in a Weighted Grid Background You are given a grid where each cell has a certain cost associated with entering it. The objective is to find the cheapest path from the top-left corner to the bottom-right corner. The movement is restricted to right and down directions only. This is a common problem in robotics and game design where finding the optimal path is crucial. Task Your goal is to implement an efficient algorithm to determine the minimum cost path from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1) in a grid. The grid is represented as a 2D list where each element indicates the cost of entering that cell. Requirements 1. Implement the algorithm using dynamic programming. 2. Optimize the space complexity to O(n) where n is the number of columns by only storing the current and previous rows. Inputs and Outputs - The input will be a 2D list `grid` of size n x m where each element is a non-negative integer representing the cost. - Output the minimum cost required to reach the bottom-right cell (n-1, m-1) from the top-left cell (0, 0). Constraints - You can assume that n, m will be in the range of 1 to 1,000. - The costs will be non-negative integers ranging from 0 to 1000. Instructions 1. Create a function `min_cost_path(grid: List[List[int]]) -> int` that returns the minimum cost. 2. Use a dynamic programming approach where you build the solution iteratively. Example ```python def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [0] * m dp[0] = grid[0][0] for j in range(1, m): dp[j] = dp[j-1] + grid[0][j] for i in range(1, n): dp[0] += grid[i][0] for j in range(1, m): dp[j] = min(dp[j], dp[j-1]) + grid[i][j] return dp[-1] # Example usage: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid)) # Output: 7 ``` In this example, the path with the minimum cost is 1 → 3 → 1 → 1 → 1.","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [0] * m dp[0] = grid[0][0] for j in range(1, m): dp[j] = dp[j-1] + grid[0][j] for i in range(1, n): dp[0] += grid[i][0] for j in range(1, m): dp[j] = min(dp[j], dp[j-1]) + grid[i][j] return dp[-1]"},{"question":"# Problem Statement You need to implement a function that will generate all valid combinations of k elements out of a list of n elements. The elements in the list are unique and of integer type. # Function to Implement 1. `generate_k_combinations(arr: List[int], k: int) -> List[List[int]]` Requirements * **generate_k_combinations**: - **Input**: * `arr` (List[int]): The input list of unique integers. (Constraints: length `1 <= len(arr) <= 15`) * `k` (int): The number of elements to choose for each combination. - **Output**: * A list of lists, where each sub-list is a valid combination of `k` elements from `arr`. Each combination should be sorted in ascending order. Constraints - The input list elements must be unique. - 1 ≤ k ≤ len(arr). - The return combination list must not have duplicate combinations and should be sorted lexicographically. Example ```python def test_generate_k_combinations(): arr = [1, 2, 3, 4] k = 2 result = generate_k_combinations(arr, k) expected_result = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] assert result == expected_result, f\\"Expected {expected_result} but got {result}\\" arr = [5, 8, 12] k = 3 result = generate_k_combinations(arr, k) expected_result = [[5, 8, 12]] assert result == expected_result, f\\"Expected {expected_result} but got {result}\\" test_generate_k_combinations() ``` **Note**: Ensure the output combinations are sorted lexicographically and the function implements efficient combination generation logic to handle the necessary constraints.","solution":"from itertools import combinations from typing import List def generate_k_combinations(arr: List[int], k: int) -> List[List[int]]: Generate all valid combinations of k elements out of the list arr. Parameters: arr (List[int]): The input list of unique integers. k (int): The number of elements to choose for each combination. Returns: List[List[int]]: A list of lists, where each sub-list is a valid combination of k elements from arr. # Generate all combinations of length k combs = list(combinations(arr, k)) # Convert tuples to lists and sort combinations lexicographically result = [list(comb) for comb in combs] result.sort() return result"},{"question":"# Problem Statement You are given a forest represented as a binary tree, where each node has a unique integer value. Your task is to write a function `longest_unique_path` that finds the longest path in the tree such that all the values along the path are unique. The path doesn\'t have to pass through the root and can start and end at any node. # Input * `root`: the root node of the binary tree (`TreeNode` object). # Output The function should return an integer representing the length of the longest path with all unique values. # Constraints * The number of nodes in the binary tree is between 1 and 1000. * The value of each node is an integer. * It is guaranteed that the values of the nodes are unique. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_unique_path(root): # Your implementation here # Example binary tree: # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(longest_unique_path(root)) # Expected output: 6 (path: 4 -> 2 -> 1 -> 3 -> 6 -> 7) ``` # Scenario In a forest (binary tree) with uniquely identified species (node values), you aim to find the longest stretch (path) where all animal encounters (node values) are different, helping biologists study the diversity and behavior of species along that path.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_unique_path(root): def dfs(node, path_set): if not node: return 0 if node.val in path_set: return 0 path_set.add(node.val) left_path = dfs(node.left, path_set) right_path = dfs(node.right, path_set) path_set.remove(node.val) return 1 + max(left_path, right_path) def find_max_unique_path(node): if not node: return 0 single_path_length = dfs(node, set()) left_max = find_max_unique_path(node.left) right_max = find_max_unique_path(node.right) return max(single_path_length, left_max, right_max) return find_max_unique_path(root)"},{"question":"# Problem Statement You are tasked with implementing Dijkstra\'s Algorithm to find the shortest path from a given source vertex to all other vertices in an undirected, weighted graph. Additionally, you must also provide an implementation that uses a min-heap to improve the algorithm\'s efficiency. # Function Signature ```python class Vertex: def __init__(self, id_): self.id = str(id_) self.dist = float(\'inf\') self.prev = None self.neighbors = {} def connect(graph: list, a: int, b: int, weight: int) -> None: pass def dijkstra(graph: list[Vertex], src: Vertex) -> dict: pass def dijkstra_heap(graph: list[Vertex], src: Vertex) -> dict: pass ``` **Input Format**: - `graph` (list[Vertex]): A list of Vertices representing the graph. - `src` (Vertex): The source vertex from which the algorithm starts. **Output Format**: - `dijkstra` should return a dictionary where keys are vertex ids and values are tuples (dist, prev), indicating the minimum distance from the source vertex and the previous vertex in the shortest path. - `dijkstra_heap` should return a dictionary in the same format as `dijkstra`. **Constraints**: - The number of vertices ( n ) in the graph is in the range [1, 10^3]. - The number of edges ( m ) in the graph is in the range [1, 3 * 10^3]. - Edge weights are non-negative integers. # Example Usage ```python # Create graph and vertices vertices = [Vertex(i) for i in range(5)] # Define connections between vertices connections = [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 3, 3), (3, 4, 1)] # Connect vertices for a, b, weight in connections: connect(vertices, a, b, weight) # Compute shortest paths using Dijkstra\'s algorithm shortest_paths = dijkstra(vertices, vertices[0]) print(shortest_paths) shortest_paths_heap = dijkstra_heap(vertices, vertices[0]) print(shortest_paths_heap) ``` **Expected Output**: ``` { \'0\': (0, None), \'1\': (2, \'0\'), \'2\': (3, \'1\'), \'3\': (6, \'2\'), \'4\': (7, \'3\') } { \'0\': (0, None), \'1\': (2, \'0\'), \'2\': (3, \'1\'), \'3\': (6, \'2\'), \'4\': (7, \'3\') } ``` # Evaluation Criteria 1. Correctness: The solution should correctly compute the shortest paths for given graph inputs. 2. Efficiency: The solution should perform within acceptable time limits given the constraints. 3. Edge Handling: Solutions should adequately handle edge cases, including singular vertices, heavily connected graphs, and varying edge weights. 4. Code Quality: The implementation should be clean, well-documented, and easy to understand.","solution":"import heapq class Vertex: def __init__(self, id_): self.id = str(id_) self.dist = float(\'inf\') self.prev = None self.neighbors = {} def connect(graph: list, a: int, b: int, weight: int) -> None: graph[a].neighbors[graph[b].id] = weight graph[b].neighbors[graph[a].id] = weight def dijkstra(graph: list[Vertex], src: Vertex) -> dict: src.dist = 0 unvisited = set(graph) while unvisited: current = min(unvisited, key=lambda vertex: vertex.dist) unvisited.remove(current) for neighbor_id, weight in current.neighbors.items(): neighbor = next(v for v in graph if v.id == neighbor_id) if neighbor in unvisited: new_dist = current.dist + weight if new_dist < neighbor.dist: neighbor.dist = new_dist neighbor.prev = current return {v.id: (v.dist, v.prev.id if v.prev else None) for v in graph} def dijkstra_heap(graph: list[Vertex], src: Vertex) -> dict: src.dist = 0 heap = [(0, src)] heapq.heapify(heap) visited = set() while heap: current_dist, current_vertex = heapq.heappop(heap) if current_vertex.id in visited: continue visited.add(current_vertex.id) for neighbor_id, weight in current_vertex.neighbors.items(): neighbor = next(v for v in graph if v.id == neighbor_id) if neighbor.id not in visited: new_dist = current_dist + weight if new_dist < neighbor.dist: neighbor.dist = new_dist neighbor.prev = current_vertex heapq.heappush(heap, (new_dist, neighbor)) return {v.id: (v.dist, v.prev.id if v.prev else None) for v in graph}"},{"question":"# Coding Assessment Question You are required to enhance an image processing function that applies various filters to an image. The current implementation only supports converting the image to grayscale. As a developer, you need to extend this functionality to include other filters and handle various edge cases effectively. Function Specifications You must write a function `apply_filters` that processes an image based on the specified filter types and manages different conditions and constraints. **Function Signature**: ```python def apply_filters(image_path: str, filters: list, output_path: str) -> bool: ``` **Expected Input**: - `image_path` (str): The path to the input image file. - `filters` (list): A list of filter names to apply to the image. Supported filters are `grayscale`, `sepia`, and `negative`. - `output_path` (str): The path to save the processed image. **Expected Output**: - Returns `True` if the image was successfully processed and saved, otherwise `False`. **Constraints**: - Ensure the function handles invalid file paths gracefully. - Validate the filter names and ensure they are supported. If an unsupported filter is provided, skip it and proceed with the others. - Handle edge cases such as empty filter list or non-existent output path. - Optimize the function for handling large image files efficiently without excessive memory usage. **Performance Requirements**: - Minimize processing time by optimizing the application of filters. - Ensure the function can handle large image files efficiently. **Context**: Imagine you are developing a photo editing tool that applies various filters to images. Users can select multiple filters to apply in a sequence, and the tool should save the processed image to a specified location. # Example Usage ```python result = apply_filters(\\"input.jpg\\", [\\"grayscale\\", \\"sepia\\"], \\"output.jpg\\") print(result) ``` # Example Output ```python True ``` # Function Implementation Hints - Use image processing libraries such as PIL or OpenCV to apply the filters. - Convert the image to the specified format before applying each filter. - Ensure to save the final processed image to the output path.","solution":"from PIL import Image, ImageOps, ImageEnhance import os def apply_filters(image_path: str, filters: list, output_path: str) -> bool: try: # Load the image image = Image.open(image_path) except (FileNotFoundError, IOError): return False # Apply filters to the image for filter_name in filters: if filter_name == \\"grayscale\\": image = ImageOps.grayscale(image) elif filter_name == \\"sepia\\": image = image.convert(\\"RGB\\") sepia_data = [ (r * 0.393 + g * 0.769 + b * 0.189, r * 0.349 + g * 0.686 + b * 0.168, r * 0.272 + g * 0.534 + b * 0.131) for (r, g, b) in image.getdata() ] image.putdata(list(map(lambda x: (int(x[0]), int(x[1]), int(x[2])), sepia_data))) elif filter_name == \\"negative\\": image = ImageOps.invert(image.convert(\\"RGB\\")) else: # Skip unsupported filters continue # Save the processed image try: image.save(output_path) return True except (FileNotFoundError, IOError): return False"},{"question":"# Warehouse Inventory Management System **Context**: You are tasked with developing a warehouse inventory management system. The system tracks the inventory of various products and allows for adding, updating, and retrieving product information. **Task**: Write a Python class named `Inventory` that supports the following operations: 1. **Add a new product**: Allows adding a new product with a unique product ID, name, category, quantity, and price. 2. **Update product information**: Allows updating the quantity and price of an existing product by its ID. 3. **Get product details**: Retrieves the details of a product by its ID. 4. **Get all products in a category**: Returns a list of all products in a given category. **Constraints**: - Ensure that product IDs are unique. - Raise an appropriate exception if attempting to add a product with a duplicate ID or update a non-existing product. - Handle cases where product details are requested for a non-existing product gracefully. **Class Definition**: ```python class Inventory: def __init__(self): # Initializes an empty inventory pass def add_product(self, product_id: str, name: str, category: str, quantity: int, price: float) -> None: Adds a new product to the inventory. Parameters: - product_id (str): Unique identifier for the product - name (str): Name of the product - category (str): Category of the product - quantity (int): Quantity of the product - price (float): Price of the product Raises: - ValueError: If product_id already exists pass def update_product(self, product_id: str, quantity: int, price: float) -> None: Updates the quantity and price of an existing product by its ID. Parameters: - product_id (str): Unique identifier for the product - quantity (int): Updated quantity of the product - price (float): Updated price of the product Raises: - ValueError: If product_id does not exist pass def get_product(self, product_id: str) -> dict: Retrieves the details of a product by its ID. Parameters: - product_id (str): Unique identifier for the product Returns: - dict: A dictionary containing product details with keys \\"product_id\\", \\"name\\", \\"category\\", \\"quantity\\", and \\"price\\" Raises: - ValueError: If product_id does not exist pass def get_products_by_category(self, category: str) -> list: Retrieves a list of all products in the specified category. Parameters: - category (str): The category to search for products Returns: - list: A list of dictionaries, each containing details of a product in the specified category pass ``` **Example**: ```python # Initialize the inventory inventory = Inventory() # Add some products inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) inventory.add_product(\\"102\\", \\"Widget B\\", \\"Widgets\\", 150, 3.49) inventory.add_product(\\"201\\", \\"Gadget A\\", \\"Gadgets\\", 60, 12.99) # Update a product inventory.update_product(\\"101\\", 120, 2.95) # Get product details print(inventory.get_product(\\"101\\")) # Output: {\'product_id\': \'101\', \'name\': \'Widget A\', \'category\': \'Widgets\', \'quantity\': 120, \'price\': 2.95} # Get all products in the \\"Widgets\\" category print(inventory.get_products_by_category(\\"Widgets\\")) # Output: [{\'product_id\': \'101\', \'name\': \'Widget A\', \'category\': \'Widgets\', \'quantity\': 120, \'price\': 2.95}, {\'product_id\': \'102\', \'name\': \'Widget B\', \'category\': \'Widgets\', \'quantity\': 150, \'price\': 3.49}] ``` # Instructions: 1. Implement the `Inventory` class with the specified methods. 2. Ensure that each method performs the required functionality and handles errors appropriately. 3. Use appropriate data structures to store the inventory information efficiently. 4. Make sure your class raises meaningful error messages when encountering invalid operations.","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: str, name: str, category: str, quantity: int, price: float) -> None: if product_id in self.products: raise ValueError(f\\"Product ID {product_id} already exists.\\") self.products[product_id] = { \\"name\\": name, \\"category\\": category, \\"quantity\\": quantity, \\"price\\": price } def update_product(self, product_id: str, quantity: int, price: float) -> None: if product_id not in self.products: raise ValueError(f\\"Product ID {product_id} does not exist.\\") self.products[product_id][\\"quantity\\"] = quantity self.products[product_id][\\"price\\"] = price def get_product(self, product_id: str) -> dict: if product_id not in self.products: raise ValueError(f\\"Product ID {product_id} does not exist.\\") return {**{\\"product_id\\": product_id}, **self.products[product_id]} def get_products_by_category(self, category: str) -> list: return [ {**{\\"product_id\\": pid}, **details} for pid, details in self.products.items() if details[\\"category\\"] == category ]"},{"question":"# Problem Statement: Create a function `rectangle_diagonal(x1, y1, x2, y2) -> float` that calculates the length of the diagonal of a rectangle given the coordinates of its opposite corners. # Function Signature: ```python def rectangle_diagonal(x1: int, y1: int, x2: int, y2: int) -> float: pass ``` # Input: - `x1` (int): The x-coordinate of the first corner of the rectangle. - `y1` (int): The y-coordinate of the first corner of the rectangle. - `x2` (int): The x-coordinate of the opposite corner of the rectangle. - `y2` (int): The y-coordinate of the opposite corner of the rectangle. # Output: - A float representing the length of the diagonal of the rectangle. # Constraints: - ( -10^4 leq x1, y1, x2, y2 leq 10^4 ). # Requirements: 1. **Accuracy**: The function should calculate the diagonal\'s length correctly using the distance formula. 2. **Efficiency**: The function should compute the result efficiently within provided constraints. # Example: ```python >>> rectangle_diagonal(0, 0, 3, 4) 5.0 >>> rectangle_diagonal(-1, -1, 2, 3) 5.0 >>> rectangle_diagonal(1, 1, 4, 5) 5.0 ``` # Hint: - Utilize the distance formula for calculating the distance between any two points ((x1, y1)) and ((x2, y2)). - The formula for the distance between two points is ( sqrt{(x2 - x1)^2 + (y2 - y1)^2} ).","solution":"import math def rectangle_diagonal(x1, y1, x2, y2) -> float: Calculate the length of the diagonal of a rectangle given the coordinates of its opposite corners. Args: x1 (int): The x-coordinate of the first corner. y1 (int): The y-coordinate of the first corner. x2 (int): The x-coordinate of the opposite corner. y2 (int): The y-coordinate of the opposite corner. Returns: float: The length of the diagonal. return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"# Problem Statement You need to develop an optimized version of the classic Counting Sort algorithm, tailored to handle specific constraints and performance requirements effectively. Your task is to sort a list of non-negative integers where the range of values can be quite large. Implementation Details Implement the function `optimized_counting_sort(sequence: list) -> list` that takes a list of non-negative integers and returns a list of those integers sorted in ascending order. Constraints 1. The input list must contain only non-negative integers. 2. Raise a `TypeError` if the input list contains elements that are not integers or are negative. 3. Aim for an optimized sorting operation with regards to time and space complexities, especially for large value ranges. 4. Ensure no unnecessary memory overhead by efficiently managing space usage. Input and Output Formats *Input*: * `sequence`: A list of non-negative integers. *Output*: * A sorted list of integers in ascending order. Example ```python >>> optimized_counting_sort([6, 11, 12, 4, 1, 5]) [1, 4, 5, 6, 11, 12] >>> optimized_counting_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> optimized_counting_sort([5, 0, 4, 3]) [0, 3, 4, 5] >>> optimized_counting_sort([8, 2, 1]) [1, 2, 8] >>> optimized_counting_sort([1, 2, 0.5, 0.0, 0, -1]) Traceback (most recent call last): ... TypeError: Sequence must be list of non-negative integers ``` Performance Requirements 1. Aim to achieve a Time Complexity of O(n + k), where n is the number of elements and k is the range of input integers. 2. Ensure an efficient Space Complexity, taking advantage of the characteristics of Counting Sort without excessive memory usage. This problem requires you to design a highly efficient sorting function while ensuring that input data is valid and constraints are strictly followed.","solution":"def optimized_counting_sort(sequence): Returns the sorted list of non-negative integers from the input list `sequence`. Raises a TypeError if the input list contains elements that are not integers or are negative. # Validate input if not all(isinstance(x, int) and x >= 0 for x in sequence): raise TypeError(\\"Sequence must be list of non-negative integers\\") if not sequence: return [] max_val = max(sequence) # Initialize counting array count = [0] * (max_val + 1) # Count each element in the sequence for num in sequence: count[num] += 1 # Accumulate the counts index = 0 for i in range(len(count)): while count[i] > 0: sequence[index] = i index += 1 count[i] -= 1 return sequence"},{"question":"# Coding Assessment Question Context You are part of a team developing a new AI-based data validation system. One of the foundational tasks is to verify if the given dataset\'s labels are balanced. For this purpose, you need to implement a function that determines if a dataset has an equal number of positive and negative labels. Problem Statement **Task**: Implement a `is_balanced` function in Python that accepts a list of labels and checks if the dataset is balanced. A dataset is considered balanced if it contains an equal number of positive (`1`) and negative (`-1`) labels. * **Function Specification**: - **Function**: `is_balanced` - **Input**: A list of integers (`labels`) where each integer is either `1` or `-1`. - **Output**: A boolean value (`True` or `False`) indicating if the dataset is balanced. * **Constraints**: - The length of the input list can be between 0 and 10^6. - All elements in the list should be either `1` or `-1`. * **Performance Requirements**: - The solution should have O(n) complexity, where n is the length of the input list. Example Usage ```python def is_balanced(labels: list) -> bool: >>> is_balanced([1, -1, 1, -1]) True >>> is_balanced([1, -1, 1]) False >>> is_balanced([]) True >>> is_balanced([-1, -1, 1, 1, 1, -1]) True >>> is_balanced([1, 1, 1, 1]) False positive_count = labels.count(1) negative_count = labels.count(-1) return positive_count == negative_count ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed. **Explanation**: 1. The function `is_balanced` takes a list of integer labels as input. 2. It counts the number of `1`s and `-1`s in the list. 3. It returns `True` if the counts are equal, otherwise it returns `False`. 4. The provided examples illustrate the expected behavior of the function for various inputs. --- ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def is_balanced(labels: list) -> bool: Function that checks if the dataset is balanced. A dataset is considered balanced if it contains an equal number of positive (1) and negative (-1) labels. Parameters: labels (list): A list of integers where each integer is either 1 or -1. Returns: bool: True if the dataset is balanced, False otherwise. >>> is_balanced([1, -1, 1, -1]) True >>> is_balanced([1, -1, 1]) False >>> is_balanced([]) True >>> is_balanced([-1, -1, 1, 1, 1, -1]) True >>> is_balanced([1, 1, 1, 1]) False positive_count = labels.count(1) negative_count = labels.count(-1) return positive_count == negative_count"},{"question":"Problem Statement In a physics experiment, you are working with a pendulum system to determine characteristics of the pendulum\'s motion. The period of a simple pendulum (the time it takes to complete one full swing back and forth) can be determined using the formula: [ T = 2pi sqrt{frac{L}{g}} ] where: - ( T ) is the period in seconds. - ( L ) is the length of the pendulum in meters. - ( g ) is the acceleration due to gravity in ( m/s^2 ). # Task Write a function named `pendulum_period` that takes two parameters: 1. `length` (float): the length of the pendulum in meters. Must be positive. 2. `gravity` (float): the acceleration due to gravity in ( m/s^2 ). Must be positive. The function should return the period of the pendulum rounded to two decimal places. # Input and Output Format * **Input**: - A float `length`: The length of the pendulum in meters. - A float `gravity`: The acceleration due to gravity in ( m/s^2 ). * **Output**: - A float representing the period of the pendulum in seconds. # Constraints - The `length` and `gravity` must be positive. If any of the constraints are violated, the function should raise a `ValueError` with an appropriate error message. # Example ```python def pendulum_period(length: float, gravity: float) -> float: # Your code here # Example Usage print(pendulum_period(9.8, 9.8)) # Returns 6.28 print(pendulum_period(5, 9.8)) # Returns 4.49 ``` # Notes 1. Use the `math` library to access the value of ( pi ) and to compute the square root. 2. Ensure your function handles all edge cases as specified, raising `ValueError` for invalid inputs.","solution":"import math def pendulum_period(length: float, gravity: float) -> float: Calculate the period of a simple pendulum. Parameters: length (float): The length of the pendulum in meters. Must be positive. gravity (float): The acceleration due to gravity in m/s^2. Must be positive. Returns: float: The period of the pendulum rounded to two decimal places. Raises: ValueError: If any of the parameters are not positive. if length <= 0: raise ValueError(\\"Length must be positive.\\") if gravity <= 0: raise ValueError(\\"Gravity must be positive.\\") period = 2 * math.pi * math.sqrt(length / gravity) return round(period, 2)"},{"question":"# Problem Statement You are required to write a function to identify the contiguous subarray within a one-dimensional array of integers which has the smallest sum. Your task is to find this smallest sum. # Function Signature ```python def min_subarray_sum(nums: List[int]) -> int: Calculate the minimum possible sum of a contiguous subarray. Args: nums (List[int]): List of integers. Returns: int: The smallest sum of all possible contiguous subarrays. ``` # Input * `nums`: A list of integers `nums` (1 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4) # Output * An integer representing the smallest sum of any contiguous subarray within the provided list. # Examples ```python assert min_subarray_sum([1, -3, 2, 1, -1]) == -3 assert min_subarray_sum([4, -1, 2, 1]) == -1 assert min_subarray_sum([-2, -3, -4]) == -9 ``` # Explanation * In the first example, the sub-array `[-3]` has the smallest sum, which is `-3`. * In the second example, the sub-array `[-1]` has the smallest sum, which is `-1`. * In the third example, the sub-array `[-2, -3, -4]` has the smallest sum, which is `-9`. # Additional Context Consider that the array can have negative numbers and the smallest sum may include these negatives. You need to efficiently calculate this using, for example, a modified version of the Kadane’s algorithm, focusing on finding the minimum sum instead of the maximum sum.","solution":"def min_subarray_sum(nums): Calculate the minimum possible sum of a contiguous subarray. Args: nums (List[int]): List of integers. Returns: int: The smallest sum of all possible contiguous subarrays. min_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = min(num, current_sum + num) min_sum = min(min_sum, current_sum) return min_sum"},{"question":"# Problem Statement: You are working on a digital river monitoring system and are required to track the water levels of multiple rivers over time. Write a program that can process water level data, determine the highest level observed, and identify which river it occurred in. # Your Task: Implement the function `max_water_level` which processes input data describing water levels across various rivers and returns the name of the river with the highest recorded water level during the observation period. # Function Signature: ```python def max_water_level(data: List[Tuple[str, List[float]]]) -> str: Input Parameters: ----------------- data : List[Tuple[str, List[float]]] - A list of tuples where each tuple contains: 1. A string representing the river name 2. A list of float values representing the observed water levels of the river over time Returns: -------- str : The river name with the highest recorded water level Raises: ------- ValueError: If the input list is empty or no water levels are provided for any river ``` # Input: * `data` (List[Tuple[str, List[float]]]): A list of tuples where each tuple contains a string representing the river name and a list of float values representing the water levels of that river over time. # Output: * The function should return a string representing the name of the river with the highest recorded water level. # Constraints: * You can assume that all river names are unique. * There is at least one river with at least one recorded water level. * The water level values are non-negative floats. # Examples: ```python >>> max_water_level([(\\"Amazon\\", [23.5, 22.1, 24.2, 23.8]), (\\"Nile\\", [15.1, 14.8, 13.9]), (\\"Yangtze\\", [18.9, 19.6, 20.0, 20.5])]) \\"Amazon\\" >>> max_water_level([(\\"Mississippi\\", [12.3, 15.6, 16.2, 14.9]), (\\"Danube\\", [18.1, 17.4, 21.0, 20.3])]) \\"Danube\\" >>> max_water_level([(\\"Ganges\\", [16.2]), (\\"Volga\\", [17.3]), (\\"Missouri\\", [14.2, 14.9])]) \\"Volga\\" ``` # Notes: * Ensure the function validates input conditions to avoid any erroneous scenarios such as an empty list. * Include relevant exception handling to ensure the robustness of the function.","solution":"from typing import List, Tuple def max_water_level(data: List[Tuple[str, List[float]]]) -> str: if not data: raise ValueError(\\"Input data must not be empty.\\") max_level = -1 river_with_max_level = \\"\\" for river, levels in data: if not levels: raise ValueError(f\\"No water levels provided for river: {river}\\") current_max = max(levels) if current_max > max_level: max_level = current_max river_with_max_level = river return river_with_max_level"},{"question":"# Problem: Find Minimum Depth of a Binary Tree You are given the root of a binary tree. Write a function to find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node (a leaf is a node with no children). Function Signature ```python def min_depth(root: Node) -> int: pass ``` # Constraints * Each node in the binary tree contains an integer value. * The binary tree can have up to 10,000 nodes. * The depth of a node is the number of edges from the root to the node. # Input * `root`: The root node of the binary tree (`Node`). # Output * An integer representing the minimum depth of the binary tree. # Example ```python # The below tree looks like this # 1 # / # 2 3 # # 4 # # 5 tree = Node(1) tree.left = Node(2) tree.right = Node(3) tree.left.right = Node(4) tree.left.right.right = Node(5) print(min_depth(tree)) # Output should be 2 ``` # Explanation The shortest path from the root to a leaf node is through the right child (node 3). The path is 1 -> 3, which gives us a minimum depth of 2. # Performance Expectation * Aim for a time complexity of O(n) and a space complexity that is reasonable for the context, given that the binary tree can have up to 10,000 nodes in the worst case.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_depth(root: Node) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) # (node, depth) while queue: node, depth = queue.popleft() # If we encounter a leaf node, return its depth if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a financial software that assists bankers in determining the loan eligibility of clients based on their credit scores. The software should use a logistic regression model to make predictions about whether a client is likely to default on a loan. Given a dataset of clients\' credit scores and their corresponding default statuses, your task is to implement the logistic regression algorithm to predict the default status of a new client based on their credit score. **Objective**: Implement a function `logistic_regression_predict(train_scores: List[int], train_defaults: List[int], query_score: int) -> float` that predicts the probability of default for a given credit score using logistic regression. **Function signature:** ```python def logistic_regression_predict(train_scores: List[int], train_defaults: List[int], query_score: int) -> float: # Your code here ``` # Inputs: - `train_scores`: A list of integers representing the credit scores of clients in the training dataset. - `train_defaults`: A list of integers (0 or 1) indicating whether each client in the training dataset defaulted (1 for default, 0 for no default). - `query_score`: An integer representing the credit score of the client for whom we want to predict the default probability. # Outputs: - A float representing the probability of default for the client with the given credit score `query_score`. # Constraints: 1. Length of `train_scores` and `train_defaults` is the same and at least 2. 2. All `train_defaults` are either 0 or 1. 3. The logistic regression model should be trained using the input training data. 4. Use a sigmoid function to compute the probability. # Example: ```python train_scores = [600, 650, 700, 750, 800] train_defaults = [1, 0, 0, 0, 0] query_score = 675 # Should return a probability close to the estimated value assert 0 <= logistic_regression_predict(train_scores, train_defaults, query_score) <= 1 ``` **Note**: Ensure to properly train the logistic regression model using the provided training data and handle edge cases appropriately. Optimize the algorithm for best performance where possible.","solution":"from typing import List import numpy as np def sigmoid(z): Compute the sigmoid of z return 1 / (1 + np.exp(-z)) def logistic_regression_predict(train_scores: List[int], train_defaults: List[int], query_score: int) -> float: Predict the probability of default for a given credit score using logistic regression. # Convert lists to numpy arrays X = np.array(train_scores).reshape(-1, 1) y = np.array(train_defaults) # Adding intercept term (bias) to the features X = np.hstack([np.ones((X.shape[0], 1)), X]) # Initialize the weights weights = np.zeros(X.shape[1]) # Learning rate and number of iterations learning_rate = 0.01 num_iterations = 10000 # Gradient Descent to optimize weights for _ in range(num_iterations): predictions = sigmoid(np.dot(X, weights)) errors = y - predictions gradient = np.dot(X.T, errors) weights += learning_rate * gradient # Predict probability for query_score query_data = np.array([1, query_score]) query_prob = sigmoid(np.dot(query_data, weights)) return query_prob"},{"question":"# Coding Assessment Question: Optimized Document Similarity Context: You are tasked with creating a document similarity tool using the TF-IDF (Term Frequency-Inverse Document Frequency) method to compare the content of different documents and return the pair of documents with the highest similarity score. Your goal is to implement an efficient function for computing and identifying the most similar document pair within a collection. Task: Implement the `most_similar_documents` function that reads multiple text documents from provided file paths and calculates the similarity scores using the TF-IDF method to determine the most similar pair of documents. Function Signature: ```python def most_similar_documents(doc_paths: list[str]) -> tuple[str, str, float]: pass ``` Input: - `doc_paths` (list[str]): List of file paths to the text documents. Output: - A tuple containing: - `doc1_path` (str): The path of the first document in the most similar pair. - `doc2_path` (str): The path of the second document in the most similar pair. - `similarity_score` (float): The similarity score between the two documents. Constraints: - Ensure the similarity score is computed accurately based on the TF-IDF representation. - Handle invalid or corrupted text files gracefully. - Consider edge cases such as documents with empty content or a small number of words. - The function should handle a reasonably large number of documents efficiently. Example: ```python doc_paths = [ \\"path/to/document1.txt\\", \\"path/to/document2.txt\\", \\"path/to/document3.txt\\", \\"path/to/document4.txt\\" ] doc1_path, doc2_path, similarity_score = most_similar_documents(doc_paths) ``` **Note**: The function should handle the reading of documents, calculation of TF-IDF vectors, and computation of similarity scores using a suitable method (e.g., cosine similarity). Return the paths of the two most similar documents and their similarity score. You may use existing libraries for handling TF-IDF computation and similarity calculations if needed.","solution":"import os from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics.pairwise import cosine_similarity def most_similar_documents(doc_paths: list[str]) -> tuple[str, str, float]: # Read all documents into a list documents = [] for path in doc_paths: try: with open(path, \'r\', encoding=\'utf-8\') as file: documents.append(file.read()) except Exception as e: print(f\\"Error reading {path}: {e}\\") documents.append(\'\') # Append empty string in case of error # Compute the TF-IDF matrix vectorizer = TfidfVectorizer() tfidf_matrix = vectorizer.fit_transform(documents) # Compute cosine similarity similarity_matrix = cosine_similarity(tfidf_matrix) # Find the pair of documents with the highest similarity score max_similarity = -1 doc_pair = (None, None) for i in range(len(doc_paths)): for j in range(i + 1, len(doc_paths)): if similarity_matrix[i, j] > max_similarity: max_similarity = similarity_matrix[i, j] doc_pair = (doc_paths[i], doc_paths[j]) return doc_pair[0], doc_pair[1], max_similarity"},{"question":"# Coding Assessment Question Context You are required to analyze 2D grid-like data to perform pathfinding with specific movement constraints. The grid consists of cells, which can either be empty or blocked. Given a starting point and a destination point, determine if there\'s a possible path from the start to the destination based on the allowed movements: right, left, up, and down, while avoiding the blocked cells (`#`). The grid boundaries and blocked cells must be considered to prevent out-of-bound errors. Task Write a function `is_path_possible(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool` that takes: - `grid`: a 2D list of strings representing the grid where empty cells are represented by `\'.\'` and blocked cells by `\'#\'`. - `start`: a tuple `(x, y)` representing the starting cell coordinates. - `destination`: a tuple `(x, y)` representing the destination cell coordinates. The function should return `True` if there\'s a path from the start to the destination avoiding the blocked cells, otherwise `False`. Input * `grid`: a 2D list of strings representing a grid with values `\'.\'` or `\'#\'`. * `start`: a tuple of two integers indicating the start position. * `destination`: a tuple of two integers indicating the end position. Output * A boolean value `True` or `False`. # Sample Input 1 ```python grid = [ [\'.\', \'.\', \'.\', \'#\'], [\'#\', \'.\', \'#\', \'#\'], [\'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'#\', \'.\'] ] start = (0, 0) destination = (3, 3) ``` # Sample Output 1 ```python True ``` # Explanation A possible path from `(0, 0)` to `(3, 3)` avoiding blocked cells is through moves: (0,0) -> (0,1) -> (0,2) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (3,3). # Constraints - The grid dimensions are such that `1 <= len(grid), len(grid[0]) <= 100`. - The cells may contain either `\'.\'` (empty) or `\'#\'` (blocked). - The start and destination cells are always empty (`.`). # Edge Cases - When the start and destination positions are the same. - When there\'s no possible path due to complete blockages. - Handling of grid edges to prevent out-of-bound checks. Function Signature ```python from typing import List, Tuple def is_path_possible(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: pass # Implement a function fulfilling the conditions. ```","solution":"from typing import List, Tuple def is_path_possible(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: Determines if there is a path from start to destination in a 2D grid avoiding blocked cells. def is_valid(x, y): # Check if the (x, y) cell is within the grid bounds and is not blocked. return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == \'.\' def bfs(start, destination): from collections import deque queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == destination: return True # Check all four possible directions (right, left, down, up) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False return bfs(start, destination)"},{"question":"# Sum of Unique Elements Objective: You are tasked with implementing the `unique_sum` function, which calculates the sum of the unique elements in an input list. Elements are considered unique if they appear exactly once in the list. Function Signature: ```python def unique_sum(lst: list[int]) -> int: ``` Input: - `lst` (a list of integers): The list of numbers from which to calculate the sum of unique elements. Constraints: (1 leq text{len(lst)} leq 10^5), and (-10^9 leq text{lst[i]} leq 10^9). Output: - An integer representing the sum of elements that appear exactly once in the input list. Requirements: 1. The function should efficiently handle the upper constraints for list length. 2. Only elements that appear exactly once should be included in the sum. 3. Consider edge cases such as an empty list or a list where all elements are duplicates. Example: ```python >>> unique_sum([2, 3, 2, 4, 5]) 12 >>> unique_sum([1, 2, 2, 1, 3, 4]) 7 >>> unique_sum([5, 5, 5, 5, 5]) 0 >>> unique_sum([]) 0 ``` Hint: - Use a dictionary or a collections.Counter to efficiently count the occurrences of each element. - Iterate through the dictionary to sum up the elements that have a count of exactly one. --- Implementation Notes: Implement the `unique_sum` function by following these steps: 1. Handle the special case where the input list is empty. 2. Use a dictionary or collections.Counter to count the occurrences of each element in the list. 3. Iterate through the count dictionary to sum up the elements that appear exactly once. 4. Return the resulting sum.","solution":"def unique_sum(lst: list[int]) -> int: from collections import Counter if not lst: return 0 element_count = Counter(lst) unique_elements_sum = sum(element for element, count in element_count.items() if count == 1) return unique_elements_sum"},{"question":"# Coding Assessment Question: Fibonacci Sequence Generator **Context**: The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. The sequence typically starts with 0 and 1. For example, the first ten numbers of the Fibonacci sequence are: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Task: Write a function `generate_fibonacci_sequence` that generates the first `n` numbers of the Fibonacci sequence. The function should handle various edge cases and input constraints accordingly. # Function Signature: ```python def generate_fibonacci_sequence(n: int) -> list: ``` # Input: * `n` (int): The number of terms to generate, where (0 leq n leq 100). # Output: * `list`: Returns a list containing the first `n` numbers of the Fibonacci sequence. # Constraints: * Raise a `ValueError` if `n` is not an integer. * Raise a `ValueError` if `n` is negative. * Ensure the function\'s performance is sufficient for (0 leq n leq 100). # Examples: ```python assert generate_fibonacci_sequence(0) == [] assert generate_fibonacci_sequence(1) == [0] assert generate_fibonacci_sequence(2) == [0, 1] assert generate_fibonacci_sequence(5) == [0, 1, 1, 2, 3] assert generate_fibonacci_sequence(-1) == ValueError(\\"n must be a non-negative integer\\") assert generate_fibonacci_sequence(\\"string\\") == ValueError(\\"n must be an integer\\") assert generate_fibonacci_sequence(10.5) == ValueError(\\"n must be an integer\\") ``` # Requirements: * Implement the function with an efficient algorithm, considering the provided constraints. * Validate input to ensure it meets the specified criteria. * Ensure the function is robust against various edge cases and handle exceptions properly.","solution":"def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers of the Fibonacci sequence. Parameters: n (int): The number of terms to generate, where 0 <= n <= 100 Returns: list: A list containing the first n numbers of the Fibonacci sequence. if not isinstance(n, int): raise ValueError(\\"n must be an integer\\") if n < 0: raise ValueError(\\"n must be a non-negative integer\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence"},{"question":"# Coding Challenge # Problem Statement Write a function called `merge_sorted_arrays` that takes two sorted lists of integers and merges them into a single sorted list. The merged list should contain all elements from both input lists in non-decreasing order. # Input * Two lists of integers `a` and `b`, both sorted in non-decreasing order. # Output * A single list of integers containing all elements from `a` and `b`, sorted in non-decreasing order. # Constraints * The length of each input list `a` and `b` will be between 0 and 100,000. * Each element in the input lists will be an integer in the range of -10^9 to 10^9. # Example ```python def merge_sorted_arrays(a: List[int], b: List[int]) -> List[int]: pass # Example usage: assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_arrays([-5, -3, 0], [-6, -4, -2]) == [-6, -5, -4, -3, -2, 0] ``` # Instructions * Implement the `merge_sorted_arrays` function. * Ensure the solution has a time complexity of O(m + n), where `m` and `n` are the lengths of the two input lists. * Avoid using built-in sort functions; instead, merge the lists directly. * Consider edge cases such as one or both input lists being empty. # Performance considerations * The function must handle large inputs efficiently. * Ensure the merged result is obtained through a single pass over each input list, maintaining linear time complexity. # Note * The function must be implemented such that it efficiently merges two already sorted lists and provides the combined sorted result.","solution":"def merge_sorted_arrays(a, b): Merges two sorted lists a and b into a single sorted list. merged = [] i, j = 0, 0 while i < len(a) and j < len(b): if a[i] <= b[j]: merged.append(a[i]) i += 1 else: merged.append(b[j]) j += 1 # Append remaining elements of a (if any) while i < len(a): merged.append(a[i]) i += 1 # Append remaining elements of b (if any) while j < len(b): merged.append(b[j]) j += 1 return merged"},{"question":"# Scenario As a software developer for a tech company specializing in shifts and work schedules, you have been assigned the task of developing a utility function to manage employee shifts. The function will determine if an employee’s shift timings overlap with any existing shifts for a given day. This information will be integral to creating a robust and collision-free shift management system. # Task Write a Python function `is_shift_overlapping` to determine if a new shift overlaps with any existing shifts on a given day. The function should take the start and end times of the new shift and compare it against a list of existing shifts to check for any overlap. # Input - `new_shift` (tuple): A tuple representing the start and end time (24-hour format) of the new shift as integers, e.g., (9, 17) for a shift from 9 AM to 5 PM. - `existing_shifts` (list): A list of tuples, where each tuple represents the start and end time (24-hour format) of an existing shift on the same day as integers. # Output - Return a boolean value: `True` if the new shift overlaps with any of the existing shifts, otherwise `False`. # Constraints 1. Start time must be less than end time for all shifts. 2. All times must be within the 24-hour range (0 to 23). # Examples ```python >>> is_shift_overlapping((9, 17), [(8, 12), (13, 18)]) True >>> is_shift_overlapping((7, 9), [(10, 12), (14, 18)]) False >>> is_shift_overlapping((12, 20), [(8, 11), (11, 12)]) False >>> is_shift_overlapping((15, 19), [(14, 16), (18, 22)]) True >>> is_shift_overlapping((10, 12), [(8, 10), (11, 13)]) True ``` # Considerations - Ensure the function checks all possible overlaps: partial overlap at the start, partial overlap at the end, or complete enclosure. - The provided shifts and new shift should be validated to make sure the start time is less than the end time and that the times fall within the 24-hour range.","solution":"def is_shift_overlapping(new_shift, existing_shifts): Determine if a new shift overlaps with any existing shifts. Args: - new_shift (tuple): A tuple containing the start and end time of the new shift. - existing_shifts (list): A list of tuples, each containing the start and end time of existing shifts. Returns: - bool: True if the new shift overlaps with any existing shifts, otherwise False. new_start, new_end = new_shift # Validate the provided shift times if not (0 <= new_start <= 23 and 0 <= new_end <= 23): raise ValueError(\\"Shift times must be within the 24-hour range.\\") if new_start >= new_end: raise ValueError(\\"Start time must be less than end time.\\") for shift in existing_shifts: existing_start, existing_end = shift # Validate the existing shift times if not (0 <= existing_start <= 23 and 0 <= existing_end <= 23): raise ValueError(\\"Shift times must be within the 24-hour range.\\") if existing_start >= existing_end: raise ValueError(\\"Start time must be less than end time.\\") # Check for overlap if new_start < existing_end and new_end > existing_start: return True return False"},{"question":"# Meeting Room Scheduling In a busy office, efficiently scheduling meeting rooms is essential to avoid conflicts. Given a list of meeting time intervals for a single day requested by different teams, determine if a meeting room is available at a given time. Function Signature ```python def is_room_available( intervals: List[Tuple[float, float]], query_time: float ) -> bool: ``` Parameters - **intervals** (*List[Tuple[float, float]]*): A list of tuples where each tuple has two float values representing the start and end times of meetings (both inclusive). - **query_time** (*float*): The time you want to check for room availability. All times are in the 24-hour format as decimal numbers (e.g., 9:30 AM is 9.5, 4:45 PM is 16.75). Both start and end times in each interval are positive floats, and the end time is greater than or equal to the start time. Output - **Returns** (*bool*): True if the room is available at `query_time`, False otherwise. Requirements 1. Ensure that the room is considered available if `query_time` does not fall within any given interval. 2. Raise a `ValueError` with the message `\\"Invalid query_time\\"` if `query_time` is not a positive float. Example ```python # Example 1: intervals = [(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)] query_time = 10.0 print(is_room_available(intervals, query_time)) # Output: True # Example 2: intervals = [(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)] query_time = 12.3 print(is_room_available(intervals, query_time)) # Output: False ``` Ensure that your code is efficient, readable, and properly handles edge cases.","solution":"from typing import List, Tuple def is_room_available(intervals: List[Tuple[float, float]], query_time: float) -> bool: Determine if a meeting room is available at the given time. Parameters: intervals (List[Tuple[float, float]]): A list of tuples with start and end times of meetings. query_time (float): The time to check for room availability. Returns: bool: True if the room is available at query_time, False otherwise. Raises: ValueError: If query_time is not a positive float. if not isinstance(query_time, (int, float)) or query_time < 0: raise ValueError(\\"Invalid query_time\\") for start, end in intervals: if start <= query_time <= end: return False return True"},{"question":"# Coding Assessment Question File Filter Based on Extension You are tasked with extending a file filtering functionality that finds files with specific extensions in a given directory and all its subdirectories. The goal is to create a function that dynamically searches a directory tree and returns a list of file paths, filtered by their extension. # Problem Statement Function: `find_files_by_extension` Write a function `find_files_by_extension` that: - Takes two inputs: a string `directory` representing the path of the directory to search, and a string `extension` representing the file extension to filter by (including the dot, e.g., `.txt`). - Returns a list of strings, where each string is a file path to a file that ends with the specified extension. The function should recursively search all subdirectories of the provided directory. Constraints: 1. The `directory` input is a valid directory path. 2. The `extension` input is a valid file extension starting with a dot followed by alphabets (e.g., `.txt`, `.py`). 3. Your solution should handle directories containing a large number of files efficiently. Specifications: - Input: String `directory`, String `extension` - Output: List of strings representing file paths Example Scenario Given the directory structure: ``` /example_dir ├── file1.txt ├── file2.py ├── subdir1 │ ├── file3.txt │ └── file4.md └── subdir2 └── file5.txt ``` And filtering by the extension `.txt`: ```python result = find_files_by_extension(\'/example_dir\', \'.txt\') print(result) # Output should be: # [\'/example_dir/file1.txt\', \'/example_dir/subdir1/file3.txt\', \'/example_dir/subdir2/file5.txt\'] ``` This demonstrates an example where the function identifies and returns the full paths of all `.txt` files in the directory tree. # Note: Handle edge cases where: - The directory is empty. - The specified extension does not match any files in the directory tree. - Subdirectories contain files of different extensions. Write your implementation in a function `find_files_by_extension` to meet the requirements specified.","solution":"import os def find_files_by_extension(directory, extension): Recursively searches for files with a specified extension in a given directory and its subdirectories Args: directory (str): Path to the directory to search extension (str): File extension to filter by (including the dot, e.g., \'.txt\') Returns: list: List of file paths with the specified extension matching_files = [] for root, _, files in os.walk(directory): for file in files: if file.endswith(extension): matching_files.append(os.path.join(root, file)) return matching_files"},{"question":"# Least Common Multiple Finder You are given a function `find_lcm` that returns the least common multiple (LCM) of two positive integers. The current implementation works correctly for small integers but struggles with performance and numerical stability for very large numbers. Your task is to write a new implementation of the `find_lcm` function that optimizes performance and stability. Your function should handle edge cases and very large numbers efficiently. # Requirements: 1. **Input**: Two integers `a` and `b` where `a, b >= 1`. 2. **Output**: An integer representing the least common multiple of `a` and `b`. 3. **Constraints**: - The inputs must be positive integers (`a, b >= 1`). - The inputs can be very large, up to `10^12`. # Performance: - Optimize the function to handle large integer values efficiently without overflow issues. Additional Requirements: - Raise a `ValueError` for: - Non-positive integers. Example usage: ```python >>> find_lcm(10, 15) 30 >>> find_lcm(21, 6) 42 >>> find_lcm(-5, 10) Traceback (most recent call last): ... ValueError: Non-positive integer was passed to the function >>> find_lcm(12, 0) Traceback (most recent call last): ... ValueError: Non-positive integer was passed to the function ``` Hint: You can use the relationship between GCD (Greatest Common Divisor) and LCM: [ text{LCM}(a, b) = frac{|a times b|}{text{GCD}(a, b)} ] Implement the GCD using Euclid\'s algorithm for efficient computation. # Example Implementation ```python def gcd(a, b): while b: a, b = b, a % b return a def find_lcm(a, b): if a < 1 or b < 1: raise ValueError(\\"Non-positive integer was passed to the function\\") return abs(a * b) // gcd(a, b) ```","solution":"import math def find_lcm(a, b): if a < 1 or b < 1: raise ValueError(\\"Non-positive integer was passed to the function\\") return abs(a * b) // math.gcd(a, b)"},{"question":"# Question: Binary Tree Operations You have been tasked with implementing several fundamental operations on a binary tree data structure. Your goal is to extend the provided `BinaryTree` class with the following features: 1. **In-order Traversal**: Implement a method `in_order_traversal(self) -> list` to perform an in-order traversal of the binary tree and return a list of the node values in the order visited. 2. **Height Calculation**: Implement a method `height(self) -> int` to calculate and return the height of the binary tree. The height of the tree is defined as the number of edges on the longest path from the root to a leaf. If the tree is empty, return -1. 3. **Mirror Image**: Implement a method `mirror_image(self) -> None` to modify the tree so that it becomes the mirror image of itself. The mirror image of a binary tree is obtained by swapping the left and right child of each node. Input: - A `BinaryTree` class and its instance methods. Output: - For `in_order_traversal()`, return a list of node values. - For `height()`, return an integer representing the height of the binary tree. - For `mirror_image()`, return None but mutate the tree to its mirror image. Constraints: - The binary tree can have up to 1000 nodes. - Node values are integers. Example: ```python class BinaryTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None # Implement the methods described above here # Example usage: tree = BinaryTree() tree.root = BinaryTree.Node(1) tree.root.left = BinaryTree.Node(2) tree.root.right = BinaryTree.Node(3) tree.root.left.left = BinaryTree.Node(4) tree.root.left.right = BinaryTree.Node(5) tree.root.right.left = BinaryTree.Node(6) tree.root.right.right = BinaryTree.Node(7) # In-order Traversal print(tree.in_order_traversal()) # Output: [4, 2, 5, 1, 6, 3, 7] # Height Calculation print(tree.height()) # Output: 2 # Mirror Image tree.mirror_image() print(tree.in_order_traversal()) # Output: [7, 3, 6, 1, 5, 2, 4] ```","solution":"class BinaryTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def in_order_traversal(self): result = [] def in_order(node): if node: in_order(node.left) result.append(node.value) in_order(node.right) in_order(self.root) return result def height(self): def height_rec(node): if not node: return -1 left_height = height_rec(node.left) right_height = height_rec(node.right) return 1 + max(left_height, right_height) return height_rec(self.root) def mirror_image(self): def mirror(node): if node: node.left, node.right = node.right, node.left mirror(node.left) mirror(node.right) mirror(self.root)"},{"question":"# Question Given an `n x m` matrix of integers where each row and each column is sorted in increasing order, write a function `find_in_matrix` to search for a given integer target in the matrix. If the target integer exists, return a tuple `(row, col)` representing the position of the target in the matrix (0-indexed). If the target is not found, return `None`. # Function Signature ```python def find_in_matrix(matrix: list, target: int) -> tuple: ``` # Input * An integer matrix `matrix` where `1 <= len(matrix), len(matrix[0]) <= 500`. * An integer `target`. # Output * A tuple of the form `(row, col)` if the target is found, otherwise `None`. # Constraints * The elements in the matrix are sorted in ascending order both row-wise and column-wise. * The matrix is non-empty. * The integer target can be positive, negative, or zero. # Examples ```python # Example 1 matrix = [ [1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12, 15] ] target = 8 print(find_in_matrix(matrix, target)) # Output: (1, 2) # Example 2 matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] target = 6 print(find_in_matrix(matrix, target)) # Output: None # Example 3 matrix = [ [1] ] target = 1 print(find_in_matrix(matrix, target)) # Output: (0, 0) # Example 4 matrix = [ [10, 20, 30], [15, 25, 35], [24, 29, 37] ] target = 25 print(find_in_matrix(matrix, target)) # Output: (1, 1) # Example 5 matrix = [ [-5, -3, 0, 2], [-4, 1, 2, 3], [-3, 2, 3, 4] ] target = 2 print(find_in_matrix(matrix, target)) # Output: (0, 3) ``` # Explanation * In **Example 1**, the target integer `8` is located at the position `(1, 2)` in the matrix. * In **Example 2**, the target integer `6` is not present in the matrix, so the function returns `None`. * In **Example 3**, the target integer `1` is at the position `(0, 0)` of the single-element matrix. * In **Example 4**, the target integer `25` is located at the position `(1, 1)` in the matrix. * In **Example 5**, the target integer `2` is located at the position `(0, 3)` in the matrix. # Additional Information * Consider edge cases such as matrices with a single row or a single column. * The search should be efficient and take advantage of the sorted property of the matrix to find the target with minimum comparisons.","solution":"def find_in_matrix(matrix, target): Find the target value in a sorted matrix and return its position (row, col). Return None if the target is not found. rows = len(matrix) cols = len(matrix[0]) # Start from top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] < target: row += 1 else: col -= 1 return None"},{"question":"# Problem Statement Write a function `merge_and_count` that merges two sorted lists of integers into a single sorted list and counts the number of \\"inversions\\" during the merge. An inversion is a scenario where a larger integer appears before a smaller integer in the list. # Function Specification: - **merge_and_count(arr1: list, arr2: list) -> tuple**: - Merges two sorted lists `arr1` and `arr2` into a single sorted list. - Additionally, counts the number of inversions during the merge process. - **Input**: Two sorted lists of integers `arr1` and `arr2` where each element -10^6 <= x <= 10^6). - **Output**: A tuple containing two elements: - A list of integers representing the merged sorted list. - An integer counting the total number of inversions. # Constraints: - The combined length of the two input lists will not exceed 10^6 elements. - Lists `arr1` and `arr2` are both pre-sorted in non-decreasing order. # Implementation Details: - The function should efficiently handle the merge and inversion count within a reasonable time limit. - Ensure proper handling for edge cases such as empty lists. Here is an initial structure of the function for reference: ```python def merge_and_count(arr1: list, arr2: list) -> tuple: # Your code here pass ``` # Example Usage ```python list1 = [1, 3, 5] list2 = [2, 4, 6] merged_list, inversions = merge_and_count(list1, list2) print(merged_list) # Output: [1, 2, 3, 4, 5, 6] print(inversions) # Output: 3 (since there are three inversions: (3, 2), (5, 2), and (5, 4)) ``` # Explanation of Example - Merging [1, 3, 5] and [2, 4, 6] results in [1, 2, 3, 4, 5, 6]. - There are three inversions: 3 comes before 2, 5 comes before 2, and 5 comes before 4. - Thus, the count of inversions is 3.","solution":"def merge_and_count(arr1: list, arr2: list) -> tuple: merged = [] i = j = inversions = 0 len1, len2 = len(arr1), len(arr2) while i < len1 and j < len2: if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 inversions += (len1 - i) while i < len1: merged.append(arr1[i]) i += 1 while j < len2: merged.append(arr2[j]) j += 1 return merged, inversions"},{"question":"# Problem Description A certain encoding scheme maps a string of digits to specific alphabetic characters. The encoding is as follows: - \'1\' maps to \'A\' - \'2\' maps to \'B\' - ... - \'26\' maps to \'Z\' Write a function `decode_ways(encoded: str) -> list[str]` that returns all possible ways to decode a given string of digits into alphabetic characters according to the encoding scheme. # Input * `encoded`: A non-empty string consisting of digits (\'0\' through \'9\'). # Output * A list of strings, where each string represents a possible decoded sequence of the input digits. # Example ```python >>> decode_ways(\\"12\\") [\'AB\', \'L\'] >>> decode_ways(\\"226\\") [\'BBF\', \'BZ\', \'VF\'] >>> decode_ways(\\"0\\") [] >>> decode_ways(\\"11106\\") [\'AAJF\', \'KJF\'] ``` # Constraints * The encoded string does not start with \'0\'. * The function should handle invalid encodings appropriately by not including them in the results. * The function should handle large input strings efficiently. # Performance Requirements The implementation should ensure efficient handling using recursive backtracking or dynamic programming to reduce time complexity.","solution":"def decode_ways(encoded): Returns a list of all possible ways to decode a string of digits into alphabetic characters. :param encoded: A string of digits. :return: A list of strings. if not encoded: return [] # Function to check if a substring can be decoded def is_valid(s): return s[0] != \'0\' and 1 <= int(s) <= 26 # Helper function for recursive backtracking def helper(index): if index == len(encoded): return [\\"\\"] # Decode single digit result = [] if is_valid(encoded[index:index + 1]): for suffix in helper(index + 1): result.append(chr(int(encoded[index:index + 1]) - 1 + ord(\'A\')) + suffix) # Decode double digit if index + 1 < len(encoded) and is_valid(encoded[index:index + 2]): for suffix in helper(index + 2): result.append(chr(int(encoded[index:index + 2]) - 1 + ord(\'A\')) + suffix) return result return helper(0)"},{"question":"# Question: Balanced Substring Write a function `balanced_substring(s: str, n: int) -> int` that searches for the longest substring of a given string `s` such that the number of characters \'a\' and \'b\' in the substring is exactly `n`. Function Signature ```python def balanced_substring(s: str, n: int) -> int: ``` Input * `s` (str): The input string containing only characters \'a\' and \'b\'. * `n` (int): The target count for both characters \'a\' and \'b\' in the substring. Output * An integer indicating the length of the longest substring containing exactly `n` \'a\' characters and `n` \'b\' characters. If no such substring exists, return 0. Constraints * The length of `s` will be between 1 and 10^5. * `n` will be a non-negative integer. Example ```python balanced_substring(\\"aabbab\\", 2) # Should return 4 because the substring \\"aabb\\" has exactly 2 \'a\'s and 2 \'b\'s. balanced_substring(\\"ababab\\", 3) # Should return 6 because the entire string \\"ababab\\" has exactly 3 \'a\'s and 3 \'b\'s. balanced_substring(\\"aaaa\\", 1) # Should return 0 because there are no substrings with exactly 1 \'a\' and 1 \'b\'. ``` Notes 1. Implement the function to efficiently handle the string length constraints. 2. Consider using a sliding window technique to achieve optimal performance. 3. **Performance requirements**: Aim for a solution that works in O(n) time complexity where n is the length of the string `s`.","solution":"def balanced_substring(s: str, n: int) -> int: max_len = 0 a_count, b_count = 0, 0 left = 0 for right in range(len(s)): if s[right] == \'a\': a_count += 1 elif s[right] == \'b\': b_count += 1 while a_count > n or b_count > n: if s[left] == \'a\': a_count -= 1 elif s[left] == \'b\': b_count -= 1 left += 1 if a_count == n and b_count == n: max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Problem Statement Write a function that calculates the minimum number of operations required to convert a given string `s1` into another string `s2` using the following operations: 1. Insert a character 2. Delete a character 3. Replace a character The function should return the minimum number of operations required. # Input - Two strings `s1` and `s2` where `s1` and `s2` only consist of lowercase English letters (a-z). # Output - An integer representing the minimum number of operations required to convert `s1` to `s2`. # Constraints 1. Both strings `s1` and `s2` have lengths in the range `[0, 1000]`. # Requirements 1. Implement the function `min_operations(s1: str, s2: str) -> int` that adheres to the above constraints and solves the problem. 2. The function should be efficient and handle edge cases appropriately. 3. Ensure your code is well-documented and clear. # Example ```python assert min_operations(\\"kitten\\", \\"sitting\\") == 3 assert min_operations(\\"flaw\\", \\"lawn\\") == 2 ``` # Explanation - In the first example, the minimum operations to convert \\"kitten\\" to \\"sitting\\" are 3: 1. Replace \'k\' with \'s\' 2. Insert \'i\' after \'t\' 3. Insert \'g\' at the end - In the second example, the minimum operations to convert \\"flaw\\" to \\"lawn\\" are 2: 1. Replace \'f\' with \'l\' 2. Replace \'w\' with \'n\' # Function Signature ```python def min_operations(s1: str, s2: str) -> int: # Your code here pass ``` # Evaluation Your solution will be evaluated based on: 1. **Correctness**: Accurate computation of the minimum number of operations. 2. **Efficiency**: Use of efficient algorithms to handle the conversion. 3. **Code Quality**: Clear, readable, and well-commented code.","solution":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 to s2. The operations allowed are insert, delete, and replace a character. m = len(s1) n = len(s2) # Create a 2D array to store the number of edits required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # If s2 is empty, all characters of s1 need to be deleted for j in range(n + 1): dp[0][j] = j # If s1 is empty, all characters of s2 need to be inserted # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Coding Assessment Question **Problem Statement**: You are provided with a string `s` which consists of lowercase Latin letters. Your task is to write a function `longest_distinct_substring` that returns the length of the longest substring with all distinct characters. If the input is invalid (not a string), the function should raise a `ValueError` with a message \\"Input must be a string\\". **Function Signature**: ```python def longest_distinct_substring(s: str) -> int: pass ``` **Input**: * A string `s` (0 <= len(s) <= 10^5), consisting of lowercase Latin letters. **Output**: * An integer representing the length of the longest substring with all distinct characters. **Constraints**: * The input must be a string. If the input is not valid, raise a `ValueError` with the message \\"Input must be a string\\". **Examples**: ```python assert longest_distinct_substring(\\"abcabcbb\\") == 3 assert longest_distinct_substring(\\"bbbbb\\") == 1 assert longest_distinct_substring(\\"pwwkew\\") == 3 assert longest_distinct_substring(\\"\\") == 0 assert longest_distinct_substring(\\"abcd\\") == 4 try: longest_distinct_substring(1234) except ValueError as e: assert str(e) == \\"Input must be a string\\" try: longest_distinct_substring([1, 2, 3, 4]) except ValueError as e: assert str(e) == \\"Input must be a string\\" ``` **Performance Requirement**: You should ensure that the function runs efficiently for large string lengths up to `10^5`.","solution":"def longest_distinct_substring(s: str) -> int: if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"# Coding Assessment Question Context: A valid mountain array is an array that: 1. Length is at least 3. 2. There exists some index `i` (0 < i < len(array) - 1) such that: - `array[0] < array[1] < ... < array[i - 1] < array[i]` - `array[i] > array[i + 1] > ... > array[len(array) - 1]`. Your task is to determine whether a given list of integers forms a valid mountain array. Task: Write a function `is_valid_mountain_array(arr: list) -> bool` that determines if the provided list of integers forms a valid mountain array. The function should implement the following steps: 1. Check the length of the list. If it is less than 3, return `False`. 2. Identify and validate the peak element that meets the mountain array requirements. 3. Verify that elements before and after the peak element strictly increase and decrease, respectively. Input: * `arr` (list of integers, 0 <= len(arr) <= 10^4): List of integers. Output: * Boolean value, `True` if the list forms a valid mountain array, and `False` otherwise. Constraints: * You may assume the list `arr` contains only integers. Performance Requirements: * The algorithm should efficiently handle the upper limit case (`len(arr) = 10^4`). Example: ```python assert is_valid_mountain_array([2, 1]) == False assert is_valid_mountain_array([3, 5, 5]) == False assert is_valid_mountain_array([0, 3, 2, 1]) == True ``` Good luck! Ensure you handle edge cases and optimize your solution for large lists.","solution":"def is_valid_mountain_array(arr: list) -> bool: Determines if the given list of integers is a valid mountain array. Parameters: arr (list of integers): The list of integers to check. Returns: bool: True if the list forms a valid mountain array, False otherwise. if len(arr) < 3: return False i = 1 # Ascend to the peak while i < len(arr) and arr[i] > arr[i - 1]: i += 1 # Peak can\'t be the first or the last if i == 1 or i == len(arr): return False # Descend from the peak while i < len(arr) and arr[i] < arr[i - 1]: i += 1 # If we\'ve gone through the entire array return i == len(arr)"},{"question":"# Recursive Sum Context: Recursion is a powerful tool in computer science that can simplify the implementation of complex functions by breaking them down into simpler, self-referential steps. A common example of using recursion is to calculate the sum of all numbers in a list. In this exercise, your task is to implement a recursive function that computes the sum of all integers in a given list. Task: Implement the function `recursive_sum(numbers: list) -> int`, which recursively calculates the sum of all integers in the provided list. Input: - **numbers**: A list of integers `0 <= len(numbers) <= 10^4` where each integer `-10^6 <= numbers[i] <= 10^6`. Output: - A single integer representing the sum of all integers in the input list. Constraints: 1. The function should handle an empty list by returning 0. 2. The input list may contain both positive and negative integers. Example: ```python numbers = [1, 2, 3, 4, 5] print(recursive_sum(numbers)) # Output: 15 numbers = [-1, 2, -3, 4, -5] print(recursive_sum(numbers)) # Output: -3 numbers = [] print(recursive_sum(numbers)) # Output: 0 ``` Performance Requirements: - Your implementation should operate within reasonable time limits for input lists up to 10,000 elements.","solution":"def recursive_sum(numbers): Recursively calculates the sum of all integers in the provided list. if not numbers: return 0 return numbers[0] + recursive_sum(numbers[1:])"},{"question":"# Question You are given an unsorted array of integers and an integer ( k ). Your task is to write a function that returns the ( k )th smallest element in the array. Implement an efficient solution with an average time complexity of ( O(n) ), leveraging the Quickselect algorithm. # Function Signature ```python def kth_smallest_element(nums: list[int], k: int) -> int: ``` # Input - `nums`: a list of integers, may contain duplicate elements. - `k`: an integer representing the position of the smallest element to find (1-indexed). # Output - An integer representing the ( k )th smallest element in the array. # Constraints - ( 1 leq k leq text{len}(nums) ) - ( 1 leq text{len}(nums) leq 10^5 ) - Integer values will be within the range of -10^9 to 10^9. # Examples ```python >>> kth_smallest_element([3, 1, 2, 4, 5], 2) 2 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 1) 3 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 6) 20 ``` # Explanation - In the first example, the 2nd smallest element in ([3, 1, 2, 4, 5]) is `2`. - In the second example, the 4th smallest element in ([7, 10, 4, 3, 20, 15]) is `10`. - If the ( k ) is 1, return the smallest element in the list. - If the ( k ) equals the length of the list, return the largest element in the list. Implement your function in Python: ```python def kth_smallest_element(nums: list[int], k: int) -> int: # Your code here # ```","solution":"def kth_smallest_element(nums: list[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(left, right, k_smallest): if left == right: return nums[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"# Problem Statement You are provided with an implementation of the Trie data structure capable of efficient insert and search operations. Your task is to utilize this data structure to solve a specific problem. # Problem Description Given a list of words, construct a Trie and determine which words from a given list of queries can be found in the Trie. # Requirements * Implement the function `find_words_in_trie(words: List[str], queries: List[str]) -> Dict[str, bool]`. * Construct a Trie from the given list of words. * For each word in the `queries` list, determine if it exists in the Trie. * Return a dictionary where each key is a query word and the corresponding value is `True` if the word is found in the Trie and `False` otherwise. # Input * `words` - A list of words to be inserted into the Trie. ```python words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\", \\"strawberry\\"] ``` * `queries` - A list of query words to search for in the Trie. ```python queries = [\\"banana\\", \\"grapefruit\\", \\"orange\\", \\"blueberry\\"] ``` # Output * Return a dictionary where the keys are the query words and the values are booleans indicating whether each word is found in the Trie. ```python { \\"banana\\": True, \\"grapefruit\\": False, \\"orange\\": True, \\"blueberry\\": False } ``` # Constraints * The total number of words should not exceed (10^4). * Each word should not exceed 50 characters in length. * Words and queries are case-sensitive. # Function Signature ```python from typing import List, Dict def find_words_in_trie(words: List[str], queries: List[str]) -> Dict[str, bool]: pass ``` # Example Input ```python words = [\\"cat\\", \\"dog\\", \\"rat\\", \\"bat\\", \\"cow\\"] queries = [\\"cat\\", \\"batman\\", \\"cow\\", \\"tiger\\"] ``` Output ```python { \\"cat\\": True, \\"batman\\": False, \\"cow\\": True, \\"tiger\\": False } ```","solution":"from typing import List, Dict class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def find_words_in_trie(words: List[str], queries: List[str]) -> Dict[str, bool]: trie = Trie() for word in words: trie.insert(word) result = {} for query in queries: result[query] = trie.search(query) return result"},{"question":"# Coding Assessment Question Context You are developing a tool to analyze text data from different sources. As part of this tool, you need to parse textual data from a CSV file and perform some basic statistical analysis on the text. Task Create a function `analyze_text_stats_from_csv(file_path: str) -> dict` which: 1. Reads a CSV file from the provided file path. The CSV file contains a single column named \\"text\\". 2. Computes the following statistics: - Total number of rows. - Average length of text (in characters). - The most common word and its frequency. 3. Returns the statistics in a dictionary with keys `\'total_rows\'`, `\'avg_length\'`, and `\'most_common_word\'`. Requirements 1. Implement the function `analyze_text_stats_from_csv(file_path: str) -> dict`. 2. The CSV file will have a consistent structure with the first row as the header. 3. Use the `csv` module for reading the CSV file. 4. Handle potential errors such as file not found or incorrect format gracefully. 5. Ensure the function can handle large files efficiently. Input and Output * **Input**: A string `file_path` representing the path to the CSV file. * **Output**: A dictionary with keys `\'total_rows\'`, `\'avg_length\'`, and `\'most_common_word\'`. The value for `\'most_common_word\'` should be a tuple containing the word and its frequency, e.g., `(\'the\', 42)`. Constraints * Assume the CSV file contains only textual data in the \\"text\\" column. * Ensure the function handles common file I/O errors gracefully. * The input file path will always be valid in the testing environment. Example: ```python >>> stats = analyze_text_stats_from_csv(\\"sample.csv\\") >>> print(stats) { \'total_rows\': 100, \'avg_length\': 34.5, \'most_common_word\': (\'example\', 15) } ```","solution":"import csv from collections import Counter def analyze_text_stats_from_csv(file_path: str) -> dict: try: with open(file_path, newline=\'\', encoding=\'utf-8\') as csvfile: reader = csv.DictReader(csvfile) texts = [row[\'text\'] for row in reader] if not texts: return { \'total_rows\': 0, \'avg_length\': 0, \'most_common_word\': (\'\', 0), } # Calculate total number of rows total_rows = len(texts) # Calculate average length of text total_length = sum(len(text) for text in texts) avg_length = total_length / total_rows if total_rows > 0 else 0 # Calculate the most common word and its frequency all_words = \' \'.join(texts).split() word_counter = Counter(all_words) most_common_word = word_counter.most_common(1)[0] if word_counter else (\'\', 0) return { \'total_rows\': total_rows, \'avg_length\': avg_length, \'most_common_word\': most_common_word, } except FileNotFoundError: return { \'total_rows\': 0, \'avg_length\': 0, \'most_common_word\': (\'\', 0), } except Exception as e: print(f\\"An error occurred: {e}\\") return { \'total_rows\': 0, \'avg_length\': 0, \'most_common_word\': (\'\', 0), }"},{"question":"Stack Implementation with Minimum Value Retrieval Context You are tasked with implementing a stack data structure that supports not only typical stack operations (push, pop, and top) but also includes a `get_min` operation that retrieves the minimum element currently in the stack in constant time O(1). Task Write a class `MinStack` that implements the following methods: - `push(val: int) -> None`: Pushes the element `val` onto the stack. - `pop() -> None`: Removes the element on top of the stack. - `top() -> int`: Retrieves the top element of the stack. - `get_min() -> int`: Retrieves the minimum element in the stack. Input/Output Formats * `push(val: int) -> None`: It takes an integer `val` as an input and returns nothing. * Example: `stack.push(10)` * `pop() -> None`: It takes no arguments and returns nothing. * Example: `stack.pop()` * `top() -> int`: It takes no arguments and returns an integer. * Example: `stack.top() -> 10` * `get_min() -> int`: It takes no arguments and returns an integer. * Example: `stack.get_min() -> 5` Constraints * `val` can be any integer. * `pop()`, `top()`, and `get_min()` operations will only be called on non-empty stacks. Requirements * All operations (`push`, `pop`, `top`, and `get_min`) should run in constant time O(1). * The stack should maintain its state correctly after each operation. Example Code ```python class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] # Test Cases stack = MinStack() stack.push(-2) stack.push(0) stack.push(-3) print(stack.get_min()) # Output: -3 stack.pop() print(stack.top()) # Output: 0 print(stack.get_min()) # Output: -2 ``` Note * Ensure the class handles edge cases such as pushing and popping elements in correct sequence to maintain the correct state for minimum retrieval. * Your implementation should not use built-in libraries that provide stack or minimum functionalities directly.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"# Coding Assessment Question You have been assigned the task of developing a feature to calculate the maximum length of consecutive numbers in a given sequence. This functionality is beneficial for analyzing sequences in various applications such as identifying the longest run of consistent temperatures or stock prices. Requirements: 1. Implement a function `max_consecutive_length` that takes a list of integers and returns the maximum length of consecutive sequences. 2. A consecutive sequence is defined as a subsequence where each element is exactly one more than the previous element. 3. The function should consider both positive and negative integers. # Function Signature ```python def max_consecutive_length(nums: List[int]) -> int: Calculate the maximum length of consecutive numbers in a list. :param nums: List of integers :type nums: List[int] :return: Length of the longest consecutive sequence :rtype: int pass ``` # Input - A list of integers, `nums`, which can contain both positive and negative integers. # Output - An integer representing the maximum length of consecutive numbers in the input list. # Constraints - The list `nums` can contain at most (10^5) elements. - The solution should be optimized for performance, ideally with a time complexity better than (O(n^2)). # Examples ```python # Example Input 1 nums1 = [100, 4, 200, 1, 3, 2] # Example Output 1 print(max_consecutive_length(nums1)) # Output: 4 (because the longest consecutive sequence is [1, 2, 3, 4]) # Example Input 2 nums2 = [0, -1, 1, 2, -2, 5, 6] # Example Output 2 print(max_consecutive_length(nums2)) # Output: 5 (because the longest consecutive sequence is [-2, -1, 0, 1, 2]) # Example Input 3 nums3 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1] # Example Output 3 print(max_consecutive_length(nums3)) # Output: 13 (because the longest consecutive sequence is [-1, 0, 1, 2, ..., 11]) ``` # Additional Information A naive (O(n^2)) approach would not be efficient given the constraints, so it is recommended to explore sorting-based or hash-based algorithms to achieve optimal performance. Document any assumptions and design choices clearly in your code, along with any auxiliary functions used.","solution":"from typing import List def max_consecutive_length(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num length = 1 while current_num + 1 in num_set: current_num += 1 length += 1 max_length = max(max_length, length) return max_length"},{"question":"# Arrange Elements In Alternating Sequence You have been given an array of integers `arr`, which contains even number of elements. Your task is to write a function `arrange_alternating(arr: List[int]) -> List[int]` that rearranges the array such that it forms an alternating sequence of positive and negative numbers. The first element of the output array should be positive if such exists. If there are more positive numbers than negative nums or vice-versa, then append the remaining numbers (preserving their original relative order) at the end of the sequence. # Input - `arr` (2 ≤ len(arr) ≤ 1000) - An array of integers containing an even number of elements. # Output - The function should return a new array which alternates between positive and negative integers, starting with a positive integer if possible. # Constraints - Each number in the array will be between -10^6 and 10^6. - The array will contain an even number of elements. # Examples ```python >>> arrange_alternating([1, 2, -3, -4, -2, 6]) [1, -3, 2, -4, 6, -2] >>> arrange_alternating([-1, -2, 3, 4, 5, -6]) [3, -1, 4, -2, 5, -6] >>> arrange_alternating([1, -1, 2, -2, 3, -3]) [1, -1, 2, -2, 3, -3] >>> arrange_alternating([4, -1, -2, -3, 7, 9]) [4, -1, 7, -2, 9, -3] ``` # Guidelines - First, separate the given array into two lists: one containing all positive numbers and the other containing all negative numbers. - Iterate over the lists and create an alternating sequence by picking elements from each list. - If one list is exhausted before the other, append the remaining elements from the non-exhausted list at the end of the resulting array. - Maintain the relative order of both positive and negative lists in the final array.","solution":"from typing import List def arrange_alternating(arr: List[int]) -> List[int]: positive = [num for num in arr if num > 0] negative = [num for num in arr if num < 0] result = [] i, j = 0, 0 while i < len(positive) and j < len(negative): if len(result) == 0 or result[-1] < 0: result.append(positive[i]) i += 1 else: result.append(negative[j]) j += 1 # If positives remain while i < len(positive): result.append(positive[i]) i += 1 # If negatives remain while j < len(negative): result.append(negative[j]) j += 1 return result"},{"question":"# Problem Statement Implement a function that simulates a basic calculator with an additional feature of storing the last result. The calculator should be able to handle basic arithmetic operations such as addition, subtraction, multiplication, division, and exponentiation. Getting the result of an operation should also store this result, which should be retrievable with a special command. # Implementation Details Implement the following class: ```python class Calculator: def __init__(self): Initialize the calculator with a last result storage. self.last_result = 0 def operate(self, operation: str) -> float: Perform the given operation and return the result. Update the last result with the outcome of this operation. Args: operation (str): A valid arithmetic expression (e.g., \\"3 + 4\\"). Returns: float: The result of the arithmetic operation. Examples: >>> calc = Calculator() >>> calc.operate(\\"3 + 4\\") 7.0 >>> calc.operate(\\"10 - 3.5\\") 6.5 >>> calc.operate(\\"2 * 5\\") 10.0 >>> calc.operate(\\"8 / 2\\") 4.0 >>> calc.operate(\\"2 ** 3\\") 8.0 >>> calc.get_last_result() 8.0 pass def get_last_result(self) -> float: Retrieve the last stored result. Returns: float: The last result stored. Examples: >>> calc = Calculator() >>> calc.operate(\\"3 + 4\\") 7.0 >>> calc.get_last_result() 7.0 pass ``` Input * `operation`: A string representing a valid arithmetic expression involving two numeric operands and one operator. * Valid operators include: `+`, `-`, `*`, `/`, `**`. Output * The result of the arithmetic operation as a float. * The last result when queried. Constraints * The inputs in the expression are always valid numbers. * Division by zero should raise a `ZeroDivisionError`. * You can assume the arithmetic expression is well-formed and contains exactly two operands and one operator. * The function should handle large numbers within the constraints of standard floating-point arithmetic. # Points to Consider * Handle arithmetic operations accurately. * Ensure the last result is correctly updated and retrievable. Performance Requirements * The function should perform operations within a reasonable time frame for any input size within typical arithmetic ranges.","solution":"class Calculator: def __init__(self): Initialize the calculator with a last result storage. self.last_result = 0.0 def operate(self, operation: str) -> float: Perform the given operation and return the result. Update the last result with the outcome of this operation. Args: operation (str): A valid arithmetic expression (e.g., \\"3 + 4\\"). Returns: float: The result of the arithmetic operation. self.last_result = eval(operation) return self.last_result def get_last_result(self) -> float: Retrieve the last stored result. Returns: float: The last result stored. return self.last_result"},{"question":"# Problem Statement: Top-K Frequent Elements You are given a non-empty list of integers, and an integer `k`. Your task is to find the `k` most frequent elements in the list. Your solution should run in O(n log k) time complexity. # Function Signature ```python def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: :param nums: A list of integers. :param k: An integer representing the number of most frequent elements to return. :return: A list of integers representing the k most frequent elements. ``` # Input * `nums`: a list of integers. (1 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4) * `k`: an integer (1 ≤ k ≤ the number of unique elements in `nums`) # Output * A list of integers representing the `k` most frequent elements in the list. # Constraints * The output elements should be in the order of their frequency from highest to lowest. * If two elements have the same frequency, the order of their appearance in the output does not matter. # Example ```python assert top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert top_k_frequent_elements([1], 1) == [1] assert top_k_frequent_elements([4, 4, 4, 2, 2, 3, 3, 3, 1, 5], 3) == [4, 3, 2] ``` # Notes * Use a heap or priority queue to efficiently get the top `k` frequent elements. * You may use Python\'s `collections.Counter` for counting the frequency of elements and heapq\'s `nlargest` function to efficiently retrieve the top `k` elements.","solution":"from typing import List from collections import Counter import heapq def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in nums. # Step 1: Count the frequency of elements in nums count = Counter(nums) # Step 2: Use a heap to get the k most frequent elements # Using nlargest to find k keys with the most frequent values most_common = heapq.nlargest(k, count.keys(), key=count.get) return most_common"},{"question":"# Coding Assessment Question: Number Range Summarization As a proficient developer, you are tasked with creating a system to summarize ranges of numbers. This is especially useful in scenarios where you want to represent large sets of consecutive numbers succinctly. **Context:** In many applications, such as generating summaries or reports, handling sequences of consecutive numbers efficiently is crucial. For instance, if you have millions of log entries indicating event IDs, summarizing continuous ranges can save significant space and improve readability. # Task: Implement a function `summarize_ranges(numbers: list[int]) -> list[str]` that takes a list of integers and summarizes consecutive number sequences by representing each continuous range as `start-end`. Non-consecutive numbers should be represented individually. # Specifications: 1. **Function to Summarize Ranges** ```python def summarize_ranges(numbers: list[int]) -> list[str]: ``` - **Input**: `numbers` (list of int) - A sorted list of integers (no duplicates). - **Output**: List of strings, each representing a number or a range of numbers. # Requirements: - Ranges should be expressed in the format `start-end` if they contain more than one number. - Single numbers should be represented as they are. - The input list is guaranteed to be sorted without duplicates. # Sample Input: ```python numbers = [1, 2, 3, 7, 8, 10, 11, 12, 14, 15, 16, 20] ``` # Sample Output: ```python [\'1-3\', \'7-8\', \'10-12\', \'14-16\', \'20\'] ``` # Example Usage: ```python numbers = [1, 2, 3, 7, 8, 10, 11, 12, 14, 15, 16, 20] print(summarize_ranges(numbers)) # Output: [\'1-3\', \'7-8\', \'10-12\', \'14-16\', \'20\'] ``` # Performance Requirements: - Solutions should aim to minimize time complexity. - Handle edge cases, such as empty lists and lists with non-consecutive numbers only. # Testing: - Write unit tests to cover various scenarios, including typical, edge, and corner cases. Good luck!","solution":"def summarize_ranges(numbers: list[int]) -> list[str]: if not numbers: return [] summarized = [] start = numbers[0] end = numbers[0] for i in range(1, len(numbers)): if numbers[i] == end + 1: end = numbers[i] else: if start == end: summarized.append(f\\"{start}\\") else: summarized.append(f\\"{start}-{end}\\") start = numbers[i] end = numbers[i] if start == end: summarized.append(f\\"{start}\\") else: summarized.append(f\\"{start}-{end}\\") return summarized"},{"question":"# Integer Abrasion Challenge You are asked to implement a function `abrade_integer` that takes an integer `n` and a list of integers `abrasion_factors`. The function should return an integer that has been \\"abraded\\" by the abrasion factors. Abrasion means decreasing the given integer `n` by continuously subtracting each abrasion factor from the result until the final abrading factor or until a non-positive result is achieved. # Function Signature: ```python def abrade_integer(n: int, abrasion_factors: List[int]) -> int: pass ``` # Input: - `n` (1 ≤ n ≤ 10^6): A single integer which needs to be abraded. - `abrasion_factors` (1 ≤ len(abrasion_factors) ≤ 100, 1 ≤ abrasion_factors[i] ≤ 10^6): A list of integers representing abrasion factors. # Output: - The function should return the final abraded integer value. # Example: ```python print(abrade_integer(50, [5, 3, 8])) # Output: 34 print(abrade_integer(10, [2, 5, 3])) # Output: 0 print(abrade_integer(100, [1, 10, 20, 5])) # Output: 64 ``` # Explanation: - In the first example, starting from 50, we subtract 5 (resulting in 45), then 3 (resulting in 42), then 8 (resulting in 34). - In the second example, starting from 10, we subtract 2 (resulting in 8), then 5 (resulting in 3), then 3 (resulting in 0, a non-positive value). # Constraints: - The function should handle the sequence of abrasions efficiently. - The function should cease further calculations if the result is non-positive at any intermediate step. # Testing: 1. Use a variety of start integers and abrasion factor combinations. 2. Ensure that edge cases such as a minimal and maximal value for `n` and `abrasion_factors` length are tested. 3. Specifically, test scenarios where the abrasion leads to exactly zero or crosses into negative territory, which should stop further reductions.","solution":"def abrade_integer(n: int, abrasion_factors: list) -> int: Abrades the integer n by continuously subtracting each abrasion factor until a non-positive value is obtained or all factors are used. Parameters: n (int): The initial integer to be abraded. abrasion_factors (list): A list of integers as abrasion factors. Returns: int: The final abraded integer value. for factor in abrasion_factors: n -= factor if n <= 0: return 0 return n"},{"question":"**Problem Description**: You are tasked with implementing a function that determines the smallest positive integer `n` for which the sum of its proper divisors (i.e., all divisors excluding the number itself) is greater than `n`. Proper divisors of a number `n` are those integers `d` such that `1 <= d < n` and `n % d == 0`. **Function Signature**: ```python def smallest_int_with_abundant_divisors() -> int: Returns the smallest positive integer n for which the sum of its proper divisors is greater than n. :return: Integer, the smallest positive integer n for which the sum of its proper divisors is greater than n ``` **Input and Output**: - **Input**: The function does not take any input parameters. - **Output**: An integer representing the smallest positive integer such that the sum of its proper divisors is greater than the number itself. **Constraints**: - Focus on optimizing the evaluation of divisors for better performance. **Example**: ```python assert smallest_int_with_abundant_divisors() == 12 ``` **Requirements**: - Efficiently compute the sum of proper divisors for every integer starting from 1, and stop as soon as the smallest integer meeting the condition is found. - Consider efficient checking methods to avoid unnecessary calculations and speed up the process. **Scenario**: Suppose you are developing a screening tool for identifying numbers with special properties as part of a broader mathematical analysis software. One such property that users might want to investigate is whether certain numbers have an abundant divisor sum.","solution":"def smallest_int_with_abundant_divisors() -> int: def sum_of_proper_divisors(n): Returns the sum of proper divisors of n. if n <= 1: return 0 divisors_sum = 1 sqrt_n = int(n ** 0.5) for i in range(2, sqrt_n + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i return divisors_sum n = 1 while True: if sum_of_proper_divisors(n) > n: return n n += 1"},{"question":"# Scenario You are tasked with developing a utility for a logistics company to track the movements of trucks between different locations. Each truck\'s movement is logged as a series of recorded events with timestamps. Each truck operates independently, and the company wants to query specific trucks to find the total distance covered within a given time range. # Challenge Implement a class called `TruckTracker` that keeps track of multiple trucks and their movements. Each movement event contains truck id, a timestamp, and the distance covered in that movement. You need to provide functionality to add movement events and to compute the total distance covered by a specific truck within a specified time range. # Task 1. Implement the `add_event` method which logs the movement event for a truck. 2. Implement the `get_distance` method which computes the total distance traveled by a specific truck within a specified time range. # Requirements - Implement the methods as specified. - Store and manage events efficiently to handle multiple queries. - Handle edge cases such as no events for a truck or no events in the specified time range. - Optimize for efficient querying of distance within a time range. # Input and Output - Input: A series of add_event operations followed by get_distance operations. - Output: For each get_distance operation, return the total distance covered by the specified truck within the given time range. # Example Suppose you have the following sequence of operations: ```python tt = TruckTracker() tt.add_event(\\"truck1\\", \\"2023-10-01T10:00:00Z\\", 50) tt.add_event(\\"truck1\\", \\"2023-10-01T11:00:00Z\\", 30) tt.add_event(\\"truck1\\", \\"2023-10-01T12:00:00Z\\", 20) print(tt.get_distance(\\"truck1\\", \\"2023-10-01T09:00:00Z\\", \\"2023-10-01T11:30:00Z\\")) # Output 80 print(tt.get_distance(\\"truck1\\", \\"2023-10-01T11:30:00Z\\", \\"2023-10-01T13:00:00Z\\")) # Output 20 ``` # Constraints - Truck ids are unique strings. - Timestamps are ISO 8601 format strings. - Distances are positive integers. - The number of movement events is a positive integer. Implement the `TruckTracker` class with the required methods to track truck movements and compute distances efficiently.","solution":"from collections import defaultdict from datetime import datetime class TruckTracker: def __init__(self): self.truck_events = defaultdict(list) def add_event(self, truck_id: str, timestamp: str, distance: int): Adds a movement event for the specified truck. event = (datetime.fromisoformat(timestamp.replace(\\"Z\\", \\"+00:00\\")), distance) self.truck_events[truck_id].append(event) # Ensure events are stored sorted by timestamp for each truck self.truck_events[truck_id].sort() def get_distance(self, truck_id: str, start_time: str, end_time: str) -> int: Gets the total distance for the specified truck between the given start and end times. if truck_id not in self.truck_events: return 0 start_time_dt = datetime.fromisoformat(start_time.replace(\\"Z\\", \\"+00:00\\")) end_time_dt = datetime.fromisoformat(end_time.replace(\\"Z\\", \\"+00:00\\")) total_distance = 0 for timestamp, distance in self.truck_events[truck_id]: if start_time_dt <= timestamp <= end_time_dt: total_distance += distance return total_distance"},{"question":"# Coding Question You are tasked with implementing a task management tool that tracks tasks for different projects. Each task has a unique identifier, a title, a description, a status (either \\"incomplete\\" or \\"complete\\"), and a priority (either \\"low\\", \\"medium\\", or \\"high\\"). Projects can have multiple tasks associated with them. Objective Implement the following functionalities for robust task management: 1. **Create Project**: - Implement a function to create a new project that can hold tasks. 2. **Add Task**: - Implement a function to add a task to a specified project. The task should get a unique auto-incremented identifier within the project. 3. **Update Task**: - Implement functions to modify the title, description, status, and priority of a specified task within a project. 4. **View Tasks**: - Implement a function to retrieve and display all tasks under a specified project, optionally filtered by status and/or priority. 5. **Delete Task**: - Implement a function to delete a specified task from a project. Function Implementations - **create_project(name: str) -> dict**: - Input: A string (name of the project). - Output: Returns a new project identifier (a dictionary with empty tasks). - **add_task(project: dict, title: str, description: str, priority: str) -> None**: - Input: Project dictionary, title, description, priority of the task. - Output: Adds the task to the project with a unique identifier. - **update_task(project: dict, task_id: int, title: Optional[str] = None, description: Optional[str] = None, status: Optional[str] = None, priority: Optional[str] = None) -> None**: - Input: Project dictionary, task ID, and optionally the new title, description, status, and/or priority. - Output: Updates the specified fields for the task. - **view_tasks(project: dict, status: Optional[str] = None, priority: Optional[str] = None) -> List[dict]**: - Input: Project dictionary, optional status, and/or priority filters. - Output: Returns a list of task dictionaries filtered by the specified criteria. - **delete_task(project: dict, task_id: int) -> None**: - Input: Project dictionary and task identifier. - Output: Removes the task from the project. Example ```python >>> project = create_project(\\"Project Alpha\\") >>> add_task(project, \\"Task 1\\", \\"Description 1\\", \\"high\\") >>> add_task(project, \\"Task 2\\", \\"Description 2\\", \\"medium\\") >>> update_task(project, 1, status=\\"complete\\") >>> view_tasks(project) [{\'id\': 1, \'title\': \'Task 1\', \'description\': \'Description 1\', \'status\': \'complete\', \'priority\': \'high\'}, {\'id\': 2, \'title\': \'Task 2\', \'description\': \'Description 2\', \'status\': \'incomplete\', \'priority\': \'medium\'}] >>> delete_task(project, 2) >>> view_tasks(project) [{\'id\': 1, \'title\': \'Task 1\', \'description\': \'Description 1\', \'status\': \'complete\', \'priority\': \'high\'}] ```","solution":"def create_project(name: str) -> dict: Creates a new project with a given name. return {\\"name\\": name, \\"tasks\\": {}, \\"next_id\\": 1} def add_task(project: dict, title: str, description: str, priority: str) -> None: Adds a new task to the project. task_id = project[\\"next_id\\"] project[\\"tasks\\"][task_id] = { \\"id\\": task_id, \\"title\\": title, \\"description\\": description, \\"status\\": \\"incomplete\\", \\"priority\\": priority } project[\\"next_id\\"] += 1 def update_task(project: dict, task_id: int, title: str = None, description: str = None, status: str = None, priority: str = None) -> None: Updates a specified task\'s attributes. task = project[\\"tasks\\"].get(task_id) if task: if title is not None: task[\\"title\\"] = title if description is not None: task[\\"description\\"] = description if status is not None: task[\\"status\\"] = status if priority is not None: task[\\"priority\\"] = priority def view_tasks(project: dict, status: str = None, priority: str = None) -> list: Retrieves tasks filtered by status and/or priority. tasks = list(project[\\"tasks\\"].values()) if status is not None: tasks = [task for task in tasks if task[\\"status\\"] == status] if priority is not None: tasks = [task for task in tasks if task[\\"priority\\"] == priority] return tasks def delete_task(project: dict, task_id: int) -> None: Deletes a specified task from the project. if task_id in project[\\"tasks\\"]: del project[\\"tasks\\"][task_id]"},{"question":"Problem Statement You are tasked with developing part of a system for managing airline reservations. Specifically, you need to determine the total number of ways to book exactly `n` seats given a set of seat block sizes offered by the airline, where each seat block size can be used multiple times. Implement the function `seat_combinations(seats: List[int], target_seats: int) -> int` that takes a list of integers `seats` representing different block sizes of seats and an integer `target_seats` representing the exact number of seats to be booked. # Function Signature ```python def seat_combinations(seats: List[int], target_seats: int) -> int: ``` # Input - `seats`: A list of integers where `1 <= len(seats) <= 50` representing seat block sizes, all elements are unique and sorted in non-decreasing order. - `target_seats`: An integer where `0 <= target_seats <= 5000` representing the exact number of seats to be booked. # Output - An integer representing the number of ways to book exactly `target_seats` seats using the given seat block sizes. # Constraints - Seat block sizes and target seats are always non-negative integers. - If `target_seats` is zero, there is exactly one way to book seats, by choosing no seat blocks. # Example ```python print(seat_combinations([1, 2, 3], 4)) # Outputs: 4 print(seat_combinations([2, 5, 3, 6], 10)) # Outputs: 5 ``` # Execution Requirements - The function should operate within acceptable time limits considering O(m * n) time complexity, where `m` is the length of `seats` and `n` is `target_seats`. - Ensure to handle edge cases properly, such as when `target_seats = 0`, or certain combinations of seat blocks can\'t sum up to `target_seats`. # Scenario Consider an airline system that needs to determine various ways to fulfill booking requests using given blocks of seats. This functionality is critical in optimizing the reservation system by efficiently managing seat allocation and providing multiple options to customers. # Notes - Verify correctness of the program with various edge cases, including the minimum and maximum limits of seat blocks and target numbers. - Aim to optimize both the time and space complex required to compute the number of combinations.","solution":"from typing import List def seat_combinations(seats: List[int], target_seats: int) -> int: Determines the number of ways to book exactly \'target_seats\' seats using given seat block sizes. Parameters: seats (List[int]): A list of integers representing the seat block sizes. target_seats (int): The exact number of seats to be booked. Returns: int: The number of ways to book exactly \'target_seats\' seats using the given seat block sizes. # Create a table to store results of subproblems dp = [0] * (target_seats + 1) # There is one way to book zero seats: use zero seat blocks dp[0] = 1 # Iterate over each seat block size for seat in seats: # Update the dp table for all values from seat to target_seats for i in range(seat, target_seats + 1): dp[i] += dp[i - seat] return dp[target_seats]"},{"question":"**Question 2**: **Scenario**: Your application involves handling a large set of numeric data that require frequent basic statistical calculations. To optimize the performance and accuracy of these operations, you will add new features to your existing Statistics class. # Task 1. **Class Definition**: - Define a class named `Statistics` that will store a list of numbers. - Include an initialization method that accepts a list of numbers and stores it. 2. **Mean Calculation**: - Create a method `mean()` that returns the arithmetic mean (average) of the stored numbers. 3. **Median Calculation**: - Create a method `median()` that returns the median of the stored numbers. If the number of data points is odd, return the middle value. If it is even, return the average of the two middle values. 4. **Standard Deviation Calculation**: - Create a method `std()` that returns the sample standard deviation of the stored numbers. 5. **Data Validation**: - Modify the initialization method to raise a `ValueError` if the provided list contains non-numeric values, with an appropriate error message. # Input and Output Format - **Input**: * For the initializer: a single parameter `data` (list of numbers) * For `mean()`, `median()`, and `std()`: none - **Output**: * For `mean()`, `median()`, and `std()`: return the respective computed value (float) # Constraints - The list of numbers will always have at least one element. - All numbers in the list will be floats or integers. # Example ```python # Class Definition class Statistics: def __init__(self, data): for value in data: if not isinstance(value, (int, float)): raise ValueError(f\\"Non-numeric value found: {value}\\") self.data = data def mean(self): return sum(self.data) / len(self.data) def median(self): sorted_data = sorted(self.data) n = len(self.data) if n % 2 == 1: return sorted_data[n // 2] else: mid1, mid2 = sorted_data[n // 2 - 1], sorted_data[n // 2] return (mid1 + mid2) / 2 def std(self): mean_value = self.mean() variance = sum((x - mean_value) ** 2 for x in self.data) / (len(self.data) - 1) return variance ** 0.5 # Usage Example stats = Statistics([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) print(stats.mean()) # returns 5.5 print(stats.median()) # returns 5.5 print(stats.std()) # returns 3.0276503540974917 try: invalid_stats = Statistics([1, 2, \'a\', 4]) except ValueError as e: print(e) # Outputs: \\"Non-numeric value found: a\\" ```","solution":"class Statistics: def __init__(self, data): for value in data: if not isinstance(value, (int, float)): raise ValueError(f\\"Non-numeric value found: {value}\\") self.data = data def mean(self): return sum(self.data) / len(self.data) def median(self): sorted_data = sorted(self.data) n = len(self.data) if n % 2 == 1: return sorted_data[n // 2] else: mid1, mid2 = sorted_data[n // 2 - 1], sorted_data[n // 2] return (mid1 + mid2) / 2 def std(self): mean_value = self.mean() variance = sum((x - mean_value) ** 2 for x in self.data) / (len(self.data) - 1) return variance ** 0.5"},{"question":"# Coding Assessment Question You are assisting a research team in developing software for ecological data analysis. One functionality they require involves calculating the growth rate of a population in a habitat given the initial population size and the number of individuals added or removed over a time period. Task Write a function `calculate_population_growth(initial_population: int, change_in_population: int) -> float` that calculates the growth rate of a population, given the initial population size and the change in population over a period. The growth rate (as a percentage) can be calculated using the formula: [ text{growth_rate} = left( frac{text{change_in_population}}{text{initial_population}} right) times 100 ] Input: - `initial_population` (int): The initial population size. It is always a positive integer. - `change_in_population` (int): The change in population size. It can be a positive or negative integer representing the number of individuals added to or removed from the population. Output: - `growth_rate` (float): The population growth rate expressed as a percentage. Constraints: - The function should raise a `ValueError` if the `initial_population` is less than or equal to zero. - The function should handle both positive and negative changes in population. Examples: ```python # Example 1: Increase in population initial_population = 1000 change_in_population = 100 assert calculate_population_growth(initial_population, change_in_population) == 10.0 # Example 2: Decrease in population initial_population = 1500 change_in_population = -300 assert calculate_population_growth(initial_population, change_in_population) == -20.0 # Example 3: No change in population initial_population = 500 change_in_population = 0 assert calculate_population_growth(initial_population, change_in_population) == 0.0 ``` Provide comprehensive test cases for your function, including edge cases where the change in population is zero or significantly high or low, and typical cases reflecting realistic population changes.","solution":"def calculate_population_growth(initial_population: int, change_in_population: int) -> float: Calculates the growth rate of a population. Parameters: initial_population (int): The initial population size. change_in_population (int): The change in population size. Returns: float: The population growth rate as a percentage. Raises: ValueError: If the initial population is less than or equal to zero. if initial_population <= 0: raise ValueError(\\"Initial population must be a positive integer.\\") growth_rate = (change_in_population / initial_population) * 100 return growth_rate"},{"question":"# String Compression Challenge Context: In data storage and transmission, it\'s often necessary to reduce the size of string data. One common approach is to compress the string by using techniques such as run-length encoding (RLE). This method reduces the size of the string by replacing sequences of the same character with a single character followed by its count. Your task is to implement a run-length encoding system for strings. Tasks: 1. Implement a function `compress_string(s: str) -> str` that takes a string and returns its run-length encoded (RLE) version. 2. Implement a function `decompress_string(s: str) -> str` that takes an RLE compressed string and returns its original uncompressed version. Input: - Both functions will receive a single string `s`. Output: - For `compress_string`, a run-length encoded string where each sequence of the same character is replaced by that character followed by the count of its occurrences. - For `decompress_string`, the original string extracted from the run-length encoded format. Constraints: - The input string `s` will only contain alphanumeric characters. - The compressed string format will always be valid, containing character-digit pairs generated by the `compress_string` function. Example: ```python def compress_string(s: str) -> str: # Implement the run-length encoding here def decompress_string(s: str) -> str: # Implement the run-length decoding here # Example Usage: print(compress_string(\\"aaabbbcccaaa\\")) # Output: \'a3b3c3a3\' print(decompress_string(\\"a3b3c3a3\\")) # Output: \'aaabbbcccaaa\' ``` Your task is to provide an implementation for the functions `compress_string` and `decompress_string`, which should perform the described string compression and decompression.","solution":"def compress_string(s: str) -> str: Compresses the input string using run-length encoding. if not s: return \'\' compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") # Append the last character group return \'\'.join(compressed) def decompress_string(s: str) -> str: Decompresses the run-length encoded string. if not s: return \'\' decompressed = [] i = 0 while i < len(s): char = s[i] count = \\"\\" i += 1 while i < len(s) and s[i].isdigit(): count += s[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed)"},{"question":"# Reverse Each Word in a String Problem Statement You are given a string that consists of multiple words separated by spaces. Your task is to write a function that reverses each word in the string individually while maintaining the original order of words. Write a function `reverse_each_word(statement: str) -> str` that takes a single string as input and returns a new string where each word is reversed, but the order of words is preserved. Input Format * A single non-null string `statement`. Output Format * A single string where each word in the input string is reversed. Example Input: ```python statement = \\"Hello World\\" ``` Output: ```python \\"olleH dlroW\\" ``` Additional Example Scenarios Input: ```python statement = \\"Python is Fun\\" ``` Output: ```python \\"nohtyP si nuF\\" ``` Constraints * Ensure the function can handle scenario inputs where the string might contain only one word. * Input string may contain leading or trailing spaces which should be retained in the output. * Words consist only of alphabetic characters and spaces. Requirements * Implement the function `reverse_each_word` with the following signature: ```python def reverse_each_word(statement: str) -> str: ``` Performance * The implementation should run with a time complexity of O(n), where n is the length of the input string.","solution":"def reverse_each_word(statement: str) -> str: Returns a string where each word in the input string is reversed, but the order of words is preserved. words = statement.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# **File System Simulation in Python** Scenario: You are tasked with designing a simple in-memory file system simulation. This system should allow users to create directories, add files with content, retrieve the content of files, and list the contents of directories. Task: Implement a class `FileSystem` that supports the following methods for interaction: 1. **mkdir(path: str) -> None** - **Input**: A string `path` representing the path of the directory to be created. - **Output**: None. Creates a directory at the specified path. 2. **addFile(path: str, content: str) -> None** - **Input**: A string `path` representing the path of the file to be added, and a string `content` representing the content to be stored in the file. - **Output**: None. Adds a file at the specified path with the given content. 3. **getFile(path: str) -> str** - **Input**: A string `path` representing the path of the file. - **Output**: A string representing the content of the file at the specified path. 4. **ls(path: str) -> list[str]** - **Input**: A string `path` representing the path of the directory or file. - **Output**: A list of strings with the names of the directory\'s contents sorted alphabetically. If the `path` refers to a file, returns a list containing only the filename. Constraints: - The `path` should be specified using Unix-style paths (e.g., \\"/a/b/c\\"). - You must handle both absolute (starting with \\"/\\") and relative paths. - If a directory or file already exists at the given path, the methods should overwrite the existing content without throwing an error. - The `getFile` method should throw an error if the file does not exist. - The `ls` method should throw an error if the directory does not exist. Example Usage: ```python fs = FileSystem() # Creating directories fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/a/d\\") # Adding files fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") fs.addFile(\\"/a/d/anotherfile.txt\\", \\"Python Programming\\") # Getting file contents assert fs.getFile(\\"/a/b/c/file.txt\\") == \\"Hello, World!\\" assert fs.getFile(\\"/a/d/anotherfile.txt\\") == \\"Python Programming\\" # Listing directory contents assert fs.ls(\\"/a/b\\") == [\\"c\\"] assert fs.ls(\\"/a\\") == [\\"b\\", \\"d\\"] assert fs.ls(\\"/a/b/c/file.txt\\") == [\\"file.txt\\"] ``` Your task is to implement this in-memory file system and ensure all methods adhere to the specified functionality.","solution":"class FileSystem: def __init__(self): self.root = dict() def mkdir(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts: if part not in current: current[part] = dict() current = current[part] def addFile(self, path: str, content: str) -> None: parts = path.strip(\'/\').split(\'/\') *dirs, file_name = parts current = self.root for part in dirs: if part not in current: current[part] = dict() current = current[part] current[file_name] = content def getFile(self, path: str) -> str: parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts: current = current[part] return current def ls(self, path: str) -> list: parts = path.strip(\'/\').split(\'/\') current = self.root for part in parts: if part in current: current = current[part] else: raise ValueError(\\"Path does not exist\\") if isinstance(current, dict): return sorted(list(current.keys())) else: return [parts[-1]]"},{"question":"# Question: Minimum Sum of Absolute Differences Context: You are given an array of integers. Your task is to find a new array such that the sum of absolute differences between corresponding elements of the two arrays is minimized. The new array should be formed by replacing each element in the original array with any integer from the given array. Specification: * Function Name: `minimize_absolute_difference` * Input: - An array `arr` of integers (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) * Output: - An integer representing the minimum possible sum of absolute differences. Example: ```python def minimize_absolute_difference(arr: list) -> int: pass # Examples # Example 1: # arr = [1, 3, 2] # We can replace each number with its median, which is 2, thus forming the new array [2, 2, 2]. # The sum of absolute differences is |1-2| + |3-2| + |2-2| = 1 + 1 + 0 = 2. print(minimize_absolute_difference([1, 3, 2])) # should return 2 # Example 2: # arr = [10, 20, 30] # We can replace each number with its median, which is 20, thus forming the new array [20, 20, 20]. # The sum of absolute differences is |10-20| + |20-20| + |30-20| = 10 + 0 + 10 = 20. print(minimize_absolute_difference([10, 20, 30])) # should return 20 ``` Constraints: * The optimal solution involves using a mathematical property of medians. * Optimize for time complexity to handle the upper size constraints efficiently.","solution":"def minimize_absolute_difference(arr: list) -> int: This function returns the minimum possible sum of absolute differences between the given array and a new array where each element is replaced with the median of the original array. arr.sort() median = arr[len(arr)//2] # Median of the sorted array # Calculate the sum of absolute differences min_sum = sum(abs(x - median) for x in arr) return min_sum"},{"question":"# Find Missing Element in Array You are tasked with implementing a function that finds the missing element from an array of unique integers ranging from 1 to `n`, where only one number is missing. Function Signature ```python def find_missing_element(arr: List[int]) -> int: pass ``` Input and Output * **Input** * `arr` (List[int]): A list of unique integers from 1 to `n` with one number missing. (1 <= len(arr) <= 10^5) * **Output** * (int): Returns the missing integer from the array. Constraints * The function should raise a `ValueError` if the elements in `arr` are not unique or not within the correct range. * The function should raise a `TypeError` if `arr` is not a list of integers. Example ```python >>> find_missing_element([1, 2, 4, 5, 6]) 3 >>> find_missing_element([1, 3, 4, 5, 6]) 2 >>> find_missing_element([2]) 1 >>> find_missing_element([1]) 2 >>> find_missing_element([3, 4, 1, 2]) 5 ``` Notes * The function should handle large arrays efficiently by leveraging appropriate algorithmic techniques. * Consider edge cases such as very small arrays or arrays with elements positioned unsorted in different locations.","solution":"from typing import List def find_missing_element(arr: List[int]) -> int: n = len(arr) + 1 if not isinstance(arr, list): raise TypeError(\'Input must be a list.\') if not all(isinstance(i, int) for i in arr): raise TypeError(\'All elements in the list must be integers.\') if not all(1 <= i <= n for i in arr): raise ValueError(\'Elements must be within the range from 1 to n.\') if len(arr) != len(set(arr)): raise ValueError(\'All elements in the list must be unique.\') total_sum = n * (n + 1) // 2 actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"# Problem Statement Design an \'Order Log\' system to efficiently handle real-time e-commerce order tracking. The system should support the following commands: 1. `add_order(order_id: int)`: Adds a new order with a unique order_id. 2. `remove_order(order_id: int)`: Removes an existing order by its order_id. 3. `get_last_n_orders(n: int) -> List[int]`: Returns a list of IDs of the last `n` added orders. If there are fewer than `n` orders in the system, return all of them, ordered from the most recently added to the oldest. # Input * The input will primarily be function calls to simulate the commands: - `add_order(order_id: int)`: The `order_id` is guaranteed to be a unique integer. - `remove_order(order_id: int)`: The `order_id` is guaranteed to be present in the system when this command is issued. - `get_last_n_orders(n: int) -> List[int]`: The value `n` will be a non-negative integer. # Output * The output of `get_last_n_orders(n: int)` should be: - A list of integers representing the `order_id`s of the last `n` orders, in the order they were added, with the most recent first. # Example ```python order_log = OrderLog() order_log.add_order(1) order_log.add_order(2) order_log.add_order(3) assert order_log.get_last_n_orders(1) == [3] assert order_log.get_last_n_orders(2) == [3, 2] order_log.remove_order(2) assert order_log.get_last_n_orders(5) == [3, 1] order_log.add_order(4) order_log.add_order(5) assert order_log.get_last_n_orders(3) == [5, 4, 3] assert order_log.get_last_n_orders(10) == [5, 4, 3, 1] ``` # Implementation ```python from typing import List class OrderLog: def __init__(self): self.orders = [] self.order_set = set() def add_order(self, order_id: int): self.orders.append(order_id) self.order_set.add(order_id) def remove_order(self, order_id: int): if order_id in self.order_set: self.orders.remove(order_id) self.order_set.remove(order_id) def get_last_n_orders(self, n: int) -> List[int]: return self.orders[-n:][::-1] ``` # Explanation - The `OrderLog` class maintains an internal list (`self.orders`) to keep track of the order of additions. - The `add_order` method appends an order_id to this list and adds it to a set to ensure uniqueness. - The `remove_order` method removes the order_id from both the list and the set. - The `get_last_n_orders` method slices the list to get the last `n` orders and reverses the slice to return the most recent orders first.","solution":"from typing import List class OrderLog: def __init__(self): self.orders = [] self.order_set = set() def add_order(self, order_id: int): self.orders.append(order_id) self.order_set.add(order_id) def remove_order(self, order_id: int): if order_id in self.order_set: self.orders.remove(order_id) self.order_set.remove(order_id) def get_last_n_orders(self, n: int) -> List[int]: return self.orders[-n:][::-1]"},{"question":"# Problem: Implement an LRU (Least Recently Used) Cache You are required to implement an LRU (Least Recently Used) Cache. An LRU cache is a type of cache that evicts the least recently used item when it reaches its capacity. Requirements: 1. **Initialization**: - Initialize the LRU cache with a fixed capacity. 2. **Insertions**: - Support insertion of key-value pairs. If the cache exceeds its capacity, the least recently used item should be evicted. 3. **Access**: - Support accessing key-value pairs. Accessing an element makes it the most recently used. 4. **Deletions**: - Support deletion of key-value pairs. If the key is not found, raise a KeyError. 5. **Cache State**: - Provide methods to retrieve the current state of the cache as a list of key-value pairs in the order from the most recently used to the least recently used. Input: - A set of operations (insertions, accesses, and deletions) along with their keys and values. Output: - After each operation, return the state of the cache as a list of key-value pairs, or \\"Cache is empty\\" if there are no elements. Constraints: 1. The cache will have a maximum fixed capacity. 2. The operations will fit within the available capacity. Performance Requirements: - Insertions and deletions should be handled in O(1) time. - Access should be handled in O(1) time. - Cache state retrieval should be O(n) where n is the cache capacity. Example Scenario ```python # Initialize an LRU cache with capacity 2 cache = LRUCache(2) # Insert elements into the cache cache.put(1, \'A\') print(cache) # Expected Output: [(1, \'A\')] cache.put(2, \'B\') print(cache) # Expected Output: [(2, \'B\'), (1, \'A\')] # Access the element with key 1 (which makes it the most recently used) cache.get(1) print(cache) # Expected Output: [(1, \'A\'), (2, \'B\')] # Insert element with key 3, which causes evicting the least recently used element (2, \'B\') cache.put(3, \'C\') print(cache) # Expected Output: [(3, \'C\'), (1, \'A\')] cache.delete(1) print(cache) # Expected Output: [(3, \'C\')] cache.delete(3) print(cache) # Expected Output: \\"Cache is empty\\" try: cache.delete(2) except KeyError: print(\\"Key not found\\") # Expected Output: \\"Key not found\\" ``` **Note**: You can use a combination of a dictionary and a doubly linked list to manage the LRU cache. The dictionary allows O(1) access time to elements, while the doubly linked list manages the order of elements efficiently.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _add(self, node): prev = self.head nxt = self.head.next prev.next = node node.prev = prev node.next = nxt nxt.prev = node def get(self, key): if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value else: raise KeyError(\\"Key not found\\") def put(self, key, value): if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: node_to_remove = self.tail.prev self._remove(node_to_remove) del self.cache[node_to_remove.key] def delete(self, key): if key in self.cache: self._remove(self.cache[key]) del self.cache[key] else: raise KeyError(\\"Key not found\\") def state(self): elements = [] current = self.head.next while current != self.tail: elements.append((current.key, current.value)) current = current.next return elements if elements else \\"Cache is empty\\""},{"question":"Unique Character Finder # Objective You are tasked with implementing an efficient algorithm to determine the first non-repeating character in a given string of lowercase alphabets. # Problem Statement Write a function `first_unique_char(input_string: str) -> str` to find the first character in the string that does not repeat. If every character repeats or the string is empty, return an empty string. # Implementation Details 1. **Input**: A single string consisting of lowercase alphabets. 2. **Output**: A single character which is the first unique character in the input string. Return an empty string if no such character exists. # Function Signature ```python def first_unique_char(input_string: str) -> str: pass ``` # Constraints 1. 1 ≤ |input_string| ≤ 10^5 2. The input string contains only lowercase English letters. # Example ```python example1 = \'leetcode\' example2 = \'loveleetcode\' example3 = \'aabbcc\' assert first_unique_char(example1) == \'l\' assert first_unique_char(example2) == \'v\' assert first_unique_char(example3) == \'\' ``` # Description The function `first_unique_char` should perform the following steps: 1. Traverse the string to count the frequency of each character using a dictionary. 2. Traverse the string a second time to find the first character with a frequency of 1. # Notes - Ensure your implementation handles strings of maximum length efficiently. - Consider edge cases like strings where all characters repeat or strings that are empty.","solution":"def first_unique_char(input_string: str) -> str: Finds and returns the first non-repeating character in the input string. If all characters are repeating or the string is empty, returns an empty string. # Dictionary to keep track of character frequency char_count = {} # First pass: count the frequency of each character for char in input_string: char_count[char] = char_count.get(char, 0) + 1 # Second pass: find the first character with a frequency of 1 for char in input_string: if char_count[char] == 1: return char return \\"\\""},{"question":"# Binary Search Tree In-Order Traversal & Kth Smallest Element Context You are working on a feature for a software application that needs to retrieve specific elements from a binary search tree (BST) based on their order. This feature specifically requires finding the k-th smallest element in the tree. Task Write a function named `kth_smallest_element` that performs an in-order traversal of a binary search tree (BST) and returns the k-th smallest element. Function Signature ```python def kth_smallest_element(root: TreeNode, k: int) -> int: pass ``` Input * `root` (TreeNode): The root node of the binary search tree. * `k` (int): An integer representing the order of the smallest element to retrieve (1-based index). Output * (int): The k-th smallest element in the binary search tree. Constraints * The BST can have up to (10^4) nodes. * Values of the nodes are unique integers in the range `[-10^9, 10^9]`. * (1 leq k leq n), where (n) is the total number of nodes in the BST. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def test_kth_smallest_element(): # Constructing the BST root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.left.left.left = TreeNode(1) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.right.left.left = TreeNode(6) # Testing assert kth_smallest_element(root, 1) == 1 assert kth_smallest_element(root, 3) == 3 assert kth_smallest_element(root, 5) == 5 assert kth_smallest_element(root, 7) == 7 assert kth_smallest_element(root, 9) == 9 print(\\"All tests passed!\\") test_kth_smallest_element() ``` You should also consider writing additional test cases to cover scenarios such as a tree with a single node, a completely unbalanced tree, and values of `k` close to the bounds of the node count.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_element(root: TreeNode, k: int) -> int: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k - 1]"},{"question":"# Background In data processing and analysis, it is common to transform datasets according to specific conditions. One useful transformation is the conditional exchange of values within a list based on the relative magnitude of adjacent elements. This technique can be applied for various purposes, such as preparing data for machine learning, data normalization, or custom sorting mechanisms. # Task Implement a function that takes a list of integers and swaps adjacent elements if the first element is greater than the second. The function should continue this process until no more swaps are needed, resulting in a list where every adjacent element pair `(a_i, a_{i+1})` satisfies `a_i <= a_{i+1}`. # Function Signature ```python def conditional_swap_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr` (list): A list of integers to be sorted. # Output - `arr` (list): The list after performing the conditional swaps until no further swaps are needed. # Example ```python assert conditional_swap_sort([3, 2, 1, 4]) == [1, 2, 3, 4] assert conditional_swap_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert conditional_swap_sort([8, 5, 3, 1]) == [1, 3, 5, 8] assert conditional_swap_sort([1, 2, 3, 4]) == [1, 2, 3, 4] ``` # Constraints - The input list will contain only integers. - The input list length will be <= 1000 elements. - Each integer in the list will be in the range from `-10^6` to `10^6`. # Notes - You may assume that the list may contain duplicate values.","solution":"def conditional_swap_sort(arr: list[int]) -> list[int]: Function to sort a list of integers by swapping adjacent elements if the first element is greater than the second until no more swaps are needed. n = len(arr) if n <= 1: # an empty list or a single-element list is already sorted return arr # Keep iterating through the list until no swaps are needed swapped = True while swapped: swapped = False for i in range(n - 1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] # Swap swapped = True # A swap occurred, so we need to check again return arr"},{"question":"# Problem: Circular Array Rotation You have an array of integers and need to perform a series of rotations on it. Specifically, each rotation shifts every element of the array to the right by one position, and the last element of the array moves to the front. After a given number of rotations, you need to output the state of the array. Requirements: 1. **Implement a method `rotate_array(arr: List[int], k: int) -> List[int]`**: - This method should return the array after performing `k` rotations. - If `k` is 0 or if the array is empty, return the array as is. - Optimize to handle larger values of `k` by using the modulo of the array length with `k`. 2. **Implement a method `query_array(arr: List[int], queries: List[int]) -> List[int]`**: - This method should return the elements of the array at the positions specified in the `queries` list. - The positions in `queries` are zero-based indices. - Assume all query indices are valid. Function Signatures: ```python from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: # Code for rotate_array def query_array(arr: List[int], queries: List[int]) -> List[int]: # Code for query_array ``` Input/Output Formats: - `rotate_array(arr: List[int], k: int) -> List[int]` - Input: Array of integers (`List[int]`), Number of rotations (`k`) - Output: Rotated array (`List[int]`) - `query_array(arr: List[int], queries: List[int]) -> List[int]` - Input: Array of integers (`List[int]`), Array of query positions (`List[int]`) - Output: List of elements at queried positions (`List[int]`) Example: ```python arr = [1, 2, 3, 4, 5] k = 2 queries = [0, 2, 4] rotated_array = rotate_array(arr, k) # Rotated array should be [4, 5, 1, 2, 3] queried_elements = query_array(rotated_array, queries) # Queried elements should be [4, 1, 3] ``` Constraints: - The length of `arr` will be between 1 and 10^5. - The value of `k` will be between 0 and 10^5. - The length of `queries` will be between 1 and 10^5. - Each element in `queries` will be a valid index within the array.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: if not arr or k == 0: return arr n = len(arr) k = k % n # handle larger values of k return arr[-k:] + arr[:-k] def query_array(arr: List[int], queries: List[int]) -> List[int]: return [arr[i] for i in queries]"},{"question":"# Question: Write a function that simulates a simple parking management system. The parking lot has a fixed number of spots, and cars can enter or leave the lot based on given commands. Your task is to keep track of the number of occupied parking spots and the total time cars have occupied spots. Function Signature ```python def manage_parking_lot(commands: list) -> dict: pass ``` Input - `commands` (list): A list of commands where each command is a tuple. The first element of the tuple is a string (`\\"enter\\"` or `\\"leave\\"`), and the second element is an integer representing either the car\'s ID or the time in minutes. Output - `dict`: A dictionary with keys `\'occupied_spots\'` and `\'total_occupied_time\'`, representing the current number of occupied spots and the total time in minutes that all spots have been occupied cumulatively. Constraints - The parking lot has 10 spots. - Car IDs are unique positive integers. - Time starts at 0, and commands will be received in chronological order. - Each car will leave the spot only once after entering. - The moments when a car enters and leaves will be strictly increasing with respect to time. Example Input: ```python commands = [ (\\"enter\\", 1, 5), (\\"enter\\", 2, 10), (\\"leave\\", 1, 20), (\\"leave\\", 2, 25), ] ``` Output: ```python {\'occupied_spots\': 0, \'total_occupied_time\': 30} ``` Input: ```python commands = [ (\\"enter\\", 3, 2), (\\"enter\\", 4, 4), (\\"leave\\", 3, 10), (\\"enter\\", 5, 15), (\\"leave\\", 4, 20), (\\"leave\\", 5, 25) ] ``` Output: ```python {\'occupied_spots\': 0, \'total_occupied_time\': 34} ``` Notes - Ensure your solution efficiently handles the addition and removal of cars. - If a car tries to enter when the lot is full or leave when it wasn\'t in the lot, no changes should be made, but these cases must be gracefully handled by your function.","solution":"def manage_parking_lot(commands: list) -> dict: parked_cars = {} total_occupied_time = 0 occupied_spots = 0 max_spots = 10 for command in commands: action, car_id, time = command if action == \\"enter\\": if occupied_spots < max_spots and car_id not in parked_cars: parked_cars[car_id] = time occupied_spots += 1 elif action == \\"leave\\": if car_id in parked_cars: total_occupied_time += time - parked_cars[car_id] del parked_cars[car_id] occupied_spots -= 1 return { \'occupied_spots\': occupied_spots, \'total_occupied_time\': total_occupied_time }"},{"question":"# Coding Assessment Task: GitHub Repository Issue Fetcher Context You are a developer working on a project management tool that integrates with GitHub. Your task is to create a function that fetches the issues from a specified GitHub repository and returns the most recent 5 issues. Task Write a Python function `fetch_recent_issues(repo: str) -> List[Dict[str, Union[str, int]]]` that: 1. Takes a repository string in the format \\"owner/repo\\" as input. 2. Fetches the issues from the specified GitHub repository using the GitHub API. 3. Parses the response to extract the most recent 5 issues. 4. Returns a list of dictionaries, each containing the issue\'s title and number. Input Format - `repo` (str): A string representing the GitHub repository in the format \\"owner/repo\\". Output Format - A list of dictionaries, where each dictionary contains: - `title` (str): The title of the issue. - `number` (int): The number of the issue. Constraints - Only extract the titles and numbers of the most recent 5 issues. - Assume a stable internet connection and that the GitHub API is accessible. - Proper authentication if required by GitHub API. - Ensure the script handles unexpected API response structures gracefully. Example ```python >>> fetch_recent_issues(\\"octocat/Hello-World\\") [ {\\"title\\": \\"Issue 1\\", \\"number\\": 1}, {\\"title\\": \\"Issue 2\\", \\"number\\": 2}, {\\"title\\": \\"Issue 3\\", \\"number\\": 3}, {\\"title\\": \\"Issue 4\\", \\"number\\": 4}, {\\"title\\": \\"Issue 5\\", \\"number\\": 5} ] ``` Performance Requirements - The function should make the API request and fetch the data within a reasonable amount of time, even for multiple usage scenarios. Notes - Use the Requests library for making HTTP requests. - Proper error handling (such as timeouts, response status checks, API rate limits) should be implemented. - Example: `requests.get(\\"https://api.github.com/repos/owner/repo/issues\\")`","solution":"import requests from typing import List, Dict, Union def fetch_recent_issues(repo: str) -> List[Dict[str, Union[str, int]]]: Fetches the most recent 5 issues from the given GitHub repository. Args: repo (str): The GitHub repository in the format \\"owner/repo\\". Returns: List[Dict[str, Union[str, int]]]: A list of dictionaries containing issue titles and numbers. url = f\\"https://api.github.com/repos/{repo}/issues\\" headers = {\\"Accept\\": \\"application/vnd.github.v3+json\\"} try: response = requests.get(url, headers=headers) response.raise_for_status() # Raise an error for bad status codes issues = response.json() recent_issues = [ {\\"title\\": issue[\\"title\\"], \\"number\\": issue[\\"number\\"]} for issue in issues if \\"pull_request\\" not in issue # Ignore pull requests ][:5] return recent_issues except requests.exceptions.RequestException as e: print(f\\"Error fetching issues: {e}\\") return []"},{"question":"# Coding Assessment Question **Context**: You are required to analyze and process a sequence of operations in a data structure known as a \\"Min-Heap.\\" A Min-Heap is a complete binary tree where the value of each node is less than or equal to the values of its children. The element with the smallest value is located at the root. **Objective**: Implement a class `MinHeap` that simulates the behavior of a Min-Heap. The class should support the following operations: - `push(val: int)`: Adds a value to the heap. - `pop() -> int`: Removes and returns the smallest value from the heap. - `peek() -> int`: Returns the smallest value without removing it from the heap. **Class Signature**: ```python class MinHeap: def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> int: pass def peek(self) -> int: pass ``` **Constraints**: - `push` will be called with integer values only. - `pop` and `peek` will not be called on an empty heap. - The number of operations will not exceed 10^5. - The values of integers will be in the range [-10^9, 10^9]. **Example**: ```python heap = MinHeap() heap.push(3) heap.push(1) heap.push(6) heap.push(5) heap.push(2) heap.push(4) >>> heap.peek() 1 >>> heap.pop() 1 >>> heap.pop() 2 >>> heap.pop() 3 >>> heap.peek() 4 ``` **Performance Requirements**: - Ensure that the operations are efficient with respect to both time and space, approximating or achieving O(log n) time complexity for `push` and `pop` operations. **Additional Notes**: - Consider implementing the heap using a list to store the elements and helper functions to manage the heap property. - Make sure to handle the heap property restoration after each operation.","solution":"import heapq class MinHeap: def __init__(self): # The heap is initialized as an empty list. self.heap = [] def push(self, val: int) -> None: # Push the value onto the heap, maintaining the heap invariant. heapq.heappush(self.heap, val) def pop(self) -> int: # Pop and return the smallest item from the heap, maintaining the heap invariant. return heapq.heappop(self.heap) def peek(self) -> int: # Return the smallest item on the heap without popping it. return self.heap[0]"},{"question":"# Problem Statement: You are required to write a function that takes a list of integers and returns the list sorted in alternating order such that the first element is the largest, the second element is the smallest, the third element is the second largest, the fourth element is the second smallest, and so on. # Function Signature: ```python def alternating_sort(arr: list[int]) -> list[int]: Sort the list in an alternating large-small order. Args: arr (list): A list of integers to be sorted. Returns: list[int]: A list of integers sorted in the specified alternating order. ``` # Input: - `arr` - A list containing integers. The list may contain duplicate values. # Output: - A list of integers sorted in alternating order. # Constraints: - The length of the list (`len(arr)`) is between 1 and 1000, inclusive. # Requirements: 1. Implement the function `alternating_sort` to return the list sorted in the specified alternating order. 2. Handle edge cases where the list is empty or contains a single element efficiently. 3. Ensure that the function is optimized for performance given the constraints. # Sample Test Cases: ```python assert alternating_sort([1, 3, 2, 2, 5]) == [5, 1, 3, 2, 2] assert alternating_sort([10, 20, 30, 40, 50]) == [50, 10, 40, 20, 30] assert alternating_sort([3, 8, 1, 2, 9, 7]) == [9, 1, 8, 2, 7, 3] assert alternating_sort([7, 7, 7, 7, 7]) == [7, 7, 7, 7, 7] assert alternating_sort([5]) == [5] assert alternating_sort([]) == [] ```","solution":"def alternating_sort(arr: list[int]) -> list[int]: Sort the list in an alternating large-small order. Args: arr (list): A list of integers to be sorted. Returns: list[int]: A list of integers sorted in the specified alternating order. arr.sort() result = [] left = 0 right = len(arr) - 1 while left <= right: if right >= left: result.append(arr[right]) right -= 1 if right >= left: result.append(arr[left]) left += 1 return result"},{"question":"# Problem Statement Develop a function that evaluates the validity of a given mathematical expression string. The expression may include integers, the operators (+, -, *, /), and parentheses. The evaluation should ensure proper syntax and balanced parentheses. # Requirements Function Signature ```python def validate_expression(expr: str) -> bool: ``` Functionality Description - The function should accept one parameter: * `expr` (str): The string representing the mathematical expression. - The function should return: * `True` if the expression is syntactically valid and the parentheses are balanced. * `False` otherwise. # Constraints 1. The `expr` must be a non-empty string composed of digits, operators (+, -, *, /), parentheses, and whitespace. 2. The expression may contain valid nested parentheses. # Error Handling 1. Raise a `ValueError` if `expr` is not a string. # Performance Requirements - Implement the function such that it operates with linear time complexity, O(n), where n is the length of `expr`. - Ensure the function uses O(n) additional space. # Example Usage ```python >>> validate_expression(\\"3 + (2 - 5) * 4 / (3 + 1)\\") True >>> validate_expression(\\"3 + (2 - 5)) * 4 / (3 + 1\\") False >>> validate_expression(\\"3 + (2 - 5) * 4 / (3 + 1\\") False >>> validate_expression(\\"3 + 5 * (7 / 2))\\") False >>> validate_expression(\\"3 + -5\\") False >>> validate_expression(\\"3 + 5 * (2 - 4)\\") True ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> validate_expression(5 + (3 * 2)) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> >>> validate_expression(3.5 + 2.5) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'float\'> ``` # Notes - A valid expression cannot start with an operator or contain consecutive operators. - Ensure all content within the expression follows basic arithmetic syntax rules (e.g., `3 + * 5` is invalid). - Consider whitespace-insensiative evaluation (allowing for spaces). Ensure you cover all provided example scenarios and handle other edge cases as described.","solution":"def validate_expression(expr: str) -> bool: Validates the given mathematical expression string for correct syntax and balanced parentheses. if not isinstance(expr, str): raise ValueError(f\\"Expected string as input, found {type(expr)}\\") stack = [] last_char = \'\' valid_chars = set(\'0123456789+-*/() \') for char in expr: if char not in valid_chars: return False if char == \' \': continue if char in \'0123456789\': if last_char and last_char.isdigit() and not last_char.isspace(): continue if char in \'+-*/\': if not last_char or last_char in \'+-*/(\': return False if char == \'(\': stack.append(char) if char == \')\': if not stack: return False stack.pop() last_char = char if stack: return False if expr.strip()[-1] in \'+-*/\': return False return not expr.lstrip(\' \').startswith((\'+\', \'-\', \'*\', \'/\'))"},{"question":"# Question: Binary Tree Maximum Depth You are provided with a binary tree data structure. Your task is to calculate the maximum depth of the binary tree using a depth-first search technique. # Function Signature ```python def max_depth(root: Node) -> int: Calculate the maximum depth of a binary tree rooted at `root`. Args: root (Node): The root node of the binary tree. Returns: int: The maximum depth of the tree. ``` # Input - `root`: A `Node` object representing the root of the binary tree. The Node class is defined as: ```python class Node: def __init__(self, value: int) -> None: self.value = value self.left: Node | None = None self.right: Node | None = None ``` # Output - An integer representing the maximum depth of the given binary tree. # Constraints - The number of nodes in the tree will be in the range `[0, 10^4]`. - The value of each node will be an integer in the range `[-1000, 1000]`. # Example ```python # Define the tree root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) root.left.left.left = Node(7) # Calculate the maximum depth result = max_depth(root) # Output should be 4 ``` # Edge Cases to Consider - Tree with only one node (root). - Empty tree (should return 0). - Tree with only left or right subtrees having multiple levels. - Tree with complete binary structure.","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def max_depth(root: Node) -> int: Calculate the maximum depth of a binary tree rooted at `root`. Args: root (Node): The root node of the binary tree. Returns: int: The maximum depth of the tree. if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Coding Assessment Question Problem Statement You are required to write a function that finds and removes duplicate characters from a given string while preserving the order of the remaining characters. The function should be case-sensitive, meaning \'a\' and \'A\' are considered different characters. Function Signature ```python def remove_duplicates(input_str: str) -> str: pass ``` Input - A single string `input_str` containing only printable ASCII characters. The string may contain spaces, punctuation marks, and a mix of uppercase and lowercase letters. Output - A string with duplicates removed, preserving the order of first occurrences of each character. Constraints - The input string length will not exceed 1000 characters. Example Usage ```python assert remove_duplicates(\\"aabbcc\\") == \\"abc\\" assert remove_duplicates(\\"Hello, World!\\") == \\"Helo, Wrd!\\" assert remove_duplicates(\\"abcdefg\\") == \\"abcdefg\\" assert remove_duplicates(\\"1122334455\\") == \\"12345\\" assert remove_duplicates(\\"AaBbCc\\") == \\"AaBbCc\\" ``` Performance Requirements The function should aim for a linear time complexity of O(n) and a space complexity of O(n), where n is the length of the input string.","solution":"def remove_duplicates(input_str: str) -> str: Remove duplicate characters from the input string while preserving the order of their first occurrence. Args: input_str (str): The input string from which duplicates are to be removed. Returns: str: A string with duplicates removed. seen_chars = set() result = [] for char in input_str: if char not in seen_chars: seen_chars.add(char) result.append(char) return \'\'.join(result)"},{"question":"Optimizing Pathfinding in a Weighted Grid Context You are tasked with developing a function to find the shortest path in a weighted grid. Each cell in the grid has an associated cost, and you can only move right or down. The goal is to identify the path from the top-left corner to the bottom-right corner that minimizes the total cost, and to ensure that your implementation efficiently handles grids of varying sizes. Objective * Implement the `find_min_cost_path` function that calculates the minimum cost path in a given grid. * Optimize the function to handle large grids efficiently. Function Signature ```python def find_min_cost_path(grid: List[List[int]]) -> int: Calculate the minimum cost path from the top-left to bottom-right of a grid. Parameters: grid (List[List[int]]): A 2D list where each element represents the cost of the cell. Returns: int: The minimum cost to traverse from the top-left to the bottom-right of the grid. Example: >>> find_min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 (1 -> 3 -> 1 -> 1 -> 1) >>> find_min_cost_path([[1, 2, 5], [3, 2, 1]]) 6 (1 -> 2 -> 2 -> 1) ``` Constraints and Requirements * **Input Constraints**: - The grid is a 2D list of integers, where each integer represents the cost associated with that cell. - The dimensions of the grid will be at least 1x1. * **Output**: - The function should return an integer representing the total minimum cost of the path. * **Edge Handling**: - Ensure that the function can handle grids with varying sizes and values efficiently. - Avoid invalid accesses and handle edge cases, such as a grid of size 1x1 properly. * **Performance**: The solution should have a complexity of O(n*m), where n and m are the dimensions of the grid. ```python # Example Solution Outline def find_min_cost_path(grid: List[List[int]]) -> int: n = len(grid) m = len(grid[0]) # Initialize dp table with grid values dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the result return dp[n - 1][m - 1] # Sample Usage and Test Cases print(find_min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) # Output: 7 print(find_min_cost_path([[1, 2, 5], [3, 2, 1]])) # Output: 6 # Additional tests assert find_min_cost_path([[0, 0], [0, 0]]) == 0 assert find_min_cost_path([[1]]) == 1 assert find_min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 assert find_min_cost_path([[1, 99], [1, 1]]) == 3 assert find_min_cost_path([[1, 1, 1], [1, 50, 1], [1, 1, 1]]) == 5 ```","solution":"from typing import List def find_min_cost_path(grid: List[List[int]]) -> int: Calculate the minimum cost path from the top-left to bottom-right of a grid. Parameters: grid (List[List[int]]): A 2D list where each element represents the cost of the cell. Returns: int: The minimum cost to traverse from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize dp table with grid values dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the result return dp[n - 1][m - 1]"},{"question":"# Data Cleaning and Analysis Assessment You are required to implement a Python function to clean and analyze sales data from a given CSV file. The objective is to assess your understanding of data cleaning, processing techniques, and basic data analysis in Python. Context: You need to read sales data from a CSV file, clean the data to handle missing values and outliers, and perform a basic analysis to extract insights. The CSV file contains sales records with columns for date, product, sales_amount, and region. Task: 1. Write a function `clean_sales_data(filepath: str) -> pd.DataFrame` which reads sales data from a CSV file, handles missing values by filling them with the median of the respective column, and removes outliers (defined as values outside 1.5 times the interquartile range) in the `sales_amount` column. Return the cleaned DataFrame. 2. Write a second function `analyze_sales_data(df: pd.DataFrame) -> dict` that performs the following analysis on the cleaned DataFrame: - Calculate the total sales amount. - Calculate the average sales amount per product. - Identify the region with the highest sales. Return these insights in a dictionary format. Input: - `filepath`: (str) The path to the CSV file containing the sales data. - `df`: (pd.DataFrame) The cleaned sales DataFrame. Output: - For `clean_sales_data`: A cleaned pandas DataFrame. - For `analyze_sales_data`: A dictionary containing the total sales amount, average sales amount per product, and region with the highest sales. Notes: - Assume the CSV file has headers: \'date\', \'product\', \'sales_amount\', \'region\'. - Handle potential data reading errors with appropriate exception handling. - Ensure the analysis calculations are accurate and rounded to two decimal places where applicable. - Use pandas for data manipulation and ensure the code is modular and readable. Constraints: - Ensure the CSV file is not empty before processing. - The functions should handle potential data inconsistencies gracefully. - Import necessary libraries such as pandas. Example: Here is an example of expected function usage: ```python filepath = \\"sales_data.csv\\" cleaned_df = clean_sales_data(filepath) sales_analysis = analyze_sales_data(cleaned_df) print(sales_analysis) ``` Expected output could be: ```python { \'total_sales_amount\': 123456.78, \'average_sales_amount_per_product\': {\'ProductA\': 345.67, \'ProductB\': 234.56}, \'region_with_highest_sales\': \'North\' } ```","solution":"import pandas as pd def clean_sales_data(filepath: str) -> pd.DataFrame: try: df = pd.read_csv(filepath) except Exception as e: raise FileNotFoundError(f\\"Error reading the CSV file: {e}\\") if df.empty: raise ValueError(\\"The CSV file is empty.\\") # Fill missing values with the median of the respective column df[\'sales_amount\'].fillna(df[\'sales_amount\'].median(), inplace=True) # Remove outliers from \'sales_amount\' Q1 = df[\'sales_amount\'].quantile(0.25) Q3 = df[\'sales_amount\'].quantile(0.75) IQR = Q3 - Q1 # Interquartile range lower_bound = Q1 - 1.5 * IQR upper_bound = Q3 + 1.5 * IQR # Filter the data to remove outliers df = df[(df[\'sales_amount\'] >= lower_bound) & (df[\'sales_amount\'] <= upper_bound)] return df def analyze_sales_data(df: pd.DataFrame) -> dict: results = {} # Calculate the total sales amount total_sales_amount = df[\'sales_amount\'].sum() results[\'total_sales_amount\'] = round(total_sales_amount, 2) # Calculate the average sales amount per product avg_sales_per_product = df.groupby(\'product\')[\'sales_amount\'].mean().round(2).to_dict() results[\'average_sales_amount_per_product\'] = avg_sales_per_product # Identify the region with the highest sales sales_per_region = df.groupby(\'region\')[\'sales_amount\'].sum() region_with_highest_sales = sales_per_region.idxmax() results[\'region_with_highest_sales\'] = region_with_highest_sales return results"},{"question":"# Bandwidth Monitoring You are part of a team developing a network monitoring tool that tracks the bandwidth usage of multiple connections over a period of time. Each connection logs the amount of data transferred at specific times. # Task Write a function `calculate_bandwidth_usage(logs: List[Tuple[str, int, int]], start: int, end: int) -> Dict[str, int]` that calculates the total data transferred by each connection between the given start and end time (inclusive). # Parameters - `logs`: A list of tuples, where each tuple contains: - A string representing the connection identifier (e.g., \\"WAN1\\"). - An integer representing the timestamp in seconds. - An integer representing the amount of data transferred in bytes. - `start`: An integer representing the start time in seconds. - `end`: An integer representing the end time in seconds. # Output - A dictionary where the keys are the connection identifiers and the values are the total data transferred by each connection between the `start` and `end` times (inclusive). # Constraints - Each timestamp in the logs is unique. - Timestamps in the logs are not necessarily in order. - All timestamps in the logs are within the range of `start` and `end`. - The `start` time is always less than or equal to the `end` time. - `start` and `end` are non-negative integers. - The logs list is non-empty. # Example Here\'s an example to clarify the problem: ```python logs = [ (\\"WAN1\\", 1, 150), (\\"WAN2\\", 2, 300), (\\"WAN1\\", 3, 200), (\\"WAN2\\", 4, 100), (\\"WAN3\\", 5, 400) ] start = 2 end = 4 assert calculate_bandwidth_usage(logs, start, end) == { \\"WAN1\\": 200, \\"WAN2\\": 400 } ``` # Detailed Objective 1. **Understand the Inputs/Outputs**: - Input: list of logs, start time, end time. - Output: dictionary of data usage per connection within the time range. 2. **Filter Relevant Logs**: - Iterate through logs, summing data amounts if timestamps fall within the start and end range. 3. **Edge Cases Handling**: - Ensure only logs within the timestamp range are included. - Handle cases where no logs fall within the given range gracefully (default to zero usage for those connections). This problem tests your ability to manipulate lists and dictionaries, filter data based on conditions, and perform basic summation operations efficiently.","solution":"from typing import List, Tuple, Dict def calculate_bandwidth_usage(logs: List[Tuple[str, int, int]], start: int, end: int) -> Dict[str, int]: Calculate the total data transferred by each connection between the given start and end time (inclusive). :param logs: A list of tuples containing connection identifiers, timestamps, and data transferred. :param start: An integer representing the start time in seconds. :param end: An integer representing the end time in seconds. :return: A dictionary where keys are connection identifiers and values are total data transferred. usage = {} for connection, timestamp, data in logs: if start <= timestamp <= end: if connection in usage: usage[connection] += data else: usage[connection] = data return usage"},{"question":"# Question: Implement a Simple File-based Key-Value Store Problem Statement: You are required to implement a simple file-based key-value store. This store needs to support basic operations such as `get`, `set`, `delete`, and `save`. Data must persist across sessions by saving it to a file. Requirements: 1. Write a class `KeyValueStore` with the following methods: - `__init__(self, filename: str)`: Initialize the key-value store with the given filename. Load existing data from the file if it exists. - `get(self, key: str) -> str`: Return the value associated with the provided key. If the key does not exist, return `\\"Key not found\\"`. - `set(self, key: str, value: str) -> None`: Set the value for the provided key. If the key already exists, update the value. - `delete(self, key: str) -> None`: Delete the key-value pair for the provided key. If the key does not exist, do nothing. - `save(self) -> None`: Save the current state of the key-value store to the file. Input Format: 1. Integer `n`: The number of operations to be performed. 2. `n` operations each can be one of the following commands: - `\\"get <key>\\"` - `\\"set <key> <value>\\"` - `\\"delete <key>\\"` - `\\"save\\"` Output Format: * For each `get` command, return the value or `\\"Key not found\\"` if the key does not exist. Constraints: * Number of operations (1 leq n leq 10^3) * Keys and values are strings with lengths between 1 and 100 Example: Input: ``` 5 set name Alice set age 30 get name delete age get age ``` Output: ``` Alice Key not found ``` Implementation: ```python import json import os class KeyValueStore: def __init__(self, filename: str): self.filename = filename self.store = {} if os.path.isfile(filename): with open(filename, \'r\') as f: self.store = json.load(f) def get(self, key: str) -> str: return self.store.get(key, \\"Key not found\\") def set(self, key: str, value: str) -> None: self.store[key] = value def delete(self, key: str) -> None: if key in self.store: del self.store[key] def save(self) -> None: with open(self.filename, \'w\') as f: json.dump(self.store, f) if __name__ == \\"__main__\\": kv_store = KeyValueStore(\'store.json\') n = int(input()) for _ in range(n): command = input().split() cmd = command[0] if cmd == \'get\': print(kv_store.get(command[1])) elif cmd == \'set\': kv_store.set(command[1], command[2]) elif cmd == \'delete\': kv_store.delete(command[1]) elif cmd == \'save\': kv_store.save() ```","solution":"import json import os class KeyValueStore: def __init__(self, filename: str): self.filename = filename self.store = {} if os.path.isfile(filename): with open(filename, \'r\') as f: self.store = json.load(f) def get(self, key: str) -> str: return self.store.get(key, \\"Key not found\\") def set(self, key: str, value: str) -> None: self.store[key] = value def delete(self, key: str) -> None: if key in self.store: del self.store[key] def save(self) -> None: with open(self.filename, \'w\') as f: json.dump(self.store, f)"},{"question":"# Problem Statement You are given an array of integers where each element appears twice except for one element which appears only once. Your task is to implement a function that finds the element that appears only once. The algorithm should run in linear time and use constant space. # Input and Output - **Input**: An array of integers `nums`. - **Output**: An integer representing the element that appears only once in the array. # Constraints - The length of `nums` is between 1 and 10^5. - Each element in `nums` is between -10^9 and 10^9. - All but one of the elements in the array appear exactly twice. # Function Signature ```python def single_number(nums: List[int]) -> int: pass ``` # Example ```python # Example 1 nums = [2, 2, 1] print(single_number(nums)) # Output should be 1 # Example 2 nums = [4, 1, 2, 1, 2] print(single_number(nums)) # Output should be 4 # Example 3 nums = [1] print(single_number(nums)) # Output should be 1 # Example 4 nums = [1, 2, 0, 2, 3, 1, 0] print(single_number(nums)) # Output should be 3 ``` # Requirements 1. Implement the function to find the single number using linear time complexity (O(n)). 2. Ensure the function uses constant space (O(1)). 3. Handle edge cases such as an array with a single element.","solution":"def single_number(nums): Find the element that appears only once in the list where all other elements appear twice. Args: nums: List[int] - List of integers Returns: int - The single integer that appears only once single_num = 0 for num in nums: single_num ^= num return single_num"},{"question":"# Reordering Linked List Context You are given a linked list, and your goal is to reorder it in a specific manner. The task is to interleave elements from the beginning of the list with elements from the end of the list, maintaining their relative order. Objective Modify the `LinkedList` class to include a method `reorder_list` that reorders the linked list in-place as described above. 1. Find the middle of the linked list. 2. Reverse the second half of the list. 3. Merge the two halves, alternating nodes from each half. Requirements - **Input/Output Specifications**: * The `LinkedList` class should expose an `add`, `__str__`, and `reorder_list` method. * The `add` method adds an element to the end of the linked list. * The `reorder_list` method reorders the linked list as specified. * The `__str__` method returns a string representation of the linked list in the format “element1 -> element2 -> ...”. - **Constraints**: * The reordering must be done in-place without using any additional data structures for storing the nodes. * Maintain optimal time complexity and ensure that all methods handle the internal state correctly. Implementation Implement the `LinkedList` class with the necessary methods as outlined. Ensure that all methods operate as intended and handle edge cases such as an empty list or a list with a single element. Here is a function definition for reference: ```python class LinkedList: class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.head = None def add(self, data): new_node = self.Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): nodes = [] current = self.head while current: nodes.append(str(current.data)) current = current.next return \\" -> \\".join(nodes) def reorder_list(self): ... ``` Example Usage: ```python ll = LinkedList() ll.add(1) ll.add(2) ll.add(3) ll.add(4) ll.add(5) print(ll) # \\"1 -> 2 -> 3 -> 4 -> 5\\" ll.reorder_list() print(ll) # \\"1 -> 5 -> 2 -> 4 -> 3\\" ``` Make sure to run comprehensive tests to validate your implementation and handle edge cases effectively.","solution":"class LinkedList: class Node: def __init__(self, data=None): self.data = data self.next = None def __init__(self): self.head = None def add(self, data): new_node = self.Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): nodes = [] current = self.head while current: nodes.append(str(current.data)) current = current.next return \\" -> \\".join(nodes) def reorder_list(self): if not self.head or not self.head.next: return # Step 1: Find the middle of the linked list slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the list prev = None current = slow while current: next_node = current.next current.next = prev prev = current current = next_node # Step 3: Merge the two halves first = self.head second = prev while second.next: first_next = first.next second_next = second.next first.next = second second.next = first_next first = first_next second = second_next"},{"question":"# Matrix Rotation Given the following specifications: * You are implementing a function to rotate a given square matrix (2D list) 90 degrees clockwise. * The function should modify the matrix in place. * Consider handling both even and odd sizes of matrices. **Function Signature:** ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` **Input:** * List of lists `matrix` representing a square matrix of integers. **Output:** * The function modifies the input matrix in place and returns None. **Constraints:** * The matrix will have equal numbers of rows and columns. * `1 <= len(matrix) <= 100` * `-1000 <= matrix[i][j] <= 1000` for all valid `i`, `j`. **Problem Requirements:** * Implement the `rotate_matrix` function to rotate the matrix 90 degrees clockwise. * The rotation should be performed in place, requiring no additional matrices. * Ensure the matrix is correctly rotated for both even-sized and odd-sized matrices. **Example:** ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` **Notes:** * Test the function with various sizes of square matrices. * Verify the correctness of the function by checking if each element is properly rotated in place.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given square matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are given a string `s` and an integer `k`. Your task is to determine the minimum length of a substring of `s` in which at least `k` unique characters are present. # Function Signature ```python def min_length_k_unique_chars(s: str, k: int) -> int: ``` # Input * A string `s` of length `n` (1 ≤ n ≤ 10^5). * An integer `k` (1 ≤ k ≤ 26), representing the number of unique characters required in the substring. # Output * Return an integer representing the minimum length of a substring of `s` that contains at least `k` unique characters. If no such substring exists, return `-1`. # Example ```python assert min_length_k_unique_chars(\\"abcba\\", 2) == 2 assert min_length_k_unique_chars(\\"abcdefgh\\", 7) == 7 assert min_length_k_unique_chars(\\"aaaaaa\\", 2) == -1 ``` # Constraints * The solution should efficiently handle the time complexity and edge cases as discussed in the analysis. * Substrings should only be considered with sequential characters from the original string. # Note Utilize a sliding window approach to determine the minimum length efficiently. # Hints * Use a hash map to keep track of the count of characters in the current window. * Expand the window until it contains at least `k` unique characters, then try to shrink it from the left while maintaining the count of unique characters.","solution":"def min_length_k_unique_chars(s: str, k: int) -> int: if k > len(s): return -1 from collections import defaultdict min_length = float(\'inf\') char_count = defaultdict(int) unique_chars = 0 left = 0 for right in range(len(s)): if char_count[s[right]] == 0: unique_chars += 1 char_count[s[right]] += 1 while unique_chars >= k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_chars -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"# Coding Question: Optimizing Merge Sort for Linked List You are given an implementation of merge sort for sorting an array of integers. Your task is to modify and extend the existing algorithm to sort a singly linked list instead of an array. The given linked list is defined using the `ListNode` class. # Task 1. **Implement Merge Sort for Linked List**: - Modify the merge sort algorithm to work with a singly linked list. - Implement helper functions to find the middle of the linked list and to merge two sorted linked lists. 2. **Integration and Testing**: - Ensure that your implementation works correctly for various linked list lengths. - Write a test function to validate the merge sort implementation with at least three different test cases (e.g., an empty list, a short list, and a longer list). # Function Signatures ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sorts a linked list using merge sort. :param head: ListNode, the head of the linked list to be sorted. :return: ListNode, the head of the sorted linked list. # Implement merge sort for linked list here def find_middle(head: ListNode) -> ListNode: Finds the middle of the linked list. :param head: ListNode, the head of the linked list. :return: ListNode, the middle node of the linked list. # Implement logic to find the middle here def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists into one sorted linked list. :param l1: ListNode, the head of the first sorted linked list. :param l2: ListNode, the head of the second sorted linked list. :return: ListNode, the head of the merged sorted linked list. # Implement merging of two sorted lists here def test_merge_sort_linked_list(): Test function for merge sort on a linked list. # Implement test cases here ``` # Constraints: 1. Assume the linked list contains integer values. 2. Optimize the algorithm for both time (O(n log n)) and space complexity. # Sample Input: No specific input is needed as you will generate test cases for testing. # Sample Output: Print the sorted linked list for each test case to validate the correctness of the implementation. For example: ``` Original List: [3, 1, 2] Sorted List: [1, 2, 3] ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sorts a linked list using merge sort. :param head: ListNode, the head of the linked list to be sorted. :return: ListNode, the head of the sorted linked list. if not head or not head.next: return head middle = find_middle(head) right_head = middle.next middle.next = None # Split the list into two halves left_sorted = merge_sort_linked_list(head) right_sorted = merge_sort_linked_list(right_head) return merge_two_lists(left_sorted, right_sorted) def find_middle(head: ListNode) -> ListNode: Finds the middle of the linked list. :param head: ListNode, the head of the linked list. :return: ListNode, the middle node of the linked list. slow = head fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists into one sorted linked list. :param l1: ListNode, the head of the first sorted linked list. :param l2: ListNode, the head of the second sorted linked list. :return: ListNode, the head of the merged sorted linked list. dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 else: tail.next = l2 return dummy.next def linked_list_to_list(head: ListNode) -> list: Helper function to convert linked list to list for easier verification of results. :param head: ListNode, the head of the linked list. :return: list, the linked list represented as a Python list. result = [] while head: result.append(head.value) head = head.next return result def list_to_linked_list(values: list) -> ListNode: Helper function to convert list to linked list for easier test setup. :param values: list, the list of values to create the linked list. :return: ListNode, the head of the linked list. if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head"},{"question":"# Problem Statement Write a function that determines the number of unique words in a given text file. The function should be efficient in terms of memory usage and capable of handling large files. Function Signature ```python def count_unique_words(file_path: str) -> int: ``` Input * `file_path` (str): The path to the text file. Output * Returns the number of unique words in the given text file. Constraints * The function should read the file in a memory-efficient way (i.e., not loading the entire file into memory at once). * Words are case-insensitive (e.g., \\"Apple\\" and \\"apple\\" should be counted as the same word). * Punctuation should be ignored when determining unique words (e.g., \\"word,\\" and \\"word\\" should be counted as the same word). * The file may contain very large text, up to several gigabytes in size. Requirements * Your function should use file reading techniques to handle large amounts of text. * Implement necessary error handling for scenarios such as file not found or access denied. * Use appropriate data structures to ensure memory efficiency while counting unique words. # Example ```python unique_word_count = count_unique_words(\\"large_text_file.txt\\") print(f\\"Number of unique words: {unique_word_count}\\") ``` # Testing * Test with various text files including small, medium, and large sizes. * Ensure proper handling of edge cases like empty files, files with only punctuation, and files with mixed cases and special characters. * Validate memory efficiency by testing with files significantly larger than available system memory. # Additional Notes * Consider using libraries such as `re` for regular expression operations and `collections` for efficient data storage. * May provide example text files for test cases with varied content types, sizes, and structures to thoroughly evaluate the function\'s performance and accuracy.","solution":"import re def count_unique_words(file_path: str) -> int: Determines the number of unique words in a given text file. Words are treated case insensitive and punctuation is ignored. The function reads the file in a memory-efficient way. :param file_path: Path to the text file :return: Number of unique words in the file unique_words = set() word_pattern = re.compile(r\'bw+b\') try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: # Find all words in the current line words = word_pattern.findall(line.lower()) unique_words.update(words) except FileNotFoundError: print(f\\"The file {file_path} was not found.\\") return 0 except Exception as e: print(f\\"An error occurred: {e}\\") return 0 return len(unique_words)"},{"question":"# Coding Assessment Question: Matrix Operation and Statistics Context: In mathematical computations, operations with matrices are essential, and it\'s vital to perform them efficiently. Given a matrix representing data points, different computational statistics are required to analyze this data. Problem Statement: You are required to implement the following functions: 1. **transpose_matrix**: - **Input**: A matrix represented as a list of lists, where each inner list is a row of the matrix. - **Output**: The transpose of the given matrix. 2. **matrix_mean**: - **Input**: A matrix represented as a list of lists, where each inner list is a row of the matrix. - **Output**: A list of mean values of each column in the matrix. 3. **matrix_variance**: - **Input**: A matrix represented as a list of lists, where each inner list is a row of the matrix. - **Output**: A list of variances of each column in the matrix. 4. **correlation_coefficient**: - **Input**: Two lists of numerical values `x` and `y` representing two sets of data points. - **Output**: The correlation coefficient between `x` and `y`. - **Constraints**: The length of `x` must match the length of `y`. 5. **normalize_matrix**: - **Input**: A matrix represented as a list of lists, where each inner list is a row of the matrix. - **Output**: A normalized version of the matrix where each element is mapped to the range [0, 1]. Requirements: - Ensure input validation where appropriate, such as matrix dimensions matching for operations. - Optimize for performance and clarity. - Consider edge cases such as empty matrices, mismatched list lengths, etc. - Provide clear and concise documentation within the code. Example Usage: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Transpose Matrix transposed = transpose_matrix(matrix) print(transposed) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Matrix Mean mean_values = matrix_mean(matrix) print(mean_values) # Output: [4.0, 5.0, 6.0] # Matrix Variance variance_values = matrix_variance(matrix) print(variance_values) # Output: [6.0, 6.0, 6.0] # Correlation Coefficient x = [1, 2, 3] y = [4, 5, 6] correlation = correlation_coefficient(x, y) print(correlation) # Output: 1.0 # Normalize Matrix normalized = normalize_matrix(matrix) print(normalized) # Output: [[0.0, 0.5, 1.0], [0.0, 0.5, 1.0], [0.0, 0.5, 1.0]] ``` # Notes: - The `transpose_matrix` function flips the rows and columns of the matrix. - The `matrix_mean` function computes the average value of each column. - The `matrix_variance` function calculates the variance of each column. - The `correlation_coefficient` function measures the linear relationship between two datasets. - The `normalize_matrix` function scales the matrix values between 0 and 1.","solution":"def transpose_matrix(matrix): Returns the transpose of the given matrix. if not matrix: return [] return [list(row) for row in zip(*matrix)] def matrix_mean(matrix): Returns a list of mean values of each column in the matrix. if not matrix or not matrix[0]: return [] num_rows = len(matrix) num_cols = len(matrix[0]) return [sum(matrix[row][col] for row in range(num_rows)) / num_rows for col in range(num_cols)] def matrix_variance(matrix): Returns a list of variance values of each column in the matrix. if not matrix or not matrix[0]: return [] means = matrix_mean(matrix) num_rows = len(matrix) num_cols = len(matrix[0]) return [ sum((matrix[row][col] - means[col]) ** 2 for row in range(num_rows)) / num_rows for col in range(num_cols) ] def correlation_coefficient(x, y): Returns the correlation coefficient between two sets of data points x and y. if len(x) != len(y) or not x: return None n = len(x) mean_x, mean_y = sum(x) / n, sum(y) / n cov_xy = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y)) var_x = sum((xi - mean_x) ** 2 for xi in x) var_y = sum((yi - mean_y) ** 2 for yi in y) if var_x == 0 or var_y == 0: return None return cov_xy / ((var_x * var_y) ** 0.5) def normalize_matrix(matrix): Returns a normalized version of the matrix where each element is mapped to the range [0, 1]. if not matrix or not matrix[0]: return [] num_cols = len(matrix[0]) min_vals = [min(col) for col in zip(*matrix)] max_vals = [max(col) for col in zip(*matrix)] range_vals = [(max_vals[col] - min_vals[col]) for col in range(num_cols)] return [ [(matrix[row][col] - min_vals[col]) / range_vals[col] if range_vals[col] != 0 else 0 for col in range(num_cols)] for row in range(len(matrix)) ]"},{"question":"# Coding Challenge: Enhanced Text Analytics Objective Build a comprehensive text analytics tool that can analyze a given text for various features. You need to implement functions to derive the following statistics: 1. **Word Frequency**: Count the frequency of each word in the text. 2. **Unique Word Count**: Determine the number of unique words. 3. **Top N Frequent Words**: Return the N most frequent words and their counts. 4. **Sentence Count**: Determine the number of sentences in the text. Function Signatures 1. **Word Frequency**: ```python def word_frequency(text: str) -> dict: Counts the frequency of each word in the text. Parameters: text: str - The input text to be analyzed. Returns: dict - A dictionary with words as keys and their frequencies as values. ``` 2. **Unique Word Count**: ```python def unique_word_count(text: str) -> int: Determines the number of unique words in the text. Parameters: text: str - The input text to be analyzed. Returns: int - The count of unique words. ``` 3. **Top N Frequent Words**: ```python def top_n_frequent_words(text: str, n: int) -> list: Returns the N most frequent words and their counts. Parameters: text: str - The input text to be analyzed. n: int - The number of top frequent words to return. Returns: list - A list of tuples with the top N words and their frequencies. ``` 4. **Sentence Count**: ```python def sentence_count(text: str) -> int: Determines the number of sentences in the text. Parameters: text: str - The input text to be analyzed. Returns: int - The number of sentences in the text. ``` Constraints * **Input Format**: * **Word Frequency/Unique Word Count/Top N Frequent Words/Sentence Count**: `text` as a string. * **Top N Frequent Words**: `n` as a positive integer. * **Output Format**: * **Word Frequency**: Dictionary with words and their frequencies. * **Unique Word Count**: Single integer. * **Top N Frequent Words**: List of tuples, each containing a word and its frequency. * **Sentence Count**: Single integer. # Example ``` python >>> text = \\"Hello world! Hello everyone. Welcome to the world of programming.\\" >>> word_frequency(text) {\'hello\': 2, \'world\': 2, \'everyone.\': 1, \'welcome\': 1, \'to\': 1, \'the\': 1, \'of\': 1, \'programming.\': 1} >>> unique_word_count(text) 8 >>> top_n_frequent_words(text, 2) [(\'hello\', 2), (\'world\', 2)] >>> sentence_count(text) 3 ``` Additional Notes * Ensure all functions include proper docstrings and handling of edge cases. * Words should be treated case-insensitively (e.g., \\"Hello\\" and \\"hello\\" are the same word). * Sentences can be considered as sequences ending with punctuation marks like \'.\', \'!\', or \'?\'. * You may assume input text is well-formed and does not contain consecutive punctuation marks.","solution":"import re from collections import Counter def word_frequency(text: str) -> dict: Counts the frequency of each word in the text. Parameters: text: str - The input text to be analyzed. Returns: dict - A dictionary with words as keys and their frequencies as values. # Remove punctuation and make the text lowercase words = re.findall(r\'bw+b\', text.lower()) return dict(Counter(words)) def unique_word_count(text: str) -> int: Determines the number of unique words in the text. Parameters: text: str - The input text to be analyzed. Returns: int - The count of unique words. words = re.findall(r\'bw+b\', text.lower()) unique_words = set(words) return len(unique_words) def top_n_frequent_words(text: str, n: int) -> list: Returns the N most frequent words and their counts. Parameters: text: str - The input text to be analyzed. n: int - The number of top frequent words to return. Returns: list - A list of tuples with the top N words and their frequencies. words = re.findall(r\'bw+b\', text.lower()) frequency = Counter(words) return frequency.most_common(n) def sentence_count(text: str) -> int: Determines the number of sentences in the text. Parameters: text: str - The input text to be analyzed. Returns: int - The number of sentences in the text. sentences = re.split(r\'[.!?]+\', text) # Filter out empty strings in case of trailing punctuation return len([s for s in sentences if s.strip()])"},{"question":"# Customer Churn Prediction using Random Forest You are tasked with creating a Random Forest classifier to predict customer churn based on the given dataset. This involves loading and preprocessing the data, training the model, and validating its performance. Additionally, you\'ll need to implement a method for hyperparameter tuning to improve the model\'s accuracy. Function Specifications 1. **load_and_preprocess_data(filepath: str) -> tuple**: - **Input**: String `filepath` which is the path to the CSV file containing customer data. - **Output**: A tuple containing the features and target label arrays. 2. **train_random_forest(features: np.ndarray, target: np.ndarray, params: dict) -> RandomForestClassifier**: - **Input**: - `features`: numpy array of shape `(n_samples, n_features)` containing the feature data. - `target`: numpy array of shape `(n_samples,)` containing the target labels. - `params`: dictionary of hyperparameters for Random Forest. - **Output**: Trained `RandomForestClassifier` model. 3. **evaluate_model(model: RandomForestClassifier, features: np.ndarray, target: np.ndarray) -> float**: - **Input**: - `model`: Trained RandomForestClassifier model. - `features`: numpy array of shape `(n_samples, n_features)`. - `target`: numpy array of shape `(n_samples,)`. - **Output**: Accuracy score of the model on the provided dataset. 4. **tune_rf_hyperparameters(features: np.ndarray, target: np.ndarray) -> dict**: - **Input**: - `features`: numpy array of shape `(n_samples, n_features)`. - `target`: numpy array of shape `(n_samples,)`. - **Output**: Dictionary containing the best hyperparameters. Additional Requirements - The `load_and_preprocess_data` function should handle missing values and perform any necessary data transformations. - The `tune_rf_hyperparameters` function should explore multiple combinations of hyperparameters such as max depth, number of estimators, and min samples split. - Utilize cross-validation within `tune_rf_hyperparameters` to select the best performing hyperparameters. - The final model\'s performance should be assessed using a classification report and confusion matrix. # Example ```python # Expected usage example: # Load and preprocess data features, target = load_and_preprocess_data(\'customer_churn.csv\') # Split data into training and test sets x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.25) # Define initial hyperparameters params = {\'n_estimators\': 100, \'max_depth\': 10, \'min_samples_split\': 2} # Train the model rf_model = train_random_forest(x_train, y_train, params) # Evaluate model initial_accuracy = evaluate_model(rf_model, x_test, y_test) print(f\'Initial Model Accuracy: {initial_accuracy:.2f}\') # Tune hyperparameters best_rf_params = tune_rf_hyperparameters(x_train, y_train) # Train model with tuned hyperparameters best_rf_model = train_random_forest(x_train, y_train, best_rf_params) # Final evaluation final_accuracy = evaluate_model(best_rf_model, x_test, y_test) print(f\'Final Model Accuracy: {final_accuracy:.2f}\') # Additional performance metrics y_pred = best_rf_model.predict(x_test) print(classification_report(y_test, y_pred)) conf_matrix = confusion_matrix(y_test, y_pred) print(f\'Confusion Matrix:n{conf_matrix}\') ``` # Constraints - Assume the CSV file is correctly formatted with appropriate columns for features and the target label. - Your solution should be efficient and well-optimized for performance. - Write clean, readable, and well-documented code.","solution":"import numpy as np import pandas as pd from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.metrics import accuracy_score, classification_report, confusion_matrix def load_and_preprocess_data(filepath: str) -> tuple: Loads the data from the CSV file and preprocesses it. Parameters: filepath (str): Path to the CSV file containing customer data. Returns: tuple: Features and target label arrays. data = pd.read_csv(filepath) # Handle missing values data.fillna(method=\'ffill\', inplace=True) # For this example, let\'s assume the target column is named \'Churn\', and it is binary target = data[\'Churn\'].values features = data.drop(columns=[\'Churn\']).values return features, target def train_random_forest(features: np.ndarray, target: np.ndarray, params: dict) -> RandomForestClassifier: Trains a Random Forest classifier with the given parameters. Parameters: features (numpy array): Feature data of shape (n_samples, n_features). target (numpy array): Target labels of shape (n_samples,). params (dict): Hyperparameters for Random Forest. Returns: RandomForestClassifier: Trained Random Forest model. rf_model = RandomForestClassifier(**params) rf_model.fit(features, target) return rf_model def evaluate_model(model: RandomForestClassifier, features: np.ndarray, target: np.ndarray) -> float: Evaluates the model\'s accuracy on the given dataset. Parameters: model (RandomForestClassifier): Trained Random Forest model. features (numpy array): Feature data of shape (n_samples, n_features). target (numpy array): Target labels of shape (n_samples,). Returns: float: Accuracy score of the model. predictions = model.predict(features) return accuracy_score(target, predictions) def tune_rf_hyperparameters(features: np.ndarray, target: np.ndarray) -> dict: Performs hyperparameter tuning for the Random Forest classifier. Parameters: features (numpy array): Feature data of shape (n_samples, n_features). target (numpy array): Target labels of shape (n_samples,). Returns: dict: Best hyperparameters for Random Forest. param_grid = { \'n_estimators\': [50, 100, 150], \'max_depth\': [None, 10, 20, 30], \'min_samples_split\': [2, 5, 10] } rf_model = RandomForestClassifier() grid_search = GridSearchCV(estimator=rf_model, param_grid=param_grid, cv=5, n_jobs=-1) grid_search.fit(features, target) return grid_search.best_params_"},{"question":"# Context You are developing a purchase prediction model for an e-commerce platform. The platform tracks various user interactions (e.g., clicks, cart additions) and ultimately the purchase status. Your task is to implement a logistic regression algorithm to predict whether a user will make a purchase based on their interaction logs. # Requirements 1. Implement logistic regression to predict the binary outcome. 2. Implement the necessary functions to calculate the logistic hypothesis, update the parameters using gradient descent, and compute the cost function. 3. Ensure the algorithm converges to a reasonably good solution. # Input/Output 1. **Function**: `logistic_regression(train_data, test_data, initial_parameters, learning_rate, num_iterations)` - **Arguments**: - `train_data`: List of tuples ` [((feature1, feature2, ..., featureN), purchase_status), ...]`. Where purchase_status is 1 if purchase made, else 0. - `test_data`: List of tuples ` [((feature1, feature2, ..., featureN), purchase_status), ...]`. - `initial_parameters`: Initial parameters for the logistic hypothesis function. - `learning_rate`: Learning rate for the gradient descent. - `num_iterations`: Number of iterations for the gradient descent. - **Returns**: The optimized parameter vector after performing logistic regression. # Constraints - Interaction features and initial parameters are provided. - Learning rate is a small float value. - Assume no missing data for any example. - Iteration count is fixed. # Example ```python train_data = [((0.5, 0.3), 1), ((0.7, 0.8), 0), ((0.9, 0.4), 1), ((0.2, 0.1), 0)] test_data = [((0.6, 0.2), 1), ((0.3, 0.7), 0)] initial_parameters = [0.1, -0.2, 0.5] learning_rate = 0.01 num_iterations = 1000 optimal_parameters = logistic_regression(train_data, test_data, initial_parameters, learning_rate, num_iterations) print(optimal_parameters) # Output would be the optimized parameter vector. ``` # Criteria - Solution\'s accuracy in predicting the purchase status. - Correct implementation of logistic regression components. - Stability and convergence of the gradient descent process. - Efficient handling of the given computational complexity.","solution":"import math def logistic_regression(train_data, test_data, initial_parameters, learning_rate, num_iterations): Perform logistic regression using gradient descent. Args: train_data: List of tuples of feature vectors and purchase status test_data: List of tuples of feature vectors and purchase status initial_parameters: Initial parameters for the logistic hypothesis function. learning_rate: Learning rate for gradient descent num_iterations: Number of iterations for gradient descent Returns: The optimized parameter vector def sigmoid(z): return 1 / (1 + math.exp(-z)) def hypothesis(features, parameters): z = parameters[0] # bias term for i in range(len(features)): z += parameters[i + 1] * features[i] return sigmoid(z) def compute_cost(data, parameters): cost = 0 m = len(data) for features, purchase_status in data: prediction = hypothesis(features, parameters) if purchase_status == 1: cost += -math.log(prediction) else: cost += -math.log(1 - prediction) return cost / m def gradient_descent_step(parameters, data, learning_rate): m = len(data) n = len(parameters) - 1 parameter_updates = [0] * len(parameters) for features, purchase_status in data: prediction = hypothesis(features, parameters) error = prediction - purchase_status parameter_updates[0] += error # update for bias term for i in range(len(features)): parameter_updates[i + 1] += error * features[i] new_parameters = [0] * len(parameters) for i in range(len(parameters)): new_parameters[i] = parameters[i] - (learning_rate / m) * parameter_updates[i] return new_parameters parameters = initial_parameters[:] for _ in range(num_iterations): parameters = gradient_descent_step(parameters, train_data, learning_rate) return parameters"},{"question":"# Querying Customer Orders from a Database Problem Description You are given a database with tables representing customer information and orders. Your task is to fetch specific data as per the requirements. The database schema consists of the following tables: - `Customers`: - `customer_id` (integer, primary key) - `name` (text) - `email` (text) - `registration_date` (date) - `Orders`: - `order_id` (integer, primary key) - `customer_id` (integer, foreign key referencing Customers) - `order_date` (date) - `total_amount` (decimal) You need to write a function `fetch_customer_orders` to query this data. Your function should accept a single parameter `customer_id` and return a list of orders placed by that customer, sorted by `order_date` in descending order. Task Requirements Implement the function `fetch_customer_orders(customer_id: int) -> List[Dict[str, Union[int, str, float]]]` that: - Connects to an SQLite database named `shop.db`. - Executes an SQL query to fetch all orders made by the `customer_id` provided, sorted by `order_date` in descending order. - Returns the results as a list of dictionaries, each containing `order_id`, `order_date`, and `total_amount`. Input and Output - **Input**: A single integer `customer_id`. - **Output**: A list of dictionaries, each containing: - `order_id` (integer) - `order_date` (string, in \'YYYY-MM-DD\' format) - `total_amount` (float) Constraints - If the `customer_id` does not exist in the `Customers` table, return an empty list. - Assume the connection to the SQLite database is always successful. Example Assuming the `shop.db` database has the following entries: In `Customers` table: ``` customer_id | name | email | registration_date ------------------------------------------------------------- 1 | Alice | alice@example.com | 2021-01-10 2 | Bob | bob@example.com | 2021-02-15 ``` In `Orders` table: ``` order_id | customer_id | order_date | total_amount ----------------------------------------------------- 101 | 1 | 2021-05-15 | 250.75 102 | 1 | 2021-04-20 | 125.00 103 | 2 | 2021-06-18 | 300.00 ``` Output for `fetch_customer_orders(1)` would be: ```python [ {\\"order_id\\": 101, \\"order_date\\": \\"2021-05-15\\", \\"total_amount\\": 250.75}, {\\"order_id\\": 102, \\"order_date\\": \\"2021-04-20\\", \\"total_amount\\": 125.00} ] ``` Python code for reference: ```python import sqlite3 from typing import List, Dict, Union def fetch_customer_orders(customer_id: int) -> List[Dict[str, Union[int, str, float]]]: conn = sqlite3.connect(\'shop.db\') cursor = conn.cursor() cursor.execute( SELECT order_id, order_date, total_amount FROM Orders WHERE customer_id = ? ORDER BY order_date DESC , (customer_id,) ) rows = cursor.fetchall() conn.close() return [{\\"order_id\\": row[0], \\"order_date\\": row[1], \\"total_amount\\": row[2]} for row in rows] ```","solution":"import sqlite3 from typing import List, Dict, Union def fetch_customer_orders(customer_id: int) -> List[Dict[str, Union[int, str, float]]]: conn = sqlite3.connect(\'shop.db\') cursor = conn.cursor() cursor.execute( SELECT order_id, order_date, total_amount FROM Orders WHERE customer_id = ? ORDER BY order_date DESC , (customer_id,) ) rows = cursor.fetchall() conn.close() return [{\\"order_id\\": row[0], \\"order_date\\": row[1], \\"total_amount\\": row[2]} for row in rows]"},{"question":"# Problem Description Implement a function that identifies the largest palindrome in a given string, considering only alphanumeric characters and ignoring cases. A palindrome is a string that reads the same forward and backward when ignoring non-alphanumeric characters and case differences. # Function Signature ```python def longest_palindrome_substring(s: str) -> str: Identify the longest palindromic substring in the given string. ``` # Input * `s` (str): A string consisting of alphanumeric characters as well as other characters (e.g., punctuation and whitespace). # Output * A string representing the longest palindromic substring within the input. If multiple substrings of the same maximum length exist, return the first one encountered. # Constraints * The length of `s` will not exceed 1000 characters. # Performance Requirements * Aim for a solution that operates within O(n^2) time complexity if optimal, but sub-optimal solutions are acceptable with note. # Errors and Edge Cases * Consider both lower and upper cases equal. * Ignore non-alphanumeric characters while identifying the palindrome, but preserve original characters in the output. # Example ```python longest_palindrome_substring(\\"A man, a plan, a canal, Panama\\") # Returns \'amanaplanacanalPanama\' longest_palindrome_substring(\\"No \'x\' in Nixon\\") # Returns \'NoxinnixoN\' longest_palindrome_substring(\\"civic center\\") # Returns \'civic\' longest_palindrome_substring(\\"123abcba321\\") # Returns \'123abcba321\' ``` # Scenario Imagine that you are creating a text analysis tool that must identify meaningful patterns within texts, such as palindromic phrases or identifiers. This function will be used to extract the longest palindromic substring for applications such as DNA sequence analysis, cryptography, or literary studies.","solution":"def longest_palindrome_substring(s: str) -> str: Identify the longest palindromic substring in the given string. def preprocess(s): # Function to filter out non-alphanumeric and make all characters lower case return \'\'.join(c.lower() for c in s if c.isalnum()) def longest_palindrome(s): n = len(s) if n == 0: return \\"\\" # Initialize a table to record palindromic substrings table = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic start = 0 max_length = 1 for i in range(n): table[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 and up to n for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Checking if the substring from i to j is a palindrome if s[i] == s[j] and table[i + 1][j - 1]: table[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length] preprocessed = preprocess(s) longest_substr = longest_palindrome(preprocessed) return longest_substr"},{"question":"# Coding Assessment Question Circular Queue Implementation You are tasked with creating a circular queue data structure, which provides a fixed capacity. This type of queue should support common operations such as enqueue and dequeue while wrapping around when the end of the queue\'s array is reached. # Problem Statement Class: CircularQueue Implement a class `CircularQueue` that: - Initializes with a specified size (capacity). - Contains methods: `enqueue`, `dequeue`, `is_empty`, `is_full`, and `peek`. Specifications 1. **Constructor**: - `CircularQueue(capacity)`: Initializes the queue with the given capacity. 2. **Methods**: - `enqueue(item)`: Adds `item` to the end of the queue if it is not full. If the queue is full, print `Queue is full`. - `dequeue()`: Removes and returns the front item of the queue if it is not empty. If the queue is empty, print `Queue is empty` and return `None`. - `is_empty()`: Returns `True` if the queue is empty, otherwise `False`. - `is_full()`: Returns `True` if the queue is full, otherwise `False`. - `peek()`: Returns the front item in the queue without removing it if the queue is not empty. If the queue is empty, print `Queue is empty` and return `None`. Example Scenario Here\'s an example showing the expected behavior of the `CircularQueue` class: ```python queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.is_full()) # Output: True queue.enqueue(4) # Output: Queue is full print(queue.dequeue()) # Output: 1 queue.enqueue(4) print(queue.peek()) # Output: 2 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: 3 print(queue.dequeue()) # Output: 4 print(queue.dequeue()) # Output: Queue is empty # None ``` # Notes: - Ensure your implementation handles the circular nature of the queue correctly. - The queue should wrap around to the beginning of the array once the end is reached. Write the implementation for the `CircularQueue` class as described above.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 def is_full(self): if (self.rear + 1) % self.capacity == self.front: return True return False def is_empty(self): if self.front == -1: return True return False def enqueue(self, item): if self.is_full(): print(\\"Queue is full\\") return if self.front == -1: # Inserting the first element self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = item def dequeue(self): if self.is_empty(): print(\\"Queue is empty\\") return None item = self.queue[self.front] if self.front == self.rear: # Queue has become empty self.front = self.rear = -1 else: self.front = (self.front + 1) % self.capacity return item def peek(self): if self.is_empty(): print(\\"Queue is empty\\") return None return self.queue[self.front]"},{"question":"# Substring Finder in Circular Strings You are tasked with finding a substring within a circular version of a given string. A circular string is created by concatenating the string to itself. For example, the circular version of \\"abc\\" is \\"abcabc\\". Your goal is to determine if a substring exists in this circular string. # Task 1. **Circular Substring Check**: Write a function `is_substring_in_circular_string(s: str, sub: str) -> bool` that checks if a given substring `sub` exists in the circular version of the string `s`. # Expected Input and Output Format Input: * `is_substring_in_circular_string(s: str, sub: str) -> bool` - `s` is a non-empty string containing lowercase alphabetic characters. - `sub` is also a string containing lowercase alphabetic characters that is not empty. Output: * The function should return `True` if `sub` exists in the circular version of `s`, otherwise `False`. # Constraints and Limitations - The length of the input string `s` will be between 1 and 100 characters. - The length of the substring `sub` will be between 1 and 100 characters. # Example Example 1: ```python assert is_substring_in_circular_string(\\"abcde\\", \\"cdeab\\") == True ``` Example 2: ```python assert is_substring_in_circular_string(\\"abcd\\", \\"cdab\\") == True ``` Example 3: ```python assert is_substring_in_circular_string(\\"abc\\", \\"def\\") == False ``` Example 4: ```python assert is_substring_in_circular_string(\\"xyz\\", \\"yzx\\") == True ``` # Explanation: - In Example 1, the circular version of \\"abcde\\" is \\"abcdeabcde\\", and \\"cdeab\\" is indeed a substring of \\"abcdeabcde\\". - In Example 2, the circular version of \\"abcd\\" is \\"abcdabcd\\", and \\"cdab\\" is a substring of \\"abcdabcd\\". - In Example 3, the circular version of \\"abc\\" is \\"abcabc\\", and \\"def\\" is not a substring of \\"abcabc\\". - In Example 4, the circular version of \\"xyz\\" is \\"xyzxyz\\", and \\"yzx\\" is a substring of \\"xyzxyz\\".","solution":"def is_substring_in_circular_string(s: str, sub: str) -> bool: Checks if `sub` is a substring in the circular version of `s`. circular_s = s + s return sub in circular_s"},{"question":"# Problem Statement You are required to implement a system that monitors a live chat and filters out inappropriate messages. The system should maintain a list of banned words and phrases, and replace them in messages with asterisks (*). # Task Write a function `filter_messages` that takes in a list of banned words and a list of messages. The function should return a new list where all occurrences of banned words in each message are replaced with asterisks, preserving the original casing. # Input - `banned_words` (list of str): A list of banned words or phrases. - `messages` (list of str): A list of messages to be filtered. # Output - List of filtered messages with banned words replaced by `*`. # Constraints - The length of `banned_words` and `messages` should not exceed 1000. - Each individual message and banned word/phrase should not exceed 100 characters. - Banned words/phrases are case-insensitive, but the replacement should match the original casing. # Performance Requirements - The solution should handle multiple messages efficiently. - Ensure that replacements are correctly done with pattern matching for whole words and phrases. # Example Function Signature ```python import re def filter_messages(banned_words: list, messages: list) -> list: filtered_messages = [] # Create a regex pattern out of banned words pattern = \'|\'.join(re.escape(word) for word in banned_words) regex = re.compile(pattern, re.IGNORECASE) for message in messages: # Replace banned words with asterisks filtered_message = regex.sub(lambda match: \'*\' * len(match.group()), message) filtered_messages.append(filtered_message) return filtered_messages # Example Usage banned_words = [\\"badword\\", \\"unwanted\\"] messages = [ \\"This is a badword example.\\", \\"No unwanted phrases allowed.\\", \\"This message is clean.\\" ] filtered = filter_messages(banned_words, messages) for message in filtered: print(message) # Output: # This is a ******* example. # No ******* phrases allowed. # This message is clean. ``` **Note:** Ensure that your function preserves punctuation around banned words and correctly handles words with mixed casing.","solution":"import re def filter_messages(banned_words: list, messages: list) -> list: filtered_messages = [] # Create a regex pattern out of banned words with word boundaries to ensure the whole word is matched pattern = r\'b(\' + \'|\'.join(re.escape(word) for word in banned_words) + r\')b\' regex = re.compile(pattern, re.IGNORECASE) for message in messages: # Replace banned words with asterisks def asterisk_replacement(match): return \'*\' * len(match.group()) filtered_message = regex.sub(asterisk_replacement, message) filtered_messages.append(filtered_message) return filtered_messages"},{"question":"# Question: Merge Sorted Subarrays You are given two non-decreasingly sorted subarrays residing within a larger array. Your task is to implement a function `merge_sorted_subarrays(arr: List[int], start1: int, end1: int, start2: int, end2: int) -> None` that merges these two subarrays in place such that the resultant subarray is also sorted. Function Signature: ```python def merge_sorted_subarrays(arr: List[int], start1: int, end1: int, start2: int, end2: int) -> None: pass ``` # Input: * An array `arr` of integers. * Integers `start1`, `end1` representing the start and end indices (inclusive) of the first subarray. * Integers `start2`, `end2` representing the start and end indices (inclusive) of the second subarray. # Output: * The function should modify the original array `arr` in place to merge the specified subarrays. # Constraints: * `1 <= len(arr) <= 10^5` * The specified subarrays `arr[start1:end1+1]` and `arr[start2:end2+1]` are sorted in non-decreasing order. * `0 <= start1 <= end1 < start2 <= end2 < len(arr)` # Example: ```python arr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] merge_sorted_subarrays(arr, 0, 4, 5, 9) # Now, arr should be modified to: assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] arr = [1, 2, 3, 6, 7, 4, 5, 8, 9, 10] merge_sorted_subarrays(arr, 0, 4, 5, 9) # Now, arr should be modified to: assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] arr = [15, 18, 20, 22, 30, 1, 5, 10] merge_sorted_subarrays(arr, 0, 4, 5, 7) # Now, arr should be modified to: assert arr == [1, 5, 10, 15, 18, 20, 22, 30] ``` # Performance Requirements: * The function must handle input sizes up to `10^5` efficiently in terms of both time and space complexity. **Hint**: You can use an auxiliary array for merging but try to optimize the space usage considering in-place modification as much as possible. # Scenario: Consider you are working on a large-scale data processing system that involves merging sorted datasets frequently. Your function needs to operate on large data sets and must perform merging operations without allocating excessive additional memory. Your solution should focus on both the efficiency and the correctness of the in-place merge operation.","solution":"from typing import List def merge_sorted_subarrays(arr: List[int], start1: int, end1: int, start2: int, end2: int) -> None: Merges two sorted subarrays within `arr` in place. # Create auxiliary arrays for the two subarrays left = arr[start1:end1+1] right = arr[start2:end2+1] l_index, r_index = 0, 0 k = start1 # Merge the two subarrays back into the original array `arr` while l_index < len(left) and r_index < len(right): if left[l_index] <= right[r_index]: arr[k] = left[l_index] l_index += 1 else: arr[k] = right[r_index] r_index += 1 k += 1 # Copy any remaining elements from left subarray, if any while l_index < len(left): arr[k] = left[l_index] l_index += 1 k += 1 # Copy any remaining elements from right subarray, if any while r_index < len(right): arr[k] = right[r_index] r_index += 1 k += 1"},{"question":"# Coding Assessment Question You are a software engineer at a logistics company. Your team is developing an application that tracks the movement of delivery trucks in a city. Part of your task is to determine the optimal route for each truck to follow to minimize travel distance. Create a function `shortest_route(routes: List[Tuple[str, str, int]], start: str, end: str) -> int` that calculates the minimum travel distance between two cities based on the given routes. * **Input/Output Formats**: * **Input**: * `routes` (List[Tuple[str, str, int]]): A list of tuples, each containing three elements: * A string representing the starting city. * A string representing the destination city. * An integer representing the travel distance between these two cities. * `start` (str): The starting city. * `end` (str): The destination city. * **Output**: * (int): The minimum travel distance from `start` city to `end` city. If there is no possible route, return -1. * **Constraints and Limitations**: * All cities are represented by unique strings. * The travel distance between two cities is a positive integer. * If either `start` or `end` city is not in the routes, or no route exists between them, return -1. * There can be multiple routes between the same pair of cities, but with different distances. * **Performance Requirements**: * Your function should handle the input effectively. * Ensure the function runs within reasonable time limits for large input sizes. * **Example**: ```python from typing import List, Tuple def shortest_route(routes: List[Tuple[str, str, int]], start: str, end: str) -> int: # your implementation here # Test Cases print(shortest_route([(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"C\\", 15)], \\"A\\", \\"C\\")) # Expected output: 15 print(shortest_route([(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 20), (\\"A\\", \\"C\\", 10)], \\"A\\", \\"C\\")) # Expected output: 10 print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10), (\\"C\\", \\"D\\", 7), (\\"A\\", \\"D\\", 20)], \\"A\\", \\"D\\")) # Expected output: 20 print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10), (\\"C\\", \\"D\\", 7)], \\"A\\", \\"E\\")) # Expected output: -1 print(shortest_route([(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 10)], \\"A\\", \\"D\\")) # Expected output: -1 ``` Compose a function that handles complex and sizable inputs efficiently, adhering to the time complexity expected for an optimal graph traversal problem, such as Dijkstra\'s algorithm or similar.","solution":"from typing import List, Tuple from heapq import heappop, heappush from collections import defaultdict, deque def shortest_route(routes: List[Tuple[str, str, int]], start: str, end: str) -> int: Calculates the minimum travel distance between two cities based on given routes. Parameters: - routes: List of tuples each containing (starting city, destination city, travel distance) - start: Starting city - end: Destination city Returns: - Minimum travel distance from start city to end city. If no route exists, returns -1. graph = defaultdict(list) for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # If routes are bidirectional heap = [(0, start)] distances = {start: 0} while heap: current_distance, current_city = heappop(heap) if current_city == end: return current_distance for neighbor, weight in graph[current_city]: distance = current_distance + weight if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return -1"},{"question":"# Scenario Strings are a crucial data type in programming, and manipulating them efficiently is a common task. Whether it is formatting, searching, or transforming, string operations are fundamental in many applications. # Task Create a Python function `count_substrings(main_string: str, sub_string: str) -> int` that takes a main string and a sub-string, and returns the number of times the sub-string occurs within the main string. The search should be case-insensitive and overlapping matches should also be counted. # Input Specifications * `main_string`: The main string within which the sub-string is to be searched. It will be a non-empty string containing up to 10^6 characters. * `sub_string`: The sub-string to search for within the main string. It will be a non-empty string containing up to 10^3 characters. # Output Specifications * Returns an integer representing the count of occurrences of the sub-string within the main string. # Constraints * The search should be case-insensitive. * Overlapping occurrences should be counted. # Example ```python >>> count_substrings(\\"abababa\\", \\"aba\\") 3 >>> count_substrings(\\"The quick brown fox jumps over the lazy dog\\", \\"the\\") 2 >>> count_substrings(\\"aaaa\\", \\"aa\\") 3 ``` # Requirements * Ensure the function is optimized to handle the upper limit of input sizes efficiently. * Handle case-insensitivity by converting the input strings appropriately before processing.","solution":"def count_substrings(main_string: str, sub_string: str) -> int: Count occurrences of sub_string within main_string, case-insensitively and allowing overlapping matches. main_string = main_string.lower() sub_string = sub_string.lower() count = 0 start = 0 while True: start = main_string.find(sub_string, start) if start == -1: break count += 1 start += 1 # Increment start to allow for overlapping matches return count"},{"question":"# Problem Description You are challenged to implement a **Matrix Flipping Algorithm** that flips a given matrix horizontally and vertically. The goal is to provide a function that inverts the order of the rows and the order of the elements in each row, effectively performing a 180-degree rotation. # Function Specification **Function Name**: `flip_matrix` **Input**: - `matrix`: A list of lists of integers, where each sublist represents a row of the matrix. Each row will contain integers such that ( 0 leq text{len(row)} leq 10^3 ) and ( -10^6 leq text{matrix[i][j]} leq 10^6 ). **Output**: - The function should return a new list of lists of integers representing the flipped matrix. **Constraints**: - Assume the input matrix has at least one row and that all rows have the same length. - Do not use any built-in flip or reverse functions. - Handle edge cases where the matrix could be empty or contain one row. # Example ```python def flip_matrix(matrix): >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> result = flip_matrix(matrix) >>> print(result) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] >>> matrix = [ ... [1, 2] ... ] >>> result = flip_matrix(matrix) >>> print(result) [[2, 1]] >>> matrix = [] >>> result = flip_matrix(matrix) >>> print(result) [] ``` # Requirements - Do not use any built-in functions for reversing the matrix or its rows. - The function should be as efficient as possible given the constraints. - Ensure proper handling of edge cases, including very small or empty matrices. # Performance Requirements - The time complexity should be O(n * m) where n is the number of rows and m is the number of columns. - The space complexity should be proportional to the size of the matrix.","solution":"def flip_matrix(matrix): Flips the given matrix horizontally and vertically. flipped = [] for row in reversed(matrix): new_row = row[::-1] flipped.append(new_row) return flipped"},{"question":"# Context You are given a large dataset representing user activity on a social media platform. Each entry in the dataset consists of the user ID and the timestamp of an action performed by the user. Your goal is to analyze the dataset and find the user with the most frequent actions within a given time period. # Problem Statement Write a function `most_active_user(start_time: str, end_time: str, activities: List[Tuple[str, str]]) -> str` that determines the user who has the highest number of activities within the specified time frame. If there is a tie, return the user with the lexicographically smaller user ID. # Function Signature ```python from typing import List, Tuple def most_active_user(start_time: str, end_time: str, activities: List[Tuple[str, str]]) -> str: Determines the user with the most activities within the given time period. If there\'s a tie, returns the user with the lexicographically smaller user ID. Parameters: start_time (str): The start of the time period in the format \'YYYY-MM-DD HH:MM:SS\'. end_time (str): The end of the time period in the format \'YYYY-MM-DD HH:MM:SS\'. activities (List[Tuple[str, str]]): A list of tuples where each tuple contains a user ID and a timestamp in the format \'YYYY-MM-DD HH:MM:SS\'. Returns: str: The user ID with the most frequent activities within the given time period. ``` # Input - `start_time`: A string representing the start of the time period in the format \'YYYY-MM-DD HH:MM:SS\'. - `end_time`: A string representing the end of the time period in the format \'YYYY-MM-DD HH:MM:SS\'. - `activities`: A list of tuples where each tuple contains: - A string `user_id` representing the ID of the user. - A string `timestamp` representing the time the action was performed in the format \'YYYY-MM-DD HH:MM:SS\'. # Output - Returns a string representing the user ID with the highest number of activities within the specified time period. If there is a tie, the lexicographically smaller user ID is returned. # Examples ```python activities = [ (\'user_1\', \'2023-01-01 10:00:00\'), (\'user_2\', \'2023-01-01 11:00:00\'), (\'user_1\', \'2023-01-01 12:00:00\'), (\'user_3\', \'2023-01-01 12:30:00\'), (\'user_2\', \'2023-01-01 13:00:00\'), (\'user_2\', \'2023-01-01 14:00:00\'), (\'user_1\', \'2023-01-01 15:00:00\') ] assert most_active_user(\'2023-01-01 11:00:00\', \'2023-01-01 14:00:00\', activities) == \'user_2\' assert most_active_user(\'2023-01-01 09:00:00\', \'2023-01-01 12:00:00\', activities) == \'user_1\' ``` # Constraints - The timestamps in `activities` are guaranteed to be in ascending order. - The number of activities can be large, up to (10^6). - User IDs are alphanumeric strings. - The implementation should handle large inputs efficiently. # Notes - Consider using a dictionary to count the activities for each user within the given time range. - Ensure that the function can handle edge cases such as multiple users with the same highest number of activities.","solution":"from typing import List, Tuple from collections import defaultdict def most_active_user(start_time: str, end_time: str, activities: List[Tuple[str, str]]) -> str: Determines the user with the most activities within the given time period. If there\'s a tie, returns the user with the lexicographically smaller user ID. start_time = int(start_time.replace(\'-\', \'\').replace(\' \', \'\').replace(\':\', \'\')) end_time = int(end_time.replace(\'-\', \'\').replace(\' \', \'\').replace(\':\', \'\')) activity_count = defaultdict(int) for user_id, timestamp in activities: current_time = int(timestamp.replace(\'-\', \'\').replace(\' \', \'\').replace(\':\', \'\')) if start_time <= current_time <= end_time: activity_count[user_id] += 1 # Find the user with the maximum activities most_active = sorted(activity_count.items(), key=lambda x: (-x[1], x[0])) return most_active[0][0] if most_active else None"},{"question":"# Question: Implement a Custom Cache System You are required to implement a custom cache system as a class named `CustomCache`. The cache should support two primary operations: retrieving a value associated with a given key and inserting a key-value pair with a time-to-live (TTL) value. The cache should automatically invalidate and remove expired entries based on their TTL values which are specified in milliseconds. Your task is to complete the implementation of the following methods in the `CustomCache` class: 1. `get(self, key: str) -> int | float | None`: This method should return the value associated with the given key if it exists and hasn\'t expired. If the key does not exist or has expired, it should return `None`. 2. `put(self, key: str, value: int | float, ttl: int) -> None`: This method should insert the key-value pair into the cache with an associated TTL value specified in milliseconds. If the key already exists, it should update the value and TTL accordingly. Additionally, implement an internal method `_cleanup(self) -> None` that should remove expired entries from the cache. Constraints: - The cache should support integer and float values only. - The cache should operate in O(1) average time complexity for the `get` and `put` operations. - The maximum number of entries in the cache is 1000. # Example Usage: ```python # Create the custom cache object cache = CustomCache() # Insert key-value pairs with TTLs cache.put(\\"a\\", 100, 5000) # TTL of 5 seconds cache.put(\\"b\\", 200, 10000) # TTL of 10 seconds # Retrieve values before TTL expires print(cache.get(\\"a\\")) # Output: 100 print(cache.get(\\"b\\")) # Output: 200 # Simulate waiting (in reality, would need to wait in real-time or manipulate the system clock) import time time.sleep(6) # Sleep for 6 seconds to allow TTL of \\"a\\" to expire # Retrieve values after TTL expires print(cache.get(\\"a\\")) # Output: None (expired) print(cache.get(\\"b\\")) # Output: 200 (still valid) ``` # Additional Details: - The `get` method should trigger the `_cleanup` method to ensure expired entries are removed before any retrieval operation. - The system time should be used to check whether an entry has expired. # Notes: - Your implementation of `CustomCache` should ensure optimal performance and efficient memory management.","solution":"import time import threading class CustomCache: def __init__(self): self.cache = {} self.lock = threading.Lock() # To ensure thread safety self.capacity = 1000 def get(self, key: str) -> int | float | None: with self.lock: self._cleanup() if key in self.cache: value, expiry = self.cache[key] if time.time() * 1000 < expiry: return value return None def put(self, key: str, value: int | float, ttl: int) -> None: with self.lock: if len(self.cache) >= self.capacity: self._cleanup() if len(self.cache) >= self.capacity: # In case _cleanup didn\'t free up space self._evict_lru() expiry = time.time() * 1000 + ttl self.cache[key] = (value, expiry) def _cleanup(self) -> None: current_time = time.time() * 1000 keys_to_delete = [key for key, (value, expiry) in self.cache.items() if expiry < current_time] for key in keys_to_delete: del self.cache[key] def _evict_lru(self) -> None: # could use more sophisticated eviction policy here if desired oldest_key = min(self.cache, key=lambda k: self.cache[k][1]) del self.cache[oldest_key]"},{"question":"# Task To validate your understanding of string manipulation and data encoding, implement a function to determine whether a given string contains valid ASCII values when transformed. # Function Signature ```python def is_valid_ascii(s: str) -> bool: Check if the given string contains only valid ASCII values when transformed. :param s: The string to check. :return: True if the string contains only valid ASCII values, otherwise False. ``` # Description - **Input**: A single string `s`. - **Output**: Return a boolean value, `True` if each character\'s transformed ASCII value should be between 0 and 127 inclusive, and `False` otherwise. # Constraints - The string length `0 <= len(s) <= 100`. # Example ```python assert is_valid_ascii(\\"Hello\\") == True # Each character\'s ASCII: H(72), e(101), l(108), l(108), o(111) - all within ASCII. assert is_valid_ascii(\\"Ç\\") == False # ASCII value for \'Ç\' is 199 - not within ASCII range. assert is_valid_ascii(\\"\\") == True # Empty string should return True. assert is_valid_ascii(chr(127)) == True # ASCII value for chr(127) is 127. assert is_valid_ascii(chr(128)) == False # ASCII value for chr(128) is 128 - out of valid ASCII range. ``` # Guidelines 1. **ASCII Range Definition**: ASCII values range from 0 to 127 inclusive. 2. **Check Properties**: - Ensure all characters in the string satisfy the ASCII range condition. - Return `True` if all characters are within range and `False` otherwise. 3. **Edge Cases**: - Consider the empty string case which should return `True`. - Handle non-ASCII characters correctly. # Note Pay attention to potential characters outside the typical ASCII range that could appear in Unicode or other extended character sets. The function should return `False` for any such characters.","solution":"def is_valid_ascii(s: str) -> bool: Check if the given string contains only valid ASCII values when transformed. :param s: The string to check. :return: True if the string contains only valid ASCII values, otherwise False. return all(ord(c) >= 0 and ord(c) <= 127 for c in s)"},{"question":"# Question: Finding the First Non-Repeated Character in a String Context You are developing a string manipulation utility for a text processing application. One of the features you need to implement is to find the first character in a string that does not repeat itself later in the string. This function will help in identifying unique markers or keys in the given input. Task Implement the function `first_non_repeated_character(s: str) -> str` that takes a single string as its input and returns the first character which does not repeat later in the string. If all characters are repeated or if the string is empty, return an empty string. Function Signature ```python def first_non_repeated_character(s: str) -> str: pass ``` Input * A single string `s` containing lowercase and uppercase letters (0 <= len(s) <= 1000). Output * A single character which is the first non-repeated character in the string or an empty string if all characters are repeated or the string is empty. Constraints * If the input string contains any characters other than lowercase and uppercase letters, the function should raise a `ValueError` indicating an invalid character. Example ```python first_non_repeated_character(\\"swiss\\") ➞ \\"w\\" first_non_repeated_character(\\"character\\") ➞ \\"c\\" first_non_repeated_character(\\"aabbcc\\") ➞ \\"\\" first_non_repeated_character(\\"\\") ➞ \\"\\" first_non_repeated_character(\\"Engineering\\") ➞ \\"E\\" ``` Additional Notes * Ensure the function handles both lowercase and uppercase characters as distinct. * Test for the presence of invalid characters and respond with the appropriate error. * Handle typical edge cases such as strings with all repeated characters or empty strings effectively. --- This question aligns with coding assessments common in interviews, testing knowledge in string manipulation, algorithm design, and error handling. It showcases a common real-world problem closely related to text processing and data parsing.","solution":"def first_non_repeated_character(s: str) -> str: if not s: return \'\' # Check for invalid characters if not s.isalpha(): raise ValueError(\\"Invalid character in input string. Only letters are allowed.\\") char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find and return the first non-repeated character for char in s: if char_count[char] == 1: return char return \'\' # Sample run to verify code # print(first_non_repeated_character(\\"swiss\\")) # should return \\"w\\" # print(first_non_repeated_character(\\"aabbcc\\")) # should return \\"\\""},{"question":"# Coding Assessment Question Scenario: You are developing a software system that requires processing of geometric shapes, particularly rectangles. One of the tasks involves determining if rectangles overlap on a 2D plane, which is crucial for collision detection algorithms in games and graphical applications. Task: Implement a function `do_rectangles_overlap` that determines if two rectangles overlap. Rectangles are represented as tuples of four integers: `(x1, y1, x2, y2)`, where `(x1, y1)` are the coordinates of the bottom-left corner and `(x2, y2)` are the coordinates of the top-right corner. # Requirements: 1. Implement the function `do_rectangles_overlap(rect1: tuple, rect2: tuple) -> bool`. 2. Ensure that your function handles various edge cases, including touching rectangles and completely overlapping rectangles. 3. Optimize for performance given the constraints. # Input Format: - Two tuples representing the coordinates of two rectangles. # Output Format: - A boolean value: `True` if the rectangles overlap, otherwise `False`. # Constraints: - Coordinates are integers. - ( |x1|, |y1|, |x2|, |y2| leq 10^4 ). # Explanation: Two rectangles do not overlap if one is entirely to the left, right, above, or below the other. Use this principle to determine the overlap. # Code: ```python def do_rectangles_overlap(rect1: tuple[int, int, int, int], rect2: tuple[int, int, int, int]) -> bool: # Extract coordinates x1A, y1A, x2A, y2A = rect1 x1B, y1B, x2B, y2B = rect2 # Check if one rectangle is to the left of the other if x1A >= x2B or x1B >= x2A: return False # Check if one rectangle is above the other if y1A >= y2B or y1B >= y2A: return False return True ``` # Example: ```python # Example usage rect1 = (2, 1, 5, 5) rect2 = (3, 2, 6, 6) rect3 = (6, 2, 8, 4) print(do_rectangles_overlap(rect1, rect2)) # Output: True print(do_rectangles_overlap(rect1, rect3)) # Output: False ``` # Explanation: - **Input 1**: Two tuples `rect1` and `rect2`. - **Process**: Check if any rectangle is completely to one side of the other using logical conditions. - **Output**: `True` if the rectangles overlap, `False` otherwise.","solution":"def do_rectangles_overlap(rect1, rect2): Determine if two rectangles overlap. Parameters: rect1 (tuple): A tuple containing four integers representing the coordinates of the first rectangle (x1, y1, x2, y2). rect2 (tuple): A tuple containing four integers representing the coordinates of the second rectangle (x1, y1, x2, y2). Returns: bool: True if the rectangles overlap, False otherwise. # Extract coordinates x1A, y1A, x2A, y2A = rect1 x1B, y1B, x2B, y2B = rect2 # Check if one rectangle is to the left of the other if x1A >= x2B or x1B >= x2A: return False # Check if one rectangle is above the other if y1A >= y2B or y1B >= y2A: return False return True"},{"question":"# Coding Assessment Question **Scenario**: You\'ve been employed as a software engineer tasked with developing an automatic code indentation verifier for Python. The verifier checks whether the given Python code has consistent indentation or not. Proper indentation is crucial for the readability and execution of Python code. # Problem Statement: Implement a function `is_indentation_correct(code: str) -> bool` that determines whether the provided Python code string has consistent indentation. The code should be indented with either tabs or spaces but not both, and each indentation level should be consistent throughout. # Requirements: 1. **Input**: - A single string `code` representing the Python source code, which can span multiple lines. 2. **Output**: - A boolean value: `True` if the code has consistent indentation, and `False` otherwise. 3. **Constraints**: - The input `code` string may include any characters relevant to Python syntax. - Empty lines or lines that entirely consist of spaces or tabs can be ignored. - The input `code` string will be at most 10,000 characters long. # Examples: ```python >>> code1 = \\"def func():n print(\'Hello\')n if True:n print(\'World\')\\" >>> is_indentation_correct(code1) True >>> code2 = \\"def func():ntprint(\'Hello\')ntif True:nttprint(\'World\')\\" >>> is_indentation_correct(code2) True >>> code3 = \\"def func():n print(\'Hello\')ntif True:n print(\'World\')\\" >>> is_indentation_correct(code3) False >>> code4 = \\"def func():n print(\'Hello\') n if True:n print(\'World\')n\\" >>> is_indentation_correct(code4) True >>> code5 = \\"def func():n print(\'Hello\')n if True:n print(\'World \') \\" >>> is_indentation_correct(code5) True >>> code6 = \\"\\" >>> is_indentation_correct(code6) True ``` # Guidelines: * Your function should be robust and correctly identify inconsistencies in indentation, handling both tabs and spaces. * Ignore empty lines or lines containing only whitespace characters when checking indentation. * Do not mix tabs and spaces in the same indentation level. * Consider edge cases such as empty input, lines with varying amounts of indentation, and mixed usage of tabs and spaces. By carefully analyzing the indentation pattern, your function will help ensure that Python code adheres to proper formatting practices, enhancing readability and maintainability.","solution":"def is_indentation_correct(code: str) -> bool: Check if the given Python code has consistent indentation. :param code: A string representing Python source code. :return: True if indentation is consistent, else False. lines = code.split(\'n\') first_indent = None type_of_indent = None for line in lines: stripped_line = line.lstrip() if not stripped_line: # Ignore empty lines or lines with only whitespace continue indent = len(line) - len(stripped_line) if indent > 0: if first_indent is None: first_indent = indent type_of_indent = line[0] else: if line[0] != type_of_indent: return False if indent % first_indent != 0: return False return True"},{"question":"# Scenario You are developing a URL shortening service similar to bit.ly or tinyurl. This service will take long URLs and shorten them to a fixed-length string. In this scenario, you need to create the core functionality which includes encoding long URLs to short ones and decoding them back. # Problem Statement Write a class `UrlShortener` with methods `encode` and `decode` to shorten URLs and retrieve the original URLs respectively. - `encode(long_url: str) -> str`: This method should take a long URL and return a short URL. - `decode(short_url: str) -> str`: This method should take a short URL and return the original long URL. Input * `long_url` (String): The original long URL to be shortened. * `short_url` (String): The shortened URL to be decoded back to the original long URL. Output * For `encode(long_url: str) -> str`: A shortened URL string. * For `decode(short_url: str) -> str`: The original long URL string. Function Signature ```python class UrlShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass ``` Constraints * All URLs will be strings of length between 1 and 10,000. * URL strings will be alphanumeric and may contain special characters like `.`, `/`, `?`, `=`, and `&`. * There should not be any loss of data; the short URL must be uniquely mapped to the original URL. * Assume the service can handle up to 10,000 URLs. Example ```python url_shortener = UrlShortener() # Encode URLs short_url_1 = url_shortener.encode(\\"https://www.example.com/page1\\") short_url_2 = url_shortener.encode(\\"https://www.example.com/page2\\") # Decode URLs assert url_shortener.decode(short_url_1) == \\"https://www.example.com/page1\\" assert url_shortener.decode(short_url_2) == \\"https://www.example.com/page2\\" ``` Note Ensure URLs are uniquely encoded and decoded, handle edge cases, and make use of a suitable hashing or encoding strategy. Document any assumptions made.","solution":"import hashlib class UrlShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" def encode(self, long_url: str) -> str: # Generate a unique short code using hashing hash_object = hashlib.md5(long_url.encode()) short_code = hash_object.hexdigest()[:6] # Take first 6 characters of the hash for the short URL if short_code not in self.code_to_url: self.url_to_code[long_url] = short_code self.code_to_url[short_code] = long_url return self.base_url + short_code def decode(self, short_url: str) -> str: # Extract the short code from the URL short_code = short_url.split(\\"/\\")[-1] if short_code in self.code_to_url: return self.code_to_url[short_code] else: return None"},{"question":"# Programming Question: Implement a Custom Deque You are tasked with implementing a custom deque (double-ended queue) that supports insertion and removal of elements from both ends in O(1) time. Your deque should handle operations efficiently and correctly for various types of elements, such as integers, floats, strings, and other comparable data structures. **Class Signature:** ```python class CustomDeque: def __init__(self): Initializes an empty deque. def append(self, item) -> None: Adds an item to the right end of the deque. :param item: The element to be added to the deque (integers, floats, strings, etc.). def appendleft(self, item) -> None: Adds an item to the left end of the deque. :param item: The element to be added to the deque (integers, floats, strings, etc.). def pop(self): Removes and returns the item from the right end of the deque. :return: The removed element. :raises IndexError: If the deque is empty. def popleft(self): Removes and returns the item from the left end of the deque. :return: The removed element. :raises IndexError: If the deque is empty. def peek(self): Returns the item at the right end of the deque without removing it. :return: The item at the right end. :raises IndexError: If the deque is empty. def peekleft(self): Returns the item at the left end of the deque without removing it. :return: The item at the left end. :raises IndexError: If the deque is empty. def __len__(self): Returns the number of items in the deque. :return: The size of the deque. def is_empty(self) -> bool: Checks if the deque is empty. :return: True if the deque is empty, False otherwise. ``` # Constraints * Input item types: integers, floats, strings, and other comparable data structures. * No fixed constraints on the number of elements; support typical use cases efficiently. # Requirements * All operations must complete in O(1) time complexity. * Handle edge cases such as an empty deque appropriately. * Ensure proper maintenance of internal data structure integrity and consistency. # Input & Output Examples 1. **Example 1:** ```python d = CustomDeque() d.append(1) d.append(2) d.appendleft(0) print(d.pop()) # Output: 2 print(d.popleft()) # Output: 0 print(len(d)) # Output: 1 ``` 2. **Example 2:** ```python d = CustomDeque() d.append(\'apple\') d.append(\'banana\') d.appendleft(\'orange\') print(d.peek()) # Output: \'banana\' print(d.peekleft()) # Output: \'orange\' print(d.is_empty()) # Output: False d.pop() d.pop() d.pop() print(d.is_empty()) # Output: True ``` 3. **Example 3:** ```python d = CustomDeque() d.append(3.14) d.append(2.71) d.appendleft(1.61) print(d.peekleft()) # Output: 1.61 d.popleft() print(d.peek()) # Output: 2.71 ``` # Additional Notes * Ensure your implementation is well-tested and able to maintain O(1) performance for all operations. * Use appropriate data structures to uphold performance guarantees and manage internal details efficiently.","solution":"class CustomDeque: def __init__(self): Initializes an empty deque. self._deque = [] def append(self, item) -> None: Adds an item to the right end of the deque. :param item: The element to be added to the deque. self._deque.append(item) def appendleft(self, item) -> None: Adds an item to the left end of the deque. :param item: The element to be added to the deque. self._deque.insert(0, item) def pop(self): Removes and returns the item from the right end of the deque. :return: The removed element. :raises IndexError: If the deque is empty. if self.is_empty(): raise IndexError(\\"pop from an empty deque\\") return self._deque.pop() def popleft(self): Removes and returns the item from the left end of the deque. :return: The removed element. :raises IndexError: If the deque is empty. if self.is_empty(): raise IndexError(\\"pop from an empty deque\\") return self._deque.pop(0) def peek(self): Returns the item at the right end of the deque without removing it. :return: The item at the right end. :raises IndexError: If the deque is empty. if self.is_empty(): raise IndexError(\\"peek from an empty deque\\") return self._deque[-1] def peekleft(self): Returns the item at the left end of the deque without removing it. :return: The item at the left end. :raises IndexError: If the deque is empty. if self.is_empty(): raise IndexError(\\"peek from an empty deque\\") return self._deque[0] def __len__(self): Returns the number of items in the deque. :return: The size of the deque. return len(self._deque) def is_empty(self) -> bool: Checks if the deque is empty. :return: True if the deque is empty, False otherwise. return len(self._deque) == 0"},{"question":"# String Pattern Finder Strings can often contain repeated patterns. For example, in the string `abab`, the pattern `ab` is repeated twice. Write a function to determine if a given string has a repeating pattern, and if so, return the shortest pattern. Function Signature ```python def find_repeating_pattern(s: str) -> str: pass ``` Input * `s` (str): A string that needs to be checked for a repeating pattern. The string length will be in the range of 1 to 1000 characters. Output * Returns the shortest repeating pattern if found, else returns an empty string. Constraints * The input string will contain only lowercase English letters (\'a\' to \'z\'). Example ```python # Example 1: input: \\"abab\\" output: \\"ab\\" # Example 2: input: \\"aaaa\\" output: \\"a\\" # Example 3: input: \\"abcabcabcabc\\" output: \\"abc\\" # Example 4: input: \\"abcdef\\" output: \\"\\" # Example 5: input: \\"xyzxyz\\" output: \\"xyz\\" ``` Notes * Ensure your function is efficient, especially for larger strings. * If there is no repeating pattern, return an empty string.","solution":"def find_repeating_pattern(s: str) -> str: Determines if a given string has a repeating pattern and returns the shortest pattern. If no repeating pattern is found, returns an empty string. # Iterate over possible lengths of the repeating pattern for i in range(1, len(s) // 2 + 1): if len(s) % i == 0: # Repeat the candidate pattern (substring) to match the length of the original string repeated_pattern = s[:i] * (len(s) // i) if repeated_pattern == s: return s[:i] return \\"\\""},{"question":"# Isogram Determination # Background An isogram (also known as a \\"non-pattern word\\") is a word or phrase without a repeating letter, meaning each letter appears exactly once. Determining whether a given word is an isogram can help in various word game applications, where uniqueness of characters can be essential. # Problem Write a function `is_isogram(s: str) -> bool` that checks if a given string is an isogram. # Inputs - `s`: A string consisting of only alphabetic characters and may include both uppercase and lowercase letters. # Outputs - A boolean value. Return `True` if the string is an isogram, otherwise return `False`. # Constraints - The string `s` may include mixed-case letters but the function should treat letters as case-insensitive. For example, \'A\' and \'a\' should be considered the same character. - The input string will have a length between 1 and 100 characters. # Examples ```python assert is_isogram(\\"Dermatoglyphics\\") == True assert is_isogram(\\"isogram\\") == True assert is_isogram(\\"aba\\") == False assert is_isogram(\\"moOse\\") == False assert is_isogram(\\"thumbscrew-japingly\\") == True ``` **Your task** is to implement the `is_isogram` function to correctly identify whether the provided string `s` meets the isogram condition. Make sure to appropriately handle the case sensitivity and validate the input as per the rules described.","solution":"def is_isogram(s: str) -> bool: Determines if a given string is an isogram. Args: s: A string consisting of only alphabetic characters and may include both uppercase and lowercase letters. Returns: bool: True if the string is an isogram, otherwise False. s = s.lower() return len(s) == len(set(s))"},{"question":"# Real-Time Moving Average Filter Implementation In signal processing, smoothing an incoming data stream is a common task, especially when working with sensor data. A moving average filter is one of the simplest and most commonly used digital filters. You are tasked with implementing a real-time moving average filter that processes an incoming stream of sensor data. Task Description: Implement a class `MovingAverageFilter` that: - Takes as input upon initialization: * `window_size` (int): The number of data points to consider for the moving average. - Implements the following method: * `add_data_point(data_point: float) -> float`: Takes a new data point, updates the sliding window, and returns the current moving average. Constraints: - The `window_size` will always be a positive integer. - You must manage the window efficiently to ensure that the oldest data points are discarded as new ones come in. - Ensure the class can handle a varying number of data points provided in real-time. Example Usage: ```python >>> filter = MovingAverageFilter(window_size=5) >>> filter.add_data_point(10) 10.0 >>> filter.add_data_point(20) 15.0 >>> filter.add_data_point(30) 20.0 >>> filter.add_data_point(40) 25.0 >>> filter.add_data_point(50) 30.0 >>> filter.add_data_point(60) 40.0 >>> filter.add_data_point(70) 50.0 ``` Here\'s an example of how you could implement the class: ```python class MovingAverageFilter: def __init__(self, window_size): self.window_size = window_size self.data_window = [] def add_data_point(self, data_point): self.data_window.append(data_point) if len(self.data_window) > self.window_size: self.data_window.pop(0) return sum(self.data_window) / len(self.data_window) ``` Implement the `MovingAverageFilter` class as described, ensuring it handles various edge cases and operates efficiently for real-time data streams.","solution":"class MovingAverageFilter: def __init__(self, window_size): self.window_size = window_size self.data_window = [] def add_data_point(self, data_point): self.data_window.append(data_point) if len(self.data_window) > self.window_size: self.data_window.pop(0) return sum(self.data_window) / len(self.data_window)"},{"question":"# Question You are tasked with developing a function that simulates a simplified version of the binary addition operation between two binary strings. Both binary strings will be non-negative and without a \\"0b\\" prefix. The function should return the resulting binary string, also without the \\"0b\\" prefix. Function Signature ```python def binary_addition(bin1: str, bin2: str) -> str: ... ``` Input - **bin1** (str): the first binary string to be added. It will contain only characters \'0\' and \'1\'. - **bin2** (str): the second binary string to be added. It will contain only characters \'0\' and \'1\'. Output - (str): the resulting binary string from adding bin1 and bin2. Constraints - The output length will not exceed 1000 characters. Performance Requirement - Implement in (O(n)) time complexity where (n) is the length of the longer input string. Examples ```python >>> binary_addition(\'1010\', \'1011\') \'10101\' >>> binary_addition(\'110\', \'1010\') \'10000\' >>> binary_addition(\'111\', \'1\') \'1000\' ```","solution":"def binary_addition(bin1: str, bin2: str) -> str: Returns the binary sum of two binary strings. max_len = max(len(bin1), len(bin2)) # Padding the shorter string with zeros bin1 = bin1.zfill(max_len) bin2 = bin2.zfill(max_len) carry = 0 result = [] # Add the binary numbers from right to left for i in range(max_len - 1, -1, -1): digit_sum = carry digit_sum += int(bin1[i]) digit_sum += int(bin2[i]) result.append(str(digit_sum % 2)) # current (result) digit carry = digit_sum // 2 # carry to the next digit if carry: result.append(\'1\') result.reverse() return \'\'.join(result)"},{"question":"# Problem Description Write a function `count_unique_sublists` that takes a list of integers and a positive integer ( k ), and returns the number of unique sublists of length ( k ). A sublist is a contiguous subset of the list. # Function Signature ```python def count_unique_sublists(arr: list[int], k: int) -> int: ``` # Input * `arr` (list of int): List of integers. ( 1 leq text{len(arr)} leq 10^5 ) * `k` (int): Length of the sublists. ( 1 leq k leq text{len(arr)} ) # Output * (int): The number of unique sublists of length ( k ). # Constraints * Your solution should be efficient and account for potentially large input sizes. # Examples ```python >>> count_unique_sublists([1, 2, 3, 2, 1, 2], 2) 4 >>> count_unique_sublists([1, 2, 2, 2, 3], 3) 3 >>> count_unique_sublists([1, 1, 1, 1], 1) 1 ``` # Notes * The sublists [1, 2] and [2, 1] are considered different sublists. * Ensure that your solution handles edge cases such as when all elements in the list are the same. * Consider using sets to facilitate finding unique sublists efficiently.","solution":"def count_unique_sublists(arr: list[int], k: int) -> int: Returns the number of unique sublists of length k in the given list of integers. if k > len(arr): return 0 unique_sublists = set() for i in range(len(arr) - k + 1): sublist = tuple(arr[i:i+k]) unique_sublists.add(sublist) return len(unique_sublists)"},{"question":"# Challenging Coding Assessment Question Context Sorting algorithms are fundamental in computer science and have various levels of complexity and efficiency. Today’s challenge focuses on implementing a sophisticated sorting algorithm that handles large datasets efficiently while providing stable output. Task Implement a function `merge_sort(arr: List[int]) -> List[int]` that sorts a list of integers using the Merge Sort algorithm. Your implementation should adhere to the principles of stability and divide-and-conquer methodology inherent to Merge Sort. Input and Output Formats: ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: pass # Example usage: print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([5, 3, 8, 6, 2, 7, 4, 1])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Constraints: * The input list will have length `0 <= len(arr) <= 10^5`. * The list elements `arr[i]` will be integers within the range `-10^9 <= arr[i] <= 10^9`. Requirements: 1. **Merge Sort Implementation:** Develop an in-depth merge sort that respects the intrinsic properties of the algorithm. 2. **Stability:** Ensure the sorting algorithm maintains the relative order of equal elements (stability). 3. **Split and Merge Methodology:** Properly implement the divide (split) and conquer (merge) steps to guarantee efficiency and accuracy. 4. **Scalability:** Optimize to handle the upper limits of input size and range effectively. Performance Goals: * Target a time complexity of O(n log n) in all cases, making sure to handle best, average, and worst scenarios with optimal performance. * Manage space to ensure it remains within practical bounds, given the recursive nature of the merge sort algorithm. Implement the `merge_sort` function, ensuring it adheres to the above specifications and performs reliably for all given constraints.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Scenario: You are developing a software system for a library that helps in managing book loans and returns. One of the functionalities required is to track whether a series of books can be returned in the same order as they were borrowed. This helps the library staff ensure that books are returned sequentially and maintain proper order. # Problem Description: Implement a function `can_return_books` that takes two lists as inputs: `borrowed` and `returned`. The function should return `True` if the books can be returned in the same sequence as they were borrowed, otherwise return `False`. Both lists contain book IDs and are of the same length. # Function Signature: `def can_return_books(borrowed: List[int], returned: List[int]) -> bool:` # Input: - `borrowed`: A list of integers representing the order of books borrowed. - `returned`: A list of integers representing the order of books returned. # Output: - Returns a boolean value: `True` if the books can be returned in the same order as they were borrowed, otherwise `False`. # Constraints: - 1 <= len(borrowed) <= 1000 - The elements in `borrowed` and `returned` are unique integers representing book IDs. - Both lists have the same length. # Example: ```python print(can_return_books([1, 2, 3], [1, 2, 3])) # Output: True print(can_return_books([1, 2, 3], [3, 2, 1])) # Output: False print(can_return_books([4, 5, 6], [4, 6, 5])) # Output: False print(can_return_books([10, 20, 30], [10, 30, 20])) # Output: False ``` # Notes: - The function should only return `True` if the order of books returned exactly matches the order in which they were borrowed. - Consider edge cases such as empty lists or a single book in the list.","solution":"def can_return_books(borrowed, returned): Checks if the books can be returned in the same order as they were borrowed. :param borrowed: List of integers representing the order of borrowed books. :param returned: List of integers representing the order of returned books. :return: True if books can be returned in the same order, otherwise False. return borrowed == returned"},{"question":"# Coding Question You are required to develop an algorithm to identify all the strongly connected components (SCCs) in a directed graph. Your implementation should utilize Tarjan\'s algorithm, which is optimal for this task in terms of complexity and performance. # Problem Statement Write a Python function `tarjan_scc` that finds all the strongly connected components in a given directed graph using Tarjan\'s algorithm. # Function Signature ```python def tarjan_scc(graph): Identify all the strongly connected components in a given directed graph using Tarjan\'s algorithm. Arguments: graph -- A dictionary representing the directed graph. Keys are node identifiers, and values are lists of destination nodes. Returns: A list of lists, where each inner list contains the nodes that form a strongly connected component. pass ``` # Input & Output * **Input**: - `graph`: A dictionary where keys are integers representing node identifiers, and values are lists of integers representing the destination nodes of directed edges. * **Output**: - A list of lists. Each inner list represents a strongly connected component, containing all the node identifiers in that component. # Constraints - The graph can have up to 1000 nodes. - Each node identifier is an integer within the range [0, 999]. - The graph is represented as a directed graph with directed edges. # Example Consider the following directed graph represented by the adjacency list: ```python graph = { 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] } sccs = tarjan_scc(graph) print(sccs) # Expected output could be [[0, 2, 1], [4, 5, 3]] or similar, depending on the order of node processing ```","solution":"def tarjan_scc(graph): Identify all the strongly connected components in a given directed graph using Tarjan\'s algorithm. Arguments: graph -- A dictionary representing the directed graph. Keys are node identifiers, and values are lists of destination nodes. Returns: A list of lists, where each inner list contains the nodes that form a strongly connected component. index = 0 stack = [] indices = {} lowlink = {} on_stack = set() sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif neighbor in on_stack: lowlink[node] = min(lowlink[node], indices[neighbor]) if lowlink[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"# Network Delay Time Given a network of nodes represented by a graph and a list of travel times as directed edges, you need to calculate the time it will take for a signal to travel from a given starting node to all other nodes. # Function Specifications Your task is to implement a function `network_delay_time` that takes in the following parameters: - `times: List[Tuple[int, int, int]]`: A list of tuples where each tuple `(u, v, w)` represents a directed edge from node `u` to node `v` with travel time `w`. - `n: int`: The total number of nodes in the network, labeled from 1 to `n`. - `k: int`: The starting node from which the signal is sent. The function should return an integer representing the amount of time it will take for the signal to reach all nodes. If it is impossible to reach all nodes, return `-1`. # Constraints * The number of nodes `n` will be in the range `[1, 100]`. * The number of edges will be in the range `[1, 6000]`. * All travel times `w` will be positive integers. # Example ```python def network_delay_time(times: List[Tuple[int, int, int]], n: int, k: int) -> int: import heapq # Build the graph graph = [[] for _ in range(n)] for u, v, w in times: graph[u-1].append((v-1, w)) # Use Dijkstra\'s algorithm to find the shortest path min_heap = [(0, k-1)] min_time = {i: float(\'inf\') for i in range(n)} min_time[k-1] = 0 while min_heap: cur_time, u = heapq.heappop(min_heap) for v, w in graph[u]: time = cur_time + w if time < min_time[v]: min_time[v] = time heapq.heappush(min_heap, (time, v)) max_time = max(min_time.values()) return max_time if max_time < float(\'inf\') else -1 # Example usage: times = [(2, 1, 1), (2, 3, 1), (3, 4, 1)] n = 4 k = 2 assert network_delay_time(times, n, k) == 2 times = [(1, 2, 1)] n = 2 k = 1 assert network_delay_time(times, n, k) == 1 times = [(1, 2, 1)] n = 2 k = 2 assert network_delay_time(times, n, k) == -1 ``` # Notes Ensure that your implementation efficiently handles the constraints and edge cases, particularly concerning the range and density of edges.","solution":"from typing import List, Tuple import heapq def network_delay_time(times: List[Tuple[int, int, int]], n: int, k: int) -> int: # Build the graph graph = [[] for _ in range(n)] for u, v, w in times: graph[u - 1].append((v - 1, w)) # Use Dijkstra\'s algorithm to find the shortest path min_heap = [(0, k - 1)] # (distance, node) min_time = {i: float(\'inf\') for i in range(n)} min_time[k - 1] = 0 while min_heap: cur_time, u = heapq.heappop(min_heap) for v, w in graph[u]: time = cur_time + w if time < min_time[v]: min_time[v] = time heapq.heappush(min_heap, (time, v)) max_time = max(min_time.values()) return max_time if max_time < float(\'inf\') else -1 # Example usage and test cases: times = [(2, 1, 1), (2, 3, 1), (3, 4, 1)] n = 4 k = 2 result = network_delay_time(times, n, k) print(result) # Expected output: 2"},{"question":"# Binary Search Tree Operations Objective Given a list of integers, construct a Binary Search Tree (BST) and implement basic operations that allow insertion, search, and finding the minimum and maximum values in the BST. Additionally, provide an analysis of the BST\'s performance and discuss the potential impact of tree balancing. Task 1. **BST Class Implementation**: Implement a `BinarySearchTree` class with methods for insertion, search, and finding minimum and maximum values. 2. **Performance Analysis**: Write a brief analysis (approximately 200 words) discussing the expected time and space complexity of your implementation. Explain how the tree\'s balance affects performance and suggest balancing techniques. Function Signature ```python class BinarySearchTree: def __init__(self): Initializes an empty BST. pass def insert(self, value: int) -> None: Inserts a value into the BST. :param value: The integer value to be inserted. pass def search(self, value: int) -> bool: Searches for a value in the BST. :param value: The integer value to search for. :return: True if the value is found, False otherwise. pass def find_min(self) -> int: Finds the minimum value in the BST. :return: The minimum integer value in the BST. pass def find_max(self) -> int: Finds the maximum value in the BST. :return: The maximum integer value in the BST. pass ``` Input Format * A sequence of integer insertions, searches, and queries for minimum and maximum values. Output Format * Results from search operations as boolean values, and min/max operations as integers. Constraints * Insertions will be non-duplicate integer values. * The BST will contain at most 1000 elements. * Values in insertions range from -10^6 to 10^6. Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(8) bst.insert(2) bst.insert(4) bst.insert(7) bst.insert(9) assert bst.search(4) == True assert bst.search(6) == False assert bst.find_min() == 2 assert bst.find_max() == 9 ``` Analysis Evaluate the implementation in terms of: * **Average and Worst-case Time Complexity**: Explain the average time complexity of O(log n) for balanced trees and O(n) for skewed trees. * **Space Complexity**: Justify the O(n) space complexity due to node storage. * **Balancing Techniques**: Discuss how tree balancing techniques such as AVL or Red-Black trees improve performance. Highlight situations where balancing is crucial for maintaining efficient operations. Notes * Ensure edge cases are considered, like inserting into an empty tree or operating on a single-node tree. * Provide docstrings and comments to explain the logic behind your implementation.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: Node, value: int) -> None: if value < node.value: if not node.left: node.left = Node(value) else: self._insert_recursive(node.left, value) else: # value > node.value if not node.right: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: Node, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: # value > node.value return self._search_recursive(node.right, value) def find_min(self) -> int: current_node = self.root while current_node and current_node.left: current_node = current_node.left return current_node.value if current_node else None def find_max(self) -> int: current_node = self.root while current_node and current_node.right: current_node = current_node.right return current_node.value if current_node else None"},{"question":"# Problem Statement Context You are writing a function to compute the longest sequence of identical characters in a given string. The function should return both the character and the length of this sequence. If there are multiple sequences with the same length, return the first occurring one. Function Signature ```python def longest_sequence(s: str) -> tuple[str, int]: ``` Input 1. `s (str)`: The input string containing any characters. Output * Returns a `tuple[str, int]` where the first element is the character and the second element is the length of the longest sequence of identical characters. If the input string is empty, return an empty string and zero. Constraints * The function should handle edge cases such as an empty string or string with a single character. * The function should work efficiently for strings up to length 1000. Examples ```python >>> longest_sequence(\\"aaabbbaaaccc\\") (\'a\', 3) >>> longest_sequence(\\"abcd\\") (\'a\', 1) >>> longest_sequence(\\"aabbccdd\\") (\'a\', 2) >>> longest_sequence(\\"\\") (\'\', 0) >>> longest_sequence(\\"aaaa\\") (\'a\', 4) ``` Additional Requirements: 1. Iterate through the string to keep track of the longest sequence and ensure the function handles edge cases gracefully. 2. If there are multiple longest sequences, ensure the function returns the first occurring one.","solution":"def longest_sequence(s: str) -> tuple[str, int]: Returns a tuple containing the character with the longest sequence in the string and the length of that sequence. If the string is empty, return an empty string and zero. if not s: return (\\"\\", 0) max_char = s[0] max_length = 1 current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: if current_length > max_length: max_char = current_char max_length = current_length current_char = char current_length = 1 # final check at the end of the loop if current_length > max_length: max_char = current_char max_length = current_length return (max_char, max_length)"},{"question":"# Problem Statement Fibonacci Sequence is one of the most well-known sequences in mathematics. In this task, you will extend the Fibonacci sequence to create a modified version, where each term is the sum of the previous three terms. This new sequence is known as the Tribonacci Sequence. Task Write a function `tribonacci` that computes the first `n` terms of the Tribonacci sequence given the first three terms. Function Signature ```python def tribonacci(first: int, second: int, third: int, n: int) -> List[int]: ``` Input * `first` (int): The first term of the Tribonacci sequence. * `second` (int): The second term of the Tribonacci sequence. * `third` (int): The third term of the Tribonacci sequence. * `n` (int): The number of terms to be computed. Must be greater than 0. Output * Returns a list of integers representing the first `n` terms of the Tribonacci sequence. Constraints * If `n` is less than or equal to 0, raise a `ValueError` with the message \\"Impossible sequence length\\". Performance Requirements * The function should run efficiently with a time complexity of O(n). * Ensure validation checks are in place and handle error scenarios accordingly. Example Usage ```python >>> tribonacci(1, 1, 2, 6) [1, 1, 2, 4, 7, 13] >>> tribonacci(0, 0, 1, 5) [0, 0, 1, 1, 2] >>> tribonacci(1, 2, 3, 1) [1] >>> tribonacci(1, 2, 3, 0) Traceback (most recent call last): ... ValueError: Impossible sequence length ``` Notes - The Tribonacci sequence is similar to the Fibonacci sequence but starts with three specified terms, with each subsequent term being the sum of the previous three. - Ensure your function provides correct results and handles all edge cases effectively.","solution":"from typing import List def tribonacci(first: int, second: int, third: int, n: int) -> List[int]: Computes the first n terms of the Tribonacci sequence given the first three terms. Arguments: first -- the first term in the Tribonacci sequence. second -- the second term in the Tribonacci sequence. third -- the third term in the Tribonacci sequence. n -- the number of terms to be computed. Returns: A list of integers representing the first n terms of the Tribonacci sequence. Raises: ValueError: If n is less than or equal to 0. if n <= 0: raise ValueError(\\"Impossible sequence length\\") if n == 1: return [first] if n == 2: return [first, second] if n == 3: return [first, second, third] sequence = [first, second, third] for i in range(3, n): next_term = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_term) return sequence"},{"question":"# Number of Distinct Elements in Sliding Window **Context**: Analyzing the number of distinct elements within specific parts of a dataset is a common requirement in many real-time data processing scenarios. # Problem Statement Write a function `distinct_elements_in_window(arr: list[int], k: int) -> list[int]` that computes the number of distinct elements in every sliding window of size `k` across the list `arr`. # Input and Output Format **Input**: 1. `arr` (list of int): The list of integers to analyze. 2. `k` (int): The size of the sliding window. **Output**: - Returns a `list[int]` where each element is the number of distinct elements within a corresponding sliding window of size `k`. # Constraints: - `1 <= len(arr) <= 10^5` - `1 <= k <= len(arr)` # Example Input: ```python arr = [1, 2, 1, 3, 4, 2, 3] k = 4 ``` Output: ```python [3, 4, 4, 3] ``` # Explanation: - The first window is `[1, 2, 1, 3]`, which has 3 distinct elements: {1, 2, 3} - The second window is `[2, 1, 3, 4]`, which has 4 distinct elements: {1, 2, 3, 4} - The third window is `[1, 3, 4, 2]`, which has 4 distinct elements: {1, 2, 3, 4} - The fourth window is `[3, 4, 2, 3]`, which has 3 distinct elements: {2, 3, 4} # Edge Cases to Consider - The array has all identical elements. - The window size `k` is 1. - The window size `k` is equal to the length of the array. # Additional Instructions Ensure the function is efficient, leveraging appropriate data structures to maintain and update the count of distinct elements as the window slides. Consider the performance given the constraint on the maximum size of the array. This new question focuses on algorithmic challenges similar to managing prefixes, emphasizing operational efficiency and correct handling of dynamic data within a specified scope, aligning well with the existing problem\'s metrics and structure.","solution":"from collections import defaultdict def distinct_elements_in_window(arr, k): Returns a list of counts of distinct elements in every sliding window of size k in an array. Parameters: arr (list): The input array of integers. k (int): The size of the sliding window. Returns: list: A list of integers representing the number of distinct elements in each window. if not arr or k == 0: return [] n = len(arr) if k > n: return [] result = [] freq = defaultdict(int) distinct_count = 0 # Initialize the frequency dictionary for the first window for i in range(k): if freq[arr[i]] == 0: distinct_count += 1 freq[arr[i]] += 1 result.append(distinct_count) # Slide the window for i in range(k, n): old_elem = arr[i - k] freq[old_elem] -= 1 if freq[old_elem] == 0: distinct_count -= 1 new_elem = arr[i] if freq[new_elem] == 0: distinct_count += 1 freq[new_elem] += 1 result.append(distinct_count) return result"},{"question":"Question: Next Greater Element Using Stack You are provided with a list of integers. You need to find the next greater element for each element in the list. The next greater element for an element x is the first greater element that comes after x in the list. If there isn\'t any, then the next greater element is -1. Your task is to implement this functionality using a stack for efficient processing. 1. **Function Implementation**: - `next_greater_element(nums: List[int]) -> List[int]`: Compute the next greater element for each element in the input list. 2. **Input and Output Formats**: - Input: A list of integers `nums` where `1 <= len(nums) <= 10^5` and `-10^9 <= nums[i] <= 10^9`. - Output: A list of integers where each element is the next greater element of the corresponding element in the input list or -1 if no greater element exists. 3. **Constraints**: - Efficiently find the next greater elements using a stack. - Handle large input sizes within reasonable time complexity. 4. **Example**: ```python print(next_greater_element([4, 5, 2, 25])) # Output: [5, 25, 25, -1] print(next_greater_element([13, 7, 6, 12])) # Output: [-1, 12, 12, -1] print(next_greater_element([11, 13, 21, 3])) # Output: [13, 21, -1, -1] print(next_greater_element([1, 3, 2, 4])) # Output: [3, 4, 4, -1] ``` 5. **Edge Cases**: - If the list has only one element, the next greater element is always -1. - Ensure that the function handles both positive and negative numbers correctly. # Requirements Your implementation will be evaluated based on: - Correctness of the computed result. - Efficiency in handling large inputs using a stack. - Proper handling of edge cases. # Submission Submit your implementation of the `next_greater_element` function. Ensure to include edge case handling and consider the performance requirements specified.","solution":"from typing import List def next_greater_element(nums: List[int]) -> List[int]: Finds the next greater element for each element in the list. Uses a stack to efficiently process elements. n = len(nums) result = [-1] * n stack = [] for i in range(n): # Maintain elements in decreasing order in the stack while stack and nums[i] > nums[stack[-1]]: result[stack.pop()] = nums[i] stack.append(i) return result"},{"question":"# Problem Statement In many programming scenarios, you\'re required to provide auto-suggestions based on a given set of words. You\'re tasked with building a feature that returns the top `k` words from a list of words based on a given prefix and their frequency of occurrence. # Function Signature ```python def top_k_suggestions(words: List[str], prefix: str, k: int) -> List[str]: pass ``` # Input - **words**: `List[str]` - A list of words. - **prefix**: `str` - The prefix to search for. - **k**: `int` - The number of top suggestions to return. # Output - `List[str]` - A list of the top `k` words that start with the given prefix, sorted primarily by frequency (high to low) and secondarily in alphabetical order. # Constraints - 1 <= len(words) <= 10^5 - 1 <= len(prefix) <= 100 - 1 <= k <= 100 - Each word in `words` has a length of at most 100. - Words are case-insensitive and should be treated as lower-case. # Example ```python words = [ \\"apple\\", \\"appetite\\", \\"application\\", \\"app\\", \\"apply\\", \\"appoint\\", \\"banana\\", \\"band\\", \\"bandana\\", \\"bandage\\", \\"apple\\", \\"application\\", \\"banana\\", \\"bandage\\", \\"bandana\\", \\"ban\\", \\"app\\", \\"apple\\", \\"banana\\" ] prefix = \\"app\\" k = 3 print(top_k_suggestions(words, prefix, k)) ``` Expected Output: ``` [\'apple\', \'app\', \'application\'] ``` # Explanation In this example, the word \\"apple\\" appears 3 times, \\"app\\" 2 times, and \\"application\\" 2 times. These words start with the prefix \\"app\\" and are the most frequent ones to appear. Hence, they are included in the result. # Instructions 1. Implement a function to count the frequency of each word. 2. Filter the words that start with the given prefix. 3. Sort the filtered words based on their frequency and alphabetically where frequencies are tied. 4. Return the top `k` words according to the sorted order. 5. Handle edge cases such as no words matching the prefix or `k` being larger than the number of suggestions available.","solution":"from typing import List from collections import Counter def top_k_suggestions(words: List[str], prefix: str, k: int) -> List[str]: # Convert all words to lower case to handle case insensitivity words = [word.lower() for word in words] prefix = prefix.lower() # Count frequency of each word word_count = Counter(words) # Filter words that start with the given prefix filtered_words = [word for word in word_count if word.startswith(prefix)] # Sort filtered words first by frequency in descending order, then alphabetically sorted_words = sorted(filtered_words, key=lambda word: (-word_count[word], word)) # Return top k words return sorted_words[:k]"},{"question":"# Sorting Custom Object Lists You are provided with a predefined class `Person` that represents an individual with attributes: `name`, `age`, and `city`. You need to implement a function to sort a list of `Person` objects based on multiple attributes. Objective: Your task is to implement a function `sort_person_list()` which sorts a list of `Person` objects first by `age` (ascending), and for individuals with the same age, sort by `name` (alphabetically). # Specifications: - **Function Name**: sort_person_list - **Input**: - `persons`: a list of `Person` objects. - **Output**: A list of `Person` objects sorted first by `age` in ascending order, and then by `name` in alphabetical order. # Constraints: - The `persons` list can have zero or more `Person` objects. - All `age` values are non-negative integers. - The `name` attribute is a non-empty string. # Example: ```python class Person: def __init__(self, name, age, city): self.name = name self.age = age self.city = city # Example List persons = [ Person(\\"John\\", 30, \\"New York\\"), Person(\\"Jane\\", 25, \\"Los Angeles\\"), Person(\\"Alice\\", 25, \\"Chicago\\"), Person(\\"Bob\\", 30, \\"San Francisco\\") ] sorted_persons = sort_person_list(persons) for person in sorted_persons: print(f\\"{person.name}, {person.age}, {person.city}\\") # Expected Output: # Alice, 25, Chicago # Jane, 25, Los Angeles # Bob, 30, San Francisco # John, 30, New York ``` # Steps: 1. Implement `sort_person_list()` to sort the provided list using the specified criteria. 2. Iterate over the sorted list and ensure the output adheres to the sorting rules specified. # Edge Cases to Consider: - Empty list of `Person` objects. - List with `Person` objects having the same age but different names. - Mixed order of input list.","solution":"class Person: def __init__(self, name, age, city): self.name = name self.age = age self.city = city def sort_person_list(persons): Sorts a list of Person objects first by age in ascending order, and if ages are the same then by name in alphabetical order. Args: persons (list of Person): List of Person objects to be sorted. Returns: list of Person: Sorted list of Person objects. return sorted(persons, key=lambda person: (person.age, person.name))"},{"question":"Implement a Thread-Safe Bounded Blocking Queue In this exercise, you are required to design and implement a thread-safe bounded blocking queue. A bounded blocking queue is a data structure that holds a fixed number of elements and supports concurrent access. When the queue is full, any thread that tries to enqueue a new element will be blocked until space becomes available. Similarly, if the queue is empty, any thread that tries to dequeue an element will be blocked until an element is available. Detailed Specifications 1. You need to implement the `BoundedBlockingQueue` class with the following methods: ```python import threading class BoundedBlockingQueue: def __init__(self, capacity: int): # Initialize the queue with the given capacity self.queue = [] self.capacity = capacity self.lock = threading.Lock() self.not_full = threading.Condition(self.lock) self.not_empty = threading.Condition(self.lock) def enqueue(self, element: int) -> None: # Insert an element into the queue, blocking if the queue is full with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: # Remove and return the element from the queue, blocking if the queue is empty with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: # Return the current number of elements in the queue with self.lock: return len(self.queue) ``` Input and Output Formats * **Input**: - `capacity` (integer): The maximum number of elements the queue can hold. - `enqueue(element)` (integer): Add the element to the queue if space is available, otherwise block until space is available. - `dequeue()` (): Remove and return the element from the queue if it is non-empty, otherwise block until an element is available. - `size()` (): Return the current number of elements in the queue. * **Output**: - The `enqueue` method should add the element to the queue or block until space is available. - The `dequeue` method should remove and return the next element from the queue or block until an element is available. - The `size` method should return the current number of elements in the queue. Example Usage ```python import threading def producer(queue, values): for val in values: queue.enqueue(val) print(f\\"Produced {val}\\") def consumer(queue, count): for _ in range(count): val = queue.dequeue() print(f\\"Consumed {val}\\") queue = BoundedBlockingQueue(2) producer_thread = threading.Thread(target=producer, args=(queue, [1, 2, 3, 4])) consumer_thread = threading.Thread(target=consumer, args=(queue, 4)) producer_thread.start() consumer_thread.start() producer_thread.join() consumer_thread.join() ``` Implement the `BoundedBlockingQueue` class to meet the specifications mentioned above.","solution":"import threading class BoundedBlockingQueue: def __init__(self, capacity: int): # Initialize the queue with the given capacity self.queue = [] self.capacity = capacity self.lock = threading.Lock() self.not_full = threading.Condition(self.lock) self.not_empty = threading.Condition(self.lock) def enqueue(self, element: int) -> None: # Insert an element into the queue, blocking if the queue is full with self.not_full: while len(self.queue) >= self.capacity: self.not_full.wait() self.queue.append(element) self.not_empty.notify() def dequeue(self) -> int: # Remove and return the element from the queue, blocking if the queue is empty with self.not_empty: while len(self.queue) == 0: self.not_empty.wait() element = self.queue.pop(0) self.not_full.notify() return element def size(self) -> int: # Return the current number of elements in the queue with self.lock: return len(self.queue)"},{"question":"# Coding Assessment Question Tree-Structure Generation and Analysis **Scenario:** Your company is developing a simulation tool to model various branching patterns found in nature, such as trees, river networks, and blood vessels. An essential feature of the tool is the ability to generate and visualize binary tree structures. **Task:** Create a function that generates a binary tree and provides various utility functions to visualize and analyze the generated tree structure. **Requirements:** 1. Implement the function `generate_binary_tree(depth: int) -> dict` that generates a binary tree of a specified depth. Each node in the tree should be represented as a dictionary with `left` and `right` children. 2. Ensure that your function can handle inputs with a high depth efficiently. 3. Provide utility functions to visualize the generated tree using a plotting library like `matplotlib` and to calculate its depth. **Implementation Details:** 1. **Input:** * `depth` (int): The maximum depth of the binary tree. 2. **Output:** * A dictionary representing the root of the binary tree. Each child node should also follow the same structure, creating a nested dictionary representation of the tree. 3. **Requirements:** * Your function should be optimized for scenarios where the `depth` can be significantly high (e.g., up to 10). * Provide a brief explanation of how your function achieves memory and computational efficiency. * Include a function for visualizing the tree structure, ensuring that the visualization is clearly laid out and easy to interpret. * Include a function `calculate_depth(tree: dict) -> int` that calculates the depth of the generated tree structure. **Constraints:** * The `depth` parameter will be a non-negative integer (0 <= depth <= 15). * You are encouraged to use memory-efficient data structures and algorithms. Here is a starter template to help you get started: ```python import matplotlib.pyplot as plt import networkx as nx def generate_binary_tree(depth: int) -> dict: def add_children(node: dict, current_depth: int, max_depth: int) -> None: if current_depth < max_depth: node[\'left\'] = {} node[\'right\'] = {} add_children(node[\'left\'], current_depth + 1, max_depth) add_children(node[\'right\'], current_depth + 1, max_depth) root = {} add_children(root, 0, depth) return root def plot_tree(tree: dict) -> None: G = nx.Graph() pos = {} def add_edges(node: dict, current_pos: tuple, depth: int) -> None: if \'left\' in node: left_pos = (current_pos[0] - 2 ** (-depth), current_pos[1] - 1) G.add_edge(current_pos, left_pos) pos[left_pos] = left_pos add_edges(node[\'left\'], left_pos, depth + 1) if \'right\' in node: right_pos = (current_pos[0] + 2 ** (-depth), current_pos[1] - 1) G.add_edge(current_pos, right_pos) pos[right_pos] = right_pos add_edges(node[\'right\'], right_pos, depth + 1) initial_pos = (0, 0) pos[initial_pos] = initial_pos add_edges(tree, initial_pos, 1) nx.draw(G, pos, with_labels=False, node_size=50) plt.show() def calculate_depth(tree: dict) -> int: if not tree: return 0 return 1 + max(calculate_depth(tree.get(\'left\', {})), calculate_depth(tree.get(\'right\', {}))) if __name__ == \\"__main__\\": # Example usage depth = 5 tree = generate_binary_tree(depth) print(f\\"Depth of tree: {calculate_depth(tree)}\\") plot_tree(tree) ``` Ensure the correctness of your implementation with several test cases and provide corresponding output visualizations.","solution":"def generate_binary_tree(depth: int) -> dict: Generate a binary tree of specified depth as a nested dictionary structure. def add_children(node: dict, current_depth: int, max_depth: int) -> None: if current_depth < max_depth: node[\'left\'] = {} node[\'right\'] = {} add_children(node[\'left\'], current_depth + 1, max_depth) add_children(node[\'right\'], current_depth + 1, max_depth) root = {} add_children(root, 0, depth) return root def calculate_depth(tree: dict) -> int: Calculate the depth of a binary tree represented as nested dictionaries. if not tree: return 0 left_depth = calculate_depth(tree.get(\'left\', {})) right_depth = calculate_depth(tree.get(\'right\', {})) return 1 + max(left_depth, right_depth) # Plotting is omitted for unit test purposes, but should be kept in a real implementation for visualization."},{"question":"**Objective**: Write a program that mimics the behavior of a moving average filter for processing a series of numerical data. **Scenario**: You are provided with a sequence of numerical data points that represent sensor readings over time. Implement a function `moving_average_filter` that calculates the moving average for a given window size. This filter smoothes the input data and helps in analyzing trends by averaging a subset of the data. **Guidelines**: - The function should validate the window size to ensure it is a positive integer and smaller than or equal to the length of the input data. - The output list should contain moving averages calculated for each possible position in the input sequence. - Handle cases where any incorrect data types are passed in for the input data or window size. - Your function should be efficient and capable of handling a large amount of data points. **Function Signature**: ```python def moving_average_filter(data: List[float], window_size: int) -> List[float]: ``` **Input Format**: - `data`: A list of floats representing the sensor readings. - `window_size`: An integer representing the number of data points to include in each average calculation. **Output Format**: - A list of floats representing the moving averages for each position in the data list. **Constraints**: - Data points should be non-negative. - Window size should be a positive integer. - Handle large datasets efficiently. **Examples**: ```python >>> moving_average_filter([1, 2, 3, 4, 5], 2) [1.5, 2.5, 3.5, 4.5] >>> moving_average_filter([10, 20, 30, 40, 50], 3) [20.0, 30.0, 40.0] ``` **Important Considerations**: - Ensure proper error handling and input validation. - The function should return a list with moving averages in the same order as the input data, calculated using the specified window size. - The length of the output list should be `len(data) - window_size + 1`. By creating this new question, we ensure the examination has a consistent style, length, and difficulty, while testing the candidate\'s ability to handle numerical data processing and error checking, similar to the provided examples.","solution":"from typing import List def moving_average_filter(data: List[float], window_size: int) -> List[float]: if not isinstance(data, list) or not all(isinstance(x, (int, float)) for x in data): raise ValueError(\\"Data should be a list of floats or integers.\\") if not isinstance(window_size, int) or window_size <= 0: raise ValueError(\\"Window size should be a positive integer.\\") if window_size > len(data): raise ValueError(\\"Window size should be less than or equal to the length of the data.\\") result = [] for i in range(len(data) - window_size + 1): window_sum = sum(data[i:i + window_size]) result.append(window_sum / window_size) return result"},{"question":"# Longest Increasing Subsequence Assessment Question You are tasked with developing a feature for a data analysis application that can identify trends within a dataset. One important requirement is to find the longest increasing subsequence (LIS) within a sequence of integers. An increasing subsequence is a subsequence where each element is greater than the previous one. Task: Write a function `longest_increasing_subsequence(nums: List[int]) -> int` that takes a single argument: - `nums` (List[int]): A list of integers representing the sequence in which you need to find the longest increasing subsequence. The function should return an integer corresponding to the length of the longest increasing subsequence in the given list of integers. Input: - The list `nums` will have a length of at most 1000 and will contain integers. Output: - Return an integer representing the length of the longest increasing subsequence. Examples: ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([2, 2, 22, 22, 5, 8, 6]) 3 >>> longest_increasing_subsequence([]) 0 ``` Constraints: - The function should handle edge cases such as empty lists and lists with no increasing subsequences effectively. - Performance should be optimized for input list length up to 1000 elements.","solution":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Find the Kth Largest Element in an Array You are required to find the Kth largest element in an array, where K is a given positive integer. The array may contain duplicate elements and it is guaranteed that the value of K is valid (i.e., 1 ≤ K ≤ array\'s length). **Input**: - A list of integers `arr` representing the array. - An integer `k` representing the position of the largest element to find. **Output**: - Returns an integer which is the Kth largest element in the array. **Constraints**: - Do not use external libraries for the solution, except the built-in ones available in standard Python. - The implementation should handle arrays of varying lengths and values. # Task: 1. Implement the function `find_kth_largest(arr: list, k: int) -> int` to find the Kth largest element. 2. Optimize the function to run efficiently even for large arrays. # Example Usages: ```python assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 # The 2nd largest element is 5 assert find_kth_largest([1, 1, 1, 1, 1, 1], 1) == 1 # The largest element is 1 assert find_kth_largest([7, 10, 4, 3, 20, 15], 4) == 7 # The 4th largest element is 7 assert find_kth_largest([2, 2, 3, 1, 2, 3], 3) == 2 # The 3rd largest element is 2 assert find_kth_largest([1], 1) == 1 # The 1st largest element in a single-element array is the element itself ```","solution":"def find_kth_largest(arr, k): Find the Kth largest element in an array. Args: arr (list of int): The input array. k (int): The position of the largest element to find. Returns: int: The Kth largest element. arr.sort(reverse=True) return arr[k - 1]"},{"question":"# Problem Description You are tasked with developing a function that simulates the merging process of two sorted arrays. However, the merged result should include elements from both arrays but keep only unique elements, preserving their relative sorted order. # Function Signature ```python def merge_sorted_unique(arr1: list, arr2: list) -> list: Merges two sorted arrays into one sorted array with unique elements. Args: arr1: A list of integers sorted in non-decreasing order. arr2: A list of integers sorted in non-decreasing order. Returns: list: A list of sorted unique integers merged from arr1 and arr2. Examples: >>> merge_sorted_unique([1, 3, 4, 5], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 8] >>> merge_sorted_unique([0, 2, 2, 4], [1, 1, 4, 5]) [0, 1, 2, 4, 5] >>> merge_sorted_unique([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_unique([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_unique([], []) [] ``` # Detailed Requirements 1. **Inputs**: * `arr1` (list): A list of integers sorted in non-decreasing order. * `arr2` (list): A list of integers sorted in non-decreasing order. 2. **Output**: * Returns a list of sorted unique integers merged from `arr1` and `arr2`. 3. **Constraints**: * 0 <= len(arr1), len(arr2) <= 10^4 * -10^9 <= each integer in arr1, arr2 <= 10^9 4. **Performance Requirements**: * Your solution should efficiently handle merging and removal of duplicates. # Hints: * Utilize two pointers to iterate through both arrays while maintaining the order. * Use additional space to keep track of unique elements.","solution":"def merge_sorted_unique(arr1, arr2): Merges two sorted arrays into one sorted array with unique elements. Args: arr1: A list of integers sorted in non-decreasing order. arr2: A list of integers sorted in non-decreasing order. Returns: list: A list of sorted unique integers merged from arr1 and arr2. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 elif arr1[i] > arr2[j]: if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 else: if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 j += 1 while i < len(arr1): if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 while j < len(arr2): if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 return merged"},{"question":"# Array Partitioning and Balancing Context You are working with a large dataset represented as an array of integers. Your task is to partition the array into two non-empty subsets such that the absolute difference between the sums of the subsets is minimized. This problem is common in data analysis where you want to balance the data as evenly as possible. Your job is to write a function that achieves this partitioning efficiently. Function: Partition Array for Minimum Difference Write a function `partition_array_min_difference(arr: List[int]) -> Tuple[List[int], List[int]]` that partitions an input array into two subsets with a minimal absolute difference between their sums. * **Input**: A list of integers, `arr` (where `len(arr) >= 2`). * **Output**: A tuple of two lists, representing the two subsets of the original array. # Constraints 1. The input array will have at least 2 integer elements. 2. The integers in the array can be negative, zero, or positive. Examples ```python >>> partition_array_min_difference([1, 6, 11, 5]) ([1, 11], [6, 5]) # This can also be ([6, 11], [1, 5]) depending on the logic. >>> partition_array_min_difference([1, 2, 3, 9]) ([1, 2, 3], [9]) >>> partition_array_min_difference([-7, -3, -2, 5, 8]) ([-7, 5, 8], [-3, -2]) ``` # Additional Notes - The goal is to achieve the smallest possible difference between the sums of the two subsets. - You should consider an efficient algorithm that can handle larger arrays within a reasonable timeframe. - You can assume that there is always a solution for a given input `arr`. Implement this function ensuring it handles various edge cases and provides an optimal partition for minimizing the difference of the subset sums.","solution":"from itertools import combinations from typing import List, Tuple def partition_array_min_difference(arr: List[int]) -> Tuple[List[int], List[int]]: Partitions the array into two subsets to minimize the absolute difference between their sums. total_sum = sum(arr) n = len(arr) best_diff = float(\'inf\') best_combination = None for i in range(1, n): for combo in combinations(arr, i): set1_sum = sum(combo) set2_sum = total_sum - set1_sum diff = abs(set1_sum - set2_sum) if diff < best_diff: best_diff = diff best_combination = combo set1 = list(best_combination) set2 = list(arr) for item in set1: set2.remove(item) return set1, set2"},{"question":"# Remove Duplicates from a Linked List **Context**: In the context of managing large datasets, linked lists are often used due to their dynamic size and ease of insertion and deletion of elements. One common task is cleaning up the list by removing duplicate values to ensure that each element appears only once. **Problem Statement**: Implement a function `remove_duplicates` to remove all duplicate values from a given unsorted linked list. The function should return the head of the modified linked list, which should contain only unique values in the same relative order as they first appeared. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: pass ``` # Input - **head (ListNode)**: The head of the linked list. # Output - **ListNode**: The head of the modified linked list with duplicate values removed. # Constraints 1. The number of nodes in the linked list is in the range [0, 10^4]. 2. -10^5 <= Node value <= 10^5 # Examples ```python # Example 1 # Input: 1 -> 2 -> 3 -> 2 -> 4 -> 3 -> 5 # Output: 1 -> 2 -> 3 -> 4 -> 5 # Example 2 # Input: 1 -> 1 -> 1 -> 2 -> 3 -> 3 # Output: 1 -> 2 -> 3 ``` # Notes * Your function should handle the case where the input linked list is empty. * The solution must maintain the original relative order of elements. * Consider using auxiliary storage to keep track of seen values for efficient duplicate detection. **Testing**: Besides the provided examples, create additional test cases to validate your implementation, including edge cases such as: 1. Linked list with all unique values. 2. Linked list with all duplicate values. 3. Linked list with alternating duplicate and unique values. 4. Large linked list with random values.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: if not head: return head seen = set() current = head previous = None while current: if current.val in seen: previous.next = current.next else: seen.add(current.val) previous = current current = current.next return head"},{"question":"# Objective Write a function `reverse_string` that takes a string and returns the string with its characters in reverse order while preserving the positions of the spaces. # Input & Output * **Input**: A single string `s` containing alphabetic characters and spaces. * **Output**: A string where the characters are reversed, but the spaces remain in their original positions. # Constraints 1. The input string will only contain alphabetic characters (both lowercase and uppercase) and spaces. 2. The length of the input string will not exceed 1000 characters. 3. Optimize the function to have at most O(n) time complexity, where `n` is the length of the input string. # Example ```python # Example 1 # Input: \\"a bc d\\" # Output: \\"d cb a\\" # Example 2 # Input: \\"hello world\\" # Output: \\"dlrow olleh\\" # Example 3 # Input: \\" abc \\" # Output: \\" cba \\" ``` # Scenario Imagine you\'re working on a vintage text editor that requires reversing the text entered by the user. However, the editor has a unique feature where it preserves the whitespace positions to maintain the original formatting while reversing the alphabetic characters. Implementing the `reverse_string` function will help you achieve this functionality seamlessly. # Function Signature ```python def reverse_string(s: str) -> str: pass ```","solution":"def reverse_string(s: str) -> str: Returns a string where the characters are reversed while preserving the positions of the spaces. characters = [char for char in s if char != \' \'] result = [] for char in s: if char == \' \': result.append(char) else: result.append(characters.pop()) return \'\'.join(result)"},{"question":"Design and Implement a Dijkstra\'s Algorithm with Path Reconstruction **Background**: Dijkstra\'s algorithm is a well-known algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. The algorithm creates a shortest-path tree by maintaining a set of vertices whose shortest distances from the source are known. **Task**: Extend the typical implementation of Dijkstra’s algorithm to not only return the shortest distance from the source node to a target node but also to reconstruct the path taken to achieve this shortest distance. **Function Signature**: ```python def dijkstra_with_path(graph: dict[int, list[tuple[int, int]]], start: int, end: int) -> tuple[int, list[int]]: Find the shortest path from start node to end node using Dijkstra\'s algorithm and reconstruct the path. Parameters: - graph: A dictionary where keys are node integers and values are lists of tuples (neighboring_node, edge_weight). - start: The starting node for the path. - end: The target node for the path. Returns: - A tuple where the first element is an integer representing the shortest distance from start to end. The second element is a list of integers representing the nodes in the shortest path from start to end. ``` **Input**: - `graph`: A dictionary representing the graph. Keys are node IDs (integers), and values are lists of tuples where each tuple contains a neighboring node and the edge weight. - `start`: An integer representing the starting node. - `end`: An integer representing the destination node. **Output**: - A tuple where: - The first element is an integer representing the shortest distance from the start node to the end node. - The second element is a list of integers representing the nodes in the shortest path from start to end. **Constraints**: - Assume all nodes have a unique identifier (integer). - Assume the graph is connected and does not contain negative weight edges. - If no path exists, return `float(\'inf\')` for the distance and an empty list for the path. **Example**: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } print(dijkstra_with_path(graph, 0, 3)) # Expected: (4, [0, 2, 1, 3]) graph = { 0: [(1, 3), (2, 1)], 1: [(3, 3)], 2: [(3, 1)], 3: [] } print(dijkstra_with_path(graph, 0, 3)) # Expected: (2, [0, 2, 3]) ``` **Edge Cases**: 1. Start and end node are the same. 2. Graph contains only one node. 3. Multiple paths of the same shortest distance. **Performance Requirements**: - The function should be able to handle graphs with up to a few thousand nodes efficiently. - Ensure the implementation handles cases where the end node is not reachable from the start node.","solution":"import heapq def dijkstra_with_path(graph, start, end): Find the shortest path from start node to end node using Dijkstra\'s algorithm and reconstruct the path. Parameters: - graph: A dictionary where keys are node integers and values are lists of tuples (neighboring_node, edge_weight). - start: The starting node for the path. - end: The target node for the path. Returns: - A tuple where the first element is an integer representing the shortest distance from start to end. The second element is a list of integers representing the nodes in the shortest path from start to end. # Priority queue to store (cost, node) pq = [(0, start)] distances = {node: float(\'inf\') for node in graph} distances[start] = 0 previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the end node, reconstruct the path and return if current_node == end: path = [] while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] path.reverse() return (current_distance, path) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) return (float(\'inf\'), []) # If there\'s no path to the end node"},{"question":"# Background: Linked lists are a fundamental data structure in computer science, often used to implement other data structures such as stacks and queues. A linked list consists of nodes, each holding a value and a reference to the next node in the sequence. Circular linked lists are a variation where the last node points back to the first node, forming a circle. # Task: Implement a function that detects if a given linked list is circular. Your function should return `True` if the linked list is circular and `False` otherwise. Additionally, handle the edge case where the linked list is empty. # Function Signature: ```python class ListNode: def __init__(self, value: int, next: \'ListNode\' = None): self.value = value self.next = next def is_circular_linked_list(head: ListNode) -> bool: pass ``` # Input: - `head`: A `ListNode` object representing the head of the linked list. # Output: - Returns `True` if the linked list is circular, `False` otherwise. # Constraints: - The linked list can have any number of nodes, including zero. - Each node contains only integer values. # Examples: ```python # Example 1: Circular linked list node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node1.next = node2 node2.next = node3 node3.next = node1 # Circle back to node1 print(is_circular_linked_list(node1)) # Expected: True # Example 2: Non-circular linked list node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node1.next = node2 node2.next = node3 node3.next = None print(is_circular_linked_list(node1)) # Expected: False # Example 3: Empty linked list print(is_circular_linked_list(None)) # Expected: False # Example 4: Single node pointing to itself node = ListNode(1) node.next = node print(is_circular_linked_list(node)) # Expected: True ``` # Scenario: You are working on a networking system where devices are represented as nodes in a list. In certain cases, the network forms a loop, and such loops disrupt communication. You need to detect these circular references in the network to ensure seamless communication. Implement a function to identify these circular linked lists efficiently.","solution":"class ListNode: def __init__(self, value: int, next: \'ListNode\' = None): self.value = value self.next = next def is_circular_linked_list(head: ListNode) -> bool: if head is None: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# **Coding Challenge: LRU Cache Implementation** Context Implement an LRU (Least Recently Used) Cache which has a fixed capacity and supports the following operations: 1. `get(key)`: Return the value of the key if it exists in the cache, otherwise return -1. 2. `put(key, value)`: Insert or update the value of the key. If the number of keys exceeds the fixed capacity, remove the least recently used key. An LRU Cache is useful to manage data that may not fit into memory but requires quick access patterns that prioritize recently used items. Task Implement the LRU Cache with the mentioned operations and constraints. Input and Output Formats **Input**: 1. The capacity of the LRU Cache (integer). 2. A list of operations to perform. Each operation is represented as a list where the first element is a string indicating the type of operation (`\\"get\\"` or `\\"put\\"`), followed by associated parameters: - For `\\"get\\"`: the key to retrieve. - For `\\"put\\"`: the key-value pair to insert or update. ``` Example: capacity = 2 operations = [[\\"put\\", 1, 1], [\\"put\\", 2, 2], [\\"get\\", 1], [\\"put\\", 3, 3], [\\"get\\", 2], [\\"put\\", 4, 4], [\\"get\\", 1], [\\"get\\", 3], [\\"get\\", 4]] ``` **Output**: 1. For `\\"get\\"` operations, return the retrieved value or -1 if the key does not exist. 2. No output is required for `\\"put\\"` operations. Requirements 1. **Function Signature**: ```python class LRUCache: def __init__(self, capacity: int): # initialize the LRU cache with the given capacity pass def get(self, key: int) -> int: # return the value for the given key if it exists, otherwise return -1 pass def put(self, key: int, value: int): # put or update the value for the given key pass def execute_operations(capacity: int, operations: List[List[Union[str, int]]]) -> List[int]: # initializes the LRU cache with the given capacity and perform the operations on it pass ``` 2. **Constraints**: * The `capacity` will be an integer where `1 <= capacity <= 10^4`. * The number of operations `q` will be such that `1 <= q <= 10^4`. * The key and value will be integers within the range `[-10^4, 10^4]`. Example ```python # Input capacity = 2 operations = [[\\"put\\", 1, 1], [\\"put\\", 2, 2], [\\"get\\", 1], [\\"put\\", 3, 3], [\\"get\\", 2], [\\"put\\", 4, 4], [\\"get\\", 1], [\\"get\\", 3], [\\"get\\", 4]] # Output [1, -1, -1, 3, 4] ``` **Note:** The LRU Cache should be implemented using standard Python structures such as dictionaries and doubly linked lists for efficient access and removal.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def execute_operations(capacity: int, operations: list) -> list: lru_cache = LRUCache(capacity) result = [] for operation in operations: if operation[0] == \\"put\\": lru_cache.put(operation[1], operation[2]) elif operation[0] == \\"get\\": result.append(lru_cache.get(operation[1])) return result"},{"question":"# Problem Description: You are tasked with finding all unique permutations of a given string `s` that may contain duplicate characters. Each permutation must be a rearrangement of characters in `s`, ensuring no duplicates in the results. The goal is to implement a function that efficiently generates these unique permutations. # Input: * A string `s` which may contain duplicate characters. # Output: * A list of strings with all unique permutations of `s`. # Function Signature: ```python def unique_permutations(s: str) -> list[str]: pass ``` # Constraints: * `0 <= len(s) <= 8` # Performance Requirements: Your solution should efficiently handle the permutations by eliminating duplicates directly during generation, avoiding redundant computation. Aim for clarity and correctness. # Edge Cases: * An empty string `s = \\"\\"` should return a list with a single empty string: `[\\"\\"]`. * Consider handling all possibilities of duplicating characters efficiently. # Example: ```python # Example 1: # Input: s = \\"aab\\" # Output: [\\"aab\\", \\"aba\\", \\"baa\\"] # Example 2: # Input: s = \\"abc\\" # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] # Example 3: # Input: s = \\"\\" # Output: [\\"\\"] # Example 4: # Input: s = \\"aaa\\" # Output: [\\"aaa\\"] ``` **Notes**: 1. You should use a backtracking approach to generate permutations and a set to track unique results. 2. Ensure the solution handles the case of all identical characters efficiently without unnecessary calculations. 3. Consider adding intermediate checks to prevent unnecessary recursive calls when duplicates are detected.","solution":"from itertools import permutations def unique_permutations(s: str) -> list[str]: Generate all unique permutations of the input string `s`. Parameters: s (str): The input string which may contain duplicate characters. Returns: list[str]: A list of unique permutations. return sorted(set(\'\'.join(p) for p in permutations(s)))"},{"question":"# Letter Frequency Analysis and Shift Cipher You are tasked with implementing a tool to analyze the frequency of letters in a given piece of text and to use this analysis to either encrypt or decrypt that text using the Caesar Shift Cipher method. The Caesar Shift Cipher is a type of substitution cipher where each letter in the plaintext is shifted by a fixed number of positions down the alphabet. Function Specifications: 1. **Analyze Function**: ```python def analyze_frequency(input_text: str) -> dict: Analyzes the frequency of each letter in the input text. :param input_text: The text to be analyzed. :return: A dictionary where keys are letters and values are their respective frequencies. ``` 2. **Encrypt Function**: ```python def caesar_shift_encrypt(plaintext: str, shift: int) -> str: Encrypts the plaintext using a Caesar Shift Cipher with a given shift. :param plaintext: The text to be encrypted. :param shift: The number of positions to shift each letter. :return: The encrypted text as a string. ``` 3. **Decrypt Function**: ```python def caesar_shift_decrypt(ciphertext: str, shift: int) -> str: Decrypts the ciphertext using a Caesar Shift Cipher with a given shift. :param ciphertext: The text to be decrypted. :param shift: The number of positions each letter was shifted by during encryption. :return: The decrypted text as a string. ``` Requirements - The input text for all functions should be treated as case-insensitive. - Spaces and other non-alphabet characters should be ignored in the analysis, encryption, and decryption processes. - The analysis should return the frequencies of each letter found in the input text as a dictionary. Constraints - Assume the input text (for analyze, encrypt, and decrypt functions) is composed of alphabetic characters and spaces only. - The length of the text to be analyzed, encrypted, or decrypted will be less than 10,000 characters. - The shift value for the Caesar Cipher will be between 1 and 25 inclusive. Example Usage ```python def test_cipher_functions() -> None: text = \\"HELLO WORLD\\" shift = 3 # Frequency analysis frequencies = analyze_frequency(text) assert frequencies == {\'H\': 1, \'E\': 1, \'L\': 3, \'O\': 2, \'W\': 1, \'R\': 1, \'D\': 1}, f\\"Expected frequencies, got {frequencies}\\" # Encryption encrypted = caesar_shift_encrypt(text, shift) assert encrypted == \\"KHOOR ZRUOG\\", f\\"Expected: KHOOR ZRUOG, Got: {encrypted}\\" # Decryption decrypted = caesar_shift_decrypt(encrypted, shift) assert decrypted == \\"HELLO WORLD\\", f\\"Expected: HELLO WORLD, Got: {decrypted}\\" if __name__ == \\"__main__\\": test_cipher_functions() ``` # Explanation: - For the frequency analysis, ensure that only alphabetic characters are considered, ignoring case distinctions. - For encryption, shift each letter in the plaintext by the given number, wrapping around if necessary. - For decryption, reverse the shift applied during encryption by shifting backwards. This set of tasks ensures a deep understanding of text manipulation, frequency analysis, and basic encryption techniques.","solution":"def analyze_frequency(input_text: str) -> dict: Analyzes the frequency of each letter in the input text. :param input_text: The text to be analyzed. :return: A dictionary where keys are letters and values are their respective frequencies. frequency_dict = {} for char in input_text.upper(): if char.isalpha(): frequency_dict[char] = frequency_dict.get(char, 0) + 1 return frequency_dict def caesar_shift_encrypt(plaintext: str, shift: int) -> str: Encrypts the plaintext using a Caesar Shift Cipher with a given shift. :param plaintext: The text to be encrypted. :param shift: The number of positions to shift each letter. :return: The encrypted text as a string. encrypted_text = [] for char in plaintext.upper(): if char.isalpha(): shifted_char = chr(((ord(char) - ord(\'A\') + shift) % 26) + ord(\'A\')) encrypted_text.append(shifted_char) return \'\'.join(encrypted_text) def caesar_shift_decrypt(ciphertext: str, shift: int) -> str: Decrypts the ciphertext using a Caesar Shift Cipher with a given shift. :param ciphertext: The text to be decrypted. :param shift: The number of positions each letter was shifted by during encryption. :return: The decrypted text as a string. decrypted_text = [] for char in ciphertext.upper(): if char.isalpha(): shifted_char = chr(((ord(char) - ord(\'A\') - shift) % 26) + ord(\'A\')) decrypted_text.append(shifted_char) return \'\'.join(decrypted_text)"},{"question":"# Problem Statement You are given an array of integers and a positive integer k. Your task is to implement a function that checks whether there exists two different indices `i` and `j` in the array such that the absolute difference between the values at these indices is equal to k. # Function Signature ```python def check_difference(arr: List[int], k: int) -> bool: ``` # Input * `arr` (List[int]): A list of integers, where the length of the list is between 1 and 10^5, inclusive. Each integer is between -10^9 and 10^9, inclusive. * `k` (int): A positive integer between 1 and 10^9, inclusive. # Output * A boolean value: `True` if there are two different indices `i` and `j` in `arr` such that `|arr[i] - arr[j]| == k`, and `False` otherwise. # Example ```python assert check_difference([1, 5, 9, 12], 4) == True # 5 - 1 == 4 or 9 - 5 == 4 assert check_difference([1, 3, 5, 7], 2) == True # 3 - 1 == 2 or 5 - 3 == 2 or 7 - 5 == 2 assert check_difference([2, 4, 6, 8], 7) == False # No two elements have an absolute difference of 7 ``` # Hints 1. Consider using a set for quick lookups to determine if the necessary value exists. 2. Iterate through each element in the array and check if the current element plus or minus k exists in the set.","solution":"def check_difference(arr, k): Checks whether there exists two different indices i and j in the array such that the absolute difference between the values at these indices is equal to k. value_set = set(arr) # Create a set for O(1) lookups for num in arr: if (num + k in value_set) or (num - k in value_set): return True return False"},{"question":"# Fibonacci Series with Variation You are assigned to create a function that generates a modified Fibonacci series where each term is the sum of the previous three terms instead of the traditional two. The function should validate inputs and handle edge cases appropriately. # Function Definition Implement the following function: ```python def generate_modified_fibonacci_series(n: Union[int, float, str], a: Union[int, float, str], b: Union[int, float, str], c: Union[int, float, str]) -> List[Union[int, float]]: pass ``` # Input Parameters * **n** (int, float, or str): The number of terms in the series. * **a** (int, float, or str): The first term of the series. * **b** (int, float, or str): The second term of the series. * **c** (int, float, or str): The third term of the series. # Output * **List of ints or floats**: The modified Fibonacci series as a list of numbers. # Constraints * If `n` is less than or equal to 0, return an empty list. * If `n` or any of the initial terms (`a`, `b`, `c`) are strings that cannot be converted into valid numbers, return a list containing only the first valid terms. * Handle inputs as integers, floats, and strings representing numbers. # Performance Requirements The function should efficiently handle values for `n` up to 100. # Example ```python # Example usage and output print(generate_modified_fibonacci_series(5, 1, 1, 2)) # Output: [1, 1, 2, 4, 7] print(generate_modified_fibonacci_series(6, 0.5, 1.5, 2.5)) # Output: [0.5, 1.5, 2.5, 4.5, 8.5, 15.5] print(generate_modified_fibonacci_series(-3, 1, 1, 2)) # Output: [] print(generate_modified_fibonacci_series(4, \'invalid\', 1, 2)) # Output: [] print(generate_modified_fibonacci_series(\'5\', \'1\', \'2\', \'3\')) # Output: [1, 2, 3, 6, 11] ``` # Notes * Use built-in Python functions and capabilities to perform mathematical operations. * Validate the inputs thoroughly to ensure robust and error-free execution. * The series should start with the provided initial three terms (`a`, `b`, `c`). [Question 3]:","solution":"from typing import Union, List def generate_modified_fibonacci_series(n: Union[int, float, str], a: Union[int, float, str], b: Union[int, float, str], c: Union[int, float, str]) -> List[Union[int, float]]: try: n = int(n) if n <= 0: return [] except ValueError: return [] try: a = float(a) if \'.\' in str(a) else int(a) except ValueError: return [] try: b = float(b) if \'.\' in str(b) else int(b) except ValueError: return [] try: c = float(c) if \'.\' in str(c) else int(c) except ValueError: return [] series = [a, b, c] for _ in range(n - 3): next_term = series[-1] + series[-2] + series[-3] series.append(next_term) return series[:n]"},{"question":"# Data Analysis and Visualization Challenge **Context**: You are given a dataset containing information about customer transactions from an online retail store. Each row in the dataset corresponds to a single transaction and includes details such as transaction ID, customer ID, the date of the transaction, the product purchased, the quantity, and the amount. # Function Implementation Implement a function named `generate_customer_purchases_visualization` that accepts a single parameter: 1. `transactions` (list of dictionaries): A list where each dictionary represents a transaction with the following keys: - `transaction_id` (str): The unique identifier for each transaction. - `customer_id` (str): The unique identifier for each customer. - `date` (str): The date of transaction in \'YYYY-MM-DD\' format. - `product` (str): The name of the product purchased. - `quantity` (int): The number of units purchased. - `amount` (float): The total cost of the transaction. The function should perform the following: 1. Validate the input to ensure it is a non-empty list with dictionaries containing the required keys. 2. Parse the date strings and convert them to appropriate datetime objects for analysis. 3. Group transactions by customer ID and calculate the total amount spent by each customer and the total number of transactions they made. 4. Generate a bar chart plotting customer IDs on the x-axis and total amount spent on the y-axis. 5. Save the chart as an image file named `customer_purchases.png`. **Specifications**: - If the input is invalid or empty, raise a `ValueError` with an appropriate error message. - Ensure that the date parsing correctly handles \'YYYY-MM-DD\' formatted strings. - Use Python libraries such as `matplotlib` for plotting and `pandas` for data manipulation. - Handle any potential exceptions during file operations or plotting, and raise a suitable error message if they occur. # Example ```python import matplotlib.pyplot as plt import pandas as pd from datetime import datetime def generate_customer_purchases_visualization(transactions: list) -> None: # Your implementation here ``` **Test Cases**: 1. Calling `generate_customer_purchases_visualization([])` should raise a `ValueError` with a message \\"Input must be a non-empty list of dictionaries.\\" 2. Providing an invalid list should return the appropriate ValueError. 3. Providing a valid list of transactions should generate and save `customer_purchases.png`. **Notes**: - Use the provided code snippet as a starting point. - Make sure to handle exceptions and edge cases as specified.","solution":"import matplotlib.pyplot as plt import pandas as pd from datetime import datetime def generate_customer_purchases_visualization(transactions: list) -> None: if not transactions or not isinstance(transactions, list) or not all(isinstance(t, dict) for t in transactions): raise ValueError(\\"Input must be a non-empty list of dictionaries.\\") required_keys = {\'transaction_id\', \'customer_id\', \'date\', \'product\', \'quantity\', \'amount\'} for t in transactions: if not required_keys.issubset(t.keys()): raise ValueError(\\"Each dictionary must contain the keys: \'transaction_id\', \'customer_id\', \'date\', \'product\', \'quantity\', \'amount\'\\") try: # Convert list of transactions to a DataFrame df = pd.DataFrame(transactions) # Convert \'date\' column to datetime df[\'date\'] = pd.to_datetime(df[\'date\'], format=\'%Y-%m-%d\') # Group by customer ID and calculate total amount spent and total number of transactions customer_summary = df.groupby(\'customer_id\').agg( total_amount_spent=pd.NamedAgg(column=\'amount\', aggfunc=\'sum\'), total_transactions=pd.NamedAgg(column=\'transaction_id\', aggfunc=\'count\') ).reset_index() # Create bar chart plt.figure(figsize=(10, 6)) plt.bar(customer_summary[\'customer_id\'], customer_summary[\'total_amount_spent\'], color=\'blue\') plt.xlabel(\'Customer ID\') plt.ylabel(\'Total Amount Spent\') plt.title(\'Total Amount Spent by Each Customer\') plt.xticks(rotation=45, ha=\'right\') plt.tight_layout() # Save the plot as a PNG file plt.savefig(\'customer_purchases.png\') plt.close() except Exception as e: raise RuntimeError(f\\"An error occurred while generating the visualization: {e}\\")"},{"question":"# Implement a Simple HTTP Server Your task is to implement a simple HTTP server that handles GET and POST requests. The goal is to demonstrate your understanding of HTTP protocols, socket programming, and basic request handling. # Functional Requirements: 1. **Handle GET Requests**: The server should respond to GET requests by serving static HTML content from a specified directory. 2. **Handle POST Requests**: The server should be able to accept POST requests, process the form data, and return a simple acknowledgment response. 3. **Logging**: Log each request type (GET or POST) along with requested URI and timestamp. 4. **404 Error**: Respond with a 404 error message for unsupported paths or methods. # Input and Output Formats: - **Input**: 1. Port number the server will listen on. 2. Directory where HTML files are stored. - **Output**: HTTP response with appropriate status codes and content. # Constraints: 1. Use Python\'s `socket` library for handling connections. 2. Ensure the server can handle multiple connections sequentially. 3. Provide a simple logging mechanism for the server’s activity. 4. The server should support a basic HTML form for `POST` requests and capture the form data. # Performance Requirements: 1. Efficient handling of incoming connections. 2. Minimal overhead for processing requests. # Implementation Scenario: You are required to implement the function `run_http_server(port: int, html_dir: str)`: ```python import socket import os from datetime import datetime def run_http_server(port: int, html_dir: str): def handle_request(connection): request = connection.recv(1024).decode() log_request(request) method, path, _ = request.split(\' \', 2) if method == \'GET\': serve_get_request(connection, html_dir, path) elif method == \'POST\': handle_post_request(connection, request) else: send_404_response(connection) connection.close() def log_request(request): method, path, _ = request.split(\' \', 2) print(f\\"{datetime.now()} - {method} {path}\\") def serve_get_request(connection, html_dir, path): if path == \'/\': path = \'/index.html\' try: with open(os.path.join(html_dir, path.strip(\'/\')), \'rb\') as file: content = file.read() response = \'HTTP/1.1 200 OKnn\'.encode() + content connection.sendall(response) except FileNotFoundError: send_404_response(connection) def handle_post_request(connection, request): body = request.split(\'rnrn\')[1] response = f\\"HTTP/1.1 200 OKnnReceived POST data: {body}\\".encode() connection.sendall(response) def send_404_response(connection): response = \'HTTP/1.1 404 Not Foundnn404 Not Found\' connection.sendall(response.encode()) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\'0.0.0.0\', port)) server_socket.listen(5) print(f\\"Serving HTTP on port {port} ...\\") while True: conn, addr = server_socket.accept() handle_request(conn) ``` *Note*: Ensure the directory structure includes basic HTML files for testing the GET requests and a form.html file for handling POST requests.","solution":"import socket import os from datetime import datetime def run_http_server(port: int, html_dir: str): def handle_request(connection): request = connection.recv(1024).decode() log_request(request) method, path, _ = request.split(\' \', 2) if method == \'GET\': serve_get_request(connection, html_dir, path) elif method == \'POST\': handle_post_request(connection, request) else: send_404_response(connection) connection.close() def log_request(request): method, path, _ = request.split(\' \', 2) print(f\\"{datetime.now()} - {method} {path}\\") def serve_get_request(connection, html_dir, path): if path == \'/\': path = \'/index.html\' try: with open(os.path.join(html_dir, path.strip(\'/\')), \'rb\') as file: content = file.read() response = \'HTTP/1.1 200 OKnn\'.encode() + content connection.sendall(response) except FileNotFoundError: send_404_response(connection) def handle_post_request(connection, request): body = request.split(\'rnrn\')[1] response = f\\"HTTP/1.1 200 OKnnReceived POST data: {body}\\".encode() connection.sendall(response) def send_404_response(connection): response = \'HTTP/1.1 404 Not Foundnn404 Not Found\' connection.sendall(response.encode()) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\'0.0.0.0\', port)) server_socket.listen(5) print(f\\"Serving HTTP on port {port} ...\\") while True: conn, addr = server_socket.accept() handle_request(conn)"},{"question":"# Validation of User Inputs in Web Form You are tasked with developing a function that validates user inputs in a web form. When a user submits the form, your function should verify that all required fields are populated correctly and meet specified criteria. # Objective Write a function `validate_form(data: dict) -> dict` that takes a dictionary representing form data and returns a dictionary with validation results for each field. # Input * `data` (dict): A dictionary where each key is a field name and each value is the corresponding user input. # Output * `validation_results` (dict): A dictionary containing the following key validation results: - `is_valid` (bool): Overall validity of the form (`True` if all checks pass, `False` otherwise). - `errors` (dict): Nested dictionary where each key is a field name and each value is a list of error messages for that field. # Constraints * Required fields and their validation criteria are: - `username` (str): Must be 3-30 characters long and only contain alphanumeric characters. - `email` (str): Must be a valid email address format. - `age` (int): Must be an integer between 18 and 99 inclusive. * Other fields in the input should be ignored. * Ensure that the solution is efficient and scalable. # Example ```python def validate_form(data: dict) -> dict: # Your implementation here pass # Example usage: form_data = { \\"username\\": \\"john_doe\\", \\"email\\": \\"john.doe@example.com\\", \\"age\\": 28 } validation_results = validate_form(form_data) print(validation_results) # Output: # { # \\"is_valid\\": True, # \\"errors\\": {} # } invalid_form_data = { \\"username\\": \\"jd!\\", \\"email\\": \\"john.doe@com\\", \\"age\\": 17 } validation_results = validate_form(invalid_form_data) print(validation_results) # Output: # { # \\"is_valid\\": False, # \\"errors\\": { # \\"username\\": [\\"Username must be between 3 to 30 characters long and contain only alphanumeric characters.\\"], # \\"email\\": [\\"Email must be a valid email address.\\"], # \\"age\\": [\\"Age must be an integer between 18 and 99.\\"] # } # } ``` Ensure your implementation follows the guidelines provided, handles edge cases, and efficiently processes the data.","solution":"import re def validate_form(data: dict) -> dict: errors = {} # Validate username username = data.get(\\"username\\") if not username: errors[\\"username\\"] = [\\"Username is required.\\"] elif not re.match(\\"^[a-zA-Z0-9]{3,30}\\", username): errors[\\"username\\"] = [\\"Username must be between 3 to 30 characters long and contain only alphanumeric characters.\\"] # Validate email email = data.get(\\"email\\") if not email: errors[\\"email\\"] = [\\"Email is required.\\"] elif not re.match(r\\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\\", email): errors[\\"email\\"] = [\\"Email must be a valid email address.\\"] # Validate age age = data.get(\\"age\\") if age is None: errors[\\"age\\"] = [\\"Age is required.\\"] elif not isinstance(age, int) or not (18 <= age <= 99): errors[\\"age\\"] = [\\"Age must be an integer between 18 and 99.\\"] is_valid = not bool(errors) return {\\"is_valid\\": is_valid, \\"errors\\": errors}"},{"question":"# Coding Assessment Question Context You are a software engineer working on a video streaming service. One of the critical tasks involves handling users\' personal data safely and efficiently. Specifically, each user has an associated subscription record, which includes the date they subscribed, the date their subscription is due to renew, and the plan type. Your task is to implement functionality to check the status of a user\'s subscription. Task You need to implement a method called **check_subscription_status** within the **UserSubscription** class. This function will determine whether a user\'s subscription is active or expired based on the current date. # Input and Output Specifications * **Function Signature:** ```python def check_subscription_status(self, current_date: str) -> str: ``` * **Input:** - `current_date`: A string representing the current date in the format \\"YYYY-MM-DD\\". * **Output:** - The function must return a string \\"Active\\" if the subscription is still valid (i.e., the current date is before or on the renewal date), or \\"Expired\\" if the subscription has expired (i.e., the current date is after the renewal date). # Example *Given the following subscription record:* ```python subscription = UserSubscription(\\"2023-01-15\\", \\"2023-12-31\\", \\"Premium\\") current_date = \\"2023-10-01\\" status = subscription.check_subscription_status(current_date) print(f\\"Subscription Status: {status}\\") ``` *Expected Output:* ``` Subscription Status: Active ``` # Constraints 1. The date provided as input will always be valid and follow the \\"YYYY-MM-DD\\" format. 2. The `renewal_date` will be a valid future date based on the `subscription_date`. 3. You can use Python’s standard library datetime module to handle date comparisons. **Class Definition:** ```python class UserSubscription: def __init__(self, subscription_date: str, renewal_date: str, plan_type: str): self.subscription_date = subscription_date self.renewal_date = renewal_date self.plan_type = plan_type def check_subscription_status(self, current_date: str) -> str: # Your implementation here pass ``` In this coding assessment, you must write the **check_subscription_status** method to determine the subscription status based on the current date.","solution":"from datetime import datetime class UserSubscription: def __init__(self, subscription_date: str, renewal_date: str, plan_type: str): self.subscription_date = subscription_date self.renewal_date = renewal_date self.plan_type = plan_type def check_subscription_status(self, current_date: str) -> str: renewal_date_dt = datetime.strptime(self.renewal_date, \\"%Y-%m-%d\\") current_date_dt = datetime.strptime(current_date, \\"%Y-%m-%d\\") if current_date_dt <= renewal_date_dt: return \\"Active\\" else: return \\"Expired\\""},{"question":"# Coding Assessment Question: Directory Statistics Analyzer You are tasked to create a function `directory_summary` that analyzes a given directory and provides summarized statistics of the files contained within it. 1. **Input Parameters and Constraints**: - `directory_path` (str): The path to the directory to be analyzed. - The function should handle both absolute and relative paths. 2. **Function Output**: - Should return a dictionary containing the following fields: - `total_files`: Total number of files in the directory and its subdirectories. - `total_size`: Total size of all the files in bytes. - `file_types`: A dictionary where keys are file extensions (e.g., \'.txt\', \'.jpg\') and values are the respective counts of those files. 3. **Error Handling**: - Properly handle scenarios where the directory does not exist or is not accessible. - Handle invalid input parameters (e.g., input is not a string). - Raise appropriate exceptions or return informative error messages. 4. **Performance Considerations**: - Efficiently handle large directories with numerous files. - Ensure the function is optimized for directories containing various types of files. # Function Signature ```python def directory_summary(directory_path: str) -> dict: ``` # Example Usage ```python # Example call to the function summary = directory_summary(\\"/path/to/directory\\") print(f\\"Total Files: {summary[\'total_files\']}\\") print(f\\"Total Size: {summary[\'total_size\']} bytes\\") print(\\"File Types:\\") for ext, count in summary[\'file_types\'].items(): print(f\\"{ext}: {count} files\\") ``` # Notes - Use the `os` and/or `os.path` libraries for directory and file operations. - Consider using `os.walk` or similar methods to traverse directories. - Ensure the function is well-documented and tested with various directory structures.","solution":"import os from collections import defaultdict def directory_summary(directory_path: str) -> dict: Analyzes the given directory and provides summarized statistics of the files contained within it. Parameters: directory_path (str): The path to the directory to be analyzed. Returns: dict: A dictionary containing the following fields: - \'total_files\': Total number of files in the directory and its subdirectories. - \'total_size\': Total size of all the files in bytes. - \'file_types\': A dictionary where keys are file extensions (e.g., \'.txt\', \'.jpg\') and values are the respective counts of those files. Raises: FileNotFoundError: If the directory does not exist. NotADirectoryError: If the path is not a directory. ValueError: If the input is not a string. if not isinstance(directory_path, str): raise ValueError(\\"The directory path must be a string.\\") if not os.path.exists(directory_path): raise FileNotFoundError(f\\"The directory {directory_path} does not exist.\\") if not os.path.isdir(directory_path): raise NotADirectoryError(f\\"The path {directory_path} is not a directory.\\") total_files = 0 total_size = 0 file_types = defaultdict(int) for root, _, files in os.walk(directory_path): for file in files: file_path = os.path.join(root, file) total_files += 1 total_size += os.path.getsize(file_path) file_extension = os.path.splitext(file)[1] file_types[file_extension] += 1 return {\'total_files\': total_files, \'total_size\': total_size, \'file_types\': dict(file_types)}"},{"question":"# Smallest Positive Missing Number Problem Statement Given an array of integers, find the smallest positive integer that is missing from the array. The array can contain both positive and negative numbers, as well as duplicates. # Input * An array of integers ( arr ) of size ( n ) (1 ≤ n ≤ 10^5). # Output * Return the smallest positive integer that is missing from the array. # Constraints * The elements in the array are in the range of ( -10^6 ) to ( 10^6 ). * The solution should run in ( O(n) ) time complexity and use ( O(1) ) extra space. # Examples ```python # Example 1 Input: [3, 4, -1, 1] Output: 2 Explanation: 1 is present, so the next smallest positive number is 2. # Example 2 Input: [1, 2, 0] Output: 3 Explanation: 1 and 2 are present, so the next smallest positive number is 3. # Example 3 Input: [-3, -2, -1] Output: 1 Explanation: All numbers are negative, so the smallest positive number missing is 1. ``` # Task Write a function `find_smallest_missing_positive(arr: List[int]) -> int` that implements the above requirements. # Implementation ```python def find_smallest_missing_positive(arr): n = len(arr) # Ignore numbers out of range and use the array itself to place positive numbers in their correct index positions for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # The first index position which does not have the correct number indicates the missing number for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1 ``` This new question aligns with the original set in terms of style, complexity, topic alignment, and ensures uniqueness by introducing the concept of finding a missing positive integer within an array with constraints on time and space complexity.","solution":"def find_smallest_missing_positive(arr): n = len(arr) # Ignore numbers out of range and use the array itself to place positive numbers in their correct index positions for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # The first index position which does not have the correct number indicates the missing number for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"# Generate Unique Combinations Scenario You are required to implement a function that generates all unique combinations of a specified length from a given list of elements. The function should return these combinations in a lexicographically sorted order. Your task will test the understanding of recursion and combinatorial algorithms. Task Implement a function `generate_combinations` that finds all unique combinations of a specified length from the provided list. Function Details 1. `generate_combinations(arr, k)` - **Parameters:** - `arr`: A list of elements (e.g., integers, floats, or strings). - `k`: The length of each combination. - **Returns:** A list of lists, where each inner list represents a unique combination of length `k` from `arr`, sorted lexicographically. Input and Output - **Input Format**: - A list `arr` of elements (integers, floats, or strings). - An integer `k` indicating the length of each combination. - **Output Format**: A list of lists containing unique combinations sorted lexicographically. Constraints - All elements in the list should be comparable to each other. - 1 ≤ `k` ≤ `len(arr)` - Focus on efficiently generating unique combinations and ensuring proper sorting. Example Usage ```python assert generate_combinations([1, 2, 3], 2) == [[1, 2], [1, 3], [2, 3]] assert generate_combinations([\\"a\\", \\"b\\", \\"c\\"], 2) == [[\\"a\\", \\"b\\"], [\\"a\\", \\"c\\"], [\\"b\\", \\"c\\"]] assert generate_combinations([3, 1, 2], 2) == [[1, 2], [1, 3], [2, 3]] ``` Ensure your implementation handles edge cases and runs efficiently.","solution":"from itertools import combinations def generate_combinations(arr, k): Generate all unique combinations of length k from a given list arr. Parameters: arr (list): The list of elements. k (int): The length of each combination. Returns: list of lists: A list of unique combinations sorted lexicographically. # Sort the input array to ensure lexicographic order in combinations arr_sorted = sorted(arr) # Generate all combinations of length k comb = list(combinations(arr_sorted, k)) # Convert to the required format (list of lists) return [list(c) for c in comb]"},{"question":"# Question You are given two functions, `find_sum_iterative` and `find_sum_recursive`, which find the sum of all elements in a list of numbers using iterative and recursive methods respectively. Beyond summing all elements, another crucial application is summing elements within a certain range of indices under specific conditions. Implement a function named `find_range_sum` that calculates the sum of elements within a specific range `[start, end)` in an array of numbers using the recursive divide-and-conquer strategy. Unlike the provided `find_sum_recursive`, this function should handle subranges more flexibly. # Requirements * **Function Signature**: `def find_range_sum(nums: list[int | float], start: int, end: int) -> int | float:` * **Parameters**: - `nums`: A list of integers or floats. - `start`: An integer representing the starting index (inclusive) of the range. - `end`: An integer representing the ending index (exclusive) of the range. * **Returns**: The sum of the values within the specified range. # Constraints 1. The list `nums` will not be empty. 2. The indices `start` and `end` will be within the bounds of the list and valid (i.e., 0 <= start < end <= len(nums)). 3. The function should be implemented using a recursive approach and must have a time complexity no worse than O(n), with n being the number of elements within the specified range. # Example ```python nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(find_range_sum(nums, 2, 8)) # Output should be 27 print(find_range_sum(nums, 0, 3)) # Output should be 8 print(find_range_sum(nums, 4, 10)) # Output should be 30 ``` # Implementation Guidelines * Use a similar approach to `find_sum_recursive`, but modify it to work within the specified subrange `[start, end)`. * Handle the base and recursive cases appropriately. * Ensure that you properly handle and raise necessary errors for invalid inputs.","solution":"def find_range_sum(nums: list[int | float], start: int, end: int) -> int | float: Recursively calculates the sum of elements within the range [start, end) in nums. # Base case: when the start is equal to or greater than end, return 0 if start >= end: return 0 # Base case: when the range has only one element if end - start == 1: return nums[start] # Midpoint calculation to divide the range mid = (start + end) // 2 # Recursively calculate the sums for the divided ranges left_sum = find_range_sum(nums, start, mid) right_sum = find_range_sum(nums, mid, end) return left_sum + right_sum"},{"question":"# Context: You are tasked with adding new features to a binary search tree (BST) class. The class should be able to handle standard operations efficiently while maintaining its properties. The new features include methods for finding the height of the tree, and for converting the BST into a sorted array. # Problem: 1. Write a method `height(self)` that computes the height of the binary search tree. The height of a tree with only a root node is 0, and an empty tree has a height of -1. 2. Write a method `to_sorted_array(self)` that returns a sorted list of all elements in the binary search tree. # Implementation Details: - Class definition: `class BinarySearchTree:` - Each node in the tree is an instance of the `TreeNode` class: ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None ``` - Methods to implement in the `BinarySearchTree` class: * `def height(self):` * `def to_sorted_array(self):` # Input: - `height()` takes no parameters. - `to_sorted_array()` takes no parameters. # Output: - `height()` returns an integer representing the height of the binary search tree. - `to_sorted_array()` returns a list of elements sorted in ascending order. # Constraints: - The elements of the tree are unique integers. - You may assume that the tree contains at least one element before calling these methods. - Do not use any built-in libraries or functions for sorting. # Performance Requirements: - `height()` should have a time complexity of O(n), where n is the number of nodes in the tree. - `to_sorted_array()` should have a time complexity of O(n). # Example Usage: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) # Getting the height of the BST print(bst.height()) # Output: 2 # Converting the BST to a sorted array print(bst.to_sorted_array()) # Output: [3, 5, 7, 10, 12, 15, 18] ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def height(self): return self._height_recursive(self.root) def _height_recursive(self, node): if node is None: return -1 left_height = self._height_recursive(node.left) right_height = self._height_recursive(node.right) return 1 + max(left_height, right_height) def to_sorted_array(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result)"},{"question":"# Problem Statement You are required to implement a function that calculates the sum of unique items that appear an odd number of times in the given list. **Scenario**: You work as a software engineer in charge of data processing. You need to analyze a dataset and identify certain patterns. Specifically, you need a function that calculates the sum of elements that appear an odd number of times in a list. This function will help you filter out noise from your data processing pipeline efficiently. **Function Signature**: ```python def sum_of_odd_occurrences(nums: list) -> int: Given a list of integers, return the sum of elements that appear an odd number of times. Examples: >>> sum_of_odd_occurrences([1, 2, 3, 2, 3, 4, 1, 4, 4]) 4 >>> sum_of_odd_occurrences([10, 20, 10, 30, 20, 50, 30]) 50 pass ``` **Requirements**: 1. The function `sum_of_odd_occurrences(nums: list) -> int` should take a list of integers `nums` and return the sum of elements that appear an odd number of times in the list. 2. The function should handle edge cases where the list can be empty. **Constraints**: - The length of the input list `nums` will be in the range `0 <= len(nums) <= 10^5`. - Each integer in `nums` will be in the range `-10^9 <= nums[i] <= 10^9`. **Performance Requirements**: - The function should have an average time complexity of O(n). - The function should have a space complexity of O(n). **Input and Output Formats**: - **Input**: A list `nums` of integers. - **Output**: An integer representing the sum of elements that appear an odd number of times. **Examples**: ```python >>> sum_of_odd_occurrences([1, 2, 3, 2, 3, 4, 1, 4, 4]) 4 >>> sum_of_odd_occurrences([10, 20, 10, 30, 20, 50, 30]) 50 >>> sum_of_odd_occurrences([5, 5, 5, 5, 5]) 5 >>> sum_of_odd_occurrences([]) 0 ``` Implement the function to calculate the sum of elements with odd occurrences efficiently.","solution":"def sum_of_odd_occurrences(nums: list) -> int: from collections import Counter # Count occurrences of each number count = Counter(nums) # Sum up the numbers that have an odd count return sum(num for num, cnt in count.items() if cnt % 2 == 1)"},{"question":"# Question **Context**: You are working as a software developer for a logistics company. Your team is developing a route optimization tool to minimize delivery time for a fleet of vehicles. One crucial component of this tool is to find the shortest path between two locations in a given network of roads. **Task**: Implement Dijkstra\'s algorithm to find the shortest path between two nodes in a graph, represented by an adjacency list. **Function Signature**: ```python def dijkstra(graph: dict[str, dict[str, int]], start: str, end: str) -> list[str]: Args: - graph: A dictionary representing the adjacency list of the graph, where keys are node labels and values are dictionaries of adjacent nodes with edge weights. - start: A string representing the starting node. - end: A string representing the target node. Returns: - A list of strings representing the shortest path from the start node to the end node. If no path exists, return an empty list. ``` **Requirements**: 1. Implement the function `dijkstra` that takes in: * `graph`: A dictionary where the keys are node labels and values are dictionaries. Each of these inner dictionaries represents adjacent nodes and their edge weights. * `start`: A string representing the starting node. * `end`: A string representing the target node. 2. The function should return a list of node labels (strings) representing the shortest path from the start node to the end node. If the nodes are not connected, return an empty list. 3. Use the provided docstrings for testing with examples to ensure the correctness of your implementation. **Examples**: ```python >>> graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } >>> dijkstra(graph, \'A\', \'D\') [\'A\', \'B\', \'C\', \'D\'] >>> graph = { \'A\': {\'B\': 3}, \'B\': {\'C\': 1}, \'C\': {\'D\': 2}, \'D\': {} } >>> dijkstra(graph, \'A\', \'D\') [\'A\', \'B\', \'C\', \'D\'] >>> graph = { \'A\': {\'B\': 10}, \'B\': {\'C\': 10}, \'C\': {\'D\': 10}, \'D\': {} } >>> dijkstra(graph, \'A\', \'E\') [] ``` **Constraints**: * The graph can contain up to (10^4) nodes. * The edge weights are positive integers. * Node labels are strings and unique within the graph. Good luck, and happy coding!","solution":"import heapq def dijkstra(graph, start, end): Args: - graph: A dictionary representing the adjacency list of the graph, where keys are node labels and values are dictionaries of adjacent nodes with edge weights. - start: A string representing the starting node. - end: A string representing the target node. Returns: - A list of strings representing the shortest path from the start node to the end node. If no path exists, return an empty list. # Min-heap priority queue queue = [(0, start, [])] # Set to keep track of visited nodes visited = set() while queue: (cost, node, path) = heapq.heappop(queue) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for adjacent, weight in graph.get(node, {}).items(): if adjacent not in visited: heapq.heappush(queue, (cost + weight, adjacent, path)) return []"},{"question":"# Question: Implement a BoundedQueue with Average Operation Design a bounded queue data structure that supports the following operations: - `enqueue(val: int) -> None`: Adds an element to the end of the queue if there is space. - `dequeue() -> int`: Removes and returns the front element of the queue. - `is_empty() -> bool`: Checks if the queue is empty. - `is_full() -> bool`: Checks if the queue has reached its capacity. - `average() -> float`: Returns the average value of the elements in the queue. Function Signature: ```python class BoundedQueue: def __init__(self: BoundedQueue, capacity: int) -> None: pass def enqueue(self: BoundedQueue, val: int) -> None: pass def dequeue(self: BoundedQueue) -> int: pass def is_empty(self: BoundedQueue) -> bool: pass def is_full(self: BoundedQueue) -> bool: pass def average(self: BoundedQueue) -> float: pass ``` # Constraints: - Use the Queue implementation mentioned in the provided snippet. - Ensure that the `average()` operation runs in constant time O(1). - Assume all elements are integers and capacity is a positive integer greater than zero. # Example: ```python bq = BoundedQueue(capacity=3) bq.enqueue(4) bq.enqueue(8) bq.enqueue(6) print(bq.average()) # Output: 6.0 bq.dequeue() bq.enqueue(10) print(bq.average()) # Output: 8.0 ```","solution":"class BoundedQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [] self.current_sum = 0 def enqueue(self, val: int) -> None: if not self.is_full(): self.queue.append(val) self.current_sum += val def dequeue(self) -> int: if not self.is_empty(): val = self.queue.pop(0) self.current_sum -= val return val else: return None def is_empty(self) -> bool: return len(self.queue) == 0 def is_full(self) -> bool: return len(self.queue) == self.capacity def average(self) -> float: if self.is_empty(): return 0.0 return self.current_sum / len(self.queue)"},{"question":"# Question **Context**: You are tasked with optimizing a feature in your company\'s product that deals with large collections of text data, specifically the need to quickly lookup the frequency of words within a given text dataset. **Goal**: Your task is to implement an efficient algorithm to count the frequency of each word in a given list of strings. **Function to Implement**: ```python def word_count(texts: list[str]) -> dict: Counts the frequency of each word in the list of strings and returns a dictionary with words as keys and their respective counts as values. :param texts: list of strings containing words separated by whitespace :return: a dictionary with words as keys and their counts as values ``` **Input**: - A list of strings, `texts`, where 1 <= len(texts) <= 10^4 and each string has a length of 1 <= |text[i]| <= 10^5. **Output**: - Return a dictionary where keys are words and values are the respective frequencies of those words in the combined word list from all strings. **Constraints**: - Words consist of only lowercase alphabetic characters and are separated by whitespace. - The solution should have a time complexity of O(n), where n is the total number of words across all the input strings. - Do not use any libraries that directly perform word counts. **Example**: ```python >>> word_count([\\"the quick brown fox\\", \\"the quick\\", \\"fox jumps over the lazy dog\\"]) {\'the\': 3, \'quick\': 2, \'brown\': 1, \'fox\': 2, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} >>> word_count([\\"hello world\\", \\"world of code\\", \\"hello hello\\"]) {\'hello\': 3, \'world\': 2, \'of\': 1, \'code\': 1} ``` **Hint**: - Consider using a dictionary to store the word counts and update the counts by iterating through each word in every string.","solution":"def word_count(texts: list[str]) -> dict: Counts the frequency of each word in the list of strings and returns a dictionary with words as keys and their respective counts as values. :param texts: list of strings containing words separated by whitespace :return: a dictionary with words as keys and their counts as values word_freq = {} # Dictionary to store word frequencies for text in texts: words = text.split() # Split the string into words for word in words: if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 return word_freq"},{"question":"# Budget Optimization for Classroom Supplies Scenario You are in charge of budgeting for classroom supplies and need to ensure that each class receives the necessary items without exceeding the budget. Each class has different requirements, and items can have varying costs. Your task is to determine whether or not you can distribute the supplies within the given budget. Task Implement a function `can_allocate_supplies` that determines if it\'s possible to allocate supplies for all the classes without exceeding the budget. Each class has a list of required items, each item having a specific cost. Function Signature ```python def can_allocate_supplies(budget: float, classes: list[list[float]]) -> bool: pass ``` Parameters - `budget (float)`: The total available budget. - `classes (list[list[float]])`: A list of classes, where each class is represented as a list of floats representing the cost of required items. Returns - `bool`: Returns `True` if the items can be allocated within the budget, otherwise returns `False`. Constraints - The budget value should be non-negative. - Costs of items should be non-negative floats. - If the total cost of supplies exceeds the budget, the function should return `False`. Examples - `can_allocate_supplies(budget=100.0, classes=[[20.0, 30.0], [10.0, 15.0, 25.0]])` should return `True` - `can_allocate_supplies(budget=50.0, classes=[[20.0, 30.0], [10.0, 15.0, 25.0]])` should return `False` - `can_allocate_supplies(budget=75.0, classes=[[10.0, 15.0], [20.0, 5.0], [10.0, 10.0]])` should return `True` - `can_allocate_supplies(budget=0.0, classes=[[10.0, 15.0], [20.0, 5.0]])` should return `False`","solution":"def can_allocate_supplies(budget: float, classes: list[list[float]]) -> bool: Determines if it\'s possible to allocate supplies for all classes without exceeding the budget. Parameters: budget (float): The total available budget. classes (list[list[float]]): A list of classes, where each class is represented as a list of floats representing the cost of required items. Returns: bool: True if the items can be allocated within the budget, otherwise False. total_cost = 0.0 for class_items in classes: total_cost += sum(class_items) # Early exit if we exceed the budget if total_cost > budget: return False return total_cost <= budget"},{"question":"**Scenario**: You are working on a banking application that needs to store user transaction history in a simplified format for analysis. Each transaction record contains an identifier, the amount, and a timestamp. To efficiently manage and retrieve this data, you decide to use a custom data structure that supports the addition of new transactions and the retrieval of the transaction with the highest amount. **Task**: Write a class implementation to manage the transaction records. Your class should be named `TransactionManager` and include the following methods: 1. `add_transaction(id: int, amount: float, timestamp: str) -> None` 2. `get_max_transaction() -> dict` Each method should: - `add_transaction`: Store a new transaction with the given identifier, amount, and timestamp. - `get_max_transaction`: Return a dictionary representing the transaction with the highest amount. If there are multiple transactions with the same highest amount, return the earliest one by timestamp. # Constraints 1. The transaction identifier `id` is a positive integer. 2. The transaction amount `amount` is a positive floating-point number. 3. The timestamp `timestamp` is a string in the format \\"YYYY-MM-DD HH:MM:SS\\". 4. You can assume that the `add_transaction` method will be called multiple times before any call to `get_max_transaction`. # Requirements 1. Ensure the implementation can handle an arbitrary number of transactions efficiently. 2. Provide error handling for potential issues, such as invalid input data. 3. When transactions have the same amount, the one with the earliest timestamp should be considered. # Expected Input and Output Format * **add_transaction(id: int, amount: float, timestamp: str) -> None** - **Input**: `add_transaction(1, 100.0, \\"2023-01-01 10:00:00\\")` - **Output**: None * **get_max_transaction() -> dict** - **Input**: `get_max_transaction()` - **Output**: `{\\"id\\": 1, \\"amount\\": 100.0, \\"timestamp\\": \\"2023-01-01 10:00:00\\"}` # Performance 1. The solution should be optimized to efficiently handle retrieval of the maximum transaction. # Example: ```python tm = TransactionManager() tm.add_transaction(1, 100.0, \\"2023-01-01 10:00:00\\") tm.add_transaction(2, 200.0, \\"2023-01-02 12:00:00\\") tm.add_transaction(3, 150.0, \\"2023-01-03 15:00:00\\") tm.add_transaction(4, 200.0, \\"2023-01-01 09:00:00\\") print(tm.get_max_transaction()) # Output: {\\"id\\": 4, \\"amount\\": 200.0, \\"timestamp\\": \\"2023-01-01 09:00:00\\"} ``` In this example, despite there being two transactions with the amount of 200.0, the transaction with ID 4 is returned because it has the earliest timestamp.","solution":"class TransactionManager: def __init__(self): self.transactions = [] def add_transaction(self, id: int, amount: float, timestamp: str) -> None: if id <= 0 or amount <= 0: raise ValueError(\\"Transaction ID and amount must be positive.\\") transaction = {\\"id\\": id, \\"amount\\": amount, \\"timestamp\\": timestamp} self.transactions.append(transaction) def get_max_transaction(self) -> dict: if not self.transactions: return None max_transaction = max(self.transactions, key=lambda x: (x[\\"amount\\"], -self._convert_to_timestamp(x[\\"timestamp\\"]))) return max_transaction def _convert_to_timestamp(self, timestamp: str) -> int: from datetime import datetime dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") return int(dt.timestamp())"},{"question":"# Coding Challenge: In-place Merge Sort for Linked Lists # Context: Merge Sort is an efficient, stable, comparison-based, divide-and-conquer sorting algorithm. It works by recursively dividing the list into halves, sorting each half, and then merging the sorted halves. When dealing with linked lists, an in-place merge sort can be particularly effective because it avoids the need for additional memory to store the lists during the merging process. # Task: Your task is to implement an in-place merge sort that works on singly linked lists. This exercise will help you understand the principles of recursive algorithms, linked list manipulation, and in-place sorting techniques. # Requirements: 1. Define a `Node` class to represent elements in the singly linked list. 2. Implement an in-place merge sort function that accepts the head of a singly linked list and returns the head of a sorted linked list. 3. Ensure your function handles edge cases such as an empty list and a single-element list. 4. Maintain the stability of the sorting algorithm (the relative order of equal elements must be preserved). # Input: - The head node of a singly linked list. # Output: - The head node of the sorted linked list. # Constraints: - Do not use any built-in sorting functions or external libraries. - The function should have a time complexity of O(n log n), where n is the number of nodes in the linked list. # Function Signature: ```python class Node: def __init__(self, data=None, next=None): self.data = data self.next = next def merge_sort(head: Node) -> Node: pass ``` # Examples: ```python # Utility function to convert a list to a linked list def list_to_linked_list(lst): if not lst: return None head = Node(lst[0]) current = head for value in lst[1:]: current.next = Node(value) current = current.next return head # Utility function to convert a linked list to a list def linked_list_to_list(head): lst = [] current = head while current: lst.append(current.data) current = current.next return lst # Example usage: head = list_to_linked_list([0, 5, 2, 3, 2]) sorted_head = merge_sort(head) print(linked_list_to_list(sorted_head)) # [0, 2, 2, 3, 5] head = list_to_linked_list([]) sorted_head = merge_sort(head) print(linked_list_to_list(sorted_head)) # [] head = list_to_linked_list([-2, -45, -5]) sorted_head = merge_sort(head) print(linked_list_to_list(sorted_head)) # [-45, -5, -2] head = list_to_linked_list([1.1, 3.3, 5.5, 2.2, 4.4]) sorted_head = merge_sort(head) print(linked_list_to_list(sorted_head)) # [1.1, 2.2, 3.3, 4.4, 5.5] ``` **Note**: You are encouraged to write additional test cases to further validate your implementation. # Evaluation Criteria: - Correctness: Your code should correctly sort the linked list nodes. - Efficiency: Your code should have a time complexity of O(n log n). - Robustness: Your code should handle edge cases correctly. - Clarity: Your code should be clear and well-documented. # Implementation Tips: - You may define any helper functions you need. - Consider implementing a function to split the list into two halves. - Implement an in-place merge function to combine two sorted lists.","solution":"class Node: def __init__(self, data=None, next=None): self.data = data self.next = next def merge_sort(head: Node) -> Node: if not head or not head.next: return head # Function to split the linked list into two halves def split(head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return head, slow # Function to merge two sorted linked lists def merge(l1, l2): dummy = Node() tail = dummy while l1 and l2: if l1.data < l2.data: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next left, right = split(head) left = merge_sort(left) right = merge_sort(right) return merge(left, right)"},{"question":"# Problem Statement You are tasked with writing a function that determines the sum of all the numbers that can be written as the sum of the fifth powers of their digits. # Guidelines - Implement a function `sum_of_fifth_powers()` that returns the sum of all the numbers that can be written as the sum of the fifth powers of their digits. # Input and Output - **Input**: No direct input parameters. - **Output**: Return an integer representing the sum of all such numbers. # Constraints - Consider numbers greater than a single digit, as single-digit numbers are trivial solutions. # Example ```python def sum_of_fifth_powers() -> int: # Your implementation here # Example usage: assert sum_of_fifth_powers() == 443839 ``` # Description of Example In the provided example, the function calculates the sum of all numbers that can be expressed as the sum of the fifth powers of their digits. The function processes each number, checks if it equals the sum of the fifth powers of its digits, and sums these numbers to return the desired total. # Hints - Begin by iterating through a range of numbers. It\'s important to determine an upper limit for these numbers. - Use the properties of numbers and their digits to efficiently compute sums of powers. - Consider splitting the number into its individual digits and summing their fifth powers to check for equality with the original number. - Be mindful of performance constraints when checking large ranges of numbers. # Example Walkthrough For instance, 4150 can be written as (4^5 + 1^5 + 5^5 + 0^5), which sums to 4150. Similarly, 4151 can be written as (4^5 + 1^5 + 5^5 + 1^5), which sums to 4151. These numbers are part of the summation set that the function needs to identify and sum. The solution should validate and count such numbers within a feasible range, ensuring that all potential numbers are considered.","solution":"def sum_of_fifth_powers() -> int: def fifth_power_sum(n): return sum(int(digit) ** 5 for digit in str(n)) # Since n-digit number\'s upper bound is 9^5 * n, let\'s find a reasonable limit. limit = 9 ** 5 * 6 # Covering up to six-digit numbers should be safe. result = [] for num in range(2, limit): if num == fifth_power_sum(num): result.append(num) return sum(result)"},{"question":"# Problem Statement You are given an array `arr` of integers where elements are sorted in ascending order. Your task is to implement a function `find_range` that finds the starting and ending position of a given target value `key` in the sorted array. If the target is not found, return `[-1, -1]`. # Function Signature ```python def find_range(arr: list[int], key: int) -> list[int]: pass ``` # Input * `arr` (list[int]): A list of integers sorted in ascending order. * `key` (int): The target value to be found in the array. # Output * A list `[start, end]` where `start` and `end` are the 0-based indices of the target\'s starting and ending position in the array. * If the target is not found, return `[-1, -1]`. # Constraints * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i], key <= 10^9` # Example ```python arr = [1, 2, 2, 2, 3, 4, 5, 5, 6] print(find_range(arr, 2)) # Output: [1, 3] print(find_range(arr, 5)) # Output: [6, 7] print(find_range(arr, 7)) # Output: [-1, -1] ``` # Explanation - In the first example, the key `2` is found from index `1` to `3`. - In the second example, the key `5` is found from index `6` to `7`. - In the third example, the key `7` is not found in the array, so it returns `[-1, -1]`. Implement the `find_range` function such that it meets the requirements and constraints specified.","solution":"def find_range(arr, key): # Helper function to find the first occurrence of key def find_first(arr, key): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < key: left = mid + 1 elif arr[mid] > key: right = mid - 1 else: right = mid - 1 return left if left < len(arr) and arr[left] == key else -1 # Helper function to find the last occurrence of key def find_last(arr, key): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < key: left = mid + 1 elif arr[mid] > key: right = mid - 1 else: left = mid + 1 return right if right >= 0 and arr[right] == key else -1 start = find_first(arr, key) if start == -1: return [-1, -1] end = find_last(arr, key) return [start, end]"},{"question":"# Coding Challenge: Detect Cycles in a Directed Graph Scenario: You are working on a project involving task dependencies. Each task can depend on another task to be completed first, forming a directed graph. Your goal is to determine if there are any cyclic dependencies among tasks, i.e., whether it\'s possible to complete all tasks or if the tasks are stuck in a circular dependency. Task: Implement a function `detect_cycle` that takes the number of tasks (nodes) and their dependencies (edges) as input and returns `True` if there is any cycle in the graph, otherwise returns `False`. Function Signature: ```python def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: ``` Input: - `n` (int): The number of tasks (nodes) in the dependency graph. - `edges` (list of tuples of int): Each tuple (u, v) represents a directed edge from task u to task v, indicating that task u must be completed before task v. Output: - `bool`: `True` if there is a cycle in the graph, `False` otherwise. Constraints: - `1 <= n <= 10^4` (number of nodes) - `0 <= len(edges) <= 5 * 10^4` (number of edges) - Task IDs (nodes) are numbered from 0 to n-1. Example: ```python n = 5 edges = [(0, 1), (1, 2), (2, 0), (3, 4)] print(detect_cycle(n, edges)) # Expected Output: True n = 4 edges = [(0, 1), (1, 2), (2, 3)] print(detect_cycle(n, edges)) # Expected Output: False ``` Requirements: - Use Depth-First Search (DFS) or any other suitable graph traversal algorithm to detect the cycle. - Ensure that your function runs efficiently with the provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like an empty graph (n = 0, edges = []), self-loops, and multiple disjoint subgraphs. - Make sure to handle graphs with no edges gracefully.","solution":"def detect_cycle(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n def dfs(node): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"# Question Scenario You are tasked with implementing a function to determine the shortest path in an undirected graph. The graph is represented as an adjacency list where the nodes are identified by unique integers, starting from 0. Each edge has a positive weight. Your implementation should efficiently handle large inputs while ensuring the correctness of the shortest path calculation using Dijkstra\'s algorithm. Task Write a Python function `shortest_path` that finds the shortest path from a starting node to all other nodes in the graph. Function Specification ```python def shortest_path(adj_list, start): Computes the shortest paths from the start node to all other nodes in the graph. Args: adj_list (dict): A dictionary representing the graph, where keys are node identifiers (ints), and values are lists of tuples (neighbor, weight) representing the edges. start (int): The starting node identifier. Returns: dict: A dictionary where keys are node identifiers and values are the shortest distance from the start node. ``` Constraints - `adj_list` is guaranteed to represent a connected graph. - The graph contains between 1 and 1000 nodes. - Edge weights are positive integers. Example ```python adj_list = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 1)], 2: [(0, 1), (1, 2), (3, 5)], 3: [(1, 1), (2, 5)] } start = 0 assert shortest_path(adj_list, start) == {0: 0, 1: 3, 2: 1, 3: 4} ``` Performance Requirements - The function should handle graphs with up to 1000 nodes and 10,000 edges efficiently. - Memory usage should remain within typical bounds for a personal computer when handling the largest size input.","solution":"import heapq def shortest_path(adj_list, start): Computes the shortest paths from the start node to all other nodes in the graph. Args: adj_list (dict): A dictionary representing the graph, where keys are node identifiers (ints), and values are lists of tuples (neighbor, weight) representing the edges. start (int): The starting node identifier. Returns: dict: A dictionary where keys are node identifiers and values are the shortest distance from the start node. # Initialize the shortest paths dictionary with infinite distances shortest_paths = {node: float(\'inf\') for node in adj_list} shortest_paths[start] = 0 # Use a priority queue to store (distance, node) tuples priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is larger than the stored shortest path, skip processing if current_distance > shortest_paths[current_node]: continue # Update distances for adjacent nodes for neighbor, weight in adj_list[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths"},{"question":"# Sort Elements by Frequency **Objective**: Write a function to sort the elements of an array based on their frequency in descending order. If two elements have the same frequency, the element that appears first in the array should come first. Problem Statement: You are given an array of integers. Your task is to sort the elements of the array in descending order based on their frequency of occurrence. If two elements have the same frequency, the one that appears first in the array should come first. Function Signature ```python def sort_by_frequency(arr: list[int]) -> list[int]: Sort elements by frequency in descending order. Parameters ---------- arr: list of integers. A list containing integers. Returns ------- list of integers: A list of integers sorted based on the frequency of occurrence in descending order. If two elements have the same frequency, the one that appears first in the array should come first. ``` Input: * `arr`: A list of integers. Output: * A list of integers sorted based on their frequency in descending order. If two elements have the same frequency, the one that appears first in the array should come first. Constraints: * The elements of the array can be any integers, including negative numbers. * The input list may contain zero or more integers. Edge Cases: * If the `arr` list is empty, return an empty list. * If the `arr` list contains only one element, return the list as is. Example: ```python >>> sort_by_frequency([4, 5, 6, 5, 4, 3]) [4, 4, 5, 5, 6, 3] >>> sort_by_frequency([1, 2, 3, 4, 4, 5, 5, 5]) [5, 5, 5, 4, 4, 1, 2, 3] >>> sort_by_frequency([1]) [1] >>> sort_by_frequency([]) [] ``` Additional Information: Ensure that your function is optimized to handle large datasets efficiently and includes the necessary checks to handle edge cases such as an empty input list. Consider using data structures that facilitate frequency counting and sorting according to the specified rules.","solution":"def sort_by_frequency(arr): Sort elements by frequency in descending order. Parameters ---------- arr: list of integers. A list containing integers. Returns ------- list of integers: A list of integers sorted based on the frequency of occurrence in descending order. If two elements have the same frequency, the one that appears first in the array should come first. from collections import Counter if not arr: return [] # Count frequency of each element freq = Counter(arr) # Sort based on frequency and first appearance in the array sorted_arr = sorted(arr, key=lambda x: (-freq[x], arr.index(x))) return sorted_arr"},{"question":"# Coding Challenge: Optimizing Integer Matrix Search Given an `m x n` matrix of integers, where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom, optimize a search function that checks if a given integer exists in the matrix. # Task Optimize the `search_matrix` method to reduce its execution time while maintaining its algorithmic complexity. Ensure that the code efficiently handles large matrices by minimizing unnecessary element comparisons. # Function Signature ```python def search_matrix(matrix: list[list[int]], target: int) -> bool: ``` # Inputs - `matrix`: A list of lists of integers representing the matrix, with dimensions `m` x `n`. - `target`: An integer to be searched in the matrix. # Outputs - Returns a boolean indicating whether the `target` exists in the matrix. # Constraints 1. The input matrix will have dimensions such that `1 <= m, n <= 300`. 2. The matrix is sorted such that each row is sorted from left to right and each column is sorted from top to bottom. 3. All elements of the matrix and the target are integers. # Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 print(search_matrix(matrix, target)) # Expected Output: True target = 20 print(search_matrix(matrix, target)) # Expected Output: False ``` # Additional Information - A naive search would check each element, resulting in O(m * n) complexity. Instead, aim for an algorithm with better efficiency. - Leverage the sorted property of the rows and columns for an efficient search strategy. # Hints - Utilize a `divide-and-conquer` or `binary search` approach to exploit the matrix\'s sorted properties. - A common efficient strategy involves starting from the top-right or bottom-left corner and making comparisons to narrow down the search space.","solution":"def search_matrix(matrix: list[list[int]], target: int) -> bool: Search for a target value in a sorted matrix. :param matrix: List of lists of integers representing the matrix. :param target: Integer target to search for in the matrix. :return: Boolean indicating whether the target exists in the matrix. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"# Question: Implement a Linear Regression Model with Regularization Your task is to enhance the `LinearRegression` class by adding support for L1 (Lasso) and L2 (Ridge) regularization. You will implement both penalties and allow the user to specify the regularization type and strength. Requirements: 1. Update the `LinearRegression` class to handle two new regularization types: \\"lasso\\" (L1) and \\"ridge\\" (L2). 2. Add a new parameter to the `LinearRegression` initializer: `regularization` (default None), which specifies the type of regularization. 3. Add another parameter: `alpha` (default 1.0), which specifies the regularization strength. 4. Implement the fitting process according to the chosen regularization type. - For \\"lasso\\", use the L1 regularization term: ( text{alpha} cdot sum_{i=1}^{n} |w_i| ) - For \\"ridge\\", use the L2 regularization term: ( text{alpha} cdot sum_{i=1}^{n} w_i^2 ) 5. Implement the predict method to output the predicted values using the learned weights. 6. Add appropriate validation checks for the new parameters. Input: - Features: A 2D ndarray where each row represents the feature vector of a training data point. - Targets: A 1D ndarray of continuous values representing the target variable for each training data point. - A single test observation: A 1D ndarray representing a new data point to predict. Output: - Predicted target: A continuous value corresponding to the predicted target of the input observation. Constraints: - Inputs to the `fit` method can have up to 10,000 observations with up to 100 features each. - The `predict` method must be implemented to handle new observations with the same dimensionality as the training data. # Example: ```python # Define your LinearRegression class with regularization here. class LinearRegression: def __init__(self, regularization=None, alpha=1.0): self.regularization = regularization self.alpha = alpha self.weights = None def fit(self, features, targets): # Implement the fitting process with optional regularization pass def predict(self, observation): # Implement the prediction process using the learned weights pass # Initialize the LinearRegression with Lasso regularization lr = LinearRegression(regularization=\\"lasso\\", alpha=0.1) # Fit the LinearRegression with training data features = np.array([ [1, 1], [2, 2], [3, 3], [4, 4] ]) targets = np.array([2, 4, 6, 8]) lr.fit(features, targets) # Predict a new observation new_observation = np.array([5, 5]) print(lr.predict(new_observation)) # Expected output: 10 (example) ``` Ensure your code meets these requirements and passes the provided example tests.","solution":"import numpy as np class LinearRegression: def __init__(self, regularization=None, alpha=1.0): self.regularization = regularization self.alpha = alpha self.weights = None def fit(self, features, targets): n_samples, n_features = features.shape X = np.c_[np.ones((n_samples, 1)), features] if self.regularization is None: self.weights = np.linalg.pinv(X.T @ X) @ X.T @ targets elif self.regularization == \'ridge\': I = np.eye(n_features + 1) I[0, 0] = 0 self.weights = np.linalg.pinv(X.T @ X + self.alpha * I) @ X.T @ targets elif self.regularization == \'lasso\': self.weights = self._lasso(X, targets, self.alpha) else: raise ValueError(\\"Unsupported regularization type. Supported values are None, \'ridge\' and \'lasso\'\\") def predict(self, observation): if self.weights is None: raise ValueError(\\"The model has not been trained yet.\\") X_new = np.r_[1, observation] return X_new @ self.weights def _lasso(self, X, y, alpha, tol=1e-4, max_iter=1000): n_samples, n_features = X.shape w = np.zeros(n_features) for _ in range(max_iter): w_old = w.copy() for j in range(n_features): X_j = X[:, j] residual = y - X @ w + X_j * w[j] rho = X_j.T @ residual if j == 0: w[j] = rho / (X_j.T @ X_j) else: if rho < -alpha / 2: w[j] = (rho + alpha / 2) / (X_j.T @ X_j) elif rho > alpha / 2: w[j] = (rho - alpha / 2) / (X_j.T @ X_j) else: w[j] = 0 if np.sum(np.abs(w - w_old)) < tol: break return w"},{"question":"**Question:** You are asked to write a function that finds the smallest positive integer `n` such that the value of `n^3` contains all the digits from 0 to 9 at least once. Instead of brute-forcing through every integer, consider an optimized strategy to narrow down potential candidates and quickly check if their cube contains all required digits. # Task: Implement an efficient function `find_smallest_cube()` that determines and returns the smallest integer `n` whose cube (`n^3`) contains all the digits from 0 to 9. # Input: None. The function does not require any parameters. # Output: - **Return Type**: Integer - **Description**: The smallest integer `n` whose cube contains all digits from 0 to 9 at least once. # Constraints and Notes: - You should implement checks to verify that all digits from 0 to 9 are present in the cube of the number. - You need to ensure the solution is efficient enough to handle large numbers and completes within a reasonable time. # Example: If implemented correctly, the function should return the smallest integer `Answer` such that `Answer^3` contains all digits from 0 to 9 at least once. ```python def find_smallest_cube() -> int: # implement the function here pass if __name__ == \\"__main__\\": result = find_smallest_cube() print(result) # Should print the smallest integer n whose cube contains all digits from 0 to 9 ``` You will need to iterate through potential candidates efficiently and implement any auxiliary functions within `find_smallest_cube` as required.","solution":"def contains_all_digits(number): Helper function to check if the number contains all digits from 0 to 9 at least once. digits = set(str(number)) return len(digits) == 10 and all(str(d) in digits for d in range(10)) def find_smallest_cube(): Find the smallest positive integer n such that its cube contains all the digits from 0 to 9 at least once. n = 1 while True: cube = n ** 3 if contains_all_digits(cube): return n n += 1"},{"question":"# Scenario: You are working on a string manipulation module for a text processing application. One of the features you need to implement is to parse and evaluate a sequence of arithmetic operations represented in prefix notation (also known as Polish notation). In prefix notation, operators precede their operands. For example, the expression `+ 3 * 2 2` evaluates to `7` because it represents `3 + (2 * 2)`. Given the function skeleton below, implement the prefix evaluation logic. # Function Specification **Function name**: `evaluate_prefix` **Input**: - `expression` (str): The arithmetic expression in prefix notation, consisting of integers and the operators `+`, `-`, `*`, and `/`. **Output**: - (int or float): The result of evaluating the arithmetic expression. **Constraints**: - The input expression is guaranteed to be valid. - The function should be implemented with a time complexity of O(n), where n is the length of the string. - Division should use integer division if the result is an integer otherwise return a float. **Examples**: ```python >>> evaluate_prefix(\'+ 3 * 2 2\') 7 >>> evaluate_prefix(\'- * 10 5 / 3 1\') 47 >>> evaluate_prefix(\'/ - + 7 2 3 1\') 6.0 >>> evaluate_prefix(\'/ + 7 3 2\') 5 ``` # Task: Complete the implementation of the `evaluate_prefix` function to correctly compute the result of the arithmetic expression given in prefix notation.","solution":"def evaluate_prefix(expression: str): Evaluates an arithmetic expression in prefix notation. Parameters: expression (str): The arithmetic expression in prefix notation. Returns: int or float: The result of evaluating the arithmetic expression. # Split the expression into tokens tokens = expression.split() # Reverse the tokens for easier stack manipulation tokens = tokens[::-1] def helper(stack): token = stack.pop() if token in \\"+-*/\\": left = helper(stack) right = helper(stack) if token == \'+\': return left + right elif token == \'-\': return left - right elif token == \'*\': return left * right elif token == \'/\': # Use integer division if result is an integer result = left / right return int(result) if result.is_integer() else result else: return int(token) return helper(tokens)"},{"question":"Elevator Control System Simulation In this exercise, you are required to simulate an elevator control system for a building with multiple floors. The elevator responds to requests by moving to the requested floor in an efficient manner. Detailed Specifications 1. You need to implement the `ElevatorControlSystem` class with the following methods: ```python class ElevatorControlSystem: def __init__(self, number_of_floors: int): # Initialize the system with the given number of floors ... def request_up(self, floor: int) -> None: # Simulate a request to go up from the given floor ... def request_down(self, floor: int) -> None: # Simulate a request to go down from the given floor ... def move(self) -> None: # Move the elevator one step towards the next target floor ... def get_current_floor(self) -> int: # Return the elevator\'s current floor ... def get_requests(self) -> List[int]: # Return a list of all floors with active requests ... ``` 2. The system should prioritize moving in one direction until all requests in that direction are handled, then switch direction if needed. Input and Output Formats * **Input**: - `number_of_floors` (integer): Total number of floors in the building. - `request_up(floor)` (integer): Request to call the elevator to the given floor to go up. - `request_down(floor)` (integer): Request to call the elevator to the given floor to go down. - `move()` (method): Move the elevator one step towards the next target floor. - `get_current_floor()` (method): Return the current floor of the elevator. - `get_requests()` (method): Return a list of all floors that have active requests. * **Output**: - The `get_current_floor()` method should return the current floor of the elevator. - The `get_requests()` method should return the list of all floors with active requests. Constraints * The number of floors should be a positive integer, greater than or equal to 2. * Requested floors for `request_up` and `request_down` should be valid floor numbers within the range of available floors. Example Usage ```python elevator_system = ElevatorControlSystem(10) elevator_system.request_up(3) elevator_system.request_down(7) elevator_system.move() # elevator moves towards floor 3 print(elevator_system.get_current_floor()) # returns 1 (assuming starting at ground floor 0) elevator_system.move() # elevator moves to floor 3 print(elevator_system.get_current_floor()) # returns 2 elevator_system.move() # elevator reaches floor 3, doors open and close elevator_system.move() # elevator now moves towards floor 7 print(elevator_system.get_current_floor()) # returns 4 print(elevator_system.get_requests()) # returns [7] ``` Implement the `ElevatorControlSystem` class to meet the specifications mentioned above.","solution":"class ElevatorControlSystem: def __init__(self, number_of_floors): Initialize the system with the given number of floors. self.number_of_floors = number_of_floors self.current_floor = 0 # assume ground floor as 0 self.requests = set() self.direction = None # can be \\"up\\" or \\"down\\" def request_up(self, floor): Simulate a request to go up from the given floor. if 0 <= floor < self.number_of_floors: self.requests.add(floor) self._set_direction() def request_down(self, floor): Simulate a request to go down from the given floor. if 0 <= floor < self.number_of_floors: self.requests.add(floor) self._set_direction() def move(self): Move the elevator one step towards the next target floor. if not self.requests: return next_floor = self._get_next_floor() if next_floor is not None: if self.current_floor < next_floor: self.current_floor += 1 elif self.current_floor > next_floor: self.current_floor -= 1 if self.current_floor == next_floor: self.requests.remove(next_floor) self._set_direction() def get_current_floor(self): Return the elevator\'s current floor. return self.current_floor def get_requests(self): Return a list of all floors with active requests. return sorted(list(self.requests)) def _set_direction(self): Set the direction of the elevator. if not self.requests: self.direction = None elif self.current_floor < min(self.requests): self.direction = \\"up\\" elif self.current_floor > max(self.requests): self.direction = \\"down\\" else: self.direction = \\"up\\" if self.current_floor <= max( floor for floor in self.requests if floor != self.current_floor ) else \\"down\\" def _get_next_floor(self): Get the next target floor based on the current direction. if self.direction == \\"up\\": floors_above = sorted(floor for floor in self.requests if floor > self.current_floor) return floors_above[0] if floors_above else None elif self.direction == \\"down\\": floors_below = sorted((floor for floor in self.requests if floor < self.current_floor), reverse=True) return floors_below[0] if floors_below else None return None"},{"question":"# Merge Intervals with Custom Merge Condition Objective: Implement a data structure that can merge intervals based on a custom merging condition. Description: You are required to write a data structure that supports the insertion of intervals and efficiently merges them according to a custom merging condition. The merging condition combines two intervals if the sum of their lengths does not exceed a specified threshold. Requirements: * Define the data structure to handle interval insertion and merging. * Implement functions to: * Insert a new interval. * Retrieve all merged intervals. Function Signatures: ```python class MergeIntervals: def __init__(self, threshold: int) -> None: Initialize the data structure with the provided threshold. pass def insert(self, interval: Tuple[int, int]) -> None: Insert a new interval and merge if conditions are met. pass def get_intervals(self) -> List[Tuple[int, int]]: Return the list of merged intervals. pass ``` Example: ```python # Initializing the MergeIntervals with a threshold of 5 mi = MergeIntervals(5) # Inserting intervals mi.insert((1, 2)) mi.insert((3, 4)) mi.insert((5, 7)) # Retrieve the merged intervals # The intervals (1, 2) and (3, 4) will be merged because the total length is 4, # which is less than or equal to the threshold 5. assert mi.get_intervals() == [(1, 4), (5, 7)] # Inserting another interval mi.insert((8, 10)) # Now (5, 7) and (8, 10) will be merged since the total length is also 5. assert mi.get_intervals() == [(1, 4), (5, 10)] ``` Constraints: * The intervals will consist of non-negative integers. * Intervals will be given in the form `(start, end)` where `start <= end`. * The threshold will be a positive integer. * The number of intervals inserted will not exceed 10^5. This additional question maintains the complexity and scope while introducing a unique problem focused on interval merging with a custom condition.","solution":"from typing import List, Tuple class MergeIntervals: def __init__(self, threshold: int) -> None: self.threshold = threshold self.intervals = [] def insert(self, interval: Tuple[int, int]) -> None: self.intervals.append(interval) self.intervals.sort() self._merge_intervals() def _merge_intervals(self) -> None: merged = [] for interval in self.intervals: if not merged: merged.append(interval) else: last = merged[-1] if last[1] >= interval[0] - 1: # Overlapping or contiguous if last[1] - last[0] + interval[1] - interval[0] + 1 <= self.threshold: # Merge intervals new_interval = (last[0], max(last[1], interval[1])) merged[-1] = new_interval else: merged.append(interval) else: merged.append(interval) self.intervals = merged def get_intervals(self) -> List[Tuple[int, int]]: return self.intervals"},{"question":"# Problem Statement You are given a dictionary where the keys are strings representing names of products and the values are lists of integers representing the daily sales for these products. Your task is to implement the `max_avg_sales_product` function that finds and returns the name of the product with the highest average daily sale. Function Signature ```python def max_avg_sales_product(sales_data: dict) -> str: pass ``` Input * `sales_data` (dict): A dictionary where keys are product names (strings), and values are lists of integers representing daily sales of the products, 0 < len(sales_data) <= 10^3, and each list has 0 < len(daily sales) <= 10^3 integers. Output * `str`: The name of the product with the highest average daily sale. Constraints * Ensure that the function handles a dictionary with varying sizes of sales lists efficiently. * If two or more products have the highest average daily sales, return any one of them. Performance Requirements * The solution should run in O(n) time complexity, where n is the number of products multiplied by the average length of sales lists. * Space complexity should be O(1) in terms of additional space used, apart from input storage. Scenario Consider a store where you have a record of daily sales for various products. Using your function, identify which product has the highest average sales over the recorded days. Example ```python # Example 1 sales_data = { \\"apple\\": [10, 20, 30], \\"banana\\": [5, 15, 25], \\"orange\\": [20, 30, 40], } # Explanation: The average sales are {\'apple\': 20, \'banana\': 15, \'orange\': 30} # The product with the highest average sale is \'orange\'. assert max_avg_sales_product(sales_data) == \\"orange\\" # Example 2 sales_data = { \\"item1\\": [7, 8, 9], \\"item2\\": [2, 3, 5], \\"item3\\": [9, 9, 9], } # Explanation: The average sales are {\'item1\': 8, \'item2\': 3.33, \'item3\': 9} # The product with the highest average sale is \'item3\'. assert max_avg_sales_product(sales_data) == \\"item3\\" ``` Notes * You may assume that the input dictionary\'s values are valid lists of non-negative integers. * Ensure the function efficiently handles large inputs within the constraints given.","solution":"def max_avg_sales_product(sales_data): max_avg = -1 product_with_max_avg = \\"\\" for product, sales in sales_data.items(): avg_sales = sum(sales) / len(sales) if avg_sales > max_avg: max_avg = avg_sales product_with_max_avg = product return product_with_max_avg"},{"question":"# Problem: Implement a Calendar Booking System You are tasked with implementing a calendar booking system where users can book and retrieve appointments. The system should efficiently handle overlapping appointments and avoid double bookings. Function 1: `book_appointment` Write a method `book_appointment(self, start: int, end: int) -> bool` that books an appointment if it does not overlap with any existing appointment. This method returns `True` if the booking is successful, and `False` if it conflicts with an existing appointment. Function 2: `get_appointments` Write a method `get_appointments(self) -> list` that retrieves all booked appointments as a list of tuples. Function 3: `find_next_available` Write a helper method `find_next_available(self, duration: int) -> tuple` that finds the next available slot of the specified duration. Function 4: `make_booking` Write a function `make_booking(duration: int) -> tuple | str` that books an appointment of the specified duration and returns a tuple of the appointed start and end times. If no suitable slot is found, return the string `\\"No available slot\\"`. Input * `start`: An integer representing the start time of the appointment. * `end`: An integer representing the end time of the appointment. * `duration`: An integer representing the duration of the appointment in hours. Output * `book_appointment` returns `True` or `False` based on the booking success. * `get_appointments` returns a list of tuples, where each tuple consists of the start and end times of an appointment. * `find_next_available` returns a tuple of the next available start and end times. * `make_booking` returns a tuple of appointed start and end times, or the string `\\"No available slot\\"`. Example ```python >>> calendar = Calendar() >>> calendar.book_appointment(10, 12) True >>> calendar.book_appointment(12, 13) True >>> calendar.book_appointment(11, 14) False >>> calendar.get_appointments() [(10, 12), (12, 13)] >>> calendar.find_next_available(1) (13, 14) >>> calendar.make_booking(2) (14, 16) >>> calendar.make_booking(3) \'No available slot\' ``` Constraints * Appointment times are integer values representing hours in a 24-hour format (0 to 23). * Appointment durations are positive integers. * Overlapping times are defined as any overlap between the start and end times of two appointments. # Additional Notes * Handle edge cases such as booking at the very beginning or end of the day. * Optimize for both time and space complexity.","solution":"class Calendar: def __init__(self): self.appointments = [] def book_appointment(self, start: int, end: int) -> bool: for s, e in self.appointments: if not (end <= s or start >= e): # Overlapping condition return False self.appointments.append((start, end)) self.appointments.sort() return True def get_appointments(self) -> list: return self.appointments def find_next_available(self, duration: int) -> tuple: if not self.appointments: return (0, duration) if duration <= 24 else \\"No available slot\\" for i in range(len(self.appointments) - 1): current_end = self.appointments[i][1] next_start = self.appointments[i + 1][0] if next_start - current_end >= duration: return (current_end, current_end + duration) if 24 - self.appointments[-1][1] >= duration: return (self.appointments[-1][1], self.appointments[-1][1] + duration) return \\"No available slot\\" def make_booking(self, duration: int) -> tuple | str: next_slot = self.find_next_available(duration) if next_slot == \\"No available slot\\": return next_slot start, end = next_slot self.book_appointment(start, end) return next_slot"},{"question":"# Binary Search Tree with Range Query You are to implement a Binary Search Tree (BST) and perform range queries on it. A Binary Search Tree is a binary tree in which each node has at most two children, and for each node with value `V`, all values in its left subtree are less than `V`, and all values in its right subtree are greater than `V`. Task 1: BST Construction Write a function, `insert_into_bst(root: BSTNode | None, value: int) -> BSTNode`, that inserts a given value into the BST and returns the updated tree. Task 2: Range Query Additionally, implement a function, `range_query_bst(root: BSTNode | None, low: int, high: int) -> list[int]`, that returns all values in the BST within the inclusive range `[low, high]`. Input: 1. A list of `n` integer values, `values: list[int]`. 2. Two integer values `low` and `high` representing the range query. Output: 1. A list of all values in the BST that fall within the range `[low, high]`. Example: ```python # Given values values = [10, 5, 1, 7, 40, 50] # Range query bounds low = 5 high = 45 # Construct the BST by inserting values one by one root = None for value in values: root = insert_into_bst(root, value) # Perform the range query result = range_query_bst(root, low, high) # Output: List of values within the range, e.g., [5, 7, 10, 40] ``` Constraints: - The number of values `n` will be such that `1 ≤ n ≤ 1000`. - The values of each integer will be within the range `[-10^6, 10^6]`. Performance Requirements: - Aim for time complexity of `O(n log n)` for BST construction. - Aim for time complexity of `O(k + log n)` for range queries, where `k` is the number of elements in the range.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_into_bst(root: BSTNode | None, value: int) -> BSTNode: if root is None: return BSTNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def range_query_bst(root: BSTNode | None, low: int, high: int) -> list[int]: if root is None: return [] result = [] if low <= root.value <= high: result.append(root.value) if low < root.value: result.extend(range_query_bst(root.left, low, high)) if root.value < high: result.extend(range_query_bst(root.right, low, high)) return result"},{"question":"Implement a function to perform matrix multiplication using the Strassen algorithm. The Strassen algorithm is a divide and conquer algorithm for matrix multiplication that is asymptotically faster than the standard matrix multiplication algorithm. Implement the following function: ```python def strassen_matrix_multiplication(A: list, B: list) -> list: Perform matrix multiplication using Strassen\'s algorithm. :param A: The first matrix as a list of lists where each sublist represents a row. :param B: The second matrix as a list of lists where each sublist represents a row. :return: The product of the matrices A and B, also as a list of lists. >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6], ... [7, 8] ... ] >>> strassen_matrix_multiplication(A, B) [[19, 22], [43, 50]] >>> C = [ ... [1, 0, 2], ... [-1, 3, 1] ... ] >>> D = [ ... [3, 1], ... [2, 1], ... [1, 0] ... ] >>> strassen_matrix_multiplication(C, D) [[5, 1], [4, 2]] pass ``` # Requirements: 1. **Function Signature**: - The function should take two matrices, `A` and `B`, as input, where each matrix is represented as a list of lists. - The function will return the product of these matrices as a list of lists. 2. **Input Constraints**: - Matrix dimensions should be compatible for multiplication, i.e., the number of columns in the first matrix should be equal to the number of rows in the second matrix. - Matrices should be represented as lists of lists with numerical values (integers or floats). 3. **Output**: - The product matrix should be correctly computed using the Strassen algorithm. 4. **Performance**: - The function should leverage the Strassen algorithm to improve performance over the standard ( O(n^3) ) matrix multiplication algorithm, especially for large matrices. # Important Notes: - Ensure the base cases for small matrices (e.g., 1x1, 2x2) are handled efficiently. - The function should be able to handle both square and rectangular matrices. - Properly manage edge cases such as empty matrices.","solution":"def strassen_matrix_multiplication(A: list, B: list) -> list: def add_matrix(X, Y): return [[X[i][j] + Y[i][j] for j in range(len(X[0]))] for i in range(len(X))] def sub_matrix(X, Y): return [[X[i][j] - Y[i][j] for j in range(len(X[0]))] for i in range(len(X))] def split_matrix(M): mid = len(M) // 2 A = [row[:mid] for row in M[:mid]] B = [row[mid:] for row in M[:mid]] C = [row[:mid] for row in M[mid:]] D = [row[mid:] for row in M[mid:]] return A, B, C, D def strassen_recursive(A, B): if len(A) == 1: return [[A[0][0] * B[0][0]]] A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen_recursive(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_recursive(add_matrix(A21, A22), B11) M3 = strassen_recursive(A11, sub_matrix(B12, B22)) M4 = strassen_recursive(A22, sub_matrix(B21, B11)) M5 = strassen_recursive(add_matrix(A11, A12), B22) M6 = strassen_recursive(sub_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_recursive(sub_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(sub_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(sub_matrix(add_matrix(M1, M3), M2), M6) return [ C11[i] + C12[i] for i in range(len(C11)) ] + [ C21[i] + C22[i] for i in range(len(C21)) ] def pad_matrix(M, size): return [row + [0] * (size - len(row)) for row in M] + [[0] * size] * (size - len(M)) assert len(A[0]) == len(B), \\"Incompatible matrices for multiplication\\" n = max(len(A), len(B[0]), len(A[0])) m = 1 while m < n: m *= 2 A_padded = pad_matrix(A, m) B_padded = pad_matrix(B, m) C_padded = strassen_recursive(A_padded, B_padded) return [row[:len(B[0])] for row in C_padded[:len(A)]]"},{"question":"# Question Context In a game development scenario, there is a need to frequently calculate the new position of a character on a 2D grid after a series of moves. The character can move up, down, left, or right, and each move changes the character\'s position by one unit in the corresponding direction. You are tasked with creating a function that computes the final position of the character after a given sequence of moves. Task Write a function `final_position` that calculates the final coordinates of a character on a 2D grid after a sequence of moves. Function Signature ```python def final_position(moves: str) -> Tuple[int, int]: ``` Input * `moves` (str): A string consisting of the characters \'U\', \'D\', \'L\', \'R\' which represent moves Up, Down, Left, and Right respectively. (1 <= len(moves) <= 10^5) Output * (Tuple[int, int]): The final position (x, y) of the character on the 2D grid, assuming the starting position is (0, 0). Example ```python >>> final_position(\'UUDDLRLR\') (0, 0) >>> final_position(\'UUUL\') (-1, 3) >>> final_position(\'RRRDD\') (3, -2) ``` Constraints * Each move in the string is one of \'U\', \'D\', \'L\', \'R\'. * The length of the `moves` string will be between 1 and 100,000. Edge Cases * When `moves` is an empty string, the final position should be the starting position (0, 0). * If the moves cancel each other out (e.g., \'UD\' or \'LR\'), the final position should be the starting position (0, 0).","solution":"from typing import Tuple def final_position(moves: str) -> Tuple[int, int]: Returns the final coordinates of the character on a 2D grid after a sequence of moves. The starting position is (0, 0). Parameters: moves (str): A string consisting of the characters \'U\', \'D\', \'L\', \'R\'. Returns: Tuple[int, int]: The final position (x, y) of the character. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y)"},{"question":"# Problem Statement Write a function that rotates a given matrix 90 degrees clockwise. The matrix is represented as a list of lists, where each inner list is a row of the matrix. The function should return the rotated matrix. # Function Signature ```python def rotate_matrix_90_degree_clockwise(matrix: list[list[int]]) -> list[list[int]]: ``` # Input * A list of lists `matrix` where each inner list represents a row of the matrix. * The matrix has `m` rows and `n` columns. 0 <= m, n <= 100. * The matrix will always be rectangular (i.e., all rows have the same number of columns). # Output * Return a new matrix which is the input matrix rotated 90 degrees clockwise. # Examples 1. **Example 1:** ```python rotate_matrix_90_degree_clockwise([[1, 2, 3], [4, 5, 6]]) ``` **Output:** ```python [[4, 1], [5, 2], [6, 3]] ``` 2. **Example 2:** ```python rotate_matrix_90_degree_clockwise([[1, 2], [3, 4], [5, 6]]) ``` **Output:** ```python [[5, 3, 1], [6, 4, 2]] ``` 3. **Example 3:** ```python rotate_matrix_90_degree_clockwise([[1]]) ``` **Output:** ```python [[1]] ``` 4. **Example 4:** ```python rotate_matrix_90_degree_clockwise([]) ``` **Output:** ```python [] ``` # Constraints * The number of rows `m` and columns `n` can be 0 (representing an empty matrix). # Performance Requirements * The solution should have a time complexity of O(m * n), where `m` is the number of rows and `n` is the number of columns. # Notes * Do not modify the input matrix in place; return a new matrix that represents the rotated result. * The input matrix can be non-square.","solution":"def rotate_matrix_90_degree_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotates the given matrix 90 degrees clockwise and returns the resulting matrix. if not matrix: return [] m, n = len(matrix), len(matrix[0]) rotated_matrix = [[0] * m for _ in range(n)] for i in range(m): for j in range(n): rotated_matrix[j][m - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Question: Aggregating and Analyzing Server Logs You are required to write a Python script to process and analyze server log files. The log files are in a standardized format, and include log entries that consist of the timestamp, HTTP method, URI, status code, and response time. Your task is to analyze these logs to extract useful statistics. Requirements: 1. **Input**: - The script should accept the path to the log file as a command-line argument. 2. **Log Parsing**: - Each log entry will be a line in the log file with the following format: ``` [timestamp] \\"HTTP_METHOD URI\\" status_code response_time ``` For example: ``` [2023-04-12T12:34:56Z] \\"GET /index.html\\" 200 0.123 ``` 3. **Data Extraction**: - Parse the log file and extract the following data for each entry: - Timestamp - HTTP Method - URI - Status Code - Response Time 4. **Statistics Calculation**: - Calculate the following statistics: - Total number of requests. - Number of requests per HTTP method. - Number of requests per URI. - Average response time. - Number of requests with status codes in the 2xx, 3xx, 4xx, and 5xx ranges. 5. **Output**: - Print the calculated statistics in a readable format. 6. **Error Handling**: - Handle any errors that may occur during file reading, parsing, or processing, and provide meaningful error messages. Implementation Details: 1. **Helper Functions**: - Implement helper functions where necessary to keep the code organized. 2. **Logging**: - Include logging to keep track of the process (e.g., indicating when the log file is successfully read, any lines that couldn\'t be parsed, etc.) Constraints: - Python 3 must be used. - You can use the `re` library for regular expressions if needed. - The log file will be well-formed with each entry correctly formatted as specified. Performance Expectations: - The script should handle log files with up to 100,000 entries efficiently. # Example Usage: ```bash python log_analysis.py /path/to/server.log ``` # Code Implementation: Implement your solution with the function signature given below: ```python def analyze_server_logs(log_file_path: str): pass ```","solution":"import re import sys import logging from collections import defaultdict def parse_log_entry(line: str): Parses a single log entry and returns a tuple with the extracted data. :param line: A single line from the log file. :return: A tuple with (timestamp, http_method, uri, status_code, response_time). log_pattern = re.compile( r\'[(?P<timestamp>[w-T:.Z]+)] \\"(?P<http_method>w+) (?P<uri>[^\\"]+)\\" (?P<status_code>d{3}) (?P<response_time>[d.]+)\' ) match = log_pattern.match(line) if match: return (match.group(\'timestamp\'), match.group(\'http_method\'), match.group(\'uri\'), int(match.group(\'status_code\')), float(match.group(\'response_time\'))) return None def analyze_server_logs(log_file_path: str): Processes and analyzes the server log file to extract and print statistics. :param log_file_path: Path to the server log file. total_requests = 0 method_counts = defaultdict(int) uri_counts = defaultdict(int) total_response_time = 0.0 status_code_counts = {\'2xx\': 0, \'3xx\': 0, \'4xx\': 0, \'5xx\': 0} try: with open(log_file_path, \'r\') as file: for line in file: parsed_entry = parse_log_entry(line) if parsed_entry: total_requests += 1 timestamp, http_method, uri, status_code, response_time = parsed_entry method_counts[http_method] += 1 uri_counts[uri] += 1 total_response_time += response_time if 200 <= status_code < 300: status_code_counts[\'2xx\'] += 1 elif 300 <= status_code < 400: status_code_counts[\'3xx\'] += 1 elif 400 <= status_code < 500: status_code_counts[\'4xx\'] += 1 elif 500 <= status_code < 600: status_code_counts[\'5xx\'] += 1 average_response_time = total_response_time / total_requests if total_requests else 0 print(f\\"Total number of requests: {total_requests}\\") print(\\"Number of requests per HTTP method:\\") for method, count in method_counts.items(): print(f\\" {method}: {count}\\") print(\\"Number of requests per URI:\\") for uri, count in uri_counts.items(): print(f\\" {uri}: {count}\\") print(f\\"Average response time: {average_response_time:.3f} seconds\\") print(\\"Number of requests with status codes:\\") for code_range, count in status_code_counts.items(): print(f\\" {code_range}: {count}\\") except Exception as e: logging.error(f\\"An error occurred while processing the log file: {e}\\") # Example usage: # analyze_server_logs(\'path_to_log_file.log\')"},{"question":"# Coding Question Write a function that takes a non-negative integer `n` and returns the sum of its digits raised to successive powers, starting from 1. The function should return this sum. **Function Signature**: ```python def sum_of_digits_to_powers(n: int) -> int: Args: n (int): A non-negative integer. Returns: int: The sum of the digits of `n` raised to successive powers starting from 1. Examples: >>> sum_of_digits_to_powers(234) 21 >>> sum_of_digits_to_powers(123) 10 >>> sum_of_digits_to_powers(999) 2790 >>> sum_of_digits_to_powers(0) 0 Constraints: * n is a non-negative integer less than 10^10. ``` **Constraints**: - `n` is a non-negative integer less than `10^10`. **Example Testing**: ```python assert sum_of_digits_to_powers(234) == 21 # 2^1 + 3^2 + 4^3 = 2 + 9 + 64 = 75 assert sum_of_digits_to_powers(123) == 10 # 1^1 + 2^2 + 3^3 = 1 + 4 + 27 = 32 assert sum_of_digits_to_powers(999) == 2790 # 9^1 + 9^2 + 9^3 = 9 + 81 + 729 = 819 assert sum_of_digits_to_powers(0) == 0 # 0^1 = 0 assert sum_of_digits_to_powers(9876543210) == 2163978753 # 9^1 + 8^2 + 7^3 + 6^4 + 5^5 + 4^6 + 3^7 + 2^8 + 1^9 + 0^10 ```","solution":"def sum_of_digits_to_powers(n: int) -> int: Returns the sum of the digits of `n` raised to successive powers starting from 1. return sum(int(digit) ** (index + 1) for index, digit in enumerate(str(n)))"},{"question":"# Problem Statement You are tasked with developing a feature for a fitness tracking application that analyzes a user\'s running performance over a specified number of days. The application should calculate the user\'s total distance ran, average distance per day, and identify the longest run in the given timeframe. # Requirements You are to implement four functions: `total_distance`, `average_distance`, `longest_run`, and `running_summary`. These functions will compute the respective metrics and the final summary of the user\'s running performance. # Input and Output 1. **Input** - `running_summary(distances: List[float]) -> dict` - `distances`: list of float (each representing the distance run in a day, must be non-negative) 2. **Output** - Return a dictionary containing: - `\'total_distance\'`: float (total distance run over the specified days) - `\'average_distance\'`: float (average distance run per day) - `\'longest_run\'`: float (longest single run within the specified days) # Constraints - All distances provided in the list must be non-negative. - The list of distances should not be empty. # Example ```python running_summary([5.0, 7.2, 3.3, 4.7, 6.6]) # Output: {\'total_distance\': 26.8, \'average_distance\': 5.36, \'longest_run\': 7.2} running_summary([10.5, 8.6, 12.3, 7.4]) # Output: {\'total_distance\': 38.8, \'average_distance\': 9.7, \'longest_run\': 12.3} ``` # Notes - Handle invalid inputs by raising appropriate exceptions. - Ensure the calculations are accurate to two decimal points. # Implementation Implement the required functions ensuring to follow the input validation rigorously. The `running_summary` function should utilize the other three functions to provide a comprehensive summary.","solution":"from typing import List def total_distance(distances: List[float]) -> float: if not all(d >= 0 for d in distances): raise ValueError(\\"All distances must be non-negative\\") return round(sum(distances), 2) def average_distance(distances: List[float]) -> float: if not distances: return 0.0 return round(sum(distances) / len(distances), 2) def longest_run(distances: List[float]) -> float: if not distances: return 0.0 return round(max(distances), 2) def running_summary(distances: List[float]) -> dict: if not distances: raise ValueError(\\"The list of distances should not be empty\\") return { \\"total_distance\\": total_distance(distances), \\"average_distance\\": average_distance(distances), \\"longest_run\\": longest_run(distances) }"},{"question":"# Context You are developing a feature for a book management system where the titles need to be organized for easier browsing. The librarian has requested that the list of book titles be sorted in alphabetical order. # Task Write a function `alphabetical_sort(titles: list[str]) -> list[str]` that sorts a list of book titles using the Merge Sort algorithm. # Function Signature ```python def alphabetical_sort(titles: list[str]) -> list[str]: Sorts a list of book titles in alphabetical order using the merge sort algorithm. :param titles: A list of strings, where each string is a book title. :return: The sorted list of book titles in alphabetical order. ``` # Input * `titles`: A list of strings, where each string is a book title. For example: `[\\"The Catcher in the Rye\\", \\"To Kill a Mockingbird\\", \\"1984\\"]` # Output * A sorted list of strings containing the book titles in alphabetical order. # Constraints * 0 ≤ len(titles) ≤ 10^3 * Each string represents a book title and may contain spaces, punctuation, and numbers. # Examples 1. Input: `[\\"The Catcher in the Rye\\", \\"To Kill a Mockingbird\\", \\"1984\\"]` Output: `[\\"1984\\", \\"The Catcher in the Rye\\", \\"To Kill a Mockingbird\\"]` 2. Input: `[\\"The Great Gatsby\\", \\"War and Peace\\", \\"Moby Dick\\", \\"A Tale of Two Cities\\"]` Output: `[\\"A Tale of Two Cities\\", \\"Moby Dick\\", \\"The Great Gatsby\\", \\"War and Peace\\"]` # Notes Make sure to handle edge cases like empty lists or lists with a single book title. Ensure that the sorting is case-insensitive for consistent alphabetical order.","solution":"def alphabetical_sort(titles: list[str]) -> list[str]: Sorts a list of book titles in alphabetical order using the merge sort algorithm. :param titles: A list of strings, where each string is a book title. :return: The sorted list of book titles in alphabetical order. def merge(left: list[str], right: list[str]) -> list[str]: sorted_list = [] while left and right: if left[0].lower() <= right[0].lower(): sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left or right) return sorted_list def merge_sort(titles: list[str]) -> list[str]: if len(titles) <= 1: return titles mid = len(titles) // 2 left = merge_sort(titles[:mid]) right = merge_sort(titles[mid:]) return merge(left, right) return merge_sort(titles)"},{"question":"# Problem Statement: You are given multiple transactions in a single day for various customers of a bank. Each transaction is represented by a tuple with the format (customer_id, transaction_amount). Your task is to determine the total transaction amount per customer and return the IDs of customers who made transactions exceeding a given threshold. # Detailed Instructions: 1. **Transaction Summation**: For each customer, calculate the total amount from all their transactions. 2. **Threshold Check**: Identify customers whose total transaction amount exceeds a specified threshold. 3. **Output**: Return a list of customer IDs who meet or exceed the transaction threshold. The list should be sorted in ascending order of the customer IDs. # Input and Output: - **Input**: A list of tuples representing the transactions and an integer representing the threshold. - **Output**: An ascending sorted list of customer IDs whose total transaction amounts meet or exceed the threshold. # Constraints: - The list of transactions contains well-formed tuples with positive integer customer IDs and floating-point transaction amounts. - The threshold is a positive floating-point number. - It is guaranteed that there will be at least one transaction in the transactions list. # Function Signature: ```python def get_high_value_customers(transactions: list, threshold: float) -> list: pass ``` # Performance Requirements: Your solution should efficiently handle the summation of transactions, ensuring minimal processing time and memory usage even with large lists of transactions. # Example: ```python >>> transactions = [(1, 100.0), (2, 200.0), (3, 150.0), (1, 50.0), (2, 75.0)] >>> threshold = 200.0 >>> get_high_value_customers(transactions, threshold) [1, 2] ``` Here, customers 1 and 2 have total transaction amounts of 150.0 and 275.0, respectively, which both meet or exceed the threshold of 200.0. # Notes: - Ensure that transactions list is handled properly and efficiently. - Consider edge cases such as customers with exactly the threshold amount or no transaction meeting the threshold.","solution":"def get_high_value_customers(transactions, threshold): # Dictionary to hold the total transaction amount per customer customer_totals = {} # Sum the transactions for each customer for customer_id, transaction_amount in transactions: if customer_id in customer_totals: customer_totals[customer_id] += transaction_amount else: customer_totals[customer_id] = transaction_amount # Filter customers who meet or exceed the threshold high_value_customers = [customer_id for customer_id, total in customer_totals.items() if total >= threshold] # Sort the customer IDs in ascending order high_value_customers.sort() return high_value_customers"},{"question":"# Newton\'s Second Law of Motion Context In physics, Newton\'s second law of motion states that the force applied on an object is directly proportional to the acceleration of the object, with the object\'s mass being the proportionality constant. This principle is essential in mechanics and is used to solve various problems related to force, mass, and acceleration. Problem Statement Create a function `compute_force_mass_acceleration` that will compute and return the missing value (force, mass, or acceleration) based on the inputs. The function should handle inputs correctly and raise appropriate exceptions for invalid inputs. Function Signature ```python def compute_force_mass_acceleration( force: float, mass: float, acceleration: float ) -> tuple[str, float]: ``` Input - `force`: (float) The force applied on the object. - `mass`: (float) The mass of the object. - `acceleration`: (float) The acceleration of the object. Output - Returns a tuple containing: - A string with the name of the calculated quantity: `\\"force\\"`, `\\"mass\\"`, or `\\"acceleration\\"`. - The computed value (float). Constraints - Exactly one of the values among (`force`, `mass`, `acceleration`) should be 0 to indicate that it needs to be calculated. - The values provided should be non-negative. Error Handling Raise a `ValueError` in case of: - Any parameter being negative. - More than one parameter being zero. Examples ```python >>> compute_force_mass_acceleration(force=0, mass=10, acceleration=5) (\'force\', 50.0) >>> compute_force_mass_acceleration(force=200, mass=0, acceleration=5) (\'mass\', 40.0) >>> compute_force_mass_acceleration(force=100, mass=25, acceleration=0) (\'acceleration\', 4.0) >>> compute_force_mass_acceleration(force=0, mass=0, acceleration=10) ValueError: You cannot supply more or less than 2 values >>> compute_force_mass_acceleration(force=100, mass=20, acceleration=-5) ValueError: Acceleration cannot be negative ``` Explanation: 1. **When force is zero**: The function should return the force value as the result of multiplying mass by acceleration. 2. **When mass is zero**: The function should return the mass value as the result of dividing force by acceleration. 3. **When acceleration is zero**: The function should return the acceleration value as the result of dividing force by mass. 4. **Raise an error** if the input violates any constraints.","solution":"def compute_force_mass_acceleration(force: float, mass: float, acceleration: float) -> tuple[str, float]: Computes and returns the missing value (force, mass, or acceleration) based on the inputs. if force < 0 or mass < 0 or acceleration < 0: raise ValueError(\\"Inputs cannot be negative\\") zero_count = (force == 0) + (mass == 0) + (acceleration == 0) if zero_count != 1: raise ValueError(\\"Exactly one of the values must be zero\\") if force == 0: return \'force\', mass * acceleration elif mass == 0: return \'mass\', force / acceleration elif acceleration == 0: return \'acceleration\', force / mass"},{"question":"# Objective Write a function to generate a histogram of oriented gradients (HOG) for a given grayscale image. # Description Develop a function `compute_hog_histogram(image: np.ndarray, cell_size: int) -> np.ndarray` which takes a grayscale image and an integer cell size as input and returns a 2D histogram matrix, where each entry represents the gradient orientation histogram for a cell. # Input - **`image`**: A 2D numpy array of integers representing a grayscale image. - **`cell_size`**: An integer specifying the size of each cell (px). # Output - A 2D numpy array where each element is a numpy array representing the histogram of gradients for each cell in the image. # Constraints - You may assume the input image is a 2D numpy array with integer values in the range [0, 255]. - The input image will have at least `cell_size x cell_size` dimensions. - The `cell_size` will be a positive integer. - You should handle boundary conditions where parts of a cell might fall outside the image dimensions. # Performance Requirement - Your solution should efficiently compute the HOG for images of up to 1000x1000 pixels with reasonably sized cells. # Example ```python import numpy as np image = np.array([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160] ]) cell_size = 2 hog_histogram = compute_hog_histogram(image, cell_size) print(hog_histogram) ``` # Scenario Consider a vehicle detection system that uses HOG for feature extraction before applying machine learning algorithms. Efficient computation of HOG values enhances the system\'s performance and accuracy.","solution":"import numpy as np def compute_hog_histogram(image: np.ndarray, cell_size: int) -> np.ndarray: Computes the histogram of oriented gradients (HOG) for a given grayscale image. Parameters: - image: np.ndarray, input grayscale image - cell_size: int, size of the cell in pixels Returns: - 2D array of histograms for each cell # Compute gradients gx = np.gradient(image, axis=1) gy = np.gradient(image, axis=0) # Calculate magnitude and orientation of gradient magnitude = np.sqrt(gx ** 2 + gy ** 2) orientation = np.arctan2(gy, gx) * 180 / np.pi # Convert radians to degrees orientation[orientation < 0] += 180 # Keep orientation within [0, 180] degrees # Get dimensions of the input image height, width = image.shape # Establish number of cells along x and y axes n_cells_x = width // cell_size n_cells_y = height // cell_size # Initialize a 3D numpy array to hold the HOG histograms hog_hist = np.zeros((n_cells_y, n_cells_x, 9)) # Binning initialization bins = np.arange(0, 181, 20) for y in range(n_cells_y): for x in range(n_cells_x): # Extract cell gradients and orientations cell_magnitude = magnitude[y * cell_size:(y + 1) * cell_size, x * cell_size:(x + 1) * cell_size] cell_orientation = orientation[y * cell_size:(y + 1) * cell_size, x * cell_size:(x + 1) * cell_size] hist, _ = np.histogram(cell_orientation, bins=bins, weights=cell_magnitude) hog_hist[y, x, :] = hist return hog_hist"},{"question":"# Longest Substring Without Repeating Characters You are given a string and need to find the length of the longest substring that contains no repeating characters. This problem will test your ability to work with sliding window techniques and hashmaps. Function Signature ```python def length_of_longest_substring(input_str: str) -> int: ``` Input and Output Formats * **Input**: A single string `input_str`. * **Constraints**: * The string will only contain printable ASCII characters. * It can be of any length, including zero. * **Output**: An integer value representing the length of the longest substring without repeating characters. Example ```python # Example 1 assert length_of_longest_substring(\\"abcabcbb\\") == 3 # Example 2 assert length_of_longest_substring(\\"bbbbb\\") == 1 # Example 3 assert length_of_longest_substring(\\"pwwkew\\") == 3 # Example 4 assert length_of_longest_substring(\\"\\") == 0 # Example 5 assert length_of_longest_substring(\\"aab\\") == 2 ``` Explanation 1. For \\"abcabcbb\\", the longest substring without repeating characters is \\"abc\\", with a length of 3. 2. For \\"bbbbb\\", the longest substring without repeating characters is \\"b\\", with a length of 1. 3. For \\"pwwkew\\", the longest substring without repeating characters is \\"wke\\", with a length of 3. 4. An empty string has a longest substring length of 0. 5. For \\"aab\\", the longest substring without repeating characters is \\"ab\\", with a length of 2. Instructions 1. Implement the function according to the provided signature. 2. Use a sliding window approach to efficiently track the longest substring without repeating characters. 3. Utilize a hashmap to store the indices of characters for quick look-up and window adjustment.","solution":"def length_of_longest_substring(input_str: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} left = 0 max_length = 0 for right, char in enumerate(input_str): if char in char_index_map and char_index_map[char] >= left: left = char_index_map[char] + 1 char_index_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement Given an integer array `nums` sorted in non-decreasing order, return a list of unique combinations that sum up to a target value `target`. Each number in `nums` may be used as many times as needed. You may assume that there are no repeated elements in `nums` and that all elements are positive integers. # Function Signature ```python def combination_sum(nums: List[int], target: int) -> List[List[int]] ``` # Input - `nums`: a list of integers, sorted in non-decreasing order. - `target`: an integer representing the target sum. # Output - Return a list of lists of integers where each list represents a combination that sums to `target`. # Constraints - The length of `nums` will be in the range [1, 30]. - 1 <= nums[i] <= 200. - All elements in `nums` are unique. - 1 <= target <= 500. # Examples ```python >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) [] ``` # Implementation Requirements - Your solution should have a time complexity that makes it feasible for the given constraints. - Pay attention to edge cases like when there is no possible combination summing to `target` or when there is only one element in `nums`. # Helper Functions You may use a helper function to aid in the generation of combinations. This can be a recursive function that builds combinations by exploring all possible sums below or equal to `target`. # Tips - Use backtracking to explore potential combinations by including or excluding current numbers. - Ensure to avoid duplicate combinations by keeping track of the starting point for each recursive call.","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> List[List[int]]: result = [] def backtrack(remaining, path, start): if remaining == 0: result.append(list(path)) return elif remaining < 0: return for i in range(start, len(nums)): path.append(nums[i]) backtrack(remaining - nums[i], path, i) path.pop() backtrack(target, [], 0) return result"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that demonstrates an understanding of sorting algorithms and their optimization when dealing with large datasets. Specifically, you will create a function that sorts a list of integer tuples based on a specific criterion to emphasize the importance of stability in sorting algorithms. Requirements * Write a function `sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that takes a list of tuples, where each tuple consists of two integers. * The function should sort the list primarily by the first integer in ascending order. * If two tuples have the same first integer, they should be sorted by the second integer in descending order. Input * `arr` (List[Tuple[int, int]]): A list of tuples, where each tuple consists of two integers. Output * A list of tuples, sorted according to the specified criteria. Constraints * The function should handle cases where the input list has zero or one tuple gracefully, returning the list as is. * Ensure the function performs efficiently for input lists with up to 10^6 tuples. Performance Requirements * The function should be efficient and able to handle large lists of tuples without significant delays. Example ```python arr = [(1, 3), (4, 2), (2, 6), (1, 5), (4, 1), (3, 4)] sorted_arr = sort_tuples(arr) print(sorted_arr) ``` Expected Output: ```python [(1, 5), (1, 3), (2, 6), (3, 4), (4, 2), (4, 1)] ``` Submission Please submit a Python file containing the implementation of the `sort_tuples` function. Include appropriate comments explaining important sections of your code and any assumptions you\'ve made.","solution":"from typing import List, Tuple def sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples primarily by the first integer in ascending order and secondarily by the second integer in descending order. Parameters: arr (List[Tuple[int, int]]): A list of tuples, where each tuple consists of two integers. Returns: List[Tuple[int, int]]: The list of tuples, sorted according to the specified criteria. # Sort the list with a key that does a primary sort on the first element (ascending) # and a secondary sort on the second element (descending) return sorted(arr, key=lambda x: (x[0], -x[1]))"},{"question":"# Introduction A common task in data analysis is transforming a list of positive integers such that every integer is replaced by the product of all the integers in the list except the integer at that position. This problem requires optimizing the approach to avoid computing the product repeatedly for each position. # Task Write a function named `product_except_self(nums: List[int]) -> List[int]` that transforms a list of integers. For each position in the list, replace the integer with the product of all other integers in the list. Do this without using division and in O(n) time complexity. # Requirements * **Function Signature**: `def product_except_self(nums: List[int]) -> List[int]:` * **Input**: A list of integers `nums` where each integer is positive. * **Output**: A list of integers where each integer at index `i` is replaced by the product of all other integers in the list except the integer at index `i`. # Constraints 1. The length of the input list will be at least 1 and at most 10^5. 2. All elements in `nums` are positive integers. 3. Do not use division. 4. Aim for a solution with O(n) time complexity. # Examples ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] >>> product_except_self([2]) [1] >>> product_except_self([7, 8]) [8, 7] ``` # Additional Notes 1. You can achieve the solution by using two passes over the list: one to store the products of all elements to the left and another to store products of all elements to the right. 2. Carefully handle edge cases, such as when the list contains only one element. 3. Ensure your function handles large inputs efficiently in terms of both time and space complexity.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 1: return [1] result = [1] * n # Compute the product of all elements to the left of each element left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Compute the product of all elements to the right of each element right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"# Problem Statement You have been given a list of events, each with a start and end time. Your task is to find out the maximum number of concurrent events that occur at the same time. An event is considered concurrent if its time interval overlaps with another event. # Objective Implement a function `max_concurrent_events` to determine the maximum number of concurrent events. # Requirements - **Input**: - `events`: A list of tuples, where each tuple contains two integers `(start_time, end_time)` representing the start and end times of an event. `(1 ≤ start_time < end_time ≤ 10^5)` - **Output**: An integer representing the maximum number of concurrent events. # Constraints - Ensure efficient computation even for large input sizes. - Handle edge cases, such as no events or all events overlapping. # Example Case ```python def max_concurrent_events(events: list[tuple[int, int]]) -> int: # Your implementation here # Example usage events = [(1, 4), (2, 5), (3, 6), (7, 8)] print(max_concurrent_events(events)) ``` **Expected Output**: `3` # Note - Use appropriate data structures to manage event start and end times effectively. - Document any assumptions and ensure robust handling of unusual scenarios.","solution":"def max_concurrent_events(events): Determine the maximum number of concurrent events. Parameters: events (list of tuples): List of tuples where each tuple contains start and end times of an event. Returns: int: Maximum number of concurrent events. times = [] for start, end in events: times.append((start, \'start\')) times.append((end, \'end\')) # Sort the times based on time, and in case of tie, put \'end\' before \'start\' times.sort(key=lambda x: (x[0], x[1] == \'start\')) max_concurrent = 0 current_concurrent = 0 for time, typ in times: if typ == \'start\': current_concurrent += 1 max_concurrent = max(max_concurrent, current_concurrent) else: current_concurrent -= 1 return max_concurrent"},{"question":"# Question: Count Unique Words in a String Context: In text processing, counting the number of unique words in a string is a common task. A word is defined as a sequence of alphanumeric characters, and words are case insensitive. Non-alphanumeric characters (like punctuation marks) should be ignored. Problem Statement: Write a Python function `count_unique_words(s: str) -> int` that takes a string `s` and returns the number of unique words in the string. Input: * `s` (str): A string potentially containing words separated by spaces or punctuation. Output: * `int`: The count of unique words in the input string. Constraints: * The input string `s` may contain any printable ASCII characters. * The length of `s` will be up to 10,000 characters. * Words are case insensitive (e.g., \\"Hello\\" and \\"hello\\" are considered the same word). Example: ```python assert count_unique_words(\\"Hello, world! Hello!\\") == 2 # \\"hello\\" and \\"world\\" assert count_unique_words(\\"The quick brown fox jumps over the lazy dog.\\") == 8 # each word is unique in this case assert count_unique_words(\\"Test, test; TEST.\\") == 1 # \\"test\\" is the only unique word assert count_unique_words(\\"123 123 456! 456?\\") == 2 # \\"123\\" and \\"456\\" ``` Requirements: * Your solution should handle inputs efficiently, ideally with a time complexity of O(N), where N is the length of the input string. * You may use Python built-in libraries for string manipulation if needed. * Ensure correctness for edge cases such as strings with no alphanumeric characters or different punctuations.","solution":"import re def count_unique_words(s: str) -> int: Counts the number of unique words in the given string. Words are considered sequences of alphanumeric characters and are case insensitive. Parameters: s (str): Input string that may contain words separated by spaces or punctuation. Returns: int: The count of unique words in the input string. # Use regex to find all alphanumeric sequences (words) words = re.findall(r\'bw+b\', s.lower()) # Converting to lower case for case insensitivity unique_words = set(words) # Using set to store unique words return len(unique_words)"},{"question":"# Question: Efficiently Find Closest Points Scenario You are given a list of points in a 2D plane, each represented by their `(x, y)` coordinates. Your task is to find the `k` closest points to the origin `(0, 0)` using the Euclidean distance. This is a common problem in various fields like computer graphics, geographic information systems, and clustering algorithms. Rather than computing the distance for each point, you should optimize the algorithm to handle large datasets efficiently. You may use appropriate data structures and algorithms to achieve this. Function Implementation Your task is to implement the function `find_closest_points` which finds the `k` closest points to the origin. Function Signature ```python def find_closest_points(points: list[tuple[int, int]], k: int) -> list[tuple[int, int]]: ``` Input - `points`: a list of tuples, where each tuple contains two integers representing the `(x, y)` coordinates of a point. - `k`: an integer representing the number of closest points to find, `1 ≤ k ≤ len(points)`. Output - Returns a list of `k` tuples, each representing the coordinates of one of the `k` closest points to the origin. Constraints - The input list `points` can have up to `10^6` points. - The coordinates of each point lie in the integer range `[-10^4, 10^4]`. - The result should maintain the relative order of points having the same distance to the origin. Example ```python points = [(1, 3), (3, 4), (2, -1)] k = 2 closest_points = find_closest_points(points, k) # Expected output is the two closest points to the origin: # [(1, 3), (2, -1)] ``` # Considerations - Ensure your algorithm is efficient in terms of time complexity, especially for large inputs. - Efficiently manage memory usage to handle the upper limit of input size. - Points with the same distance to the origin should be returned in the order they appear in the original list.","solution":"import heapq def euclidean_distance(point): Helper function to calculate the squared Euclidean distance from origin (0, 0). Squared distance is used to avoid floating-point operations and preserve performance. x, y = point return x * x + y * y def find_closest_points(points, k): Finds the k closest points to the origin (0, 0). Parameters: points (list of tuple): List of tuples representing points (x, y) in the 2D plane. k (int): Number of closest points to find. Returns: list of tuple: List of k tuples representing the closest points to the origin. # Create a max heap of size k max_heap = [] for point in points: distance = euclidean_distance(point) if len(max_heap) < k: heapq.heappush(max_heap, (-distance, point)) else: # If the current point is closer than the farthest point in the heap, replace it if -max_heap[0][0] > distance: heapq.heappop(max_heap) heapq.heappush(max_heap, (-distance, point)) # Extract the points from the heap result = [point for (neg_distance, point) in max_heap] return result"},{"question":"# Place Reservation System Using Priority Queue **Context:** You are tasked with implementing a priority queue-based reservation system for an event venue. The system prioritizes VIP reservations over Regular reservations. Each reservation request has an associated priority level, and customers should be served based on their priority. # Task: Implement the following methods in a `ReservationQueue` class: 1. **Add Reservation** 2. **Process Reservation** 3. **View Reservations** # Requirements: 1. **Add Reservation**: - Add a new reservation to the priority queue based on its priority level. - **Input**: String reservation_name, Integer priority (higher number indicates higher priority). - **Output**: None. 2. **Process Reservation**: - Process and remove the highest priority reservation from the queue. - **Output**: String reservation_name of the processed reservation. 3. **View Reservations**: - View all reservations in the priority queue in the order they would be processed. - **Output**: List of tuples (reservation_name, priority). # Constraints: 1. The priority queue should handle multiple reservations efficiently. 2. Priorities will be integers and can be both positive and negative. 3. Operations will be performed in a sequence, including adding reservations and processing them. # Example: * Add Reservation: (\\"John Doe\\", 5), (\\"Jane Smith\\", 10), (\\"Alice Johnson\\", 7) * Process Reservation: Returns \\"Jane Smith\\" * View Reservations: Returns [(\\"Alice Johnson\\", 7), (\\"John Doe\\", 5)] # Guidelines: 1. Use appropriate data structures to implement the priority queue with efficient operations. 2. Ensure your implementation can handle edge cases such as an empty queue when processing a reservation. 3. Do not use built-in library classes for the priority queue. # Implementation: ```python import heapq class ReservationQueue: def __init__(self): self.queue = [] # A list to hold the reservations self.entry_count = 0 # This is to maintain the order of arrivals for reservations with same priority def add_reservation(self, reservation_name, priority): heapq.heappush(self.queue, (-priority, self.entry_count, reservation_name)) self.entry_count += 1 def process_reservation(self): if not self.queue: return None _, _, reservation_name = heapq.heappop(self.queue) return reservation_name def view_reservations(self): return [(res[2], -res[0]) for res in sorted(self.queue)] # Example usage: reservation_system = ReservationQueue() reservation_system.add_reservation(\\"John Doe\\", 5) reservation_system.add_reservation(\\"Jane Smith\\", 10) reservation_system.add_reservation(\\"Alice Johnson\\", 7) processed_reservation = reservation_system.process_reservation() print(processed_reservation) # Outputs: Jane Smith pending_reservations = reservation_system.view_reservations() print(pending_reservations) # Outputs: [(\'Alice Johnson\', 7), (\'John Doe\', 5)] ``` In this implementation, the priority queue is modeled using a min-heap, where the priority is inverted to handle highest priority first. Ensure to handle edge cases such as empty queues efficiently. The provided example code is expected to produce the specified output upon performing the stated operations.","solution":"import heapq class ReservationQueue: def __init__(self): self.queue = [] # A list to hold the reservations self.entry_count = 0 # This is to maintain the order of arrivals for reservations with same priority def add_reservation(self, reservation_name, priority): Add a new reservation to the priority queue. :param reservation_name: Name of the reservation. :param priority: Priority level of the reservation (higher number is higher priority). heapq.heappush(self.queue, (-priority, self.entry_count, reservation_name)) self.entry_count += 1 def process_reservation(self): Process and remove the highest priority reservation from the queue. :return: The name of the reservation that was processed. if not self.queue: return None _, _, reservation_name = heapq.heappop(self.queue) return reservation_name def view_reservations(self): View all reservations in the priority order they would be processed. :return: List of tuples containing the reservation name and its priority. return [(res[2], -res[0]) for res in sorted(self.queue)]"},{"question":"# Coding Assessment Question: Event Emitter System **Context**: You are part of a team developing a complex application that heavily relies on event-driven architecture. Your task is to implement an event emitter system that allows registering event handlers, emitting events, and removing event handlers. **Problem Statement**: Write a class named `EventEmitter` to manage event-driven communication. This class should allow handlers to subscribe to specific events, emit events to notify the subscribed handlers, and remove handlers if necessary. **Class Definition**: ```python class EventEmitter: def __init__(self): Initialize an empty dictionary to hold event handlers. def on(self, event_name: str, handler: callable) -> None: Register an event handler for a specific event. :param event_name: The name of the event to subscribe to. :param handler: A callable to be called when the event is emitted. def emit(self, event_name: str, *args, **kwargs) -> None: Emit an event and execute all handlers subscribed to it. :param event_name: The name of the event to emit. :param args: Positional arguments to pass to each handler. :param kwargs: Keyword arguments to pass to each handler. def off(self, event_name: str, handler: callable) -> None: Remove a specific handler from an event. :param event_name: The name of the event. :param handler: The handler to remove. ``` **Input**: - `on(event_name, handler)`: Register an event handler (`handler`) for the specified `event_name`. - `emit(event_name, *args, **kwargs)`: Emit an event (`event_name`) with optional positional (`*args`) and keyword arguments (`**kwargs`) that will be passed to each handler. - `off(event_name, handler)`: Remove a specific handler (`handler`) from the specified `event_name`. **Output**: - The methods do not return any value. The effect of the methods is observed through the behavior of registered handlers upon event emission. **Constraints**: - Event names (`event_name`) are non-empty strings. - Handlers are callable and can accept both positional and keyword arguments. - The number of different event types is at most 100. - The number of handlers for each event type is at most 100. **Example**: ```python def handler_a(*args, **kwargs): print(\\"Handler A called with\\", args, kwargs) def handler_b(*args, **kwargs): print(\\"Handler B called with\\", args, kwargs) em = EventEmitter() em.on(\'test_event\', handler_a) em.on(\'test_event\', handler_b) em.emit(\'test_event\', 1, 2, key=\'value\') # Expected Output: # Handler A called with (1, 2) {\'key\': \'value\'} # Handler B called with (1, 2) {\'key\': \'value\'} em.off(\'test_event\', handler_a) em.emit(\'test_event\', 1, 2, key=\'value\') # Expected Output: # Handler B called with (1, 2) {\'key\': \'value\'} ``` Your implementation will be tested against multiple cases, including edge cases and performance-critical scenarios. Ensure that your solution correctly handles all specified interactions and verifies the behavior of the event system under various conditions.","solution":"class EventEmitter: def __init__(self): self.events = {} def on(self, event_name: str, handler: callable) -> None: if event_name not in self.events: self.events[event_name] = [] self.events[event_name].append(handler) def emit(self, event_name: str, *args, **kwargs) -> None: handlers = self.events.get(event_name, []) for handler in handlers: handler(*args, **kwargs) def off(self, event_name: str, handler: callable) -> None: if event_name in self.events: self.events[event_name].remove(handler) if not self.events[event_name]: del self.events[event_name]"},{"question":"# Fibonacci Sequence Analysis Write a function named `extended_fibonacci(n: int) -> List[int]` that returns the first `n` Fibonacci numbers. In addition to generating the sequence, include an analysis of its properties. Requirements: 1. The function should generate the sequence of Fibonacci numbers up to the `n`th term. 2. It should return a list containing the sequence. 3. Along with the sequence, perform a simple analysis to identify and print: - The sum of the first `n` Fibonacci numbers. - The average value of the first `n` Fibonacci numbers. 4. Ensure the function handles edge cases such as `n = 0`. Constraints: - `0 <= n <= 10^5` Expected Input and Output: ```python >>> extended_fibonacci(0) { \\"sequence\\": [], \\"sum\\": 0, \\"average\\": None } >>> extended_fibonacci(1) { \\"sequence\\": [0], \\"sum\\": 0, \\"average\\": 0.0 } >>> extended_fibonacci(2) { \\"sequence\\": [0, 1], \\"sum\\": 1, \\"average\\": 0.5 } >>> extended_fibonacci(5) { \\"sequence\\": [0, 1, 1, 2, 3], \\"sum\\": 7, \\"average\\": 1.4 } >>> extended_fibonacci(10) { \\"sequence\\": [0, 1, 1, 2, 3, 5, 8, 13, 21, 34], \\"sum\\": 88, \\"average\\": 8.8 } ```","solution":"from typing import List, Dict, Union def extended_fibonacci(n: int) -> Dict[str, Union[List[int], int, float]]: Generates the first n Fibonacci numbers and performs an analysis on the sequence. Args: n (int): The number of Fibonacci numbers to generate. Returns: dict: A dictionary containing: - \\"sequence\\": List[int] - The Fibonacci sequence of length n. - \\"sum\\": int - The sum of the first n Fibonacci numbers. - \\"average\\": float - The average value of the first n Fibonacci numbers. If n is zero, average is None. if n == 0: return {\\"sequence\\": [], \\"sum\\": 0, \\"average\\": None} sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) sequence = sequence[:n] sum_fib = sum(sequence) average_fib = sum_fib / n return {\\"sequence\\": sequence, \\"sum\\": sum_fib, \\"average\\": average_fib}"},{"question":"# Problem Statement You are tasked with writing a function to manage the basic operations of a simplified banking system. The system records deposits and withdrawals and can calculate the current balance. Your job is to implement the function `process_transactions` that calculates the final balance after a series of transactions. # Function Signature ```python def process_transactions( initial_balance: float, # initial_balance should be in USD. transactions: list # transactions should be a list of tuples containing transaction type and amount. ) -> float: pass ``` # Input - A non-negative float for `initial_balance` (Initial balance in USD). - A list of tuples for `transactions`: - Each tuple contains a string (either `deposit` or `withdrawal`) and a positive float representing the transaction amount. # Output - Returns the final balance as a float rounded to two decimal places. # Constraints - `initial_balance >= 0` - The transaction type must be either `deposit` or `withdrawal`, otherwise raise a `ValueError` with the message: \\"Transaction type must be \'deposit\' or \'withdrawal\'.\\" - The transaction amount must be positive, otherwise raise a `ValueError` with the message: \\"Transaction amount must be positive.\\" # Example ```python >>> process_transactions(100.0, [(\'deposit\', 50.0), (\'withdrawal\', 30.0)]) 120.00 >>> process_transactions(200.0, [(\'withdrawal\', 100.0), (\'deposit\', 25.0), (\'withdrawal\', 50.0)]) 75.00 >>> process_transactions(50.0, [(\'deposit\', 20.0), (\'withdrawal\', -15.0)]) Traceback (most recent call last): ... ValueError: Transaction amount must be positive. >>> process_transactions(150.0, [(\'transfer\', 50.0)]) Traceback (most recent call last): ... ValueError: Transaction type must be \'deposit\' or \'withdrawal\'. ``` Your task is to implement this function such that all constraints are met and it accurately computes the final balance after processing all transactions.","solution":"def process_transactions(initial_balance: float, transactions: list) -> float: balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if amount <= 0: raise ValueError(\\"Transaction amount must be positive.\\") if transaction_type == \'deposit\': balance += amount elif transaction_type == \'withdrawal\': balance -= amount else: raise ValueError(\\"Transaction type must be \'deposit\' or \'withdrawal\'.\\") return round(balance, 2)"},{"question":"# Coding Question Context A financial firm needs a utility to help summarize the performance of its financial assets. Performance data for each asset is provided as a list of daily price changes. For each asset, they need a tool to identify the period with the highest cumulative gain. Problem Given a list of daily price changes for a financial asset, implement a function to identify the maximum sum of any non-empty contiguous subarray of the list of changes. This task is commonly referred to as finding the maximum subarray sum, which can be efficiently solved using Kadane\'s algorithm. Requirements 1. Implement the function using an efficient algorithm. 2. Your solution should handle both positive and negative numbers. 3. Ensure the function accurately finds the maximum sum of any contiguous subarray. Function Signature ```python def max_subarray_sum(price_changes: list[int]) -> int: Finds the maximum sum of any contiguous subarray. :param price_changes: List of integers representing daily price changes. :return: Maximum sum of any contiguous subarray. Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([]) 0 ``` Constraints 1. The input list can contain negative and positive integers. 2. The length of the input list ranges from 0 to 10^5. Input/Output Format * **Input**: A list of integers representing daily price changes. * **Output**: An integer representing the maximum sum of any contiguous subarray. Examples 1. `max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])` should return `6` (4 + (-1) + 2 + 1). 2. `max_subarray_sum([1, 2, 3, 4, 5])` should return `15` (1 + 2 + 3 + 4 + 5). 3. `max_subarray_sum([-1, -2, -3, -4, -5])` should return `-1` (-1). Notes 1. Handle edge cases, such as an empty list, where the maximum sum should be considered as 0. 2. Use Kadane\'s algorithm for an optimal solution with O(n) time complexity.","solution":"def max_subarray_sum(price_changes: list[int]) -> int: Finds the maximum sum of any contiguous subarray. :param price_changes: List of integers representing daily price changes. :return: Maximum sum of any contiguous subarray. if not price_changes: # Edge case for empty list return 0 max_current = max_global = price_changes[0] for change in price_changes[1:]: max_current = max(change, max_current + change) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Matrix Region Sum Query Context: Matrix region sum queries are a common type of problem in competitive programming and data analysis. This problem involves pre-processing a 2D matrix to answer sum queries efficiently. Problem Statement: Write a class `MatrixSumQuery` which processes a given 2D matrix and should be able to answer sum queries on any submatrix efficiently. The class should contain the following methods: * `__init__(matrix: List[List[int]])` - Initializes the object with a 2D matrix. * `query_sum(row1: int, col1: int, row2: int, col2: int) -> int` - Returns the sum of the elements within the rectangle defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`. Input: * `matrix` - a list of lists of integers, representing a 2D matrix. The number of rows and columns in the matrix will be between 1 and 300. * `(row1, col1, row2, col2)` - four integers representing the coordinates of the submatrix. Output: * An integer representing the sum of the elements within the specified submatrix. Example: ```python matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] mq = MatrixSumQuery(matrix) print(mq.query_sum(2, 1, 4, 3)) # Output: 8 print(mq.query_sum(1, 1, 2, 2)) # Output: 11 print(mq.query_sum(1, 2, 2, 4)) # Output: 12 ``` # Constraints: 1. Each element of the matrix is an integer in the range -10000 to 10000. 2. The submatrix indices will always be valid. # Function Signatures: ```python from typing import List class MatrixSumQuery: def __init__(self, matrix: List[List[int]]): pass def query_sum(self, row1: int, col1: int, row2: int, col2: int) -> int: pass ``` # Notes: * Pre-process the matrix to handle sum queries efficiently. * Optimize for both time and space complexity. * Consider the possible edge cases such as querying a single-element submatrix or the entire matrix.","solution":"from typing import List class MatrixSumQuery: def __init__(self, matrix: List[List[int]]): if not matrix or not matrix[0]: raise ValueError(\\"Matrix cannot be empty.\\") self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) self.prefix_sum = [[0] * (self.cols + 1) for _ in range(self.rows + 1)] # Build the prefix sum matrix for i in range(1, self.rows + 1): for j in range(1, self.cols + 1): self.prefix_sum[i][j] = (self.matrix[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1]) def query_sum(self, row1: int, col1: int, row2: int, col2: int) -> int: row2 += 1 col2 += 1 return (self.prefix_sum[row2][col2] - self.prefix_sum[row1][col2] - self.prefix_sum[row2][col1] + self.prefix_sum[row1][col1])"},{"question":"# Polynomial Regression Implementation **Problem Statement:** As a software developer for a scientific computing company, you are tasked with implementing a polynomial regression algorithm. The polynomial regression should be able to fit a dataset using a polynomial function of specified degree. Your goal is to provide a solution that fits a polynomial to a given set of data points and predicts new values. **Requirements:** 1. Implement a function `polynomial_regression` that takes as input a dataset (`data`), a degree (`degree`), and a list of new x-values (`new_x_values`). 2. The function should return a list of predicted y-values corresponding to the new x-values. 3. You should use the least squares method to fit the polynomial. **Function Signature:** ```python def polynomial_regression(data: List[Tuple[float, float]], degree: int, new_x_values: List[float]) -> List[float]: ... ``` **Input:** - `data` : A list of tuples where each tuple contains an x-value and a y-value. Example: `[(x1, y1), (x2, y2), ...]` - `degree` : An integer representing the degree of the polynomial to fit. - `new_x_values` : A list of float values for which the predictions are to be made. **Output:** - `y_predictions` : A list of float values representing the predicted y-values for the given `new_x_values`. **Constraints:** - The degree of the polynomial must be a non-negative integer. - The number of data points will be at least the degree of the polynomial plus one. - The results must be computed using least squares fitting without using any specialized polynomial fitting libraries. **Performance Requirements:** 1. The solution should handle typical dataset sizes efficiently. 2. Ensure that numerical stability is considered when solving for polynomial coefficients. **Example:** ```python data = [ (1.0, 6.0), (2.0, 18.0), (3.0, 26.0), (4.0, 40.0) ] degree = 2 new_x_values = [1.5, 2.5, 3.5] result = polynomial_regression(data, degree, new_x_values) print(result) # Expected output (approximately): # [12.0, 22.0, 34.0] ``` **Note:** - Use NumPy for matrix operations. - Implement the solution without using pre-built polynomial regression functions. - You may write helper functions to handle matrix creation and solving. **Instructions:** - Ensure that your code is well-documented with appropriate comments. - The implementation should include checks for valid inputs. - Thoroughly test your function using sample data provided and additional test cases.","solution":"import numpy as np from typing import List, Tuple def polynomial_regression(data: List[Tuple[float, float]], degree: int, new_x_values: List[float]) -> List[float]: Performs polynomial regression using least squares method and predicts y-values for given x-values. Parameters: data (List[Tuple[float, float]]): The dataset of (x, y) points. degree (int): The degree of the polynomial to fit. new_x_values (List[float]): The x-values for which we want to predict y-values. Returns: List[float]: Predicted y-values for new_x_values. # Extract x and y values from the data x_values, y_values = zip(*data) # Create the Vandermonde matrix for x_values A = np.vander(x_values, degree + 1) # Convert y_values to a numpy array y = np.array(y_values) # Calculate the polynomial coefficients using the least squares fit coeffs, residuals, rank, s = np.linalg.lstsq(A, y, rcond=None) # Predict y-values for new_x_values using the polynomial coefficients A_new = np.vander(new_x_values, degree + 1) y_predictions = A_new.dot(coeffs) return y_predictions.tolist()"},{"question":"# Coding Assessment Question: Minimum Spanning Tree with Kruskal\'s Algorithm Scenario You are tasked with implementing a function to find the Minimum Spanning Tree (MST) of a connected, undirected, weighted graph using Kruskal\'s algorithm. The graph will be represented by an edge list. Function Signature ```python def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: pass ``` Input - `n`: An integer representing the number of nodes in the graph. - `edges`: A list of tuples, where each tuple contains three integers `(u, v, w)` representing an edge between nodes `u` and `v` with weight `w`. Output - Returns a list of tuples representing the edges in the MST. Each tuple contains three integers `(u, v, w)`, same as the input edge list format. Constraints - Each node is labeled with a unique integer from `0` to `n-1`. - The number of edges will not exceed `10^4`. - The graph is guaranteed to be connected. Performance Requirements - The solution should efficiently handle graphs with up to `10^4` edges. - Kruskal\'s algorithm typically runs in O(E log E) time complexity, which is suitable for this problem. Example ```python n = 4 edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] # One of the MSTs can be: # Edges: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] assert minimum_spanning_tree(n, edges) == [(2, 3, 4), (0, 3, 5), (0, 1, 10)] ``` Detailed Steps 1. Initialize a list to store the edges of the MST. 2. Sort all edges based on their weights in non-decreasing order. 3. Initialize a union-find (disjoint-set) data structure to keep track of connected components. 4. Iterate over the sorted edges: - For each edge, use the union-find structure to determine if the endpoints of the edge belong to different components. - If so, add the edge to the MST and union the components. 5. Continue until the MST contains `n-1` edges. 6. Return the list of edges in the MST. Edge Cases - Handle cases where multiple edges have the same weight. - Ensure that the graph remains connected after selecting the edges. - Verify the uniqueness of edge weights to handle degeneracies appropriately. # Implementation Notes Implement the union-find data structure with path compression and union by rank to achieve near constant-time performance for the union and find operations. Carefully organize and sort the edges to ensure Kruskal\'s algorithm runs efficiently, even for large input sizes.","solution":"from typing import List, Tuple def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Find the Minimum Spanning Tree of a connected, undirected, weighted graph using Kruskal\'s algorithm. # Kruskal\'s algorithm requires sorting edges by weight edges.sort(key=lambda edge: edge[2]) parent = list(range(n)) rank = [0] * n def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): rootU = find(u) rootV = find(v) if rootU != rootV: if rank[rootU] > rank[rootV]: parent[rootV] = rootU elif rank[rootU] < rank[rootV]: parent[rootU] = rootV else: parent[rootV] = rootU rank[rootU] += 1 mst = [] mst_cost = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst.append((u, v, weight)) mst_cost += weight if len(mst) == n - 1: break return mst"},{"question":"Question **Problem Statement: Implement Custom String to Integer Conversion** You are tasked to implement a function that converts a string to an integer (similar to Python\'s built-in `int` function), handling various scenarios such as leading/trailing spaces, optional sign, invalid input strings, and overflow. # Function Signature ```python def custom_atoi(s: str) -> int: Convert a string to an integer with enhanced error checking and edge case handling. Parameters: s (str): The input string. Returns: int: The converted integer. Raises: ValueError: If the string cannot be converted to a valid integer. ``` # Requirements 1. The function should ignore leading and trailing whitespace. 2. The function must handle an optional initial \'+\' or \'-\' sign. 3. If the input string is empty or consists of only spaces return 0. 4. Return `ValueError` for invalid input such as strings with characters beyond digits (excluding the sign at the beginning). 5. Handle overflow cases by returning `INT_MAX (2**31 - 1)` if the result is greater than `INT_MAX` and `INT_MIN (-(2**31))` if the result is less than `INT_MIN`. # Input Format - A single string. # Output Format - An integer representing the converted number or a raised `ValueError` for invalid input. # Constraints - You should not use any external libraries, only standard string manipulation methods. - The function should handle inputs within the 32-bit signed integer range. # Example ```python >>> custom_atoi(\\"42\\") 42 >>> custom_atoi(\\" -42\\") -42 >>> custom_atoi(\\"4193 with words\\") ValueError: Invalid input string >>> custom_atoi(\\"words and 987\\") ValueError: Invalid input string >>> custom_atoi(\\"-91283472332\\") -2147483648 >>> custom_atoi(\\"2147483648\\") 2147483647 ``` Document your function thoughtfully to explain the approach taken, edge cases handled, and any specific considerations unique to the problem.","solution":"def custom_atoi(s: str) -> int: Convert a string to an integer with enhanced error checking and edge case handling. Parameters: s (str): The input string. Returns: int: The converted integer. Raises: ValueError: If the string cannot be converted to a valid integer. s = s.strip() if not s: return 0 INT_MAX = 2**31 - 1 INT_MIN = -(2**31) sign = 1 if s[0] == \'+\': s = s[1:] elif s[0] == \'-\': sign = -1 s = s[1:] number = 0 for char in s: if char.isdigit(): number = number * 10 + int(char) if sign * number > INT_MAX: return INT_MAX if sign * number < INT_MIN: return INT_MIN else: raise ValueError(\\"Invalid input string\\") return sign * number"},{"question":"# Problem Statement Write a function `depth_sum` that calculates the sum of all integers in a nested list weighted by their depth. The depth of the top-level list is considered to be 1. If an element is itself a list, you should calculate its sum by multiplying each of its elements by its depth, and add that to the overall sum. # Function Signature ```python def depth_sum(nested_list: List) -> int: ``` # Input - `nested_list`: A possibly nested list where each element is either an integer or a nested list. # Output - Returns the sum of all integers in the list weighted by their depth. # Constraints - The nested list can have a depth of up to 50. - Each integer in the list is in the range `[-1000, 1000]`. - The number of elements in the entire structure will not exceed 1000. # Example ```python # Example 1: nested_list_1 = [1, [4, [6]]] # Weight calculation: # 1 * 1 (depth 1) + 4 * 2 (depth 2) + 6 * 3 (depth 3) # Result = 1 + 8 + 18 = 27 assert depth_sum(nested_list_1) == 27 # Example 2: nested_list_2 = [[1, 1], 2, [1, 1]] # Weight calculation: # 1 * 2 (depth 2) + 1 * 2 (depth 2) + 2 * 1 (depth 1) + 1 * 2 (depth 2) + 1 * 2 (depth 2) # Result = 2 + 2 + 2 + 2 + 2 = 10 assert depth_sum(nested_list_2) == 10 ``` # Detailed Description 1. **Algorithm to Calculate Depth Sum** - Design a helper function that processes the nested list and keeps track of the current depth. - Recursively traverse each element in the list. - If an element is an integer, multiply it by the current depth and add to the total sum. - If an element is a list, recursively call the helper function with incremented depth. 2. **Base Cases** - If the list is empty, return 0. # Code Template ```python from typing import List, Union def depth_sum(nested_list: List[Union[int, List]]) -> int: def helper(nested, depth): total = 0 for element in nested: if isinstance(element, list): total += helper(element, depth + 1) else: total += element * depth return total return helper(nested_list, 1) ``` Use this implementation to ensure that it behaves correctly for the given examples and handles various edge cases like deeply nested lists, lists with negative integers, and empty lists effectively.","solution":"from typing import List, Union def depth_sum(nested_list: List[Union[int, List]]) -> int: def helper(nested, depth): total = 0 for element in nested: if isinstance(element, list): total += helper(element, depth + 1) else: total += element * depth return total return helper(nested_list, 1)"},{"question":"Implement a function `prime_indices` that takes a list of integers and returns a list of indices where the elements are prime numbers. A prime number is a natural number greater than 1 that is not divisible by any positive integers other than 1 and itself. Function Signature ```python def prime_indices(numbers: List[int]) -> List[int]: ``` Input * `numbers`: A list of integers. Output * A list of integers indicating the indices of prime numbers in the input list. Constraints * The input list will have at least one integer. * The integers in the input list are non-negative and less than or equal to 1000. Example ```python >>> prime_indices([0, 1, 2, 3, 4, 5, 6, 7]) [2, 3, 5, 7] >>> prime_indices([10, 14, 17, 19, 21, 23]) [2, 3, 5] >>> prime_indices([4, 6, 8, 9]) [] ``` In the case of `prime_indices([0, 1, 2, 3, 4, 5, 6, 7])`, the function returns `[2, 3, 5, 7]` because 2, 3, 5, and 7 are the indices where the prime numbers appear in the input list.","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def prime_indices(numbers: List[int]) -> List[int]: return [index for index, number in enumerate(numbers) if is_prime(number)]"},{"question":"You are tasked with implementing a class `LRUCache` which uses a fixed-size cache to store key-value pairs, following the Least Recently Used (LRU) eviction policy. In this cache, the least recently utilized entry is removed when the capacity is exceeded. # Functionality Requirements: 1. **`__init__(capacity)`**: Initializes a new LRU cache with the given capacity. 2. **`get(key)`**: Retrieves the value associated with the key, updating its usage. If the key doesn\'t exist, return -1. 3. **`put(key, value)`**: Inserts or updates the key-value pair in the cache. If the cache exceeds the given capacity, it evicts the least recently used item. # Input and Output Formats: - **`__init__(capacity)`**: - Input: `capacity` is an integer. - Output: None - **`get(key)`**: - Input: `key` is an integer. - Output: The value associated with the key (or -1 if key doesn\'t exist). - **`put(key, value)`**: - Input: `key` and `value` are integers. - Output: None. # Constraints: 1. The cache initializes with a fixed capacity. 2. `1 <= capacity <= 1000` 3. `0 <= key, value <= 10^5` 4. Sequence of `get` and `put` operations will not exceed 10000. # Performance Requirements: Ensure that both `get` and `put` operations occur in O(1) average time complexity. # Example Usage: ```python # Initialize cache with capacity 2 cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Your task is to complete the given class `LRUCache` and implement the methods as per the description.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Scenario You are developing a dynamic content management system where articles are continuously added, read and updated. Each article has a unique identifier, content, and a timestamp of the last update. Your goal is to implement a system that allows efficient management of articles. # Task Description Implement an `ArticleManager` class that keeps track of articles. The `ArticleManager` class should provide the following functionalities: 1. Add a new article. 2. Read an article\'s content. 3. Update an article\'s content and automatically update its timestamp. 4. Retrieve the most recently updated article. # Input and Output Formats `ArticleManager` class should have the following methods: - `add_article(id: str, content: str, timestamp: int)`: Adds a new article with the given id, content, and timestamp. - `get_article_content(id: str) -> str`: Returns the content of the specified article. - `update_article(id: str, new_content: str, new_timestamp: int)`: Updates the content of the specified article to `new_content` and its timestamp to `new_timestamp`. - `get_latest_article() -> str`: Returns the id of the most recently updated article. # Constraints - Article ids are unique. - The articles will not exceed (mathbf{10^5}). - Timestamps are integers. # Example ```python manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) manager.add_article(\\"A2\\", \\"Initial Content A2\\", 2) manager.add_article(\\"A3\\", \\"Initial Content A3\\", 3) assert manager.get_article_content(\\"A1\\") == \\"Initial Content A1\\" manager.update_article(\\"A1\\", \\"Updated Content A1\\", 4) assert manager.get_article_content(\\"A1\\") == \\"Updated Content A1\\" assert manager.get_latest_article() == \\"A1\\" manager.update_article(\\"A2\\", \\"Updated Content A2\\", 5) assert manager.get_latest_article() == \\"A2\\" assert manager.get_latest_article() == \\"A2\\" ``` # Requirements Ensure that your implementation is efficient and handles all edge cases appropriately.","solution":"class ArticleManager: def __init__(self): self.articles = {} self.latest_article_id = None def add_article(self, id: str, content: str, timestamp: int): self.articles[id] = {\'content\': content, \'timestamp\': timestamp} if self.latest_article_id is None or self.articles[self.latest_article_id][\'timestamp\'] < timestamp: self.latest_article_id = id def get_article_content(self, id: str) -> str: article = self.articles.get(id) if article is not None: return article[\'content\'] return None def update_article(self, id: str, new_content: str, new_timestamp: int): if id in self.articles and self.articles[id][\'timestamp\'] < new_timestamp: self.articles[id][\'content\'] = new_content self.articles[id][\'timestamp\'] = new_timestamp if self.latest_article_id is None or self.articles[self.latest_article_id][\'timestamp\'] < new_timestamp: self.latest_article_id = id def get_latest_article(self) -> str: return self.latest_article_id"},{"question":"# Question: Implement Depth-First Search to Detect Cycles in a Directed Graph You are given a directed graph represented as an adjacency list. Your task is to implement Depth-First Search (DFS) to detect any cycles in the graph. If a cycle is detected, return `True`, otherwise return `False`. Input - A graph `graph` represented as a dictionary where keys are node identifiers (strings) and values are lists of adjacent nodes (strings). Output - A boolean value `True` if there is at least one cycle in the graph, `False` otherwise. Constraints 1. The graph may contain several disconnected components. 2. All nodes in the graph will have unique identifiers. Function Signature ```python def contains_cycle(graph: dict) -> bool: pass ``` Example ```python graph1 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } print(contains_cycle(graph1)) # Output: True graph2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"] } print(contains_cycle(graph2)) # Output: False graph3 = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [] } print(contains_cycle(graph3)) # Output: True ``` Guidelines - Ensure that your DFS implementation visits each node and keeps track of the visited nodes as well as the call stack to detect back edges. - Handle graphs with disconnected components by iterating through all nodes and initiating a DFS from each unvisited node. - Consider using a recursive approach for the DFS traversal with a helper function to manage the state.","solution":"def contains_cycle(graph: dict) -> bool: def dfs(node, visited, stack): visited.add(node) stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, stack): return True elif neighbor in stack: return True stack.remove(node) return False visited = set() for node in graph: if node not in visited: if dfs(node, visited, set()): return True return False"},{"question":"# Rotate Image You are tasked with creating an image processing tool that performs a fundamental transformation on images stored in a 2D matrix format. One such transformation is rotating the image 90 degrees clockwise. Write a function `rotate_image` that takes as input an `n x n` 2D matrix representing an image and rotates the image by 90 degrees clockwise in place. # Input: - A 2D list `matrix` of integers of size `n x n` where `1 <= n <= 1000`. # Output: - The same 2D list `matrix` should be modified to reflect the rotated image. # Constraints: - The input matrix will have dimensions n x n. - Each element in the matrix can be any integer within the range `[-10^4, 10^4]`. # Example: ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_image(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] >>> rotate_image(matrix) >>> print(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Performance: Aim for a solution with O(n^2) time complexity and O(1) additional space complexity. # Note: The transformation must be done in place, meaning you cannot use additional data structures other than the input matrix itself to perform the rotation.","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# List Flattening and Filtering You are required to implement a function that takes a nested list of integers and returns a flattened list with all elements filtered based on a specified condition. The specified condition is that the number must be even. **Function Signature**: `def flatten_and_filter(lst: list) -> list:` # Requirements: 1. Flatten the nested list of integers into a single list. 2. Filter out all odd integers, keeping only even integers in the flattened list. 3. Return the resulting filtered list in the same order as they appeared in the original list. # Input and Output Formats: * **Input**: A single list `lst` which contains either integer elements or nested lists of integers. The nesting can be arbitrary (i.e., the list can contain lists within lists to any depth). * **Output**: A list of even integers in the same order as they appear in the input list. # Constraints: * The input list may be deeply nested. * The elements in the list are guaranteed to be integers or lists of integers. * Ensure that the function handles empty lists or nested empty lists correctly. # Examples: 1. `flatten_and_filter([1, 2, [3, [4, 5, [6]]], 7])` should return `[2, 4, 6]`. 2. `flatten_and_filter([[8, 9], [10, [11, 12]], 13])` should return `[8, 10, 12]`. 3. `flatten_and_filter([[[[14]], [[15, 16]]], 17, 18])` should return `[14, 16, 18]`. 4. `flatten_and_filter([1, 3, [5], [7, [9]]])` should return `[]`. Ensure to handle edge cases such as large inputs, deeply nested lists, and lists where no elements meet the condition. Test your function rigorously for correctness and performance.","solution":"def flatten_and_filter(lst): Processes a nested list of integers, flattens it and filters out odd numbers. Args: lst (list): A nested list of integers. Returns: list: A flattened list containing only even numbers. def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return [item for item in flatten(lst) if item % 2 == 0]"},{"question":"**[Question 2]:** You are given a linked list containing various integers. Your task is to write a function that partitions this list around a value `x` such that all nodes less than `x` come before nodes greater than or equal to `x`. The partitioning should preserve the original relative order of the nodes in each of the two partitions. **Requirements**: 1. Implement `partition` function in the `LinkedList` class to rearrange the nodes according to the rules described above. 2. Expected Time Complexity: O(N), where N is the number of nodes in the linked list. 3. Expected Space Complexity: O(1), operate in-place without using additional data structures. **Function Signature**: ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def partition(self, x: int) -> None: # Your implementation here pass ``` **Input/Output**: - Input: A linked list and an integer `x`. - Output: None (rearrange the linked list in place). **Constraints**: - The values in the linked list are integers. - The list can be empty or contain up to 10^5 nodes. - The integer `x` is guaranteed to be within the range of the values in the linked list. **Examples**: ```python # Example 1 ll1 = LinkedList() ll1.head = Node(1) ll1.head.next = Node(4) ll1.head.next.next = Node(3) ll1.head.next.next.next = Node(2) ll1.head.next.next.next.next = Node(5) ll1.head.next.next.next.next.next = Node(2) ll1.partition(3) # After partitioning around 3, the list should be: 1 -> 2 -> 2 -> 4 -> 3 -> 5 # Example 2 ll2 = LinkedList() ll2.head = Node(2) ll2.head.next = Node(1) ll2.partition(2) # After partitioning around 2, the list should be: 1 -> 2 # Example 3 ll3 = LinkedList() ll3.partition(1) # For an empty linked list, the output is still an empty list. ``` **Hint**: Maintain two pointers that traverse the list: one to build the list of nodes less than `x` and one to build the list of nodes greater than or equal to `x`. After traversing the entire list, combine the two lists.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def partition(self, x: int) -> None: less_head = less_tail = Node() greater_head = greater_tail = Node() current = self.head while current: if current.value < x: less_tail.next = current less_tail = current else: greater_tail.next = current greater_tail = current current = current.next less_tail.next = greater_head.next greater_tail.next = None self.head = less_head.next"},{"question":"# Coding Assessment Question **Scenario**: You are developing utilities for managing user data in a social media application. One of the challenges is to pinpoint the most active users based on the frequency of their interactions. You are tasked with identifying the top `k` most frequent elements (user IDs) from a list of user interactions. **Task**: Write a function to determine the `k` most frequent elements in a list. If multiple elements have the same frequency, any order of the elements with the same frequency can be returned. **Function Signature**: ```python def top_k_frequent_elements(arr: list, k: int) -> list: pass ``` **Input**: * `arr`: A list of integers representing user interactions (user IDs). (0 <= len(arr) <= 10^5, -10^4 <= arr[i] <= 10^4). * `k`: An integer representing the number of most frequent elements to return (1 <= k <= len(arr)). **Output**: * A list containing `k` integers in any order, each representing a unique user ID. **Constraints**: * The list should contain exactly `k` most frequent elements. * Each element in the output should be unique. **Performance**: * Your solution should efficiently handle the maximum constraints by using appropriate data structures to ensure optimal time complexity. **Examples**: ```python >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent_elements([1], 1) [1] >>> top_k_frequent_elements([4, 4, 4, 1, 1, 2, 2, 3], 3) [4, 1, 2] ``` Implement the function `top_k_frequent_elements`.","solution":"from collections import Counter import heapq def top_k_frequent_elements(arr, k): Returns the k most frequent elements in the given list. if not arr: return [] # Count the frequency of each element in the array frequency = Counter(arr) # Use a heap to find the k elements with the highest frequency most_frequent = heapq.nlargest(k, frequency.keys(), key=frequency.get) return most_frequent"},{"question":"# Sorting and Filtering: Music Library Organizer You are tasked with developing a small part of a music library organizer application. The application must handle a collection of songs and perform various operations on this collection. Each song in the collection has the following attributes: title, artist, duration (in seconds), and genre. # Task Implement a function that sorts the collection of songs based on their duration and filters them by a specific genre. Function Signature ```python def organize_music_library(songs: list, genre: str) -> list: Sorts and filters a collection of songs based on their duration and genre, respectively. Parameters: songs (list): A list of dictionaries, where each dictionary represents a song with keys \'title\', \'artist\', \'duration\' (in seconds), and \'genre\'. genre (str): The genre by which to filter the songs. Returns: list: A sorted and filtered list of songs, sorted by their duration in ascending order and filtered by the specified genre. Raises: TypeError: If songs is not a list of dictionaries or genre is not a string. ValueError: If any song does not contain the required keys. pass ``` # Constraints 1. Each song in the `songs` list must be a dictionary with the keys \'title\', \'artist\', \'duration\', and \'genre\'. 2. The `duration` should be a positive integer. 3. The `genre` should be a non-empty string. 4. If these constraints are not met, raise appropriate exceptions (`TypeError` or `ValueError`). # Expected Output Format The function should return a list of songs sorted by duration in ascending order and filtered to include only songs that match the specified genre. # Examples ```python songs = [ {\'title\': \'Song A\', \'artist\': \'Artist 1\', \'duration\': 240, \'genre\': \'Rock\'}, {\'title\': \'Song B\', \'artist\': \'Artist 2\', \'duration\': 180, \'genre\': \'Jazz\'}, {\'title\': \'Song C\', \'artist\': \'Artist 1\', \'duration\': 210, \'genre\': \'Rock\'}, {\'title\': \'Song D\', \'artist\': \'Artist 3\', \'duration\': 300, \'genre\': \'Jazz\'} ] assert organize_music_library(songs, \'Rock\') == [ {\'title\': \'Song C\', \'artist\': \'Artist 1\', \'duration\': 210, \'genre\': \'Rock\'}, {\'title\': \'Song A\', \'artist\': \'Artist 1\', \'duration\': 240, \'genre\': \'Rock\'} ] assert organize_music_library(songs, \'Jazz\') == [ {\'title\': \'Song B\', \'artist\': \'Artist 2\', \'duration\': 180, \'genre\': \'Jazz\'}, {\'title\': \'Song D\', \'artist\': \'Artist 3\', \'duration\': 300, \'genre\': \'Jazz\'} ] ``` # Hints 1. Use the `sorted` function with a lambda function to sort the songs list. 2. Ensure you perform input validation before processing the songs.","solution":"def organize_music_library(songs, genre): Sorts and filters a collection of songs based on their duration and genre, respectively. Parameters: songs (list): A list of dictionaries, where each dictionary represents a song with keys \'title\', \'artist\', \'duration\' (in seconds), and \'genre\'. genre (str): The genre by which to filter the songs. Returns: list: A sorted and filtered list of songs, sorted by their duration in ascending order and filtered by the specified genre. Raises: TypeError: If songs is not a list of dictionaries or genre is not a string. ValueError: If any song does not contain the required keys. # Input checks if not isinstance(songs, list): raise TypeError(\\"songs must be a list.\\") if not isinstance(genre, str): raise TypeError(\\"genre must be a string.\\") filtered_songs = [] for song in songs: if not isinstance(song, dict): raise TypeError(\\"Each song must be a dictionary.\\") if \'title\' not in song or \'artist\' not in song or \'duration\' not in song or \'genre\' not in song: raise ValueError(\\"Each song dictionary must contain \'title\', \'artist\', \'duration\', and \'genre\' keys.\\") if not isinstance(song[\'duration\'], int) or song[\'duration\'] <= 0: raise ValueError(\\"The \'duration\' must be a positive integer.\\") if song[\'genre\'] == genre: filtered_songs.append(song) # Sort the filtered list by \'duration\' in ascending order sorted_songs = sorted(filtered_songs, key=lambda x: x[\'duration\']) return sorted_songs"},{"question":"# Anagram Substring Check Problem Context: In string manipulation, one common task is to determine whether one string is a substring of another. A more complex variation of this problem is checking whether any permutation of one string (anagram) is a substring of another string. This involves sliding windows and hashing techniques to maintain efficiency. Objective: Write a function that determines if any permutation of a given string `s1` is a substring of another string `s2`. Function Signature: ```python def is_anagram_substring(s1: str, s2: str) -> bool: ``` Input: * `s1` (str): a non-empty string, length 1 ≤ len(s1) ≤ 100. * `s2` (str): a non-empty string, length 1 ≤ len(s2) ≤ 10^5. Output: * `True` if any permutation of `s1` is a substring of `s2`. * `False` otherwise. Constraints: * The function should handle string inputs efficiently with lengths as specified. * Consider using efficient sliding window and hashing techniques to achieve the solution. Example: ```python assert is_anagram_substring(\\"ab\\", \\"eidbaooo\\") == True # \\"ba\\" is a permutation of \\"ab\\" and present in \\"eidbaooo\\" assert is_anagram_substring(\\"ab\\", \\"eidboaoo\\") == False # No permutation of \\"ab\\" is a substring of \\"eidboaoo\\" ``` Notes: * You should precompute and compare character counts for efficiency. * Think about edge cases where `s1` is longer than `s2` or where `s1` contains repeating characters.","solution":"from collections import Counter def is_anagram_substring(s1: str, s2: str) -> bool: Determine if any permutation of s1 is a substring of s2. len_s1, len_s2 = len(s1), len(s2) if len_s1 > len_s2: return False counter_s1 = Counter(s1) window_counter = Counter(s2[:len_s1]) if counter_s1 == window_counter: return True for i in range(len_s1, len_s2): window_counter[s2[i]] += 1 window_counter[s2[i - len_s1]] -= 1 if window_counter[s2[i - len_s1]] == 0: del window_counter[s2[i - len_s1]] if counter_s1 == window_counter: return True return False"},{"question":"# Coding Challenge: List Rotation In many applications, it may be necessary to rotate a list by a given number of positions. This is commonly encountered in queue management, task scheduling, and cyclical data access patterns. Your task is to implement list rotation. **Your Task**: - Write a function `rotate_list(lst: List[int], k: int) -> List[int]` that rotates a list to the right by `k` positions. - The rotation should be performed in-place, meaning that the function directly modifies the input list and also returns it. **Input**: - `lst` (List[int]): A list of integers. - `k` (int): The number of positions to rotate the list to the right. **Output**: - A list of integers that has been rotated to the right by `k` positions. **Constraints**: - The list `lst` may contain up to 10^5 elements. - The value of `k` will be a non-negative integer. - If `k` is greater than the length of the list, rotate the list by `k % len(lst)` positions instead. ```python from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Rotate the list to the right by k positions. Parameters: - lst (List[int]): A list of integers. - k (int): Number of positions to rotate the list to the right. Returns: - List[int]: The rotated list. n = len(lst) if n == 0: return lst k = k % n # Normalize k if it\'s greater than the length of the list lst[:] = lst[-k:] + lst[:-k] # Rotate the list in-place return lst ``` **Example Scenarios**: 1. Given the list and positions to rotate: - `lst = [1, 2, 3, 4, 5]` - `k = 2` - Calling `rotate_list(lst, k)` should output `[4, 5, 1, 2, 3]`. 2. Given the list and positions to rotate: - `lst = [10, 20, 30, 40, 50, 60, 70]` - `k = 3` - Calling `rotate_list(lst, k)` should output `[50, 60, 70, 10, 20, 30, 40]`. **Edge cases**: - List is empty. - List length is 1, regardless of the value of `k`. - `k` is zero, meaning no rotation should occur. - `k` is equal to or a multiple of the list length. Ensure your solution handles these appropriately.","solution":"from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Rotate the list to the right by k positions. Parameters: - lst (List[int]): A list of integers. - k (int): Number of positions to rotate the list to the right. Returns: - List[int]: The rotated list. n = len(lst) if n == 0: return lst k = k % n # Normalize k if it\'s greater than the length of the list lst[:] = lst[-k:] + lst[:-k] # Rotate the list in-place return lst"},{"question":"# Problem: Implement a Sudoku Validator Background Sudoku is a popular number puzzle that consists of a 9x9 grid subdivided into 3x3 subgrids. The objective is to fill the grid such that every row, column, and 3x3 subgrid contain the digits 1 to 9 exactly once. Validating a filled Sudoku grid is a common task that requires checking each row, column, and subgrid for compliance with these rules. Task Implement a `SudokuValidator` class in Python that validates a filled Sudoku grid. Input - **Grid**: A 2D list of integers, where each element is an integer from 1 to 9. The grid is guaranteed to be 9x9. Output - A boolean value: `True` if the grid is a valid Sudoku solution, `False` otherwise. Constraints 1. The grid will always be of size 9x9. 2. The grid will only contain integers between 1 and 9. Performance Requirements - The implementation should handle the validation efficiently with a time complexity not exceeding O(N^2) where N is the size of the grid (N=9). Example ```python class SudokuValidator: def __init__(self, grid): self.grid = grid def is_valid(self): return self._check_rows() and self._check_cols() and self._check_subgrids() def _check_rows(self): for row in self.grid: if not self._is_part_valid(row): return False return True def _check_cols(self): for col in range(9): if not self._is_part_valid([self.grid[row][col] for row in range(9)]): return False return True def _check_subgrids(self): for row in range(0, 9, 3): for col in range(0, 9, 3): if not self._is_part_valid([ self.grid[i][j] for i in range(row, row + 3) for j in range(col, col + 3) ]): return False return True def _is_part_valid(self, part): return sorted(part) == list(range(1, 10)) if __name__ == \\"__main__\\": sudoku_grid = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] validator = SudokuValidator(sudoku_grid) print(validator.is_valid()) # Output: True ```","solution":"class SudokuValidator: def __init__(self, grid): self.grid = grid def is_valid(self): return self._check_rows() and self._check_cols() and self._check_subgrids() def _check_rows(self): for row in self.grid: if not self._is_part_valid(row): return False return True def _check_cols(self): for col in range(9): if not self._is_part_valid([self.grid[row][col] for row in range(9)]): return False return True def _check_subgrids(self): for row in range(0, 9, 3): for col in range(0, 9, 3): if not self._is_part_valid([ self.grid[i][j] for i in range(row, row + 3) for j in range(col, col + 3) ]): return False return True def _is_part_valid(self, part): return sorted(part) == list(range(1, 10))"},{"question":"# Problem Statement Write a function to compute the longest common subsequence (LCS) of two strings. The LCS is the longest sequence that can be derived from both strings without changing the order of characters. # Function Specifications **Function Name**: `longest_common_subsequence` **Input**: - A string `A` (0 <= len(A) <= 1000) - A string `B` (0 <= len(B) <= 1000) **Output**: A string representing the longest common subsequence. If there are multiple, return any one of them. # Constraints - The input strings `A` and `B` will consist only of uppercase English letters. # Performance Requirements - Your solution should run in O(n*m) time complexity, where n and m are the lengths of strings `A` and `B`, respectively. - Use dynamic programming to achieve this. # Examples ```python >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") \'BCBA\' >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") \'GTAB\' >>> longest_common_subsequence(\\"\\", \\"ABC\\") \'\' >>> longest_common_subsequence(\\"ABC\\", \\"ABC\\") \'ABC\' ``` # Notes - If `A` and `B` have no common subsequence, the function should return an empty string. - Focus on writing efficient and clean code. - Remember to handle edge cases such as empty strings and strings with no common characters effectively.","solution":"def longest_common_subsequence(A, B): Returns the longest common subsequence of strings A and B. n, m = len(A), len(B) dp = [[\\"\\" for _ in range(m + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + A[i - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len) return dp[n][m]"},{"question":"# File Organizer Script In this task, you are required to develop a Python script that organizes files in a specified directory based on their file types into separate subdirectories. Requirements: - Your script should create subdirectories in the specified directory for each file type encountered. - File types are determined by the file extension (e.g., `.txt`, `.jpg`). - If a file type\'s subdirectory already exists, move the file into the existing subdirectory. - The script should recursively organize files in subdirectories as well. - Ignore hidden files and directories (those starting with a dot `.`). Function Signature: ```python def organize_files(directory: str) -> None: Organize files in a specified directory based on their file types. Parameters: directory (str): The path to the directory to organize. Returns: None ``` Constraints: - The input directory is a valid path, and the user has read/write permissions for it. - The script should handle a large number of files and directories efficiently. - If a file has no extension, place it in a subdirectory named `others`. - If a subdirectory is empty after the reorganization, it should be removed. - Use standard Python libraries for file and directory operations. Example Usage: Assume the following initial structure: ``` /example_directory file1.txt file2.jpg file3.mp3 sub_dir file4.txt ``` After running `organize_files(\'/example_directory\')`, the structure should be: ``` /example_directory /txt file1.txt file4.txt /jpg file2.jpg /mp3 file3.mp3 ``` Performance Requirements: - The function should efficiently handle directories with thousands of files. - It should avoid unnecessary operations to minimize execution time. - Ensure the script can handle concurrent executions or be able to recover gracefully from interruptions.","solution":"import os import shutil def organize_files(directory: str) -> None: Organize files in a specified directory based on their file types. Parameters: directory (str): The path to the directory to organize. Returns: None # Recursively organize files for root, dirs, files in os.walk(directory): # Ignore hidden directories dirs[:] = [d for d in dirs if not d.startswith(\'.\')] for file in files: # Ignore hidden files if file.startswith(\'.\'): continue file_path = os.path.join(root, file) file_name, file_extension = os.path.splitext(file) # Define target subdirectory if file_extension: target_directory = os.path.join(directory, file_extension[1:]) else: target_directory = os.path.join(directory, \'others\') # Create target subdirectory if it doesn\'t exist if not os.path.exists(target_directory): os.makedirs(target_directory) # Move file to target subdirectory shutil.move(file_path, os.path.join(target_directory, file)) # Remove empty directories for root, dirs, files in os.walk(directory, topdown=False): for dir in dirs: dir_path = os.path.join(root, dir) if not os.listdir(dir_path): os.rmdir(dir_path)"},{"question":"# Problem Statement: **Image Pixels Brightness Adjustment** You are required to implement a function `adjust_brightness` that modifies the brightness of an image. Each image is represented as a 2D list of integer tuples. Each tuple contains 3 integers representing the Red, Green, and Blue color values of a pixel. The task is to adjust the brightness by a given factor for all pixels. # Requirements: Implement the function: ```python def adjust_brightness(image: list[list[tuple[int, int, int]]], brightness_factor: float) -> list[list[tuple[int, int, int]]]: Adjusts the brightness of an image. :param image: A 2D list where each element is a tuple (R, G, B), representing the pixel color values. :param brightness_factor: A float representing the adjustment factor. A value > 1 will increase brightness, and a value between 0 and 1 will decrease brightness. :return: A new image with adjusted brightness. :raises ValueError: If brightness_factor <= 0 or pixel values are out of the range 0-255. ``` # Input Constraints: - `image`: A 2D list of dimensions m x n (1 ≤ m, n ≤ 1000). Each element is a tuple (R, G, B), where 0 ≤ R, G, B ≤ 255. - `brightness_factor`: A float, where 0 < `brightness_factor` ≤ 10.0. # Output Constraints: - The output should be a 2D list of the same dimensions as the input `image`. - Each pixel value after adjustment should be clamped within the range 0 to 255. # Example Scenarios: 1. **Example 1**: ```python image = [ [(123, 234, 45), (12, 34, 56)], [(78, 90, 100), (200, 150, 100)] ] brightness_factor = 1.2 new_image = adjust_brightness(image, brightness_factor) print(new_image) # Expected output: # [ # [(147, 255, 54), (14, 40, 67)], # [(93, 108, 120), (240, 180, 120)] # ] ``` 2. **Example 2**: ```python image = [ [(10, 20, 30), (40, 50, 60)], [(100, 110, 120), (130, 140, 150)] ] brightness_factor = 0.5 new_image = adjust_brightness(image, brightness_factor) print(new_image) # Expected output: # [ # [(5, 10, 15), (20, 25, 30)], # [(50, 55, 60), (65, 70, 75)] # ] ``` # Edge Cases to Consider: - Inputs where some pixel values are at the upper boundary (255) before the adjustment. - Ensure the function correctly clamps values that exceed the range 0-255 after adjustment. - Handling of very high or very low brightness factors close to the constraints.","solution":"def adjust_brightness(image: list[list[tuple[int, int, int]]], brightness_factor: float) -> list[list[tuple[int, int, int]]]: Adjusts the brightness of an image. :param image: A 2D list where each element is a tuple (R, G, B), representing the pixel color values. :param brightness_factor: A float representing the adjustment factor. A value > 1 will increase brightness, and a value between 0 and 1 will decrease brightness. :return: A new image with adjusted brightness. :raises ValueError: If brightness_factor <= 0 or pixel values are out of the range 0-255. if brightness_factor <= 0: raise ValueError(\\"Brightness factor must be greater than zero.\\") def clamp(value): return max(0, min(255, value)) new_image = [] for row in image: new_row = [] for pixel in row: new_pixel = tuple(clamp(int(channel * brightness_factor)) for channel in pixel) new_row.append(new_pixel) new_image.append(new_row) return new_image"},{"question":"# Problem Statement: Efficient Fibonacci Sequence Generation with Memory Optimization The Fibonacci sequence is defined as follows: - (F(0) = 0) - (F(1) = 1) - (F(n) = F(n-1) + F(n-2)) for (n geq 2) Traditionally, computing the (n)-th Fibonacci number can be done using a recursive approach which has exponential time complexity. To optimize, an iterative approach can be employed to save on redundant calculations and excessive memory usage. Task Write a function, `fibonacci(n)`, that takes an integer `n` and returns the `n`-th Fibonacci number using an iterative approach with optimized memory usage. Function Signature ```python def fibonacci(n: int) -> int: ``` Input * `n`: An integer representing the position in the Fibonacci sequence (where (0 leq n leq 1000000)). Output * Returns an integer which is the `n`-th Fibonacci number. Constraints 1. Optimize the function to use (O(1)) space complexity, i.e., constant space. 2. Ensure the algorithm runs with (O(n)) time complexity. Examples ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(50) == 12586269025 ``` Performance Requirements * Ensure that your implementation is efficient and handles the upper limit constraints within reasonable time bounds. Avoid using recursive approaches due to stack overflow risks with large values of (n).","solution":"def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an iterative approach with optimized memory usage. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"New Question # Function Signature ```python def exist(board: List[List[str]], word: str) -> bool: board : List[List[str]] : A 2D grid of characters. word : str : The word to search for in the grid. Returns True if the word exists in the grid; otherwise, False. ``` # Input * `board` (List[List[str]]): A list of lists of characters representing the grid. The grid dimensions can vary but will not exceed 200x200. * `word` (str): The word to search for. Its length will not exceed 200. # Output * Returns `True` if the word exists in the grid according to the specified rules, otherwise `False`. # Constraints 1. The characters in `board` are lowercase alphabets. 2. The function must handle the search efficiently. # Example ```python def test_exist(): board = [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] assert exist(board, \\"ABCCED\\") == True assert exist(board, \\"SEE\\") == True assert exist(board, \\"ABCB\\") == False test_exist() ``` # Explanation 1. The example provided gives a 2D list `board` of characters and words to search. 2. Your solution will perform a depth-first search (DFS) from each cell in the grid to find the word character by character, ensuring the same cell is not used more than once for each instance of the word. 3. For the given example, the word \\"ABCCED\\" exists in the grid, thus returning `True`. Likewise, \\"SEE\\" is also found, but \\"ABCB\\" cannot be constructed without reusing a cell, so it returns `False`. You can assume that input will always be valid and within the specified constraints.","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: # Helper function to perform DFS def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[index]: return False # Mark the current cell as visited temp = board[x][y] board[x][y] = \'#\' # Explore all 4 possible directions found = (dfs(x+1, y, index+1) or dfs(x-1, y, index+1) or dfs(x, y+1, index+1) or dfs(x, y-1, index+1)) # Restore the character in the cell board[x][y] = temp return found # Iterate over each cell in the board for i in range(len(board)): for j in range(len(board[0])): if (board[i][j] == word[0] and dfs(i, j, 0)): return True return False"},{"question":"# Scenario You are working on a system that needs to manage multiple temperature sensors. The system needs to monitor the readings and ensure that they stay within a specific range. If any sensor reading falls outside this range, the system should log an alert. # Task Implement a function that takes a list of temperature readings and a threshold range, then returns a list of indices where the readings are out of the specified range. # Function Signature ```python def check_temperature_readings(readings: list[int], min_temp: int, max_temp: int) -> list[int]: Identify out-of-range temperature readings. :param readings: List of temperature readings as integers. :param min_temp: Minimum acceptable temperature. :param max_temp: Maximum acceptable temperature. :return: List of indices where readings are out of the specified range. :raises ValueError: If min_temp is greater than max_temp. ``` # Input * `readings`: List of integers representing temperature readings. * `min_temp`: An integer representing the minimum acceptable temperature. * `max_temp`: An integer representing the maximum acceptable temperature. # Output Returns a list of indices where the readings are out of the range `[min_temp, max_temp]`. # Constraints * All temperature readings must be integers. * `min_temp` must be less than or equal to `max_temp`. * If `min_temp` is greater than `max_temp`, the function should raise a `ValueError`. # Example ```python >>> check_temperature_readings([15, 30, 25, 40, 10], 20, 35) [0, 3, 4] >>> check_temperature_readings([22, 25, 28, 33, 30], 20, 30) [3] >>> check_temperature_readings([10, 20, 30, 25, 23], 10, 30) [] >>> check_temperature_readings([25, 15, 14, 22, 35], 10, 34) [4] >>> check_temperature_readings([15, 20, 25], 25, 20) Traceback (most recent call last): ... ValueError: min_temp must be less than or equal to max_temp ``` # Notes * Your function should operate with a time complexity of O(n), where n is the number of temperature readings.","solution":"def check_temperature_readings(readings: list[int], min_temp: int, max_temp: int) -> list[int]: Identify out-of-range temperature readings. :param readings: List of temperature readings as integers. :param min_temp: Minimum acceptable temperature. :param max_temp: Maximum acceptable temperature. :return: List of indices where readings are out of the specified range. :raises ValueError: If min_temp is greater than max_temp. if min_temp > max_temp: raise ValueError(\\"min_temp must be less than or equal to max_temp\\") out_of_range_indices = [] for i, reading in enumerate(readings): if reading < min_temp or reading > max_temp: out_of_range_indices.append(i) return out_of_range_indices"},{"question":"# Problem Statement **Generate Permutations of a List** Given a list `lst` of unique integers, implement a function to generate all possible permutations of the elements in the list using a recursive approach. # Requirements 1. **Function Signature**: ```python def generate_permutations(lst): Arguments: lst -- A list of unique integers. Returns: A list of lists, where each inner list is a permutation of the input list. ``` 2. **Input Format**: - `lst`: A list of unique integers. 3. **Output Format**: - Return a list of lists, each representing a different permutation of the integers in `lst`. 4. **Constraints**: - The length of `lst` is between 1 and 8 (inclusive). - All integers in `lst` are unique. 5. **Performance Requirements**: - Ensure that your solution efficiently generates all permutations without unnecessary computations. - Handle the case where the input list is empty. # Example ```python lst = [1, 2, 3] # Example call permutations = generate_permutations(lst) for perm in permutations: print(perm) # Expected output (order of permutations may vary): # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ``` # Notes * Ensure your solution includes appropriate assertions/tests for different scenarios. * Function should work correctly for edge cases, including an empty list and lists of varying lengths up to 8. * The order of the permutations in the output list does not matter.","solution":"def generate_permutations(lst): Generates all possible permutations of the input list lst. Arguments: lst -- A list of unique integers. Returns: A list of lists, where each inner list is a permutation of the input list. def recurse(current, remaining): # Base case: no remaining elements if not remaining: permutations.append(current) return # Recursive case: generate permutations by choosing # each remaining element one by one for i in range(len(remaining)): new_current = current + [remaining[i]] new_remaining = remaining[:i] + remaining[i+1:] recurse(new_current, new_remaining) permutations = [] recurse([], lst) return permutations"},{"question":"# Question: Schedule Overlap Detection You are tasked with developing a function that determines if there is any overlap between two schedules. Each schedule consists of a list of time intervals. An interval is represented by a tuple with start and end times in the format `(start, end)`, where `start` and `end` are integers representing time in hours on a 24-hour clock. Specifications: * Each time interval in the schedule is guaranteed to be valid, meaning the start time is less than the end time, and all times are within the range `0` to `23`. Input: * Two lists of tuples representing the schedules. * The first list represents the `schedule_1`. * The second list represents the `schedule_2`. Output: * A `bool` value indicating whether there is any overlap between the two schedules. Examples: ```python def has_schedule_overlap(schedule_1: list[tuple[int, int]], schedule_2: list[tuple[int, int]]) -> bool: pass # Example Schedules: schedule_1 = [(9, 12), (14, 17)] schedule_2 = [(8, 10), (11, 13)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output True schedule_1 = [(9, 12), (14, 17)] schedule_2 = [(12, 14), (17, 18)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output False ```","solution":"def has_schedule_overlap(schedule_1, schedule_2): Determines if there is any overlap between two schedules. Each schedule is a list of time intervals represented by tuples (start, end). Args: - schedule_1 (list of tuple(int, int)): The first schedule. - schedule_2 (list of tuple(int, int)): The second schedule. Returns: - bool: True if there is any overlap between the two schedules, False otherwise. for start1, end1 in schedule_1: for start2, end2 in schedule_2: # Check if intervals (start1, end1) and (start2, end2) overlap if start1 < end2 and start2 < end1: return True return False"},{"question":"# Square Root Approximation using Newton\'s Method Newton\'s method, also known as the Newton-Raphson method, can be used to approximate the square root of a number. The method iteratively improves the guess for the square root by using the formula: [ x_{n+1} = frac{1}{2} left( x_n + frac{S}{x_n} right) ] where ( S ) is the number for which we want to find the square root, and ( x_n ) is the current approximation. Write a Python function `sqrt_newton_method(S: float, tolerance: float = 1e-10) -> float` that: 1. Accepts a non-negative number ( S ) and an optional tolerance level. 2. Initializes an initial guess for the square root (`x0`), which can be ( S/2 ) or 1 (whichever is greater). 3. Iteratively applies Newton\'s method to improve the guess until the change is smaller than the given tolerance. 4. Returns the approximate square root. # Input - A non-negative floating-point number ( S ). - An optional floating-point number ( tolerance ) with a default value of ( 1e-10 ). # Output - A floating-point number representing the approximate square root of ( S ). # Example ```python >>> sqrt_newton_method(25) 5.0 >>> sqrt_newton_method(2) 1.414213562373095 >>> sqrt_newton_method(0.25) 0.5 >>> sqrt_newton_method(100, 1e-5) 10.000000000163116 ``` # Constraints - ( 0 leq S leq 10^{10} ) - ( 1e-15 leq text{tolerance} leq 1e-5 ) Create the function `sqrt_newton_method` to meet the specifications above, ensuring it handles the given constraints efficiently. If ( S ) is negative, raise a `ValueError` with an appropriate message.","solution":"def sqrt_newton_method(S: float, tolerance: float = 1e-10) -> float: Approximates the square root of a non-negative number S using Newton\'s method. if S < 0: raise ValueError(\\"S must be a non-negative number.\\") if S == 0: return 0.0 x_n = max(S / 2.0, 1.0) while True: x_n1 = 0.5 * (x_n + S / x_n) if abs(x_n1 - x_n) < tolerance: return x_n1 x_n = x_n1"},{"question":"# Coding Assessment Question Objective: You are tasked with implementing a function that efficiently finds the majority element in a list of integers. A majority element is an element that appears more than half of the total number of elements in the list. Your solution should handle both positive and negative integers and should be optimized for performance. Problem Description: Implement a function `find_majority_element(nums: List[int]) -> int` that returns the majority element in the list if it exists. If no majority element exists, the function should return `None`. Function Signature: ```python from typing import List, Optional def find_majority_element(nums: List[int]) -> Optional[int]: pass ``` Input: * `nums` - a list of integers which can be positive, negative, or zero. Output: * The function should return the integer that is the majority element in the list. * If no majority element exists, return `None`. Constraints: * The function should efficiently handle lists of different sizes, including small and very large lists. * Avoid solutions that lead to excessive computation time or space usage. Examples: ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None >>> find_majority_element([6]) 6 >>> find_majority_element([-1, -1, -1, 2, 2]) -1 >>> find_majority_element([1, 2, 3, 4, 5, 6]) None >>> find_majority_element([1, 1, 1, 1, 50]) 1 ``` Performance Requirements: * Your solution should be optimized to have a time complexity of O(n) and a space complexity of O(1).","solution":"from typing import List, Optional def find_majority_element(nums: List[int]) -> Optional[int]: Finds the majority element in a list using the Boyer-Moore Voting Algorithm. The majority element is the element that appears more than half of the total number of elements. Args: nums (List[int]): The list of integers. Returns: Optional[int]: The majority element if it exists, otherwise None. candidate = None count = 0 # Phase 1: Find a potential candidate for majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify if the candidate is actually the majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return None"},{"question":"# Problem Statement You need to implement a simple text-based search engine. The search engine should be able to process a list of documents and retrieve the indices of documents that contain all the words in a given query. The search should be case-insensitive. Your function should: 1. Tokenize the documents by converting them to lowercase and splitting by spaces. 2. Tokenize the query by converting it to lowercase and splitting by spaces. 3. Return the list of indices of documents that contain all the words in the query. # Function Signature ```python def search_engine(documents, query): :param documents: List[str] - List of textual documents. :param query: str - The search query. :return: List[int] - List of indices of documents containing all words in the query. ``` # Constraints & Input Format - `documents` is a list of strings where each string represents a document. Each document is non-empty and has at most 1000 words. - `query` is a non-empty string with at most 10 words. - Each document and query consists solely of English letters and spaces. - The length of `documents` is between `1` and `1000`. # Example ```python documents = [ \\"Machine learning allows computers to learn patterns.\\", \\"Natural Language Processing helps computers understand human language.\\", \\"Machine learning and Natural Language Processing are closely related fields.\\" ] query = \\"machine learning\\" result = search_engine(documents, query) print(result) # Expected output: [0, 2] ``` # Explanation 1. **Tokenization**: Convert each document and the query to lowercase and split them into words. 2. **Search**: Check each document to determine if it contains all the words in the query. 3. **Output**: Return a list of indices of documents that meet the search criteria. - In the above example, the first and third documents both contain the words \\"machine\\" and \\"learning\\". Hence the output is [0, 2].","solution":"def search_engine(documents, query): :param documents: List[str] - List of textual documents. :param query: str - The search query. :return: List[int] - List of indices of documents containing all words in the query. query_words = set(query.lower().split()) result_indices = [] for index, document in enumerate(documents): document_words = set(document.lower().split()) if query_words.issubset(document_words): result_indices.append(index) return result_indices"},{"question":"# Coding Assessment Question You are tasked with developing a function that calculates the time complexity of a given code snippet. The input will be a simplified form of pseudo-code that only includes nested loops. Each loop can be represented as either `for i in 1..N` (iterating from 1 to N inclusive) or `for i in 1..M` (iterating from 1 to M inclusive). The function should analyze these nested loops and return the overall time complexity in Big-O notation. Function Specification Function Name: `time_complexity` Parameters: - `code_snippet` (str): A string representing the pseudo-code to analyze. Returns: - A string indicating the time complexity in Big-O notation. Constraints - The input pseudo-code will contain only well-formed nested loops. - The maximum depth of nested loops will be 5. - Loops will iterate over fixed bounds denoted by `N` or `M`. - `N` and `M` are independent variables representing the sizes of loops and should be considered as different dimensions. Examples ```python >>> time_complexity(\\"for i in 1..N:n for j in 1..N:n pass\\") \'O(N^2)\' >>> time_complexity(\\"for i in 1..N:n for j in 1..N:n for k in 1..M:n pass\\") \'O(N^2 * M)\' >>> time_complexity(\\"for i in 1..N:n pass\\") \'O(N)\' ``` Write the function `time_complexity` to solve the problem using the constraints and requirements provided.","solution":"def time_complexity(code_snippet): Analyzes nested loops in the given pseudo-code and returns the overall time complexity in Big-O notation. Parameters: code_snippet (str): A string representing the pseudo-code to analyze. Returns: str: The overall time complexity in Big-O notation. # Split the code into lines lines = code_snippet.strip().split(\'n\') # Initialize a dictionary to count loop variables loop_count = {} # Iterate over each line of code for line in lines: line = line.strip() # Only consider lines that start with \\"for\\" if line.startswith(\\"for\\"): # Determine the loop variable and bounds if \\"1..N\\" in line: variable = \'N\' elif \\"1..M\\" in line: variable = \'M\' # Count the nested loops for each variable if variable in loop_count: loop_count[variable] += 1 else: loop_count[variable] = 1 # Construct the time complexity string complexity_terms = [] for variable, count in loop_count.items(): if count == 1: complexity_terms.append(f\\"O({variable})\\") else: complexity_terms.append(f\\"O({variable}^{count})\\") # Join the terms with multiplication if len(complexity_terms) == 1: return complexity_terms[0] else: return \\"O(\\" + \\" * \\".join(term[2:-1] for term in complexity_terms) + \\")\\""},{"question":"# Sparse Matrix Representation **Scenario**: You\'re working on a scientific computation project involving large datasets with the majority of elements as zero. To optimize memory and improve performance, you need to represent and manipulate these sparse matrices efficiently. **Task**: Create a class `SparseMatrix` that uses a dictionary to represent and manipulate a sparse matrix with the following methods: 1. **add_element(row, col, value)**: Adds a non-zero value to the matrix at the specified row and column. If the value is zero, remove the element from the representation if it exists. 2. **remove_element(row, col)**: Removes an element from the matrix at the specified row and column. 3. **get_element(row, col)**: Returns the value at the given row and column. Returns `0` if the element is not explicitly stored in the sparse representation. 4. **transpose()**: Returns a new `SparseMatrix` that is the transpose of the original matrix (rows and columns interchanged). 5. **add_matrix(other)**: Adds another sparse matrix to the current matrix, element-wise. Raise an exception if the dimensions do not match. **Constraints**: - The matrices can be of any dimensions. - Handle edge cases such as adding or getting elements at indices that are not explicitly stored. - Raise exceptions as necessary to avoid invalid operations. **Example Usage**: ```python sm = SparseMatrix() sm.add_element(1, 2, 3) sm.add_element(3, 4, 5) print(sm.get_element(1, 2)) # 3 print(sm.get_element(2, 2)) # 0 sm.remove_element(1, 2) print(sm.get_element(1, 2)) # 0 transpose_sm = sm.transpose() print(transpose_sm.get_element(2, 1)) # 3 sm2 = SparseMatrix() sm2.add_element(3, 4, 5) added_sm = sm.add_matrix(sm2) print(added_sm.get_element(3, 4)) # 10 ``` **Implementation**: Complete the implementation by filling in the missing methods for the `SparseMatrix` class. Ensure your methods handle all specified operations correctly, capturing edge cases and performance constraints as discussed.","solution":"class SparseMatrix: def __init__(self): self.elements = {} # Dictionary to store non-zero values as {(row, col): value} def add_element(self, row, col, value): if value == 0: if (row, col) in self.elements: del self.elements[(row, col)] else: self.elements[(row, col)] = value def remove_element(self, row, col): if (row, col) in self.elements: del self.elements[(row, col)] def get_element(self, row, col): return self.elements.get((row, col), 0) def transpose(self): transposed = SparseMatrix() for (row, col), value in self.elements.items(): transposed.add_element(col, row, value) return transposed def add_matrix(self, other): # Here we assume other to be another SparseMatrix added_matrix = SparseMatrix() # Copy elements from the current matrix for (row, col), value in self.elements.items(): added_matrix.add_element(row, col, value) # Add elements from the other matrix for (row, col), value in other.elements.items(): new_value = added_matrix.get_element(row, col) + value added_matrix.add_element(row, col, new_value) return added_matrix"},{"question":"# Problem Statement: Scenario: A software system is designed to manage and optimize resource allocation for a set of tasks. Each task has a specific resource requirement and a priority level. Your task is to write a function that distributes available resources among the tasks to maximize the sum of priority levels, without exceeding the total available resources. Function Signature: ```python def maximize_priority(tasks: List[Tuple[int, int]], available_resources: int) -> int: pass ``` Input: 1. `tasks` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers: the first integer represents the resource requirement of the task, and the second integer represents the priority level of the task. 2. `available_resources` (int): The total amount of resources available for allocation. Output: - (int): The maximum sum of priority levels that can be achieved without exceeding the available resources. Constraints: - 1 <= length of `tasks` <= 1000 - 1 <= resource requirement of each task <= 1000 - 1 <= priority level of each task <= 1000 - 1 <= `available_resources` <= 100000 Requirements: - The function should use dynamic programming for efficient computation. - Proper error handling for invalid inputs is required. Example: ```python tasks = [(2, 50), (4, 60), (3, 40), (5, 70)] available_resources = 5 print(maximize_priority(tasks, available_resources)) # Expected output: 90 tasks = [(1, 10), (1, 20), (1, 30)] available_resources = 2 print(maximize_priority(tasks, available_resources)) # Expected output: 50 ``` **Note**: This problem can be tackled with a dynamic programming approach similar to the knapsack problem. The goal is to maximize the sum of the priority levels within the given resource constraint.","solution":"from typing import List, Tuple def maximize_priority(tasks: List[Tuple[int, int]], available_resources: int) -> int: num_tasks = len(tasks) dp = [0] * (available_resources + 1) for resource_req, priority in tasks: for r in range(available_resources, resource_req - 1, -1): dp[r] = max(dp[r], dp[r - resource_req] + priority) return dp[available_resources]"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},F={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],z={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=c(N,[["render",P],["__scopeId","data-v-0f85f2fc"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/38.md","filePath":"drive/38.md"}'),j={name:"drive/38.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,V as default};
