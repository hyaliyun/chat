import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as k}from"./chunks/framework.B1z0IdBH.js";const x={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},L={class:"review-content"};function R(i,e,l,m,n,a){return s(),r("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=_(x,[["render",R],["__scopeId","data-v-126e6c9c"]]),E=JSON.parse(`[{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string consisting of '(', ')', '{', '}', '[' and ']' is valid. Args: s (str): the input string with parentheses Returns: bool: True if the string is valid, False otherwise >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"{[]}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[}\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"((((((()))))))\\") True >>> is_valid_parentheses(\\"(((()))\\") False >>> is_valid_parentheses(\\"([{}])\\") True >>> is_valid_parentheses(\\"([{])\\") False","solution":"def is_valid_parentheses(s): Determine if the input string consisting of '(', ')', '{', '}', '[' and ']' is valid. Args: s (str): the input string with parentheses Returns: bool: True if the string is valid, False otherwise stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket: top_element = stack.pop() if stack else '#' if matching_bracket[char] != top_element: return False else: stack.append(char) return not stack # Time complexity: O(n) where n is the length of the string, as we process each character once. # Space complexity: O(n) in the worst case, if all opening brackets are stored in the stack. # A stack is used here because the last opened bracket needs to be the first one to be closed, which follows the LIFO (Last In, First Out) principle."},{"question":"from typing import Union def withdraw_balance(current_balance: float, withdrawal_amount: float) -> Union[str, float]: Simulates a bank account withdrawal. Parameters: - current_balance (float): The current account balance. - withdrawal_amount (float): The amount to withdraw. Returns: - (float): The new balance if the withdrawal is successful. - (str): An error message if there are insufficient funds or the withdrawal amount is invalid. Examples: >>> withdraw_balance(500.00, 100.00) 400.00 >>> withdraw_balance(500.00, 600.00) \\"Insufficient funds\\" >>> withdraw_balance(500.00, -50.00) \\"Invalid withdrawal amount\\" >>> withdraw_balance(500.00, 0.00) \\"Invalid withdrawal amount\\"","solution":"from typing import Union def withdraw_balance(current_balance: float, withdrawal_amount: float) -> Union[str, float]: Simulates a bank account withdrawal. Parameters: - current_balance (float): The current account balance. - withdrawal_amount (float): The amount to withdraw. Returns: - (float): The new balance if the withdrawal is successful. - (str): An error message if there are insufficient funds or the withdrawal amount is invalid. if withdrawal_amount <= 0: return \\"Invalid withdrawal amount\\" elif withdrawal_amount > current_balance: return \\"Insufficient funds\\" else: return current_balance - withdrawal_amount"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: A string containing only lowercase letters :return: Length of the longest substring with all unique characters >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"tmmzuxt\\") 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. :param s: String containing only lowercase letters :return: Length of the longest substring with all unique characters if not s: return 0 n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"import pandas as pd import numpy as np def process_sales_data(input_file: str, output_file: str): Processes the sales data from the given input file and generates a summary file. Parameters: input_file (str): The path to the input CSV file containing sales records. output_file (str): The path to the output CSV file to save the summary. try: # Load sales data sales_data = pd.read_csv(input_file) # Check if the required columns are present if 'Category' not in sales_data.columns or 'Sales' not in sales_data.columns: raise ValueError(\\"Input file must contain 'Category' and 'Sales' columns.\\") # Calculate total sales for each product category total_sales_by_category = sales_data.groupby('Category')['Sales'].sum() # Find the overall total sales total_sales = sales_data['Sales'].sum() # Calculate the average sales per transaction average_sales = sales_data['Sales'].mean() # Generate a summary summary = { 'Total Sales by Category': total_sales_by_category, 'Overall Total Sales': total_sales, 'Average Sales per Transaction': average_sales } # Convert the summary to a DataFrame summary_df = pd.DataFrame({ 'Description': ['Total Sales by Category', 'Overall Total Sales', 'Average Sales per Transaction'], 'Value': [total_sales_by_category.to_dict(), total_sales, average_sales] }) # Save the summary to a CSV file summary_df.to_csv(output_file, index=False) except FileNotFoundError: print(f\\"Error: The file '{input_file}' was not found.\\") except pd.errors.EmptyDataError: print(\\"Error: The input file is empty.\\") except ValueError as e: print(f\\"Error: {e}\\") except Exception as e: print(f\\"An unexpected error occurred: {e}\\") # Example usage: # process_sales_data('sales_records.csv', 'sales_summary.csv') Unit Test: import pytest import os import pandas as pd from solution import process_sales_data def test_process_sales_data_file_not_found(): input_file = 'non_existent_file.csv' output_file = 'output.csv' process_sales_data(input_file, output_file) assert not os.path.exists(output_file), \\"Output file should not be created if input file is not found\\" def test_process_sales_data_empty_file(): input_file = 'empty_file.csv' output_file = 'output.csv' pd.DataFrame().to_csv(input_file, index=False) process_sales_data(input_file, output_file) assert not os.path.exists(output_file), \\"Output file should not be created if input file is empty\\" os.remove(input_file) def test_process_sales_data_missing_columns(): input_file = 'missing_columns_file.csv' output_file = 'output.csv' pd.DataFrame({'OtherColumn': [1, 2, 3]}).to_csv(input_file, index=False) process_sales_data(input_file, output_file) assert not os.path.exists(output_file), \\"Output file should not be created if required columns are missing\\" os.remove(input_file) def test_process_sales_data_correct_input(): input_file = 'sales_records.csv' output_file = 'sales_summary.csv' data = { 'Category': ['Electronics', 'Furniture', 'Electronics', 'Furniture'], 'Sales': [100, 200, 300, 400] } pd.DataFrame(data).to_csv(input_file, index=False) process_sales_data(input_file, output_file) assert os.path.exists(output_file), \\"Output file should be created if input file is correct\\" summary_df = pd.read_csv(output_file) assert 'Overall Total Sales' in summary_df['Description'].values, \\"Output file should contain overall total sales\\" assert 'Average Sales per Transaction' in summary_df['Description'].values, \\"Output file should contain average sales per transaction\\" assert 'Total Sales by Category' in summary_df['Description']. values, \\"Output file should contain total sales by category\\" os.remove(input_file) os.remove(output_file)","solution":"import pandas as pd import numpy as np def process_sales_data(input_file, output_file): Processes the sales data from the given input file and generates a summary file. Parameters: input_file (str): The path to the input CSV file containing sales records. output_file (str): The path to the output CSV file to save the summary. try: # Load sales data sales_data = pd.read_csv(input_file) # Check if the required columns are present if 'Category' not in sales_data.columns or 'Sales' not in sales_data.columns: raise ValueError(\\"Input file must contain 'Category' and 'Sales' columns.\\") # Calculate total sales for each product category total_sales_by_category = sales_data.groupby('Category')['Sales'].sum() # Find the overall total sales total_sales = sales_data['Sales'].sum() # Calculate the average sales per transaction average_sales = sales_data['Sales'].mean() # Generate a summary summary = { 'Total Sales by Category': total_sales_by_category, 'Overall Total Sales': total_sales, 'Average Sales per Transaction': average_sales } # Convert the summary to a DataFrame summary_df = pd.DataFrame({ 'Description': ['Total Sales by Category', 'Overall Total Sales', 'Average Sales per Transaction'], 'Value': [total_sales_by_category.to_dict(), total_sales, average_sales] }) # Save the summary to a CSV file summary_df.to_csv(output_file, index=False) except FileNotFoundError: print(f\\"Error: The file '{input_file}' was not found.\\") except pd.errors.EmptyDataError: print(\\"Error: The input file is empty.\\") except ValueError as e: print(f\\"Error: {e}\\") except Exception as e: print(f\\"An unexpected error occurred: {e}\\") # Example usage: # process_sales_data('sales_records.csv', 'sales_summary.csv')"},{"question":"import math from itertools import combinations from typing import List, Tuple def gcd_pairs(input_list: List[int]) -> List[Tuple[int, int, int]]: Takes a list of integers and returns a list of tuples, where each tuple contains a pair of numbers and their GCD. >>> gcd_pairs([12, 15, 18]) [(12, 15, 3), (12, 18, 6), (15, 18, 3)] >>> gcd_pairs([12]) [] >>> gcd_pairs([10, 10, 10]) [(10, 10, 10), (10, 10, 10), (10, 10, 10)] >>> gcd_pairs([8, 9, 21]) [(8, 9, 1), (8, 21, 1), (9, 21, 3)] >>> gcd_pairs([0, 20, 30]) [(0, 20, 20), (0, 30, 30), (20, 30, 10)] >>> gcd_pairs([-12, -15, -18]) [(-12, -15, 3), (-12, -18, 6), (-15, -18, 3)]","solution":"import math from itertools import combinations def gcd_pairs(input_list): Takes a list of integers and returns a list of tuples, where each tuple contains a pair of numbers and their GCD. result = [] for (a, b) in combinations(input_list, 2): gcd_value = math.gcd(a, b) result.append((a, b, gcd_value)) return result"},{"question":"def capitalize_words(s: str) -> str: Returns a new string where the first letter of each word is capitalized, and all other letters are in lowercase. Words are defined as sequences of characters separated by spaces. >>> capitalize_words(\\"hello world\\") == \\"Hello World\\" >>> capitalize_words(\\" multiple spaces here \\") == \\"Multiple Spaces Here\\" >>> capitalize_words(\\"\\") == \\"\\"","solution":"def capitalize_words(s): Returns a new string where the first letter of each word is capitalized, and all other letters are in lowercase. Words are defined as sequences of characters separated by spaces. return ' '.join(word.capitalize() for word in s.split())"},{"question":"def find_max_min(numbers): Return a tuple containing the largest and smallest numbers from the list. If the list is empty, return None. >>> find_max_min([3, 1, -2, 7, 9]) (9, -2) >>> find_max_min([]) None >>> find_max_min([5]) (5, 5) >>> find_max_min([-3, -1, -7, -9]) (-1, -9) >>> find_max_min([-10, 0, 10, 5, -5]) (10, -10)","solution":"def find_max_min(numbers): Return a tuple containing the largest and smallest numbers from the list. If the list is empty, return None. if not numbers: return None max_num = max(numbers) min_num = min(numbers) return (max_num, min_num)"},{"question":"import boto3 import pandas as pd import json import matplotlib.pyplot as plt import logging from botocore.exceptions import NoCredentialsError, PartialCredentialsError, ClientError # Setup logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') logger = logging.getLogger() def connect_to_s3(aws_access_key_id, aws_secret_access_key): Establish a connection to S3. try: s3_client = boto3.client( 's3', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key ) logger.info(\\"Successfully connected to S3\\") return s3_client except (NoCredentialsError, PartialCredentialsError) as e: logger.error(\\"AWS credentials not available.\\", exc_info=True) raise e except ClientError as e: logger.error(\\"Failed to connect to S3.\\", exc_info=True) raise e def retrieve_json_files(s3_client, bucket_name, prefix): Retrieve JSON files from S3 bucket. files = [] try: response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=prefix) for obj in response.get('Contents', []): if obj['Key'].endswith('.json'): files.append(obj['Key']) except ClientError as e: logger.error(\\"Error in accessing S3 objects.\\", exc_info=True) raise e return files def load_and_combine_json_files(s3_client, bucket_name, files): Load and combine JSON files into a single DataFrame. data_frames = [] for file in files: try: response = s3_client.get_object(Bucket=bucket_name, Key=file) file_content = response['Body'].read().decode('utf-8') json_data = json.loads(file_content) data_frame = pd.json_normalize(json_data) data_frames.append(data_frame) except Exception as e: logger.error(f\\"Error in loading or parsing JSON file: {file}\\", exc_info=True) continue combined_df = pd.concat(data_frames, ignore_index=True) return combined_df def perform_eda(data_frame): Perform exploratory data analysis. statistics = data_frame.describe() print(\\"Basic Statistics:n\\", statistics) print(\\"Missing Values:n\\", data_frame.isnull().sum()) print(\\"Data Types:n\\", data_frame.dtypes) logger.info(\\"Exploratory Data Analysis performed successfully.\\") def visualize_data(data_frame, column_name): Visualize distribution of key variables. if column_name in data_frame: plt.figure(figsize=(10, 6)) data_frame[column_name].hist(bins=30) plt.title(f'Distribution of {column_name}') plt.xlabel(column_name) plt.ylabel('Frequency') plt.show() logger.info(f\\"Visualization for {column_name} done successfully.\\") else: logger.warning(f'Column {column_name} not found in DataFrame.')","solution":"import boto3 import pandas as pd import json import matplotlib.pyplot as plt import logging from botocore.exceptions import NoCredentialsError, PartialCredentialsError, ClientError # Setup logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') logger = logging.getLogger() def connect_to_s3(aws_access_key_id, aws_secret_access_key): Establish a connection to S3. try: s3_client = boto3.client( 's3', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key ) logger.info(\\"Successfully connected to S3\\") return s3_client except (NoCredentialsError, PartialCredentialsError) as e: logger.error(\\"AWS credentials not available.\\", exc_info=True) raise e except ClientError as e: logger.error(\\"Failed to connect to S3.\\", exc_info=True) raise e def retrieve_json_files(s3_client, bucket_name, prefix): Retrieve JSON files from S3 bucket. files = [] try: response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=prefix) for obj in response.get('Contents', []): if obj['Key'].endswith('.json'): files.append(obj['Key']) except ClientError as e: logger.error(\\"Error in accessing S3 objects.\\", exc_info=True) raise e return files def load_and_combine_json_files(s3_client, bucket_name, files): Load and combine JSON files into a single DataFrame. data_frames = [] for file in files: try: response = s3_client.get_object(Bucket=bucket_name, Key=file) file_content = response['Body'].read().decode('utf-8') json_data = json.loads(file_content) data_frame = pd.json_normalize(json_data) data_frames.append(data_frame) except Exception as e: logger.error(f\\"Error in loading or parsing JSON file: {file}\\", exc_info=True) continue combined_df = pd.concat(data_frames, ignore_index=True) return combined_df def perform_eda(data_frame): Perform exploratory data analysis. statistics = data_frame.describe() print(\\"Basic Statistics:n\\", statistics) print(\\"Missing Values:n\\", data_frame.isnull().sum()) print(\\"Data Types:n\\", data_frame.dtypes) logger.info(\\"Exploratory Data Analysis performed successfully.\\") def visualize_data(data_frame, column_name): Visualize distribution of key variables. if column_name in data_frame: plt.figure(figsize=(10, 6)) data_frame[column_name].hist(bins=30) plt.title(f'Distribution of {column_name}') plt.xlabel(column_name) plt.ylabel('Frequency') plt.show() logger.info(f\\"Visualization for {column_name} done successfully.\\") else: logger.warning(f'Column {column_name} not found in DataFrame.') if __name__ == \\"__main__\\": # Example usage aws_access_key_id = \\"your_access_key_id\\" aws_secret_access_key = \\"your_secret_access_key\\" bucket_name = \\"your_bucket_name\\" prefix = \\"your_prefix\\" try: s3_client = connect_to_s3(aws_access_key_id, aws_secret_access_key) files = retrieve_json_files(s3_client, bucket_name, prefix) combined_df = load_and_combine_json_files(s3_client, bucket_name, files) perform_eda(combined_df) visualize_data(combined_df, 'key_column_name') except Exception as e: logger.error(\\"Error encountered in main execution\\", exc_info=True)"},{"question":"def knapsack(items, max_weight): Solves the 0/1 Knapsack problem and returns the maximum value that can be achieved. Parameters: items (list of tuples): A list where each tuple contains (weight, value) of an item. max_weight (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable with the given items and knapsack capacity. >>> knapsack([(2, 3), (2, 4), (4, 8), (5, 8)], 8) 15 >>> knapsack([], 10) 0 >>> knapsack([(1, 10), (2, 20), (3, 30)], 0) 0 >>> knapsack([(3, 10)], 5) 10 >>> knapsack([(5, 10)], 4) 0 >>> knapsack([(1, 1), (2, 6), (3, 10), (5, 12)], 5) 16 >>> knapsack([(4, 5), (4, 6), (4, 7)], 8) 13 >>> knapsack([(4, 3), (3, 2), (2, 4), (6, 1)], 10) 9","solution":"def knapsack(items, max_weight): Solves the 0/1 Knapsack problem and returns the maximum value that can be achieved. Parameters: items (list of tuples): A list where each tuple contains (weight, value) of an item. max_weight (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable with the given items and knapsack capacity. n = len(items) # Initialize the DP table with (n+1) x (max_weight+1) dimensions filled with 0 dp = [[0] * (max_weight + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): weight, value = items[i - 1] for w in range(max_weight + 1): if weight > w: dp[i][w] = dp[i - 1][w] # If the item cannot be included, inherit the value from above else: # Choose the maximum between not taking the item and taking the item dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) return dp[n][max_weight]"},{"question":"def remove_vowels(input_string: str) -> str: Removes all vowels from the input string. Parameters: input_string (str): The string from which to remove vowels. Returns: str: The string with all vowels removed. >>> remove_vowels(\\"Hello, World!\\") \\"Hll, Wrld!\\" >>> remove_vowels(\\"aeiouAEIOU\\") \\"\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"bcdfg\\") \\"bcdfg\\" >>> remove_vowels(\\"Python is awesome!\\") \\"Pythn s wsm!\\" >>> remove_vowels(\\"MULTIPLE TESTS\\") \\"MLTPL TSTS\\" >>> remove_vowels(\\"12345!@#aeiou\\") \\"12345!@#\\"","solution":"def remove_vowels(input_string): Removes all vowels from the input string. Parameters: input_string (str): The string from which to remove vowels. Returns: str: The string with all vowels removed. vowels = 'aeiouAEIOU' return ''.join(filter(lambda x: x not in vowels, input_string))"},{"question":"import heapq class OrderSorter: def __init__(self): Initializes the OrderSorter with an empty heap. self.min_heap = [] def add_order(self, order): Adds an order to the sorting system. Assumes each order is a tuple where the first element is a sortable key (e.g., timestamp or order ID). def get_sorted_orders(self): Returns all orders sorted by the sortable key. # Unit Tests import pytest def test_add_single_order(): sorter = OrderSorter() sorter.add_order((1, 'order1')) assert sorter.get_sorted_orders() == [(1, 'order1')] def test_add_multiple_orders(): sorter = OrderSorter() sorter.add_order((2, 'order2')) sorter.add_order((1, 'order1')) sorter.add_order((3, 'order3')) assert sorter.get_sorted_orders() == [(1, 'order1'), (2, 'order2'), (3, 'order3')] def test_add_orders_out_of_order(): sorter = OrderSorter() sorter.add_order((5, 'order5')) sorter.add_order((3, 'order3')) sorter.add_order((8, 'order8')) sorter.add_order((1, 'order1')) assert sorter.get_sorted_orders() == [(1, 'order1'), (3, 'order3'), (5, 'order5'), (8, 'order8')] def test_add_duplicate_order_ids(): sorter = OrderSorter() sorter.add_order((2, 'order2')) sorter.add_order((2, 'order2-a')) sorter.add_order((1, 'order1')) assert sorter.get_sorted_orders() == [(1, 'order1'), (2, 'order2'), (2, 'order2-a')] def test_adding_and_getting_orders(): sorter = OrderSorter() sorter.add_order((6, 'order6')) sorter.add_order((4, 'order4')) sorter.add_order((2, 'order2')) assert sorter.get_sorted_orders() == [(2, 'order2'), (4, 'order4'), (6, 'order6')] # adding more orders after getting previous ones sorter.add_order((5, 'order5')) sorter.add_order((3, 'order3')) assert sorter.get_sorted_orders() == [(3, 'order3'), (5, 'order5')]","solution":"import heapq class OrderSorter: def __init__(self): self.min_heap = [] def add_order(self, order): Adds an order to the sorting system. Assumes each order is a tuple where the first element is a sortable key (e.g., timestamp or order ID). heapq.heappush(self.min_heap, order) def get_sorted_orders(self): Returns all orders sorted by the sortable key. sorted_orders = [] while self.min_heap: sorted_orders.append(heapq.heappop(self.min_heap)) return sorted_orders"},{"question":"def highest_grades(students_grades): Takes a list of tuples where each tuple contains a student's name and their grade, and returns a dictionary mapping each student's name to their highest grade. >>> highest_grades([(\\"John\\", 88), (\\"Jane\\", 92), (\\"John\\", 93), (\\"Jane\\", 85), (\\"Dave\\", 90)]) {'John': 93, 'Jane': 92, 'Dave': 90} >>> highest_grades([(\\"John\\", 88), (\\"Jane\\", 92), (\\"Dave\\", 90)]) {'John': 88, 'Jane': 92, 'Dave': 90} >>> highest_grades([(\\"John\\", 75), (\\"Jane\\", 80), (\\"John\\", 70), (\\"Jane\\", 85), (\\"Dave\\", 90), (\\"Jane\\", 89)]) {'John': 75, 'Jane': 89, 'Dave': 90} >>> highest_grades([]) {} >>> highest_grades([(\\"John\\", 90), (\\"Jane\\", 90), (\\"Dave\\", 90), (\\"John\\", 90), (\\"Jane\\", 90), (\\"Dave\\", 90)]) {'John': 90, 'Jane': 90, 'Dave': 90}","solution":"def highest_grades(students_grades): Takes a list of tuples where each tuple contains a student's name and their grade, and returns a dictionary mapping each student's name to their highest grade. grade_dict = {} for name, grade in students_grades: if name in grade_dict: if grade > grade_dict[name]: grade_dict[name] = grade else: grade_dict[name] = grade return grade_dict # Example usage students_grades = [(\\"John\\", 88), (\\"Jane\\", 92), (\\"John\\", 93), (\\"Jane\\", 85), (\\"Dave\\", 90)] print(highest_grades(students_grades)) # Output: {'John': 93, 'Jane': 92, 'Dave': 90}"},{"question":"def validate_parentheses(sequences: List[str]) -> List[bool]: Given a list of strings representing sequences of parentheses, this function checks if each sequence is valid. :param sequences: List[String] - List of strings with parentheses sequences :return: List[Bool] - List of booleans corresponding to validity of each sequence >>> validate_parentheses([\\"()\\"]) [True] >>> validate_parentheses([\\"(())\\"]) [True] >>> validate_parentheses([\\"(()\\"]) [False] >>> validate_parentheses([\\"())\\"]) [False] >>> validate_parentheses([\\")(\\"]) [False] >>> validate_parentheses([\\"()\\", \\"(())\\", \\"(()\\", \\"())\\", \\")(\\"]) [True, True, False, False, False] >>> validate_parentheses([\\"\\", \\"()\\", \\"(()())\\", \\"(()(()))\\"]) [True, True, True, True] >>> validate_parentheses([\\"(()))(()\\", \\"(()))\\", \\")(\\"]) [False, False, False] >>> validate_parentheses([\\"(())\\", \\"(()))(\\", \\"()()\\"]) [True, False, True] >>> validate_parentheses([\\"()\\", \\"()(\\", \\")\\", \\"(())()(\\"]) [True, False, False, False] >>> validate_parentheses([\\"((()))\\", \\"((())\\", \\"()())\\", \\"(())()\\"]) [True, False, False, True] >>> validate_parentheses([\\"\\", \\"\\", \\"\\"]) [True, True, True] >>> validate_parentheses([\\"\\", \\"()()\\", \\"(())\\"]) [True, True, True] >>> validate_parentheses([\\"((\\", \\"(()\\", \\")\\", \\"(()))\\"]) [False, False, False, False]","solution":"def validate_parentheses(sequences): Given a list of strings representing sequences of parentheses, this function checks if each sequence is valid. :param sequences: List[String] - List of strings with parentheses sequences :return: List[Bool] - List of booleans corresponding to validity of each sequence def is_valid(sequence): Check if a single sequence of parentheses is valid. :param sequence: String - The parentheses sequence :return: Bool - True if valid, False otherwise stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0 return [is_valid(seq) for seq in sequences]"},{"question":"class Stack: def __init__(self): self.stack = [] def push(self, element): Push an integer element to the stack. Raises: ValueError: If the element is not an integer. pass def pop(self): Remove and return the top element of the stack. Raises: IndexError: If the stack is empty. pass def peek(self): Return the top element of the stack without removing it. Raises: IndexError: If the stack is empty. pass def is_empty(self): Check if the stack is empty. Returns: bool: True if the stack is empty, False otherwise. pass # Example usage s = Stack() s.push(5) s.push(10) s.push(15) print(s.peek()) # Should print 15 s.pop() print(s.peek()) # Should print 10 print(s.is_empty()) # Should print False","solution":"class Stack: def __init__(self): self.stack = [] # Push method def push(self, element): if not isinstance(element, int): raise ValueError(\\"Only integers can be pushed to the stack\\") self.stack.append(element) # Pop method def pop(self): if self.is_empty(): raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop() # Peek method def peek(self): if self.is_empty(): raise IndexError(\\"Peek from an empty stack\\") return self.stack[-1] # Check if stack is empty def is_empty(self): return len(self.stack) == 0 # Example usage s = Stack() s.push(5) s.push(10) s.push(15) print(s.peek()) # Should print 15 s.pop() print(s.peek()) # Should print 10 print(s.is_empty()) # Should print False"},{"question":"def find_odd_occurrence(nums: List[int]) -> int: Returns the integer that appears an odd number of times in the list. >>> find_odd_occurrence([2, 3, 2, 4, 4, 4, 4, 5, 5, 3, 7]) 7 >>> find_odd_occurrence([9, 9, 9, 10, 10]) 9 >>> find_odd_occurrence([]) 0","solution":"def find_odd_occurrence(nums): Returns the integer that appears an odd number of times in the list. result = 0 for num in nums: result ^= num return result"},{"question":"def sort_by_frequency_and_value(data: list[int]) -> list[int]: Sort the list by frequency of elements in ascending order. If two numbers have the same frequency, they are sorted by their values. Example: >>> sort_by_frequency_and_value([4, 5, 6, 5, 4, 3]) [3, 6, 4, 4, 5, 5] >>> sort_by_frequency_and_value([1, 2, 2, 2, 3, 3]) [1, 3, 3, 2, 2, 2]","solution":"def sort_by_frequency_and_value(data): Sort the list by frequency of elements in ascending order. If two numbers have the same frequency, they are sorted by their values. Args: data (list): A list of integers. Returns: list: A sorted list by frequency, with ties broken by value. # Count frequency of each element frequency = {} for num in data: frequency[num] = frequency.get(num, 0) + 1 items = [(num, frequency[num]) for num in data] # Custom sorting def custom_sort(item): return (item[1], item[0]) sorted_items = sorted(items, key=custom_sort) return [item[0] for item in sorted_items]"},{"question":"from typing import List, Tuple import re def extract_errors(log_file: str) -> List[Tuple[str, str]]: Parses a log file string and extracts error messages with their corresponding timestamps. Args: log_file (str): The log file content as a single string. Returns: List[Tuple[str, str]]: A list of tuples, where each tuple contains a timestamp and an error message. Examples: >>> extract_errors( 2023-01-01 00:00:00 INFO Starting application 2023-01-01 00:01:00 ERROR An unexpected error occurred 2023-01-01 00:02:00 INFO Application running ) [(\\"2023-01-01 00:01:00\\", \\"An unexpected error occurred\\")] >>> extract_errors( 2023-01-01 00:00:00 INFO Starting application 2023-01-01 00:01:00 WARN Low memory 2023-01-01 00:02:00 INFO Application running ) []","solution":"import re from typing import List, Tuple def extract_errors(log_file: str) -> List[Tuple[str, str]]: Parses a log file string and extracts error messages with their corresponding timestamps. Args: log_file (str): The log file content as a single string. Returns: List[Tuple[str, str]]: A list of tuples, where each tuple contains a timestamp and an error message. error_pattern = re.compile(r'(d{4}-d{2}-d{2} d{2}:d{2}:d{2}) ERROR (.*)') errors = error_pattern.findall(log_file) return errors"},{"question":"def longest_subsequence_with_target_sum(arr, target): Returns the length of the longest contiguous subsequence that sums to the target value. If no such subsequence exists, returns 0. >>> longest_subsequence_with_target_sum([1, 2, 3], 10) == 0 >>> longest_subsequence_with_target_sum([1, 2, 3], 2) == 1 >>> longest_subsequence_with_target_sum([1, 2, 3, 4], 10) == 4 >>> longest_subsequence_with_target_sum([1, 2, -3, 3, 4], 4) == 3 >>> longest_subsequence_with_target_sum([1, 2, 3, 0, 3, -1], 6) == 4 >>> longest_subsequence_with_target_sum([1, -1, 2, -2, 3, -3, 3], 0) == 6 >>> longest_subsequence_with_target_sum([0, 0, 0, 0], 0) == 4","solution":"def longest_subsequence_with_target_sum(arr, target): Returns the length of the longest contiguous subsequence that sums to the target value. If no such subsequence exists, returns 0. prefix_sum = 0 prefix_sum_index_map = {0: -1} max_length = 0 for index, num in enumerate(arr): prefix_sum += num if prefix_sum - target in prefix_sum_index_map: max_length = max(max_length, index - prefix_sum_index_map[prefix_sum - target]) if prefix_sum not in prefix_sum_index_map: prefix_sum_index_map[prefix_sum] = index return max_length"},{"question":"from typing import List def maxSkylineArea(heights: List[int]) -> int: Calculate the maximum rectangular area in a skyline represented by heights. The function \`maxSkylineArea\` takes a list of non-negative integers representing the heights of buildings. It returns the maximum rectangular area that can be formed using the buildings in the skyline. The width of each rectangle is the distance between two buildings, and the height is the minimum height of the buildings in between. Args: heights (List[int]): A list of non-negative integers representing the heights of buildings. Returns: int: The maximum rectangular area that can be formed. Examples: >>> maxSkylineArea([2, 1, 5, 6, 2, 3]) 10 >>> maxSkylineArea([5]) 5 >>> maxSkylineArea([1, 1]) 2 >>> maxSkylineArea([5, 4, 3, 2, 1]) 9 >>> maxSkylineArea([1, 2, 3, 4, 5]) 9 >>> maxSkylineArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> maxSkylineArea([3, 3, 3, 3, 3]) 15","solution":"def maxSkylineArea(heights): Calculate the maximum rectangular area in a skyline represented by heights. :param heights: List[int] - list of non-negative integers representing heights of buildings. :return: int - the maximum rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def find_second_largest(nums): Returns the second largest unique number in the list. If there is no second largest unique number, return None. # Your code goes here # Test Cases print(find_second_largest([10, 5, 8, 12, 8])) # Output: 10 print(find_second_largest([3, 3, 3])) # Output: None print(find_second_largest([1])) # Output: None print(find_second_largest([])) # Output: None print(find_second_largest([9, 9, 8, 8, 7])) # Output: 8","solution":"def find_second_largest(nums): Returns the second largest unique number in the list. If there is no second largest unique number, return None. if len(nums) < 2: return None unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def merge_and_find_median(arr1, arr2): Merges two sorted arrays into a single sorted array and returns the median value. If the merged array has an even number of elements, the median is the average of the two middle values. pass # Example usage: # arr1 = [1, 3, 5] # arr2 = [2, 4, 6] # merged_array, median = merge_and_find_median(arr1, arr2) # print(merged_array) # Output: [1, 2, 3, 4, 5, 6] # print(median) # Output: 3.5 # Here are some test cases to validate the solution def test_merge_and_find_median_odd_length(): arr1 = [1, 3, 5] arr2 = [2, 4, 6] merged_array, median = merge_and_find_median(arr1, arr2) assert merged_array == [1, 2, 3, 4, 5, 6] assert median == 3.5 def test_merge_and_find_median_even_length(): arr1 = [1, 2] arr2 = [3, 4] merged_array, median = merge_and_find_median(arr1, arr2) assert merged_array == [1, 2, 3, 4] assert median == 2.5 def test_merge_and_find_median_one_empty(): arr1 = [] arr2 = [2, 4, 6] merged_array, median = merge_and_find_median(arr1, arr2) assert merged_array == [2, 4, 6] assert median == 4 def test_merge_and_find_median_disjoint(): arr1 = [1, 2, 3] arr2 = [7, 8, 9] merged_array, median = merge_and_find_median(arr1, arr2) assert merged_array == [1, 2, 3, 7, 8, 9] assert median == 5 def test_merge_and_find_median_same_values(): arr1 = [1, 1, 1] arr2 = [1, 1, 1] merged_array, median = merge_and_find_median(arr1, arr2) assert merged_array == [1, 1, 1, 1, 1, 1] assert median == 1","solution":"def merge_and_find_median(arr1, arr2): Merges two sorted arrays into a single sorted array and returns the median value. If the merged array has an even number of elements, the median is the average of the two middle values. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 n = len(merged_array) if n % 2 == 1: median = merged_array[n // 2] else: median = (merged_array[n // 2 - 1] + merged_array[n // 2]) / 2 return merged_array, median"},{"question":"def find_sequences(s: str) -> List[str]: Write a function that takes a string containing only lowercase letters and returns a list of substrings, each representing a consecutive sequence of alphabetically ordered characters from the original string. >>> find_sequences(\\"abcdefg\\") [\\"abcdefg\\"] >>> find_sequences(\\"zyx\\") [\\"z\\", \\"y\\", \\"x\\"] >>> find_sequences(\\"abcfde\\") [\\"abc\\", \\"f\\", \\"de\\"] >>> find_sequences(\\"abcxyz\\") [\\"abc\\", \\"xyz\\"] >>> find_sequences(\\"abcmnopxyz\\") [\\"abc\\", \\"mnop\\", \\"xyz\\"] >>> find_sequences(\\"abcdabcd\\") [\\"abcd\\", \\"abcd\\"] >>> find_sequences(\\"\\") [] >>> long_string = \\"abcdefghijklmnopqrstuvwxyz\\" * 10; find_sequences(long_string) [\\"abcdefghijklmnopqrstuvwxyz\\"] * 10","solution":"def find_sequences(s): Returns a list of substrings, each representing a consecutive sequence of alphabetically ordered characters from the string. sequences = [] current_sequence = \\"\\" for i in range(len(s)): if i == 0 or ord(s[i]) == ord(s[i-1]) + 1: current_sequence += s[i] else: sequences.append(current_sequence) current_sequence = s[i] if current_sequence: sequences.append(current_sequence) return sequences"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the input string s. A palindrome is a word that reads the same forward and backward. >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"b\\") == \\"b\\" >>> longest_palindrome_substring(\\"abba\\") == \\"abba\\" >>> longest_palindrome_substring(\\"abcdcba\\") == \\"abcdcba\\" >>> longest_palindrome_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindrome_substring(\\"babcbab\\") == \\"babcbab\\" >>> longest_palindrome_substring(\\"abc\\") == \\"a\\" >>> longest_palindrome_substring(\\"xyz\\") == \\"x\\" >>> longest_palindrome_substring(\\"\\") == \\"\\" >>> longest_palindrome_substring(\\"aabacdfgdcabaaba\\") == \\"abaaba\\"","solution":"def longest_palindrome_substring(s): Returns the longest palindromic substring in the input string s. A palindrome is a word that reads the same forward and backward. if not s: return \\"\\" def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # odd length palindromes temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # even length palindromes temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"from typing import List, Optional def most_frequent_string(strings: List[str]) -> Optional[str]: Returns the string that appears most frequently in the list of strings. If there is a tie, returns the string that comes first alphabetically. If the list is empty, returns None. Examples: >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"banana\\"]) 'banana' >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"cherry\\"]) 'apple' >>> most_frequent_string([\\"apple\\"]) 'apple' >>> most_frequent_string([]) None >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"cherry\\"]) 'apple' pass","solution":"from collections import Counter def most_frequent_string(strings): Returns the string that appears most frequently in the list of strings. If there is a tie, returns the string that comes first alphabetically. if not strings: return None count = Counter(strings) max_count = max(count.values()) most_frequent = [string for string, freq in count.items() if freq == max_count] return min(most_frequent)"},{"question":"class Contact: def __init__(self, first_name: str, last_name: str, phone_number: str, email: str): self.first_name = first_name self.last_name = last_name self.phone_number = phone_number self.email = email class ContactManager: def __init__(self): self.contacts = {} def add_contact(self, first_name: str, last_name: str, phone_number: str, email: str): Add a new contact to the contact list. pass def update_contact(self, phone_number: str, **kwargs): Update the details of an existing contact identified by phone_number. pass def delete_contact(self, phone_number: str): Remove a contact from the list using phone_number. pass def search_contact(self, last_name: str): Return all contacts that match a given last_name. pass def list_contacts(self): Return a list of contacts sorted by last_name. pass Unit Test: import pytest from solution import ContactManager def test_add_contact(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") assert len(manager.contacts) == 1 assert manager.contacts[\\"123-456-7890\\"].first_name == \\"John\\" def test_add_duplicate_contact(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") with pytest.raises(ValueError): manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.another@example.com\\") def test_update_contact(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") manager.update_contact(\\"123-456-7890\\", first_name=\\"Jonathan\\") assert manager.contacts[\\"123-456-7890\\"].first_name == \\"Jonathan\\" def test_update_nonexistent_contact(): manager = ContactManager() with pytest.raises(ValueError): manager.update_contact(\\"999-999-9999\\", first_name=\\"Jonathan\\") def test_delete_contact(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") manager.delete_contact(\\"123-456-7890\\") assert len(manager.contacts) == 0 def test_delete_nonexistent_contact(): manager = ContactManager() with pytest.raises(ValueError): manager.delete_contact(\\"999-999-9999\\") def test_search_contact(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") manager.add_contact(\\"Jane\\", \\"Doe\\", \\"098-765-4321\\", \\"jane.doe@example.com\\") results = manager.search_contact(\\"Doe\\") assert len(results) == 2 def test_list_contacts(): manager = ContactManager() manager.add_contact(\\"John\\", \\"Doe\\", \\"123-456-7890\\", \\"john.doe@example.com\\") manager.add_contact(\\"Jane\\", \\"Smith\\", \\"098-765-4321\\", \\"jane.smith@example.com\\") contacts = manager.list_contacts() assert contacts[0].last_name == \\"Doe\\" assert contacts[1].last_name == \\"Smith\\"","solution":"class Contact: def __init__(self, first_name, last_name, phone_number, email): self.first_name = first_name self.last_name = last_name self.phone_number = phone_number self.email = email class ContactManager: def __init__(self): self.contacts = {} def add_contact(self, first_name, last_name, phone_number, email): if phone_number in self.contacts: raise ValueError(\\"Contact with this phone number already exists.\\") self.contacts[phone_number] = Contact(first_name, last_name, phone_number, email) def update_contact(self, phone_number, **kwargs): if phone_number not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") contact = self.contacts[phone_number] for key, value in kwargs.items(): if hasattr(contact, key): setattr(contact, key, value) def delete_contact(self, phone_number): if phone_number not in self.contacts: raise ValueError(\\"Contact with this phone number does not exist.\\") del self.contacts[phone_number] def search_contact(self, last_name): return [contact for contact in self.contacts.values() if contact.last_name == last_name] def list_contacts(self): return sorted(self.contacts.values(), key=lambda contact: contact.last_name)"},{"question":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given an array of integers, find two numbers such that they add up to a specific target number. Return the indices of the two numbers as a tuple. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> two_sum([123456789, 987654321], 1111111110) (0, 1) >>> two_sum([1, 2, 3, 4, 4], 8) (3, 4) >>> two_sum([3, 2, 4], 6) (1, 2)","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): Array of integers. target (int): Target sum. Returns: Tuple[int, int]: Indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"def has_k_divisors(nums: List[int], k: int) -> List[bool]: Takes a list of integers and an integer k and returns a list of booleans indicating for each integer in the list whether it has at least k divisors. >>> has_k_divisors([10, 15, 7], 3) [True, True, False] >>> has_k_divisors([3, 5, 7, 11], 3) [False, False, False, False]","solution":"def has_k_divisors(nums, k): def count_divisors(n): count = 0 for i in range(1, n + 1): if n % i == 0: count += 1 return count result = [] for num in nums: result.append(count_divisors(num) >= k) return result # Example usage: # print(has_k_divisors([10, 15, 7], 3)) # Output: [True, True, False]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a string containing an algebraic expression comprised of single-digit integers and the four basic operations (addition, subtraction, multiplication, and division) with proper operator precedence. >>> evaluate_expression(\\"2+2\\") == 4 >>> evaluate_expression(\\"5-3\\") == 2 >>> evaluate_expression(\\"3*4\\") == 12 >>> evaluate_expression(\\"6/2\\") == 3 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"2+3*4-5\\") == 9 >>> evaluate_expression(\\"2+3*4-5/2\\") == 11.5 >>> evaluate_expression(\\"2+2*2\\") == 6 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"5/2\\") == 2.5 >>> evaluate_expression(\\"1+5/2\\") == 3.5","solution":"def evaluate_expression(expression): Evaluates a string containing an algebraic expression comprised of single-digit integers and the four basic operations (addition, subtraction, multiplication, and division) with proper operator precedence. import re tokens = re.findall(r'd+|[*/+-]', expression) def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) values = [] operators = [] precedence = {'+': 1, '-': 1, '*': 2, '/': 2} for token in tokens: if token.isdigit(): values.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def sum_of_even_numbers(numbers: List[int]) -> int: Calculate the sum of all even numbers in a given list of integers. Parameters: numbers (list): a list of integers Returns: int: the sum of all even integers in the list >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6]) 12 >>> sum_of_even_numbers([2, 4, 6, 8]) 20 >>> sum_of_even_numbers([1, 3, 5, 7]) 0 >>> sum_of_even_numbers([-2, -3, -4, 5, -6]) -12 >>> sum_of_even_numbers([]) 0","solution":"def sum_of_even_numbers(numbers): Returns the sum of all even numbers in the given list. Parameters: numbers (list): a list of integers Returns: int: the sum of all even integers in the list return sum(number for number in numbers if number % 2 == 0)"},{"question":"def is_balanced_parentheses(s: str) -> str: Checks if the string of parentheses is balanced. Returns True if balanced, False if not balanced, and \\"Invalid input\\" if input is invalid. >>> is_balanced_parentheses(\\"()\\") == True >>> is_balanced_parentheses(\\"(())\\") == True >>> is_balanced_parentheses(\\"(()())\\") == True >>> is_balanced_parentheses(\\"\\") == True >>> is_balanced_parentheses(\\"(()\\") == False >>> is_balanced_parentheses(\\"())\\") == False >>> is_balanced_parentheses(\\"((())\\") == False >>> is_balanced_parentheses(\\"())(\\") == False >>> is_balanced_parentheses(\\"(a)\\") == \\"Invalid input\\" >>> is_balanced_parentheses(\\"(()b)\\") == \\"Invalid input\\" >>> is_balanced_parentheses(\\"123\\") == \\"Invalid input\\" >>> is_balanced_parentheses(\\"(())[]\\") == \\"Invalid input\\" # Your implementation goes here","solution":"def is_balanced_parentheses(s): Checks if the string of parentheses is balanced. Returns True if balanced, False if not balanced, and \\"Invalid input\\" if input is invalid. # Check if input contains invalid characters if not all(c in '()' for c in s): return \\"Invalid input\\" # Initialize counter for balance checking balance = 0 for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance goes negative, parentheses are not balanced if balance < 0: return False # If balance is zero, parentheses are balanced return balance == 0"},{"question":"def encrypt_message(message: str, shift: int) -> str: Returns the encrypted message where each character in the message is shifted by \`shift\` positions in the alphabet. Only lowercase letters are considered. >>> encrypt_message(\\"abcxyz\\", 1) \\"bcdyza\\" >>> encrypt_message(\\"a\\", 2) \\"c\\" >>> encrypt_message(\\"yza\\", 2) \\"abc\\" >>> encrypt_message(\\"hello\\", 0) \\"hello\\" >>> encrypt_message(\\"abc\\", 26) \\"abc\\" >>> encrypt_message(\\"hello world!\\", 3) \\"khoor zruog!\\" >>> encrypt_message(\\"cde\\", -1) \\"bcd\\" >>> encrypt_message(\\"xyz\\", 29) \\"abc\\"","solution":"def encrypt_message(message: str, shift: int) -> str: Returns the encrypted message where each character in the message is shifted by \`shift\` positions in the alphabet. Only lowercase letters are considered. Parameters: message (str): The original message to encrypt. shift (int): The number of positions to shift each character. Returns: str: The encrypted message. encrypted_message = [] for char in message: if 'a' <= char <= 'z': new_position = (ord(char) - ord('a') + shift) % 26 new_char = chr(ord('a') + new_position) encrypted_message.append(new_char) else: encrypted_message.append(char) return ''.join(encrypted_message)"},{"question":"def find_unique_characters(s: str) -> List[str]: Returns a list of unique characters in the order they first appear in the string. The comparison is case-sensitive. Parameters: s (str): The input string. Returns: List[str]: A list of unique characters. >>> find_unique_characters(\\"apple\\") ['a', 'p', 'l', 'e'] >>> find_unique_characters(\\"banana\\") ['b', 'a', 'n'] >>> find_unique_characters(\\"AaBbCc\\") ['A', 'a', 'B', 'b', 'C', 'c'] >>> find_unique_characters(\\"\\") [] >>> find_unique_characters(\\"!@#%^^&\\") ['!', '@', '#', '', '%', '^', '&']","solution":"def find_unique_characters(s): Returns a list of unique characters in the order they first appear in the string. The comparison is case-sensitive. seen = set() unique_chars = [] for char in s: if char not in seen: unique_chars.append(char) seen.add(char) return unique_chars"},{"question":"def optimal_task_assignment(tasks: List[int]) -> List[List[int]]: Given a list of task durations, returns the optimal assignment of tasks to workers to minimize the maximum sum of task durations assigned to any worker. :param tasks: List of integers representing the task durations. :return: List of lists where each sub-list contains two tasks assigned to a worker. >>> optimal_task_assignment([5, 2, 1, 6, 4, 4]) [[1, 6], [2, 5], [4, 4]] >>> optimal_task_assignment([1, 2]) [[1, 2]] >>> optimal_task_assignment([7, 7, 7, 7]) [[7, 7], [7, 7]] >>> optimal_task_assignment([10, 1, 8, 7, 2, 9]) [[1, 10], [2, 9], [7, 8]] >>> optimal_task_assignment([1000000, 1, 999999, 2]) [[1, 1000000], [2, 999999]] pass","solution":"def optimal_task_assignment(tasks): Given a list of task durations, returns the optimal assignment of tasks to workers to minimize the maximum sum of task durations assigned to any worker. :param tasks: List of integers representing the task durations. :return: List of lists where each sub-list contains two tasks assigned to a worker. tasks.sort() n = len(tasks) assignment = [] for i in range(n // 2): assignment.append([tasks[i], tasks[n - 1 - i]]) return assignment"},{"question":"class MinStack: Custom stack data structure that supports typical stack operations such as push, pop, peek, and isEmpty. In addition, the stack provides a function getMin() that returns the minimum element in the stack in constant time. Assume that all elements inserted into the stack are integers. def __init__(self): Initialize the MinStack with two stacks: - one for storing the elements themselves, - one for keeping track of the minimum elements. pass def push(self, val: int) -> None: Push an integer onto the main stack and update the min stack. pass def pop(self) -> None: Remove the element on the top of the stack, and update the min stack. pass def peek(self) -> int: Get the top element of the stack without removing it. pass def isEmpty(self) -> bool: Return True if stack is empty, False otherwise. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass # Unit Tests import pytest from solution import MinStack def test_push_and_pop(): stack = MinStack() stack.push(3) stack.push(2) stack.push(1) assert stack.pop() is None # stack should remove 1, the top element assert stack.pop() is None # stack should remove 2, the top element with pytest.raises(IndexError, match=\\"pop from empty stack\\"): stack.pop() stack.pop() def test_peek(): stack = MinStack() stack.push(3) stack.push(2) assert stack.peek() == 2 stack.pop() assert stack.peek() == 3 stack.pop() with pytest.raises(IndexError, match=\\"peek from empty stack\\"): stack.peek() def test_isEmpty(): stack = MinStack() assert stack.isEmpty() == True stack.push(1) assert stack.isEmpty() == False def test_getMin(): stack = MinStack() stack.push(3) assert stack.getMin() == 3 stack.push(2) assert stack.getMin() == 2 stack.push(1) assert stack.getMin() == 1 stack.pop() assert stack.getMin() == 2 stack.pop() assert stack.getMin() == 3 stack.push(7) stack.push(1) assert stack.getMin() == 1 stack.pop() assert stack.getMin() == 3 stack.pop() assert stack.getMin() == 3 stack.pop() with pytest.raises(IndexError, match=\\"getMin from empty stack\\"): stack.getMin()","solution":"class MinStack: def __init__(self): Initialize the MinStack with two stacks: - one for storing the elements themselves, - one for keeping track of the minimum elements. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push an integer onto the main stack and update the min stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Remove the element on the top of the stack, and update the min stack. if not self.stack: raise IndexError(\\"pop from empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def peek(self) -> int: Get the top element of the stack without removing it. if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def isEmpty(self) -> bool: Return True if stack is empty, False otherwise. return len(self.stack) == 0 def getMin(self) -> int: Retrieve the minimum element in the stack. if not self.min_stack: raise IndexError(\\"getMin from empty stack\\") return self.min_stack[-1]"},{"question":"from typing import List, Optional def max_product_of_three(nums: List[int]) -> Optional[int]: Returns the maximum possible product of any three numbers from the list. If the list contains less than three numbers, return None. # Example usage: >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, 2]) None def test_max_product_of_three(): # Test case with positive numbers assert max_product_of_three([1, 10, 2, 6, 5, 3]) == 300 # Test case with negative numbers involved assert max_product_of_three([-10, -10, 5, 2]) == 500 # Test case with less than three numbers assert max_product_of_three([1, 2]) == None # Test case with all negative numbers assert max_product_of_three([-10, -3, -5, -6, -20]) == -90 # Test case with mixed positive and negative numbers assert max_product_of_three([-4, -4, 2, 8]) == 128 # Test case with repeating maximum values assert max_product_of_three([10, 10, 10]) == 1000 # Test case with zero values assert max_product_of_three([0, 1, 2, 3]) == 6 assert max_product_of_three([0, -1, -2, -3]) == 0","solution":"from typing import List, Optional def max_product_of_three(nums: List[int]) -> Optional[int]: Returns the maximum possible product of any three numbers from the list. If the list contains less than three numbers, return None. if len(nums) < 3: return None # Initialize variables to track the highest and lowest values max1 = max2 = max3 = float('-inf') min1 = min2 = float('inf') for num in nums: if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num return max(max1 * max2 * max3, min1 * min2 * max1)"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among a list of strings. >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"flower\\"]) 'flower' >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"a\\", \\"a\\"]) 'a' >>> longest_common_prefix([\\"abcd\\", \\"efgh\\"]) '' >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) '' >>> longest_common_prefix([\\"\\", \\"nonempty\\"]) '' >>> longest_common_prefix([\\"\\", \\"flower\\", \\"flow\\", \\"flight\\"]) ''","solution":"def longest_common_prefix(strs): Returns the longest common prefix from a list of strings. Parameters: strs (list of str): List of strings to find the common prefix. Returns: str: The longest common prefix or an empty string if there's none. if not strs: return \\"\\" # Sort the list of strings strs.sort() # Initialize the first and last string from the sorted list as reference first, last = strs[0], strs[-1] i = 0 # Find common prefix between first and last string while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def group_strings_by_length(strings: List[str]) -> Dict[int, List[str]]: Takes a list of strings as input and returns a dictionary with keys as the lengths of the strings and values as lists of strings that correspond to those lengths. >>> group_strings_by_length([\\"abc\\", \\"de\\", \\"fgh\\", \\"i\\", \\"jk\\", \\"lmno\\"]) {1: [\\"i\\"], 2: [\\"de\\", \\"jk\\"], 3: [\\"abc\\", \\"fgh\\"], 4: [\\"lmno\\"]} >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"a\\", \\"b\\", \\"c\\"]) {1: [\\"a\\", \\"b\\", \\"c\\"]} >>> group_strings_by_length([\\"a\\", \\"bc\\", \\"def\\"]) {1: [\\"a\\"], 2: [\\"bc\\"], 3: [\\"def\\"]} >>> group_strings_by_length([\\"long\\", \\"short\\", \\"tiny\\", \\"minuscule\\", \\"I\\"]) {1: [\\"I\\"], 4: [\\"long\\", \\"tiny\\"], 5: [\\"short\\"], 9: [\\"minuscule\\"]}","solution":"def group_strings_by_length(strings): Takes a list of strings as input and returns a dictionary with keys as the lengths of the strings and values as lists of strings that correspond to those lengths. :param strings: List of strings :return: Dictionary with keys as string lengths and values as lists of strings length_dict = {} for string in strings: length = len(string) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"def is_balanced_parentheses(sequence: str) -> bool: Given a string \`sequence\` consisting of parentheses characters '(', ')', determine if the sequence is balanced. A sequence is balanced if: - Every opening parenthesis '(' has a corresponding closing parenthesis ')'. - The pairs of parentheses are properly nested. Examples: >>> is_balanced_parentheses(\\"()\\") True >>> is_balanced_parentheses(\\"(()\\") False >>> is_balanced_parentheses(\\"()()\\") True >>> is_balanced_parentheses(\\"(())\\") True >>> is_balanced_parentheses(\\")(\\") False Args: sequence (str): The input string to check. Returns: bool: True if the parentheses sequence is balanced, False otherwise.","solution":"def is_balanced_parentheses(sequence: str) -> bool: Given a string \`sequence\` consisting of parentheses characters '(', ')', determine if the sequence is balanced. A sequence is balanced if: - Every opening parenthesis '(' has a corresponding closing parenthesis ')'. - The pairs of parentheses are properly nested. Examples: >>> is_balanced_parentheses(\\"()\\") True >>> is_balanced_parentheses(\\"(()\\") False >>> is_balanced_parentheses(\\"()()\\") True >>> is_balanced_parentheses(\\"(())\\") True >>> is_balanced_parentheses(\\")(\\") False Args: sequence (str): The input string to check. Returns: bool: True if the parentheses sequence is balanced, False otherwise. stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack or stack.pop() != '(': return False return not stack"},{"question":"import re def is_palindrome(s: str) -> bool: Evaluates whether a string is a palindrome. A palindrome reads the same backward as forward, disregarding spaces, punctuation, and capitalization. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"hello world\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"1a2b2a1\\") True pass","solution":"import re def is_palindrome(s): Evaluates whether a string is a palindrome. A palindrome reads the same backward as forward, disregarding spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string reads the same backward as forward return cleaned_s == cleaned_s[::-1]"},{"question":"def is_prime(num: int) -> bool: Helper function to determine if a number is prime. def sum_of_first_n_primes(n: int) -> int: Returns the sum of the first n prime numbers. Raises a ValueError for invalid inputs. >>> sum_of_first_n_primes(0) == 0 >>> sum_of_first_n_primes(1) == 2 >>> sum_of_first_n_primes(2) == 5 >>> sum_of_first_n_primes(3) == 10 >>> sum_of_first_n_primes(5) == 28 >>> sum_of_first_n_primes(10) == 129 >>> sum_of_first_n_primes(-1) ValueError: Input must be a non-negative integer. >>> sum_of_first_n_primes(\\"a\\") ValueError: Input must be a non-negative integer. >>> sum_of_first_n_primes([1, 2, 3]) ValueError: Input must be a non-negative integer.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_first_n_primes(n): Returns the sum of the first n prime numbers. Raises a ValueError for invalid inputs. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") prime_sum = 0 count = 0 num = 2 while count < n: if is_prime(num): prime_sum += num count += 1 num += 1 return prime_sum"},{"question":"def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the list to the right by k positions. If k is larger than the length of the list, rotates by k % len(nums). If the list is empty or k is zero, returns the list unchanged. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([], 0) [] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([1], 5) [1] >>> rotate_list([1, 2, 3, 4], 4) [1, 2, 3, 4]","solution":"def rotate_list(nums, k): Rotates the list to the right by k positions. If k is larger than the length of the list, rotates by k % len(nums). If the list is empty or k is zero, returns the list unchanged. if not nums or k == 0: return nums n = len(nums) k = k % n # To handle cases where k is larger than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def reverse_words(s: str) -> str: Takes a string s and returns the same string with the words reversed. >>> reverse_words(\\"The sky is blue\\") 'blue is sky The' >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\" The sky is blue \\") 'blue is sky The' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"how now brown cow\\") 'cow brown now how'","solution":"def reverse_words(s): Takes a string s and returns the same string with the words reversed. words = s.split() return ' '.join(reversed(words))"},{"question":"def special_sort(arr): Sort the array such that all negative integers come before positive ones, while maintaining the original relative order among negative and positive numbers. >>> special_sort([1, -2, 3, -4, 5, -6]) == [-2, -4, -6, 1, 3, 5] >>> special_sort([-1, -2, -3, -4]) == [-1, -2, -3, -4] >>> special_sort([1, 2, 3, 4]) == [1, 2, 3, 4] >>> special_sort([]) == [] >>> special_sort([-1]) == [-1] >>> special_sort([1]) == [1] >>> special_sort([-1, 0, 2]) == [-1, 0, 2] >>> special_sort([0, -1, 2]) == [-1, 0, 2] >>> special_sort([1, -1, 1, -1]) == [-1, -1, 1, 1]","solution":"def special_sort(arr): Sort the array such that all negative integers come before positive ones, while maintaining the original relative order among negative and positive numbers. negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] return negatives + positives"},{"question":"from typing import List def sort_emails(email_list: List[str]) -> List[str]: Sorts a list of email addresses first by domain name and then by username, in a case-insensitive manner. >>> sort_emails([\\"bob.Smith@yahoo.Com\\", \\"alice.jones@Gmail.com\\", \\"charlie.brown@hotmail.com\\", \\"david.wilson@Org.Net\\", \\"eve.miller@Yahoo.com\\"]) [\\"alice.jones@Gmail.com\\", \\"charlie.brown@hotmail.com\\", \\"david.wilson@Org.Net\\", \\"bob.Smith@yahoo.Com\\", \\"eve.miller@Yahoo.com\\"] >>> sort_emails([]) [] >>> sort_emails([\\"single@domain.com\\"]) [\\"single@domain.com\\"] >>> sort_emails([\\"bob@domain.com\\", \\"alice@domain.com\\", \\"charlie@domain.com\\"]) [\\"alice@domain.com\\", \\"bob@domain.com\\", \\"charlie@domain.com\\"] >>> sort_emails([\\"user@sub1.domain.com\\", \\"user@sub2.domain.com\\", \\"user@domain.com\\"]) [\\"user@domain.com\\", \\"user@sub1.domain.com\\", \\"user@sub2.domain.com\\"]","solution":"def sort_emails(email_list): Sorts a list of email addresses first by domain name and then by username, in a case-insensitive manner. return sorted(email_list, key=lambda email: (email.split('@')[1].lower(), email.split('@')[0].lower()))"},{"question":"def find_min_subset_difference(nums: List[int]) -> int: Given a list of non-negative numbers, this function partitions it into two subsets such that the absolute difference between the sums of the subsets is minimized. Parameters: nums (List[int]): List of non-negative integers. Returns: int: The minimum difference between the sums of the two subsets. >>> find_min_subset_difference([1, 6, 11, 5]) 1 >>> find_min_subset_difference([3, 1, 4, 2, 2]) 0 >>> find_min_subset_difference([]) 0 >>> find_min_subset_difference([1]) 1 >>> find_min_subset_difference([2, 2, 2, 2]) 0 >>> find_min_subset_difference([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1","solution":"def find_min_subset_difference(nums): Given a list of non-negative numbers, this function partitions it into two subsets such that the absolute difference between the sums of the subsets is minimized. Parameters: nums (List[int]): List of non-negative integers. Returns: int: The minimum difference between the sums of the two subsets. total_sum = sum(nums) n = len(nums) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in nums: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i"},{"question":"from typing import List def average_of_evens(numbers: List[int]) -> float: Returns the average of all even numbers in the list. If there are no even numbers, returns 0. >>> average_of_evens([1, 2, 3, 4, 5]) # should return 3.0 3.0 >>> average_of_evens([2, 4, 6, 8]) # should return 5.0 5.0 >>> average_of_evens([1, 3, 5, 7]) # should return 0 0 >>> average_of_evens([]) # should return 0 0 >>> average_of_evens([-2, -4, 4, 2]) # should return 0.0 0.0","solution":"def average_of_evens(numbers): Returns the average of all even numbers in the list. If there are no even numbers, returns 0. evens = [num for num in numbers if num % 2 == 0] if not evens: return 0 return sum(evens) / len(evens)"},{"question":"from typing import List def find_one_row_words(words: List[str]) -> List[str]: Returns a list of words that can be typed using just one row of QWERTY keyboard. >>> find_one_row_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> find_one_row_words([\\"qwerty\\", \\"asdfgh\\", \\"zxcvbn\\", \\"QWERTY\\", \\"ASDFGH\\", \\"ZXCVBN\\"]) [\\"qwerty\\", \\"asdfgh\\", \\"zxcvbn\\", \\"QWERTY\\", \\"ASDFGH\\", \\"ZXCVBN\\"] >>> find_one_row_words([\\"Hello\\", \\"World\\"]) [] >>> find_one_row_words([]) [] >>> find_one_row_words([\\"a\\", \\"s\\", \\"d\\", \\"g\\", \\"h\\", \\"A\\", \\"S\\", \\"D\\", \\"G\\", \\"H\\"]) [\\"a\\", \\"s\\", \\"d\\", \\"g\\", \\"h\\", \\"A\\", \\"S\\", \\"D\\", \\"G\\", \\"H\\"]","solution":"def find_one_row_words(words): Returns a list of words that can be typed using just one row of QWERTY keyboard. :param words: List of words to check. :return: List of words that can be typed using one row on a QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): word_set = set(word.lower()) return word_set <= row1 or word_set <= row2 or word_set <= row3 return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"import random def card_game() -> str: Simulates a simplified card game between two players and determines the winner. The deck consists of 52 cards with values from 1 (Ace) to 13 (King). Each player draws 5 cards alternately, and the player with the higher total value wins. If both players have the same total value, the game is a draw. Example Output: >>> card_game() The winner is Player 1 with total value: 42 # or >>> card_game() The game is a draw with both players having total value: 38 # Your implementation here","solution":"import random def card_game() -> str: Simulates a simplified card game between two players and determines the winner. # Create a deck of 52 cards (4 suits, values 1 to 13) deck = [value for value in range(1, 14)] * 4 # Shuffle the deck random.shuffle(deck) # Each player draws 5 cards alternately player1_hand = [] player2_hand = [] for i in range(5): player1_hand.append(deck.pop(0)) player2_hand.append(deck.pop(0)) # Calculate the total values of cards for each player player1_total = sum(player1_hand) player2_total = sum(player2_hand) # Determine the winner or if the game is a draw if player1_total > player2_total: return f\\"The winner is Player 1 with total value: {player1_total}\\" elif player2_total > player1_total: return f\\"The winner is Player 2 with total value: {player2_total}\\" else: return f\\"The game is a draw with both players having total value: {player1_total}\\""},{"question":"def rearrange_string(s: str) -> str: Given a string containing a mixture of uppercase letters, lowercase letters, and digits, returns a new string where: - All digits are moved to the front of the string. - All letters retain their relative order after the digits. - The order of digits should also be same as their relative order in the input string. >>> rearrange_string(\\"a1b2c3\\") == \\"123abc\\" >>> rearrange_string(\\"3F5G7h9\\") == \\"3579FGh\\" >>> rearrange_string(\\"abcABC\\") == \\"abcABC\\" >>> rearrange_string(\\"123456\\") == \\"123456\\" >>> rearrange_string(\\"\\") == \\"\\" >>> rearrange_string(\\"987654321\\") == \\"987654321\\" >>> rearrange_string(\\"xyzXYZ\\") == \\"xyzXYZ\\" >>> rearrange_string(\\"aA1bB2cC3\\") == \\"123aAbBcC\\" >>> rearrange_string(\\"1a2B3cD4\\") == \\"1234aBcD\\" # Your code here","solution":"def rearrange_string(s): Given a string containing a mixture of uppercase letters, lowercase letters, and digits, returns a new string where: - All digits are moved to the front of the string. - All letters retain their relative order after the digits. - The order of digits should also be same as their relative order in the input string. Parameters: s (str): The input string. Returns: str: The rearranged string with digits in front. digits = ''.join([c for c in s if c.isdigit()]) letters = ''.join([c for c in s if c.isalpha()]) return digits + letters"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted singly-linked lists into a single sorted linked list. :param l1: ListNode, the head of the first sorted linked list :param l2: ListNode, the head of the second sorted linked list :return: ListNode, the head of the merged sorted linked list >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([1, 2, 4]), list_to_linkedlist([1, 3, 4]))) [1, 1, 2, 3, 4, 4] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([]), list_to_linkedlist([0]))) [0] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([]), list_to_linkedlist([]))) [] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([5, 10, 15]), list_to_linkedlist([2, 3, 20]))) [2, 3, 5, 10, 15, 20] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([1, 1, 1]), list_to_linkedlist([1, 1, 1]))) [1, 1, 1, 1, 1, 1] pass def list_to_linkedlist(items): if not items: return None head = ListNode(items[0]) current = head for item in items[1:]: current.next = ListNode(item) current = current.next return head def linkedlist_to_list(node): res = [] while node: res.append(node.val) node = node.next return res","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1, l2): Merges two sorted singly-linked lists into a single sorted linked list. :param l1: ListNode, the head of the first sorted linked list :param l2: ListNode, the head of the second sorted linked list :return: ListNode, the head of the merged sorted linked list dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"from typing import List from collections import defaultdict def groupAnagrams(strs: List[str]) -> List[List[str]]: Groups a list of strings into sets of anagrams. Args: strs (List[str]): A list of strings to be grouped Returns: List[List[str]]: A list of lists where each inner list contains words that are anagrams of each other Examples: >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> groupAnagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"zyx\\"]] >>> groupAnagrams([\\"code\\", \\"doce\\", \\"framer\\", \\"frame\\"]) [[\\"code\\", \\"doce\\"], [\\"framer\\"], [\\"frame\\"]] >>> groupAnagrams([\\"solo\\", \\"only\\", \\"one\\"]) [[\\"solo\\"], [\\"only\\"], [\\"one\\"]] >>> groupAnagrams([\\"a\\", \\"b\\", \\"a\\"]) [[\\"a\\", \\"a\\"], [\\"b\\"]] >>> groupAnagrams([]) [] pass def test_example1(): input_list = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] output = groupAnagrams(input_list) expected_output = [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] for group in expected_output: assert group in output assert len(output) == len(expected_output) def test_example2(): input_list = [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"] output = groupAnagrams(input_list) expected_output = [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"zyx\\"]] for group in expected_output: assert group in output assert len(output) == len(expected_output) def test_example3(): input_list = [\\"code\\", \\"doce\\", \\"framer\\", \\"frame\\"] output = groupAnagrams(input_list) expected_output = [[\\"code\\", \\"doce\\"], [\\"framer\\"], [\\"frame\\"]] for group in expected_output: assert group in output assert len(output) == len(expected_output) def test_no_anagrams(): input_list = [\\"solo\\", \\"only\\", \\"one\\"] output = groupAnagrams(input_list) expected_output = [[\\"solo\\"], [\\"only\\"], [\\"one\\"]] for group in expected_output: assert group in output assert len(output) == len(expected_output) def test_single_character(): input_list = [\\"a\\", \\"b\\", \\"a\\"] output = groupAnagrams(input_list) expected_output = [[\\"a\\", \\"a\\"], [\\"b\\"]] for group in expected_output: assert group in output assert len(output) == len(expected_output) def test_empty_input(): input_list = [] output = groupAnagrams(input_list) expected_output = [] assert output == expected_output","solution":"def groupAnagrams(strs): Groups a list of strings into sets of anagrams. from collections import defaultdict anagrams = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def can_be_converted(s1: str, s2: str) -> bool: Determine if two input strings can be made identical by performing at most one swap between two characters within one of the strings. >>> can_be_converted(\\"same\\", \\"same\\") True >>> can_be_converted(\\"ab\\", \\"ba\\") True >>> can_be_converted(\\"converse\\", \\"conserve\\") True >>> can_be_converted(\\"abc\\", \\"bca\\") False >>> can_be_converted(\\"ab\\", \\"cd\\") False >>> can_be_converted(\\"abcde\\", \\"edcba\\") False >>> can_be_converted(\\"aabbcc\\", \\"aabbcc\\") True >>> can_be_converted(\\"a\\", \\"a\\") True >>> can_be_converted(\\"abc\\", \\"abcd\\") False","solution":"def can_be_converted(s1, s2): This function checks if two strings can be made identical by performing at most one swap between two characters within one of the strings. if len(s1) != len(s2): return False # Find the indices where the characters in s1 and s2 don't match mismatch_indices = [] for i in range(len(s1)): if s1[i] != s2[i]: mismatch_indices.append(i) # If there are no mismatches, the strings are already identical if len(mismatch_indices) == 0: return True # There must be exactly two mismatches to have a possible single swap conversion if len(mismatch_indices) != 2: return False i, j = mismatch_indices # Check if swapping the mismatched characters in s1 turns it into s2 return s1[i] == s2[j] and s1[j] == s2[i]"},{"question":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merges two dictionaries. In case of duplicate keys, the value from dict2 will override the value from dict1. Parameters: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing the merged content of dict1 and dict2. >>> merge_dictionaries({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': 3, 'c': 4} >>> merge_dictionaries({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> merge_dictionaries({'a': 1, 'b': 2}, {}) {'a': 1, 'b': 2} >>> merge_dictionaries({}, {}) {}","solution":"def merge_dictionaries(dict1, dict2): Merges two dictionaries. In case of duplicate keys, the value from dict2 will override the value from dict1. Parameters: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing the merged content of dict1 and dict2. merged_dict = dict1.copy() # Ensure original dict1 is not modified merged_dict.update(dict2) # Update merged_dict with dict2 values return merged_dict"},{"question":"def largest_kth_product(tuple_list: list, k: int): Returns the k-th largest product from the set of all possible products of the integers in each tuple. Returns 'Invalid Input' if the list contains any invalid elements. Examples: >>> largest_kth_product([(3, 5), (1, 2), (7, 8)], 1) 56 >>> largest_kth_product([(3, 5), (1, 2), (7, 8)], 2) 15 >>> largest_kth_product([(3, 5), (1, 2), (7, 'x')], 1) Invalid Input >>> largest_kth_product([3, (1, 2), (7, 8)], 3) Invalid Input","solution":"def largest_kth_product(tuple_list: list, k: int): Returns the k-th largest product from the set of all possible products of the integers in each tuple. Returns 'Invalid Input' if the list contains any invalid elements. # Validate input for item in tuple_list: if not isinstance(item, tuple) or len(item) != 2: return \\"Invalid Input\\" if not all(isinstance(i, int) for i in item): return \\"Invalid Input\\" # Calculate products products = [a * b for a, b in tuple_list] # Sort products in descending order products.sort(reverse=True) # Return k-th largest product if 0 < k <= len(products): return products[k-1] else: return \\"Invalid Input\\""},{"question":"import string from collections import Counter from typing import List def is_anagram(s1: str, s2: str) -> bool: Returns True if s1 is an anagram of s2, False otherwise. >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"Hello\\", \\"World\\") False >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True >>> is_anagram(\\"A gentleman.\\", \\"Elegant mann!!\\") False >>> is_anagram(\\"Tar\\", \\"Rat\\") True >>> is_anagram(\\"Tired\\", \\"TrieD\\") True >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"aabbcc\\", \\"abc\\") False","solution":"import string def is_anagram(s1, s2): Returns True if s1 is an anagram of s2, False otherwise. # Remove spaces and punctuation, convert to lowercase refined_s1 = ''.join(char.lower() for char in s1 if char in string.ascii_letters) refined_s2 = ''.join(char.lower() for char in s2 if char in string.ascii_letters) # Use a dictionary to count character frequencies from collections import Counter return Counter(refined_s1) == Counter(refined_s2)"},{"question":"def string_permutations(s: str) -> list: Generates all possible permutations of a given string in lexicographical order. >>> string_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> string_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> string_permutations(\\"\\") [] >>> string_permutations(\\"a\\") ['a'] >>> string_permutations(\\"aabb\\") ['aabb', 'abab', 'abba', 'baab', 'baba', 'bbaa'] >>> string_permutations(\\"aaaa\\") ['aaaa']","solution":"def string_permutations(s: str) -> list: Generates all possible permutations of a given string in lexicographical order. if not s: return [] # Function to find the next lexicographical permutation def next_permutation(arr): # Find the largest index i such that arr[i] < arr[i + 1] for i in range(len(arr) - 2, -1, -1): if arr[i] < arr[i + 1]: break else: return False # No further permutation # Find the largest index j such that arr[i] < arr[j] for j in range(len(arr) - 1, i, -1): if arr[i] < arr[j]: break # Swap the values at index i and j arr[i], arr[j] = arr[j], arr[i] # Reverse the sequence from i+1 to end arr[i + 1:] = arr[i + 1:][::-1] return True # The initial permutation is the sorted order of characters arr = sorted(s) results = [''.join(arr)] while next_permutation(arr): results.append(''.join(arr)) return results"},{"question":"def update_scores(scores: dict) -> list: Accepts a dictionary where keys are student names and values are their respective scores. 1. Adds 5 bonus points to each student's score. 2. If a student's total score after adding the bonus exceeds 100, sets their score to 100. 3. If a student's original score was below 50, applies a 10% reduction after adding the bonus. 4. Returns a sorted list of tuples (name, score) sorted by the students' names in alphabetical order. >>> update_scores({\\"Alice\\": 90, \\"Bob\\": 45, \\"Charlie\\": 85, \\"David\\": 76}) [('Alice', 95), ('Bob', 45), ('Charlie', 90), ('David', 81)] >>> update_scores({\\"Ellie\\": 92, \\"Frank\\": 53}) [('Ellie', 97), ('Frank', 58)] >>> update_scores({\\"Gina\\": 99, \\"Harry\\": 100}) [('Gina', 100), ('Harry', 100)] >>> update_scores({\\"Iris\\": 47, \\"Jack\\": 30}) [('Iris', 46), ('Jack', 31)] >>> update_scores({\\"Keira\\": 98, \\"Liam\\": 97}) [('Keira', 100), ('Liam', 100)] >>> update_scores({\\"Mia\\": 42, \\"Noah\\": 38}) [('Mia', 42), ('Noah', 38)]","solution":"def update_scores(scores): Accepts a dictionary where keys are student names and values are their respective scores. 1. Adds 5 bonus points to each student's score. 2. If a student's total score after adding the bonus exceeds 100, sets their score to 100. 3. If a student's original score was below 50, applies a 10% reduction after adding the bonus. 4. Returns a sorted list of tuples (name, score) sorted by the students' names in alphabetical order. updated_scores = {} for name, score in scores.items(): updated_score = score + 5 if updated_score > 100: updated_score = 100 elif score < 50: updated_score *= 0.9 updated_scores[name] = int(updated_score) return sorted(updated_scores.items()) # Example usage # scores = {\\"Alice\\": 90, \\"Bob\\": 45, \\"Charlie\\": 85, \\"David\\": 76} # print(update_scores(scores)) # Should yield [('Alice', 95), ('Bob', 45), ('Charlie', 90), ('David', 81)]"},{"question":"def compress_string(s: str) -> str: Write a function compress_string that takes a string s as input and returns a compressed version of the string using the following method: consecutive occurrences of the same character are replaced by the character followed by the number of times it appears consecutively. If the compressed string is equal to or longer than the original string, return the original string. Args: s (str): Input string containing only lowercase alphabetic characters. Returns: str: Compressed string or the original string if compression does not reduce the size. Examples: >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\"","solution":"def compress_string(s: str) -> str: if not s: return s result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] + str(count)) count = 1 # Add the last character (and its count) result.append(s[-1] + str(count)) compressed = \\"\\".join(result) return compressed if len(compressed) < len(s) else s"},{"question":"def sort_by_second_element(tuples_list): Sorts a list of tuples by the second element in each tuple. Parameters: tuples_list (list of tuple): List of tuples to be sorted. Returns: list of tuple: Sorted list of tuples by the second element. >>> sort_by_second_element([(3, 5), (2, 1), (4, 7), (1, 4)]) == [(2, 1), (1, 4), (3, 5), (4, 7)] >>> sort_by_second_element([(1, 2), (2, 2), (3, 2)]) == [(1, 2), (2, 2), (3, 2)] >>> sort_by_second_element([]) == [] >>> sort_by_second_element([(1, 5)]) == [(1, 5)] >>> sort_by_second_element([(1, -1), (2, -3), (3, -2)]) == [(2, -3), (3, -2), (1, -1)]","solution":"def sort_by_second_element(tuples_list): Sorts a list of tuples by the second element in each tuple. Parameters: tuples_list (list of tuple): List of tuples to be sorted. Returns: list of tuple: Sorted list of tuples by the second element. return sorted(tuples_list, key=lambda x: x[1]) # Example usage: # sorted_list = sort_by_second_element([(3, 5), (2, 1), (4, 7), (1, 4)]) # The sorted_list will be [(2, 1), (1, 4), (3, 5), (4, 7)]"},{"question":"import pandas as pd import matplotlib.pyplot as plt def clean_dataset(df): Cleans the dataframe by removing duplicates, filling missing values, and addressing data inconsistencies. Parameters: df (pd.DataFrame): The dataframe to be cleaned. Returns: pd.DataFrame: The cleaned dataframe. pass def summary_statistics(df): Returns the summary statistics of the dataframe. Parameters: df (pd.DataFrame): The dataframe. Returns: pd.DataFrame: The summary statistics. pass def plot_histograms(df): Plots histograms for all numeric columns in the dataframe. Parameters: df (pd.DataFrame): The dataframe. pass # Example usage with a publicly available dataset def load_and_clean_example_dataset(): # Load the dataset df = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/titanic.csv') # Clean the dataset df_cleaned = clean_dataset(df) # Calculate and display summary statistics print(summary_statistics(df_cleaned)) # Plot histograms plot_histograms(df_cleaned) # Uncomment the following line to execute the example # load_and_clean_example_dataset()","solution":"import pandas as pd import matplotlib.pyplot as plt def clean_dataset(df): Cleans the dataframe by removing duplicates, filling missing values, and addressing data inconsistencies. Parameters: df (pd.DataFrame): The dataframe to be cleaned. Returns: pd.DataFrame: The cleaned dataframe. # Remove duplicate entries df = df.drop_duplicates() # Handling missing values: Filling with mean for numeric columns and mode for categorical columns for column in df.columns: if df[column].dtype == 'object': mode = df[column].mode()[0] df[column].fillna(mode, inplace=True) else: mean = df[column].mean() df[column].fillna(mean, inplace=True) # Data inconsistencies could include invalid values or incorrect data types # Here, let's assume there's a column 'age' which should be numeric if 'age' in df.columns: df['age'] = pd.to_numeric(df['age'], errors='coerce') df['age'].fillna(df['age'].mean(), inplace=True) return df def summary_statistics(df): Returns the summary statistics of the dataframe. Parameters: df (pd.DataFrame): The dataframe. Returns: pd.DataFrame: The summary statistics. return df.describe() def plot_histograms(df): Plots histograms for all numeric columns in the dataframe. Parameters: df (pd.DataFrame): The dataframe. numeric_columns = df.select_dtypes(include=['float64', 'int64']).columns df[numeric_columns].hist(bins=15, figsize=(15, 6), layout=(2, len(numeric_columns)//2)) plt.tight_layout() plt.show() # Example usage with a publicly available dataset def load_and_clean_example_dataset(): # Load the dataset df = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/titanic.csv') # Clean the dataset df_cleaned = clean_dataset(df) # Calculate and display summary statistics print(summary_statistics(df_cleaned)) # Plot histograms plot_histograms(df_cleaned) # Uncomment the following line to execute the example # load_and_clean_example_dataset()"},{"question":"def find_pairs(numbers, target): Returns a list of unique pairs of integers from the list that sum up to the target integer. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([-1, -2, 3, 4, 5], 3) [(-2, 5), (-1, 4)] >>> find_pairs([5], 5) [] >>> find_pairs([], 5) [] >>> find_pairs([-5, -4, -3, -2, -1], -5) [(-4, -1), (-3, -2)] >>> find_pairs([1, 3, 5, 7, 9, 11], 12) [(1, 11), (3, 9), (5, 7)]","solution":"def find_pairs(numbers, target): Returns a list of unique pairs of integers from the list that sum up to the target integer. numbers.sort() pairs = [] seen = set() left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: if (numbers[left], numbers[right]) not in seen: pairs.append((numbers[left], numbers[right])) seen.add((numbers[left], numbers[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Args: - arr1: List[int], first sorted array. - arr2: List[int], second sorted array. Returns: - List[int], merged sorted array containing all elements from arr1 and arr2. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 3, 5], [1, 2, 6]) [1, 1, 2, 3, 5, 6] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([2], [1]) [1, 2] >>> merge_sorted_arrays([1], [3]) [1, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Args: - arr1: List[int], first sorted array. - arr2: List[int], second sorted array. Returns: - List[int], merged sorted array containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def find_second_largest(arr: List[int]) -> int: Returns the second largest element in the list or None if the list contains fewer than 2 elements. >>> find_second_largest([3, 2, 1, 4, 5]) == 4 >>> find_second_largest([10]) == None >>> find_second_largest([]) == None >>> find_second_largest([2, 2, 3, 1]) == 2","solution":"def find_second_largest(arr): Returns the second largest element in the list or None if the list contains fewer than 2 elements. :param arr: list of integers :return: second largest integer or None if len(arr) < 2: return None first_largest = second_largest = float('-inf') for num in arr: if num > first_largest: second_largest = first_largest first_largest = num elif first_largest > num > second_largest: second_largest = num return second_largest if second_largest != float('-inf') else None"},{"question":"def above_average(numbers: List[int]) -> List[int]: Returns a list of integers from the input list that are above the average value. Maintains the relative order of elements. >>> above_average([1, 2, 3, 4, 5]) == [4, 5] >>> above_average([-5, -4, -3, -2, -1]) == [-2, -1] >>> above_average([1, -2, 3, 0, -5, 6]) == [1, 3, 6] >>> above_average([7]) == [] >>> above_average([2, 4, 4, 4, 6]) == [6] >>> above_average([3, 3, 3, 3]) == [] >>> above_average([]) == [] >>> above_average([0, 0, 0, 0]) == [] >>> above_average([1000, 2000, 3000, 4000, 5000]) == [4000, 5000]","solution":"def above_average(numbers): Returns a list of integers from the input list that are above the average value. Maintains the relative order of elements. if not numbers: return [] average_val = sum(numbers) / len(numbers) return [num for num in numbers if num > average_val]"},{"question":"from typing import List def longest_consecutive_sequence(arr: List[int]) -> int: This function takes a list of integers and determines the length of the longest consecutive sequence of unique numbers. The list may contain both positive and negative integers, and duplicate values should be ignored when counting the sequence length. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([1, 2]) 2 >>> longest_consecutive_sequence([1, 3]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([-1, -9, -2, -3, -5, -4]) 5 >>> longest_consecutive_sequence([1, 9, 3, 10, 2, 20, 4]) 4 >>> longest_consecutive_sequence([10, 1, 9, 3, 11, 2, 20, 4, 12]) 4 >>> longest_consecutive_sequence([4, 5, 99, 100, 101, 1, 2, 3]) 5","solution":"def longest_consecutive_sequence(arr): This function takes a list of integers and returns the length of the longest consecutive sequence of unique numbers within the list. if not arr: return 0 num_set = set(arr) max_length = 0 for num in num_set: if num - 1 not in num_set: # start of a new sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the given string. If all characters repeat or the string is empty, returns None. >>> first_non_repeating_char(\\"aabbcc\\") is None >>> first_non_repeating_char(\\"abcdef\\") == 'a' >>> first_non_repeating_char(\\"swiss\\") == 'w' >>> first_non_repeating_char(\\"\\") is None >>> first_non_repeating_char(\\"a\\") == 'a' >>> first_non_repeating_char(\\"a a b b c c d\\") == 'd' >>> first_non_repeating_char(\\"!@#%^&*!\\") == '@'","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the given string. If all characters repeat or the string is empty, returns None. from collections import Counter # Count the frequency of each character char_count = Counter(s) # Iterate through the string and find the first character with count 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character found, return None return None # Example usage example_string = \\"swiss\\" print(first_non_repeating_char(example_string)) # Output: 'w'"},{"question":"def find_char_frequencies(text: str) -> dict: Returns a dictionary with the frequency of each character in the string. Ignore whitespaces and consider all characters as lowercase. >>> find_char_frequencies(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> find_char_frequencies(\\"\\") {} >>> find_char_frequencies(\\" \\") {} >>> find_char_frequencies(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, ',': 1, '!': 1} >>> find_char_frequencies(\\"HeLLo WoRLd\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> find_char_frequencies(\\"helloworld\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} pass","solution":"def find_char_frequencies(text): Returns a dictionary with the frequency of each character in the string. Ignore whitespaces and consider all characters as lowercase. text = text.replace(\\" \\", \\"\\").lower() freq_dict = {} for char in text: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"def decode_rle(encoded_str: str) -> str: Decodes a run-length encoded string back to its original form. Parameters: encoded_str (str): The run-length encoded string. Returns: str: The decoded original string. >>> decode_rle(\\"a4b3c2\\") 'aaaabbbcc' >>> decode_rle(\\"a1b1c1\\") 'abc' >>> decode_rle(\\"a10b5\\") 'aaaaaaaaaabbbbb' >>> decode_rle(\\"a0b1c0\\") 'b' >>> decode_rle(\\"\\") ''","solution":"def decode_rle(encoded_str): Decodes a run-length encoded string back to its original form. Parameters: encoded_str (str): The run-length encoded string. Returns: str: The decoded original string. decoded_str = \\"\\" i = 0 while i < len(encoded_str): char = encoded_str[i] i += 1 freq = \\"\\" while i < len(encoded_str) and encoded_str[i].isdigit(): freq += encoded_str[i] i += 1 decoded_str += char * int(freq) return decoded_str"},{"question":"def account_balance(transactions: list, date: str) -> int: Returns the account balance at the end of the given date. Parameters: transactions (list): List of transactions where each transaction is a tuple containing the date (in \\"YYYY-MM-DD\\" format), the transaction amount, and an optional description. date (str): The date for which the balance needs to be calculated. Returns: int: The balance of the account at the end of the specified date. >>> transactions = [ (\\"2022-01-01\\", 500, \\"Initial deposit\\"), (\\"2022-01-05\\", -200, \\"Grocery shopping\\"), (\\"2022-01-10\\", 100, \\"Gift\\"), (\\"2022-01-10\\", -50, \\"Dinner\\"), (\\"2022-01-15\\", -20, \\"Book purchase\\") ] >>> account_balance(transactions, \\"2022-01-10\\") 350 >>> account_balance(transactions, \\"2022-01-05\\") 300 >>> account_balance(transactions, \\"2022-01-01\\") 500 from datetime import datetime def test_account_balance_simple_case(): transactions = [ (\\"2022-01-01\\", 500, \\"Initial deposit\\"), (\\"2022-01-05\\", -200, \\"Grocery shopping\\"), (\\"2022-01-10\\", 100, \\"Gift\\"), (\\"2022-01-10\\", -50, \\"Dinner\\"), (\\"2022-01-15\\", -20, \\"Book purchase\\") ] assert account_balance(transactions, \\"2022-01-10\\") == 350 def test_account_balance_all_transactions_before_date(): transactions = [ (\\"2022-01-01\\", 500, \\"Initial deposit\\"), (\\"2022-01-05\\", -200, \\"Grocery shopping\\"), (\\"2022-01-06\\", 100, \\"Gift\\"), (\\"2022-01-07\\", -50, \\"Dinner\\") ] assert account_balance(transactions, \\"2022-01-06\\") == 400 def test_account_balance_no_transactions_before_date(): transactions = [ (\\"2022-01-10\\", 100, \\"Gift\\"), (\\"2022-01-12\\", -50, \\"Dinner\\"), (\\"2022-01-15\\", -20, \\"Book purchase\\") ] assert account_balance(transactions, \\"2022-01-05\\") == 0 def test_account_balance_include_all_transactions(): transactions = [ (\\"2022-01-01\\", 500, \\"Initial deposit\\"), (\\"2022-01-05\\", -200, \\"Grocery shopping\\"), (\\"2022-01-10\\", 100, \\"Gift\\"), (\\"2022-01-10\\", -50, \\"Dinner\\"), (\\"2022-01-15\\", -20, \\"Book purchase\\") ] assert account_balance(transactions, \\"2022-01-15\\") == 330 assert account_balance(transactions, \\"2022-01-20\\") == 330 def test_account_balance_multiple_transactions_same_day(): transactions = [ (\\"2022-01-01\\", 500), (\\"2022-01-01\\", -100), (\\"2022-01-05\\", 100), (\\"2022-01-05\\", -50) ] assert account_balance(transactions, \\"2022-01-05\\") == 450 assert account_balance(transactions, \\"2022-01-01\\") == 400","solution":"def account_balance(transactions, date): Returns the account balance at the end of the given date. Parameters: transactions (list): List of transactions where each transaction is a tuple containing the date (in \\"YYYY-MM-DD\\" format), the transaction amount, and an optional description. date (str): The date for which the balance needs to be calculated. Returns: int: The balance of the account at the end of the specified date. balance = 0 for transaction_date, amount, *description in transactions: if transaction_date <= date: balance += amount return balance"},{"question":"def max_occuring_char(s: str) -> str: Create a Python function called \`max_occuring_char\` that takes a string as input and returns the character that appears the most frequently within that string. In case of a tie, return the character that comes first alphabetically. You may assume the string contains only lowercase alphabetic characters and is non-empty. >>> max_occuring_char(\\"examples\\") 'e' >>> max_occuring_char(\\"testcase\\") 'e'","solution":"def max_occuring_char(s): Returns the character that appears the most frequently within the input string. In case of a tie, returns the character that comes first alphabetically. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the maximum frequency max_frequency = max(char_count.values()) # Collect characters that have the maximum frequency max_chars = [char for char, freq in char_count.items() if freq == max_frequency] # Return the smallest character lexicographically from the list of max frequency characters return min(max_chars)"},{"question":"from typing import List, Union def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> Union[List[int], str]: Merges two sorted arrays arr1 and arr2 into a single sorted array without using built-in sorting functions. Handles empty arrays, duplicates, and negative values. Parameters: arr1 (List[int]): The first sorted array. arr2 (List[int]): The second sorted array. Returns: Union[List[int], str]: The merged sorted array or a message if both arrays are empty. Examples: >>> merge_sorted_arrays([], []) 'Both arrays are empty' >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [1, 2, 3]) [1, 1, 2, 3, 3, 5] >>> merge_sorted_arrays([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays arr1 and arr2 into a single sorted array without using built-in sorting functions. Handles empty arrays, duplicates, and negative values. if not arr1 and not arr2: return \\"Both arrays are empty\\" if not arr1: return arr2 if not arr2: return arr1 merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements of arr1 or arr2 (if any) while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def find_max_length_subarray(arr: list) -> int: Finds the length of the longest contiguous subarray with an equal number of 0s and 1s. Args: arr (list): A list of integers containing only 0s and 1s. Returns: int: The length of the longest contiguous subarray with equal number of 0s and 1s. >>> find_max_length_subarray([0, 1, 0, 0, 1, 1, 0]) 6 >>> find_max_length_subarray([0, 0, 0, 0]) 0 >>> find_max_length_subarray([1, 1, 1, 1]) 0 >>> find_max_length_subarray([0, 1, 1, 0, 1, 0, 0]) 6 >>> find_max_length_subarray([]) 0 >>> find_max_length_subarray([0]) 0 >>> find_max_length_subarray([1]) 0 >>> find_max_length_subarray([0, 1, 0]) 2 >>> find_max_length_subarray([0, 1, 1, 0]) 4","solution":"def find_max_length_subarray(arr: list) -> int: Finds the length of the longest contiguous subarray with an equal number of 0s and 1s. Args: arr (list): A list of integers containing only 0s and 1s. Returns: int: The length of the longest contiguous subarray with equal number of 0s and 1s. count = 0 max_length = 0 count_dict = {0: -1} for i in range(len(arr)): if arr[i] == 0: count -= 1 else: count += 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Compute the amount of water that can be trapped after a rain given the heights of the buildings. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 pass # Implement the function here def test_no_buildings(): assert trap_rain_water([]) == 0 def test_buildings_with_no_trapped_water(): assert trap_rain_water([3, 3, 3]) == 0 def test_single_trapped_water(): assert trap_rain_water([2, 0, 2]) == 2 def test_complex_trapped_water_example_one(): assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_complex_trapped_water_example_two(): assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 def test_only_one_building(): assert trap_rain_water([1]) == 0 def test_two_buildings(): assert trap_rain_water([1, 0]) == 0 def test_descending_heights(): assert trap_rain_water([5, 4, 3, 2, 1]) == 0 def test_ascending_heights(): assert trap_rain_water([1, 2, 3, 4, 5]) == 0 def test_v_shape(): assert trap_rain_water([5, 0, 5]) == 5 def test_plateau_shape(): assert trap_rain_water([5, 5, 5, 5]) == 0","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: Compute the amount of water that can be trapped after a rain given the heights of the buildings. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"from typing import Optional def first_k_distinct_substring(s: str, k: int) -> str: Returns the first substring of length k that contains k distinct characters. If no such substring exists, returns an empty string. Args: s (str): The input string. k (int): The length of the substring. Returns: str: The first substring of length k with k distinct characters or an empty string. Examples: >>> first_k_distinct_substring(\\"abcdefg\\", 3) \\"abc\\" >>> first_k_distinct_substring(\\"aaabbccddeeff\\", 2) \\"ab\\" >>> first_k_distinct_substring(\\"xyzzzzxyz\\", 3) \\"xyz\\" >>> first_k_distinct_substring(\\"abcd\\", 4) \\"abcd\\" >>> first_k_distinct_substring(\\"abc\\", 4) \\"\\" >>> first_k_distinct_substring(\\"aaaaa\\", 2) \\"\\" >>> first_k_distinct_substring(\\"aAbbA\\", 2) \\"aA\\" >>> first_k_distinct_substring(\\"AaBbCc\\", 3) \\"AaB\\"","solution":"def first_k_distinct_substring(s, k): Returns the first substring of length k that contains k distinct characters. If no such substring exists, returns an empty string. Args: s (str): The input string. k (int): The length of the substring. Returns: str: The first substring of length k with k distinct characters or an empty string. if k > len(s): return \\"\\" for i in range(len(s) - k + 1): substring = s[i:i + k] if len(set(substring)) == k: return substring return \\"\\""},{"question":"def evaluate_expression(math_expression): Evaluates a mathematical expression string containing non-negative integers and the operators '+', '-', '*', '/'. Returns the result as an integer or float. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10/2-7\\") -2.0 >>> evaluate_expression(\\"15-3*3+2\\") 8","solution":"import operator def evaluate_expression(math_expression): Evaluates a mathematical expression string containing non-negative integers and the operators '+', '-', '*', '/'. Returns the result as an integer or float. The function is equipped with error handling for invalid inputs and division by zero. if not math_expression: raise ValueError(\\"Empty expression is not valid.\\") # Operator precedence precedence = {'+': 1, '-': 1, '*': 2, '/': 2} # Supported operators operators = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv} def apply_operator(operands, op): right = operands.pop() left = operands.pop() if op == '/' and right == 0: raise ZeroDivisionError(\\"division by zero\\") operands.append(operators[op](left, right)) def greater_precedence(op1, op2): return precedence[op1] >= precedence[op2] operands = [] ops = [] i = 0 while i < len(math_expression): if math_expression[i] in '0123456789': j = i while j < len(math_expression) and math_expression[j] in '0123456789': j += 1 operands.append(int(math_expression[i:j])) i = j elif math_expression[i] in operators: while (ops and ops[-1] in operators and greater_precedence(ops[-1], math_expression[i])): apply_operator(operands, ops.pop()) ops.append(math_expression[i]) i += 1 else: raise ValueError(f\\"Invalid character found in expression: {math_expression[i]}\\") while ops: apply_operator(operands, ops.pop()) return operands[0] # Example Usage: # result = evaluate_expression(\\"3+5*2\\") # print(result) # Output: 13"},{"question":"import pytest def modify_list(nums): Takes a list of integers and returns a new list where each positive integer is squared, each negative integer is cubed, and zeroes remain unchanged. Handles non-integer values by raising a ValueError. pass def test_modify_list_positive_integers(): assert modify_list([1, 2, 3]) == [1, 4, 9] def test_modify_list_negative_integers(): assert modify_list([-1, -2, -3]) == [-1, -8, -27] def test_modify_list_mixed_integers(): assert modify_list([-1, 0, 1]) == [-1, 0, 1] def test_modify_list_zero(): assert modify_list([0, 0, 0]) == [0, 0, 0] def test_modify_list_mix_with_zero(): assert modify_list([2, 0, -2]) == [4, 0, -8] def test_modify_list_non_integer_values(): with pytest.raises(ValueError): modify_list([1, 2, 'a']) def test_modify_list_empty_list(): assert modify_list([]) == []","solution":"def modify_list(nums): Takes a list of integers and returns a new list where each positive integer is squared, each negative integer is cubed, and zeroes remain unchanged. Handles non-integer values by raising a ValueError. result = [] for num in nums: if not isinstance(num, int): raise ValueError(\\"All elements in the input list must be integers.\\") if num > 0: result.append(num ** 2) elif num < 0: result.append(num ** 3) else: result.append(num) return result"},{"question":"from typing import Dict def word_frequency(sentence: str) -> Dict[str, int]: Develop a function that accepts a string representing a sequence of words separated by single spaces and returns a dictionary where the key is each unique word and the value is its frequency of occurrence in the sequence. Ignore case, treating \\"Word\\" and \\"word\\" as the same. >>> word_frequency(\\"the quick brown fox jumps over the lazy dog the quick brown dog\\") {'the': 3, 'quick': 2, 'brown': 2, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 2} >>> word_frequency(\\"Word word WoRd\\") {'word': 3} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"hello world\\") {'hello': 1, 'world': 1} >>> word_frequency(\\"Word\\") {'word': 1}","solution":"def word_frequency(sentence): Returns a dictionary with each unique word as the key and its frequency in the sentence as the value. The words are case insensitive. words = sentence.lower().split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"from typing import Tuple, Dict, List def find_highest_density_cities(populations: Dict[str, int], land_areas: Dict[str, float], n: int) -> Tuple[List[str], Dict[str, float]]: Finds the top n cities with the highest population density and returns a statistical summary. Parameters: populations (dict): Dictionary with city names as keys and population as values. land_areas (dict): Dictionary with city names as keys and land area in sq km as values. n (int): Number of top cities to return based on population density. Returns: list: Top n cities with the highest population density. dict: Statistical summary containing average, median, and mode of the population densities. >>> populations = { ... \\"CityA\\": 1000000, ... \\"CityB\\": 500000, ... \\"CityC\\": 200000, ... } >>> land_areas = { ... \\"CityA\\": 200, ... \\"CityB\\": 50, ... \\"CityC\\": 75, ... } >>> find_highest_density_cities(populations, land_areas, 2) ([\\"CityB\\", \\"CityA\\"], {\\"average\\": 8333.33, \\"median\\": 6666.67, \\"mode\\": None})","solution":"from statistics import mean, median, mode, StatisticsError def find_highest_density_cities(populations, land_areas, n): Finds the top n cities with the highest population density and returns a statistical summary. Parameters: populations (dict): Dictionary with city names as keys and population as values. land_areas (dict): Dictionary with city names as keys and land area in sq km as values. n (int): Number of top cities to return based on population density. Returns: list: Top n cities with the highest population density. dict: Statistical summary containing average, median, and mode of the population densities. if n <= 0: return [], {} densities = {} for city, population in populations.items(): if city in land_areas: land_area = land_areas[city] if population > 0 and land_area > 0: densities[city] = population / land_area sorted_densities = sorted(densities.items(), key=lambda item: item[1], reverse=True) top_cities = sorted_densities[:n] top_city_names = [city for city, density in top_cities] density_values = list(densities.values()) if not density_values: return [],{} try: density_mode = mode(density_values) except StatisticsError: density_mode = None stats_summary = { 'average': mean(density_values), 'median': median(density_values), 'mode': density_mode } return top_city_names, stats_summary"},{"question":"def calculate_total_cost(n: int) -> float: Returns the total cost for n number of donuts based on the bakery's pricing tiers. >>> calculate_total_cost(3) -> 3.00 >>> calculate_total_cost(5) -> 4.75 >>> calculate_total_cost(10) -> 9.00 >>> calculate_total_cost(25) -> 21.25","solution":"def calculate_total_cost(n): Returns the total cost for n number of donuts based on the bakery's pricing tiers. return round( n * ( (n >= 1) * (n <= 4) * 1.00 + (n >= 5) * (n <= 9) * 0.95 + (n >= 10) * (n <= 19) * 0.90 + (n >= 20) * 0.85 ), 2 )"},{"question":"def longest_increasing_subarray(inputArray: List[int]) -> List[int]: Finds the longest contiguous subarray within the given array where all the elements are strictly increasing. If there are multiple such subarrays with the same maximum length, returns the first one encountered. >>> longest_increasing_subarray([]) == [] >>> longest_increasing_subarray([5]) == [5] >>> longest_increasing_subarray([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> longest_increasing_subarray([5, 5, 5, 5]) == [5] >>> longest_increasing_subarray([5, 4, 3, 2, 1]) == [5] >>> longest_increasing_subarray([1, 3, 5, 4, 7, 8, 2, 3, 4, 5, 6, 1]) == [2, 3, 4, 5, 6] >>> longest_increasing_subarray([1, 2, 3, 4, 1, 2, 3, 4]) == [1, 2, 3, 4] >>> longest_increasing_subarray([1, 2, 2, 3, 4, 5, 1]) == [2, 3, 4, 5] >>> longest_increasing_subarray([1, 1, 1, 2, 3]) == [1, 2, 3]","solution":"def longest_increasing_subarray(inputArray): Finds the longest contiguous subarray within the given array where all the elements are strictly increasing. If there are multiple such subarrays with the same maximum length, returns the first one encountered. if not inputArray: return [] max_len = 1 current_len = 1 max_start = 0 current_start = 0 for i in range(1, len(inputArray)): if inputArray[i] > inputArray[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start = current_start current_start = i current_len = 1 if current_len > max_len: max_len = current_len max_start = current_start return inputArray[max_start:max_start + max_len]"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> Union[List[Tuple[int, int]], str]: Finds all unique pairs of integers in the list 'arr' that sum up to 'target'. Parameters: arr (list of int): List of integers. target (int): The target sum for the pairs. Returns: list of tuple: List of tuples where each tuple represents a unique pair summing up to the target. Remarks: If the list has fewer than 2 elements, return \\"Not enough elements to form pairs.\\" Examples: >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 2, 3, 3, 4, 4, 5], 6) [(1, 5), (2, 4), (3, 3)] >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> find_pairs_with_sum([], 5) \\"Not enough elements to form pairs.\\" >>> find_pairs_with_sum([1], 5) \\"Not enough elements to form pairs.\\" >>> find_pairs_with_sum([-1, -2, -3, 2, 3, 4], 1) [(-3, 4), (-2, 3), (-1, 2)] >>> find_pairs_with_sum([-1, 0, 1, 2, -2, 3], 0) [(-2, 2), (-1, 1)]","solution":"def find_pairs_with_sum(arr, target): Finds all unique pairs of integers in the list 'arr' that sum up to 'target'. Parameters: arr (list of int): List of integers. target (int): The target sum for the pairs. Returns: list of tuple: List of tuples where each tuple represents a unique pair summing up to the target. if len(arr) < 2: return \\"Not enough elements to form pairs.\\" arr = sorted(arr) pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"from typing import List, Union, Tuple class VendingMachine: Class to simulate a basic vending machine. - Accept a list of integers representing coins inserted (with values of 1, 5, 10, 25). - Have a predefined list of items with their prices (for example, {\\"soda\\": 125, \\"water\\": 100, \\"chips\\": 50}). - Provide an interface to select an item and return the change or indicate insufficient funds. def insert_coins(self, coins: List[int]) -> None: Insert coins into the vending machine to update the current balance. pass def get_current_balance(self) -> int: Get the current balance of the vending machine. pass def select_item(self, item: str) -> Union[str, Tuple[str, int]]: Select an item from the vending machine, providing change or indicating insufficient funds if necessary. pass","solution":"from typing import List, Union, Tuple class VendingMachine: def __init__(self): self.balance = 0 self.items = { \\"soda\\": 125, \\"water\\": 100, \\"chips\\": 50 } def insert_coins(self, coins: List[int]) -> None: valid_coins = {1, 5, 10, 25} for coin in coins: if coin in valid_coins: self.balance += coin def get_current_balance(self) -> int: return self.balance def select_item(self, item: str) -> Union[str, Tuple[str, int]]: if item not in self.items: return \\"Item not available\\" item_price = self.items[item] if self.balance >= item_price: self.balance -= item_price return (item, self.balance) else: return \\"Insufficient funds\\""},{"question":"def get_oldest_person(people): Returns the name of the oldest person, or a list of names if multiple people have the highest age, sorted alphabetically. >>> get_oldest_person([{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 30}]) ['Alice', 'Charlie'] >>> get_oldest_person([{'name': 'John', 'age': 40}, {'name': 'Jane', 'age': 40}, {'name': 'Jessica', 'age': 40}]) ['Jane', 'Jessica', 'John']","solution":"def get_oldest_person(people): Returns the name of the oldest person, or a list of names if multiple people have the highest age, sorted alphabetically. if not people: return [] max_age = max(person['age'] for person in people) oldest_people = [person['name'] for person in people if person['age'] == max_age] return sorted(oldest_people)"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([], [1, 3, 5]) [1, 3, 5] >>> merge_sorted_lists([2, 4, 6], []) [2, 4, 6] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 5], [2, 4, 6]) [1, 2, 2, 4, 5, 6] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([-5, -3, 0], [-4, -2, 1]) [-5, -4, -3, -2, 0, 1]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def min_subarray_len(arr, k): Finds the minimum length of a contiguous subarray with sum >= k. If such a subarray doesn't exist, returns 0. :param arr: List of integers :param k: Integer, the target sum :return: Integer, the minimum length of subarray with sum >= k >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([1], 2) 0 >>> min_subarray_len([2, 1, 5, 2, 3, 2], 7) 2 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([2, 1, 6, 5, 4], 9) 2 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([1, 2, 3, 4, 5], 16) 0 >>> min_subarray_len([1, 1, 1, 1, 1, 1], 10) 0 >>> min_subarray_len([], 10) 0 >>> min_subarray_len([1, 2, '3', 4], 10) 0 >>> min_subarray_len([1, 2, 3, 4], '10') 0 >>> min_subarray_len('1234', 10) 0 >>> min_subarray_len(None, 10) 0","solution":"def min_subarray_len(arr, k): Finds the minimum length of a contiguous subarray with sum >= k. If such a subarray doesn't exist, returns 0. :param arr: List of integers :param k: Integer, the target sum :return: Integer, the minimum length of subarray with sum >= k if not arr or not isinstance(k, int) or not isinstance(arr, list) or any(not isinstance(x, int) for x in arr): return 0 n = len(arr) min_len = float('inf') left = 0 curr_sum = 0 for right in range(n): curr_sum += arr[right] while curr_sum >= k: min_len = min(min_len, right - left + 1) curr_sum -= arr[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def common_elements(list1, list2): Returns a list of common elements between list1 and list2 without duplicates. >>> common_elements([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> common_elements(['a', 'b', 'c'], ['b', 'c', 'd', 'e']) ['b', 'c']","solution":"def common_elements(list1, list2): Returns a list of common elements between list1 and list2 without duplicates. return list(set(list1) & set(list2))"},{"question":"def count_unique_seats(ticket_codes: List[str]) -> int: Determines the total number of unique seats booked given a list of alphanumeric ticket codes. Each ticket code follows a pattern where the first part (before the hyphen) represents the seat. >>> count_unique_seats([\\"A12-12345\\", \\"A12-67890\\", \\"B13-12345\\", \\"B14-12345\\", \\"C15-67890\\"]) 4 >>> count_unique_seats([\\"A12-12345\\", \\"A12-12345\\", \\"A12-12345\\"]) 1 >>> count_unique_seats([\\"A12-12345\\", \\"B13-12345\\", \\"C14-67890\\"]) 3 >>> count_unique_seats([\\"A12-12345\\", \\"A12-67890\\", \\"A12-11111\\"]) 1 >>> count_unique_seats([\\"A12-12345\\", \\"A12-67890\\", \\"B13-12345\\", \\"C14-67890\\"]) 3 >>> count_unique_seats([\\"A12-12345\\", \\"A12-12345\\", \\"A12-12345\\"]) 1 >>> count_unique_seats([\\"A{}-12345\\".format(i) for i in range(10000)]) 10000 >>> count_unique_seats([\\"A{}-12345\\".format(i % 5000) for i in range(10000)]) 5000","solution":"def count_unique_seats(ticket_codes): Determines the number of unique seats booked given a list of ticket codes. Args: ticket_codes (List[str]): A list of alphanumeric ticket codes. Returns: int: The number of unique seats booked. unique_seats = set() for code in ticket_codes: seat = code.split('-')[0] unique_seats.add(seat) return len(unique_seats)"},{"question":"def next_greater_element(nums1: List[int], nums2: List[int]) -> List[int]: Finds the next greater element for each element in nums1 within the list nums2. >>> next_greater_element([4, 1, 2], [1, 3, 4, 2]) [-1, 3, -1] >>> next_greater_element([2, 4], [1, 2, 3, 4]) [3, -1] >>> next_greater_element([1, 2, 3], [1, 2, 3, 4]) [2, 3, 4] >>> next_greater_element([3, 2, 1], [4, 3, 2, 1]) [-1, -1, -1] >>> next_greater_element([1], [1, 5]) [5] >>> next_greater_element([1], [1]) [-1]","solution":"def next_greater_element(nums1, nums2): Finds the next greater element for each element in nums1 within the list nums2. result = [] nums2_map = {num: -1 for num in nums2} stack = [] for num in nums2: while stack and stack[-1] < num: smaller_num = stack.pop() nums2_map[smaller_num] = num stack.append(num) for num in nums1: result.append(nums2_map[num]) return result"},{"question":"def analyze_list_order(lst: List[int]) -> str: Analyzes the order of elements in a list and returns a string denoting whether the list is strictly increasing, strictly decreasing, or neither. >>> analyze_list_order([1, 2, 3, 4, 5]) 'Increasing' >>> analyze_list_order([5, 4, 3, 2, 1]) 'Decreasing' >>> analyze_list_order([1, 3, 2, 4, 5]) 'Neither' >>> analyze_list_order([1]) 'Increasing' >>> analyze_list_order([]) 'Increasing' >>> analyze_list_order([1, 1, 1]) 'Neither' >>> analyze_list_order([1, 2, 2, 3]) 'Neither'","solution":"def analyze_list_order(lst): Analyzes the order of elements in a list. Returns \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". if all(lst[i] < lst[i + 1] for i in range(len(lst) - 1)): return \\"Increasing\\" elif all(lst[i] > lst[i + 1] for i in range(len(lst) - 1)): return \\"Decreasing\\" else: return \\"Neither\\""},{"question":"import pandas as pd from sklearn.preprocessing import StandardScaler from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score import numpy as np def preprocess_data(data: pd.DataFrame) -> np.ndarray: Handle missing values and apply feature scaling. Parameters: data (pd.DataFrame): The input data containing customer demographics and purchasing behavior. Returns: np.ndarray: The preprocessed and scaled data. # Handle missing values # ... # Feature scaling scaler = StandardScaler() scaled_data = scaler.fit_transform(data) return scaled_data def find_optimal_clusters(data: np.ndarray, max_clusters: int = 10) -> int: Determine the optimal number of clusters using the Elbow method. Parameters: data (np.ndarray): The preprocessed and scaled data. max_clusters (int): The maximum number of clusters to consider (default is 10). Returns: int: The optimal number of clusters. # ... optimal_clusters = 3 # Placeholder return optimal_clusters def clustering_analysis(data_path: str) -> float: Preprocess data, apply K-Means clustering, and evaluate the clusters. Parameters: data_path (str): The path to the CSV file containing the data. Returns: float: The silhouette score evaluating the clusters. # Load the dataset data = pd.read_csv(data_path) # Preprocess the data scaled_data = preprocess_data(data) # Determine the optimal number of clusters optimal_clusters = find_optimal_clusters(scaled_data) # Apply K-Means clustering kmeans = KMeans(n_clusters=optimal_clusters, random_state=42) clusters = kmeans.fit_predict(scaled_data) # Evaluate clusters using silhouette score score = silhouette_score(scaled_data, clusters) return score # Sample data for testing data_dict = { 'age': [25, 34, 45, 23, 35, np.nan, 29], 'annual_income': [50000, 60000, 80000, 55000, 65000, 70000, np.nan], 'spending_score': [45, 60, 80, 50, 65, 55, 70] } sample_data = pd.DataFrame(data_dict) def test_preprocess_data(): scaled_data = preprocess_data(sample_data) assert not np.any(np.isnan(scaled_data)), \\"There should be no NaNs after preprocessing (handling missing values and scaling)\\" assert scaled_data.shape == sample_data.shape, \\"Shape mismatch after preprocessing\\" def test_find_optimal_clusters(monkeypatch): def plot_mock(*args, **kwargs): pass monkeypatch.setattr('matplotlib.pyplot.show', plot_mock) optimal_clusters = find_optimal_clusters(sample_data, max_clusters=5) assert optimal_clusters == 3, \\"Assume 3 for this mock; this should be adjusted based on Elbow Analysis\\" @pytest.mark.skip(\\"Skipping full clustering analysis test as it needs file I/O operations\\") def test_clustering_analysis(): data_path = 'customer_segmentation.csv' # Use a correct path score = clustering_analysis(data_path) assert 0 <= score <= 1, \\"Silhouette score should be between 0 and 1\\" # Run the tests def run_tests(): test_preprocess_data() test_find_optimal_clusters() test_clustering_analysis() if __name__ == \\"__main__\\": run_tests()","solution":"import pandas as pd from sklearn.preprocessing import StandardScaler from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score import numpy as np import matplotlib.pyplot as plt def preprocess_data(data): Handle missing values and apply feature scaling. # Handle missing values by filling them with the mean of the column data.fillna(data.mean(), inplace=True) # Feature scaling scaler = StandardScaler() scaled_data = scaler.fit_transform(data) return scaled_data def find_optimal_clusters(data, max_clusters=10): Determine the optimal number of clusters using the Elbow method. wcss = [] for i in range(1, max_clusters+1): kmeans = KMeans(n_clusters=i, random_state=42) kmeans.fit(data) wcss.append(kmeans.inertia_) # Plot the Elbow graph plt.plot(range(1, max_clusters+1), wcss) plt.title('Elbow Method') plt.xlabel('Number of clusters') plt.ylabel('WCSS') plt.show() # Assume the elbow occurs at clusters=3 for example purposes (this should be analyzed from the plot) optimal_clusters = 3 return optimal_clusters def clustering_analysis(data_path): Preprocess data, apply K-Means clustering and evaluate the clusters. # Load the dataset data = pd.read_csv(data_path) # Preprocess the data scaled_data = preprocess_data(data) # Determine the optimal number of clusters optimal_clusters = find_optimal_clusters(scaled_data) # Apply K-Means clustering kmeans = KMeans(n_clusters=optimal_clusters, random_state=42) clusters = kmeans.fit_predict(scaled_data) # Evaluate clusters using silhouette score score = silhouette_score(scaled_data, clusters) return score # Example usage if __name__ == \\"__main__\\": data_path = 'customer_segmentation.csv' score = clustering_analysis(data_path) print(\\"Silhouette Score:\\", score)"},{"question":"def generate_fibonacci_series(n: int): Generates the Fibonacci series up to the Nth term and identifies whether each number is even or odd. Args: n (int): The number of terms in the Fibonacci series. Returns: List[Tuple[int, str]]: A list of tuples where each tuple contains a Fibonacci number and a string (\\"even\\" or \\"odd\\"). Raises: ValueError: If the input is not a positive integer greater than or equal to 1. >>> generate_fibonacci_series(1) [(0, \\"even\\")] >>> generate_fibonacci_series(2) [(0, \\"even\\"), (1, \\"odd\\")] >>> generate_fibonacci_series(5) [(0, \\"even\\"), (1, \\"odd\\"), (1, \\"odd\\"), (2, \\"even\\"), (3, \\"odd\\")] >>> generate_fibonacci_series(10) [(0, \\"even\\"), (1, \\"odd\\"), (1, \\"odd\\"), (2, \\"even\\"), (3, \\"odd\\"), (5, \\"odd\\"), (8, \\"even\\"), (13, \\"odd\\"), (21, \\"odd\\"), (34, \\"even\\")]","solution":"def generate_fibonacci_series(n): Generates the Fibonacci series up to the Nth term. if n < 1: raise ValueError(\\"N must be a positive integer greater than or equal to 1.\\") fib = [0, 1] for i in range(2, n): fib.append(fib[-1] + fib[-2]) result = [] for i in range(n): parity = \\"even\\" if fib[i] % 2 == 0 else \\"odd\\" result.append((fib[i], parity)) return result"},{"question":"def filter_long_strings(strings: List[str], n: int) -> List[str]: Returns a list of strings that have more than n characters. Parameters: strings (list of str): List of strings to be filtered. n (int): The minimum number of characters a string must have to be included in the result. Returns: list of str: List of strings that have more than n characters. >>> filter_long_strings([\\"short\\", \\"medium-sized\\", \\"a very long string!\\"], 5) ['medium-sized', 'a very long string!'] >>> filter_long_strings([], 5) [] >>> filter_long_strings([\\"tiny\\", \\"more text\\", \\"extravagant\\", \\"code\\", \\"\\"], 4) ['more text', 'extravagant'] >>> filter_long_strings([\\"!@#\\", \\"#\\", \\"*******\\"], 3) ['#', '*******'] >>> filter_long_strings([\\" \\", \\" \\", \\"long string\\"], 3) [' ', 'long string'] >>> filter_long_strings([\\"a\\", \\"bb\\", \\"ccc\\"], 3) []","solution":"def filter_long_strings(strings, n): Returns a list of strings that have more than n characters. Parameters: strings (list of str): List of strings to be filtered. n (int): The minimum number of characters a string must have to be included in the result. Returns: list of str: List of strings that have more than n characters. filtered = [] for string in strings: if len(string) > n: filtered.append(string) return filtered"},{"question":"def fibonacci(n, memo={}): Calculates the nth Fibonacci number using memoization. Args: n (int): The Fibonacci term to calculate. memo (dict): Dictionary to store previously computed Fibonacci numbers. Returns: int: The nth Fibonacci number. >>> fibonacci(10) == 55 >>> fibonacci(15) == 610 # Your code here","solution":"def fibonacci(n, memo={}): Calculates the nth Fibonacci number using memoization. Args: n (int): The Fibonacci term to calculate. memo (dict): Dictionary to store previously computed Fibonacci numbers. Returns: int: The nth Fibonacci number. if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo) return memo[n]"},{"question":"def calibrate_coordinates(coords): Given a list of tuples representing coordinates (x, y), produce a list which excludes any coordinate pair where the sum of the absolute values of x and y exceeds 50. The function should preserve the sequence of the remaining coordinates. e.g: coords = [(30, 20), (40, 30), (-10, -15), (25, 25)], expected result: [(30, 20), (-10, -15), (25, 25)] coords = [(10, 10), (25, 35), (60, 5)], expected result: [(10, 10)] coords = [(-50, 5), (15, -15), (5, 10), (10, 5)], expected result: [(-50, 5), (15, -15), (5, 10), (10, 5)] coords = [(51, 0), (100, 0), (0, 100)], expected result: []","solution":"def calibrate_coordinates(coords): Filter out coordinates where the sum of the absolute values of the x and y coordinates exceeds 50. return [coord for coord in coords if abs(coord[0]) + abs(coord[1]) <= 50]"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def predict_house_prices(dataframe): Train a Linear Regression model to predict house prices based on input features. Args: dataframe (pd.DataFrame): The input dataframe containing the features and target variable. Returns: model (LinearRegression): The trained linear regression model. mse (float): Mean Squared Error of the model on the test set. r2 (float): R-squared value of the model on the test set. Example: >>> data = { >>> 'bedrooms': [3, 2], >>> 'bathrooms': [2, 1], >>> 'sqft': [1500, 900], >>> 'location_B': [1, 0], >>> 'location_C': [0, 1], >>> 'price': [300000, 150000] >>> } >>> dataframe = pd.DataFrame(data) >>> model, mse, r2 = predict_house_prices(dataframe) # Implement the function here.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def predict_house_prices(dataframe): Train a Linear Regression model to predict house prices based on input features. # Split the data into features and target X = dataframe.drop(columns='price') y = dataframe['price'] # Split the data into training and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train the Linear Regression model model = LinearRegression() model.fit(X_train, y_train) # Predict on the test set y_pred = model.predict(X_test) # Calculate performance metrics mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) # Visualization plt.scatter(y_test, y_pred) plt.xlabel('Actual Prices') plt.ylabel('Predicted Prices') plt.title('Actual vs Predicted House Prices') plt.plot([y.min(), y.max()], [y.min(), y.max()], color='red', linewidth=2) plt.show() return model, mse, r2"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in the list \`nums\` that add up to \`target\`. Each pair should be sorted in ascending order, and the list of pairs should be sorted in lexicographical order. Parameters: nums (list): A list of integers. target (int): The target sum for the pairs. Returns: list: A list of unique pairs that sum to the target. >>> find_pairs([1, 2, 3], 6) [] >>> find_pairs([1, 2, 3], 5) [(2, 3)] >>> find_pairs([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 1, 2, 2], 3) [(1, 2)] >>> find_pairs([], 5) [] >>> find_pairs([-1, -2, -3, 3, 1, 2], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs([0, 0, 1, -1, 2, -2], 0) [(-2, 2), (-1, 1), (0, 0)]","solution":"def find_pairs(nums, target): Finds all unique pairs in the list \`nums\` that add up to \`target\`. Each pair should be sorted in ascending order, and the list of pairs should be sorted in lexicographical order. Parameters: nums (list): A list of integers. target (int): The target sum for the pairs. Returns: list: A list of unique pairs that sum to the target. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"def rearrange_pairs(pairs): Rearrange each pair (a, b) to (min(a, b), max(a, b)) and then sort the list of pairs primarily by the first element of each pair, and secondarily by the second element. >>> rearrange_pairs([(5, 2), (1, 7), (3, 3)]) [(1, 7), (2, 5), (3, 3)] >>> rearrange_pairs([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> rearrange_pairs([(10, 1), (5, 9), (7, 3)]) [(1, 10), (3, 7), (5, 9)] >>> rearrange_pairs([(1, 1), (1, 2), (2, 2)]) [(1, 1), (1, 2), (2, 2)] >>> rearrange_pairs([(4, 4), (4, 4), (4, 4)]) [(4, 4), (4, 4), (4, 4)]","solution":"def rearrange_pairs(pairs): Rearrange each pair (a, b) to (min(a, b), max(a, b)) and then sort the list of pairs primarily by the first element of each pair, and secondarily by the second element. # Rearrange pairs rearranged = [(min(a, b), max(a, b)) for a, b in pairs] # Sort the list of pairs rearranged.sort() return rearranged"},{"question":"def is_prime(k: int) -> bool: Returns True if the given integer k is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def check_primes(arr: List[int]) -> List[bool]: Returns a list of boolean values indicating the primality of each integer in the input array. >>> check_primes([2, 3, 4, 5, -1, 1, 0, 100]) [True, True, False, True, False, False, False, False] >>> check_primes([]) []","solution":"def is_prime(k): Returns True if the given integer k is a prime number, otherwise False. if k <= 1: return False for i in range(2, int(k ** 0.5) + 1): if k % i == 0: return False return True def check_primes(arr): Returns a list of boolean values indicating the primality of each integer in the input array. return [is_prime(num) for num in arr]"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. Explanation: 1. Initialize a boolean array 'sieve' of size (n+1) with all entries set to True. 2. Mark 0 and 1 as not prime, as they are not considered prime numbers. 3. Starting from the first prime number (2), mark all of its multiples as not prime. 4. Repeat the process for the next number in the array that is still marked as prime, until the square root of n. 5. Collect and return all the numbers that remain marked as true, as these are the prime numbers. >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] pass","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] # initialization of boolean array sieve = [True] * (n + 1) sieve[0:2] = [False, False] # 0 and 1 are not primes # Eliminate non-primes by marking multiples of each prime for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False # Extracting all primes primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes # Function usage example: # primes_up_to_30 = sieve_of_eratosthenes(30) # print(primes_up_to_30) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"},{"question":"def longest_substr_two_distinct(s: str) -> str: Write a function that takes in a string consisting of lowercase alphabets, and returns the longest contiguous substring that contains at most two distinct characters. >>> longest_substr_two_distinct(\\"abcbbbbcccbdddadacb\\") == \\"bcbbbbcccb\\" >>> longest_substr_two_distinct(\\"\\") == \\"\\" >>> longest_substr_two_distinct(\\"aaaaa\\") == \\"aaaaa\\" >>> longest_substr_two_distinct(\\"aabbcc\\") in [\\"aabb\\", \\"bbcc\\"] >>> longest_substr_two_distinct(\\"abcdef\\") in [\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\"] >>> longest_substr_two_distinct(\\"kkkkk\\") == \\"kkkkk\\" >>> longest_substr_two_distinct(\\"abcdeffedcba\\") in [\\"effe\\", \\"cdeffedc\\"]","solution":"def longest_substr_two_distinct(s): if not s: return \\"\\" start = 0 max_length = 0 max_substring = \\"\\" char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"import pandas as pd from sklearn.metrics.pairwise import cosine_similarity class CollaborativeFilteringRecommender: def __init__(self): self.user_ratings_matrix = None self.similarity_matrix = None def fit(self, ratings): Fit the collaborative filtering model. Parameters: ratings (pd.DataFrame): DataFrame containing user's ratings with columns ['user_id', 'book_id', 'rating'] pass def recommend(self, user_id, num_recommendations=5): Recommend books for a given user. Parameters: user_id (int): ID of the user to whom recommendations are to be made num_recommendations (int): Number of book recommendations Returns: list: List of book IDs recommended for the user pass def evaluate(self, test_ratings): Evaluate the accuracy of the recommendations. Parameters: test_ratings (pd.DataFrame): DataFrame containing user's ratings with columns ['user_id', 'book_id', 'rating'] Returns: float: Mean squared error of the predictions pass # Example usage: # ratings = pd.DataFrame({'user_id': ..., 'book_id': ..., 'rating': ...}) # cf_recommender = CollaborativeFilteringRecommender() # cf_recommender.fit(ratings) # recommendations = cf_recommender.recommend(user_id=1, num_recommendations=5) # Unit tests def test_recommendations(): ratings = pd.DataFrame({ 'user_id': [1, 1, 2, 2, 3, 3, 4, 4, 5, 5], 'book_id': [101, 102, 101, 103, 102, 104, 101, 104, 102, 105], 'rating': [5, 4, 5, 3, 4, 5, 4, 3, 2, 5] }) cf_recommender = CollaborativeFilteringRecommender() cf_recommender.fit(ratings) recommendations_user_1 = cf_recommender.recommend(1, num_recommendations=2) assert set(recommendations_user_1) & {101, 102} == set() assert isinstance(recommendations_user_1, list) assert len(recommendations_user_1) == 2 def test_evaluation(): ratings_train = pd.DataFrame({ 'user_id': [1, 1, 2, 2, 3, 3], 'book_id': [101, 102, 101, 103, 102, 104], 'rating': [5, 4, 5, 3, 4, 5] }) ratings_test = pd.DataFrame({ 'user_id': [1, 2, 3], 'book_id': [103, 102, 101], 'rating': [5, 3, 5] }) cf_recommender = CollaborativeFilteringRecommender() cf_recommender.fit(ratings_train) mse = cf_recommender.evaluate(ratings_test) assert isinstance(mse, float) assert mse >= 0","solution":"import pandas as pd import numpy as np from sklearn.metrics.pairwise import cosine_similarity class CollaborativeFilteringRecommender: def __init__(self): self.user_ratings_matrix = None self.similarity_matrix = None def fit(self, ratings): Fit the collaborative filtering model. Parameters: ratings (pd.DataFrame): DataFrame containing user's ratings with columns ['user_id', 'book_id', 'rating'] self.user_ratings_matrix = ratings.pivot(index='user_id', columns='book_id', values='rating').fillna(0) self.similarity_matrix = cosine_similarity(self.user_ratings_matrix) self.similarity_matrix = pd.DataFrame(self.similarity_matrix, index=self.user_ratings_matrix.index, columns=self.user_ratings_matrix.index) def recommend(self, user_id, num_recommendations=5): Recommend books for a given user. Parameters: user_id (int): ID of the user to whom recommendations are to be made num_recommendations (int): Number of book recommendations Returns: list: List of book IDs recommended for the user user_similarity_scores = self.similarity_matrix[user_id] similar_users = user_similarity_scores.sort_values(ascending=False).index.tolist() user_ratings = self.user_ratings_matrix.loc[user_id] already_rated = user_ratings[user_ratings > 0].index.tolist() recommendations = [] for similar_user in similar_users: if similar_user != user_id: similar_user_ratings = self.user_ratings_matrix.loc[similar_user] for book_id, rating in similar_user_ratings.items(): if book_id not in already_rated and book_id not in recommendations: recommendations.append(book_id) if len(recommendations) >= num_recommendations: break if len(recommendations) >= num_recommendations: break return recommendations def evaluate(self, test_ratings): Evaluate the accuracy of the recommendations. Parameters: test_ratings (pd.DataFrame): DataFrame containing user's ratings with columns ['user_id', 'book_id', 'rating'] Returns: float: Mean squared error of the predictions test_ratings_matrix = test_ratings.pivot(index='user_id', columns='book_id', values='rating').fillna(0) mse = 0 total_ratings = 0 for user_id, user_ratings in test_ratings_matrix.iterrows(): predictions = self.recommend(user_id, num_recommendations=len(user_ratings)) actual_ratings = user_ratings[user_ratings > 0] total_ratings += len(actual_ratings) for book_id in predictions: if book_id in actual_ratings: mse += (actual_ratings[book_id] - 5) ** 2 mse /= total_ratings return mse"},{"question":"def reverse_words(sentence: str) -> str: Returns a string with the order of words reversed. Args: sentence: A string representing the input sentence. Returns: A string with the words in reverse order. >>> reverse_words(\\"Hello\\") == \\"Hello\\" >>> reverse_words(\\"Hello World\\") == \\"World Hello\\" >>> reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" >>> reverse_words(\\" Hello World \\") == \\"World Hello\\" >>> reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" >>> reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(sentence): Returns a string with the order of words reversed. Args: sentence: A string representing the input sentence. Returns: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def is_palindrome_permutation(s: str) -> bool: Write a function that takes a string as input and returns True if the string can be rearranged to form a palindrome, and False otherwise. Consider only alphanumeric characters and ignore case differences. Example: >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello World\\") False pass from solution import is_palindrome_permutation def test_palindrome_permutation_true_cases(): assert is_palindrome_permutation(\\"Tact Coa\\") == True assert is_palindrome_permutation(\\"Able was I ere I saw Elba\\") == True assert is_palindrome_permutation(\\"A man a plan a canal Panama\\") == True assert is_palindrome_permutation(\\"No lemon, no melon\\") == True assert is_palindrome_permutation(\\"Racecar\\") == True def test_palindrome_permutation_false_cases(): assert is_palindrome_permutation(\\"Hello World\\") == False assert is_palindrome_permutation(\\"abcde\\") == False assert is_palindrome_permutation(\\"Python\\") == False def test_palindrome_permutation_edge_cases(): assert is_palindrome_permutation(\\"\\") == True # An empty string is considered a palindrome permutation assert is_palindrome_permutation(\\"a\\") == True # Single character is a palindrome permutation assert is_palindrome_permutation(\\"ab\\") == False def test_palindrome_permutation_with_special_characters(): assert is_palindrome_permutation(\\"T@act Coa!\\") == True assert is_palindrome_permutation(\\"!Able*** was I, ere I saw @Elba!\\") == True assert is_palindrome_permutation(\\"No lem-on_ *no melon@\\") == True","solution":"def is_palindrome_permutation(s: str) -> bool: Returns True if the input string can be rearranged to form a palindrome, False otherwise. Considers only alphanumeric characters and ignores case differences. from collections import Counter import re # Remove non-alphanumeric characters and convert to lowercase filtered_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count frequencies of each character char_counts = Counter(filtered_s) # Check the counts to see if a palindrome permutation is possible odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # For a string to be rearranged as a palindrome: # Odd lengths can have at most one character with an odd count # Even lengths can't have any characters with an odd count return odd_count <= 1"},{"question":"def top_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from the given list of integers. >>> top_k_frequent_elements([1, 1, 2, 2, 2, 3, 3, 4], 2) in [[2, 1], [1, 2], [2, 3]] True >>> top_k_frequent_elements([-1, -1, -2, -2, 3, 3, 3, 4, 4, 4, 4], 2) in [[3, 4], [-1, 4]] True >>> top_k_frequent_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) True >>> top_k_frequent_elements([1, -1, -1, 2, 2, -1, 3, 3, 3], 3) in [[-1, 2, 3], [2, -1, 3]] True >>> top_k_frequent_elements([1, 1, 2, 2, 3, 3, 4, 4], 4) in [[1, 2, 3, 4]] True","solution":"from collections import defaultdict import heapq def top_k_frequent_elements(nums, k): Returns the k most frequent elements from the given list of integers. # First, create a frequency dictionary frequency = defaultdict(int) for num in nums: frequency[num] += 1 # Create a max heap based on frequency max_heap = [] for num, freq in frequency.items(): heapq.heappush(max_heap, (-freq, num)) # push (-freq, num) to make a max heap # Extract the top k elements from the max heap top_k_elements = [] for _ in range(k): top_k_elements.append(heapq.heappop(max_heap)[1]) # pop the element with the highest frequency return top_k_elements"},{"question":"def subtract_sums_of_digits(s: str) -> int: Given a string containing only digits, return the result of subtracting the sum of all odd digits from the sum of all even digits. >>> subtract_sums_of_digits(\\"123456\\") == 3 >>> subtract_sums_of_digits(\\"2468\\") == 20 >>> subtract_sums_of_digits(\\"13579\\") == -25 >>> subtract_sums_of_digits(\\"\\") == 0 >>> subtract_sums_of_digits(\\"11223344556677889900\\") == -10","solution":"def subtract_sums_of_digits(s): Given a string containing only digits, return the result of subtracting the sum of all odd digits from the sum of all even digits. if not s: return 0 sum_even = 0 sum_odd = 0 for char in s: digit = int(char) if digit % 2 == 0: sum_even += digit else: sum_odd += digit return sum_even - sum_odd"},{"question":"class EmptyDictError(Exception): Custom exception raised when the input dictionary is empty. def __init__(self, message=\\"The input dictionary is empty. Please provide a dictionary with product names and prices.\\"): self.message = message super().__init__(self.message) def find_max_price(product_prices): Returns the product with the highest price from the product_prices dictionary. Raises an EmptyDictError if the input dictionary is empty. >>> find_max_price({\\"laptop\\": 1200, \\"phone\\": 800, \\"tablet\\": 400}) \\"laptop\\" >>> find_max_price({\\"laptop\\": 1200}) \\"laptop\\" >>> find_max_price({\\"laptop\\": 1200, \\"phone\\": 1200, \\"tablet\\": 400}) \\"laptop\\" >>> find_max_price({}) [Raises EmptyDictError] >>> find_max_price({\\"laptop\\": 0, \\"phone\\": 0, \\"tablet\\": 0}) \\"laptop\\" >>> find_max_price({\\"laptop\\": -500, \\"phone\\": 0, \\"tablet\\": 300}) \\"tablet\\"","solution":"class EmptyDictError(Exception): Custom exception raised when the input dictionary is empty. def __init__(self, message=\\"The input dictionary is empty. Please provide a dictionary with product names and prices.\\"): self.message = message super().__init__(self.message) def find_max_price(product_prices): Returns the product with the highest price from the product_prices dictionary. Raises an EmptyDictError if the input dictionary is empty. if len(product_prices) == 0: raise EmptyDictError() max_price_product = None max_price = -1 for product, price in product_prices.items(): if price > max_price: max_price_product = product max_price = price return max_price_product"},{"question":"from typing import List, Dict class StudentScores: def __init__(self, students: List[Dict[str, int]]): Initialize the StudentScores class with a list of student dictionaries. Args: students (List[Dict[str, int]]): List of dictionaries containing student names and their scores in subjects. self.students = students def calculate_average_scores(self) -> List[Dict[str, float]]: Calculate average scores for each student and return a list of dictionaries containing student names and their average scores. Returns: List[Dict[str, float]]: List of dictionaries with student names and their average scores. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 90, \\"english\\": 78}, ... {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, ... {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 88, \\"english\\": 84} ... ] >>> student_scores = StudentScores(students) >>> student_scores.calculate_average_scores() [{'name': 'Alice', 'average': 84.33}, {'name': 'Bob', 'average': 81.33}, {'name': 'Charlie', 'average': 88.0}] pass def rank_students_by_average(self) -> List[Dict[str, float]]: Rank students by their average scores in descending order. Returns: List[Dict[str, float]]: List of dictionaries with student names and their average scores, ranked by average scores. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 90, \\"english\\": 78}, ... {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, ... {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 88, \\"english\\": 84} ... ] >>> student_scores = StudentScores(students) >>> student_scores.rank_students_by_average() [{'name': 'Charlie', 'average': 88.0}, {'name': 'Alice', 'average': 84.33}, {'name': 'Bob', 'average': 81.33}] pass def test_calculate_average_scores(): students = [ {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 90, \\"english\\": 78}, {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 88, \\"english\\": 84} ] student_scores = StudentScores(students) averages = student_scores.calculate_average_scores() expected_averages = [ {\\"name\\": \\"Alice\\", \\"average\\": 84.33}, {\\"name\\": \\"Bob\\", \\"average\\": 81.33}, {\\"name\\": \\"Charlie\\", \\"average\\": 88.0} ] assert averages == expected_averages def test_rank_students_by_average(): students = [ {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 90, \\"english\\": 78}, {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 88, \\"english\\": 84} ] student_scores = StudentScores(students) ranked_students = student_scores.rank_students_by_average() expected_ranked_students = [ {\\"name\\": \\"Charlie\\", \\"average\\": 88.0}, {\\"name\\": \\"Alice\\", \\"average\\": 84.33}, {\\"name\\": \\"Bob\\", \\"average\\": 81.33} ] assert ranked_students == expected_ranked_students def test_calculate_average_scores_missing_subject(): students = [ {\\"name\\": \\"Alice\\", \\"math\\": 85, \\"science\\": 90}, # Missing 'english' {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 92, \\"science\\": 88} # Missing 'english' ] student_scores = StudentScores(students) averages = student_scores.calculate_average_scores() expected_averages = [ {\\"name\\": \\"Alice\\", \\"average\\": 87.5}, {\\"name\\": \\"Bob\\", \\"average\\": 81.33}, {\\"name\\": \\"Charlie\\", \\"average\\": 90.0} ] assert averages == expected_averages def test_calculate_average_scores_all_missing_subjects(): students = [ {\\"name\\": \\"Alice\\"}, # No scores for any subjects {\\"name\\": \\"Bob\\", \\"math\\": 79, \\"science\\": 80, \\"english\\": 85}, {\\"name\\": \\"Charlie\\"} # No scores for any subjects ] student_scores = StudentScores(students) averages = student_scores.calculate_average_scores() expected_averages = [ {\\"name\\": \\"Alice\\", \\"average\\": 0}, {\\"name\\": \\"Bob\\", \\"average\\": 81.33}, {\\"name\\": \\"Charlie\\", \\"average\\": 0} ] assert averages == expected_averages","solution":"from typing import List, Dict import statistics class StudentScores: def __init__(self, students: List[Dict[str, int]]): self.students = students def calculate_average_scores(self) -> List[Dict[str, float]]: result = [] for student in self.students: name = student.pop(\\"name\\") scores = list(student.values()) average_score = round(statistics.mean(scores), 2) if scores else 0 result.append({\\"name\\": name, \\"average\\": average_score}) return result def rank_students_by_average(self) -> List[Dict[str, float]]: averages = self.calculate_average_scores() ranked_students = sorted(averages, key=lambda x: x[\\"average\\"], reverse=True) return ranked_students"},{"question":"def process_list(integers): Processes a list of integers to produce a specific sequence of outputs. :param integers: List of integers :return: A hyphen-separated string of processed numbers or an error message for non-integer values. >>> process_list([1, 2, 3, 4, 5]) '25-9-1' >>> process_list([-1, -2, -3, -4, -5]) '25-9-1' >>> process_list([1, -2, 3, -4, 5]) '25-9-1' >>> process_list([2, 4, 6, 8]) '' >>> process_list([2, 4, 6, 8, 10]) '' >>> process_list([0, 0, 0]) '' >>> process_list([1, 2, 'a', 4]) 'Error: Input list contains non-integer values' >>> process_list([1.2, 3.5]) 'Error: Input list contains non-integer values' >>> process_list(['1', '2', '3']) 'Error: Input list contains non-integer values'","solution":"def process_list(integers): Processes a list of integers to produce a specific sequence of outputs. :param integers: List of integers :return: A hyphen-separated string of processed numbers or an error message for non-integer values. def is_integer_list(lst): return all(isinstance(i, int) for i in lst) if not is_integer_list(integers): return \\"Error: Input list contains non-integer values\\" # Step 1: Create a new list containing the squares of each integer in the input list. squared_list = [x ** 2 for x in integers] # Step 2: Filter the squared list to retain only the odd numbers. odd_squares = [x for x in squared_list if x % 2 != 0] # Step 3: Sort the filtered list in descending order. odd_squares_sorted = sorted(odd_squares, reverse=True) # Step 4: Convert each element of the sorted list to a string. odd_squares_strings = list(map(str, odd_squares_sorted)) # Step 5: Join all the string elements with a hyphen (\\"-\\") as a separator. result = \\"-\\".join(odd_squares_strings) return result # Time Complexity Analysis: # - Step 1: O(n) where n is the number of elements in the input list (squaring each element). # - Step 2: O(n) for filtering the list to retain odd numbers. # - Step 3: O(n log n) for sorting the list in descending order. # - Step 4: O(n) for mapping each element to a string. # - Step 5: O(n) for joining the string elements with a hyphen. # Overall Time Complexity: O(n log n)"},{"question":"def calculate(s: str) -> int: Evaluates the value of a given mathematical expression. The expression may include the following operators: addition (+), subtraction (-), multiplication (*), and division (/). Parentheses may also be used to alter the precedence of operations. Division between two integers should truncate toward zero. Do not use the 'eval' function in Python or the equivalent function in any other language. :param s: A string containing a mathematical expression. :return: The result of the expression as an integer. Examples: >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\" 3/2 \\") 1 >>> calculate(\\" (1+(4+5+2)-3)+(6+8) \\") 23 pass def test_simple_addition(): assert calculate(\\"3+2\\") == 5 def test_addition_multiplication(): assert calculate(\\"3+2*2\\") == 7 def test_simple_division(): assert calculate(\\"3/2\\") == 1 def test_expression_with_parentheses(): assert calculate(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 def test_complex_expression(): assert calculate(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 def test_expression_with_spaces(): assert calculate(\\" 3/2 \\") == 1 assert calculate(\\" 3 + 5 / 2 \\") == 5 def test_expression_with_multiple_parentheses(): assert calculate(\\"((2+3)*(4-1))/2\\") == 7","solution":"def calculate(s: str) -> int: Evaluates the value of a given mathematical expression. :param s: A string containing a mathematical expression. :return: The result of the expression as an integer. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # truncates toward zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operands = [] operators = [] i = 0 while i < len(s): if s[i] == ' ': i += 1 continue if s[i] in '0123456789': num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 operands.append(num) i -= 1 elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators and operators[-1] != '(': apply_operator(operands, operators.pop()) operators.pop() elif s[i] in '+-*/': while operators and precedence(operators[-1]) >= precedence(s[i]): apply_operator(operands, operators.pop()) operators.append(s[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1]"},{"question":"def rotate_list(nums, k): Rotates the given list of integers 'nums' by 'k' positions to the right. Args: nums (list): A list of integers. k (int): Number of positions to rotate the list. Returns: list: Rotated list. pass def test_rotate_list_positive_k(): assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_list_k_zero(): assert rotate_list([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_list_k_greater_than_len(): assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] def test_rotate_list_empty(): assert rotate_list([], 3) == [] def test_rotate_list_single_element(): assert rotate_list([1], 3) == [1] def test_rotate_list_k_len(): assert rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_list_negative_k(): assert rotate_list([1, 2, 3, 4, 5], -2) == [3, 4, 5, 1, 2]","solution":"def rotate_list(nums, k): Rotates the given list of integers 'nums' by 'k' positions to the right. Args: nums (list): A list of integers. k (int): Number of positions to rotate the list. Returns: list: Rotated list. if not nums: return nums k = k % len(nums) return nums[-k:] + nums[:-k]"},{"question":"def isBipartite(graph: List[List[int]]) -> bool: Determine if the given undirected graph is bipartite. Parameters: graph (List[List[int]]): A list of lists representing the adjacency list of the graph. Returns: bool: True if the graph is bipartite, False otherwise. >>> isBipartite([[1, 3], [0, 2], [1, 3], [0, 2]]) True >>> isBipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]) False >>> isBipartite([[1], [0, 3], [3], [1, 2]]) True from typing import List def test_example1(): graph = [[1, 3], [0, 2], [1, 3], [0, 2]] assert isBipartite(graph) == True def test_example2(): graph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]] assert isBipartite(graph) == False def test_example3(): graph = [[1], [0, 3], [3], [1, 2]] assert isBipartite(graph) == True def test_single_node_graph(): graph = [[]] assert isBipartite(graph) == True def test_disconnected_components(): graph = [[1], [0], [3], [2]] # Two disconnected components assert isBipartite(graph) == True def test_non_bipartite_disconnected_components(): graph = [[1, 2], [0, 2], [0, 1], [4], [3]] # One non-bipartite and one bipartite component assert isBipartite(graph) == False def test_large_bipartite_graph(): graph = [] for i in range(50): graph.append([j for j in range(50, 100)]) for i in range(50, 100): graph.append([j for j in range(50)]) assert isBipartite(graph) == True","solution":"def isBipartite(graph): Determine if the given undirected graph is bipartite. Parameters: graph (List[List[int]]): A list of lists representing the adjacency list of the graph. Returns: bool: True if the graph is bipartite, False otherwise. n = len(graph) color = [-1] * n # -1 means uncolored, 0 and 1 are the two colors def bfs(start): queue = [start] color[start] = 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if color[neighbor] == -1: # if the neighbor is uncolored # color the neighbor with opposite color color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # if the neighbor has the same color return False return True for i in range(n): if color[i] == -1: # if the node is uncolored if not bfs(i): return False return True"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Parameters: sentence (str): A string of words. Returns: str: A new string with the order of the words reversed. Examples: >>> reverse_words(\\"Hello world this is a test\\") == \\"test a is this world Hello\\" >>> reverse_words(\\"Hello\\") == \\"Hello\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" >>> reverse_words(\\"Hello World This Is A Test\\") == \\"Test A Is This World Hello\\" >>> reverse_words(\\"Hello @world #this is a test!\\") == \\"test! a is #this @world Hello\\" >>> reverse_words(12345) Traceback (most recent call last): ... ValueError: Input must be a string","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence. Parameters: sentence (str): A string of words. Returns: str: A new string with the order of the words reversed. if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") words = sentence.split() reversed_sentence = ' '.join(words[::-1]) return reversed_sentence"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Write a function \`common_elements\` that takes two lists of integers as input and returns a sorted list of integers that are present in both lists, without duplicates. Your function should have a time complexity better than O(n^2), where \`n\` is the length of the longer list. >>> common_elements([4, 5, 9, 11, 13, 17, 21], [5, 7, 9, 13, 17, 23, 29]) [5, 9, 13, 17] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 3, 5, 7], [2, 3, 4, 5, 6]) [3, 5] # Your code here","solution":"def common_elements(list1, list2): Returns a sorted list of integers that are present in both input lists, without duplicates. set1 = set(list1) set2 = set(list2) common_set = set1.intersection(set2) return sorted(list(common_set))"},{"question":"def is_rotation(s1: str, s2: str) -> bool: Write a function in Python that takes two strings as input, and returns \`True\` if one string is a rotation of the other, and \`False\` otherwise. A string is considered a rotation of another if they contain the same characters in the same order but start at different positions. For example, \\"hello\\" is a rotation of \\"llohe\\". Ensure your solution is efficient in terms of time complexity. >>> is_rotation(\\"hello\\", \\"llohe\\") True >>> is_rotation(\\"hello\\", \\"world\\") False >>> is_rotation(\\"abcd\\", \\"abcd\\") True >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"abc\\", \\"ab\\") False >>> is_rotation(\\"prefixsuffix\\", \\"suffixprefix\\") True","solution":"def is_rotation(s1, s2): Returns True if s1 is a rotation of s2, otherwise False. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"def filter_even_numbers(int_list): Returns a list containing only the even numbers from the original list. Parameters: int_list (list): A list of integers. Returns: list: A list of even integers. Examples: >>> filter_even_numbers([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_even_numbers([]) [] >>> filter_even_numbers([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) [-10, -8, -6, -4, -2]","solution":"def filter_even_numbers(int_list): Returns a list containing only the even numbers from the original list. Parameters: int_list (list): A list of integers. Returns: list: A list of even integers. return [num for num in int_list if num % 2 == 0]"},{"question":"class DivisionByZeroError(Exception): Custom exception for handling division by zero errors. pass def divide_numbers(dividend, divisor): Divide two numbers and handle division by zero with a custom exception. >>> divide_numbers(10, 2) 5.0 >>> divide_numbers(0, 5) 0.0 >>> divide_numbers(-10, -2) 5.0 >>> divide_numbers(-10, 2) -5.0 >>> divide_numbers(10, 0) Traceback (most recent call last): ... DivisionByZeroError: Cannot divide by zero.","solution":"class DivisionByZeroError(Exception): Custom exception for handling division by zero errors. pass def divide_numbers(dividend, divisor): if divisor == 0: raise DivisionByZeroError(\\"Cannot divide by zero.\\") result = dividend / divisor return result"},{"question":"def generate_fibonacci_sequence(n: int) -> List[int]: Generates and returns a list containing the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: List[int]: A list containing the first n Fibonacci numbers >>> generate_fibonacci_sequence(0) [] >>> generate_fibonacci_sequence(-5) [] >>> generate_fibonacci_sequence(1) [0] >>> generate_fibonacci_sequence(2) [0, 1] >>> generate_fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci_sequence(3) [0, 1, 1] >>> generate_fibonacci_sequence(5) [0, 1, 1, 2, 3] # Include your implementation here","solution":"def generate_fibonacci_sequence(n): Generates and returns a list of the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: list: A list containing the first n Fibonacci numbers # Return an empty list for non-positive n values if n <= 0: return [] # Initialize the first two numbers of the Fibonacci sequence fib_sequence = [0, 1] # Generate the rest of the sequence until we have n numbers for i in range(2, n): next_number = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_number) # Return the first n numbers of the sequence return fib_sequence[:n]"},{"question":"def reverse_string(s: str) -> str: Reverses the given string and handles edge cases such as empty strings and strings containing only whitespaces. >>> reverse_string(\\"hello\\") 'olleh' >>> reverse_string(\\"python\\") 'nohtyp' >>> reverse_string(\\"\\") '' >>> reverse_string(\\" \\") ' '","solution":"def reverse_string(s): Reverses the given string and handles edge cases such as empty strings and strings containing only whitespaces. return s[::-1]"},{"question":"def merge_sort_and_count(arr): Create a function that takes in a list of numbers and sorts it using the Merge Sort algorithm. Additionally, augment the function to count the number of inversions in the list. An inversion is defined as a pair of indices (i, j) such that i < j and list[i] > list[j]. Implement error handling for invalid inputs such as non-numeric elements or a non-list input. >>> merge_sort_and_count([2, 4, 1, 3, 5]) ([1, 2, 3, 4, 5], 3) >>> merge_sort_and_count([1, 2, 3, 4, 5]) ([1, 2, 3, 4, 5], 0) >>> merge_sort_and_count([5, 4, 3, 2, 1]) ([1, 2, 3, 4, 5], 10) >>> merge_sort_and_count([42]) ([42], 0) >>> merge_sort_and_count([]) ([], 0) >>> merge_sort_and_count(\\"not a list\\") Traceback (most recent call last): ... TypeError: Input must be a list >>> merge_sort_and_count([1, \\"two\\", 3]) Traceback (most recent call last): ... ValueError: All elements in the list must be numbers","solution":"def merge_sort_and_count(arr): def merge_and_count(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") if not all(isinstance(x, (int, float)) for x in arr): raise ValueError(\\"All elements in the list must be numbers\\") temp_arr = [0]*len(arr) inv_count = merge_sort(arr, temp_arr, 0, len(arr)-1) return arr, inv_count"},{"question":"def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B and returns the result matrix C. Assumes the number of columns in A is equal to the number of rows in B. >>> matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2, 3]], [[4], [5], [6]]) [[32]] >>> matrix_multiply([[2]], [[3]]) [[6]] >>> matrix_multiply([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) [[30, 24, 18], [84, 69, 54], [138, 114, 90]]","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B and returns the result matrix C. Assumes the number of columns in A is equal to the number of rows in B. m = len(A) n = len(A[0]) p = len(B[0]) # Initialize result matrix C with zeros C = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"def findClosestPair(arr: List[int], target: int) -> List[int]: Find two integers in the list whose sum is closest to the target. Parameters: arr (List[int]): List of unsorted integers target (int): Target integer sum Returns: List[int]: Pair of integers with sum closest to target Examples: >>> findClosestPair([1, 60, -10, 70, -80, 85], 50) [60, -10] # or [-10, 60] >>> findClosestPair([10, 22, 28, 29, 30, 40], 54) [22, 30] # or [30, 22] >>> findClosestPair([6, 8], 5) [6, 8] # or [8, 6]","solution":"def findClosestPair(arr, target): arr.sort() left = 0 right = len(arr) - 1 closest_pair = [arr[left], arr[right]] closest_diff = abs(arr[left] + arr[right] - target) while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [arr[left], arr[right]] if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"def rotate_matrix(matrix): Rotates a given 2D list (matrix) by 90 degrees clockwise and returns the rotated matrix. The original matrix is not modified. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[4, 1], [5, 2], [6, 3]] >>> rotate_matrix([ ... [1] ... ]) [[1]] >>> rotate_matrix([]) [] >>> rotate_matrix([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> rotate_matrix([ ... [1], ... [2], ... [3] ... ]) [[3, 2, 1]]","solution":"def rotate_matrix(matrix): Rotates a given 2D list (matrix) by 90 degrees clockwise and returns the rotated matrix. The original matrix is not modified. if not matrix: return [] num_rows, num_cols = len(matrix), len(matrix[0]) rotated_matrix = [] for col in range(num_cols): new_row = [matrix[row][col] for row in reversed(range(num_rows))] rotated_matrix.append(new_row) return rotated_matrix"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Returns True if there is a cycle in the linked list, otherwise False. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> has_cycle(node1) True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> has_cycle(node1) False >>> node1 = ListNode(1) >>> node1.next = node1 >>> has_cycle(node1) True >>> has_cycle(None) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Returns True if there is a cycle in the linked list, otherwise False. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def merge_sorted_arrays(array1, array2): Merge two sorted arrays into a single sorted array. :param array1: List[int] - First sorted array. :param array2: List[int] - Second sorted array. :return: List[int] - Merged and sorted array. >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([1, 1000, 10000], [2, 2000, 20000]) [1, 2, 1000, 2000, 10000, 20000]","solution":"def merge_sorted_arrays(array1, array2): Merge two sorted arrays into a single sorted array. :param array1: List[int] - First sorted array. :param array2: List[int] - Second sorted array. :return: List[int] - Merged and sorted array. merged_array = [] i, j = 0, 0 # Traverse through both arrays while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 # Collect remaining elements of array1 while i < len(array1): merged_array.append(array1[i]) i += 1 # Collect remaining elements of array2 while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"def fibonacci_series(n): Write a Python function called \`fibonacci_series(n)\` that takes in an integer \`n\` and returns a list of the first \`n\` numbers in the Fibonacci sequence, starting from 0. For example, \`fibonacci_series(5)\` should return \`[0, 1, 1, 2, 3]\`. Ensure that your function handles the case where \`n\` is 0 or a negative integer by returning an empty list. Include validation to check if the input is a non-negative integer. >>> fibonacci_series(1) [0] >>> fibonacci_series(2) [0, 1] >>> fibonacci_series(3) [0, 1, 1] >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(0) [] >>> fibonacci_series(-1) []","solution":"def fibonacci_series(n): Returns a list containing the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate. If n is 0 or a negative integer, returns an empty list. Returns: list: A list of the first n numbers in the Fibonacci sequence. if not isinstance(n, int) or n <= 0: return [] fibonacci = [0, 1] for _ in range(2, n): fibonacci.append(fibonacci[-1] + fibonacci[-2]) return fibonacci[:n]"},{"question":"from typing import List def intersect(nums1: List[int], nums2: List[int]) -> List[int]: Computes the intersection of two arrays, returning a new array containing only the elements that are present in both input arrays. Each element should appear in the result as many times as it shows in both arrays. >>> intersect([1, 2, 2, 1], [2, 2]) [2, 2] >>> intersect([1, 2, 3], [4, 5, 6]) [] >>> intersect([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> intersect([1, 2, 3], []) [] >>> intersect([], [4, 5, 6]) [] >>> intersect([1, 2, 2, 3], [1, 2, 2, 3]) [1, 2, 2, 3] >>> intersect([1], [1]) [1] >>> intersect([1], [2]) [] >>> intersect([1, 2, 3], [2, 2]) [2]","solution":"from collections import Counter def intersect(nums1, nums2): Computes the intersection of two arrays, returning a new array containing only the elements that are present in both input arrays. Each element should appear in the result as many times as it shows in both arrays. counter1 = Counter(nums1) counter2 = Counter(nums2) intersection = [] for num in counter1: if num in counter2: min_count = min(counter1[num], counter2[num]) intersection.extend([num] * min_count) return intersection"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 pass # Unit tests def test_roman_to_integer_simple(): assert roman_to_integer(\\"III\\") == 3 assert roman_to_integer(\\"IV\\") == 4 assert roman_to_integer(\\"IX\\") == 9 def test_roman_to_integer_composite(): assert roman_to_integer(\\"LVIII\\") == 58 assert roman_to_integer(\\"MCMXCIV\\") == 1994 assert roman_to_integer(\\"MMMCMXCIX\\") == 3999 def test_roman_to_integer_edge_cases(): assert roman_to_integer(\\"I\\") == 1 assert roman_to_integer(\\"MMM\\") == 3000 assert roman_to_integer(\\"CXL\\") == 140 def test_roman_to_integer_subtractive_notation(): assert roman_to_integer(\\"XL\\") == 40 assert roman_to_integer(\\"XC\\") == 90 assert roman_to_integer(\\"CD\\") == 400 assert roman_to_integer(\\"CM\\") == 900","solution":"def roman_to_integer(s): Convert a Roman numeral to an integer. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def find_max_average_sum(arr: List[int], k: int) -> float: Finds the maximum average sum of k consecutive elements in the array. Parameters: - arr: List[int], the input array of integers. - k: int, number of consecutive elements to consider for the average. Returns: - The maximum average sum of k consecutive elements in the array, or -1 if the array has fewer than k elements. Examples: >>> find_max_average_sum([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average_sum([5, 5, 5, 5, 5], 2) 5.0 >>> find_max_average_sum([1, 2, 3], 4) -1 >>> find_max_average_sum([-1, -2, -3, -4, -5], 3) -2.0 pass","solution":"def find_max_average_sum(arr, k): Finds the maximum average sum of k consecutive elements in the array. Parameters: - arr: List[int], the input array of integers. - k: int, number of consecutive elements to consider for the average. Returns: - The maximum average sum of k consecutive elements in the array, or -1 if the array has fewer than k elements. n = len(arr) if n < k: return -1 # Calculate the sum of first 'k' elements current_sum = sum(arr[:k]) max_sum = current_sum # Use sliding window technique to find the max sum of 'k' consecutive elements for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum / k"},{"question":"def longest_word_length(word_list): Determine the length of the longest word in the list. Case insensitive. If the list is empty, return 0. >>> longest_word_length([\\"Hello\\", \\"world\\", \\"Python\\", \\"is\\", \\"awesome\\"]) == 7 >>> longest_word_length([]) == 0 >>> longest_word_length([\\"Python\\"]) == 6 >>> longest_word_length([\\"PYTHON\\", \\"python\\", \\"PyThOn\\"]) == 6 >>> longest_word_length([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) == 5","solution":"def longest_word_length(word_list): Returns the length of the longest word in the list. Case insensitive. If the list is empty, returns 0. if not word_list: return 0 return max(len(word) for word in word_list)"},{"question":"def is_valid_sudoku(board: list) -> bool: Check if the given Sudoku board is valid >>> is_valid_sudoku([ [5,3,0,0,7,0,0,0,0], [6,0,0,1,9,5,0,0,0], [0,9,8,0,0,0,0,6,0], [8,0,0,0,6,0,0,0,3], [4,0,0,8,0,3,0,0,1], [7,0,0,0,2,0,0,0,6], [0,6,0,0,0,0,2,8,0], [0,0,0,4,1,9,0,0,5], [0,0,0,0,8,0,0,7,9] ]) # should return True >>> is_valid_sudoku([ [5,5,0,0,7,0,0,0,0], [6,0,0,1,9,5,0,0,0], [0,9,8,0,0,0,0,6,0], [8,0,0,0,6,0,0,0,3], [4,0,0,8,0,3,0,0,1], [7,0,0,0,2,0,0,0,6], [0,6,0,0,0,0,2,8,0], [0,0,0,4,1,9,0,0,5], [0,0,0,0,8,0,0,7,9] ]) # should return False pass def solve_sudoku(board: list) -> list: Solve the given Sudoku puzzle or return \\"Unsolvable\\" >>> solve_sudoku([ [5,3,0,0,7,0,0,0,0], [6,0,0,1,9,5,0,0,0], [0,9,8,0,0,0,0,6,0], [8,0,0,0,6,0,0,0,3], [4,0,0,8,0,3,0,0,1], [7,0,0,0,2,0,0,0,6], [0,6,0,0,0,0,2,8,0], [0,0,0,4,1,9,0,0,5], [0,0,0,0,8,0,0,7,9] ]) # should return the solved Sudoku board: [ [5,3,4,6,7,8,9,1,2], [6,7,2,1,9,5,3,4,8], [1,9,8,3,4,2,5,6,7], [8,5,9,7,6,1,4,2,3], [4,2,6,8,5,3,7,9,1], [7,1,3,9,2,4,8,5,6], [9,6,1,5,3,7,2,8,4], [2,8,7,4,1,9,6,3,5], [3,4,5,2,8,6,1,7,9] ], >>> solve_sudoku([ [5,3,0,0,7,0,0,0,0], [6,0,0,1,9,5,0,0,0], [0,9,8,0,0,0,0,6,0], [8,0,0,0,6,0,0,0,3], [4,0,0,8,0,3,0,0,1], [7,0,5,0,2,0,6,0,0], [0,6,0,0,0,0,2,8,0], [0,0,0,4,1,9,0,0,5], [0,0,0,0,8,0,0,7,9] ]) # should return \\"Unsolvable\\" pass","solution":"def is_valid_sudoku(board: list) -> bool: Check if the given Sudoku board is valid def is_valid_unit(unit): Helper function to check if a unit (row/column/grid) is valid non_zeros = [i for i in unit if i != 0] return len(non_zeros) == len(set(non_zeros)) def get_subgrid(board, start_row, start_col): Helper function to get the subgrid starting at (start_row, start_col) subgrid = [] for r in range(3): for c in range(3): subgrid.append(board[start_row + r][start_col + c]) return subgrid # Check rows and columns for i in range(9): if not is_valid_unit(board[i]) or not is_valid_unit([board[r][i] for r in range(9)]): return False # Check 3x3 subgrids for r in range(0, 9, 3): for c in range(0, 9, 3): if not is_valid_unit(get_subgrid(board, r, c)): return False return True def solve_sudoku(board: list) -> list: Solve the given Sudoku puzzle or return 'Unsolvable' def find_empty_location(board): Helper function to find an empty location on the board for r in range(9): for c in range(9): if board[r][c] == 0: return r, c return None def is_safe(board, row, col, num): Helper function to check if num can be placed at board[row][col] for r in range(9): if board[r][col] == num: return False for c in range(9): if board[row][c] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(3): for c in range(3): if board[start_row + r][start_col + c] == num: return False return True def solve(): Helper function to solve the Sudoku puzzle empty_location = find_empty_location(board) if not empty_location: return True row, col = empty_location for num in range(1, 10): if is_safe(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = 0 return False if solve(): return board else: return \\"Unsolvable\\""},{"question":"def missing_number(nums: List[int]) -> int: Implement a function called \`missing_number\` that takes a list of integers containing numbers from 1 to n (inclusive) with exactly one missing number. The function should identify and return the missing integer. The list is guaranteed to have no duplicates, and the numbers are not sorted. >>> missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> missing_number([2]) 1 >>> missing_number([3, 4, 1, 2]) 5 >>> missing_number([2, 3, 4, 5, 6]) 1 Args: nums (List[int]): A list of integers Returns: int: The missing integer","solution":"def missing_number(nums): Returns the missing number from 1 to n in the given list. Arguments: nums -- a list of integers containing numbers from 1 to n with one missing number. Returns: The missing integer. n = len(nums) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"from typing import List def findAllSubsets(nums: List[int]) -> List[List[int]]: Write a function called \`findAllSubsets\` that takes a list of unique integers and returns all possible subsets of these integers. The subsets can be returned in any order, but each subset must be unique and the function should not include duplicate sets. >>> findAllSubsets([]) == [[]] >>> findAllSubsets([1]) == [[], [1]] >>> findAllSubsets([1, 2]) == [[], [1], [2], [1, 2]] >>> findAllSubsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> findAllSubsets([1, 2, 3, 4]) == [ ... [], [1], [2], [3], [4], ... [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], ... [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4] ... ] def test_findAllSubsets_empty_list(): assert findAllSubsets([]) == [[]] def test_findAllSubsets_single_element(): assert findAllSubsets([1]) == [[], [1]] def test_findAllSubsets_two_elements(): result = findAllSubsets([1, 2]) expected = [[], [1], [2], [1, 2]] assert sorted(result) == sorted(expected) def test_findAllSubsets_three_elements(): result = findAllSubsets([1, 2, 3]) expected = [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert sorted(result) == sorted(expected) def test_findAllSubsets_four_elements(): result = findAllSubsets([1, 2, 3, 4]) expected = [ [], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4] ] assert sorted(result) == sorted(expected)","solution":"from typing import List def findAllSubsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): subsets.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() subsets = [] backtrack(0, []) return subsets"},{"question":"def validate_email(name: str, email: str) -> bool: Validates the email based on the given criteria. Parameters: name (str): The name to be checked. email (str): The email to be validated. Returns: bool: True if the email is valid, False otherwise. >>> validate_email(\\"JohnDoe\\", \\"johndoe@example.com\\") True >>> validate_email(\\"John\\", \\"john@domaincom\\") False >>> validate_email(\\"John\\", \\"johndomain.com\\") False >>> validate_email(\\"John\\", \\"john@domaincom\\") False >>> validate_email(\\"John\\", \\"john.domain@com\\") False >>> validate_email(\\"Johnny\\", \\"john@example.com\\") False >>> validate_email(\\"John\\", \\"@john.com\\") False >>> validate_email(\\"John\\", \\"john@com.\\") False >>> validate_email(\\"JoHnDoE\\", \\"JohnDoe@example.com\\") True","solution":"def validate_email(name, email): Validates the email based on the given criteria. Parameters: name (str): The name to be checked. email (str): The email to be validated. Returns: bool: True if the email is valid, False otherwise. name = name.lower() email = email.lower() if '@' not in email or '.' not in email: return False at_index = email.index('@') dot_index = email.index('.') if at_index == 0 or dot_index == len(email) - 1: return False if at_index > dot_index: return False local_part = email.split('@')[0] if local_part != name: return False return True"},{"question":"def merge_sorted_arrays(arr1: list, arr2: list) -> list: Given two sorted arrays, merge them into a single sorted array. :param arr1: List of sorted numbers (integers and floats). :param arr2: List of sorted numbers (integers and floats). :return: A single sorted array containing all elements from arr1 and arr2. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0.1, 2.5, 3.3], [1.2, 2.2, 4.5]) [0.1, 1.2, 2.2, 2.5, 3.3, 4.5] >>> merge_sorted_arrays([-1, 0, 1], [-2, 2, 3]) [-2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([1, 3, 3], [3, 3, 5]) [1, 3, 3, 3, 3, 5]","solution":"def merge_sorted_arrays(arr1: list, arr2: list) -> list: Given two sorted arrays, merge them into a single sorted array. :param arr1: List of sorted numbers (integers and floats). :param arr2: List of sorted numbers (integers and floats). :return: A single sorted array containing all elements from arr1 and arr2. result = [] i, j = 0, 0 # Compare and merge arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: result.append(arr1[i]) i += 1 else: result.append(arr2[j]) j += 1 # Append remaining elements of arr1 while i < len(arr1): result.append(arr1[i]) i += 1 # Append remaining elements of arr2 while j < len(arr2): result.append(arr2[j]) j += 1 return result"},{"question":"from typing import List def minCut(s: str) -> int: Given a string \`s\`, partition \`s\` such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of \`s\`. >>> minCut(\\"aab\\") 1 >>> minCut(\\"a\\") 0 >>> minCut(\\"ab\\") 1","solution":"def minCut(s): Returns the minimum cuts needed for a palindrome partitioning of s. n = len(s) if n < 2: return 0 # Create a 2D table to store whether a substring is palindrome or not is_palindrome = [[False]*n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True # Each single character is a palindrome for length in range(2, n+1): # Check all substrings of length 2 to n for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: if length == 2: # Substring of two characters is_palindrome[i][j] = True else: is_palindrome[i][j] = is_palindrome[i+1][j-1] cuts = [float('inf')] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 # No need to cut if whole substring is a palindrome else: for j in range(i): if is_palindrome[j+1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"import re from typing import List def extract_unique_words(paragraph: str) -> List[str]: Extract a list of unique words from a given paragraph, ignoring case and punctuation. :param paragraph: A string containing a paragraph. :return: A list of unique words. >>> extract_unique_words(\\"Hello world! Hello Earth.\\") ['earth', 'hello', 'world'] >>> extract_unique_words(\\"Cats, cats, and more cats.\\") ['and', 'cats', 'more'] >>> extract_unique_words(\\"The quick brown Fox jumps over the lazy Dog.\\") ['brown', 'dog', 'fox', 'jumps', 'lazy', 'over', 'quick', 'the'] >>> extract_unique_words(\\"Numbers: 123 123 456.\\") ['123', '456', 'numbers'] >>> extract_unique_words(\\"\\") []","solution":"import re def extract_unique_words(paragraph): Extracts a list of unique words from the given paragraph, ignoring case and punctuation. :param paragraph: A string containing a paragraph. :return: A list of unique words. # Remove punctuation and convert to lower case words = re.findall(r'bw+b', paragraph.lower()) unique_words = list(set(words)) # Convert to set to get unique words, then back to list unique_words.sort() # Sort the list of unique words return unique_words"},{"question":"import numpy as np def get_matrix_inverse(matrix_dict): Takes a dictionary representing a mathematical matrix and returns the inverse. Returns None if the matrix is not invertible. :param matrix_dict: dict where keys are (row, column) tuples and values are the matrix entries :return: dict representing the inverse matrix or None if not invertible","solution":"import numpy as np def get_matrix_inverse(matrix_dict): Takes a dictionary representing a mathematical matrix and returns the inverse. Returns None if the matrix is not invertible. :param matrix_dict: dict where keys are (row, column) tuples and values are the matrix entries :return: dict representing the inverse matrix or None if not invertible # Determine the size of the matrix keys = matrix_dict.keys() rows = max(key[0] for key in keys) + 1 cols = max(key[1] for key in keys) + 1 if rows != cols: return None # Not a square matrix, hence not invertible # Create a numpy array from the dictionary matrix = np.zeros((rows, cols)) for (i, j), value in matrix_dict.items(): matrix[i, j] = value try: # Compute the inverse using numpy matrix_inv = np.linalg.inv(matrix) except np.linalg.LinAlgError: return None # Matrix is not invertible # Convert the result back to a dictionary inverse_dict = {(i, j): matrix_inv[i, j] for i in range(rows) for j in range(cols)} return inverse_dict"},{"question":"def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals in a given list of intervals. Each interval is represented as a tuple of two integers where the first integer is the start time and the second is the end time. The function should return a list of merged intervals, ensuring no two intervals overlap. Args: intervals (List[Tuple[int, int]]): A list of intervals represented as tuples. Returns: List[Tuple[int, int]]: A list of merged intervals, sorted by start times. >>> merge_intervals([(1, 5), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(8, 10), (1, 5), (15, 18), (2, 6)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 3), (2, 4)]) [(1, 4)] >>> merge_intervals([(1, 2), (2, 3)]) [(1, 3)]","solution":"def merge_intervals(intervals): Merges overlapping intervals in a list of intervals. Args: intervals (List[Tuple[int, int]]): A list of intervals represented as tuples. Returns: List[Tuple[int, int]]: A list of merged intervals, sorted by start times. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if last[1] >= current[0]: # Merge if there's an overlap or touching intervals merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged"},{"question":"def total_transmission_delay(B: int, packets: List[int]) -> float: Calculate the total transmission delay for multiple packets. Parameters: B (int): Bandwidth in bits per second packets (list): List of packet sizes in bits Returns: float: Total transmission delay in seconds, rounded to six decimal places >>> total_transmission_delay(1000000, [1000, 2000, 3000, 1500, 2500]) == 0.010000 >>> total_transmission_delay(1000000, [1000000]) == 1.000000 >>> total_transmission_delay(500000, [1000, 1000, 1000]) == 0.006000 >>> total_transmission_delay(10**9, [1000, 2000, 1000]) == 0.000004 >>> total_transmission_delay(1000000, []) == 0.000000","solution":"def total_transmission_delay(B, packets): Calculate the total transmission delay for multiple packets. Parameters: B (int): Bandwidth in bits per second packets (list): List of packet sizes in bits Returns: float: Total transmission delay in seconds, rounded to six decimal places total_delay = sum(p / B for p in packets) return round(total_delay, 6)"},{"question":"def sort_and_deduplicate(s: str) -> str: Sort the provided string of lowercase characters alphabetically and remove any duplicate characters. Parameters: s (str): Input string composed of lowercase characters. Returns: str: The resultant string with characters sorted and duplicates removed. >>> sort_and_deduplicate(\\"programming\\") 'agimnopr' >>> sort_and_deduplicate(\\"\\") '' >>> sort_and_deduplicate(\\"a\\") 'a' >>> sort_and_deduplicate(\\"aaabbc\\") 'abc' >>> sort_and_deduplicate(\\"abcdef\\") 'abcdef' >>> sort_and_deduplicate(\\"zyxwvut\\") 'tuvwxyz' pass # Implement the function here. from solution import sort_and_deduplicate def test_sort_and_deduplicate_typical_case(): assert sort_and_deduplicate(\\"programming\\") == \\"agimnopr\\" def test_sort_and_deduplicate_empty_string(): assert sort_and_deduplicate(\\"\\") == \\"\\" def test_sort_and_deduplicate_single_character(): assert sort_and_deduplicate(\\"a\\") == \\"a\\" assert sort_and_deduplicate(\\"z\\") == \\"z\\" def test_sort_and_deduplicate_duplicate_characters(): assert sort_and_deduplicate(\\"aaabbc\\") == \\"abc\\" def test_sort_and_deduplicate_already_sorted(): assert sort_and_deduplicate(\\"abcdef\\") == \\"abcdef\\" def test_sort_and_deduplicate_reverse_order(): assert sort_and_deduplicate(\\"zyxwvut\\") == \\"tuvwxyz\\" def test_sort_and_deduplicate_all_duplicate_characters(): assert sort_and_deduplicate(\\"aaa\\") == \\"a\\" assert sort_and_deduplicate(\\"bbbb\\") == \\"b\\" def test_sort_and_deduplicate_mixed_characters(): assert sort_and_deduplicate(\\"acebdf\\") == \\"abcdef\\" def test_sort_and_deduplicate_long_string(): long_string = \\"thequickbrownfoxjumpsoverthelazydog\\" * 10 assert sort_and_deduplicate(long_string) == \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def sort_and_deduplicate(s): Sorts the provided string alphabetically and removes duplicate characters. Parameters: s (str): The input string. Returns: str: A string with characters sorted and duplicates removed. return ''.join(sorted(set(s))) # Time Complexity Analysis: # set(s): O(n), where n is the length of the string, as we need to iterate through each character. # sorted(set(s)): O(k log k), where k is the number of unique characters in the string. # join(sorted(set(s))): O(k), because join() needs to pass through each character in the sorted list. # Overall time complexity: O(n + k log k), which simplifies to O(n log n) in the worst case scenario where all characters are unique."},{"question":"def employees_by_department(employees): Takes a list of employee dictionaries and returns a dictionary where keys are department names and values are lists of employee names sorted in descending order by their years of experience. >>> employees_by_department([{'name': 'Alice', 'department': 'Engineering', 'salary': 100000, 'years_of_experience': 5}]) == {'Engineering': ['Alice']} >>> employees_by_department([]) == {} >>> employees_by_department([{'name': 'Alice', 'department': 'Engineering', 'salary': 100000, 'years_of_experience': 5}, {'name': 'Bob', 'department': 'Engineering', 'salary': 90000, 'years_of_experience': 8}, {'name': 'Charlie', 'department': 'Engineering', 'salary': 110000, 'years_of_experience': 3}]) == {'Engineering': ['Bob', 'Alice', 'Charlie']} >>> employees_by_department([{'name': 'Alice', 'department': 'Engineering', 'salary': 100000, 'years_of_experience': 5}, {'name': 'Bob', 'department': 'Engineering', 'salary': 90000, 'years_of_experience': 8}, {'name': 'Diana', 'department': 'HR', 'salary': 60000, 'years_of_experience': 6}, {'name': 'Charlie', 'department': 'Engineering', 'salary': 110000, 'years_of_experience': 3}, {'name': 'Eve', 'department': 'HR', 'salary': 70000, 'years_of_experience': 4}]) == {'Engineering': ['Bob', 'Alice', 'Charlie'], 'HR': ['Diana', 'Eve']} >>> employees_by_department([{'name': 'Alice', 'department': 'Engineering', 'salary': 100000, 'years_of_experience': 0}, {'name': 'Bob', 'department': 'Engineering', 'salary': 90000, 'years_of_experience': 8}]) == {'Engineering': ['Bob', 'Alice']}","solution":"def employees_by_department(employees): Takes a list of employee dictionaries and returns a dictionary where keys are department names and values are lists of employee names sorted in descending order by their years of experience. if not employees: return {} dept_dict = {} for emp in employees: department = emp.get('department') name = emp.get('name') years_exp = emp.get('years_of_experience') if department not in dept_dict: dept_dict[department] = [] dept_dict[department].append((name, years_exp)) for dept in dept_dict: dept_dict[dept].sort(key=lambda x: x[1], reverse=True) dept_dict[dept] = [name for name, _ in dept_dict[dept]] return dept_dict"},{"question":"def factorial_sum(m: int, n: int) -> int: Calculate the sum of factorials of each integer between m and n (inclusive). >>> factorial_sum(1, 4) 33 >>> factorial_sum(0, 3) 10 >>> factorial_sum(3, 3) 6 >>> factorial_sum(4, 6) 864 >>> factorial_sum(0, 0) 1","solution":"def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def factorial_sum(m, n): total = 0 for i in range(m, n + 1): total += factorial(i) return total"},{"question":"def count_odd_numbers(numbers: List[int]) -> int: Returns the count of odd numbers in the given list. >>> count_odd_numbers([12, 17, 19, 24, 45, 67, 78]) == 4 >>> count_odd_numbers([2, 4, 6, 8, 10]) == 0 >>> count_odd_numbers([1, 3, 5, 7, 9]) == 5 >>> count_odd_numbers([]) == 0 >>> count_odd_numbers([1]) == 1 >>> count_odd_numbers([2]) == 0","solution":"def count_odd_numbers(numbers): Returns the count of odd numbers in the given list. :param numbers: A list of integers :return: The count of odd numbers in the list return sum(1 for number in numbers if number % 2 != 0)"},{"question":"def is_prime(num): Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def is_palindrome(num): Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False pass def prime_palindromes(N): Generate a list of prime palindromes up to N. >>> prime_palindromes(10) [2, 3, 5, 7] >>> prime_palindromes(100) [2, 3, 5, 7, 11] pass","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def is_palindrome(num): Check if a number is a palindrome. return str(num) == str(num)[::-1] def prime_palindromes(N): Generate a list of prime palindromes up to N. result = [] for i in range(2, N + 1): if is_prime(i) and is_palindrome(i): result.append(i) return result"},{"question":"import re from collections import Counter def count_words(text: str) -> dict: Returns a dictionary where the keys are the unique words in the string \`text\` and the values are the counts of each word. The function ignores case and punctuation. >>> count_words(\\"Hello, world! Hello Python programmers.\\") {'hello': 2, 'world': 1, 'python': 1, 'programmers': 1} >>> count_words(\\"Python PYTHON python\\") {'python': 3} >>> count_words(\\"This, is a test. This is only a test!\\") {'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1} >>> count_words(\\"\\") {} >>> count_words(\\"Word\\") {'word': 1}","solution":"import re from collections import Counter def count_words(text): Returns a dictionary where the keys are the unique words in the string \`text\` and the values are the counts of each word. The function ignores case and punctuation. # Convert the text to lowercase text = text.lower() # Remove punctuation using regular expressions text = re.sub(r'[^ws]', '', text) # Split the text into words words = text.split() # Count the words using Counter from collections word_count = Counter(words) return dict(word_count) # Demonstrating with the provided input example_text = \\"Hello, world! Hello Python programmers.\\" print(count_words(example_text)) # Output should be {'hello': 2, 'world': 1, 'python': 1, 'programmers': 1}"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sorted_linked_lists(l1, l2): Merges two sorted linked lists into one sorted linked list. >>> l1 = Node(1, Node(3, Node(5))) >>> l2 = Node(2, Node(4, Node(6))) >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> linked_list_to_list(merged_list) [1, 2, 3, 4, 5, 6] >>> l1 = None >>> l2 = None >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> linked_list_to_list(merged_list) [] >>> l1 = Node(1, Node(3, Node(5))) >>> l2 = None >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> linked_list_to_list(merged_list) [1, 3, 5] >>> l1 = Node(2) >>> l2 = Node(1) >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> linked_list_to_list(merged_list) [1, 2] >>> l1 = Node(1, Node(4, Node(7))) >>> l2 = Node(2, Node(3, Node(6))) >>> merged_list = merge_sorted_linked_lists(l1, l2) >>> linked_list_to_list(merged_list) [1, 2, 3, 4, 6, 7] # Utility function to convert linked list to list (for easier testing) def linked_list_to_list(node): result = [] while node: result.append(node.value) node = node.next return result","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sorted_linked_lists(l1, l2): dummy = Node() current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 elif l2: current.next = l2 return dummy.next # Utility function to convert linked list to list (for easier testing) def linked_list_to_list(node): result = [] while node: result.append(node.value) node = node.next return result"},{"question":"def filter_by_threshold(nums: List[int], threshold: int) -> List[int]: Filters the list such that all remaining integers are greater than or equal to the threshold. If it is not possible, returns an empty list. Parameters: nums (list of int): The list of integers to filter. threshold (int): The threshold value. Returns: list of int: A list containing elements greater than or equal to the threshold. >>> filter_by_threshold([1, 3, 5, 7, 9], 4) [5, 7, 9] >>> filter_by_threshold([1, 2, 2, 1], 3) []","solution":"def filter_by_threshold(nums, threshold): Filters the list such that all remaining integers are greater than or equal to the threshold. If it is not possible, returns an empty list. Parameters: nums (list of int): The list of integers to filter. threshold (int): The threshold value. Returns: list of int: A list containing elements greater than or equal to the threshold. # Filter out the values less than the threshold result = [num for num in nums if num >= threshold] # Check if the result is non-empty if result: return result else: return []"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all the numbers in the original list except the one at that index. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, -1, 1, -1]) == [1, -1, 1, -1] >>> product_except_self([10, 3]) == [3, 10] >>> product_except_self([5]) == [1] >>> product_except_self([]) == [] >>> product_except_self([0, 0, 0]) == [0, 0, 0] >>> product_except_self([1, 0, 0, 4]) == [0, 0, 0, 0] >>> product_except_self([0, 2, 3, 0]) == [0, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([-1, -1, -1, -1]) == [-1, -1, -1, -1] >>> product_except_self([1, -2, 3, -4]) == [24, -12, 8, -6]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the numbers in the original list except the one at that index. n = len(nums) if n == 0: return [] # Initialize two lists to keep track of the left and right products left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate the products of all the integers to the left of each index for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate the products of all the integers to the right of each index for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Generate the result by multiplying left and right products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from fastapi import FastAPI, HTTPException from pydantic import BaseModel from typing import List, Optional app = FastAPI() class Book(BaseModel): title: str author: str ISBN: str genre: str publication_date: str class UpdateBook(BaseModel): title: Optional[str] = None author: Optional[str] = None genre: Optional[str] = None publication_date: Optional[str] = None books_db = {} @app.post(\\"/books/\\", response_model=Book) def add_book(book: Book): Add a new book to the catalog. Args: book (Book): A book object with title, author, ISBN, genre, and publication date. Returns: Book: The added book object. @app.get(\\"/books/{isbn}\\", response_model=Book) def get_book(isbn: str): Retrieve details of a specific book by its ISBN. Args: isbn (str): The ISBN of the book. Returns: Book: The book object if found. @app.put(\\"/books/{isbn}\\", response_model=Book) def update_book(isbn: str, book_update: UpdateBook): Update details of an existing book. Args: isbn (str): The ISBN of the book. book_update (UpdateBook): A book update object with optional fields to update. Returns: Book: The updated book object. @app.delete(\\"/books/{isbn}\\", response_model=dict) def delete_book(isbn: str): Delete a book from the catalog by its ISBN. Args: isbn (str): The ISBN of the book. Returns: dict: A confirmation message after deletion. @app.get(\\"/books/\\", response_model=List[Book]) def list_books(genre: Optional[str] = None, author: Optional[str] = None): List all books in the catalog, with optional filtering by genre and/or author. Args: genre (Optional[str], optional): Filter by genre. Defaults to None. author (Optional[str], optional): Filter by author. Defaults to None. Returns: List[Book]: A list of book objects. from fastapi.testclient import TestClient from solution import app, books_db client = TestClient(app) def test_add_book(): response = client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" }) assert response.status_code == 200 assert response.json() == { \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" } books_db.clear() def test_get_book(): client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" }) response = client.get(\\"/books/1234567890\\") assert response.status_code == 200 assert response.json() == { \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" } books_db.clear() def test_update_book(): client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" }) response = client.put(\\"/books/1234567890\\", json={ \\"title\\": \\"Updated Title\\" }) assert response.status_code == 200 assert response.json()[\\"title\\"] == \\"Updated Title\\" books_db.clear() def test_delete_book(): client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Test Genre\\", \\"publication_date\\": \\"2023-01-01\\" }) response = client.delete(\\"/books/1234567890\\") assert response.status_code == 200 assert response.json() == {\\"detail\\": \\"Book deleted successfully.\\"} books_db.clear() def test_list_books_by_genre(): client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Fiction\\", \\"publication_date\\": \\"2023-01-01\\" }) client.post(\\"/books/\\", json={ \\"title\\": \\"Another Test Book\\", \\"author\\": \\"Another Test Author\\", \\"ISBN\\": \\"0987654321\\", \\"genre\\": \\"Non-Fiction\\", \\"publication_date\\": \\"2023-01-01\\" }) response = client.get(\\"/books/?genre=Fiction\\") assert response.status_code == 200 assert len(response.json()) == 1 assert response.json()[0][\\"genre\\"] == \\"Fiction\\" books_db.clear() def test_list_books_by_author(): client.post(\\"/books/\\", json={ \\"title\\": \\"Test Book\\", \\"author\\": \\"Test Author\\", \\"ISBN\\": \\"1234567890\\", \\"genre\\": \\"Fiction\\", \\"publication_date\\": \\"2023-01-01\\" }) client.post(\\"/books/\\", json={ \\"title\\": \\"Another Test Book\\", \\"author\\": \\"Another Test Author\\", \\"ISBN\\": \\"0987654321\\", \\"genre\\": \\"Non-Fiction\\", \\"publication_date\\": \\"2023-01-01\\" }) response = client.get(\\"/books/?author=Test Author\\") assert response.status_code == 200 assert len(response.json()) == 1 assert response.json()[0][\\"author\\"] == \\"Test Author\\" books_db.clear()","solution":"from fastapi import FastAPI, HTTPException from pydantic import BaseModel from typing import List, Optional from uuid import uuid4 app = FastAPI() class Book(BaseModel): title: str author: str ISBN: str genre: str publication_date: str class UpdateBook(BaseModel): title: Optional[str] = None author: Optional[str] = None genre: Optional[str] = None publication_date: Optional[str] = None books_db = {} @app.post(\\"/books/\\", response_model=Book) def add_book(book: Book): if book.ISBN in books_db: raise HTTPException(status_code=400, detail=\\"Book with this ISBN already exists.\\") books_db[book.ISBN] = book return book @app.get(\\"/books/{isbn}\\", response_model=Book) def get_book(isbn: str): if isbn not in books_db: raise HTTPException(status_code=404, detail=\\"Book not found.\\") return books_db[isbn] @app.put(\\"/books/{isbn}\\", response_model=Book) def update_book(isbn: str, book_update: UpdateBook): if isbn not in books_db: raise HTTPException(status_code=404, detail=\\"Book not found.\\") updated_book = books_db[isbn].copy(update=book_update.dict(exclude_unset=True)) books_db[isbn] = updated_book return updated_book @app.delete(\\"/books/{isbn}\\", response_model=dict) def delete_book(isbn: str): if isbn not in books_db: raise HTTPException(status_code=404, detail=\\"Book not found.\\") del books_db[isbn] return {\\"detail\\": \\"Book deleted successfully.\\"} @app.get(\\"/books/\\", response_model=List[Book]) def list_books(genre: Optional[str] = None, author: Optional[str] = None): results = [book for book in books_db.values()] if genre: results = [book for book in results if book.genre == genre] if author: results = [book for book in results if book.author == author] return results"},{"question":"from collections import Counter import re def character_frequency(s: str) -> dict: Returns the frequency count of each alphabetic character in the string s, case-insensitive. >>> character_frequency(\\"Hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> character_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"AbCabc\\") {'a': 2, 'b': 2, 'c': 2} >>> character_frequency(\\"123456!@#%^&*()\\") {} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"A\\" * 1000 + \\"B\\" * 1000 + \\"1!@#%^&*()\\") {'a': 2000, 'b': 2000}","solution":"from collections import Counter import re def character_frequency(s): Returns the frequency count of each alphabetic character in the string s, case-insensitive. s = s.lower() filtered_string = re.sub(r'[^a-z]', '', s) return dict(Counter(filtered_string))"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Write a Python function \`longest_common_subsequence(str1, str2)\` that finds the length of the longest common subsequence between two input strings, \`str1\` and \`str2\`. A common subsequence is defined as a sequence that appears in both strings in the same order but not necessarily consecutively. >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 >>> longest_common_subsequence(\\"\\", \\"DEF\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"SAME\\", \\"SAME\\") 4 >>> longest_common_subsequence(\\"ABCDEFG\\", \\"EFG\\") 3","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def intersect(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of two arrays, each element appears as many times as it shows in both arrays. >>> intersect([4,9,5], [9,4,9,8,4]) [4, 9] >>> intersect([1, 2, 2, 1], [2, 2]) [2, 2] def test_common_elements(): arr1 = [4,9,5] arr2 = [9,4,9,8,4] result = intersect(arr1, arr2) assert sorted(result) == sorted([4, 9]) def test_no_common_elements(): arr1 = [1, 2, 3] arr2 = [4, 5, 6] result = intersect(arr1, arr2) assert result == [] def test_empty_arrays(): arr1 = [] arr2 = [] result = intersect(arr1, arr2) assert result == [] def test_all_elements_common(): arr1 = [1, 1, 1] arr2 = [1, 1, 1] result = intersect(arr1, arr2) assert sorted(result) == [1, 1, 1] def test_common_elements_with_different_counts(): arr1 = [1, 2, 2, 1] arr2 = [2, 2] result = intersect(arr1, arr2) assert sorted(result) == [2, 2] def test_identical_arrays(): arr1 = [1, 2, 3, 4, 5] arr2 = [1, 2, 3, 4, 5] result = intersect(arr1, arr2) assert sorted(result) == [1, 2, 3, 4, 5] def test_case_with_duplicates(): arr1 = [1, 2, 2, 3, 3, 3] arr2 = [2, 2, 2, 3, 3, 3, 3] result = intersect(arr1, arr2) assert sorted(result) == [2, 2, 3, 3, 3]","solution":"def intersect(arr1, arr2): Returns the intersection of two arrays, each element appears as many times as it shows in both arrays. from collections import Counter counter1 = Counter(arr1) counter2 = Counter(arr2) intersection = [] for element in counter1: if element in counter2: intersection.extend([element] * min(counter1[element], counter2[element])) return intersection"},{"question":"def cyclic_shifted_string(s1: str, s2: str) -> bool: Checks if s2 is a cyclic shift of s1. Args: s1 (str): The original string. s2 (str): The string to check against. Returns: bool: True if s2 is a cyclic shift of s1, False otherwise. >>> cyclic_shifted_string(\\"abcde\\", \\"cdeab\\") True >>> cyclic_shifted_string(\\"abcde\\", \\"abced\\") False >>> cyclic_shifted_string(\\"abcd\\", \\"dabc\\") True >>> cyclic_shifted_string(\\"abc\\", \\"cab\\") True >>> cyclic_shifted_string(\\"abc\\", \\"abc\\") True","solution":"def cyclic_shifted_string(s1, s2): Checks if s2 is a cyclic shift of s1. Args: s1 (str): The original string. s2 (str): The string to check against. Returns: bool: True if s2 is a cyclic shift of s1, False otherwise. if len(s1) != len(s2): return False # Concatenate s1 with itself double_s1 = s1 + s1 # Check if s2 is a substring of the concatenated result return s2 in double_s1"},{"question":"def group_dictionaries(dict_list: list, key: str, include_none: bool = True) -> dict: The function takes a list of dictionaries and groups them by a specified key. :param dict_list: List of dictionaries to be grouped. :param key: Key by which the dictionaries should be grouped. :param include_none: Boolean flag to include or exclude None or missing key values. :return: Dictionary with grouped lists of dictionaries. >>> group_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}, {'id': 1, 'value': 'c'}], 'id') {1: [{'id': 1, 'value': 'a'}, {'id': 1, 'value': 'c'}], 2: [{'id': 2, 'value': 'b'}]} >>> group_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}, {'no_id': 1, 'value': 'c'}], 'id', False) {1: [{'id': 1, 'value': 'a'}], 2: [{'id': 2, 'value': 'b'}]} import pytest def test_group_dictionaries_basic(): assert group_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}, {'id': 1, 'value': 'c'}], 'id') == {1: [{'id': 1, 'value': 'a'}, {'id': 1, 'value': 'c'}], 2: [{'id': 2, 'value': 'b'}]} def test_group_dictionaries_exclude_none(): assert group_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}, {'no_id': 1, 'value': 'c'}], 'id', False) == {1: [{'id': 1, 'value': 'a'}], 2: [{'id': 2, 'value': 'b'}]} def test_group_dictionaries_include_none(): assert group_dictionaries([{'id': 1, 'value': 'a'}, {'id': None, 'value': 'b'}, {'no_id': 1, 'value': 'c'}], 'id', True) == {1: [{'id': 1, 'value': 'a'}], None: [{'id': None, 'value': 'b'}, {'no_id': 1, 'value': 'c'}]} def test_group_dictionaries_empty_list(): assert group_dictionaries([], 'id') == {} def test_group_dictionaries_missing_key(): assert group_dictionaries([{'name': 'Alice'}, {'name': 'Bob'}], 'id', False) == {} def test_group_dictionaries_invalid_dict_list(): with pytest.raises(TypeError): group_dictionaries(\\"not a list\\", 'id') def test_group_dictionaries_invalid_key_type(): with pytest.raises(TypeError): group_dictionaries([{'id': 1}], 123) def test_group_dictionaries_invalid_element_type(): with pytest.raises(TypeError): group_dictionaries([{'id': 1}, 'not a dict'], 'id')","solution":"def group_dictionaries(dict_list: list, key: str, include_none: bool = True) -> dict: The function takes a list of dictionaries and groups them by a specified key. :param dict_list: List of dictionaries to be grouped. :param key: Key by which the dictionaries should be grouped. :param include_none: Boolean flag to include or exclude None or missing key values. :return: Dictionary with grouped lists of dictionaries. if not isinstance(dict_list, list): raise TypeError(\\"First argument must be a list of dictionaries.\\") if not isinstance(key, str): raise TypeError(\\"Second argument must be a string representing the key.\\") grouped_dict = {} for dictionary in dict_list: if not isinstance(dictionary, dict): raise TypeError(\\"Elements of the list must be dictionaries.\\") value = dictionary.get(key, None) if not include_none and (value is None): continue if value not in grouped_dict: grouped_dict[value] = [] grouped_dict[value].append(dictionary) return grouped_dict"},{"question":"def unique_elements(arr): Returns a new array containing only the unique elements from the original array, in the order they first appeared. >>> unique_elements([4, 5, 4, 6, 6, 7, 8, 8]) == [4, 5, 6, 7, 8] >>> unique_elements([1, 2, 3, 4]) == [1, 2, 3, 4] >>> unique_elements([1, 1, 1, 1]) == [1] >>> unique_elements([]) == [] >>> unique_elements([1, 2, 1, 3, 2, 1]) == [1, 2, 3] >>> unique_elements([3, 3, 2, 1, 2, 1, 4, 4]) == [3, 2, 1, 4]","solution":"def unique_elements(arr): Returns a new array containing only the unique elements from the original array, in the order they first appeared. seen = set() unique_arr = [] for element in arr: if element not in seen: seen.add(element) unique_arr.append(element) return unique_arr"},{"question":"def reverse_string(input_string: str) -> str: Write a function that takes a string as input and returns the string reversed. The function should handle the following cases: - If the input string is empty, the function should return an empty string. - The function should preserve spaces, punctuation, and capitalization as they appear in the original string. - The function should be capable of handling Unicode characters. Args: input_string (str): The string to be reversed. Returns: str: The reversed string. Examples: >>> reverse_string(\\"hello world\\") 'dlrow olleh' >>> reverse_string(\\"\\") '' >>> reverse_string(\\"A man, a plan, a canal, Panama!\\") '!amanaP ,lanac a ,nalp a ,nam A' >>> reverse_string(\\"こんにちは\\") 'はちにんこ' >>> reverse_string(\\"😊👍\\") '👍😊' # Replace with your solution import pytest def test_reverse_simple_string(): assert reverse_string(\\"hello world\\") == \\"dlrow olleh\\" def test_reverse_empty_string(): assert reverse_string(\\"\\") == \\"\\" def test_reverse_with_punctuation_and_spaces(): assert reverse_string(\\"A man, a plan, a canal, Panama!\\") == \\"!amanaP ,lanac a ,nalp a ,nam A\\" def test_reverse_string_with_unicode(): assert reverse_string(\\"こんにちは\\") == \\"はちにんこ\\" assert reverse_string(\\"😊👍\\") == \\"👍😊\\" def test_reverse_mixed_case_string(): assert reverse_string(\\"AaBbCcDd\\") == \\"dDcCbBaA\\"","solution":"def reverse_string(input_string: str) -> str: Reverses the input string and returns it. Args: input_string (str): The string to be reversed. Returns: str: The reversed string. return input_string[::-1]"},{"question":"def digit_sum(n: int) -> int: This function computes the digit sum of a given integer. - For a positive integer n, it returns the sum of its digits. - For a negative integer n, it returns the sum of the digits of its absolute value. Examples: >>> digit_sum(123) 6 >>> digit_sum(-456) 15 >>> digit_sum(0) 0 >>> digit_sum(99999) 45 # Position your solution here. # Unit Tests def test_digit_sum_positive_number(): assert digit_sum(123) == 6 def test_digit_sum_negative_number(): assert digit_sum(-456) == 15 def test_digit_sum_zero(): assert digit_sum(0) == 0 def test_digit_sum_large_number(): assert digit_sum(99999) == 45 def test_digit_sum_single_digit_positive(): assert digit_sum(7) == 7 def test_digit_sum_single_digit_negative(): assert digit_sum(-8) == 8 def test_digit_sum_mixed_zeroes(): assert digit_sum(1001) == 2","solution":"def digit_sum(n: int) -> int: This function computes the digit sum of a given integer. - For a positive integer n, it returns the sum of its digits. - For a negative integer n, it returns the sum of the digits of its absolute value. Examples: >>> digit_sum(123) 6 >>> digit_sum(-456) 15 >>> digit_sum(0) 0 >>> digit_sum(99999) 45 return sum(int(digit) for digit in str(abs(n)))"},{"question":"def caesar_cipher(message, shift): Encrypts a message using Caesar cipher. Args: message (str): The input message to be encrypted. shift (int): The number of positions each character in the message is shifted. Returns: str: The encrypted message. encrypted_message = \\"\\" for char in message: if 'a' <= char <= 'z': encrypted_message += chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) elif 'A' <= char <= 'Z': encrypted_message += chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) else: encrypted_message += char return encrypted_message # Unit Test def test_caesar_cipher(): assert caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher(\\"abc\\", 1) == \\"bcd\\" assert caesar_cipher(\\"ABC\\", 1) == \\"BCD\\" assert caesar_cipher(\\"xyz\\", 3) == \\"abc\\" assert caesar_cipher(\\"XYZ\\", 3) == \\"ABC\\" assert caesar_cipher(\\"Hello, World!\\", 0) == \\"Hello, World!\\" assert caesar_cipher(\\"Hello, World!\\", 26) == \\"Hello, World!\\" assert caesar_cipher(\\"Hello, World!\\", -3) == \\"Ebiil, Tloia!\\" assert caesar_cipher(\\"aBc123, XyZ!\\", 4) == \\"eFg123, BcD!\\" # To run the tests, use pytest if __name__ == \\"__main__\\": import pytest pytest.main([\\"-v\\"])","solution":"def caesar_cipher(message, shift): Encrypts a message using Caesar cipher. Args: message (str): The input message to be encrypted. shift (int): The number of positions each character in the message is shifted. Returns: str: The encrypted message. encrypted_message = \\"\\" for char in message: if 'a' <= char <= 'z': encrypted_message += chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) elif 'A' <= char <= 'Z': encrypted_message += chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) else: encrypted_message += char return encrypted_message"},{"question":"def find_pairs(nums, k): Returns the number of unique k-difference pairs in the array nums. Parameters: nums (List[int]): List of integers. k (int): The difference value. Returns: int: Number of unique k-difference pairs. Examples: >>> find_pairs([3, 1, 4, 1, 5], 2) 2 >>> find_pairs([1, 2, 3, 4, 5], 1) 4 >>> find_pairs([1, 3, 1, 5, 4], 0) 1 >>> find_pairs([1, 2, 3, 4, 5], 0) 0","solution":"def find_pairs(nums, k): Returns the number of unique k-difference pairs in the array nums. if k < 0: return 0 pairs = set() seen = set() if k == 0: freq = {} for number in nums: if number in freq: freq[number] += 1 else: freq[number] = 1 for number in freq: if freq[number] > 1: pairs.add((number, number)) else: for number in nums: if (number + k) in seen: pairs.add((number, number + k)) if (number - k) in seen: pairs.add((number - k, number)) seen.add(number) return len(pairs)"},{"question":"def longest_repeated_substring(s: str) -> str: Define a function that takes a string as input and returns the longest substring that appears at least twice in the given string. If there are multiple substrings of the same length that appear more than once, return the one that occurs first. Consider only non-overlapping substrings for this task. >>> longest_repeated_substring(\\"abcdef\\") == \\"\\" >>> longest_repeated_substring(\\"abcabc\\") == \\"abc\\" >>> longest_repeated_substring(\\"banana\\") == \\"an\\" >>> longest_repeated_substring(\\"abcabcabc\\") == \\"abc\\" >>> longest_repeated_substring(\\"abababab\\") == \\"abab\\" >>> longest_repeated_substring(\\"\\") == \\"\\"","solution":"def longest_repeated_substring(s): Returns the longest substring that appears at least twice in the given string. If there are multiple substrings of the same length that appear more than once, return the one that occurs first. Considers only non-overlapping substrings. n = len(s) longest_substring = \\"\\" # Try all possible substrings and count their occurrences for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] count = s.count(substring) if count > 1 and len(substring) > len(longest_substring): longest_substring = substring elif count > 1 and len(substring) == len(longest_substring) and s.index(substring) < s.index(longest_substring): longest_substring = substring return longest_substring"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be made by buying on one day and selling on another day. :param prices: List of stock prices over a number of days :return: Maximum profit that can be made >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([3, 3, 3, 3]) 0 >>> max_profit([10, 9, 8, 7, 6, 5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([2, 1, 4, 5, 3, 6, 1, 8]) 7","solution":"def max_profit(prices): Calculate the maximum profit that can be made by buying on one day and selling on another day. :param prices: List of stock prices over a number of days :return: Maximum profit that can be made if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def highest_scorers(students_scores): Returns the names of the highest scoring student(s) in alphabetical order. Args: students_scores (list of tuples): A list where each tuple contains a student's name and their score. Returns: list: A list of names of the highest scoring students in alphabetical order. pass # Tests def test_highest_scorers_single_winner(): students_scores = [(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Charlie\\", 88), (\\"Dave\\", 85), (\\"Eva\\", 80)] assert highest_scorers(students_scores) == [\\"Bob\\"] def test_highest_scorers_multiple_winners(): students_scores = [(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Charlie\\", 88), (\\"Dave\\", 85), (\\"Eva\\", 90)] assert highest_scorers(students_scores) == [\\"Bob\\", \\"Eva\\"] def test_highest_scorers_all_same_score(): students_scores = [(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 90)] assert highest_scorers(students_scores) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] def test_highest_scorers_empty_list(): students_scores = [] assert highest_scorers(students_scores) == [] def test_highest_scorers_single_student(): students_scores = [(\\"Alice\\", 85)] assert highest_scorers(students_scores) == [\\"Alice\\"] def test_highest_scorers_multiple_winners_with_same_initial(): students_scores = [(\\"Xander\\", 88), (\\"Xavier\\", 88)] assert highest_scorers(students_scores) == [\\"Xander\\", \\"Xavier\\"]","solution":"def highest_scorers(students_scores): Returns the names of the highest scoring student(s) in alphabetical order. Args: students_scores (list of tuples): A list where each tuple contains a student's name and their score. Returns: list: A list of names of the highest scoring students in alphabetical order. if not students_scores: return [] sorted_scores = sorted(students_scores, key=lambda x: (-x[1], x[0])) highest_score = sorted_scores[0][1] highest_scorers = [name for name, score in sorted_scores if score == highest_score] return sorted(highest_scorers)"},{"question":"[Completion Task in Python] import threading class BankAccount: def __init__(self): self.balance = 0 self.lock = threading.Lock() def deposit(self, amount): Deposits a specified amount into the account, ensuring thread safety. def withdraw(self, amount): Withdraws a specified amount from the account if sufficient funds are available, ensuring thread safety. def transfer(from_account, to_account, amount): Transfers a specified amount from one account to another if the balance is sufficient, ensuring thread safety. # Example usage: if __name__ == \\"__main__\\": account1 = BankAccount() account2 = BankAccount() # Depositing initial amounts account1.deposit(100) account2.deposit(50) # Starting transfer threads = [] for _ in range(10): t = threading.Thread(target=transfer, args=(account1, account2, 10)) t.start() threads.append(t) # Waiting for threads to finish for t in threads: t.join() print(f\\"Account1 balance: {account1.balance}\\") print(f\\"Account2 balance: {account2.balance}\\") # Unit tests def test_deposit(): account = BankAccount() account.deposit(50) assert account.balance == 50 def test_withdraw(): account = BankAccount() account.deposit(100) result = account.withdraw(50) assert result == True assert account.balance == 50 def test_transfer_success(): account1 = BankAccount() account2 = BankAccount() account1.deposit(100) result = transfer(account1, account2, 50) assert result == True assert account1.balance == 50 assert account2.balance == 50 def test_transfer_failure(): account1 = BankAccount() account2 = BankAccount() account1.deposit(10) result = transfer(account1, account2, 50) assert result == False assert account1.balance == 10 assert account2.balance == 0","solution":"import threading class BankAccount: def __init__(self): self.balance = 0 self.lock = threading.Lock() def deposit(self, amount): with self.lock: current_balance = self.balance current_balance += amount self.balance = current_balance def withdraw(self, amount): with self.lock: current_balance = self.balance if current_balance >= amount: current_balance -= amount self.balance = current_balance return True return False def transfer(from_account, to_account, amount): if from_account.withdraw(amount): to_account.deposit(amount) return True return False # Example usage: account1 = BankAccount() account2 = BankAccount() # Depositing initial amounts account1.deposit(100) account2.deposit(50) # Starting transfer threads = [] for _ in range(10): t = threading.Thread(target=transfer, args=(account1, account2, 10)) t.start() threads.append(t) # Waiting for threads to finish for t in threads: t.join() print(f\\"Account1 balance: {account1.balance}\\") print(f\\"Account2 balance: {account2.balance}\\")"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of positive integers, addition, and multiplication. The function respects the order of operations (multiplication before addition). >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"4*2\\") == 8 >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"2*3*4\\") == 24 >>> evaluate_expression(\\"1+2+3+4\\") == 10 >>> evaluate_expression(\\"1+2*3+4*5+6\\") == 33 >>> evaluate_expression(\\"7\\") == 7 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\" 3 + 5 * 2 \\") == 13","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of positive integers, addition, and multiplication. The function respects the order of operations (multiplication before addition). Args: expression (str): The input mathematical expression as a string. Returns: int: The result of the evaluated expression. def parse_term(term): parts = term.split('*') result = 1 for part in parts: result *= int(part) return result terms = expression.split('+') result = 0 for term in terms: result += parse_term(term) return result"},{"question":"class BookNotAvailableError(Exception): pass class BookNotBorrowedError(Exception): pass class Library: def __init__(self): Initialize with a predefined list of books self.books_inventory = {\\"The Great Gatsby\\": 3, \\"1984\\": 5, \\"To Kill a Mockingbird\\": 2} self.borrowed_books = {} def borrow_book(self, user, book): Borrow a book for a user if it's available pass # Implement the logic of borrowing a book def return_book(self, user, book): Return a borrowed book pass # Implement the logic of returning a book def list_available_books(self): Display all available books pass # Implement the logic of displaying available books def list_borrowed_books(self, user): Display all books borrowed by a specific user pass # Implement the logic of displaying borrowed books for a user # Example Usage library = Library() library.borrow_book(\\"Alice\\", \\"1984\\") library.return_book(\\"Alice\\", \\"1984\\") print(library.list_available_books()) print(library.list_borrowed_books(\\"Alice\\")) # Unit Tests def test_borrow_book(): library = Library() library.borrow_book(\\"Alice\\", \\"1984\\") assert library.books_inventory[\\"1984\\"] == 4 assert library.borrowed_books[\\"Alice\\"] == [\\"1984\\"] try: for _ in range(5): library.borrow_book(\\"Bob\\", \\"1984\\") except BookNotAvailableError: pass def test_return_book(): library = Library() library.borrow_book(\\"Alice\\", \\"1984\\") library.return_book(\\"Alice\\", \\"1984\\") assert library.books_inventory[\\"1984\\"] == 5 assert library.borrowed_books[\\"Alice\\"] == [] try: library.return_book(\\"Bob\\", \\"1984\\") except BookNotBorrowedError: pass def test_list_available_books(): library = Library() assert library.list_available_books() == {\\"The Great Gatsby\\": 3, \\"1984\\": 5, \\"To Kill a Mockingbird\\": 2} def test_list_borrowed_books(): library = Library() library.borrow_book(\\"Alice\\", \\"1984\\") library.borrow_book(\\"Alice\\", \\"The Great Gatsby\\") assert library.list_borrowed_books(\\"Alice\\") == [\\"1984\\", \\"The Great Gatsby\\"] assert library.list_borrowed_books(\\"Bob\\") == []","solution":"class BookNotAvailableError(Exception): pass class BookNotBorrowedError(Exception): pass class Library: def __init__(self): # Initialize with a predefined list of books self.books_inventory = {\\"The Great Gatsby\\": 3, \\"1984\\": 5, \\"To Kill a Mockingbird\\": 2} self.borrowed_books = {} def borrow_book(self, user, book): if self.books_inventory.get(book, 0) > 0: self.books_inventory[book] -= 1 if user not in self.borrowed_books: self.borrowed_books[user] = [] self.borrowed_books[user].append(book) else: raise BookNotAvailableError(f\\"Book '{book}' is not available for borrowing\\") def return_book(self, user, book): if user in self.borrowed_books and book in self.borrowed_books[user]: self.borrowed_books[user].remove(book) self.books_inventory[book] += 1 else: raise BookNotBorrowedError(f\\"Book '{book}' was not borrowed by user '{user}'\\") def list_available_books(self): return self.books_inventory def list_borrowed_books(self, user): return self.borrowed_books.get(user, [])"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of integers in the array that sum up to the target value. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: list of tuple: A list of unique pairs (tuples) that sum up to the target value. >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 7) == [(2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3, 10, 20], 50) == [] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 6) == [(1, 5), (2, 4)] >>> find_pairs_with_sum([-1, -2, -3, 1, 2, 3], 0) == [(-1, 1), (-2, 2), (-3, 3)] >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) == [(1, 3), (2, 2)] >>> find_pairs_with_sum([], 4) == []","solution":"def find_pairs_with_sum(arr, target): Returns all unique pairs of integers in the array that sum up to the target value. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: list of tuple: A list of unique pairs (tuples) that sum up to the target value. seen = set() output = set() for num in arr: complement = target - num if complement in seen: # Create a sorted tuple to avoid duplicate pairs like (3, 4) and (4, 3) output.add(tuple(sorted((num, complement)))) seen.add(num) return list(output) # Example: arr = [2, 4, 3, 5, 7, 8, 9] target = 7 print(find_pairs_with_sum(arr, target)) # Output: [(2, 5), (3, 4)]"},{"question":"def unique_substrings(s: str) -> List[str]: Returns all possible unique substrings of a given string, sorted in ascending order by their length, and for substrings of the same length, sorted lexicographically. Example tests: >>> unique_substrings(\\"\\") == [] >>> unique_substrings(\\"a\\") == [\\"a\\"] >>> unique_substrings(\\"aaa\\") == [\\"a\\", \\"aa\\", \\"aaa\\"] >>> unique_substrings(\\"abc\\") == [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"] >>> unique_substrings(\\"aab\\") == [\\"a\\", \\"b\\", \\"aa\\", \\"ab\\", \\"aab\\"] >>> unique_substrings(\\"banana\\") == [ \\"a\\", \\"b\\", \\"n\\", \\"an\\", \\"ba\\", \\"na\\", \\"ana\\", \\"ban\\", \\"nan\\", \\"anan\\", \\"bana\\", \\"nana\\", \\"anana\\", \\"banan\\", \\"banana\\" ]","solution":"def unique_substrings(s): Returns all possible unique substrings of a given string, sorted in ascending order by their length, and for substrings of the same length, sorted lexicographically. substrings = set() length = len(s) # Generate all possible substrings and add them to the set to make them unique for i in range(length): for j in range(i + 1, length + 1): substrings.add(s[i:j]) # Convert the set to a list and sort it sorted_substrings = sorted(substrings, key=lambda x: (len(x), x)) return sorted_substrings"},{"question":"def group_scores(data): Groups names by their respective scores from the provided list of tuples. Args: data (list of tuples): Each tuple consists of a string (name) and an integer (score). Returns: dict: A dictionary where each key is a score and each value is a list of names sorted alphabetically that share that score. >>> group_scores([ ... ('Alice', 90), ... ('Bob', 85), ... ('Charlie', 90), ... ('David', 95), ... ('Eve', 85) ... ]) {90: ['Alice', 'Charlie'], 85: ['Bob', 'Eve'], 95: ['David']} >>> group_scores([('Alice', 90)]) {90: ['Alice']} >>> group_scores([]) {} >>> group_scores([('Alice', 90), ('Alice', 90)]) {90: ['Alice', 'Alice']} >>> group_scores([('Charlie', 88), ('Alice', 88), ('Bob', 85)]) {88: ['Alice', 'Charlie'], 85: ['Bob']}","solution":"def group_scores(data): Groups names by their respective scores from the provided list of tuples. Args: data (list of tuples): Each tuple consists of a string (name) and an integer (score). Returns: dict: A dictionary where each key is a score and each value is a list of names sorted alphabetically that share that score. score_dict = {} for name, score in data: if score not in score_dict: score_dict[score] = [] score_dict[score].append(name) for score in score_dict: score_dict[score].sort() return score_dict"},{"question":"def binary_search(arr, target): Implement a binary search algorithm in Python. Args: arr (List[int]): A list of integers sorted in ascending order. target (int): The integer to search for in the list. Returns: int: The index of the target if found, else -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6) 5 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 def test_binary_search_found(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert binary_search(arr, 6) == 5 def test_binary_search_not_found(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert binary_search(arr, 11) == -1 assert binary_search(arr, 0) == -1 def test_binary_search_first_element(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert binary_search(arr, 1) == 0 def test_binary_search_last_element(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert binary_search(arr, 10) == 9 def test_binary_search_single_element_found(): arr = [5] assert binary_search(arr, 5) == 0 def test_binary_search_single_element_not_found(): arr = [5] assert binary_search(arr, 1) == -1 def test_binary_search_empty_array(): arr = [] assert binary_search(arr, 1) == -1","solution":"def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def count_characters(s: str) -> dict: Takes a string s and returns a dictionary where each key is a unique character from the string and the value is the number of occurrences of that character. The function is case-sensitive and considers spaces and punctuation as valid characters. >>> count_characters(\\"Hello, World!\\") == { 'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1 } >>> count_characters(\\"a b c a b\\") == { 'a': 2, ' ': 4, 'b': 2, 'c': 1 } >>> count_characters(\\"aA\\") == { 'a': 1, 'A': 1 } >>> count_characters(\\".,.,\\") == { '.': 2, ',': 2 } >>> count_characters(\\"\\") == {} >>> count_characters(\\"123123\\") == { '1': 2, '2': 2, '3': 2 }","solution":"def count_characters(s): Takes a string s and returns a dictionary where each key is a unique character from the string and the value is the number of occurrences of that character. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"class QueueUsingTwoStacks: Create a function that simulates a simple queue with the following operations: enqueue, dequeue, and peek. The queue should be implemented using two stacks to manage the operations. Each operation should perform in O(1) average time complexity. Additionally, create another function that checks if the queue is empty and returns a boolean value. Demonstrate your queue implementation with a series of enqueue and dequeue operations, and display the state of the queue after each operation. def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, item): Add an item to the queue pass def dequeue(self): Remove and return the front item from the queue pass def peek(self): Return the front item from the queue without removing it pass def is_empty(self): Check if the queue is empty pass # Example usage if __name__ == '__main__': queue = QueueUsingTwoStacks() queue.enqueue(1) print(\\"State after enqueue 1:\\", queue.stack1, queue.stack2) queue.enqueue(2) print(\\"State after enqueue 2:\\", queue.stack1, queue.stack2) dequeue_val = queue.dequeue() print(\\"Dequeued value:\\", dequeue_val) print(\\"State after dequeue:\\", queue.stack1, queue.stack2) peek_val = queue.peek() print(\\"Peek value:\\", peek_val) print(\\"State after peek:\\", queue.stack1, queue.stack2) queue.enqueue(3) print(\\"State after enqueue 3:\\", queue.stack1, queue.stack2) is_empty = queue.is_empty() print(\\"Is queue empty?:\\", is_empty) queue.dequeue() queue.dequeue() is_empty_again = queue.is_empty() print(\\"Is queue empty after dequeuing all?:\\", is_empty_again)","solution":"class QueueUsingTwoStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, item): self.stack1.append(item) def dequeue(self): if not self.stack2: # If stack2 is empty, transfer all items from stack1 while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2.pop() # \\"Dequeue\\" by popping from stack2 raise IndexError(\\"Dequeue from empty queue\\") def peek(self): if not self.stack2: # If stack2 is empty, transfer all items from stack1 while self.stack1: self.stack2.append(self.stack1.pop()) if self.stack2: return self.stack2[-1] # Peek the top of stack2 raise IndexError(\\"Peek from empty queue\\") def is_empty(self): return not self.stack1 and not self.stack2 # Demonstration queue = QueueUsingTwoStacks() queue.enqueue(1) print(\\"State after enqueue 1:\\", queue.stack1, queue.stack2) queue.enqueue(2) print(\\"State after enqueue 2:\\", queue.stack1, queue.stack2) dequeue_val = queue.dequeue() print(\\"Dequeued value:\\", dequeue_val) print(\\"State after dequeue:\\", queue.stack1, queue.stack2) peek_val = queue.peek() print(\\"Peek value:\\", peek_val) print(\\"State after peek:\\", queue.stack1, queue.stack2) queue.enqueue(3) print(\\"State after enqueue 3:\\", queue.stack1, queue.stack2) is_empty = queue.is_empty() print(\\"Is queue empty?:\\", is_empty) queue.dequeue() queue.dequeue() is_empty_again = queue.is_empty() print(\\"Is queue empty after dequeuing all?:\\", is_empty_again)"},{"question":"def evaluate_rpn(expression: str) -> float: Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string representing a mathematical expression in RPN. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is invalid. Example Usage: >>> evaluate_rpn(\\"3 4 + 2 *\\") 14.0 >>> evaluate_rpn(\\"2 3 + 5 /\\") 1.0","solution":"def evaluate_rpn(expression): Evaluates a mathematical expression in Reverse Polish Notation (RPN). Parameters: expression (str): A string representing a mathematical expression in RPN. Returns: int/float: The result of the evaluated expression. Raises: ValueError: If the expression is invalid. stack = [] operators = {'+': lambda y, x: x + y, '-': lambda y, x: x - y, '*': lambda y, x: x * y, '/': lambda y, x: x / y} for token in expression.split(): if token in operators: try: stack.append(operators[token](stack.pop(), stack.pop())) except IndexError: raise ValueError(\\"Invalid expression: not enough operands\\") else: try: stack.append(float(token)) # Use float to handle division results correctly except ValueError: raise ValueError(f\\"Invalid token: {token}\\") if len(stack) != 1: raise ValueError(\\"Invalid expression: too many operands\\") return stack[0] # Example Usage: # print(evaluate_rpn(\\"3 4 + 2 *\\")) # Should output 14 # print(evaluate_rpn(\\"2 3 + 5 /\\")) # Should output 1.0"},{"question":"from collections import defaultdict from typing import List, Tuple def top_three_students(scores: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Determines the top 3 students with the highest scores and their respective ranks. Ties are broken in alphabetical order of their names. :param scores: List[Tuple[str, int]] where each tuple contains a student's name and their score :return: List[Tuple[str, int]] containing the top 3 students and their ranks >>> top_three_students([(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 90), (\\"David\\", 85), (\\"Eve\\", 95), (\\"Frank\\", 85)]) [(\\"Bob\\", 1), (\\"Eve\\", 1), (\\"Charlie\\", 3)] >>> top_three_students([(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 85), (\\"David\\", 80), (\\"Eve\\", 90)]) [(\\"Alice\\", 1), (\\"Bob\\", 1), (\\"Eve\\", 1)] >>> top_three_students([(\\"Alice\\", 90), (\\"Bob\\", 85)]) [(\\"Alice\\", 1), (\\"Bob\\", 2)] >>> top_three_students([(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 90), (\\"David\\", 90), (\\"Eve\\", 90)]) [(\\"Alice\\", 1), (\\"Bob\\", 1), (\\"Charlie\\", 1)] >>> top_three_students([]) [] >>> top_three_students([(\\"Alice\\", 91), (\\"Bob\\", 89), (\\"Charlie\\", 89), (\\"David\\", 89), (\\"Eve\\", 90)]) [(\\"Alice\\", 1), (\\"Eve\\", 2), (\\"Bob\\", 3)]","solution":"from collections import defaultdict def top_three_students(scores): Determines the top 3 students with the highest scores and their respective ranks. Ties are broken in alphabetical order of their names. :param scores: List[Tuple[str, int]] where each tuple contains a student's name and their score :return: List[Tuple[str, int]] containing the top 3 students and their ranks # Create a dictionary to hold scores mapped to names score_dict = defaultdict(list) for name, score in scores: score_dict[score].append(name) # Sort the scores in descending order sorted_scores = sorted(score_dict.keys(), reverse=True) # Keep track of the ranks result = [] current_rank = 1 for score in sorted_scores: names = sorted(score_dict[score]) # Sort names alphabetically for name in names: result.append((name, current_rank)) if len(result) == 3: return result current_rank += len(names) return result"},{"question":"def product_except_self(nums): Given a list of integers, returns a list such that each element at index 'i' is the product of all the numbers in the original list except the one at 'i', without using division. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6]","solution":"def product_except_self(nums): Given a list of integers, returns a list such that each element at index 'i' is the product of all the numbers in the original list except the one at 'i', without using division. length = len(nums) answer = [1] * length # Calculate the products of all elements to the left of each index left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate the products of all elements to the right of each index right_product = 1 for i in reversed(range(length)): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def sort_strings_by_length(strings: List[str], n: int) -> List[str]: Returns a list of strings sorted by their length in descending order. In case of a tie in length, the strings are sorted alphabetically. :param strings: List of strings. :param n: An integer. :return: List of sorted strings. >>> sort_strings_by_length([\\"apple\\", \\"bat\\", \\"banana\\", \\"cherry\\"], 0) [\\"banana\\", \\"cherry\\", \\"apple\\", \\"bat\\"] >>> sort_strings_by_length([\\"xyz\\", \\"ax\\", \\"a\\", \\"b\\"], 0) [\\"xyz\\", \\"ax\\", \\"a\\", \\"b\\"] >>> sort_strings_by_length([\\"\\", \\"a\\", \\"abc\\"], 0) [\\"abc\\", \\"a\\", \\"\\"] >>> sort_strings_by_length([\\"\\", \\"\\", \\"\\"], 0) [\\"\\", \\"\\", \\"\\"] >>> sort_strings_by_length([\\"cat\\", \\"dog\\", \\"bat\\"], 0) [\\"bat\\", \\"cat\\", \\"dog\\"]","solution":"def sort_strings_by_length(strings, n): Returns a list of strings sorted by their length in descending order. In case of a tie in length, the strings are sorted alphabetically. :param strings: List of strings. :param n: An integer (not used in this case but part of the function signature). :return: List of sorted strings. return sorted(strings, key=lambda x: (-len(x), x))"},{"question":"def valid_brackets(string: str) -> bool: Recursive function to check if a string has valid brackets >>> valid_brackets(\\"((){})\\") True >>> valid_brackets(\\"([)]\\") False >>> valid_brackets(\\"()\\") True >>> valid_brackets(\\"({[]})\\") True pass def longest_valid_brackets_substring(string: str) -> str: Function to find the longest valid brackets substring >>> longest_valid_brackets_substring(\\"(())\\") \\"(())\\" >>> longest_valid_brackets_substring(\\"()(()\\") \\"()\\" >>> longest_valid_brackets_substring(\\"{[()]}[(})\\") \\"{[()]}\\" >>> longest_valid_brackets_substring(\\"[({})]({})\\") \\"[({})]({})\\" pass","solution":"def valid_brackets(string: str) -> bool: def check(s, opening=\\"([{\\", closing=\\")]}\\", match=dict(zip(\\"([{\\", \\")]}\\"))): stack = [] for char in s: if char in opening: stack.append(char) elif char in closing: if not stack or match[stack.pop()] != char: return False return not stack return check(string) def longest_valid_brackets_substring(string: str) -> str: n = len(string) max_len = 0 start_index = 0 dp = [0] * n for i in range(1, n): if string[i] == ')': if i - dp[i-1] - 1 >= 0 and string[i - dp[i-1] - 1] == '(': dp[i] = dp[i-1] + 2 + (dp[i - dp[i-1] - 2] if i - dp[i-1] - 2 >= 0 else 0) if dp[i] > max_len: max_len = dp[i] start_index = i - dp[i] + 1 elif string[i] == '}': if i - dp[i-1] - 1 >= 0 and string[i - dp[i-1] - 1] == '{': dp[i] = dp[i-1] + 2 + (dp[i - dp[i-1] - 2] if i - dp[i-1] - 2 >= 0 else 0) if dp[i] > max_len: max_len = dp[i] start_index = i - dp[i] + 1 elif string[i] == ']': if i - dp[i-1] - 1 >= 0 and string[i - dp[i-1] - 1] == '[': dp[i] = dp[i-1] + 2 + (dp[i - dp[i-1] - 2] if i - dp[i-1] - 2 >= 0 else 0) if dp[i] > max_len: max_len = dp[i] start_index = i - dp[i] + 1 return string[start_index:start_index + max_len]"},{"question":"def sieve_of_eratosthenes(n: int) -> list: Returns a list of prime numbers up to a given integer n using the Sieve of Eratosthenes method. The function should handle edge cases where n is less than 2 by returning an empty list. The implementation should be optimized to avoid redundant calculations using boolean flags. :param n: The upper limit of the range to find prime numbers within. :type n: int :return: A list of prime numbers up to n. :rtype: list >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def sieve_of_eratosthenes(n: int) -> list: Returns a list of prime numbers up to a given integer n using the Sieve of Eratosthenes method. The function should handle edge cases where n is less than 2 by returning an empty list. The implementation should be optimized to avoid redundant calculations using boolean flags. :param n: The upper limit of the range to find prime numbers within. :type n: int :return: A list of prime numbers up to n. :rtype: list >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] if n < 2: return [] sieve = [True] * (n + 1) p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return [p for p in range(2, n + 1) if sieve[p]]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression provided as a string and returns the integer result. The expression contains non-negative integers and operators +, -, *, /. >>> evaluate_expression(\\"3+2*2\\") # Outputs: 7 >>> evaluate_expression(\\" 3/2 \\") # Outputs: 1 >>> evaluate_expression(\\" 3+5 / 2 \\") # Outputs: 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression provided as a string and returns the integer result. The expression contains non-negative integers and operators +, -, *, /. def apply_operator(operators, operands): operator = operators.pop() b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a // b) # Integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 # Tokenize the input expression tokens = [] i, n = 0, len(expression) while i < n: if expression[i] == ' ': i += 1 elif expression[i] in '+-*/': tokens.append(expression[i]) i += 1 else: num = 0 while i < n and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 tokens.append(num) # Shunting-yard algorithm to convert to postfix notation operands = [] operators = [] for token in tokens: if isinstance(token, int): operands.append(token) else: while (operators and precedence(operators[-1]) >= precedence(token)): apply_operator(operators, operands) operators.append(token) while operators: apply_operator(operators, operands) return operands[0]"},{"question":"def inverted_pascals_triangle(n: int) -> List[str]: Returns a list of strings representing the first \`n\` lines of an inverted Pascal's Triangle. An inverted Pascal's Triangle starts with the largest element on the top row, and the elements decrease following a pattern related to Pascal's Triangle. Args: n (int): Number of rows in the inverted Pascal's Triangle. Returns: List[str]: List of strings where each string represents a row of the inverted Pascal's Triangle. Example: >>> inverted_pascals_triangle(4) [ \\"15\\", \\"14 13\\", \\"10 9 8\\", \\"1 0 -1 0\\" ] >>> inverted_pascals_triangle(1) [\\"15\\"]","solution":"def inverted_pascals_triangle(n): Returns a list of strings representing the first \`n\` lines of an inverted Pascal's Triangle. An inverted Pascal's Triangle starts with the largest element on the top row, and the elements decrease following a pattern related to Pascal's Triangle. if n == 0: return [] result = [] current_value = 15 # Starting value (arbitrary for demonstration) result.append(f\\"{current_value}\\") for i in range(1, n): row = [] last_row = result[-1].split() for j in range(len(last_row) + 1): if j == 0: new_value = int(last_row[0]) - 1 elif j == len(last_row): new_value = int(last_row[-1]) - 1 else: new_value = int(last_row[j - 1]) - 1 row.append(new_value) result.append(\\" \\".join(map(str, row))) return result"},{"question":"def remove_vowels(words: List[str]) -> List[str]: Given a list of words, returns a list of words with all vowels removed. :param words: List of words to process :return: List of words with vowels removed >>> remove_vowels([\\"apple\\", \\"banana\\", \\"grape\\"]) == [\\"ppl\\", \\"bnn\\", \\"grp\\"] >>> remove_vowels([\\"elephant\\", \\"oooooo\\", \\"banana\\"]) == [\\"lphnt\\", \\"\\", \\"bnn\\"] import pytest def test_remove_vowels_basic(): assert remove_vowels([\\"apple\\", \\"banana\\", \\"grape\\"]) == [\\"ppl\\", \\"bnn\\", \\"grp\\"] def test_remove_vowels_with_repetitive_vowels(): assert remove_vowels([\\"elephant\\", \\"oooooo\\", \\"banana\\"]) == [\\"lphnt\\", \\"\\", \\"bnn\\"] def test_remove_vowels_empty_list(): assert remove_vowels([]) == [] def test_remove_vowels_no_vowels(): assert remove_vowels([\\"rhythm\\", \\"crypt\\", \\"gym\\"]) == [\\"rhythm\\", \\"crypt\\", \\"gym\\"] def test_remove_vowels_all_vowels(): assert remove_vowels([\\"aeiou\\", \\"eau\\"]) == [\\"\\", \\"\\"]","solution":"def remove_vowels(words): Given a list of words, returns a list of words with all vowels removed. :param words: List of words to process :return: List of words with vowels removed vowels = \\"aeiou\\" result = [] for word in words: no_vowel_word = \\"\\".join(char for char in word if char not in vowels) result.append(no_vowel_word) return result"},{"question":"def is_valid_hex_color(code: str) -> bool: Checks if the given string is a valid hexadecimal color code. A valid hexadecimal color code starts with a \\"#\\" followed by exactly 6 characters, which can be digits (0-9) or letters (A-F, a-f). Args: code (str): The string to check. Returns: bool: True if the string is a valid hexadecimal color code, False otherwise. >>> is_valid_hex_color(\\"#1A2B3C\\") True >>> is_valid_hex_color(\\"#1G2B3C\\") False >>> is_valid_hex_color(\\"123456\\") False >>> is_valid_hex_color(\\"#12345\\") False >>> is_valid_hex_color(\\"#1234567\\") False >>> is_valid_hex_color(\\"#1a2b3c\\") True >>> is_valid_hex_color(\\"#1a2G3z\\") False >>> is_valid_hex_color(\\"#12345z\\") False >>> is_valid_hex_color(\\"\\") False >>> is_valid_hex_color(\\"#\\") False","solution":"import re def is_valid_hex_color(code: str) -> bool: Checks if the given string is a valid hexadecimal color code. A valid hexadecimal color code starts with a \\"#\\" followed by exactly 6 characters, which can be digits (0-9) or letters (A-F, a-f). Args: code (str): The string to check. Returns: bool: True if the string is a valid hexadecimal color code, False otherwise. pattern = r\\"^#[0-9A-Fa-f]{6}\\" if re.match(pattern, code): return True return False"},{"question":"import pandas as pd import numpy as np from sklearn.linear_model import LinearRegression from sklearn.tree import DecisionTreeRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import TimeSeriesSplit from sklearn.ensemble import VotingRegressor import matplotlib.pyplot as plt def load_data(url): Load data from a CSV file. Args: url (str): URL to the CSV file. Returns: pd.DataFrame: Loaded data with 'Date' as the index and 'Temp' column. df = pd.read_csv(url, parse_dates=['Date']) df.set_index('Date', inplace=True) return df def create_lag_features(data, lag): Create lag features for the time series data. Args: data (pd.DataFrame): Original data. lag (int): Number of lag features to create. Returns: pd.DataFrame: Data with lag features. df = data.copy() for i in range(1, lag+1): df[f'lag_{i}'] = df['Temp'].shift(i) df.dropna(inplace=True) return df def prepare_data(df, lag): Prepare data for modeling by creating lag features. Args: df (pd.DataFrame): Original data. lag (int): Number of lag features to create. Returns: np.ndarray: Features for modeling. np.ndarray: Target variable. data = create_lag_features(df, lag) X = data.drop(columns='Temp').values y = data['Temp'].values return X, y def train_evaluate_model(X, y, n_splits=5): Train and evaluate the model using time-series cross-validation. Args: X (np.ndarray): Features. y (np.ndarray): Target variable. n_splits (int): Number of splits for cross-validation. Returns: list: RMSE values for Linear Regression. list: RMSE values for Decision Tree Regressor. list: RMSE values for Voting Regressor. tscv = TimeSeriesSplit(n_splits=n_splits) lr_rmse = [] dt_rmse = [] vr_rmse = [] for train_idx, test_idx in tscv.split(X): X_train, X_test = X[train_idx], X[test_idx] y_train, y_test = y[train_idx], y[test_idx] # Linear Regression lr = LinearRegression() lr.fit(X_train, y_train) lr_pred = lr.predict(X_test) lr_rmse.append(np.sqrt(mean_squared_error(y_test, lr_pred))) # Decision Tree Regressor dt = DecisionTreeRegressor() dt.fit(X_train, y_train) dt_pred = dt.predict(X_test) dt_rmse.append(np.sqrt(mean_squared_error(y_test, dt_pred))) # Voting Regressor vr = VotingRegressor([('lr', lr), ('dt', dt)]) vr.fit(X_train, y_train) vr_pred = vr.predict(X_test) vr_rmse.append(np.sqrt(mean_squared_error(y_test, vr_pred))) return lr_rmse, dt_rmse, vr_rmse def plot_predictions(df, model, lag): Plot predictions of the model against actual data. Args: df (pd.DataFrame): Original data. model (VotingRegressor): Trained model. lag (int): Number of lag features. data = create_lag_features(df, lag) X = data.drop(columns='Temp').values y = data['Temp'].values model.fit(X, y) predictions = model.predict(X) plt.figure(figsize=(14, 7)) plt.plot(df.index, df['Temp'], label='Actual') plt.plot(data.index, predictions, label='Predicted') plt.xlabel('Date') plt.ylabel('Temperature') plt.legend() plt.show() # Example usage: url = 'https://raw.githubusercontent.com/jbrownlee/Datasets/master/daily-min-temperatures.csv' df = load_data(url) lag = 7 X, y = prepare_data(df, lag) lr_rmse, dt_rmse, vr_rmse = train_evaluate_model(X, y, n_splits=5) print(f\\"Linear Regression RMSE: {np.mean(lr_rmse):.4f}\\") print(f\\"Decision Tree Regressor RMSE: {np.mean(dt_rmse):.4f}\\") print(f\\"Voting Regressor RMSE: {np.mean(vr_rmse):.4f}\\") # Compare predictions vr = VotingRegressor([('lr', LinearRegression()), ('dt', DecisionTreeRegressor())]) plot_predictions(df, vr, lag)","solution":"import pandas as pd import numpy as np from sklearn.linear_model import LinearRegression from sklearn.tree import DecisionTreeRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import TimeSeriesSplit from sklearn.ensemble import VotingRegressor import matplotlib.pyplot as plt def load_data(url): df = pd.read_csv(url, parse_dates=['Date']) df.set_index('Date', inplace=True) return df def create_lag_features(data, lag): df = data.copy() for i in range(1, lag+1): df[f'lag_{i}'] = df['Temp'].shift(i) df.dropna(inplace=True) return df def prepare_data(df, lag): data = create_lag_features(df, lag) X = data.drop(columns='Temp').values y = data['Temp'].values return X, y def train_evaluate_model(X, y, n_splits=5): tscv = TimeSeriesSplit(n_splits=n_splits) lr_rmse = [] dt_rmse = [] vr_rmse = [] for train_idx, test_idx in tscv.split(X): X_train, X_test = X[train_idx], X[test_idx] y_train, y_test = y[train_idx], y[test_idx] # Linear Regression lr = LinearRegression() lr.fit(X_train, y_train) lr_pred = lr.predict(X_test) lr_rmse.append(np.sqrt(mean_squared_error(y_test, lr_pred))) # Decision Tree Regressor dt = DecisionTreeRegressor() dt.fit(X_train, y_train) dt_pred = dt.predict(X_test) dt_rmse.append(np.sqrt(mean_squared_error(y_test, dt_pred))) # Voting Regressor vr = VotingRegressor([('lr', lr), ('dt', dt)]) vr.fit(X_train, y_train) vr_pred = vr.predict(X_test) vr_rmse.append(np.sqrt(mean_squared_error(y_test, vr_pred))) return lr_rmse, dt_rmse, vr_rmse def plot_predictions(df, model, lag): data = create_lag_features(df, lag) X = data.drop(columns='Temp').values y = data['Temp'].values model.fit(X, y) predictions = model.predict(X) plt.figure(figsize=(14, 7)) plt.plot(df.index, df['Temp'], label='Actual') plt.plot(data.index, predictions, label='Predicted') plt.xlabel('Date') plt.ylabel('Temperature') plt.legend() plt.show() url = 'https://raw.githubusercontent.com/jbrownlee/Datasets/master/daily-min-temperatures.csv' df = load_data(url) lag = 7 X, y = prepare_data(df, lag) lr_rmse, dt_rmse, vr_rmse = train_evaluate_model(X, y, n_splits=5) print(f\\"Linear Regression RMSE: {np.mean(lr_rmse):.4f}\\") print(f\\"Decision Tree Regressor RMSE: {np.mean(dt_rmse):.4f}\\") print(f\\"Voting Regressor RMSE: {np.mean(vr_rmse):.4f}\\") # Compare predictions vr = VotingRegressor([('lr', LinearRegression()), ('dt', DecisionTreeRegressor())]) plot_predictions(df, vr, lag)"},{"question":"from typing import List def largest_elements(nums: List[int], k: int) -> List[int]: Given a list of integers, return the first \`k\` largest elements in descending order. You are not allowed to use built-in sorting functions like \`sorted()\` or \`sort()\`. Instead, use a heap data structure to achieve the result efficiently. If \`k\` is greater than the number of elements in the list, return the entire list sorted in descending order. Parameters: nums (List[int]): A list of integers which may contain both positive and negative values. k (int): An integer representing the number of largest elements to return. Returns: List[int]: A list of \`k\` largest integers from the input list sorted in descending order. Examples: >>> largest_elements([3, 1, 5, 12, 2, 11, 15, 8], 3) [15, 12, 11] >>> largest_elements([3, 1, 5, 12, 2, 11, 15, 8], 5) [15, 12, 11, 8, 5] >>> largest_elements([3, 1, 5, 12], 6) [12, 5, 3, 1] from solution import largest_elements def test_single_element(): assert largest_elements([12], 1) == [12] def test_k_equals_length(): assert largest_elements([3, 1, 5, 12], 4) == [12, 5, 3, 1] def test_k_greater_than_length(): assert largest_elements([3, 1, 5, 12], 6) == [12, 5, 3, 1] def test_more_elements(): assert largest_elements([3, 1, 5, 12, 2, 11, 15, 8], 3) == [15, 12, 11] def test_five_largest(): assert largest_elements([3, 1, 5, 12, 2, 11, 15, 8], 5) == [15, 12, 11, 8, 5] def test_mixed_signs(): assert largest_elements([-1, -2, -3, 0, 1, 2, 3], 4) == [3, 2, 1, 0] def test_all_negative(): assert largest_elements([-10, -20, -30, -1], 2) == [-1, -10] def test_k_is_one(): assert largest_elements([3, 15, 7, 22, -5, 0], 1) == [22]","solution":"from typing import List import heapq def largest_elements(nums: List[int], k: int) -> List[int]: Returns the first k largest elements in descending order from the given list of integers. if k >= len(nums): return sorted(nums, reverse=True) min_heap = nums[:k] heapq.heapify(min_heap) # Create a min-heap of the first k elements # Iterate through the remaining elements for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) # Sort the heap in descending order to return the result return sorted(min_heap, reverse=True)"},{"question":"def longest_substring_with_2_distinct_chars(s: str) -> str: Function to identify the longest substring that contains at most two distinct characters. >>> longest_substring_with_2_distinct_chars(\\"\\") \\"\\" >>> longest_substring_with_2_distinct_chars(\\"a\\") \\"a\\" >>> longest_substring_with_2_distinct_chars(\\"aa\\") \\"aa\\" >>> longest_substring_with_2_distinct_chars(\\"ab\\") \\"ab\\" >>> longest_substring_with_2_distinct_chars(\\"abcdef\\") \\"ab\\" >>> longest_substring_with_2_distinct_chars(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> longest_substring_with_2_distinct_chars(\\"abaccc\\") \\"accc\\" >>> longest_substring_with_2_distinct_chars(\\"aaaaaa\\") \\"aaaaaa\\" >>> longest_substring_with_2_distinct_chars(\\"aabbaac\\") \\"aabbaa\\"","solution":"def longest_substring_with_2_distinct_chars(s): Function to find the longest substring containing at most two distinct characters. n = len(s) if n < 3: return s left = 0 right = 0 hashmap = {} max_len = 2 max_substring = s[0:2] while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 if right - left > max_len: max_len = right - left max_substring = s[left:right] return max_substring"},{"question":"def manage_secrets_and_setup_ci_cd() -> str: Provides instructions on how to manage secrets effectively in a Kubernetes environment and set up a CI/CD pipeline to ensure zero downtime deployment. >>> result = manage_secrets_and_setup_ci_cd() >>> \\"Kubernetes Secrets\\" in result True >>> \\"base64 encoded value\\" in result True >>> \\"Use External Secrets Management Tools\\" in result True >>> \\"CI/CD Pipeline setup for zero downtime deployment\\" in result True >>> \\"Blue-Green Deployment strategy\\" in result True >>> \\"apiVersion: v1\\" in result True >>> \\"app: my-app-green\\" in result True >>> \\"kind: Service\\" in result True >>> \\"app: my-app-green\\" in result or \\"app: my-app-blue\\" in result True","solution":"def manage_secrets_and_setup_ci_cd(): Provides instructions on how to manage secrets effectively in a Kubernetes environment and set up a CI/CD pipeline to ensure zero downtime deployment. secrets_management = Effective secrets management in Kubernetes: 1. Use Kubernetes Secrets: - Create secrets using kubectl command or YAML configuration. - Reference secrets in your pods via environment variables or volumes. Example: yaml apiVersion: v1 kind: Secret metadata: name: my-secret type: Opaque data: username: YWRtaW4= # base64 encoded value for 'admin' password: MWYyZDFlMmU2N2Rm # base64 encoded value for '1f2d1e2e67df' To reference secrets in a pod: yaml apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mycontainer image: myimage env: - name: USERNAME valueFrom: secretKeyRef: name: my-secret key: username - name: PASSWORD valueFrom: secretKeyRef: name: my-secret key: password 2. Use External Secrets Management Tools: - Tools like HashiCorp Vault, AWS Secrets Manager, or Azure Key Vault. - Integrate these tools with Kubernetes using controllers/operators to sync secrets into Kubernetes secrets. CI/CD Pipeline setup for zero downtime deployment: 1. Use a CI/CD tool (e.g., Jenkins, GitLab CI, Github Actions) to automate build, test, and deployment processes. 2. Implement the Blue-Green Deployment strategy: - Create two identical environments called Blue and Green. - Route traffic to one environment (e.g., Blue) while deploying the new version to the other (e.g., Green). - Once the deployment is successful in the Green environment, switch the traffic to the Green environment. - Rollback can be easy by switching back to the Blue environment if something goes wrong. Example with Kubernetes: yaml apiVersion: apps/v1 kind: Deployment metadata: name: my-app-green spec: replicas: 3 selector: matchLabels: app: my-app-green template: metadata: labels: app: my-app-green spec: containers: - name: my-container image: my-new-version-image ports: - containerPort: 80 Use Kubernetes services to switch traffic: yaml apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app-green # or \`app: my-app-blue\` based on which environment should serve traffic ports: - protocol: TCP port: 80 targetPort: 80 return secrets_management"},{"question":"from typing import List def fibonacci_recursive(n: int) -> int: Returns the nth Fibonacci number using the recursive approach. >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(1) 1 >>> fibonacci_recursive(5) 5 >>> fibonacci_recursive(10) 55 def fibonacci_iterative(n: int) -> int: Returns the nth Fibonacci number using the iterative approach. >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(1) 1 >>> fibonacci_iterative(5) 5 >>> fibonacci_iterative(10) 55","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using the recursive approach. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_iterative(n): Returns the nth Fibonacci number using the iterative approach. if n < 0: raise ValueError(\\"Input should be a non-negative integer\\") a, b = 0, 1 for i in range(n): a, b = b, a + b return a"},{"question":"def filter_and_sort_even_numbers(arr: List[int]) -> List[int]: Returns a new array containing only the even numbers from the original array, sorted in ascending order. Parameters: - arr: List[int] - The input array of integers Returns: - List[int] - The list containing only even numbers sorted in ascending order Examples: >>> filter_and_sort_even_numbers([]) [] >>> filter_and_sort_even_numbers([1, 3, 5, 7]) [] >>> filter_and_sort_even_numbers([4, 2, 6, 8]) [2, 4, 6, 8] >>> filter_and_sort_even_numbers([1, 2, 3, 4, 5, 6, 7, 8]) [2, 4, 6, 8] >>> filter_and_sort_even_numbers([10, 21, 4, 20, 7, 2, 3, 8]) [2, 4, 8, 10, 20] >>> filter_and_sort_even_numbers([5, -2, 7, -8, -1, 6]) [-8, -2, 6]","solution":"def filter_and_sort_even_numbers(arr): Returns a new array containing only the even numbers from the original array, sorted in ascending order. Parameters: - arr: List[int] - The input array of integers Returns: - List[int] - The list containing only even numbers sorted in ascending order if not arr: return [] even_numbers = [num for num in arr if num % 2 == 0] even_numbers.sort() return even_numbers"},{"question":"def find_pair_with_sum(lst: List[int], target: int) -> tuple: Write a Python function that takes a list of integers and a target sum as arguments, and returns a tuple of two distinct numbers from the list that add up to the target sum. If no such pair exists, return an empty tuple. Test Cases: >>> find_pair_with_sum([2, 7, 11, 15], 9) == (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 8) == (3, 5) >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) == (-3, -5) >>> find_pair_with_sum([-1, 2, 3, -4, 5], 1) == (-1, 2) >>> find_pair_with_sum([1, 2, 3], 7) == () >>> find_pair_with_sum([10, 20, 30], 15) == () >>> find_pair_with_sum([], 5) == () >>> find_pair_with_sum([], 0) == () >>> find_pair_with_sum([5], 5) == () >>> find_pair_with_sum([0], 0) == ()","solution":"def find_pair_with_sum(lst, target): Returns a tuple of two distinct numbers from the list that add up to the target sum. If no such pair exists, returns an empty tuple. seen = set() for num in lst: complement = target - num if complement in seen: return (complement, num) seen.add(num) return ()"},{"question":"def rotate_matrix_90_degrees(matrix): Rotates the input square matrix 90 degrees clockwise. The function should take a 2D list (matrix) as its input and output the rotated matrix. Assume the input matrix is square (i.e., the number of rows is equal to the number of columns). If the input matrix is empty, return an empty list. >>> rotate_matrix_90_degrees([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_90_degrees([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> rotate_matrix_90_degrees([ [1, 2], [3, 4] ]) [ [3, 1], [4, 2] ] >>> rotate_matrix_90_degrees([]) [] >>> rotate_matrix_90_degrees([ [1] ]) [ [1] ] >>> rotate_matrix_90_degrees([ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ]) [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotate_matrix_90_degrees(matrix): Rotates the input square matrix 90 degrees clockwise. if not matrix: return [] n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def remove_duplicates(input_list): Removes duplicates from the input list while maintaining the original order of elements. :param input_list: List of elements which may contain duplicates :return: List of elements with duplicates removed, maintaining the original order >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([4, 5, 4, 6, 7, 7, 8, 8, 9]) [4, 5, 6, 7, 8, 9] >>> remove_duplicates(['apple', 'banana', 'apple', 'orange', 'banana', 'orange']) ['apple', 'banana', 'orange']","solution":"def remove_duplicates(input_list): Removes duplicates from the input list while maintaining the original order of elements. :param input_list: List of elements which may contain duplicates :return: List of elements with duplicates removed, maintaining the original order seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def number_to_words(n): Returns the English representation of the given integer. Handles numbers from 0 to 999, supports negative numbers by prefixing \\"negative\\", and returns an error for non-integer inputs. >>> number_to_words(42) \\"forty-two\\" >>> number_to_words(0) \\"zero\\" >>> number_to_words(11) \\"eleven\\" >>> number_to_words(305) \\"three hundred five\\" >>> number_to_words(-5) \\"negative five\\" >>> number_to_words(\\"forty-two\\") \\"Error: Input is not an integer\\"","solution":"def number_to_words(n): Returns the English representation of the given integer. Handles numbers from 0 to 999, supports negative numbers by prefixing \\"negative\\", and returns an error for non-integer inputs. if not isinstance(n, int): return \\"Error: Input is not an integer\\" if n < 0: return \\"negative \\" + number_to_words(-n) units = [\\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] hundreds = [\\"\\", \\"one hundred\\", \\"two hundred\\", \\"three hundred\\", \\"four hundred\\", \\"five hundred\\", \\"six hundred\\", \\"seven hundred\\", \\"eight hundred\\", \\"nine hundred\\"] if n < 10: return units[n] elif n < 20: return teens[n-10] elif n < 100: return tens[n // 10] + (\\"-\\" + units[n % 10] if n % 10 != 0 else \\"\\") else: remainder = n % 100 return hundreds[n // 100] + (\\" \\" + number_to_words(remainder) if remainder != 0 else \\"\\")"},{"question":"def longest_subsequence(arr: List[int]) -> int: This function finds the length of the longest subsequence such that every adjacent element in the subsequence has a difference of either 1 or -1. :param arr: List of integers :return: Length of the longest subsequence with adjacent elements differing by 1 or -1 pass # Unit test cases def test_longest_subsequence_all_adjacent(): assert longest_subsequence([1, 2, 1, 2, 1, 2]) == 6 def test_longest_subsequence_non_adjacent(): assert longest_subsequence([1, 2, 4, 5, 7]) == 2 def test_longest_subsequence_mixed(): assert longest_subsequence([2, 3, 4, 6, 5, 6, 7]) == 4 def test_longest_subsequence_single_element(): assert longest_subsequence([5]) == 1 def test_longest_subsequence_empty_list(): assert longest_subsequence([]) == 0 def test_longest_subsequence_multiple_subsequences(): assert longest_subsequence([1, 2, 1, 5, 6, 7, 2, 3]) == 3","solution":"def longest_subsequence(arr): This function finds the length of the longest subsequence such that every adjacent element in the subsequence has a difference of either 1 or -1. :param arr: List of integers :return: Length of the longest subsequence with adjacent elements differing by 1 or -1 if not arr: return 0 longest_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) == 1: current_length += 1 else: longest_length = max(longest_length, current_length) current_length = 1 return max(longest_length, current_length)"},{"question":"def intersect_lists_preserve_order(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are present in both input lists, preserving the order they appear in the first list. If there are duplicated values in the first list, they should be included in the result the same number of times they appear in the first list, provided they also appear in the second list at least that many times. >>> intersect_lists_preserve_order([1, 2, 2, 3, 4, 5], [2, 2, 3, 6]) [2, 2, 3] >>> intersect_lists_preserve_order([1, 2, 3], [4, 5, 6]) []","solution":"def intersect_lists_preserve_order(list1, list2): Returns a list of integers that are present in both input lists, preserving the order they appear in the first list. If there are duplicated values in the first list, they should be included in the result the same number of times they appear in the first list, provided they also appear in the second list at least that many times. result = [] count_map = {} for num in list2: count_map[num] = count_map.get(num, 0) + 1 for num in list1: if count_map.get(num, 0) > 0: result.append(num) count_map[num] -= 1 return result"},{"question":"def transform_list(n: int, lst: List[int]) -> List[int]: Receives an integer 'n' and a list of integers 'lst'. Returns a new list containing only the even numbers from the original list, each multiplied by the square of 'n'. >>> transform_list(3, [1, 2, 3, 4, 5]) [18, 36] >>> transform_list(2, [1, 3, 5]) [] >>> transform_list(2, [2, 4, 6]) [8, 16, 24] >>> transform_list(4, []) [] >>> transform_list(2, [-2, -4, -1, -5]) [-8, -16] >>> transform_list(10, [1, 2, 3, 4]) [200, 400]","solution":"def transform_list(n, lst): Receives an integer 'n' and a list of integers 'lst'. Returns a new list containing only the even numbers from the original list, each multiplied by the square of 'n'. return [x * (n ** 2) for x in lst if x % 2 == 0]"},{"question":"def sort_books(books): Sorts a list of books based on 'year_published' in ascending order. If two books have the same year, they are sorted by 'author' alphabetically. If both the 'year_published' and 'author' are identical, they are sorted by 'title' alphabetically. >>> sort_books([ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author C\\", \\"year_published\\": 2022}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author C\\", \\"year_published\\": 2022}, {\\"title\\": \\"Book C\\", \\"author\\": \\"Author A\\", \\"year_published\\": 2021}, {\\"title\\": \\"Book D\\", \\"author\\": \\"Author B\\", \\"year_published\\": 2021} ]) [{'title': 'Book C', 'author': 'Author A', 'year_published': 2021}, {'title': 'Book D', 'author': 'Author B', 'year_published': 2021}, {'title': 'Book A', 'author': 'Author C', 'year_published': 2022}, {'title': 'Book B', 'author': 'Author C', 'year_published': 2022}] >>> sort_books([]) [] >>> sort_books([ {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year_published\\": 2022}, {\\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"year_published\\": 2022} ]) [{'title': 'Book A', 'author': 'Author A', 'year_published': 2022}, {'title': 'Book A', 'author': 'Author A', 'year_published': 2022}] >>> sort_books([ {\\"title\\": None, \\"author\\": 123, \\"year_published\\": 2022}, {\\"title\\": \\"Book B\\", \\"author\\": \\"Author A\\", \\"year_published\\": 2021} ]) [{'title': 'Book B', 'author': 'Author A', 'year_published': 2021}, {'title': None, 'author': 123, 'year_published': 2022}]","solution":"def sort_books(books): Sorts a list of books based on 'year_published' in ascending order. If two books have the same year, they are sorted by 'author' alphabetically. If both the 'year_published' and 'author' are identical, they are sorted by 'title' alphabetically. books.sort(key=lambda x: (x[\\"year_published\\"], x.get(\\"author\\", \\"\\"), x.get(\\"title\\", \\"\\"))) return books"},{"question":"from typing import List, Dict def haversine(lon1: float, lat1: float, lon2: float, lat2: float) -> float: Calculate the great-circle distance between two points on the Earth surface using the Haversine formula. pass def find_nearest_store(stores: List[Dict[str, float]], location: Dict[str, float]) -> str: Returns the name of the store closest to the given location. Parameters: - stores: list of dictionaries with 'name', 'longitude', 'latitude'. - location: dictionary with 'longitude' and 'latitude'. >>> stores = [ {'name': 'Store A', 'longitude': -75.343, 'latitude': 39.984}, {'name': 'Store B', 'longitude': -75.534, 'latitude': 39.984}, {'name': 'Store C', 'longitude': -75.834, 'latitude': 38.984} ] >>> location = {'longitude': -75.343, 'latitude': 39.984} >>> find_nearest_store(stores, location) 'Store A' >>> location = {'longitude': -75.534, 'latitude': 39.984} >>> find_nearest_store(stores, location) 'Store B' >>> location = {'longitude': -75.834, 'latitude': 38.984} >>> find_nearest_store(stores, location) 'Store C' pass","solution":"import math def haversine(lon1, lat1, lon2, lat2): Calculate the great-circle distance between two points on the Earth surface using the Haversine formula. # Convert decimal degrees to radians lon1, lat1, lon2, lat2 = map(math.radians, [lon1, lat1, lon2, lat2]) # Haversine formula dlon = lon2 - lon1 dlat = lat2 - lat1 a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2 c = 2 * math.asin(math.sqrt(a)) r = 6371 # Radius of earth in kilometers. Use 3956 for miles. return c * r def find_nearest_store(stores, location): Returns the name of the store closest to the given location. Parameters: - stores: list of dictionaries with 'name', 'longitude', 'latitude'. - location: dictionary with 'longitude' and 'latitude'. closest_store = None min_distance = float('inf') for store in stores: distance = haversine(store['longitude'], store['latitude'], location['longitude'], location['latitude']) if distance < min_distance: min_distance = distance closest_store = store['name'] return closest_store"},{"question":"from typing import List, Tuple def task_scheduler(tasks: List[Tuple[str, int, int]]) -> List[str]: Simulates a simple task scheduler which handles multiple tasks with different priorities. Tasks are executed in the order of their priority and appearance. Parameters: tasks (list of tuples): List of tasks where each task is a tuple (task_name, duration, priority). Returns: list: The order in which tasks are executed. >>> tasks = [ ... (\\"Task1\\", 3, 1), ... (\\"Task2\\", 2, 3), ... (\\"Task3\\", 1, 2), ... (\\"Task4\\", 2, 2), ... (\\"Task5\\", 4, 1) ... ] >>> task_scheduler(tasks) [\\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task1\\", \\"Task5\\"] >>> tasks = [ ... (\\"Task1\\", 3, 1) ... ] >>> task_scheduler(tasks) [\\"Task1\\"] >>> tasks = [ ... (\\"Task1\\", 3, 1), ... (\\"Task2\\", 2, 1), ... (\\"Task3\\", 1, 1), ... (\\"Task4\\", 2, 1), ... (\\"Task5\\", 4, 1) ... ] >>> task_scheduler(tasks) [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task5\\"] >>> tasks = [ ... (\\"Task1\\", 3, 2), ... (\\"Task2\\", 2, 3), ... (\\"Task3\\", 1, 1), ... (\\"Task4\\", 2, 2), ... (\\"Task5\\", 4, 3) ... ] >>> task_scheduler(tasks) [\\"Task2\\", \\"Task5\\", \\"Task1\\", \\"Task4\\", \\"Task3\\"] >>> tasks = [] >>> task_scheduler(tasks) []","solution":"def task_scheduler(tasks): Simulates a simple task scheduler which handles multiple tasks with different priorities. Tasks are executed in the order of their priority and appearance. Parameters: tasks (list of tuples): List of tasks where each task is a tuple (task_name, duration, priority). Returns: list: The order in which tasks are executed. tasks_sorted = sorted(tasks, key=lambda x: (-x[2], tasks.index(x))) execution_order = [] while tasks_sorted: task = tasks_sorted.pop(0) execution_order.append(task[0]) return execution_order # Example input tasks = [ (\\"Task1\\", 3, 1), (\\"Task2\\", 2, 3), (\\"Task3\\", 1, 2), (\\"Task4\\", 2, 2), (\\"Task5\\", 4, 1) ] print(task_scheduler(tasks)) # Expected: [\\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task1\\", \\"Task5\\"]"},{"question":"def filter_even_and_divisible_by_3(nums): Returns a list of numbers that are both even and divisible by 3. Parameters: nums (list): A list of integers. Returns: list: A list containing numbers that are both even and divisible by 3. >>> filter_even_and_divisible_by_3([15, 24, 40, 33, 36, 45, 90]) [24, 36, 90] >>> filter_even_and_divisible_by_3([15, 33, 45, 21]) [] >>> filter_even_and_divisible_by_3([6, 12, 18, 20]) [6, 12, 18] >>> filter_even_and_divisible_by_3([2, 5, 7, 9, 10, 15, 21]) [] >>> filter_even_and_divisible_by_3([]) []","solution":"def filter_even_and_divisible_by_3(nums): Returns a list of numbers that are both even and divisible by 3. Parameters: nums (list): A list of integers. Returns: list: A list containing numbers that are both even and divisible by 3. return [num for num in nums if num % 2 == 0 and num % 3 == 0]"},{"question":"def binary_to_hex(binary_str: str) -> str: Convert binary string to its equivalent hexadecimal representation as lowercase string. Input is guaranteed to be a non-empty binary string (consisting only of '0' and '1' characters). Examples: >>> binary_to_hex('11010') == '1a' >>> binary_to_hex('101010111100110111101111') == 'abcdef' >>> binary_to_hex('1111') == 'f'","solution":"def binary_to_hex(binary_str): Convert binary string to its equivalent hexadecimal representation as lowercase string. Input is guaranteed to be a non-empty binary string (consisting only of '0' and '1' characters). Examples: >>> binary_to_hex('11010') == '1a' >>> binary_to_hex('101010111100110111101111') == 'abcdef' >>> binary_to_hex('1111') == 'f' # First, convert the binary string to an integer decimal_value = int(binary_str, 2) # Then, format this integer as a hexadecimal string hex_value = format(decimal_value, 'x') return hex_value"},{"question":"def char_frequency(s): Takes a string and returns a dictionary where each key is a unique character from the string and the value is the number of times that character appears in the string. :param s: String to be analyzed :return: Dictionary with character frequencies :raises TypeError: If the input is not a string >>> char_frequency(\\"HelloWorld\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"\\") == {} >>> char_frequency(\\"a\\") == {'a': 1} >>> char_frequency(\\"aaaa\\") == {'a': 4} >>> char_frequency(\\"AaAa\\") == {'A': 2, 'a': 2} >>> char_frequency(\\"123!123!\\") == {'1': 2, '2': 2, '3': 2, '!': 2} >>> char_frequency(\\"a b c a\\") == {'a': 2, ' ': 3, 'b': 1, 'c': 1}","solution":"def char_frequency(s): Takes a string and returns a dictionary where each key is a unique character from the string and the value is the number of times that character appears in the string. :param s: String to be analyzed :return: Dictionary with character frequencies :raises TypeError: If the input is not a string if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def first_non_repeating(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeated or the input string is empty, it returns \\"No unique character found\\". >>> first_non_repeating(\\"swiss\\") \\"w\\" >>> first_non_repeating(\\"programming\\") \\"p\\" >>> first_non_repeating(\\"aabbcc\\") \\"No unique character found\\" >>> first_non_repeating(\\"\\") \\"No unique character found\\" >>> first_non_repeating(\\"a\\") \\"a\\" >>> first_non_repeating(\\"ab@cd@!\\") \\"a\\"","solution":"def first_non_repeating(s): Returns the first non-repeating character in the string s. If all characters are repeated or the input string is empty, it returns \\"No unique character found\\". if not s: return \\"No unique character found\\" char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return \\"No unique character found\\""},{"question":"def zigzag_array(arr: List[int]) -> List[int]: Rearranges the elements of the input array in a zigzag fashion without modifying the input array. The resultant array has elements arranged in such a manner that every alternate element is greater than its previous element. >>> zigzag_array([]) == [] >>> zigzag_array([1]) == [1] >>> zigzag_array([2, 1]) in [[1, 2], [2, 1]] >>> result = zigzag_array([4, 3, 7, 8, 6, 2, 1]) all((i % 2 == 0 and result[i] <= result[i + 1]) or (i % 2 != 0 and result[i] >= result[i + 1]) for i in range(len(result) - 1)) >>> result = zigzag_array([10, 20, 30, 40, 50, 60]) all((i % 2 == 0 and result[i] <= result[i + 1]) or (i % 2 != 0 and result[i] >= result[i + 1]) for i in range(len(result) - 1)) >>> result = zigzag_array([1, 1, 1, 1, 1]) all((i % 2 == 0 and result[i] <= result[i + 1]) or (i % 2 != 0 and result[i] >= result[i + 1]) for i in range(len(result) - 1))","solution":"def zigzag_array(arr): Rearranges the elements of arr in a zigzag fashion without modifying the input array. The resultant array has elements arranged in such a manner that every alternate element is greater than its previous element. Parameters: arr (list): List of integers to be rearranged. Returns: list: New list containing the elements arranged in zigzag fashion. if len(arr) < 2: return arr[:] sorted_arr = sorted(arr) result = [0] * len(arr) left, right = 0, len(arr) - 1 for i in range(len(arr)): if i % 2 == 0: result[i] = sorted_arr[left] left += 1 else: result[i] = sorted_arr[right] right -= 1 return result"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverses each word in the given sentence while maintaining the word order. Parameters: sentence (str): The input sentence Returns: str: The sentence with each word reversed >>> reverse_words_in_sentence(\\"Hello\\") == \\"olleH\\" >>> reverse_words_in_sentence(\\"Hello world from AI\\") == \\"olleH dlrow morf IA\\" >>> reverse_words_in_sentence(\\"\\") == \\"\\" >>> reverse_words_in_sentence(\\"Hello, world!\\") == \\",olleH !dlrow\\" >>> reverse_words_in_sentence(\\" Hello world from AI \\") == \\"olleH dlrow morf IA\\"","solution":"def reverse_words_in_sentence(sentence): Reverses each word in the given sentence while maintaining the word order. Parameters: sentence (str): The input sentence Returns: str: The sentence with each word reversed words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List, Optional def find_largest_integer(numbers: List[int]) -> Optional[int]: Finds the largest integer in a list composed of positive and negative integers. Returns the largest integer found or None if the list is empty. >>> find_largest_integer([1, 2, 3, 4, 5]) == 5 >>> find_largest_integer([-1, -2, -3, -4, -5]) == -1 >>> find_largest_integer([]) == None >>> find_largest_integer([-1, 2, 3, -4, 5]) == 5 >>> find_largest_integer([10]) == 10 >>> find_largest_integer([3, 3, 3, 3, 3]) == 3 >>> find_largest_integer([1, 3, 5, 5, 2]) == 5","solution":"def find_largest_integer(numbers): Finds the largest integer in a list composed of positive and negative integers. Returns the largest integer found or None if the list is empty. if not numbers: return None return max(numbers)"},{"question":"def reverse_string(s: str): Prints the reverse of the given string s. >>> reverse_string(\\"hello\\") olleh >>> reverse_string(\\"Python\\") nohtyP >>> reverse_string(\\"\\") >>> reverse_string(\\"12345\\") 54321 >>> reverse_string(\\"a\\") a >>> reverse_string(\\"racecar\\") racecar","solution":"def reverse_string(s): Prints the reverse of the given string s. reversed_string = s[::-1] print(reversed_string)"},{"question":"from collections import Counter from typing import List, Tuple def gini_impurity(labels: List[int]) -> float: Calculate the Gini impurity for a given set of class labels. Args: labels (list): List of class labels. Returns: float: Gini impurity value. pass def split_dataset(dataset: List[List[float]], attribute_index: int, attribute_value: float) -> Tuple[List[List[float]], List[List[float]]]: Split the dataset based on an attribute and its value. Args: dataset (list): List of samples with attributes and class labels. attribute_index (int): Index of the attribute to split on. attribute_value (float): Value to split the attribute by. Returns: tuple: Two lists representing the left and right splits of the dataset. pass def gini_impurity_split(left_split: List[List[float]], right_split: List[List[float]]) -> float: Calculate the Gini impurity of a split dataset. Args: left_split (list): Left split of the dataset. right_split (list): Right split of the dataset. Returns: float: Gini impurity of the split. pass def test_gini_impurity(): assert gini_impurity([1, 1, 1, 1]) == 0.0 assert gini_impurity([1, 0, 0, 0]) == 0.375 assert gini_impurity([1, 0, 1, 0]) == 0.5 assert gini_impurity([]) == 0.0 def test_split_dataset(): dataset = [ [2.5, 1], [1.5, 0], [3.5, 1], [2.0, 0] ] left_split, right_split = split_dataset(dataset, 0, 2.0) assert left_split == [[1.5, 0], [2.0, 0]] assert right_split == [[2.5, 1], [3.5, 1]] def test_gini_impurity_split(): dataset = [ [2.5, 1], [1.5, 0], [3.5, 1], [2.0, 0] ] left_split, right_split = split_dataset(dataset, 0, 2.0) impurity = gini_impurity_split(left_split, right_split) assert impurity == 0.5 * gini_impurity([0, 0]) + 0.5 * gini_impurity([1, 1])","solution":"from collections import Counter def gini_impurity(labels): Calculate the Gini impurity for a given set of class labels. Args: labels (list): List of class labels. Returns: float: Gini impurity value. n = len(labels) if n == 0: return 0.0 label_counts = Counter(labels) impurity = 1.0 for count in label_counts.values(): prob = count / n impurity -= prob ** 2 return impurity # Example usage of the Gini impurity function in a decision tree splitting scenario def split_dataset(dataset, attribute_index, attribute_value): left_split = [row for row in dataset if row[attribute_index] <= attribute_value] right_split = [row for row in dataset if row[attribute_index] > attribute_value] return left_split, right_split def gini_impurity_split(left_split, right_split): n_left = len(left_split) n_right = len(right_split) n_total = n_left + n_right if n_total == 0: return 0.0 labels_left = [row[-1] for row in left_split] labels_right = [row[-1] for row in right_split] weight_left = n_left / n_total weight_right = n_right / n_total impurity = (weight_left * gini_impurity(labels_left) + weight_right * gini_impurity(labels_right)) return impurity # Gini impurity influences the choice of splitting attribute in decision tree building: # A decision tree algorithm aims to split the dataset at each node in a way that maximizes # the homogeneity of the resulting sub-nodes. The attribute and its value that minimize # the Gini impurity after the split are chosen."},{"question":"def positional_appearance(input_list): Write a Python function that takes a list of integers and returns a list of strings representing each integer's positional appearance in the list. If an integer appears multiple times in the list, append the string \\" (duplicate)\\" to its positional appearance. For example, in the list [3, 5, 3, 7], the output should be [\\"first\\", \\"second\\", \\"third (duplicate)\\", \\"fourth\\"]. Parameters: input_list (list): List of integers Returns: list: List of strings representing each integer's positional appearance Examples: >>> positional_appearance([5, 10, 15]) [\\"first\\", \\"second\\", \\"third\\"] >>> positional_appearance([5, 5, 5]) [\\"first\\", \\"second (duplicate)\\", \\"third (duplicate)\\"] >>> positional_appearance([10, 22, 10, 35, 22, 50, 22]) [\\"first\\", \\"second\\", \\"third (duplicate)\\", \\"fourth\\", \\"fifth (duplicate)\\", \\"sixth\\", \\"seventh (duplicate)\\"] >>> positional_appearance([42]) [\\"first\\"] >>> positional_appearance([]) []","solution":"def positional_appearance(input_list): This function takes a list of integers and returns a list of strings representing each integer's positional appearance in the list. If an integer appears multiple times in the list, \\" (duplicate)\\" is appended to its label. Parameters: input_list (list): List of integers Returns: list: List of strings representing each integer's positional appearance position_words = [\\"first\\", \\"second\\", \\"third\\", \\"fourth\\", \\"fifth\\", \\"sixth\\", \\"seventh\\", \\"eighth\\", \\"ninth\\", \\"tenth\\", \\"eleventh\\", \\"twelfth\\", \\"thirteenth\\", \\"fourteenth\\", \\"fifteenth\\", \\"sixteenth\\", \\"seventeenth\\", \\"eighteenth\\", \\"nineteenth\\", \\"twentieth\\"] count = {} result = [] for idx, num in enumerate(input_list): if num in count: count[num] += 1 result.append(f\\"{position_words[idx]} (duplicate)\\") else: count[num] = 1 result.append(position_words[idx]) return result input_list = [10, 22, 10, 35, 22, 50, 22] print(positional_appearance(input_list)) # expected output: ['first', 'second', 'third (duplicate)', 'fourth', 'fifth (duplicate)', 'sixth', 'seventh (duplicate)']"},{"question":"def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome('A man, a plan, a canal, Panama') == True >>> is_palindrome('race a car') == False >>> is_palindrome('') == True >>> is_palindrome('a') == True >>> is_palindrome('A') == True >>> is_palindrome('12321') == True >>> is_palindrome('1a2b2a1') == True >>> is_palindrome('Able , was I saw eLba') == True >>> is_palindrome('12345') == False >>> is_palindrome('This is definitely not a palindrome!') == False","solution":"def is_palindrome(s): Checks if the input string is a palindrome, ignoring case and non-alphanumeric characters. # Normalize the string by converting it to lowercase normalized_string = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string is the same forward and backward return normalized_string == normalized_string[::-1]"},{"question":"from typing import List def sort_even_numbers(int_list: List[int]) -> List[int]: Write a Python function that takes a list of integers as input and returns a list of those integers sorted in ascending order, but only include the integers that are even. >>> sort_even_numbers([4, 2, 8, 6]) [2, 4, 6, 8] >>> sort_even_numbers([1, 3, 6, 4, 5, 2]) [2, 4, 6] >>> sort_even_numbers([1, 3, 5, 7]) [] >>> sort_even_numbers([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_even_numbers([-2, -4, 1, 3, -6, 4, 7]) [-6, -4, -2, 4] >>> sort_even_numbers([]) []","solution":"def sort_even_numbers(int_list): Returns a list of sorted even numbers from the input list. Params: int_list (list of int): The list of integers to process. Returns: list of int: The list of sorted even integers. even_numbers = [num for num in int_list if num % 2 == 0] return sorted(even_numbers)"},{"question":"def longest_arith_seq_length(arr): Given an array of integers arr, find the length of the longest arithmetic subsequence in arr. An arithmetic sequence is defined as a sequence of numbers with the same difference between consecutive terms. You need to return the length of the longest arithmetic subsequence found. >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 >>> longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) 4 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([1, 2]) 2 >>> longest_arith_seq_length([1, 3, 5, 7, 9]) 5 >>> longest_arith_seq_length([1, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10]) 6","solution":"def longest_arith_seq_length(arr): if not arr: return 0 dp = {} longest_length = 0 for i in range(len(arr)): for j in range(i + 1, len(arr)): diff = arr[j] - arr[i] dp[(j, diff)] = dp.get((i, diff), 1) + 1 longest_length = max(longest_length, dp[(j, diff)]) return longest_length"},{"question":"def books_after_donation(total_books: int, friends: int) -> int: Calculates the number of books each friend keeps after donating half of their received books. :param total_books: Total number of books Erin has :param friends: Number of friends among whom the books are to be divided :return: Number of books each friend keeps after their donation >>> books_after_donation(24, 4) 3 >>> books_after_donation(0, 4) 0 >>> books_after_donation(24, 1) 12 >>> books_after_donation(25, 4) 3","solution":"def books_after_donation(total_books, friends): Calculates the number of books each friend keeps after donating half of their received books. :param total_books: Total number of books Erin has :param friends: Number of friends among whom the books are to be divided :return: Number of books each friend keeps after their donation # Each friend receives an equal number of books books_per_friend = total_books // friends # Each friend donates half of their received books books_donated_per_friend = books_per_friend // 2 # Books kept by each friend books_kept_per_friend = books_per_friend - books_donated_per_friend return books_kept_per_friend"},{"question":"from typing import List, Tuple def alternating_sums(numbers: List[int]) -> Tuple[int, int]: Given a list of integers, splits the list into two alternating groups, calculates the sum of each group, and returns a tuple containing the two sums. The first element of the tuple should be the sum of the first group, and the second element should be the sum of the second group. >>> alternating_sums([50, 60, 60, 45, 70]) (180, 105) >>> alternating_sums([100, 50]) (100, 50) >>> alternating_sums([80]) (80, 0)","solution":"from typing import List, Tuple def alternating_sums(numbers: List[int]) -> Tuple[int, int]: sum1, sum2 = 0, 0 for i, number in enumerate(numbers): if i % 2 == 0: sum1 += number else: sum2 += number return sum1, sum2"},{"question":"class BankAccount: A class representing a bank account with methods to manage deposits, withdrawals, balance checks, and transfers. Each BankAccount object has a unique account number generated at the time of creation. Attributes: account_holder_name (str): The name of the account holder. account_number (int): The unique account number. balance (float): The current balance in the account. Methods: deposit(amount: float): Deposits the specified amount into the account. withdraw(amount: float): Withdraws the specified amount from the account. get_balance() -> float: Returns the current balance. transfer(amount: float, to_account: 'BankAccount'): Transfers the specified amount to another account. get_account_details() -> dict: Returns the details of the account. _account_number_counter = 1000 # Class variable for generating unique account numbers def __init__(self, name: str): self.account_holder_name = name self.account_number = BankAccount._account_number_counter BankAccount._account_number_counter += 1 self.balance = 0.0 def deposit(self, amount: float): Deposit money into the account. Args: amount (float): The amount of money to be deposited. Raises: ValueError: If the deposit amount is negative. pass def withdraw(self, amount: float): Withdraw money from the account. Args: amount (float): The amount of money to be withdrawn. Raises: ValueError: If the withdrawal amount is negative or greater than the current balance. pass def get_balance(self) -> float: Get the current balance of the account. Returns: float: The current balance. pass def transfer(self, amount: float, to_account: 'BankAccount'): Transfer money to another bank account. Args: amount (float): The amount of money to be transferred. to_account (BankAccount): The account to which the money should be transferred. Raises: ValueError: If the recipient is not a valid BankAccount object or if insufficient funds exist. pass def get_account_details(self) -> dict: Get the account details. Returns: dict: A dictionary containing the account holder's name, account number, and current balance. pass","solution":"class BankAccount: _account_number_counter = 1000 # Class variable for generating unique account numbers def __init__(self, name): self.account_holder_name = name self.account_number = BankAccount._account_number_counter BankAccount._account_number_counter += 1 self.balance = 0.0 def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdraw amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def get_balance(self): return self.balance def transfer(self, amount, to_account): if not isinstance(to_account, BankAccount): raise ValueError(\\"The recipient must be a valid BankAccount object.\\") self.withdraw(amount) to_account.deposit(amount) def get_account_details(self): return { 'account_holder_name': self.account_holder_name, 'account_number': self.account_number, 'balance': self.balance }"},{"question":"def eligible_students(students): Returns a list of student names who have completed 120 or more credits, sorted by their GPA in descending order. If two students have the same GPA, they are listed in alphabetical order by their names. >>> eligible_students([ ('Alice Johnson', 3.6, 130), ('Bob Smith', 3.9, 115), ('Carol White', 3.7, 140), ('Dave Brown', 3.9, 120) ]) == ['Dave Brown', 'Carol White', 'Alice Johnson'] >>> eligible_students([ ('Alice Johnson', 3.6, 100), ('Bob Smith', 3.9, 110) ]) == []","solution":"def eligible_students(students): Returns a list of student names who have completed 120 or more credits, sorted by their GPA in descending order. If two students have the same GPA, they are listed in alphabetical order by their names. eligible = [student for student in students if student[2] >= 120] sorted_eligible = sorted(eligible, key=lambda x: (-x[1], x[0])) return [student[0] for student in sorted_eligible] # Example usage: students = [('Alice Johnson', 3.6, 130), ('Bob Smith', 3.9, 115), ('Carol White', 3.7, 140), ('Dave Brown', 3.9, 120)] print(eligible_students(students)) # Output: ['Dave Brown', 'Carol White', 'Alice Johnson']"},{"question":"def decode_message(k: int, s: str) -> str: Decodes the encoded string s by shifting each alphabetic character backwards by k positions in the alphabet. Non-alphabetic characters remain unchanged. Parameters: k (int): the number of positions to shift each character backwards s (string): the encoded string to decode Returns: string: the decoded string Examples: >>> decode_message(3, \\"dwwdfn\\") 'attack' >>> decode_message(1, \\"uifsf!ibt!cffo!b!csfbluispvhi\\") 'there!has!been!a!breakthrough' >>> decode_message(5, \\"MJQQT\\") 'HELLO' >>> decode_message(2, \\"BcdeFg\\") 'ZabcDe' >>> decode_message(3, \\"Hello, World!\\") 'Ebiil, Tloia!' >>> decode_message(1, \\"aaa\\") 'zzz' >>> decode_message(27, \\"bbb\\") 'aaa' >>> decode_message(5, \\"\\") '' >>> decode_message(4, \\"123!@#\\") '123!@#' # Your code to implement functionality comes here","solution":"def decode_message(k: int, s: str) -> str: Decodes the encoded string s by shifting each alphabetic character backwards by k positions in the alphabet. Non-alphabetic characters remain unchanged. Parameters: k (int): the number of positions to shift each character backwards s (string): the encoded string to decode Returns: string: the decoded string decoded_chars = [] shift = k % 26 # To handle cases where k is greater than 26. for char in s: if char.isalpha(): if char.islower(): # wrap-around within the lowercase letters new_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a')) else: # wrap-around within the uppercase letters new_char = chr((ord(char) - ord('A') - shift) % 26 + ord('A')) decoded_chars.append(new_char) else: decoded_chars.append(char) return ''.join(decoded_chars)"},{"question":"from typing import List, Dict def frequency_counter(lst: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the integers from the list and the values are the frequencies of those integers in the list. Args: lst (List[int]): A list of integers. Returns: Dict[int, int]: A dictionary with integers as keys and their frequencies as values. Examples: >>> frequency_counter([]) == {} >>> frequency_counter([5]) == {5: 1} >>> frequency_counter([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} >>> frequency_counter([-1, -1, 0, 1, 2, 2]) == {-1: 2, 0: 1, 1: 1, 2: 2} >>> frequency_counter(list(range(1000)) + list(range(500))) == {i: 2 for i in range(500)} | {i: 1 for i in range(500, 1000)}","solution":"def frequency_counter(lst): Returns a dictionary where the keys are the integers from the list and the values are the frequencies of those integers in the list. frequency = {} for number in lst: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 return frequency"},{"question":"[Completion Task in Python] def calculate(expression: str) -> int: Calculate the result of a mathematical expression string that includes integers, addition, subtraction, multiplication, and division, while properly handling operator precedence and parentheses. >>> calculate(\\"3 + 2 * 2\\") # should return 7 >>> calculate(\\"3/2\\") # should return 1 >>> calculate(\\"3 + 5 / 2\\") # should return 5 >>> calculate(\\"(2+3)*2\\") # should return 10 from solution import calculate def test_simple_addition(): assert calculate(\\"3 + 2\\") == 5 def test_simple_subtraction(): assert calculate(\\"10 - 3\\") == 7 def test_simple_multiplication(): assert calculate(\\"4 * 2\\") == 8 def test_simple_division(): assert calculate(\\"8 / 2\\") == 4 def test_mixed_operations(): assert calculate(\\"3 + 2 * 2\\") == 7 assert calculate(\\"3/2\\") == 1 assert calculate(\\"3 + 5 / 2\\") == 5 def test_with_parentheses(): assert calculate(\\"(2+3)*2\\") == 10 assert calculate(\\"2 * (3 + 5)\\") == 16 assert calculate(\\"2 * (3 + (2 * 2))\\") == 14 def test_with_spaces(): assert calculate(\\" 3 + 2 * 2 \\") == 7 assert calculate(\\" 3 / 2 \\") == 1 assert calculate(\\" 3 + 5 / 2 \\") == 5 def test_nested_parentheses(): assert calculate(\\"((2+3)*2)+1\\") == 11 assert calculate(\\"(1+(4+5+2)-3)+(6+8)\\") == 23","solution":"def calculate(expression: str) -> int: def evaluate(tokens: list) -> int: stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = evaluate(tokens) if not token.isdigit() or not tokens: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) sign = token num = 0 if token == ')': break return sum(stack) tokens = [] for char in expression: if char == ' ': continue if char in '()+-*/': tokens.append(char) elif tokens and tokens[-1].isdigit(): tokens[-1] += char else: tokens.append(char) return evaluate(tokens)"},{"question":"def character_frequency(s: str) -> dict: Returns a dictionary with the frequency of each character in the input string. Characters are considered case-insensitively and spaces are ignored. :param s: The input string :type s: str :return: Dictionary with frequencies of characters :rtype: dict :raises TypeError: If the input is not a string pass class CharacterFrequency: def __init__(self, input_str: str): Initializes the CharacterFrequency with a string input, performs validation, and computes the frequency of characters. :param input_str: The input string :type input_str: str :raises TypeError: If the input is not a string pass def compute_frequency(self, s: str) -> dict: Computes the frequency of each character in the given string. :param s: The input string :type s: str :return: Dictionary with frequencies of characters :rtype: dict pass def sorted_frequency(self) -> dict: Returns the character frequency dictionary sorted by character. :return: Sorted dictionary of character frequencies :rtype: dict pass # Tests import pytest def test_character_frequency_simple(): result = character_frequency(\\"aabbcc\\") assert result == {'a': 2, 'b': 2, 'c': 2} def test_character_frequency_ignore_case(): result = character_frequency(\\"AaBbCc\\") assert result == {'a': 2, 'b': 2, 'c': 2} def test_character_frequency_ignore_spaces(): result = character_frequency(\\"a a b c\\") assert result == {'a': 2, 'b': 1, 'c': 1} def test_character_frequency_empty_string(): result = character_frequency(\\"\\") assert result == {} def test_character_frequency_non_string_input(): with pytest.raises(TypeError): character_frequency(123) def test_character_frequency_class_initialization(): cf = CharacterFrequency(\\"aabbcc\\") assert cf.input_str == 'aabbcc' assert cf.frequency == {'a': 2, 'b': 2, 'c': 2} def test_character_frequency_class_ignore_case(): cf = CharacterFrequency(\\"AaBbCc\\") assert cf.frequency == {'a': 2, 'b': 2, 'c': 2} def test_character_frequency_class_ignore_spaces(): cf = CharacterFrequency(\\"a a b c\\") assert cf.frequency == {'a': 2, 'b': 1, 'c': 1} def test_character_frequency_class_empty_string(): cf = CharacterFrequency(\\"\\") assert cf.frequency == {} def test_character_frequency_class_non_string_input(): with pytest.raises(TypeError): CharacterFrequency(123) def test_character_frequency_class_sorted_output(): cf = CharacterFrequency(\\"aabbcc\\") sorted_freq = cf.sorted_frequency() expected_sorted_freq = {'a': 2, 'b': 2, 'c': 2} assert sorted_freq == expected_sorted_freq","solution":"def character_frequency(s): Returns a dictionary with the frequency of each character in the input string. Characters are considered case-insensitively and spaces are ignored. :param s: The input string :type s: str :return: Dictionary with frequencies of characters :rtype: dict :raises TypeError: If the input is not a string if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") frequency = {} for char in s.lower(): if char != ' ': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency class CharacterFrequency: def __init__(self, input_str): Initializes the CharacterFrequency with a string input, performs validation, and computes the frequency of characters. :param input_str: The input string :type input_str: str :raises TypeError: If the input is not a string if not isinstance(input_str, str): raise TypeError(\\"Input must be a string\\") self.input_str = input_str.lower() # Ignore case self.frequency = self.compute_frequency(self.input_str) def compute_frequency(self, s): Computes the frequency of each character in the given string. :param s: The input string :type s: str :return: Dictionary with frequencies of characters :rtype: dict frequency = {} for char in s: if char != ' ': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def sorted_frequency(self): Returns the character frequency dictionary sorted by character. :return: Sorted dictionary of character frequencies :rtype: dict return dict(sorted(self.frequency.items()))"},{"question":"def filter_primes(numbers: List[int]) -> Union[List[int], str]: Takes a list of integers and returns a new list containing only the prime numbers from the original list. If no primes are found, it returns a message indicating this. >>> filter_primes([4, 6, 8, 13, 15, 23, 25]) [13, 23] >>> filter_primes([4, 6, 8, 10, 12, 14]) \\"No prime numbers found\\" >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([2, 4, -3, 5, -7]) [2, 5] >>> filter_primes([]) \\"No prime numbers found\\" >>> filter_primes([0, 1, 2, 3, 4, 5]) [2, 3, 5] >>> filter_primes([-5, -2, -1, -9]) \\"No prime numbers found\\"","solution":"def is_prime(num): Helper function to check if a number is a prime number. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(numbers): Takes a list of integers and returns a new list containing only the prime numbers from the original list. If no primes are found, it returns a message indicating this. primes = [num for num in numbers if is_prime(num)] return primes if primes else \\"No prime numbers found\\""},{"question":"def fibonacci(n: int) -> list: Returns the Fibonacci sequence up to the nth term. If n is a non-positive integer or invalid input, returns an empty list. >>> fibonacci(1) [0] >>> fibonacci(2) [0, 1] >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci(0) [] >>> fibonacci(-5) [] >>> fibonacci(\\"a\\") [] >>> fibonacci(3.14) [] >>> fibonacci(None) [] >>> fibonacci(50) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049]","solution":"def fibonacci(n): Returns the Fibonacci sequence up to the nth term. If n is a non-positive integer, returns an empty list. if not isinstance(n, int) or n <= 0: return [] sequence = [0, 1] for _ in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence[:n]"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(6) == False >>> is_prime(29) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-1) == False def sum_of_primes(arr: List[int]) -> int: Returns the sum of elements that are prime numbers in the given array. >>> sum_of_primes([2, 4, 6, 7, 10, 11]) 20 >>> sum_of_primes([]) 0 >>> sum_of_primes([4, 6, 8, 10, 12]) 0 >>> sum_of_primes([2, 3, 5, 7, 11]) 28 >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sum_of_primes([-2, -3, 2, 3, 5]) 10","solution":"import math def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True def sum_of_primes(arr): Returns the sum of elements that are prime numbers in the given array. return sum(n for n in arr if is_prime(n)) # Example Usage example_array = [2, 4, 6, 7, 10, 11] print(sum_of_primes(example_array)) # Output: 20"},{"question":"def find_min(nums: List[int]) -> int: Finds the minimum element in a rotated sorted array. This array was initially sorted in ascending order and was rotated. Args: nums (list of int): The rotated sorted array. Returns: int: The minimum element in the array. Example usage: >>> find_min([4,5,6,7,0,1,2]) 0 >>> find_min([3,4,5,1,2]) 1 >>> find_min([1]) 1","solution":"def find_min(nums): Finds the minimum element in a rotated sorted array. Args: nums (list of int): The rotated sorted array. Returns: int: The minimum element in the array. left, right = 0, len(nums) - 1 while left < right: mid = left + (right - left) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"def sum_of_digits(n: int) -> int: Create a Python function named \`sum_of_digits\` that takes a single integer as input and returns the sum of its digits. Ensure the function handles both positive and negative integers correctly. >>> sum_of_digits(12345) 15 >>> sum_of_digits(-12345) 15 >>> sum_of_digits(8) 8 >>> sum_of_digits(-8) 8 >>> sum_of_digits(0) 0 >>> sum_of_digits(987654321) 45","solution":"def sum_of_digits(n): Returns the sum of the digits of the given integer. Handles both positive and negative integers. return sum(int(digit) for digit in str(abs(n)))"},{"question":"def sum_primes(nested_collection): Recursively navigates a nested collection containing integers, lists, sets, tuples, and dictionaries to find and sum all prime numbers. Args: nested_collection (list/set/tuple/dict): The nested structure to parse. Returns: int: The sum of all prime numbers found in the nested collection. pass def test_sum_primes_with_primes(): nested_collection = [2, 3, [4, 5, (6, 7)], {8, 9, 10}, {'a': 11, 'b': [12, 13, {14, 15}]}, 16] assert sum_primes(nested_collection) == 41 def test_sum_primes_empty_collection(): assert sum_primes([]) == 0 assert sum_primes({}) == 0 assert sum_primes(()) == 0 def test_sum_primes_no_primes(): nested_collection = [4, 6, [8, 10, (12, 14)], {16, 18, 20}, {'a': 22, 'b': [24, 26, {28, 30}]}, 32] assert sum_primes(nested_collection) == 0 def test_sum_primes_with_non_integers(): nested_collection = [4, 6.5, ['text', 5, (6, 7)], {8.1, 9, 'string'}, {1: 11, 2: [12, None, {14, 15.0}]}, 16] assert sum_primes(nested_collection) == 5 + 7 + 11 def test_sum_primes_large_numbers(): nested_collection = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] assert sum_primes(nested_collection) == 1060","solution":"def sum_primes(nested_collection): Recursively navigates a nested collection containing integers, lists, sets, tuples, and dictionaries to find and sum all prime numbers. Args: nested_collection (list/set/tuple/dict): The nested structure to parse. Returns: int: The sum of all prime numbers found in the nested collection. def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def sum_primes_recursive(element): Recursive helper function to sum primes in nested structures. if isinstance(element, int): if is_prime(element): return element return 0 elif isinstance(element, (list, set, tuple)): return sum(sum_primes_recursive(sub_element) for sub_element in element) elif isinstance(element, dict): return sum(sum_primes_recursive(value) for value in element.values()) return 0 return sum_primes_recursive(nested_collection)"},{"question":"def calculate_expression(expression: str) -> int: Evaluates a mathematical expression from a string input where multiplication has higher precedence over addition. >>> calculate_expression(\\"2+3*4+1\\") 15 >>> calculate_expression(\\"2*3*4\\") 24 >>> calculate_expression(\\"1+2+3+4\\") 10 >>> calculate_expression(\\"2*3*4*5\\") 120 >>> calculate_expression(\\"1+1+1+1\\") 4","solution":"def calculate_expression(expression): Evaluates a mathematical expression from a string input where multiplication has higher precedence over addition. Args: expression: str - A string representing the mathematical expression. Returns: int - The result of evaluating the expression. if not expression: return 0 # Split by addition first terms = expression.split('+') result = 0 # Evaluate each term individually for term in terms: if '*' in term: factors = map(int, term.split('*')) product = 1 for factor in factors: product *= factor result += product else: result += int(term) return result"},{"question":"import pandas as pd import numpy as np from scipy import stats def summarize_dataset(file_path: str) -> dict: Summarizes the dataset from the given CSV file path by providing mean, median, standard deviation, and most frequent value(s) for each numerical column. :param file_path: Path to the CSV file. :return: Dictionary with summaries for each numerical column. >>> summarize_dataset(\\"test.csv\\") { \\"A\\": { \\"mean\\": 2.4, \\"median\\": 2.0, \\"std_dev\\": 1.140175425099138, \\"most_frequent\\": [2] }, \\"B\\": { \\"mean\\": 7.0, \\"median\\": 7.0, \\"std_dev\\": 1.5811388300841898, \\"most_frequent\\": [5, 6, 7, 8, 9] } } >>> summarize_dataset(\\"non_existent.csv\\") {\\"error\\": \\"File not found\\"} >>> summarize_dataset(\\"test_empty.csv\\") {\\"error\\": \\"Empty data\\"} >>> summarize_dataset(\\"test_missing.csv\\") { \\"A\\": { \\"mean\\": 2.5, \\"median\\": 2.5, \\"std_dev\\": 1.2909944487358056, \\"most_frequent\\": [1, 2, 3, 4] }, \\"B\\": { \\"mean\\": 6.0, \\"median\\": 6.0, \\"std_dev\\": 1.0, \\"most_frequent\\": [5, 6, 7] } }","solution":"import pandas as pd import numpy as np from scipy import stats def summarize_dataset(file_path): Summarizes the dataset from the given CSV file path by providing mean, median, standard deviation, and most frequent value(s) for each numerical column. :param file_path: Path to the CSV file. :return: Dictionary with summaries for each numerical column. try: df = pd.read_csv(file_path) except FileNotFoundError: return {\\"error\\": \\"File not found\\"} except pd.errors.EmptyDataError: return {\\"error\\": \\"Empty data\\"} summary = {} for column in df.select_dtypes(include=np.number).columns: col_data = df[column].dropna() if col_data.empty: continue mean_value = col_data.mean() median_value = col_data.median() std_dev = col_data.std() most_freq_values = col_data.mode().tolist() summary[column] = { 'mean': mean_value, 'median': median_value, 'std_dev': std_dev, 'most_frequent': most_freq_values } return summary"},{"question":"def is_prime(num): Returns True if num is a prime number, otherwise False. pass # Your code here def filter_primes(nums): Returns a list containing only the prime numbers from the original list nums. pass # Your code here # Tests for is_prime function def test_is_prime_with_prime_numbers(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(5) == True assert is_prime(7) == True def test_is_prime_with_non_prime_numbers(): assert is_prime(1) == False assert is_prime(4) == False assert is_prime(6) == False assert is_prime(9) == False def test_is_prime_with_large_prime(): assert is_prime(97) == True def test_is_prime_with_large_non_prime(): assert is_prime(100) == False # Tests for filter_primes function def test_filter_primes_with_mixed_list(): assert filter_primes([1, 2, 3, 4, 5, 10, 13, 15]) == [2, 3, 5, 13] def test_filter_primes_with_no_primes(): assert filter_primes([1, 4, 6, 8, 10, 12]) == [] def test_filter_primes_with_all_primes(): assert filter_primes([2, 3, 5, 11, 17]) == [2, 3, 5, 11, 17] def test_filter_primes_with_empty_list(): assert filter_primes([]) == []","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def filter_primes(nums): Returns a list containing only the prime numbers from the original list nums. return [num for num in nums if is_prime(num)]"},{"question":"def reverse_words(s): Reverses the order of words in the input string s while keeping the individual words intact. :param s: Input string containing words separated by a single space :return: A new string with the order of words reversed pass # Example usage print(reverse_words(\\"Welcome to the coding interview\\")) # Output: \\"interview coding the to Welcome\\" from solution import reverse_words def test_reverse_words_basic(): assert reverse_words(\\"Welcome to the coding interview\\") == \\"interview coding the to Welcome\\" def test_reverse_words_single_word(): assert reverse_words(\\"Hello\\") == \\"Hello\\" def test_reverse_words_two_words(): assert reverse_words(\\"Hello World\\") == \\"World Hello\\" def test_reverse_words_multiple_whitespace(): assert reverse_words(\\"This is a test\\") == \\"test a is This\\" def test_reverse_words_with_numbers(): assert reverse_words(\\"1 2 3 4 5\\") == \\"5 4 3 2 1\\"","solution":"def reverse_words(s): Reverses the order of words in the input string s while keeping the individual words intact. :param s: Input string containing words separated by a single space :return: A new string with the order of words reversed # Split the string into words words = s.split(' ') # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a string return ' '.join(reversed_words) # Example usage print(reverse_words(\\"Welcome to the coding interview\\")) # Output: \\"interview coding the to Welcome\\""},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression involving addition and multiplication. The expression string will only contain non-negative integers, '+' and '*'. >>> evaluate_expression('3+5*2') == 13 >>> evaluate_expression('10+3*5+2') == 27 >>> evaluate_expression('2*3+5*2') == 16 >>> evaluate_expression('8*3+2+1*4') == 30 >>> evaluate_expression('42') == 42 >>> evaluate_expression('2*3*4') == 24 >>> evaluate_expression('1+2+3+4') == 10 >>> evaluate_expression('7') == 7 >>> evaluate_expression('99*99') == 9801 >>> evaluate_expression('0*99+99') == 99 >>> evaluate_expression('99+0*99') == 99 >>> evaluate_expression('0+0*0') == 0 # Add your code here pass","solution":"def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression involving addition and multiplication. The expression string will only contain non-negative integers, '+' and '*'. :param expr: A string containing the mathematical expression. :return: The evaluated result as an integer. # Split the expression by '+', then evaluate each part separately and add them up. terms = expr.split('+') result = 0 for term in terms: # Evaluate each term by multiplying the products together factors = map(int, term.split('*')) product = 1 for factor in factors: product *= factor result += product return result"},{"question":"def smooth_list(nums: List[int]) -> List[float]: Given a list of integers, returns a new list where each element is the average of itself and its previous and next elements in the original list. For elements at the beginning or the end of the list, only use the neighboring elements that exist. >>> smooth_list([]) == [] >>> smooth_list([5]) == [5] >>> smooth_list([3, 6]) == [4.5, 4.5] >>> smooth_list([3, 6, 9, 12, 15]) == [4.5, 6.0, 9.0, 12.0, 13.5] >>> smooth_list([4, 4, 4, 4]) == [4.0, 4.0, 4.0, 4.0]","solution":"def smooth_list(nums): Given a list of integers, returns a new list where each element is the average of itself and its previous and next elements in the original list. For elements at the beginning or the end of the list, only use the neighboring elements that exist. if not nums: return [] if len(nums) == 1: return nums smoothed = [] for i in range(len(nums)): if i == 0: average = (nums[i] + nums[i + 1]) / 2 elif i == len(nums) - 1: average = (nums[i - 1] + nums[i]) / 2 else: average = (nums[i - 1] + nums[i] + nums[i + 1]) / 3 smoothed.append(average) return smoothed"},{"question":"def count_alphanumeric_chars(s: str) -> dict: Returns a dictionary with counts of each alphanumeric character in the string \`s\`, with alphabetic characters counted in a case-insensitive manner. >>> count_alphanumeric_chars(\\"Hello, World! 123\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, '1': 1, '2': 1, '3': 1} >>> count_alphanumeric_chars(\\"\\") == {} >>> count_alphanumeric_chars(\\"!@#%^&*()\\") == {} >>> count_alphanumeric_chars(\\"12345\\") == {'1': 1, '2': 1, '3': 1, '4': 1, '5': 1} >>> count_alphanumeric_chars(\\"aBcDe\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1} >>> count_alphanumeric_chars(\\"AaBbCc\\") == {'a': 2, 'b': 2, 'c': 2} >>> count_alphanumeric_chars(\\"a 1 B 2\\") == {'a': 1, '1': 1, 'b': 1, '2': 1}","solution":"def count_alphanumeric_chars(s): Returns a dictionary with counts of each alphanumeric character in the string \`s\`, with alphabetic characters counted in a case-insensitive manner. from collections import defaultdict char_count = defaultdict(int) for char in s: if char.isalnum(): char_count[char.lower()] += 1 return dict(char_count)"},{"question":"def intersect_arrays(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are common in both input lists, without any duplicates. >>> intersect_arrays([1, 2, 3], [3, 4, 5]) == [3] >>> intersect_arrays([10, 20, 30], [40, 50, 60]) == [] >>> intersect_arrays([1, 2, 2, 3], [2, 3, 4]) == [2, 3]","solution":"def intersect_arrays(list1, list2): Returns a list of integers that are common in both input lists. The result does not contain any duplicate values. set1 = set(list1) set2 = set(list2) return list(set1 & set2)"},{"question":"from typing import List, Dict def evaluate_performance(sales_data: Dict[int, List[float]], average_threshold: float, good_threshold: float, excellent_threshold: float) -> Dict[int, str]: Evaluate the performance of employees based on sales data. Ratings are determined by comparing average sales against preset thresholds. Args: sales_data: A dictionary where keys are employee IDs and values are lists of sales amounts. average_threshold: The sales average below which employees are rated as \\"Poor\\". good_threshold: The sales average below which employees are rated as \\"Average\\". excellent_threshold: The sales average above which employees are rated as \\"Excellent\\". Returns: A dictionary with employee IDs as keys and their respective performance ratings as values. Examples: >>> evaluate_performance({1:[400, 450, 500], 2:[300, 320, 350]}, 350, 450, 500) {1: 'Good', 2: 'Poor'} >>> evaluate_performance({1:[400, 450, 500], 2:[300, 320, 350]}, 330, 400, 490) {1: 'Excellent', 2: 'Average'} # Write your code here","solution":"from typing import List, Dict def evaluate_performance(sales_data: Dict[int, List[float]], average_threshold: float, good_threshold: float, excellent_threshold: float) -> Dict[int, str]: Evaluate the performance of employees based on sales data. Ratings are determined by comparing average sales against preset thresholds. Args: sales_data: A dictionary where keys are employee IDs and values are lists of sales amounts. average_threshold: The sales average below which employees are rated as \\"Poor\\". good_threshold: The sales average below which employees are rated as \\"Average\\". excellent_threshold: The sales average above which employees are rated as \\"Excellent\\". Returns: A dictionary with employee IDs as keys and their respective performance ratings as values. Examples: >>> evaluate_performance({1:[400, 450, 500], 2:[300, 320, 350]}, 350, 450, 500) {1: 'Good', 2: 'Poor'} >>> evaluate_performance({1:[400, 450, 500], 2:[300, 320, 350]}, 330, 400, 490) {1: 'Excellent', 2: 'Average'} ratings = {} for employee_id, sales in sales_data.items(): average_sales = sum(sales) / len(sales) if average_sales < average_threshold: ratings[employee_id] = 'Poor' elif average_threshold <= average_sales < good_threshold: ratings[employee_id] = 'Average' elif good_threshold <= average_sales < excellent_threshold: ratings[employee_id] = 'Good' else: ratings[employee_id] = 'Excellent' return ratings"},{"question":"def reverse_dict(my_dict: dict) -> dict: Create a Python function called \`reverse_dict\` that takes a dictionary, \`my_dict\`, as an input. The dictionary contains keys associated with their respective string values. The function should return a new dictionary where the keys remain the same but the string values are reversed. Parameters: my_dict (dict): The input dictionary with string values. Returns: dict: A dictionary with reversed string values. >>> reverse_dict({'key1': 'hello', 'key2': 'world'}) {'key1': 'olleh', 'key2': 'dlrow'} >>> reverse_dict({}) {} >>> reverse_dict({'key1': 'python'}) {'key1': 'nohtyp'} >>> reverse_dict({'key1': 'madam'}) {'key1': 'madam'} >>> reverse_dict({'key1': 'abc123', 'key2': '!@#'}) {'key1': '321cba', 'key2': '#@!'}","solution":"def reverse_dict(my_dict): Returns a new dictionary where the keys remain the same but the string values are reversed. Parameters: my_dict (dict): The input dictionary with string values. Returns: dict: A dictionary with reversed string values. return {key: value[::-1] for key, value in my_dict.items()}"},{"question":"class User: def __init__(self, id, name, email, password_hash, role): Initialize a User object. >>> user = User(1, \\"John Doe\\", \\"john@example.com\\", \\"hashed_password\\", \\"Member\\") >>> user.id == 1 True >> user.name == \\"John Doe\\" True >> user.email == \\"john@example.com\\" True >> user.password_hash == \\"hashed_password\\" True >> user.role == \\"Member\\" True self.id = id self.name = name self.email = email self.password_hash = password_hash self.role = role class Task: def __init__(self, id, title, description, status, assigned_to, created_at, updated_at): Initialize a Task object. >>> task = Task(1, \\"Task 1\\", \\"Description\\", \\"Pending\\", 2, \\"2023-10-01\\", \\"2023-10-01\\") >>> task.id == 1 True >>> task.title == \\"Task 1\\" True >>> task.description == \\"Description\\" True >>> task.status == \\"Pending\\" True >>> task.assigned_to == 2 True >>> task.created_at == \\"2023-10-01\\" True >>> task.updated_at == \\"2023-10-01\\" True self.id = id self.title = title self.description = description self.status = status self.assigned_to = assigned_to self.created_at = created_at self.updated_at = updated_at def create_task(tasks, id, title, description, status, assigned_to, created_at, updated_at): Create a task and add it to the list of tasks. >>> tasks = [] >>> task = create_task(tasks, 1, \\"Task 1\\", \\"Description\\", \\"Pending\\", 2, \\"2023-10-01\\", \\"2023-10-01\\") >>> task.id == 1 True >>> task.title == \\"Task 1\\" True >>> task.description == \\"Description\\" True >>> task.status == \\"Pending\\" True >>> task.assigned_to == 2 True >>> task.created_at == \\"2023-10-01\\" True >>> task.updated_at == \\"2023-10-01\\" True >>> len(tasks) == 1 True new_task = Task(id, title, description, status, assigned_to, created_at, updated_at) tasks.append(new_task) return new_task def update_task_status(task, new_status): Update the status of a task. >>> task = Task(1, \\"Task 1\\", \\"Description\\", \\"Pending\\", 2, \\"2023-10-01\\", \\"2023-10-01\\") >>> updated_task = update_task_status(task, \\"In Progress\\") >>> updated_task.status == \\"In Progress\\" True task.status = new_status return task def assign_task(task, user_id): Assign a task to a user. >>> task = Task(1, \\"Task 1\\", \\"Description\\", \\"Pending\\", 2, \\"2023-10-01\\", \\"2023-10-01\\") >>> assigned_task = assign_task(task, 3) >>> assigned_task.assigned_to == 3 True task.assigned_to = user_id return task def add_user(users, id, name, email, password_hash, role): Add a new user to the list of users. >>> users = [] >>> user = add_user(users, 1, \\"John Doe\\", \\"john@example.com\\", \\"hashed_password\\", \\"Member\\") >>> user.id == 1 True >>> user.name == \\"John Doe\\" True >>> user.email == \\"john@example.com\\" True >>> user.password_hash == \\"hashed_password\\" True >>> user.role == \\"Member\\" True >>> len(users) == 1 True new_user = User(id, name, email, password_hash, role) users.append(new_user) return new_user if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"class User: def __init__(self, id, name, email, password_hash, role): self.id = id self.name = name self.email = email self.password_hash = password_hash self.role = role class Task: def __init__(self, id, title, description, status, assigned_to, created_at, updated_at): self.id = id self.title = title self.description = description self.status = status self.assigned_to = assigned_to self.created_at = created_at self.updated_at = updated_at # Example functions to operate on the Task and User data models def create_task(tasks, id, title, description, status, assigned_to, created_at, updated_at): new_task = Task(id, title, description, status, assigned_to, created_at, updated_at) tasks.append(new_task) return new_task def update_task_status(task, new_status): task.status = new_status return task def assign_task(task, user_id): task.assigned_to = user_id return task def add_user(users, id, name, email, password_hash, role): new_user = User(id, name, email, password_hash, role) users.append(new_user) return new_user"},{"question":"import json def get_products_in_category_with_stock(products_json: str, category: str, stock_threshold: int) -> list: Returns a list of product names that fall under the specified category and have a stock quantity above the specified threshold. Parameters: - products_json (str): A JSON object string representing a collection of products. - category (str): The category to filter products by. - stock_threshold (int): The minimum stock quantity required for the products. Returns: - list: A list of product names that meet the specified criteria. >>> products_json = ''' { \\"products\\": [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"stock\\": 10}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 699.99, \\"stock\\": 15}, {\\"name\\": \\"Vacuum Cleaner\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 199.99, \\"stock\\": 5}, {\\"name\\": \\"Desk Lamp\\", \\"category\\": \\"Furniture\\", \\"price\\": 49.99, \\"stock\\": 20}, {\\"name\\": \\"Electric Kettle\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 39.99, \\"stock\\": 30} ] }''' >>> get_products_in_category_with_stock(products_json, \\"Home Appliances\\", 10) [\\"Electric Kettle\\"]","solution":"import json def get_products_in_category_with_stock(products_json, category, stock_threshold): Returns a list of product names that fall under the specified category and have a stock quantity above the specified threshold. Parameters: - products_json (str): A JSON object string representing a collection of products. - category (str): The category to filter products by. - stock_threshold (int): The minimum stock quantity required for the products. Returns: - list: A list of product names that meet the specified criteria. products = json.loads(products_json)['products'] result = [product['name'] for product in products if product['category'] == category and product['stock'] > stock_threshold] return result"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Returns the length of the shortest contiguous subarray such that the sum is greater or equal to target. If there is no such subarray, returns 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1], 2) 0 >>> min_subarray_len([], 1) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([3, 1, 4, 1, 5], 5) 1 >>> min_subarray_len([2, 3, 1, 2, 4, 3, 7, 1, 2], 7) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 10], 10) 1 >>> min_subarray_len([1, 2, 2, 3, 2, 4], 6) 2 >>> min_subarray_len([1000, 2000, 3000, 4000], 7000) 2","solution":"def min_subarray_len(nums, target): Returns the length of the shortest contiguous subarray such that the sum is greater or equal to target. If there is no such subarray, returns 0. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def sum_consecutive_elements(nums: List[int], k: int) -> List[int]: Given a list of integers and an integer k, returns a new list where each element is the sum of k consecutive elements from the original list. If there are not enough elements to form a group of k, the remaining elements should be included as they are. >>> sum_consecutive_elements([1, 2, 3, 4, 5], 3) [6, 9] >>> sum_consecutive_elements([10, 20, 30, 40, 50, 60], 2) [30, 70, 110]","solution":"def sum_consecutive_elements(nums, k): Given a list of integers and an integer k, returns a new list where each element is the sum of k consecutive elements from the original list. result = [] for i in range(0, len(nums), k): result.append(sum(nums[i:i + k])) return result"},{"question":"def is_prime(number): Checks if a number is prime. Returns True if the number is prime, False otherwise. def filter_primes(numbers): Filters and returns prime numbers from a list of integers. Args: numbers (List[int]): A list of integers, which can include negative numbers. Returns: List[int]: A list containing only the prime numbers from the input list. # Example usage: input_list = [10, 15, 3, 7, 4, 11, -5, 13, 27] output_list = filter_primes(input_list) print(output_list) # Output should be [3, 7, 11, 13]","solution":"def is_prime(number): Checks if a number is prime. Returns True if the number is prime, False otherwise. if number <= 1: return False if number == 2: return True # 2 is the only even prime number if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True def filter_primes(numbers): Filters and returns prime numbers from a list of integers. Args: numbers (List[int]): A list of integers, which can include negative numbers. Returns: List[int]: A list containing only the prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def find_indices(string: str, char: str) -> List[int]: Write a Python function that takes a string and a character as inputs, and returns a list of all the indices where the character appears in the string. If the character does not appear in the string, return an empty list. Ensure that the function is case-sensitive. Args: string (str): The input string to search. char (str): The character to find in the string. Returns: List[int]: A list of indices where 'char' appears in 'string'. >>> find_indices(\\"hello\\", \\"e\\") [1] >>> find_indices(\\"hello\\", \\"l\\") [2, 3] >>> find_indices(\\"hello\\", \\"x\\") [] >>> find_indices(\\"\\", \\"a\\") [] >>> find_indices(\\"Hello\\", \\"H\\") [0] >>> find_indices(\\"Hello\\", \\"h\\") [] >>> find_indices(\\"aaaaa\\", \\"a\\") [0, 1, 2, 3, 4]","solution":"def find_indices(string, char): Find all indices of 'char' in 'string'. Args: string (str): The input string to search. char (str): The character to find in the string. Returns: List[int]: A list of indices where 'char' appears in 'string'. return [i for i, c in enumerate(string) if c == char]"},{"question":"def evalRPN(tokens: List[str]) -> int: Evaluate the value of an arithmetic expression in Reverse Polish Notation (postfix notation). Args: tokens (List[str]): List of strings representing the postfix expression. Returns: int: The result of the expression. Examples: >>> evalRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evalRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evalRPN([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evalRPN([\\"42\\"]) 42 >>> evalRPN([\\"2\\", \\"3\\", \\"-\\"]) -1 >>> evalRPN([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14","solution":"def evalRPN(tokens): Evaluate the value of an arithmetic expression in Reverse Polish Notation (postfix notation). Args: tokens (List[str]): List of strings representing the postfix expression. Returns: int: The result of the expression. stack = [] for token in tokens: if token in ('+', '-', '*', '/'): b = int(stack.pop()) a = int(stack.pop()) if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # int(a / b) truncates towards zero in Python 3 stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"class InventoryItem: def __init__(self, identifier, name, quantity, price): self.identifier = identifier self.name = name self.quantity = quantity self.price = price class InventoryManagementSystem: def __init__(self): self.items = {} def add_item(self, identifier, name, quantity, price): Adds a new item to the inventory. Raises ValueError if identifier already exists or if quantity/price are negative. pass def update_item_quantity(self, identifier, quantity): Updates the quantity of an existing item. Raises ValueError if identifier does not exist or if quantity is negative. pass def search_by_name(self, name): Searches for items by their name. Returns a list of items with matching names. pass def search_by_identifier(self, identifier): Searches for an item by its identifier. Returns the item if found, otherwise None. pass def total_value(self): Calculates the total value of the inventory. Returns the sum of quantity * price for all items. pass import pytest def test_add_item(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) assert ims.items[\\"001\\"].name == \\"Laptop\\" assert ims.items[\\"001\\"].quantity == 10 assert ims.items[\\"001\\"].price == 1000 def test_add_item_with_same_identifier(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) with pytest.raises(ValueError): ims.add_item(\\"001\\", \\"Smartphone\\", 5, 500) def test_update_item_quantity(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) ims.update_item_quantity(\\"001\\", 5) assert ims.items[\\"001\\"].quantity == 5 def test_update_item_quantity_negative(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) with pytest.raises(ValueError): ims.update_item_quantity(\\"001\\", -1) def test_search_by_name(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) ims.add_item(\\"002\\", \\"Smartphone\\", 5, 500) results = ims.search_by_name(\\"Laptop\\") assert len(results) == 1 assert results[0].identifier == \\"001\\" def test_search_by_identifier(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) item = ims.search_by_identifier(\\"001\\") assert item.name == \\"Laptop\\" def test_total_value(): ims = InventoryManagementSystem() ims.add_item(\\"001\\", \\"Laptop\\", 10, 1000) ims.add_item(\\"002\\", \\"Smartphone\\", 5, 500) assert ims.total_value() == 12500 def test_add_item_negative_quantity(): ims = InventoryManagementSystem() with pytest.raises(ValueError): ims.add_item(\\"001\\", \\"Laptop\\", -10, 1000) def test_add_item_negative_price(): ims = InventoryManagementSystem() with pytest.raises(ValueError): ims.add_item(\\"001\\", \\"Laptop\\", 10, -1000)","solution":"class InventoryItem: def __init__(self, identifier, name, quantity, price): self.identifier = identifier self.name = name self.quantity = quantity self.price = price class InventoryManagementSystem: def __init__(self): self.items = {} def add_item(self, identifier, name, quantity, price): if identifier in self.items: raise ValueError(\\"Item with the given identifier already exists.\\") if quantity < 0 or price < 0: raise ValueError(\\"Quantity and price should be non-negative.\\") self.items[identifier] = InventoryItem(identifier, name, quantity, price) def update_item_quantity(self, identifier, quantity): if identifier not in self.items: raise ValueError(\\"Item with the given identifier does not exist.\\") if quantity < 0: raise ValueError(\\"Quantity should be non-negative.\\") self.items[identifier].quantity = quantity def search_by_name(self, name): return [item for item in self.items.values() if item.name == name] def search_by_identifier(self, identifier): return self.items.get(identifier, None) def total_value(self): return sum(item.quantity * item.price for item in self.items.values())"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): The n x n matrix to be rotated. Raises: TypeError: If the input is not a list of lists or any row is not a list. ValueError: If the input matrix is not square (n x n). Example usage: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Example test cases def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_invalid_matrix_type(): try: rotate_matrix(\\"not a matrix\\") except TypeError as e: assert str(e) == \\"Input should be a list of lists\\" else: assert False, \\"TypeError not raised\\" def test_invalid_matrix_row_type(): try: rotate_matrix([1, 2, 3]) except TypeError as e: assert str(e) == \\"Each row should be a list\\" else: assert False, \\"TypeError not raised\\" def test_non_square_matrix(): try: rotate_matrix([ [1, 2], [3, 4, 5] ]) except ValueError as e: assert str(e) == \\"Matrix should be n x n\\" else: assert False, \\"ValueError not raised\\"","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. if not isinstance(matrix, list): raise TypeError(\\"Input should be a list of lists\\") n = len(matrix) if not all(isinstance(row, list) for row in matrix): raise TypeError(\\"Each row should be a list\\") if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix should be n x n\\") # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for row in matrix: row.reverse()"},{"question":"from typing import List def numMatchingSubseq(s: str, words: List[str]) -> int: You are given a list of words and a string \`s\`. You need to find how many of the words in the list can be formed by deleting some characters of \`s\` without rearranging the remaining characters. In other words, for each word in the list, check if it is a subsequence of \`s\`. Args: s (str): A string of lowercase English letters. words (List[str]): A list of strings where each string has a length of at most 50. Returns: int: The number of words that are subsequences of \`s\`. Examples: >>> numMatchingSubseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> numMatchingSubseq(\\"abcdefgh\\", [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"]) 4 import pytest def test_example_case(): s = \\"abcde\\" words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"] assert numMatchingSubseq(s, words) == 3 def test_all_words_subsequence(): s = \\"abcdefgh\\" words = [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"] assert numMatchingSubseq(s, words) == 4 def test_no_words_subsequence(): s = \\"abc\\" words = [\\"d\\", \\"ee\\", \\"fff\\"] assert numMatchingSubseq(s, words) == 0 def test_empty_string_s(): s = \\"\\" words = [\\"a\\", \\"bb\\", \\"acd\\"] assert numMatchingSubseq(s, words) == 0 def test_empty_words_list(): s = \\"abcde\\" words = [] assert numMatchingSubseq(s, words) == 0 def test_words_with_special_characters(): s = \\"a1b2c3d4\\" words = [\\"a1\\", \\"b2c\\", \\"3d\\", \\"d4\\", \\"z\\"] assert numMatchingSubseq(s, words) == 4 def test_large_inputs(): s = \\"a\\" * 100000 words = [\\"a\\" * 50, \\"a\\" * 100, \\"a\\" * 200, \\"b\\", \\"a\\" * 100000] assert numMatchingSubseq(s, words) == 4 # Only \\"b\\" is not a subsequence","solution":"from typing import List def is_subsequence(s: str, word: str) -> bool: it = iter(s) return all(char in it for char in word) def numMatchingSubseq(s: str, words: List[str]) -> int: count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"from typing import List def card_game(player1_cards: List[int], player2_cards: List[int]) -> str: Simulate a simple card game. The game begins with two players each being dealt an equal number of cards from a standard deck of 52 cards. Each integer corresponds to a card value, where 11 is Jack, 12 is Queen, 13 is King, and 14 is Ace. Rules: 1. Both players place their top card (first element of their list) face up. The player with the higher card wins the round and takes both cards, placing them at the bottom of their stack of cards. 2. If the two cards are of equal value, it’s a tie for that round, and both cards are placed at the bottom of the respective players' stacks. 3. The game continues until one player has all the cards or rounds reach a maximum number to prevent infinite games. 4. If neither player wins all cards before the maximum rounds, the player with more cards is declared the winner. >>> card_game([14, 2, 3, 4], [13, 2, 3, 4]) 'Player 1 wins' >>> card_game([2, 3, 4, 5], [2, 3, 4, 5]) 'Draw'","solution":"from typing import List def card_game(player1_cards: List[int], player2_cards: List[int]) -> str: max_rounds = 500 round_count = 0 while player1_cards and player2_cards and round_count < max_rounds: round_count += 1 card1 = player1_cards.pop(0) card2 = player2_cards.pop(0) if card1 > card2: player1_cards += [card1, card2] elif card2 > card1: player2_cards += [card2, card1] else: player1_cards.append(card1) player2_cards.append(card2) if len(player1_cards) > len(player2_cards): return \\"Player 1 wins\\" elif len(player2_cards) > len(player1_cards): return \\"Player 2 wins\\" else: return \\"Draw\\""},{"question":"from typing import List def min_distance_path(matrix: List[List[int]]) -> int: Calculate the minimum path sum from the top-left corner to the bottom-right corner of a given rectangular grid. Each cell in the grid contains a non-negative integer, representing the cost to traverse that cell. You can only move either down or right at any point in time. Example: >>> min_distance_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 pass def test_min_distance_path_typical_case(): matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_distance_path(matrix) == 7 def test_min_distance_path_single_row(): matrix = [ [1, 2, 3] ] assert min_distance_path(matrix) == 6 def test_min_distance_path_single_column(): matrix = [ [1], [2], [3] ] assert min_distance_path(matrix) == 6 def test_min_distance_path_single_cell(): matrix = [ [5] ] assert min_distance_path(matrix) == 5 def test_min_distance_path_empty_matrix(): matrix = [ [] ] assert min_distance_path(matrix) == 0","solution":"from typing import List def min_distance_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"class TicTacToe: def __init__(self): self.board = [' ' for _ in range(9)] # A list to hold the board's current state self.current_winner = None # To keep track of the winner def print_board(self): # This method prints the current board state for row in [self.board[i*3:(i+1)*3] for i in range(3)]: print('| ' + ' | '.join(row) + ' |') def available_moves(self): This method returns a list of available moves (empty spots). >>> game = TicTacToe() >>> game.available_moves() [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> game.make_move(0, 'X') >>> game.available_moves() [1, 2, 3, 4, 5, 6, 7, 8] def empty_squares(self): This method checks if there are any empty squares left on the board. >>> game = TicTacToe() >>> game.empty_squares() True >>> for i in range(9): ... game.make_move(i, 'X') >>> game.empty_squares() False def num_empty_squares(self): This method returns the number of empty squares left on the board. >>> game = TicTacToe() >>> game.num_empty_squares() 9 >>> game.make_move(0, 'X') >>> game.num_empty_squares() 8 def make_move(self, square, letter): This method makes a move on the board. >>> game = TicTacToe() >>> game.make_move(0, 'X') True >>> game.make_move(0, 'O') False def is_winner(self, square, letter): This method checks if the current move is a winning move. >>> game = TicTacToe() >>> game.make_move(0, 'X') >>> game.make_move(1, 'X') >>> game.make_move(2, 'X') >>> game.is_winner(2, 'X') True >>> game = TicTacToe() >>> game.make_move(0, 'O') >>> game.make_move(3, 'O') >>> game.make_move(6, 'O') >>> game.is_winner(6, 'O') True","solution":"class TicTacToe: def __init__(self): self.board = [' ' for _ in range(9)] # A list to hold the board's current state self.current_winner = None # To keep track of the winner def print_board(self): # This method prints the current board state for row in [self.board[i*3:(i+1)*3] for i in range(3)]: print('| ' + ' | '.join(row) + ' |') def available_moves(self): # This method returns a list of available moves (empty spots) return [i for i, spot in enumerate(self.board) if spot == ' '] def empty_squares(self): # This method checks if there are any empty squares left on the board return ' ' in self.board def num_empty_squares(self): # This method returns the number of empty squares left on the board return self.board.count(' ') def make_move(self, square, letter): # This method makes a move on the board, returns True if move is valid, False otherwise if self.board[square] == ' ': self.board[square] = letter if self.is_winner(square, letter): self.current_winner = letter return True return False def is_winner(self, square, letter): # This method checks if the current move is a winning move row_ind = square // 3 row = self.board[row_ind*3 : (row_ind+1)*3] if all([spot == letter for spot in row]): return True col_ind = square % 3 column = [self.board[col_ind+i*3] for i in range(3)] if all([spot == letter for spot in column]): return True if square % 2 == 0: diagonal1 = [self.board[i] for i in [0, 4, 8]] if all([spot == letter for spot in diagonal1]): return True diagonal2 = [self.board[i] for i in [2, 4, 6]] if all([spot == letter for spot in diagonal2]): return True return False"},{"question":"def manage_student_data(students, subjects): Manage student data with functionalities including filtering, sorting, error handling, and subject queries. >>> manage_student_data([], {'Math': [1, 2, 3]}) \\"Student list is empty or not provided.\\" >>> manage_student_data([('Alice', 1, 3, 85, 2023)], {}) \\"Subject dictionary is empty or not provided.\\" >>> manage_student_data([('Alice', 1, 3, 85, 2023), ('Bob', 2, 4)], {'Math': [1, 2]}) Traceback (most recent call last): ... ValueError: Incorrect data format for student: Bob >>> manage_student_data([('Alice', 1, 3, 85, 2023), ('Charlie', 'ID2', 4, 90, 2024)], {'Math': [1, 2]}) Traceback (most recent call last): ... ValueError: Student ID is not a number for student: Charlie >>> manage_student_data([('Alice', 1, 3, 85, 2023), ('Bob', 1, 4, 90, 2024)], {'Math': [1, 2]}) Traceback (most recent call last): ... ValueError: Duplicate student ID found: 1 >>> students = [ ... ('Alice', 1, 3, 85, 2023), ... ('Bob', 2, 4, 90, 2024), ... ('Charlie', 3, 2, 70, 2022) ... ] >>> subjects = { ... 'Math': [1, 2], ... 'Science': [2, 3] ... } >>> result = manage_student_data(students, subjects) >>> result['filter_and_sort']('average_grade') [('Bob', 2, 4, 90, 2024), ('Alice', 1, 3, 85, 2023), ('Charlie', 3, 2, 70, 2022)] >>> result['filter_and_sort']('graduation_year') [('Charlie', 3, 2, 70, 2022), ('Alice', 1, 3, 85, 2023), ('Bob', 2, 4, 90, 2024)] >>> result['filter_and_sort']('number_of_subjects') [('Bob', 2, 4, 90, 2024), ('Alice', 1, 3, 85, 2023), ('Charlie', 3, 2, 70, 2022)] >>> result['filter_and_sort']('student_name') [('Alice', 1, 3, 85, 2023), ('Bob', 2, 4, 90, 2024), ('Charlie', 3, 2, 70, 2022)] >>> result['get_subjects_by_student_id'](2) ['Math', 'Science'] >>> result['get_subjects_by_student_id'](3) ['Science'] >>> result['get_subjects_by_student_id'](1) ['Math'] >>> result['get_subjects_by_student_id'](4) []","solution":"def manage_student_data(students, subjects): if not students or not isinstance(students, list): return \\"Student list is empty or not provided.\\" if not subjects or not isinstance(subjects, dict): return \\"Subject dictionary is empty or not provided.\\" # Checking constraints and processing student data student_ids = set() for student in students: if len(student) != 5: raise ValueError(f\\"Incorrect data format for student: {student[0]}\\") if not isinstance(student[1], int): raise ValueError(f\\"Student ID is not a number for student: {student[0]}\\") if student[1] in student_ids: raise ValueError(f\\"Duplicate student ID found: {student[1]}\\") student_ids.add(student[1]) def filter_and_sort(criteria): if criteria == 'average_grade': return sorted(students, key=lambda x: x[3], reverse=True) elif criteria == 'graduation_year': return sorted(students, key=lambda x: x[4]) elif criteria == 'number_of_subjects': return sorted(students, key=lambda x: x[2], reverse=True) elif criteria == 'student_name': return sorted(students, key=lambda x: x[0]) else: return \\"Invalid criteria provided.\\" def get_subjects_by_student_id(student_id): enrolled_subjects = [] for subject, ids in subjects.items(): if student_id in ids: enrolled_subjects.append(subject) return enrolled_subjects return { 'filter_and_sort': filter_and_sort, 'get_subjects_by_student_id': get_subjects_by_student_id }"},{"question":"from datetime import datetime def process_borrow_records(books: list, borrow_records: list, current_date: str) -> list: Processes a list of dictionaries representing a collection of books in a library and a list of dictionaries representing book borrow records. Modifies the borrow records to include details like book title and author, and filters out records of books that have not been returned within a specified number of days. Parameters: books (list): List of dictionaries containing book details. borrow_records (list): List of dictionaries containing borrow record details. current_date (str): Current date as a string in the format 'YYYY-MM-DD'. Returns: list: Filtered and enriched list of borrow records. pass import pytest def test_process_within_30_days(): books = [ {\\"book_id\\": 1, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publish_year\\": 1949}, {\\"book_id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publish_year\\": 1960}, ] borrow_records = [ {\\"record_id\\": 1, \\"book_id\\": 1, \\"borrower_name\\": \\"Alice\\", \\"borrow_date\\": \\"2023-09-01\\", \\"return_date\\": \\"2023-09-25\\"}, {\\"record_id\\": 2, \\"book_id\\": 2, \\"borrower_name\\": \\"Bob\\", \\"borrow_date\\": \\"2023-09-20\\", \\"return_date\\": None}, ] current_date = \\"2023-10-01\\" expected = [ {\\"record_id\\": 1, \\"book_id\\": 1, \\"borrower_name\\": \\"Alice\\", \\"borrow_date\\": \\"2023-09-01\\", \\"return_date\\": \\"2023-09-25\\", \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}, {\\"record_id\\": 2, \\"book_id\\": 2, \\"borrower_name\\": \\"Bob\\", \\"borrow_date\\": \\"2023-09-20\\", \\"return_date\\": None, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"}, ] assert process_borrow_records(books, borrow_records, current_date) == expected def test_process_more_than_30_days(): books = [ {\\"book_id\\": 1, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publish_year\\": 1949}, {\\"book_id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publish_year\\": 1960}, ] borrow_records = [ {\\"record_id\\": 1, \\"book_id\\": 1, \\"borrower_name\\": \\"Alice\\", \\"borrow_date\\": \\"2023-08-01\\", \\"return_date\\": \\"2023-09-25\\"}, {\\"record_id\\": 2, \\"book_id\\": 2, \\"borrower_name\\": \\"Bob\\", \\"borrow_date\\": \\"2023-08-20\\", \\"return_date\\": None}, ] current_date = \\"2023-10-01\\" expected = [] assert process_borrow_records(books, borrow_records, current_date) == expected def test_process_no_return_date(): books = [ {\\"book_id\\": 1, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"publish_year\\": 1949}, {\\"book_id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"publish_year\\": 1960}, {\\"book_id\\": 3, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"publish_year\\": 1925}, ] borrow_records = [ {\\"record_id\\": 1, \\"book_id\\": 1, \\"borrower_name\\": \\"Alice\\", \\"borrow_date\\": \\"2023-09-01\\", \\"return_date\\": None}, {\\"record_id\\": 2, \\"book_id\\": 2, \\"borrower_name\\": \\"Bob\\", \\"borrow_date\\": \\"2023-08-20\\", \\"return_date\\": None}, {\\"record_id\\": 3, \\"book_id\\": 3, \\"borrower_name\\": \\"Charlie\\", \\"borrow_date\\": \\"2023-07-15\\", \\"return_date\\": \\"2023-08-20\\"}, ] current_date = \\"2023-10-01\\" expected = [ {\\"record_id\\": 1, \\"book_id\\": 1, \\"borrower_name\\": \\"Alice\\", \\"borrow_date\\": \\"2023-09-01\\", \\"return_date\\": None, \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}, ] assert process_borrow_records(books, borrow_records, current_date) == expected","solution":"from datetime import datetime, timedelta def process_borrow_records(books, borrow_records, current_date): Processes borrow records for a list of books and retains records within 30 days of borrow_date. Parameters: books (list): List of dictionaries containing book details. borrow_records (list): List of dictionaries containing borrow record details. current_date (str): Current date as a string in the format 'YYYY-MM-DD'. Returns: list: Filtered and enriched list of borrow records. book_details = {book['book_id']: book for book in books} filtered_records = [] for record in borrow_records: book_id = record['book_id'] if book_id in book_details: record['title'] = book_details[book_id]['title'] record['author'] = book_details[book_id]['author'] borrow_date = datetime.strptime(record['borrow_date'], \\"%Y-%m-%d\\") return_date_str = record['return_date'] return_date = datetime.strptime(return_date_str, \\"%Y-%m-%d\\") if return_date_str else datetime.strptime(current_date, \\"%Y-%m-%d\\") if (return_date - borrow_date).days <= 30: filtered_records.append(record) return filtered_records"},{"question":"def longest_even_odd_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. >>> longest_even_odd_subarray([2, 4, 6, 8, 10]) == 0 >>> longest_even_odd_subarray([1, 3, 5, 7, 9]) == 0 >>> longest_even_odd_subarray([1, 2, 3, 4, 5, 6]) == 6 >>> longest_even_odd_subarray([1, 1, 2, 2, 1, 2]) == 6 >>> longest_even_odd_subarray([1, 2, 1, 2, 1, 2]) == 6 >>> longest_even_odd_subarray([2, 1, 2, 1, 2, 1]) == 6 >>> longest_even_odd_subarray([1, 3, 5, 2]) == 2 >>> longest_even_odd_subarray([]) == 0 >>> longest_even_odd_subarray([2]) == 0 >>> longest_even_odd_subarray([1]) == 0 >>> longest_even_odd_subarray([1, 2, 3, 4, 5, 2, 1, 6, 7, 8, 9, 10]) == 12","solution":"def longest_even_odd_subarray(arr): Returns the length of the longest contiguous subarray with an equal number of even and odd numbers. prefix_sum = {0: -1} # Dictionary to store prefix sums and their first occurrence indices max_length = 0 sum_even_odd = 0 for i in range(len(arr)): if arr[i] % 2 == 0: sum_even_odd += 1 else: sum_even_odd -= 1 if sum_even_odd in prefix_sum: max_length = max(max_length, i - prefix_sum[sum_even_odd]) else: prefix_sum[sum_even_odd] = i return max_length"},{"question":"def generate_squares(n: int) -> dict: Generates a dictionary with keys from 1 to n (inclusive) and values as the squares of the keys. >>> generate_squares(5) {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} >>> generate_squares(3) {1: 1, 2: 4, 3: 9} >>> generate_squares(0) {} pass def test_generate_squares(): assert generate_squares(1) == {1: 1} assert generate_squares(2) == {1: 1, 2: 4} assert generate_squares(3) == {1: 1, 2: 4, 3: 9} assert generate_squares(5) == {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} assert generate_squares(0) == {} assert generate_squares(10) == {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}","solution":"def generate_squares(n: int) -> dict: Generates a dictionary with keys from 1 to n (inclusive) and values as the squares of the keys. Parameters: n (int): The upper limit for keys in the dictionary. Returns: dict: A dictionary where the keys are integers from 1 to n and the values are the squares of the keys. return {i: i**2 for i in range(1, n+1)}"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: The function accepts a list of integers nums and returns a new list where each element at index i is the product of all the elements in the original array except nums[i]. This must be achieved without using the division operator. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] pass","solution":"def product_except_self(nums): Returns a list where each element at index i is the product of all the elements in the original array except nums[i]. Args: nums (list): List of integers. Returns: list: A list of products. length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def longest_zero_sum_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with sum equal to zero. >>> longest_zero_sum_subarray([0, 0, 0, 0]) == 4 >>> longest_zero_sum_subarray([1, 2, 3, 4, 5]) == 0 >>> longest_zero_sum_subarray([1, -1, 3, -3, 5, -5]) == 6 >>> longest_zero_sum_subarray([1, 2, -2, 4, -4]) == 4 >>> longest_zero_sum_subarray([]) == 0 >>> longest_zero_sum_subarray([0]) == 1 >>> longest_zero_sum_subarray([5]) == 0 >>> longest_zero_sum_subarray([-5]) == 0 >>> longest_zero_sum_subarray([1, 2, -3, 3, 1]) == 3 >>> longest_zero_sum_subarray([1, 2, 3, -3, -2, -1]) == 6","solution":"def longest_zero_sum_subarray(arr): Returns the length of the longest contiguous subarray with sum equal to zero. sum_index_map = {} # To store the first occurrence of a sum max_length = 0 current_sum = 0 for index, value in enumerate(arr): current_sum += value if current_sum == 0: max_length = index + 1 if current_sum in sum_index_map: max_length = max(max_length, index - sum_index_map[current_sum]) else: sum_index_map[current_sum] = index return max_length"},{"question":"def interpret_z_score(z_score: float) -> str: Interprets the given z-score in the context of customer rating. :param z_score: float, the z-score of the customer's rating :return: string, explanation of the z-score implies that the customer's rating is 1.5 standard deviations above the mean rating >>> interpret_z_score(1.5) \\"The customer's rating is 1.5 standard deviations above the mean rating.\\" >>> interpret_z_score(2.0) \\"This function specifically interprets a z-score of 1.5.\\"","solution":"def interpret_z_score(z_score): Interprets the given z-score in the context of customer rating. :param z_score: float, the z-score of the customer's rating :return: string, explanation of the z-score implies that the customer's rating is 1.5 standard deviations above the mean rating if z_score == 1.5: return \\"The customer's rating is 1.5 standard deviations above the mean rating.\\" else: return \\"This function specifically interprets a z-score of 1.5.\\""},{"question":"def fizzbuzz(n: int) -> None: Prints the FizzBuzz sequence up to the given number n. Handles invalid input gracefully. Arguments: n : int : The upper bound of the FizzBuzz sequence to generate. Returns: None Raises: ValueError: If n is not a positive integer or if n is not an integer. >>> fizzbuzz(15) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz >>> fizzbuzz(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> fizzbuzz(-5) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> fizzbuzz('a') Traceback (most recent call last): ... ValueError: Input must be an integer >>> fizzbuzz(4.5) Traceback (most recent call last): ... ValueError: Input must be an integer","solution":"def fizzbuzz(n): Prints the FizzBuzz sequence up to the given number n. Arguments: n : int : The upper bound of the FizzBuzz sequence to generate. Returns: None Raises: ValueError: If n is not a positive integer. if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") for i in range(1, n + 1): output = '' if i % 3 == 0: output += 'Fizz' if i % 5 == 0: output += 'Buzz' if not output: output = str(i) print(output)"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Args: strs: A list of strings. Returns: The longest common prefix string. # Some unit tests to check the correctness of your implementation def test_all_strings_have_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dogmatic\\", \\"dogma\\", \\"dog\\"]) == \\"dog\\" def test_no_common_prefix(): assert longest_common_prefix([\\"cat\\", \\"dog\\", \\"bird\\"]) == \\"\\" assert longest_common_prefix([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"\\" def test_empty_list(): assert longest_common_prefix([]) == \\"\\" def test_single_string_list(): assert longest_common_prefix([\\"apple\\"]) == \\"apple\\" assert longest_common_prefix([\\"\\"]) == \\"\\" def test_common_prefix_with_empty_string(): assert longest_common_prefix([\\"\\", \\"\\"]) == \\"\\" def test_mixed_length_strings(): assert longest_common_prefix([\\"cir\\", \\"car\\"]) == \\"c\\" assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" def test_all_strings_are_identical(): assert longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) == \\"same\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. Args: strs: A list of strings. Returns: The longest common prefix string. if not strs: return \\"\\" # Sort the list, the shortest string will be the prefix of a common prefix if there's one strs.sort() # Take the first and the last string in the sorted list first, last = strs[0], strs[-1] # Compare characters until they match i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> dict: Merges two dictionaries. If both dictionaries have the same key, the value from the second dictionary is taken. Parameters: dict1 (dict): First dictionary dict2 (dict): Second dictionary Returns: dict: Merged dictionary >>> merge_dicts({'a': 1, 'b': 2}, {'b': 20, 'c': 3}) {'a': 1, 'b': 20, 'c': 3} >>> merge_dicts({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2} >>> merge_dicts({'a': 1, 'b': 2}, {}) {'a': 1, 'b': 2} >>> merge_dicts({}, {}) {}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries. If both dictionaries have the same key, the value from the second dictionary is taken. Parameters: dict1 (dict): First dictionary dict2 (dict): Second dictionary Returns: dict: Merged dictionary result = dict1.copy() # Start with the keys and values from dict1 result.update(dict2) # Update with the keys and values from dict2, overwriting existing keys return result"},{"question":"from typing import List, Dict from datetime import datetime, timedelta def identify_delayed_flights(flights: List[Dict[str, str]]) -> List[Dict[str, str]]: Identifies all flights that are delayed by more than 30 minutes. Args: flights (List[Dict[str, str]]): A list of flight records. Returns: List[Dict[str, str]]: A list of delayed flight records. pass def calculate_average_delay(flights: List[Dict[str, str]]) -> Dict[str, float]: Calculates the average delay time for each airport. Args: flights (List[Dict[str, str]]): A list of flight records. Returns: Dict[str, float]: A dictionary with airports as keys and average delay times as values. pass def optimize_departure_times(flights: List[Dict[str, str]], avg_delay_dict: Dict[str, float]) -> List[Dict[str, str]]: Suggests optimized departure times for flights originating from congested airports. Args: flights (List[Dict[str, str]]): A list of flight records. avg_delay_dict (Dict[str, float]): A dictionary with airports as keys and average delay times as values. Returns: List[Dict[str, str]]: A list of flight records with optimized departure times. pass # Unit Tests def test_identify_delayed_flights(): dataset = [ {'flight_number': 'A101', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 08:00:00', 'actual_departure': '2023-10-01 08:45:00'}, {'flight_number': 'A102', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 09:00:00', 'actual_departure': '2023-10-01 09:30:00'}, {'flight_number': 'A103', 'origin': 'ATL', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 10:00:00', 'actual_departure': '2023-10-01 10:05:00'} ] delayed_flights = identify_delayed_flights(dataset) assert len(delayed_flights) == 1 assert delayed_flights[0]['flight_number'] == 'A101' def test_calculate_average_delay(): dataset = [ {'flight_number': 'A101', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 08:00:00', 'actual_departure': '2023-10-01 08:45:00'}, {'flight_number': 'A102', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 09:00:00', 'actual_departure': '2023-10-01 09:30:00'}, {'flight_number': 'A103', 'origin': 'ATL', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 10:00:00', 'actual_departure': '2023-10-01 10:05:00'} ] avg_delay_dict = calculate_average_delay(dataset) assert avg_delay_dict['JFK'] == 37.5 assert avg_delay_dict['ATL'] == 5.0 def test_optimize_departure_times(): dataset = [ {'flight_number': 'A101', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 08:00:00', 'actual_departure': '2023-10-01 08:45:00'}, {'flight_number': 'A102', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 09:00:00', 'actual_departure': '2023-10-01 09:30:00'}, {'flight_number': 'A103', 'origin': 'ATL', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 10:00:00', 'actual_departure': '2023-10-01 10:05:00'} ] avg_delay_dict = calculate_average_delay(dataset) optimized_flights = optimize_departure_times(dataset, avg_delay_dict) assert optimized_flights[0]['optimized_departure'] == '2023-10-01 07:22:30' assert optimized_flights[1]['optimized_departure'] == '2023-10-01 08:22:30' assert optimized_flights[2]['optimized_departure'] == '2023-10-01 09:55:00'","solution":"import pandas as pd import numpy as np from datetime import datetime, timedelta def identify_delayed_flights(flights): delayed_flights = [] for flight in flights: scheduled_time = datetime.strptime(flight['scheduled_departure'], '%Y-%m-%d %H:%M:%S') actual_time = datetime.strptime(flight['actual_departure'], '%Y-%m-%d %H:%M:%S') delay = (actual_time - scheduled_time).total_seconds() / 60.0 # delay in minutes if delay > 30: delayed_flights.append(flight) return delayed_flights def calculate_average_delay(flights): delay_dict = {} count_dict = {} for flight in flights: airport = flight['origin'] scheduled_time = datetime.strptime(flight['scheduled_departure'], '%Y-%m-%d %H:%M:%S') actual_time = datetime.strptime(flight['actual_departure'], '%Y-%m-%d %H:%M:%S') delay = (actual_time - scheduled_time).total_seconds() / 60.0 # delay in minutes if airport not in delay_dict: delay_dict[airport] = 0 count_dict[airport] = 0 delay_dict[airport] += delay count_dict[airport] += 1 avg_delay_dict = {airport: (delay_dict[airport] / count_dict[airport]) for airport in delay_dict} return avg_delay_dict def optimize_departure_times(flights, avg_delay_dict): optimized_flights = [] for flight in flights: airport = flight['origin'] avg_delay = avg_delay_dict.get(airport, 0) scheduled_time = datetime.strptime(flight['scheduled_departure'], '%Y-%m-%d %H:%M:%S') optimized_time = scheduled_time + timedelta(minutes=-avg_delay) flight['optimized_departure'] = optimized_time.strftime('%Y-%m-%d %H:%M:%S') optimized_flights.append(flight) return optimized_flights # Example usage with a dataset: # Assuming \`dataset\` is a list of dictionaries containing flight records. dataset = [ {'flight_number': 'A101', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 08:00:00', 'actual_departure': '2023-10-01 08:45:00'}, {'flight_number': 'A102', 'origin': 'JFK', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 09:00:00', 'actual_departure': '2023-10-01 09:30:00'}, {'flight_number': 'A103', 'origin': 'ATL', 'destination': 'LAX', 'scheduled_departure': '2023-10-01 10:00:00', 'actual_departure': '2023-10-01 10:05:00'} ] # Step 1: Identify delayed flights delayed_flights = identify_delayed_flights(dataset) # Step 2: Calculate average delay per airport avg_delay_dict = calculate_average_delay(dataset) # Step 3: Optimize departure times optimized_flights = optimize_departure_times(dataset, avg_delay_dict)"},{"question":"def cumulative_product(lst): Given a list of integers, returns a new list with each element being the cumulative product of the elements up to that position. Parameters: lst (list): A list of integers. Returns: list: A list of integers representing the cumulative product. >>> cumulative_product([1, 2, 3, 4]) [1, 2, 6, 24] >>> cumulative_product([5]) [5] >>> cumulative_product([]) [] >>> cumulative_product([1, 1, 1, 1]) [1, 1, 1, 1] >>> cumulative_product([1, 2, 0, 4]) [1, 2, 0, 0] >>> cumulative_product([-1, -2, -3, -4]) [-1, 2, -6, 24] >>> cumulative_product([-1, 2, -3, 4]) [-1, -2, 6, 24]","solution":"def cumulative_product(lst): Given a list of integers, returns a new list with each element being the cumulative product of the elements up to that position. Parameters: lst (list): A list of integers. Returns: list: A list of integers representing the cumulative product. if not lst: return [] result = [lst[0]] for i in range(1, len(lst)): result.append(result[-1] * lst[i]) return result"},{"question":"def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list containing the elements that are present in both input lists, sorted in ascending order. The function avoids using set operations. >>> find_common_elements([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> find_common_elements([1, 2, 3], [4, 5, 6]) [] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3], []) [] >>> find_common_elements([], []) [] >>> find_common_elements([1, 1, 2, 3], [1, 1, 1, 3, 4]) [1, 3] >>> find_common_elements([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> find_common_elements([5, 2, 1, 4], [6, 4, 3, 2]) [2, 4]","solution":"def find_common_elements(list1, list2): Returns a list containing the elements that are present in both input lists, sorted in ascending order. The function avoids using set operations. The time complexity is O(n + m), where n and m are the lengths of the two lists. list1.sort() list2.sort() common_elements = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: if not common_elements or list1[i] != common_elements[-1]: # Avoid duplicates common_elements.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common_elements"},{"question":"class Task: def __init__(self, description): Initialize a task with a description and a completion status set to False. def mark_completed(self): Mark the task as completed. def __str__(self): Return a string representation of the task, including its status (completed or not). class ToDoList: def __init__(self): Initialize an empty to-do list containing tasks. def add_task(self, description): Add a new task with the given description to the to-do list. def mark_task_completed(self, task_index): Mark the task at the given index as completed. If the task does not exist, print \\"Task does not exist.\\" def remove_completed_task(self, task_index): Remove the completed task at the given index. If the task does not exist, print \\"Task does not exist.\\" If the task isn't completed, print \\"Task is not completed.\\" def display_tasks(self): Display all tasks in the to-do list along with their statuses. def main(): Main function to drive the command-line to-do list application providing options to add, mark, remove tasks, display tasks, or exit. if __name__ == '__main__': main() # Tests def test_task_creation(): task = Task(\\"Test task\\") assert task.description == \\"Test task\\" assert not task.completed def test_task_mark_completed(): task = Task(\\"Test task\\") task.mark_completed() assert task.completed def test_todo_list_add_task(): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") assert len(todo_list.tasks) == 1 assert todo_list.tasks[0].description == \\"Test task 1\\" assert not todo_list.tasks[0].completed def test_todo_list_mark_task_completed(): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") todo_list.mark_task_completed(0) assert todo_list.tasks[0].completed def test_todo_list_remove_completed_task(): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") todo_list.mark_task_completed(0) todo_list.remove_completed_task(0) assert len(todo_list.tasks) == 0 def test_todo_list_remove_non_existent_task(): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") todo_list.remove_completed_task(1) # Should print \\"Task does not exist.\\" assert len(todo_list.tasks) == 1 def test_todo_list_remove_non_completed_task(): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") todo_list.remove_completed_task(0) # Should print \\"Task is not completed.\\" assert len(todo_list.tasks) == 1 def test_todo_list_display_tasks(capsys): todo_list = ToDoList() todo_list.add_task(\\"Test task 1\\") todo_list.display_tasks() captured = capsys.readouterr() assert \\"Test task 1\\" in captured.out","solution":"class Task: def __init__(self, description): self.description = description self.completed = False def mark_completed(self): self.completed = True def __str__(self): status = \\"Completed\\" if self.completed else \\"Not Completed\\" return f\\"{self.description} - {status}\\" class ToDoList: def __init__(self): self.tasks = [] def add_task(self, description): task = Task(description) self.tasks.append(task) def mark_task_completed(self, task_index): if 0 <= task_index < len(self.tasks): self.tasks[task_index].mark_completed() else: print(\\"Task does not exist.\\") def remove_completed_task(self, task_index): if 0 <= task_index < len(self.tasks): if self.tasks[task_index].completed: del self.tasks[task_index] else: print(\\"Task is not completed.\\") else: print(\\"Task does not exist.\\") def display_tasks(self): if not self.tasks: print(\\"No tasks available.\\") for idx, task in enumerate(self.tasks, 1): print(f\\"Task {idx}: {task}\\") def main(): todo_list = ToDoList() while True: print(\\"nTo-Do List Manager\\") print(\\"1. Add a new task\\") print(\\"2. Mark a task as completed\\") print(\\"3. Remove a completed task\\") print(\\"4. Display all tasks\\") print(\\"5. Exit\\") choice = input(\\"Select an option: \\") if choice == '1': description = input(\\"Enter task description: \\") todo_list.add_task(description) elif choice == '2': task_index = int(input(\\"Enter task index to mark as completed: \\")) - 1 todo_list.mark_task_completed(task_index) elif choice == '3': task_index = int(input(\\"Enter task index to remove: \\")) - 1 todo_list.remove_completed_task(task_index) elif choice == '4': todo_list.display_tasks() elif choice == '5': break else: print(\\"Invalid option. Please try again.\\") if __name__ == '__main__': main()"},{"question":"class Library: def __init__(self): Initializes an empty library self.books = [] def add_book(self, title, author, year): Adds a new book to the library. >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) \\"Book added successfully.\\" >>> len(library.books) == 1 >>> library.books[0] == {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'year': 1925} pass def remove_book(self, title): Removes a book by its title. >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) >>> library.remove_book(\\"The Great Gatsby\\") \\"Book removed successfully.\\" >>> len(library.books) == 0 >>> library.remove_book(\\"Non-existent Book\\") \\"Book not found.\\" pass def search_books(self, query): Searches for books by title or author. >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> results = library.search_books(\\"F. Scott Fitzgerald\\") >>> len(results) == 1 >>> results[0] == {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'year': 1925} >>> results = library.search_books(\\"Mockingbird\\") >>> len(results) == 1 >>> results[0] == {'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\", 'year': 1960} >>> results = library.search_books(\\"Non-existent Author\\") >>> len(results) == 0 pass def list_books(self): Lists all the current books in the library. >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> books = library.list_books() >>> len(books) == 2 >>> books[0] == {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'year': 1925} >>> books[1] == {'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\", 'year': 1960} pass","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, year): Adds a new book to the library. book = {'title': title, 'author': author, 'year': year} self.books.append(book) return \\"Book added successfully.\\" def remove_book(self, title): Removes a book by its title. for book in self.books: if book['title'] == title: self.books.remove(book) return \\"Book removed successfully.\\" return \\"Book not found.\\" def search_books(self, query): Searches for books by title or author. results = [book for book in self.books if query.lower() in book['title'].lower() or query.lower() in book['author'].lower()] return results def list_books(self): Lists all the current books in the library. return self.books"},{"question":"def compute_special_string(n: int, x: int, y: int) -> str: Generates a string of length n, alternating between characters represented by ASCII values x and y. Parameters: n (int): The length of the desired output string. x (int): ASCII value of the first character. y (int): ASCII value of the second character. Returns: str: The alternating string of length n or an empty string if input is invalid. Examples: >>> compute_special_string(5, 65, 66) 'ABABA' >>> compute_special_string(8, 36, 64) '@@@@' >>> compute_special_string(3, 50, 51) '232' >>> compute_special_string(0, 100, 101) '' >>> compute_special_string(6, 31, 60) '' >>> compute_special_string(4, 60, 127) ''","solution":"def compute_special_string(n, x, y): Generates a string based on alternating characters represented by ASCII values x and y. Parameters: n (int): The length of the desired output string. x (int): ASCII value of the first character. y (int): ASCII value of the second character. Returns: str: The alternating string of length n or an empty string if input is invalid. # Check for invalid conditions if n <= 0 or not (33 <= x <= 126) or not (33 <= y <= 126): return \\"\\" # Convert ASCII values to characters char_x = chr(x) char_y = chr(y) # Generate the alternating string result = [] for i in range(n): if i % 2 == 0: result.append(char_x) else: result.append(char_y) return \\"\\".join(result)"},{"question":"def reverse_list(lst): Returns the reversed list without using built-in reverse functions. >>> reverse_list([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_list([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> reverse_list([1, 2, 3]) [3, 2, 1] >>> reverse_list([3, 2, 1]) [1, 2, 3] >>> reverse_list([]) [] >>> reverse_list([1]) [1] >>> reverse_list([-1, -2, -3, -4, -5]) [-5, -4, -3, -2, -1] >>> reverse_list([-5, 4, -3, 2, -1]) [-1, 2, -3, 4, -5]","solution":"def reverse_list(lst): Returns the reversed list without using built-in reverse functions. reversed_lst = [] for item in lst[::-1]: reversed_lst.append(item) return reversed_lst # Example usage: # Input: [1, 2, 3, 4, 5] # Output: [5, 4, 3, 2, 1]"},{"question":"def merge_sort(arr): Sorts an array of integers in ascending order using the merge sort algorithm. >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([3, 1]) [1, 3] >>> merge_sort([1]) [1] >>> merge_sort([]) [] >>> merge_sort([3, -2, 5, -1, 0]) [-2, -1, 0, 3, 5] >>> merge_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge_sort([-5, -23, -1, -7]) [-23, -7, -5, -1] pass def merge(left, right): Merges two sorted arrays into one sorted array. >>> merge([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge([1, 2], [3, 4]) [1, 2, 3, 4] >>> merge([0], [0]) [0, 0] >>> merge([], []) [] >>> merge([], [1, 2, 3]) [1, 2, 3] pass","solution":"def merge_sort(arr): Sorts an array of integers in ascending order using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted arrays into one sorted array. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"from datetime import datetime from typing import List, Tuple def find_earliest_transaction(transactions: List[Tuple[int, str, float]]) -> Tuple[int, str, float]: Returns the earliest transaction from a list of transactions. If multiple transactions have the same earliest timestamp, returns the one with the smallest transaction ID. Parameters: transactions (list of tuple): A list of transactions, each represented as a tuple (transaction_id, timestamp, amount). Returns: tuple: The earliest transaction. >>> transactions1 = [ ... (1, \\"2023-01-15 12:30:00\\", 100.50), ... (2, \\"2023-01-10 16:45:00\\", 200.75), ... (3, \\"2023-01-10 16:45:00\\", 150.25) ... ] >>> find_earliest_transaction(transactions1) (2, \\"2023-01-10 16:45:00\\", 200.75) >>> transactions2 = [ ... (10, \\"2022-12-31 23:59:59\\", 500.00), ... (8, \\"2022-12-31 23:59:59\\", 300.00), ... (15, \\"2023-01-01 00:00:01\\", 750.00) ... ] >>> find_earliest_transaction(transactions2) (8, \\"2022-12-31 23:59:59\\", 300.00) >>> transactions3 = [ ... (4, \\"2022-11-11 11:11:11\\", 444.44), ... (7, \\"2022-12-01 01:01:01\\", 777.77), ... (6, \\"2023-01-01 00:00:00\\", 666.66) ... ] >>> find_earliest_transaction(transactions3) (4, \\"2022-11-11 11:11:11\\", 444.44)","solution":"from datetime import datetime def find_earliest_transaction(transactions): Returns the earliest transaction from a list of transactions. If multiple transactions have the same earliest timestamp, returns the one with the smallest transaction ID. Parameters: transactions (list of tuple): A list of transactions, each represented as a tuple (transaction_id, timestamp, amount). Returns: tuple: The earliest transaction. return min(transactions, key=lambda x: (datetime.strptime(x[1], '%Y-%m-%d %H:%M:%S'), x[0])) # Test cases transactions1 = [ (1, \\"2023-01-15 12:30:00\\", 100.50), (2, \\"2023-01-10 16:45:00\\", 200.75), (3, \\"2023-01-10 16:45:00\\", 150.25) ] print(find_earliest_transaction(transactions1)) # Output: (2, \\"2023-01-10 16:45:00\\", 200.75) transactions2 = [ (10, \\"2022-12-31 23:59:59\\", 500.00), (8, \\"2022-12-31 23:59:59\\", 300.00), (15, \\"2023-01-01 00:00:01\\", 750.00) ] print(find_earliest_transaction(transactions2)) # Output: (8, \\"2022-12-31 23:59:59\\", 300.00) transactions3 = [ (4, \\"2022-11-11 11:11:11\\", 444.44), (7, \\"2022-12-01 01:01:01\\", 777.77), (6, \\"2023-01-01 00:00:00\\", 666.66) ] print(find_earliest_transaction(transactions3)) # Output: (4, \\"2022-11-11 11:11:11\\", 444.44)"},{"question":"def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than the given number. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(2) [] >>> primes_less_than(1) [] >>> primes_less_than(3) [2] >>> primes_less_than(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Write a function that takes a list of integers and removes the duplicates, preserving the original order of their first occurrence. Your implementation should not use any built-in functions that directly solve the problem (like set or collections.OrderedDict). >>> remove_duplicates([5, 3, 5, 7, 3, 9]) [5, 3, 7, 9] >>> remove_duplicates([1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> remove_duplicates([5, 5, 5]) [5] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([10]) [10] >>> remove_duplicates([5, 1, 2]) [5, 1, 2] >>> large_list = list(range(1000)) + list(range(500)) >>> remove_duplicates(large_list) list(range(1000))","solution":"def remove_duplicates(lst): Removes duplicates from list, preserving the original order of their first occurrence. Parameters: lst (list): List of integers containing duplicates. Returns: list: List of integers with duplicates removed. seen = {} result = [] for item in lst: if item not in seen: seen[item] = True result.append(item) return result"},{"question":"def rotate_right(arr: List[int], k: int) -> None: Rotates the elements of the array arr to the right by k steps. This function modifies the input array in-place. :param arr: List[int] - the list of integers to be rotated :param k: int - the number of steps to rotate the array to the right :return: None # Unit tests def test_rotate_right_basic(): arr = [1, 2, 3, 4, 5, 6, 7] rotate_right(arr, 3) assert arr == [5, 6, 7, 1, 2, 3, 4] def test_rotate_right_full_rotation(): arr = [1, 2, 3, 4, 5, 6, 7] rotate_right(arr, 7) assert arr == [1, 2, 3, 4, 5, 6, 7] def test_rotate_right_more_than_length(): arr = [1, 2, 3, 4, 5, 6, 7] rotate_right(arr, 10) assert arr == [5, 6, 7, 1, 2, 3, 4] def test_rotate_right_single_element(): arr = [1] rotate_right(arr, 3) assert arr == [1] def test_rotate_right_no_rotation(): arr = [1, 2, 3, 4, 5, 6, 7] rotate_right(arr, 0) assert arr == [1, 2, 3, 4, 5, 6, 7] def test_rotate_right_two_elements(): arr = [1, 2] rotate_right(arr, 1) assert arr == [2, 1] def test_rotate_right_large_array(): arr = list(range(1, 101)) # Array from 1 to 100 rotate_right(arr, 50) assert arr == list(range(51, 101)) + list(range(1, 51))","solution":"def rotate_right(arr, k): Rotates the elements of the array arr to the right by k steps. :param arr: List[int] - the list of integers to be rotated :param k: int - the number of steps to rotate the array to the right :return: void - the array is modified in-place n = len(arr) k = k % n # In case k is greater than the length of the array def reverse(start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 reverse(0, n - 1) # Reverse the entire array reverse(0, k - 1) # Reverse the first k elements reverse(k, n - 1) # Reverse the remaining elements"},{"question":"def filter_even_and_greater_than(input_list: List[int], threshold: int) -> List[int]: Returns a list of elements that are even and greater than the given threshold. Parameters: - input_list: List of integers - threshold: Integer threshold Returns: - List of integers that are even and greater than the threshold Examples: >>> filter_even_and_greater_than([5, 12, 7, 20, 15, 32], 10) [12, 20, 32] >>> filter_even_and_greater_than([3, 8, 10], 15) [] >>> filter_even_and_greater_than([16, 18, 22, 24], 15) [16, 18, 22, 24] >>> filter_even_and_greater_than([1, 4, 5, 7, 10, 15, 19, 21], 3) [4, 10] >>> filter_even_and_greater_than([-20, -10, 0, 10, 20], 0) [10, 20] >>> filter_even_and_greater_than([1, 3, 5, 7], 10) [] >>> filter_even_and_greater_than([], 10) []","solution":"def filter_even_and_greater_than(input_list, threshold): Returns a list of elements that are even and greater than the given threshold. Parameters: - input_list: List of integers - threshold: Integer threshold Returns: - List of integers that are even and greater than the threshold return [x for x in input_list if x % 2 == 0 and x > threshold] # Example usage: input_list = [5, 12, 7, 20, 15, 32] threshold = 10 print(filter_even_and_greater_than(input_list, threshold)) # Output: [12, 20, 32]"},{"question":"from typing import List def has_pair_with_sum(numbers: List[int], target_sum: int) -> bool: Determines if there are any two distinct integers in the list that sum up to the target. :param numbers: List of integers to search through. :param target_sum: The target sum to find. :return: True if a pair with the sum exists, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([5, -2, 3, 6], 1) True","solution":"def has_pair_with_sum(numbers, target_sum): Determines if there are any two distinct integers in the list that sum up to the target. :param numbers: List of integers to search through. :param target_sum: The target sum to find. :return: True if a pair with the sum exists, False otherwise. seen = set() for number in numbers: complement = target_sum - number if complement in seen: return True seen.add(number) return False"},{"question":"from typing import List, Dict def count_integers(lst: List[int]) -> Dict[int, int]: Write a Python function that takes a list of integers as input and returns a dictionary where the key is the integer and the value is the number of times that integer appears in the list. If an integer appears only once, it should not be included in the dictionary. >>> count_integers([1, 2, 2, 3, 3, 3]) {2: 2, 3: 3} >>> count_integers([1, 2, 3, 4, 5]) {} >>> count_integers([1, 1, 2, 3, 3, 4, 4, 4]) {1: 2, 3: 2, 4: 3} >>> count_integers([]) {} >>> count_integers([1, 1, 1, 1, 1]) {1: 5}","solution":"def count_integers(lst): Returns a dictionary where the keys are the integers from the list and the values are the number of times each integer appears in the list. Integers that appear only once are not included in the dictionary. from collections import Counter counter = Counter(lst) result = {k: v for k, v in counter.items() if v > 1} return result"},{"question":"from typing import List, Tuple, Dict def segregate_and_calculate_ratio(numbers: List[int]) -> Tuple[Dict[str, List[int]], float]: Takes in a list of integers and returns a dictionary with two keys, \\"even\\" and \\"odd\\". The value for each key should be a list of integers from the input that are even and odd respectively. Also returns the ratio of the sum of even numbers to the sum of odd numbers. >>> segregate_and_calculate_ratio([12, 45, 23, 8, 16, 7, 14]) ({'even': [12, 8, 16, 14], 'odd': [45, 23, 7]}, 2.148) >>> segregate_and_calculate_ratio([]) ({'even': [], 'odd': []}, float('inf')) >>> segregate_and_calculate_ratio([2, 4, 6, 8]) ({'even': [2, 4, 6, 8], 'odd': []}, float('inf')) >>> segregate_and_calculate_ratio([1, 3, 5, 7]) ({'even': [], 'odd': [1, 3, 5, 7]}, 0.0) >>> segregate_and_calculate_ratio([0, 1, 2, 3]) ({'even': [0, 2], 'odd': [1, 3]}, 0.5) >>> segregate_and_calculate_ratio([2]) ({'even': [2], 'odd': []}, float('inf')) >>> segregate_and_calculate_ratio([1]) ({'even': [], 'odd': [1]}, 0.0)","solution":"def segregate_and_calculate_ratio(numbers): Segregates the input list of integers into even and odd numbers and returns a dictionary with keys 'even' and 'odd'. Also returns the ratio of the sum of even numbers to the sum of odd numbers. even = [num for num in numbers if num % 2 == 0] odd = [num for num in numbers if num % 2 != 0] sum_even = sum(even) sum_odd = sum(odd) ratio = sum_even / sum_odd if sum_odd != 0 else float('inf') return {'even': even, 'odd': odd}, ratio"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list where each element is the product of all other elements in the input list. Args: nums: List of integers Returns: List of integers pass # Replace with your implementation # Unit tests def test_product_except_self_general_case(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_product_except_self_single_element(): assert product_except_self([5]) == [1] def test_product_except_self_two_elements(): assert product_except_self([9, 3]) == [3, 9] def test_product_except_self_with_zero(): assert product_except_self([5, 0, 2]) == [0, 10, 0] def test_product_except_self_all_zeroes(): assert product_except_self([0, 0, 0]) == [0, 0, 0] def test_product_except_self_empty_list(): assert product_except_self([]) == [] def test_product_except_self_negative_numbers(): assert product_except_self([-1, -2, -3]) == [6, 3, 2]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the input list. Args: nums: List of integers Returns: List of integers if not nums: return [] length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length-1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def filter_odd_numbers(lst: list[int]) -> list[int]: Returns a list containing only the odd numbers from the original list. >>> filter_odd_numbers([10, 21, 32, 43, 54]) [21, 43] >>> filter_odd_numbers([2, 4, 6, 8]) [] >>> filter_odd_numbers([1, 3, 5, 7]) [1, 3, 5, 7] >>> filter_odd_numbers([]) [] >>> filter_odd_numbers([-1, -2, -3, -4, -5]) [-1, -3, -5] >>> filter_odd_numbers([1]) [1] >>> filter_odd_numbers([2]) [] >>> filter_odd_numbers([0, 1, 2, 3, 4, 5]) [1, 3, 5]","solution":"def filter_odd_numbers(lst): Returns a list containing only the odd numbers from the original list. :param lst: list of integers :return: list of odd integers return [num for num in lst if num % 2 != 0]"},{"question":"def unique_permutations(string: str) -> List[str]: Returns a list of all unique permutations of the string using a recursive approach. >>> unique_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> unique_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> unique_permutations(\\"a\\") ['a'] def test_unique_permutations_simple(): assert sorted(unique_permutations(\\"aab\\")) == sorted([\\"aab\\", \\"aba\\", \\"baa\\"]) def test_unique_permutations_single_char(): assert sorted(unique_permutations(\\"a\\")) == sorted([\\"a\\"]) def test_unique_permutations_two_chars(): assert sorted(unique_permutations(\\"ab\\")) == sorted([\\"ab\\", \\"ba\\"]) def test_unique_permutations_with_duplicates(): assert sorted(unique_permutations(\\"aa\\")) == sorted([\\"aa\\"]) def test_unique_permutations_long_string(): result = unique_permutations(\\"abc\\") expected = [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert sorted(result) == sorted(expected) def test_unique_permutations_repeated_chars(): result = unique_permutations(\\"aabb\\") expected = [\\"aabb\\", \\"abab\\", \\"abba\\", \\"baab\\", \\"baba\\", \\"bbaa\\"] assert sorted(result) == sorted(expected)","solution":"def unique_permutations(string): Returns a list containing all unique permutations of the input string. def permute(s): if len(s) <= 1: return {s} else: perms = set() for i, char in enumerate(s): for perm in permute(s[:i] + s[i+1:]): perms.add(char + perm) return perms return list(permute(string))"},{"question":"def first_missing_positive(nums: List[int]) -> int: Finds the smallest missing positive integer in an unsorted array. Parameters: nums (List[int]): The input list of integers Returns: int: The smallest missing positive integer Examples: >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from solution import first_missing_positive def test_example1(): assert first_missing_positive([1, 2, 0]) == 3 def test_example2(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_example3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_single_positive(): assert first_missing_positive([1]) == 2 def test_single_negative(): assert first_missing_positive([-1]) == 1 def test_all_negatives(): assert first_missing_positive([-1, -2, -3]) == 1 def test_all_zeros(): assert first_missing_positive([0, 0, 0]) == 1 def test_repeated_numbers(): assert first_missing_positive([1, 1, 1, 1]) == 2 def test_mixed_numbers(): assert first_missing_positive([3, 4, 2, 1, 5, 0, -1]) == 6","solution":"def first_missing_positive(nums): Finds the smallest missing positive integer in an unsorted array. Parameters: nums (List[int]): The input list of integers Returns: int: The smallest missing positive integer n = len(nums) # Step 1: Replace negative numbers, zeros, and numbers larger than n with n+1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash and mark the presence of an element for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first index that is positive is the smallest missing positive number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"from typing import List, Dict from functools import reduce def calculate_average(grades: List[int]) -> float: Calculates the average of a list of grades. >>> calculate_average([85, 90, 78]) 84.33333333333333 >>> calculate_average([82, 88, 91]) 87.0 >>> calculate_average([]) 0 def process_student_records_functional(records: List[Dict[str, List[int]]]) -> Dict[str, float]: Processes student records to calculate average grade using functional programming. >>> records = [{'name': 'Alice', 'grades': [85, 90, 78]}, {'name': 'Bob', 'grades': [82, 88, 91]}] >>> process_student_records_functional(records) {'Alice': 84.33333333333333, 'Bob': 87.0} >>> records = [{'name': 'Alice', 'grades': []}] >>> process_student_records_functional(records) {'Alice': 0} def process_student_records_imperative(records: List[Dict[str, List[int]]]) -> Dict[str, float]: Processes student records to calculate average grade using imperative approach. >>> records = [{'name': 'Alice', 'grades': [85, 90, 78]}, {'name': 'Bob', 'grades': [82, 88, 91]}] >>> process_student_records_imperative(records) {'Alice': 84.33333333333333, 'Bob': 87.0} >>> records = [{'name': 'Alice', 'grades': []}] >>> process_student_records_imperative(records) {'Alice': 0}","solution":"from functools import reduce def calculate_average(grades): Calculates the average of a list of grades. if not grades: return 0 return sum(grades) / len(grades) # Functional Programming Approach def process_student_records_functional(records): Processes student records to calculate average grade using functional programming. return dict(map(lambda record: (record['name'], calculate_average(record['grades'])), records)) # Imperative Programming Approach def process_student_records_imperative(records): Processes student records to calculate average grade using imperative approach. output = {} for record in records: name = record['name'] grades = record['grades'] output[name] = calculate_average(grades) return output # Analysis: # Functional Approach: # - Advantages: Code is more declarative and concise, easier to read for those familiar with functional programming # - Disadvantages: May be less intuitive for those unfamiliar with functional programming concepts, difficult to handle complex logical conditions # Imperative Approach: # - Advantages: Code is more explicit and easier to follow for beginners, easier to debug # - Disadvantages: Can become verbose and harder to maintain, especially when handling more complex operations # Example Data student_records = [ {'name': 'Alice', 'grades': [85, 90, 78]}, {'name': 'Bob', 'grades': [82, 88, 91]}, ]"},{"question":"def next_greater_elements(nums: List[int]) -> List[int]: Returns a list containing the next greater elements for each element in the original list. If no such element exists, returns -1 for that position. >>> next_greater_elements([4, 5, 2, 10, 8]) [5, 10, 10, -1, -1] >>> next_greater_elements([1, 2, 3, 4, 5]) [2, 3, 4, 5, -1] >>> next_greater_elements([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] >>> next_greater_elements([2, 1, 2, 4, 3]) [4, 2, 4, -1, -1] >>> next_greater_elements([]) [] >>> next_greater_elements([1]) [-1]","solution":"def next_greater_elements(nums): Returns a list containing the next greater elements for each element in the original list. If no such element exists, returns -1 for that position. result = [-1] * len(nums) stack = [] for i in range(len(nums)): while stack and nums[stack[-1]] < nums[i]: index = stack.pop() result[index] = nums[i] stack.append(i) return result"},{"question":"from collections import defaultdict from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: Groups a list of strings into categories where each group contains anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"word\\"]) [['word']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) [['listen', 'silent', 'enlist']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"abcd\\", \\"bcda\\"]) [['abc', 'bca', 'cab'], ['abcd', 'bcda']]","solution":"from collections import defaultdict def group_anagrams(strings): Groups a list of strings into categories where each group contains anagrams of each other. anagrams = defaultdict(list) for s in strings: sorted_s = ''.join(sorted(s)) anagrams[sorted_s].append(s) return list(anagrams.values())"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression containing positive integers, operators, and parentheses according to mathematical rules of precedence and returns the result. >>> evaluate_expression(\\"3 + 2\\") 5 >>> evaluate_expression(\\"4 * 2\\") 8 >>> evaluate_expression(\\"(3 + 2) * 4\\") 20 >>> evaluate_expression(\\"2 * (3 + (2 - 1) * 2)\\") 10 >>> evaluate_expression(\\"3 + 2 * (1 + 2 / (1 + 1))\\") 7.0","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing positive integers, operators, and parentheses according to mathematical rules of precedence and returns the result. try: result = eval(expression) except (SyntaxError, NameError): raise ValueError(\\"Invalid expression\\") return result"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aAbBcC\\") 6 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aa\\") 1 >>> length_of_longest_substring(\\"a!@#%^&*()_+b\\") 14","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. chars_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in chars_map: left = max(left, chars_map[char] + 1) chars_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"import random from typing import List, Dict def generate_students(num_students: int) -> List[Dict[str, object]]: Generates a list of dictionaries, where each dictionary represents a student with 'name', 'age', and 'grades'. >>> students = generate_students(5) >>> len(students) == 5 True >>> all(\\"name\\" in student and \\"age\\" in student and \\"grades\\" in student and len(student[\\"grades\\"]) == 5 for student in students) True def sort_students_by_average_grade(students: List[Dict[str, object]]) -> List[Dict[str, object]]: Sorts the list of students based on their average grade in descending order. >>> students = [ >>> {\\"name\\": \\"Alice\\", \\"age\\": 10, \\"grades\\": [100, 100, 100, 100, 100]}, >>> {\\"name\\": \\"Bob\\", \\"age\\": 11, \\"grades\\": [90, 90, 90, 90, 90]}, >>> {\\"name\\": \\"Charlie\\", \\"age\\": 12, \\"grades\\": [80, 80, 80, 80, 80]} >>> ] >>> sorted_students = sort_students_by_average_grade(students) >>> sorted_students[0][\\"name\\"] == \\"Alice\\" True >>> sorted_students[1][\\"name\\"] == \\"Bob\\" True >>> sorted_students[2][\\"name\\"] == \\"Charlie\\" True def top_n_students(students: List[Dict[str, object]], n: int = 3) -> List[str]: Returns the names of the top n students with the highest average grades. >>> students = [ >>> {\\"name\\": \\"Alice\\", \\"age\\": 10, \\"grades\\": [100, 100, 100, 100, 100]}, >>> {\\"name\\": \\"Bob\\", \\"age\\": 11, \\"grades\\": [90, 90, 90, 90, 90]}, >>> {\\"name\\": \\"Charlie\\", \\"age\\": 12, \\"grades\\": [80, 80, 80, 80, 80]}, >>> {\\"name\\": \\"David\\", \\"age\\": 13, \\"grades\\": [70, 70, 70, 70, 70]} >>> ] >>> top_students = top_n_students(students, 3) >>> top_students == [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] True >>> top_students = top_n_students(students, 2) >>> top_students == [\\"Alice\\", \\"Bob\\"] True >>> top_students = top_n_students(students, 5) >>> top_students == [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] True","solution":"import random def generate_students(num_students): Generates a list of dictionaries, where each dictionary represents a student with 'name', 'age', and 'grades'. students = [] for i in range(num_students): student = { \\"name\\": f\\"Student{i+1}\\", \\"age\\": random.randint(10, 20), \\"grades\\": [random.randint(0, 100) for _ in range(5)] } students.append(student) return students def sort_students_by_average_grade(students): Sorts the list of students based on their average grade in descending order. return sorted(students, key=lambda s: sum(s[\\"grades\\"]) / len(s[\\"grades\\"]), reverse=True) def top_n_students(students, n=3): Returns the names of the top n students with the highest average grades. sorted_students = sort_students_by_average_grade(students) return [student[\\"name\\"] for student in sorted_students[:n]]"},{"question":"from collections import defaultdict def validate_json(json_data: dict, schema: dict): Validates JSON data against a given schema and counts occurrences of each data type. >>> schema = { ... \\"name\\": \\"string\\", ... \\"age\\": \\"number\\", ... \\"email\\": \\"string?\\", ... \\"address\\": \\"object\\" ... } >>> json_data = { ... \\"name\\": \\"John Doe\\", ... \\"age\\": 30, ... \\"address\\": { ... \\"street\\": \\"1234 Elm Street\\", ... \\"city\\": \\"Exampleville\\", ... \\"zip\\": \\"12345\\" ... } ... } >>> validate_json(json_data, schema) (True, {'string': 4, 'number': 1, 'object': 2}) >>> json_data = { ... \\"name\\": \\"John Doe\\", ... \\"age\\": 30 ... } >>> validate_json(json_data, schema) (False, \\"Missing mandatory field: address\\") >>> json_data = { ... \\"name\\": \\"John Doe\\", ... \\"age\\": \\"30\\", ... \\"address\\": { ... \\"street\\": \\"1234 Elm Street\\", ... \\"city\\": \\"Exampleville\\", ... \\"zip\\": \\"12345\\" ... } ... } >>> validate_json(json_data, schema) (False, \\"Incorrect type for field 'age'. Expected number.\\")","solution":"def validate_json(json_data, schema): Validates JSON data against a given schema and counts occurrences of each data type. :param json_data: Dictionary containing JSON data to be validated :param schema: Dictionary containing schema to validate against :return: Tuple containing a validation status (True/False), and either an error message or data type summary from collections import defaultdict def check_type(data, expected_type): if expected_type == \\"number\\": return isinstance(data, (int, float)) elif expected_type == \\"string\\": return isinstance(data, str) elif expected_type == \\"object\\": return isinstance(data, dict) return False def count_data_types(data, counts): if isinstance(data, dict): counts['object'] += 1 for key, value in data.items(): count_data_types(value, counts) elif isinstance(data, str): counts['string'] += 1 elif isinstance(data, (int, float)): counts['number'] += 1 elif isinstance(data, list): counts['array'] += 1 for item in data: count_data_types(item, counts) # Validate schema for key, expected_type in schema.items(): if expected_type.endswith(\\"?\\"): expected_type = expected_type[:-1] if key not in json_data: continue if key not in json_data: return False, f\\"Missing mandatory field: {key}\\" if not check_type(json_data[key], expected_type): return False, f\\"Incorrect type for field '{key}'. Expected {expected_type}.\\" # Count occurrences of each type counts = defaultdict(int) count_data_types(json_data, counts) return True, counts"},{"question":"def longest_word(sentence: str) -> str: Returns the longest word in a sentence. If there are multiple words with the same maximum length, the first occurrence is returned. >>> longest_word(\\"hello\\") == \\"hello\\" >>> longest_word(\\"The quick brown fox jumped over the lazy dog\\") == \\"jumped\\" >>> longest_word(\\"cat bat rat hat\\") == \\"cat\\" >>> longest_word(\\"hello, goodbye! world.\\") == \\"goodbye!\\" >>> longest_word(\\"\\") == \\"\\" >>> longest_word(\\" \\") == \\"\\" >>> longest_word(\\"Cat CaT caT cAt cAt\\") == \\"Cat\\"","solution":"def longest_word(sentence): Returns the longest word in a sentence. If there are multiple words with the same maximum length, the first occurrence is returned. words = sentence.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def schedule_tasks(tasks: List[Dict[str, Any]]) -> List[str]: Schedules tasks such that all dependencies are respected. :param tasks: List of task dictionaries. Each task dictionary contains 'id', 'duration', and 'dependencies' keys. :return: List of task IDs in the order they should be executed. :raises: Exception if there are circular dependencies. >>> tasks = [ ... {'id': 'A', 'duration': 3, 'dependencies': []}, ... {'id': 'B', 'duration': 2, 'dependencies': ['A']}, ... {'id': 'C', 'duration': 1, 'dependencies': ['A']}, ... {'id': 'D', 'duration': 4, 'dependencies': ['B', 'C']} ... ] >>> schedule_tasks(tasks) ['A', 'B', 'C', 'D'] >>> tasks = [ ... {'id': 'A', 'duration': 3, 'dependencies': []}, ... {'id': 'B', 'duration': 2, 'dependencies': []}, ... {'id': 'C', 'duration': 1, 'dependencies': []}, ... ] >>> schedule_tasks(tasks) {'A', 'B', 'C'} >>> tasks = [ ... {'id': 'A', 'duration': 3, 'dependencies': []}, ... {'id': 'B', 'duration': 2, 'dependencies': ['A']}, ... {'id': 'C', 'duration': 1, 'dependencies': ['B']}, ... ] >>> schedule_tasks(tasks) ['A', 'B', 'C'] >>> tasks = [ ... {'id': 'A', 'duration': 3, 'dependencies': ['C']}, ... {'id': 'B', 'duration': 2, 'dependencies': ['A']}, ... {'id': 'C', 'duration': 1, 'dependencies': ['B']}, ... ] >>> schedule_tasks(tasks) Traceback (most recent call last): ... Exception: Circular dependencies detected >>> tasks = [ ... {'id': 'A', 'duration': 3, 'dependencies': []}, ... {'id': 'B', 'duration': 2, 'dependencies': ['A']}, ... {'id': 'C', 'duration': 1, 'dependencies': ['A', 'B']}, ... {'id': 'D', 'duration': 3, 'dependencies': ['A']}, ... {'id': 'E', 'duration': 2, 'dependencies': ['C', 'D']} ... ] >>> schedule_tasks(tasks) ['A', 'B', 'D', 'C', 'E']","solution":"def schedule_tasks(tasks): Schedules tasks such that all dependencies are respected. :param tasks: List of task dictionaries. Each task dictionary contains 'id', 'duration', and 'dependencies' keys. :return: List of task IDs in the order they should be executed. :raises: Exception if there are circular dependencies. from collections import deque, defaultdict # Create a graph and indegree count graph = defaultdict(list) indegree = defaultdict(int) for task in tasks: task_id = task['id'] indegree[task_id] = 0 # Ensure every task is in indegree map for dependency in task['dependencies']: graph[dependency].append(task_id) indegree[task_id] += 1 # Find all starting points (tasks with no dependencies) queue = deque([task_id for task_id in indegree if indegree[task_id] == 0]) # List to store the ordered tasks ordered_tasks = [] while queue: current_task = queue.popleft() ordered_tasks.append(current_task) for neighbor in graph[current_task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Check if there was a cycle if len(ordered_tasks) != len(tasks): raise Exception(\\"Circular dependencies detected\\") return ordered_tasks"},{"question":"def shift_string(s: str) -> str: Write a Python function that takes a string containing both numbers and letters, and returns a new string where all the letters are shifted by one position in the alphabet (with 'z' wrapping around to 'a') and all the digits are replaced by their successor (with '9' wrapping around to '0'). Non-alphanumeric characters should remain unchanged. For example, if the input is \\"hello123\\", the output should be \\"ifmmp234\\". >>> shift_string(\\"hello123\\") 'ifmmp234' >>> shift_string(\\"xyzXYZ789\\") 'yzaYZA890' >>> shift_string(\\"a1!z9@\\") 'b2!a0@' >>> shift_string(\\"\\") '' >>> shift_string(\\"!@#\\") '!@#' >>> shift_string(\\"a\\") 'b' >>> shift_string(\\"z\\") 'a' >>> shift_string(\\"0\\") '1' >>> shift_string(\\"9\\") '0'","solution":"def shift_string(s): Shifts each letter in the string by one position in the alphabet and each digit by its successor. Non-alphanumeric characters remain unchanged. shifted_str = [] for char in s: if char.isalpha(): if char == 'z': shifted_str.append('a') elif char == 'Z': shifted_str.append('A') else: shifted_str.append(chr(ord(char) + 1)) elif char.isdigit(): if char == '9': shifted_str.append('0') else: shifted_str.append(str(int(char) + 1)) else: shifted_str.append(char) return ''.join(shifted_str)"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Write a function that takes two strings as input and returns \`True\` if they are anagrams of each other, and \`False\` otherwise. An anagram is a word formed by rearranging the letters of another, such as \\"listen\\" and \\"silent\\". Ignore spaces, punctuation, and case differences. Examples: >>> is_anagram(\\"Dormitory\\", \\"dirty room\\") True >>> is_anagram(\\"astronomer\\", \\"moon starer\\") True >>> is_anagram(\\"hello\\", \\"world\\") False pass from solution import is_anagram def test_anagram_with_spaces(): assert is_anagram(\\"Dormitory\\", \\"dirty room\\") == True assert is_anagram(\\"The eyes\\", \\"They see\\") == True def test_anagram_with_punctuation(): assert is_anagram(\\"A man, a plan, a canal, Panama!\\", \\"A man a plan a canal Panama\\") == True def test_anagram_with_case_difference(): assert is_anagram(\\"Astronomer\\", \\"Moon starer\\") == True def test_not_anagram(): assert is_anagram(\\"hello\\", \\"world\\") == False def test_empty_strings(): assert is_anagram(\\"\\", \\"\\") == True def test_anagram_with_numbers(): assert is_anagram(\\"12345\\", \\"54321\\") == True assert is_anagram(\\"12345\\", \\"5432 1\\") == True","solution":"def is_anagram(str1, str2): Checks if two strings are anagrams of each other, ignoring spaces, punctuation, and case differences. import re # Remove all non-alphanumeric characters and convert to lower case clean_str1 = re.sub(r'[^a-zA-Z0-9]', '', str1).lower() clean_str2 = re.sub(r'[^a-zA-Z0-9]', '', str2).lower() # Check if sorted characters of both strings are the same return sorted(clean_str1) == sorted(clean_str2)"},{"question":"def create_schedule(meetings: List[Tuple[str, str]]) -> str: Write a function that creates a schedule for a single conference room, given a list of meetings. Each meeting is represented by a tuple with a start and end time. If any of the meetings overlap, the function should return 'Conflict', otherwise it should return 'No Conflict'. Additionally, ensure the proposed schedule is a balanced one by checking if the total number of hours of meetings is split as evenly as possible between the first and second half of the day. >>> create_schedule([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:00\\", \\"14:00\\"), (\\"15:00\\", \\"16:00\\")]) 'No Conflict' >>> create_schedule([(\\"09:00\\", \\"10:30\\"), (\\"10:15\\", \\"11:15\\")]) 'Conflict' >>> create_schedule([(\\"09:00\\", \\"10:30\\"), (\\"12:00\\", \\"12:30\\"), (\\"14:00\\", \\"15:30\\"), (\\"15:30\\", \\"16:00\\")]) 'No Conflict' >>> create_schedule([(\\"09:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:30\\"), (\\"14:00\\", \\"15:00\\")]) 'Unbalanced' >>> create_schedule([]) 'No Conflict'","solution":"def create_schedule(meetings): Given a list of meetings represented by tuples of start and end times, returns 'Conflict' if any meetings overlap, otherwise 'No Conflict'. Also ensures the total number of hours of meetings is as balanced as possible between the first and second half of the day. # Helper function to convert time to minutes since 00:00 def time_to_minutes(time_str): hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes # Convert meeting times to minutes meetings_in_minutes = [(time_to_minutes(start), time_to_minutes(end)) for start, end in meetings] # Sort meetings by start time meetings_in_minutes.sort() # Check for conflicts for i in range(len(meetings_in_minutes) - 1): if meetings_in_minutes[i][1] > meetings_in_minutes[i + 1][0]: return \\"Conflict\\" # Check for balanced schedule first_half_limit = time_to_minutes(\\"12:00\\") first_half_duration = sum(min(end, first_half_limit) - start for start, end in meetings_in_minutes if start < first_half_limit) second_half_duration = sum(end - max(start, first_half_limit) for start, end in meetings_in_minutes if end > first_half_limit) if abs(first_half_duration - second_half_duration) <= 60: return \\"No Conflict\\" else: return \\"Unbalanced\\" # Example usage: meetings = [(\\"09:00\\", \\"10:30\\"), (\\"12:00\\", \\"13:30\\"), (\\"11:00\\", \\"12:30\\"), (\\"14:00\\", \\"15:30\\")] print(create_schedule(meetings)) # Output: Conflict"},{"question":"class StockTradingPlatform: def __init__(self, initial_balance): Initialize the stock trading platform with an initial balance. Args: initial_balance (float): The initial balance for the platform. def add_to_portfolio(self, stock, quantity, price): Add stocks to the portfolio. Args: stock (str): The stock ticker. quantity (int): The number of shares to add. price (float): The buying price per share. def execute_trade(self, stock, quantity, price, buy=True): Execute a trade (buy or sell) for a given stock. Args: stock (str): The stock ticker. quantity (int): The number of shares to trade. price (float): The trade price per share. buy (bool): True if buying, False if selling. def update_market_data(self): Update the market data (simulate real-time price updates). def optimize_investment(self): Optimize the investment strategy to maximize profits. def get_portfolio_value(self): Calculate the total value of the portfolio including the balance. Returns: float: The total portfolio value. import pytest def test_add_to_portfolio(): platform = StockTradingPlatform(10000) platform.add_to_portfolio(\\"AAPL\\", 10, 120) assert \\"AAPL\\" in platform.portfolio assert platform.portfolio[\\"AAPL\\"][\\"quantity\\"] == 10 assert platform.balance == 8800 def test_execute_trade_buy(): platform = StockTradingPlatform(10000) platform.execute_trade(\\"AAPL\\", 10, 120, buy=True) assert platform.portfolio[\\"AAPL\\"][\\"quantity\\"] == 10 assert platform.balance == 8800 def test_execute_trade_sell(): platform = StockTradingPlatform(10000) platform.add_to_portfolio(\\"AAPL\\", 10, 120) platform.execute_trade(\\"AAPL\\", 5, 130, buy=False) assert platform.portfolio[\\"AAPL\\"][\\"quantity\\"] == 5 assert platform.balance == 9450 def test_update_market_data(): platform = StockTradingPlatform(10000) platform.add_to_portfolio(\\"AAPL\\", 10, 120) platform.update_market_data() assert \\"current_price\\" in platform.portfolio[\\"AAPL\\"] def test_optimize_investment(): platform = StockTradingPlatform(10000) platform.add_to_portfolio(\\"AAPL\\", 10, 120) platform.portfolio[\\"AAPL\\"][\\"current_price\\"] = 140 # Manually setting the price platform.optimize_investment() assert platform.portfolio[\\"AAPL\\"][\\"quantity\\"] == 0 def test_get_portfolio_value(): platform = StockTradingPlatform(10000) platform.add_to_portfolio(\\"AAPL\\", 10, 120) platform.portfolio[\\"AAPL\\"][\\"current_price\\"] = 130 # Manually setting the price portfolio_value = platform.get_portfolio_value() assert portfolio_value == 10000 - 1200 + 1300 # initial balance - cost of stocks + current value of stocks","solution":"import random class StockTradingPlatform: def __init__(self, initial_balance): self.balance = initial_balance self.portfolio = {} def add_to_portfolio(self, stock, quantity, price): if stock in self.portfolio: self.portfolio[stock]['quantity'] += quantity else: self.portfolio[stock] = {'quantity': quantity, 'avg_price': price} self.balance -= quantity * price def execute_trade(self, stock, quantity, price, buy=True): if buy: self.add_to_portfolio(stock, quantity, price) else: if stock in self.portfolio and self.portfolio[stock]['quantity'] >= quantity: self.portfolio[stock]['quantity'] -= quantity self.balance += quantity * price def update_market_data(self): for stock in self.portfolio: new_price = random.uniform(50, 150) # Simulating real time price data self.portfolio[stock]['current_price'] = new_price def optimize_investment(self): for stock, data in self.portfolio.items(): if data['current_price'] > data['avg_price'] * 1.1: # Sell if price increased by 10% self.execute_trade(stock, data['quantity'], data['current_price'], buy=False) def get_portfolio_value(self): total_value = self.balance for stock, data in self.portfolio.items(): total_value += data['quantity'] * data['current_price'] return total_value # Example usage: # platform = StockTradingPlatform(10000) # platform.execute_trade(\\"AAPL\\", 10, 120, buy=True) # platform.update_market_data() # platform.optimize_investment() # value = platform.get_portfolio_value()"},{"question":"def reverse_and_length(words: List[str]) -> List[Tuple[str, int]]: Reverse the characters in each string from the given list and return a list of tuples containing the reversed string and its length. >>> reverse_and_length([\\"hello\\", \\"world\\", \\"python\\"]) [('olleh', 5), ('dlrow', 5), ('nohtyp', 6)] >>> reverse_and_length([]) [] >>> reverse_and_length([\\"single\\"]) [('elgnis', 6)] >>> reverse_and_length([\\"a\\", \\"ab\\", \\"abc\\"]) [('a', 1), ('ba', 2), ('cba', 3)] >>> reverse_and_length([\\" \\", \\"word \\", \\" spaced out \\"]) [(' ', 1), (' drow', 5), (' tuo decaps ', 13)]","solution":"def reverse_and_length(words): Reverse the characters in each string from the given list and return a list of tuples containing the reversed string and its length. :param words: List of strings :return: List of tuples (reversed_string, length) return [(word[::-1], len(word)) for word in words]"},{"question":"from typing import List def is_prime(num: int) -> bool: Checks if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(11) == True >>> is_prime(15) == False >>> is_prime(1) == False >>> is_prime(0) == False pass def squares_of_primes(numbers: List[int]) -> List[int]: Returns a list of squares of prime numbers from the input list. >>> squares_of_primes([4, 6, 8, 10]) == [] >>> squares_of_primes([4, 6, 7, 10, 11]) == [49, 121] >>> squares_of_primes([2, 3, 5, 7, 11]) == [4, 9, 25, 49, 121] >>> squares_of_primes([]) == [] >>> squares_of_primes([101, 103, 107, 109]) == [10201, 10609, 11449, 11881] pass","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def squares_of_primes(numbers): Returns a list of squares of prime numbers from the input list. return [num ** 2 for num in numbers if is_prime(num)]"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Identifies all elements that appear more than once in a list of integers. The returned list is sorted in ascending order and contains each duplicate element only once. >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([-1, -2, -3, -1, -2]) [-2, -1] >>> find_duplicates([1000000, 1000001, 1000000, 1000002]) [1000000]","solution":"def find_duplicates(nums): Identifies all elements that appear more than once in a list of integers. The returned list is sorted in ascending order and contains each duplicate element only once. duplicates = set() seen = set() for num in nums: if num in seen: duplicates.add(num) else: seen.add(num) return sorted(duplicates)"},{"question":"def sum_excluding_self(nums: List[int]) -> List[int]: Given a list of integers, returns a list where each element is the sum of all other elements excluding the one at the corresponding index. Args: nums (list): A list of integers. Returns: list: A new list where each element is the sum of all other elements. Examples: >>> sum_excluding_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_excluding_self([5, 10, 15]) [25, 20, 15] >>> sum_excluding_self([0, 0, 0]) [0, 0, 0] >>> sum_excluding_self([-1, -2, -3]) [-5, -4, -3] >>> sum_excluding_self([42]) [0] >>> sum_excluding_self([]) [] >>> sum_excluding_self([0, 0, 0, 0]) [0, 0, 0, 0] pass","solution":"def sum_excluding_self(nums): Given a list of integers, returns a list where each element is the sum of all other elements excluding the one at the corresponding index. Args: nums (list): A list of integers. Returns: list: A new list where each element is the sum of all other elements. total_sum = sum(nums) return [total_sum - num for num in nums]"},{"question":"def move_target_to_end(lst, target): Moves all occurrences of the \`target\` integer to the end of the list while maintaining the relative order of the other elements, modifying the list in place. Parameters: lst (list of int): The list of integers. target (int): The target integer to move to the end. Returns: None # Example usage: lst = [3, 1, 2, 3, 4, 3, 5] move_target_to_end(lst, 3) print(lst) # Output should be: [1, 2, 4, 5, 3, 3, 3] def test_move_target_to_end_all_targets(): lst = [3, 3, 3, 3] move_target_to_end(lst, 3) assert lst == [3, 3, 3, 3] def test_move_target_to_end_no_targets(): lst = [1, 2, 4, 5] move_target_to_end(lst, 3) assert lst == [1, 2, 4, 5] def test_move_target_to_end_mixed(): lst = [3, 1, 2, 3, 4, 3, 5] move_target_to_end(lst, 3) assert lst == [1, 2, 4, 5, 3, 3, 3] def test_move_target_to_end_repeated_elements(): lst = [3, 3, 1, 3, 3, 2, 3, 3, 4, 5, 3] move_target_to_end(lst, 3) assert lst == [1, 2, 4, 5, 3, 3, 3, 3, 3, 3, 3] def test_move_target_to_end_with_zero(): lst = [0, 1, 0, 2, 0, 3, 0, 4] move_target_to_end(lst, 0) assert lst == [1, 2, 3, 4, 0, 0, 0, 0]","solution":"def move_target_to_end(lst, target): Moves all occurrences of the \`target\` integer to the end of the list while maintaining the relative order of the other elements, modifying the list in place. Parameters: lst (list of int): The list of integers. target (int): The target integer to move to the end. Returns: None n = len(lst) last_non_target_index = 0 # Iterate through the list and move non-target elements to the front for i in range(n): if lst[i] != target: lst[last_non_target_index] = lst[i] last_non_target_index += 1 # Fill the rest of the list with the target value for i in range(last_non_target_index, n): lst[i] = target"},{"question":"def knapsack(weights, values, W): Solves the knapsack problem using dynamic programming. Args: weights: List of weights for each item. values: List of values for each item. W: Maximum capacity of the knapsack. Returns: tuple of the maximum value obtainable and list of indexes of items included in the knapsack. # Initialize variables and the dp table # Fill the dp table using dynamic programming approach # Determine the items included in the knapsack by backtracking through the dp table return # Return the maximum value and the list of included items # Example usage values = [60, 100, 120] weights = [10, 20, 30] W = 50 max_value, items_included = knapsack(weights, values, W) print(f\\"Maximum value: {max_value}, Items included: {items_included}\\")","solution":"def knapsack(weights, values, W): Solves the knapsack problem using dynamic programming. Args: weights: List of weights for each item. values: List of values for each item. W: Maximum capacity of the knapsack. Returns: tuple of the maximum value obtainable and list of indexes of items included in the knapsack. n = len(weights) # dp table where dp[i][w] represents the max value we can achieve with the first i items and capacity w dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] # To find the items included in the knapsack w = W included_items = [] for i in range(n, 0, -1): if dp[i][w] != dp[i-1][w]: included_items.append(i-1) w -= weights[i-1] included_items.reverse() return dp[n][W], included_items"},{"question":"def filter_and_sort_emails(emails: list[str], domain: str = None) -> list[str]: Removes duplicates from the list of email addresses, sorts the resulting list alphabetically, and filters the emails based on the specified domain if provided. Args: emails (list of str): A list of email addresses. domain (str, optional): The domain to filter email addresses. Defaults to None. Returns: list of str: A list of unique, sorted email addresses, possibly filtered by domain. >>> filter_and_sort_emails([\\"alice@yahoo.com\\", \\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"charlie@gmail.com\\", \\"david@example.com\\"], \\"gmail.com\\") ['bob@gmail.com', 'charlie@gmail.com'] >>> filter_and_sort_emails([\\"alice@yahoo.com\\", \\"bob@gmail.com\\", \\"alice@yahoo.com\\", \\"charlie@gmail.com\\", \\"david@example.com\\"]) ['alice@yahoo.com', 'bob@gmail.com', 'charlie@gmail.com', 'david@example.com']","solution":"def filter_and_sort_emails(emails, domain=None): Removes duplicates from the list of email addresses, sorts the resulting list alphabetically, and filters the emails based on the specified domain if provided. Args: emails (list of str): A list of email addresses. domain (str, optional): The domain to filter email addresses. Defaults to None. Returns: list of str: A list of unique, sorted email addresses, possibly filtered by domain. unique_emails = set(emails) if domain: filtered_emails = [email for email in unique_emails if email.endswith(f\\"@{domain}\\")] else: filtered_emails = list(unique_emails) return sorted(filtered_emails)"},{"question":"def simplify_expression(): Simplifies the algebraic expression 4x^2 - 12x + 9 - (2x - 3)^2 and factors the resulting polynomial completely. >>> simplify_expression() 0 from sympy import symbols, simplify, factor # Define the variable x = symbols('x') # Define the expression expression = 4*x**2 - 12*x + 9 - (2*x - 3)**2 # Simplify the expression simplified_expr = simplify(expression) # Factor the simplified expression factored_expr = factor(simplified_expr) # Return the factorized form return factored_expr","solution":"def simplify_expression(): Simplifies the algebraic expression 4x^2 - 12x + 9 - (2x - 3)^2 and factors the resulting polynomial completely. from sympy import symbols, simplify, factor # Define the variable x = symbols('x') # Define the expression expression = 4*x**2 - 12*x + 9 - (2*x - 3)**2 # Simplify the expression simplified_expr = simplify(expression) # Factor the simplified expression factored_expr = factor(simplified_expr) # Return the factorized form return factored_expr"},{"question":"from typing import List def min_jumps(arr: List[int]) -> int: Return the minimum number of jumps needed to reach the last element of the array starting from the first element. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 1, 1, 1, 1]) 4 >>> min_jumps([1, 0, 1, 1, 1]) -1 >>> min_jumps([10, 1, 1, 1, 1]) 1 >>> min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) 3 >>> min_jumps([1, 1]) 1","solution":"from typing import List def min_jumps(arr: List[int]) -> int: if len(arr) == 1: return 0 max_reach = arr[0] step = arr[0] jumps = 1 for i in range(1, len(arr)): if i == len(arr) - 1: return jumps max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jumps += 1 step = max_reach - i if step <= 0: return -1 return -1"},{"question":"def most_common_substring(s: str, k: int) -> str: Returns the most common substring of length k found in the string s. If there are multiple substrings with the same highest frequency, return the lexicographically smallest one. >>> most_common_substring(\\"ababcbabab\\", 3) == \\"bab\\" >>> most_common_substring(\\"abcabcabc\\", 3) == \\"abc\\" >>> most_common_substring(\\"zzzyyxxbbbaaazzzyy\\", 2) == \\"zz\\" >>> most_common_substring(\\"aabbcc\\", 2) == \\"aa\\" >>> most_common_substring(\\"abcdefgh\\", 2) == \\"ab\\" >>> most_common_substring(\\"a\\" * 1000, 1) == \\"a\\" >>> most_common_substring(\\"aaaaaa\\", 6) == \\"aaaaaa\\"","solution":"def most_common_substring(s, k): Returns the most common substring of length k found in the string s. If there are multiple substrings with the same highest frequency, return the lexicographically smallest one. from collections import defaultdict # Dictionary to hold substring counts substring_count = defaultdict(int) # Populate the dictionary with substring frequencies for i in range(len(s) - k + 1): substring = s[i:i+k] substring_count[substring] += 1 # Find the most common substrings max_count = max(substring_count.values()) most_common_substrings = [key for key, value in substring_count.items() if value == max_count] # Return the lexicographically smallest substring return min(most_common_substrings)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, this function returns a list where each integer is replaced by the product of all the integers in the original list except the integer at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([1, 0, 3, 0, 5]) [0, 0, 0, 0, 0]","solution":"def product_except_self(nums): Given a list of integers, this function returns a list where each integer is replaced by the product of all the integers in the original list except the integer at that position. length = len(nums) if length == 0: return [] result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"class Bank: A simple banking system The program supports the following operations: - Creating an account with an initial balance. - Depositing a specified amount into a specified account. - Withdrawing a specified amount from a specified account, with a check to ensure that the account does not go into the negative. - Checking the balance of a given account. def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, initial_balance=0): Creates an account with an initial balance. >>> bank = Bank() >>> account_number = bank.create_account(100) >>> account_number == 1 True >>> bank.check_balance(account_number) == 100 True pass def deposit(self, account_number, amount): Deposits a specified amount into a specified account. >>> bank = Bank() >>> account_number = bank.create_account(100) >>> new_balance = bank.deposit(account_number, 50) >>> new_balance == 150 True >>> bank.check_balance(account_number) == 150 True >>> import pytest >>> with pytest.raises(ValueError): ... bank.deposit(account_number, -20) pass def withdraw(self, account_number, amount): Withdraws a specified amount from a specified account. >>> bank = Bank() >>> account_number = bank.create_account(100) >>> new_balance = bank.withdraw(account_number, 50) >>> new_balance == 50 True >>> bank.check_balance(account_number) == 50 True >>> import pytest >>> with pytest.raises(ValueError): ... bank.withdraw(account_number, 100) >>> with pytest.raises(ValueError): ... bank.withdraw(account_number, -10) pass def check_balance(self, account_number): Checks the balance of a given account. >>> bank = Bank() >>> account_number = bank.create_account(200) >>> bank.check_balance(account_number) == 200 True >>> import pytest >>> with pytest.raises(ValueError): ... bank.check_balance(999) pass # Example unit tests def test_create_account(): bank = Bank() account_number = bank.create_account(100) assert account_number == 1 assert bank.check_balance(account_number) == 100 def test_deposit(): bank = Bank() account_number = bank.create_account(100) new_balance = bank.deposit(account_number, 50) assert new_balance == 150 assert bank.check_balance(account_number) == 150 with pytest.raises(ValueError): bank.deposit(account_number, -20) def test_withdraw(): bank = Bank() account_number = bank.create_account(100) new_balance = bank.withdraw(account_number, 50) assert new_balance == 50 assert bank.check_balance(account_number) == 50 with pytest.raises(ValueError): bank.withdraw(account_number, 100) with pytest.raises(ValueError): bank.withdraw(account_number, -10) def test_check_balance(): bank = Bank() account_number = bank.create_account(200) assert bank.check_balance(account_number) == 200 with pytest.raises(ValueError): bank.check_balance(999) def test_non_existent_account(): bank = Bank() with pytest.raises(ValueError): bank.deposit(1, 50) with pytest.raises(ValueError): bank.withdraw(1, 50) with pytest.raises(ValueError): bank.check_balance(1)","solution":"class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, initial_balance=0): account_number = self.next_account_number self.accounts[account_number] = initial_balance self.next_account_number += 1 return account_number def deposit(self, account_number, amount): if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.accounts[account_number] += amount return self.accounts[account_number] def withdraw(self, account_number, amount): if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.accounts[account_number] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_number] -= amount return self.accounts[account_number] def check_balance(self, account_number): if account_number not in self.accounts: raise ValueError(\\"Account does not exist.\\") return self.accounts[account_number]"},{"question":"def nth_highest_score(scores: list, n: int) -> int: Returns the nth highest unique score from the list of scores. Parameters: scores (list): List of integer scores. n (int): The rank of the highest score to return. Returns: int: The nth highest unique score or None if it doesn't exist. Examples: >>> nth_highest_score([62, 85, 75, 85, 92, 75, 68, 92], 2) 85 >>> nth_highest_score([62, 85, 75, 85, 92, 75, 68, 92], 4) 68 >>> nth_highest_score([50, 20, 30, 80, 90], 5) 50 >>> nth_highest_score([50, 20, 30, 80, 90], 10) None","solution":"def nth_highest_score(scores, n): Returns the nth highest unique score from the list of scores. Parameters: scores (list): List of integer scores. n (int): The rank of the highest score to return. Returns: int: The nth highest unique score or None if it doesn't exist. if n < 1: return None unique_scores = sorted(set(scores), reverse=True) if n > len(unique_scores): return None return unique_scores[n - 1]"},{"question":"def find_substring_indices(text: str, pattern: str) -> List[int]: Returns a list of starting indices where the substring pattern is found within the string text. >>> find_substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substring_indices(\\"hello world, hello universe\\", \\"hello\\") [0, 13] >>> find_substring_indices(\\"abracadabra\\", \\"x\\") [] >>> find_substring_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_substring_indices(\\"hello\\", \\"hello world\\") [] >>> find_substring_indices(\\"hello\\", \\"hello\\") [0] >>> find_substring_indices(\\"hello\\", \\"\\") [] >>> find_substring_indices(\\"\\", \\"hello\\") []","solution":"def find_substring_indices(text, pattern): Returns a list of starting indices where the substring pattern is found within the string text. if not pattern or not text: return [] pattern_length = len(pattern) text_length = len(text) result = [] for i in range(text_length - pattern_length + 1): if text[i:i + pattern_length] == pattern: result.append(i) return result"},{"question":"class AdventureGame: def __init__(self): Initialize the game with the starting location and inventory. pass def describe_location(self): Describe the current location to the player. pass def move(self, direction): Move the player in the specified direction. pass def pick_up_item(self, item): Add the item to the player's inventory. pass def show_inventory(self): Show the items currently in the player's inventory. pass def check_win_condition(self): Check if the player has met the win condition. pass def handle_command(game, command): Process the player's command and take appropriate action. pass def main(): Run the main game loop. pass if __name__ == \\"__main__\\": main() def test_initial_location(): game = AdventureGame() assert game.describe_location() == \\"You are in a dark forest. Paths lead north and east.\\" def test_movement(): game = AdventureGame() assert game.move('north') assert game.current_location == 'cave' assert game.move('south') assert game.current_location == 'forest' assert not game.move('west') def test_pick_up_item(): game = AdventureGame() game.move('north') assert game.pick_up_item('torch') assert 'torch' in game.show_inventory() assert not game.pick_up_item('boat') def test_show_inventory(): game = AdventureGame() game.inventory = ['torch', 'boat'] assert game.show_inventory() == ['torch', 'boat'] def test_check_win_condition(): game = AdventureGame() game.inventory = ['torch', 'boat'] assert game.check_win_condition() def test_handle_command_go(): game = AdventureGame() assert handle_command(game, \\"go north\\") == \\"You are in a damp cave. There is a torch on the wall. Paths lead south.\\" assert handle_command(game, \\"go west\\") == \\"You can't go that way.\\" def test_handle_command_take(): game = AdventureGame() game.move('north') assert handle_command(game, \\"take torch\\") == \\"You picked up torch.\\" assert handle_command(game, \\"take torch\\") == \\"There is no such item here.\\" def test_handle_command_inventory(): game = AdventureGame() game.inventory = ['torch'] assert handle_command(game, \\"inventory\\") == \\"Your inventory: torch\\" def test_handle_command_help(): game = AdventureGame() help_text = (\\"Instructions:n\\" \\"- Use 'go [direction]' to move (e.g., 'go north').n\\" \\"- Use 'take [item]' to pick up an item (e.g., 'take torch').n\\" \\"- Use 'inventory' to check your items.n\\" \\"- Goal: Collect the torch and the boat to win the game.\\") assert handle_command(game, \\"help\\") == help_text def test_invalid_command(): game = AdventureGame() assert handle_command(game, \\"jump\\") == \\"Invalid command. Type 'help' for instructions.\\" assert handle_command(game, \\"\\") == \\"Invalid command. Try again!\\"","solution":"class AdventureGame: def __init__(self): self.inventory = [] self.current_location = 'forest' self.locations = { 'forest': { 'description': \\"You are in a dark forest. Paths lead north and east.\\", 'north': 'cave', 'east': 'river' }, 'cave': { 'description': \\"You are in a damp cave. There is a torch on the wall. Paths lead south.\\", 'items': ['torch'], 'south': 'forest' }, 'river': { 'description': \\"You are by a rushing river. There is a boat here. Paths lead west.\\", 'items': ['boat'], 'west': 'forest' } } def describe_location(self): return self.locations[self.current_location]['description'] def move(self, direction): if direction in self.locations[self.current_location]: self.current_location = self.locations[self.current_location][direction] return True else: return False def pick_up_item(self, item): if 'items' in self.locations[self.current_location] and item in self.locations[self.current_location]['items']: self.inventory.append(item) self.locations[self.current_location]['items'].remove(item) return True else: return False def show_inventory(self): return self.inventory def check_win_condition(self): return 'torch' in self.inventory and 'boat' in self.inventory def handle_command(game, command): command = command.lower().split() if not command: return \\"Invalid command. Try again!\\" if command[0] == 'go': if len(command) != 2: return \\"Invalid command. Try 'go north', 'go south', 'go east' or 'go west'.\\" if game.move(command[1]): return game.describe_location() else: return \\"You can't go that way.\\" elif command[0] == 'take': if len(command) != 2: return \\"Invalid command. Try 'take torch', 'take boat'.\\" if game.pick_up_item(command[1]): return f\\"You picked up {command[1]}.\\" else: return \\"There is no such item here.\\" elif command[0] == 'inventory': return \\"Your inventory: \\" + ', '.join(game.show_inventory()) elif command[0] == 'help': return (\\"Instructions:n\\" \\"- Use 'go [direction]' to move (e.g., 'go north').n\\" \\"- Use 'take [item]' to pick up an item (e.g., 'take torch').n\\" \\"- Use 'inventory' to check your items.n\\" \\"- Goal: Collect the torch and the boat to win the game.\\") else: return \\"Invalid command. Type 'help' for instructions.\\" def main(): game = AdventureGame() print(\\"Welcome to the Adventure Game!\\") print(game.describe_location()) while True: command = input(\\"> \\") message = handle_command(game, command) print(message) if game.check_win_condition(): print(\\"Congratulations! You have collected all the items and won the game!\\") break if __name__ == \\"__main__\\": main()"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> str: Find the longest common subsequence of two strings. The subsequence does not need to be contiguous but should maintain the order of characters from the input strings. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") \\"\\" >>> longest_common_subsequence(\\"abcdef\\", \\"abcdef\\") \\"abcdef\\" >>> longest_common_subsequence(\\"ABAZDC\\", \\"BACBAD\\") \\"ABAD\\" >>> longest_common_subsequence(\\"\\", \\"abcdef\\") \\"\\" >>> longest_common_subsequence(\\"abcdef\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"a\\", \\"a\\") \\"a\\" >>> longest_common_subsequence(\\"a\\", \\"b\\") \\"\\" >>> longest_common_subsequence(\\"aA\\", \\"Aa\\") \\"a\\"","solution":"def longest_common_subsequence(str1, str2): Returns the longest common subsequence (LCS) of str1 and str2. n = len(str1) m = len(str2) # Create a 2D array to store the lengths of LCS dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct LCS from dp array lcs = [] i, j = n, m while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] >= dp[i][j - 1]: i -= 1 else: j -= 1 return ''.join(reversed(lcs))"},{"question":"from typing import List, Dict, Union def analyze_employee_records(employee_records: List[Dict[str, Union[str, int]]]) -> Dict[str, Dict[str, Union[float, int, List[str]]]]: Analyzes a list of employee records to provide department statistics. Parameters: - employee_records: List[Dict[str, Union[str, int]]] : A list of dictionaries containing employee details. Returns: - A dictionary with departments as keys, and for each department: - The average age of employees (or None if no employees) - The total salary of all employees - A list of names of employees with above-average salaries in that department pass # Unit Tests def test_single_department(): employee_records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 1000}, {\\"name\\": \\"Bob\\", \\"age\\": 40, \\"department\\": \\"Engineering\\", \\"salary\\": 1500} ] result = analyze_employee_records(employee_records) expected = { \\"Engineering\\": { \\"average_age\\": 35, \\"total_salary\\": 2500, \\"above_average_salary_employees\\": [\\"Bob\\"] } } assert result == expected def test_multiple_departments(): employee_records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 1000}, {\\"name\\": \\"Bob\\", \\"age\\": 40, \\"department\\": \\"Engineering\\", \\"salary\\": 1500}, {\\"name\\": \\"Charlie\\", \\"age\\": 28, \\"department\\": \\"HR\\", \\"salary\\": 1200}, {\\"name\\": \\"David\\", \\"age\\": 35, \\"department\\": \\"HR\\", \\"salary\\": 1100}, {\\"name\\": \\"Eve\\", \\"age\\": 29, \\"department\\": \\"Engineering\\", \\"salary\\": 1300} ] result = analyze_employee_records(employee_records) expected = { \\"Engineering\\": { \\"average_age\\": 33, \\"total_salary\\": 3800, \\"above_average_salary_employees\\": [\\"Bob\\", \\"Eve\\"] }, \\"HR\\": { \\"average_age\\": 31.5, \\"total_salary\\": 2300, \\"above_average_salary_employees\\": [\\"Charlie\\"] } } assert result == expected def test_no_employees_in_department(): employee_records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 1000}, {\\"name\\": \\"Bob\\", \\"age\\": 40, \\"department\\": \\"Engineering\\", \\"salary\\": 1500}, {\\"name\\": \\"Charlie\\", \\"age\\": 28, \\"department\\": \\"HR\\", \\"salary\\": 1200}, {\\"name\\": \\"David\\", \\"age\\": 35, \\"department\\": \\"HR\\", \\"salary\\": 1100} ] result = analyze_employee_records(employee_records) expected = { \\"Engineering\\": { \\"average_age\\": 35, \\"total_salary\\": 2500, \\"above_average_salary_employees\\": [\\"Bob\\"] }, \\"HR\\": { \\"average_age\\": 31.5, \\"total_salary\\": 2300, \\"above_average_salary_employees\\": [\\"Charlie\\"] } } assert result == expected def test_empty_employee_records(): employee_records = [] result = analyze_employee_records(employee_records) expected = {} assert result == expected def test_single_employee(): employee_records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 1000} ] result = analyze_employee_records(employee_records) expected = { \\"Engineering\\": { \\"average_age\\": 30, \\"total_salary\\": 1000, \\"above_average_salary_employees\\": [] } } assert result == expected","solution":"from typing import List, Dict, Union def analyze_employee_records(employee_records: List[Dict[str, Union[str, int]]]): Analyzes a list of employee records to provide department statistics. Parameters: - employee_records: List[Dict[str, Union[str, int]]] : A list of dictionaries containing employee details. Returns: - A dictionary with departments as keys, and for each department: - The average age of employees (or None if no employees) - The total salary of all employees - A list of names of employees with above-average salaries in that department department_stats = {} department_employees = {} for record in employee_records: department = record['department'] if department not in department_employees: department_employees[department] = [] department_employees[department].append(record) for department, employees in department_employees.items(): total_age = sum(employee['age'] for employee in employees) total_salary = sum(employee['salary'] for employee in employees) average_age = total_age / len(employees) if employees else None average_salary = total_salary / len(employees) if employees else 0 above_average_salary_employees = [ employee['name'] for employee in employees if employee['salary'] > average_salary ] department_stats[department] = { \\"average_age\\": average_age if employees else None, \\"total_salary\\": total_salary, \\"above_average_salary_employees\\": above_average_salary_employees } return department_stats"},{"question":"class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.is_borrowed = False class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.borrowed_books = [] class Library: def __init__(self): self.books = [] self.members = {} def add_book(self, book): Add a new book to the library collection. pass def remove_book(self, isbn): Remove a book from the library collection if it is not borrowed. pass def register_member(self, member): Register a new member to the library. pass def borrow_book(self, member_id, isbn): Allow a member to borrow a book if it is available, with a maximum limit of 5 books. pass def return_book(self, member_id, isbn): Allow a member to return a borrowed book. pass # Unit tests import pytest from solution import Library, Member, Book def test_library_add_book(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) assert len(library.books) == 1 assert library.books[0].title == \\"Test Book\\" def test_library_remove_book_not_borrowed(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) assert library.remove_book(\\"123\\") assert len(library.books) == 0 def test_library_remove_book_borrowed(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) library.borrow_book(\\"1\\", \\"123\\") assert not library.remove_book(\\"123\\") assert len(library.books) == 1 def test_library_register_member(): library = Library() member = Member(\\"1\\", \\"John\\") library.register_member(member) assert len(library.members) == 1 assert library.members[\\"1\\"].name == \\"John\\" def test_library_borrow_book(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) assert library.borrow_book(\\"1\\", \\"123\\") assert book.is_borrowed assert len(member.borrowed_books) == 1 assert member.borrowed_books[0].isbn == \\"123\\" def test_library_borrow_book_not_available(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") book.is_borrowed = True library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) assert not library.borrow_book(\\"1\\", \\"123\\") assert len(member.borrowed_books) == 0 def test_library_borrow_book_exceeds_limit(): library = Library() for i in range(5): book = Book(f\\"Book {i}\\", \\"Author\\", str(i)) library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) for i in range(5): library.borrow_book(\\"1\\", str(i)) sixth_book = Book(\\"Book 5\\", \\"Author\\", \\"5\\") library.add_book(sixth_book) assert not library.borrow_book(\\"1\\", \\"5\\") assert len(member.borrowed_books) == 5 def test_library_return_book(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) library.borrow_book(\\"1\\", \\"123\\") assert library.return_book(\\"1\\", \\"123\\") assert not book.is_borrowed assert len(member.borrowed_books) == 0 def test_library_return_book_not_borrowed(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_book(book) member = Member(\\"1\\", \\"John\\") library.register_member(member) assert not library.return_book(\\"1\\", \\"123\\") def test_library_return_book_different_member(): library = Library() book = Book(\\"Test Book\\", \\"Author\\", \\"123\\") library.add_add(book) member1 = Member(\\"1\\", \\"John\\") member2 = Member(\\"2\\", \\"Jane\\") library.register_member(member1) library.register_member(member2) library.borrow_book(\\"1\\", \\"123\\") assert not library.return_book(\\"2\\", \\"123\\")","solution":"class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.is_borrowed = False class Member: def __init__(self, member_id, name): self.member_id = member_id self.name = name self.borrowed_books = [] class Library: def __init__(self): self.books = [] self.members = {} def add_book(self, book): self.books.append(book) def remove_book(self, isbn): for book in self.books: if book.isbn == isbn and not book.is_borrowed: self.books.remove(book) return True return False def register_member(self, member): self.members[member.member_id] = member def borrow_book(self, member_id, isbn): member = self.members.get(member_id) if member and len(member.borrowed_books) < 5: for book in self.books: if book.isbn == isbn and not book.is_borrowed: book.is_borrowed = True member.borrowed_books.append(book) return True return False def return_book(self, member_id, isbn): member = self.members.get(member_id) if member: for book in member.borrowed_books: if book.isbn == isbn: book.is_borrowed = False member.borrowed_books.remove(book) return True return False"},{"question":"def combine_dicts(dict1, dict2): Combines two dictionaries by summing values of keys that appear in both dictionaries. If a key exists in only one of the dictionaries, its value is included as is in the resulting dictionary. Parameters: dict1 (dict): First dictionary with integer values. dict2 (dict): Second dictionary with integer values. Returns: dict: A new dictionary with combined keys and summed values where applicable. from solution import combine_dicts def test_combine_dicts_regular_case(): assert combine_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) == {'a': 1, 'b': 5, 'c': 4} def test_combine_dicts_empty_dicts(): assert combine_dicts({}, {}) == {} assert combine_dicts({}, {'a': 1}) == {'a': 1} assert combine_dicts({'a': 1}, {}) == {'a': 1} def test_combine_dicts_no_overlapping_keys(): assert combine_dicts({'a': 1}, {'b': 2}) == {'a': 1, 'b': 2} def test_combine_dicts_all_overlapping_keys(): assert combine_dicts({'a': 1, 'b': 2}, {'a': 3, 'b': 4}) == {'a': 4, 'b': 6} def test_combine_dicts_large_input(): dict1 = {'key' + str(i): i for i in range(1000)} dict2 = {'key' + str(i): i * 2 for i in range(500, 1500)} expected = {'key' + str(i): i for i in range(500)} expected.update({'key' + str(i): i + i * 2 for i in range(500, 1000)}) expected.update({'key' + str(i): i * 2 for i in range(1000, 1500)}) assert combine_dicts(dict1, dict2) == expected","solution":"def combine_dicts(dict1, dict2): Combines two dictionaries by summing values of keys that appear in both dictionaries. If a key exists in only one of the dictionaries, its value is included as is in the resulting dictionary. Parameters: dict1 (dict): First dictionary with integer values. dict2 (dict): Second dictionary with integer values. Returns: dict: A new dictionary with combined keys and summed values where applicable. result = {} for key in dict1: if key in dict2: result[key] = dict1[key] + dict2[key] else: result[key] = dict1[key] for key in dict2: if key not in result: result[key] = dict2[key] return result"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in a given string and return it. If multiple substrings of the same maximum length exist, return the one that appears first. Constraints: 1 <= len(s) <= 10^4 >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") 'a' from solution import longest_palindromic_substring def test_example_case_1(): assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" def test_example_case_2(): assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" def test_single_character(): assert longest_palindromic_substring(\\"a\\") == \\"a\\" def test_no_palindrome(): assert longest_palindromic_substring(\\"ac\\") == \\"a\\" def test_palindromic_input(): assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" def test_longest_palindrome_at_end(): assert longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\" def test_all_characters_same(): assert longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\"","solution":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in a given string and return it. If multiple substrings of the same maximum length exist, return the one that appears first. Constraints: 1 <= len(s) <= 10^4 if not s or len(s) == 1: return s start, max_length = 0, 1 for i in range(1, len(s)): # Even length palindromes, center at i-1 and i low, high = i - 1, i while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Odd length palindromes, center at i low, high = i - 1, i + 1 while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> int: Returns the length of the longest substring that contains no more than two distinct characters. >>> longest_substring_with_two_distinct_chars(\\"aaaa\\") 4 >>> longest_substring_with_two_distinct_chars(\\"aabb\\") 4 >>> longest_substring_with_two_distinct_chars(\\"\\") 0 >>> longest_substring_with_two_distinct_chars(\\"ccaabbb\\") 5 >>> longest_substring_with_two_distinct_chars(\\"abcabcabc\\") 2 >>> longest_substring_with_two_distinct_chars(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_chars(\\"abaccc\\") 4 >>> longest_substring_with_two_distinct_chars(\\"xyzxyzxyx\\") 3","solution":"def longest_substring_with_two_distinct_chars(s): Returns the length of the longest substring that contains no more than two distinct characters. if len(s) == 0: return 0 left = 0 char_map = {} max_len = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def calculate_total_spending(transactions: List[Dict[str, Any]]) -> Dict[int, float]: Given a list of transactions, calculate the total spending per user. :param transactions: List of dictionaries, each containing 'user_id', 'item', and 'amount'. :return: Dictionary with user_id as keys and total spending as values. >>> transactions = [ ... {\\"user_id\\": 1, \\"item\\": \\"pen\\", \\"amount\\": 2.5}, ... {\\"user_id\\": 2, \\"item\\": \\"notebook\\", \\"amount\\": 5.0}, ... {\\"user_id\\": 1, \\"item\\": \\"pencil\\", \\"amount\\": 1.0}, ... {\\"user_id\\": 3, \\"item\\": \\"eraser\\", \\"amount\\": 0.5}, ... {\\"user_id\\": 2, \\"item\\": \\"ruler\\", \\"amount\\": 1.5}, ... ] >>> calculate_total_spending(transactions) {1: 3.5, 2: 6.5, 3: 0.5} >>> calculate_total_spending([]) {} >>> calculate_total_spending([{\\"user_id\\": 1, \\"item\\": \\"pen\\", \\"amount\\": 2.5}]) {1: 2.5} >>> calculate_total_spending([{\\"user_id\\": \\"1\\", \\"item\\": \\"pen\\", \\"amount\\": 2.5}]) Traceback (most recent call last): ... ValueError: 'user_id' must be an integer. >>> calculate_total_spending([{\\"user_id\\": 1, \\"item\\": \\"pen\\"}]) Traceback (most recent call last): ... ValueError: Each transaction must contain 'user_id', 'item', and 'amount'. >>> calculate_total_spending([\\"invalid\\"]) Traceback (most recent call last): ... ValueError: Each transaction must be a dictionary. >>> calculate_total_spending([{\\"user_id\\": 1, \\"item\\": \\"pen\\", \\"amount\\": \\"2.5\\"}]) Traceback (most recent call last): ... ValueError: 'amount' must be a number.","solution":"def calculate_total_spending(transactions): Given a list of transactions, calculate the total spending per user. :param transactions: List of dictionaries, each containing 'user_id', 'item', and 'amount'. :return: Dictionary with user_id as keys and total spending as values. spending = {} for transaction in transactions: # Validate transaction format if not isinstance(transaction, dict): raise ValueError(\\"Each transaction must be a dictionary.\\") if not all(key in transaction for key in [\\"user_id\\", \\"item\\", \\"amount\\"]): raise ValueError(\\"Each transaction must contain 'user_id', 'item', and 'amount'.\\") if not isinstance(transaction['user_id'], int): raise ValueError(\\"'user_id' must be an integer.\\") if not isinstance(transaction['amount'], (int, float)): raise ValueError(\\"'amount' must be a number.\\") user_id = transaction['user_id'] amount = transaction['amount'] if user_id in spending: spending[user_id] += amount else: spending[user_id] = amount return spending"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Given a grid of size m x n filled with non-negative integers, find the minimum sum of the numbers along a path from the top-left to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 3, 1]]) 5 >>> minPathSum([[1], [3], [1]]) 5 >>> minPathSum([[1]]) 1 >>> minPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> minPathSum([]) 0 >>> minPathSum([[1, 2], [1, 1]]) 3","solution":"from typing import List def minPathSum(grid: List[List[int]]) -> int: # If grid is empty, return 0 if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first cell with its own value for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] # Fill up the dp table for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) # Return the value at the bottom-right corner return grid[m - 1][n - 1]"},{"question":"import json import re import csv from typing import List, Dict class Contact: def __init__(self, name: str, phone: str, email: str, tag: str): self.name = name self.phone = phone self.email = email self.tag = tag def to_dict(self) -> Dict[str, str]: return {\\"name\\": self.name, \\"phone\\": self.phone, \\"email\\": self.email, \\"tag\\": self.tag} class ContactManager: def __init__(self, storage_file: str = 'contacts.json'): Initialize the contact manager with a given storage file. self.contacts = [] self.storage_file = storage_file self.load_contacts() def add_contact(self, name: str, phone: str, email: str, tag: str): Add a new contact with the given details. # Implementation here def edit_contact(self, index: int, name: str = None, phone: str = None, email: str = None, tag: str = None): Edit an existing contact identified by index. # Implementation here def delete_contact(self, index: int): Delete a contact identified by index. # Implementation here def search_contacts(self, query: str) -> List[Dict[str, str]]: Search contacts by a query and return matching contacts as list of dictionaries. # Implementation here def export_contacts(self, csv_file: str): Export all contacts to a CSV file. # Implementation here def import_contacts(self, csv_file: str, merge: bool = True): Import contacts from a CSV file, with an option to merge or replace existing contacts. # Implementation here def save_contacts(self): Save the contacts to the storage file. # Implementation here def load_contacts(self): Load contacts from the storage file. # Implementation here @staticmethod def validate_email(email: str) -> bool: Validate the format of the provided email address. # Implementation here","solution":"import csv import json import re class Contact: def __init__(self, name, phone, email, tag): self.name = name self.phone = phone self.email = email self.tag = tag def to_dict(self): return {\\"name\\": self.name, \\"phone\\": self.phone, \\"email\\": self.email, \\"tag\\": self.tag} class ContactManager: def __init__(self, storage_file='contacts.json'): self.contacts = [] self.storage_file = storage_file self.load_contacts() def add_contact(self, name, phone, email, tag): if not self.validate_email(email): raise ValueError(\\"Invalid email format\\") if not phone.isdigit(): raise ValueError(\\"Phone number must be numeric\\") contact = Contact(name, phone, email, tag) self.contacts.append(contact) self.save_contacts() def edit_contact(self, index, name=None, phone=None, email=None, tag=None): if index < 0 or index >= len(self.contacts): raise IndexError(\\"Contact index out of range\\") if email and not self.validate_email(email): raise ValueError(\\"Invalid email format\\") if phone and not phone.isdigit(): raise ValueError(\\"Phone number must be numeric\\") contact = self.contacts[index] if name: contact.name = name if phone: contact.phone = phone if email: contact.email = email if tag: contact.tag = tag self.save_contacts() def delete_contact(self, index): if index < 0 or index >= len(self.contacts): raise IndexError(\\"Contact index out of range\\") del self.contacts[index] self.save_contacts() def search_contacts(self, query): return [c.to_dict() for c in self.contacts if query.lower() in c.name.lower()] def export_contacts(self, csv_file): fields = ['name', 'phone', 'email', 'tag'] with open(csv_file, 'w', newline='') as file: writer = csv.DictWriter(file, fieldnames=fields) writer.writeheader() for contact in self.contacts: writer.writerow(contact.to_dict()) def import_contacts(self, csv_file, merge=True): with open(csv_file, newline='') as file: reader = csv.DictReader(file) for row in reader: if merge: if not any(c.email == row['email'] for c in self.contacts): self.contacts.append(Contact(**row)) else: self.contacts.append(Contact(**row)) self.save_contacts() def save_contacts(self): with open(self.storage_file, 'w') as file: json.dump([contact.to_dict() for contact in self.contacts], file) def load_contacts(self): try: with open(self.storage_file, 'r') as file: contacts = json.load(file) self.contacts = [Contact(**c) for c in contacts] except (FileNotFoundError, json.JSONDecodeError): self.contacts = [] @staticmethod def validate_email(email): regex = r'^b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b' return re.match(regex, email) is not None"},{"question":"from typing import List def calculate_operations(operations: List[str], target: int) -> int: Implement a function that receives a list of strings representing mathematical operations and a target integer. Each string in the list will have an operation (either \\"add\\" or \\"subtract\\") followed by a space and an integer. Calculate the result of these operations starting from the target integer and return the final result. >>> calculate_operations([\\"add 5\\", \\"subtract 3\\", \\"add 2\\"], 10) 14 >>> calculate_operations([\\"subtract 10\\", \\"add 15\\"], 0) 5 # Your code here def test_example_1(): assert calculate_operations([\\"add 5\\", \\"subtract 3\\", \\"add 2\\"], 10) == 14 def test_example_2(): assert calculate_operations([\\"subtract 10\\", \\"add 15\\"], 0) == 5 def test_all_add_operations(): assert calculate_operations([\\"add 5\\", \\"add 10\\", \\"add 20\\"], 5) == 40 def test_all_subtract_operations(): assert calculate_operations([\\"subtract 5\\", \\"subtract 10\\", \\"subtract 20\\"], 50) == 15 def test_mixed_operations(): assert calculate_operations([\\"add 5\\", \\"subtract 10\\", \\"add 20\\", \\"subtract 15\\"], 10) == 10 def test_large_numbers(): assert calculate_operations([\\"add 1000\\", \\"subtract 500\\", \\"add 250\\"], 0) == 750 def test_negative_start(): assert calculate_operations([\\"add 10\\", \\"subtract 5\\"], -10) == -5 def test_no_operations(): assert calculate_operations([], 5) == 5 def test_operations_with_negative_values(): assert calculate_operations([\\"add -5\\", \\"subtract -10\\"], 5) == 10","solution":"from typing import List def calculate_operations(operations: List[str], target: int) -> int: for operation in operations: action, value = operation.split() value = int(value) if action == \\"add\\": target += value elif action == \\"subtract\\": target -= value return target"},{"question":"def categorize_books_by_genre(books): Categorize books by their genres. Args: books (list): A list of dictionaries, where each dictionary represents a book and contains the keys 'title', 'author', 'year', and 'genres'. Returns: dict: A dictionary where keys are genre names and values are lists of book titles belonging to those genres, sorted alphabetically. # Implement your function here # Example usage: books = [ {'title': 'Book A', 'author': 'Author 1', 'year': 2000, 'genres': ['Fantasy', 'Adventure']}, {'title': 'Book B', 'author': 'Author 2', 'year': 1995, 'genres': ['Science Fiction', 'Fantasy']}, {'title': 'Book C', 'author': 'Author 1', 'year': 2010, 'genres': ['Adventure']}, ] print(categorize_books_by_genre(books)) # Expected output: # { # 'Fantasy': ['Book A', 'Book B'], # 'Adventure': ['Book A', 'Book C'], # 'Science Fiction': ['Book B'] # } # Unit Tests def test_multiple_genres(): books = [ {'title': 'Book A', 'author': 'Author 1', 'year': 2000, 'genres': ['Fantasy', 'Adventure']}, {'title': 'Book B', 'author': 'Author 2', 'year': 1995, 'genres': ['Science Fiction', 'Fantasy']}, {'title': 'Book C', 'author': 'Author 1', 'year': 2010, 'genres': ['Adventure']}, ] expected_output = { 'Fantasy': ['Book A', 'Book B'], 'Adventure': ['Book A', 'Book C'], 'Science Fiction': ['Book B'] } assert categorize_books_by_genre(books) == expected_output def test_empty_list(): books = [] expected_output = {} assert categorize_books_by_genre(books) == expected_output def test_single_book(): books = [ {'title': 'Book A', 'author': 'Author 1', 'year': 2000, 'genres': ['Fantasy']}, ] expected_output = { 'Fantasy': ['Book A'] } assert categorize_books_by_genre(books) == expected_output def test_multiple_books_single_genre(): books = [ {'title': 'Book A', 'author': 'Author 1', 'year': 2000, 'genres': ['Fantasy']}, {'title': 'Book B', 'author': 'Author 2', 'year': 1995, 'genres': ['Fantasy']}, ] expected_output = { 'Fantasy': ['Book A', 'Book B'] } assert categorize_books_by_genre(books) == expected_output def test_books_with_no_genres(): books = [ {'title': 'Book A', 'author': 'Author 1', 'year': 2000, 'genres': []}, {'title': 'Book B', 'author': 'Author 2', 'year': 1995, 'genres': []}, ] expected_output = {} assert categorize_books_by_genre(books) == expected_output","solution":"def categorize_books_by_genre(books): Categorize books by their genres. Args: books (list): A list of dictionaries, where each dictionary represents a book and contains the keys 'title', 'author', 'year', and 'genres'. Returns: dict: A dictionary where keys are genre names and values are lists of book titles belonging to those genres, sorted alphabetically. genre_dict = {} for book in books: for genre in book['genres']: if genre not in genre_dict: genre_dict[genre] = [] genre_dict[genre].append(book['title']) for genre in genre_dict: genre_dict[genre].sort() return genre_dict"},{"question":"import json from datetime import datetime class BookNotFoundException(Exception): pass class InsufficientStockException(Exception): pass class Book: def __init__(self, title, author, genre, isbn, price, stock_quantity): self.title = title self.author = author self.genre = genre self.isbn = isbn self.price = price self.stock_quantity = stock_quantity class Bookstore: @staticmethod def load_data(): Load bookstore data from a JSON file. try: with open('bookstore_data.json', 'r') as file: global store store = json.load(file) except FileNotFoundError: pass @staticmethod def save_data(): Save bookstore data to a JSON file. with open('bookstore_data.json', 'w') as file: json.dump(store, file) @staticmethod def add_book(book): Add a new book to the bookstore. Args: book (Book): The book to add. store['books'].append(book.__dict__) Bookstore.save_data() @staticmethod def search_book(criteria): Search for books based on criteria. Args: criteria (dict): The criteria for searching books. Returns: list: A list of books matching the criteria. results = [book for book in store['books'] if all(book[k] == v for k, v in criteria.items())] return results @staticmethod def update_book(isbn, **updates): Update the details of a book. Args: isbn (str): The ISBN of the book to update. updates (dict): The details to update. Raises: BookNotFoundException: If the book with the given ISBN is not found. for book in store['books']: if book['isbn'] == isbn: book.update(updates) Bookstore.save_data() return True raise BookNotFoundException(\\"Book with the given ISBN not found.\\") @staticmethod def record_sale(isbn, quantity): Record a sale of a book. Args: isbn (str): The ISBN of the book sold. quantity (int): The quantity sold. Raises: InsufficientStockException: If there is not enough stock. BookNotFoundException: If the book with the given ISBN is not found. for book in store['books']: if book['isbn'] == isbn: if book['stock_quantity'] < quantity: raise InsufficientStockException(\\"Not enough stock available.\\") book['stock_quantity'] -= quantity sale_record = { 'isbn': isbn, 'quantity': quantity, 'revenue': quantity * book['price'], 'date': datetime.now().isoformat() } store['sales'].append(sale_record) Bookstore.save_data() return raise BookNotFoundException(\\"Book with the given ISBN not found.\\") @staticmethod def generate_sales_report(start_date, end_date): Generate a sales report. Args: start_date (str): The start date of the report period. end_date (str): The end date of the report period. Returns: dict: A dictionary containing sales report data. start_date = datetime.fromisoformat(start_date) end_date = datetime.fromisoformat(end_date) total_sold = 0 total_revenue = 0 popularity_tracker = {} for sale in store['sales']: sale_date = datetime.fromisoformat(sale['date']) if start_date <= sale_date <= end_date: total_sold += sale['quantity'] total_revenue += sale['revenue'] if sale['isbn'] in popularity_tracker: popularity_tracker[sale['isbn']] += sale['quantity'] else: popularity_tracker[sale['isbn']] = sale['quantity'] most_popular = max(popularity_tracker, key=popularity_tracker.get, default=None) most_popular_books = [book for book in store['books'] if book['isbn'] == most_popular][0] if most_popular else None report = { 'total_books_sold': total_sold, 'total_revenue': total_revenue, 'most_popular_books': most_popular_books } return report # Unit tests import pytest def setup_module(module): Bookstore.load_data() def teardown_module(module): Bookstore.save_data() def test_add_book(): new_book = Book(\\"Test Book\\", \\"Test Author\\", \\"Test Genre\\", \\"123456789\\", 9.99, 50) Bookstore.add_book(new_book) assert any(book['isbn'] == \\"123456789\\" for book in store['books']) def test_search_book(): criteria = {\\"title\\": \\"Test Book\\"} results = Bookstore.search_book(criteria) assert len(results) > 0 assert results[0]['title'] == \\"Test Book\\" def test_update_book(): Bookstore.update_book(\\"123456789\\", price=12.99, stock_quantity=60) book = next(book for book in store['books'] if book['isbn'] == \\"123456789\\") assert book['price'] == 12.99 assert book['stock_quantity'] == 60 with pytest.raises(BookNotFoundException): Bookstore.update_book(\\"invalid_isbn\\", price=10.99) def test_record_sale(): Bookstore.record_sale(\\"123456789\\", 10) book = next(book for book in store['books'] if book['isbn'] == \\"123456789\\") assert book['stock_quantity'] == 50 # was 60, sold 10 with pytest.raises(InsufficientStockException): Bookstore.record_sale(\\"123456789\\", 100) with pytest.raises(BookNotFoundException): Bookstore.record_sale(\\"invalid_isbn\\", 1) def test_generate_sales_report(): start_date = datetime.now().isoformat() end_date = datetime.now().isoformat() report = Bookstore.generate_sales_report(start_date, end_date) assert report['total_books_sold'] >= 0 assert report['total_revenue'] >= 0 if report['most_popular_books']: assert 'isbn' in report['most_popular_books']","solution":"import json from datetime import datetime # The unified in-memory storage store = { 'books': [], 'sales': [] } # Exception Classes class BookNotFoundException(Exception): pass class InsufficientStockException(Exception): pass class Book: def __init__(self, title, author, genre, isbn, price, stock_quantity): self.title = title self.author = author self.genre = genre self.isbn = isbn self.price = price self.stock_quantity = stock_quantity class Bookstore: @staticmethod def load_data(): try: with open('bookstore_data.json', 'r') as file: global store store = json.load(file) except FileNotFoundError: pass # No existing data, that's fine. @staticmethod def save_data(): with open('bookstore_data.json', 'w') as file: json.dump(store, file) @staticmethod def add_book(book): store['books'].append(book.__dict__) Bookstore.save_data() @staticmethod def search_book(criteria): results = [book for book in store['books'] if all(book[k] == v for k, v in criteria.items())] return results @staticmethod def update_book(isbn, **updates): for book in store['books']: if book['isbn'] == isbn: book.update(updates) Bookstore.save_data() return True raise BookNotFoundException(\\"Book with the given ISBN not found.\\") @staticmethod def record_sale(isbn, quantity): for book in store['books']: if book['isbn'] == isbn: if book['stock_quantity'] < quantity: raise InsufficientStockException(\\"Not enough stock available.\\") book['stock_quantity'] -= quantity sale_record = { 'isbn': isbn, 'quantity': quantity, 'revenue': quantity * book['price'], 'date': datetime.now().isoformat() } store['sales'].append(sale_record) Bookstore.save_data() return raise BookNotFoundException(\\"Book with the given ISBN not found.\\") @staticmethod def generate_sales_report(start_date, end_date): start_date = datetime.fromisoformat(start_date) end_date = datetime.fromisoformat(end_date) total_sold = 0 total_revenue = 0 popularity_tracker = {} for sale in store['sales']: sale_date = datetime.fromisoformat(sale['date']) if start_date <= sale_date <= end_date: total_sold += sale['quantity'] total_revenue += sale['revenue'] if sale['isbn'] in popularity_tracker: popularity_tracker[sale['isbn']] += sale['quantity'] else: popularity_tracker[sale['isbn']] = sale['quantity'] most_popular = max(popularity_tracker, key=popularity_tracker.get, default=None) most_popular_books = [book for book in store['books'] if book['isbn'] == most_popular][0] if most_popular else None report = { 'total_books_sold': total_sold, 'total_revenue': total_revenue, 'most_popular_books': most_popular_books } return report"},{"question":"def calculate_ratio(croissants: int, baguettes: int) -> str: Calculate the ratio of croissants to baguettes. Args: croissants (int): Number of croissants. baguettes (int): Number of baguettes. Returns: str: The ratio of croissants to baguettes in the format 'a:b' where a and b are the simplest form of the ratio. gcd = greatest_common_divisor(croissants, baguettes) return f\\"{croissants // gcd}:{baguettes // gcd}\\" def greatest_common_divisor(a: int, b: int) -> int: Computes the greatest common divisor of a and b using Euclid's algorithm. Args: a (int): First number. b (int): Second number. Returns: int: The greatest common divisor of a and b. while b: a, b = b, a % b return a # Test cases def test_calculate_ratio(): assert calculate_ratio(20, 50) == \\"2:5\\" assert calculate_ratio(10, 5) == \\"2:1\\" assert calculate_ratio(6, 3) == \\"2:1\\" assert calculate_ratio(0, 5) == \\"0:1\\" assert calculate_ratio(5, 0) == \\"1:0\\" assert calculate_ratio(7, 3) == \\"7:3\\" def test_greatest_common_divisor(): assert greatest_common_divisor(20, 50) == 10 assert greatest_common_divisor(18, 24) == 6 assert greatest_common_divisor(7, 5) == 1 assert greatest_common_divisor(0, 5) == 5 assert greatest_common_divisor(5, 0) == 5 if __name__ == \\"__main__\\": test_calculate_ratio() test_greatest_common_divisor() print(\\"All tests passed.\\")","solution":"def calculate_ratio(croissants, baguettes): Calculate the ratio of croissants to baguettes. Args: croissants (int): Number of croissants. baguettes (int): Number of baguettes. Returns: str: The ratio of croissants to baguettes in the format 'a:b' where a and b are the simplest form of the ratio. gcd = greatest_common_divisor(croissants, baguettes) return f\\"{croissants // gcd}:{baguettes // gcd}\\" def greatest_common_divisor(a, b): Computes the greatest common divisor of a and b using Euclid's algorithm. Args: a (int): First number. b (int): Second number. Returns: int: The greatest common divisor of a and b. while b: a, b = b, a % b return a # The bakery has 20 croissants and 50 baguettes croissants = 20 baguettes = 50 # Calculate the ratio ratio = calculate_ratio(croissants, baguettes) ratio"},{"question":"def merge_sorted_arrays(list_a: List[int], list_b: List[int]) -> List[int]: Merges two sorted lists into one sorted list. >>> merge_sorted_arrays([], []) == [] >>> merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 3, 6]) == [1, 2, 3, 3, 5, 6] >>> merge_sorted_arrays([-3, -2, 1], [-4, 0, 2]) == [-4, -3, -2, 0, 1, 2] >>> merge_sorted_arrays([1, 1, 2], [1, 3, 3]) == [1, 1, 1, 2, 3, 3] # Your implementation here","solution":"def merge_sorted_arrays(list_a, list_b): Merges two sorted lists into one sorted list. merged_list = [] i, j = 0, 0 while i < len(list_a) and j < len(list_b): if list_a[i] < list_b[j]: merged_list.append(list_a[i]) i += 1 else: merged_list.append(list_b[j]) j += 1 # Add remaining elements from list_a, if any while i < len(list_a): merged_list.append(list_a[i]) i += 1 # Add remaining elements from list_b, if any while j < len(list_b): merged_list.append(list_b[j]) j += 1 return merged_list"},{"question":"def calculate_packs_needed(total_required: int, current_beads: int, pack_size: int) -> int: This function calculates the number of bead packs needed. total_required: int - Total beads required for the project current_beads: int - Beads currently available pack_size: int - Number of beads in one pack Returns: int - Number of whole packs needed to buy >>> calculate_packs_needed(350, 200, 25) 6 >>> calculate_packs_needed(350, 300, 25) 2 >>> calculate_packs_needed(350, 325, 25) 1 >>> calculate_packs_needed(400, 150, 25) 10 >>> calculate_packs_needed(500, 0, 25) 20 >>> calculate_packs_needed(100, 0, 25) 4 >>> calculate_packs_needed(100, 90, 25) 1 def olivia_beads_packs() -> int: Calculates the number of packs Olivia needs to buy for her bead project. >>> olivia_beads_packs() 6","solution":"def calculate_packs_needed(total_required, current_beads, pack_size): This function calculates the number of bead packs needed. total_required: int - Total beads required for the project current_beads: int - Beads currently available pack_size: int - Number of beads in one pack Returns: int - Number of whole packs needed to buy beads_needed = total_required - current_beads packs_needed = (beads_needed + (pack_size - 1)) // pack_size # Ceiling division return packs_needed # Olivia's specific case def olivia_beads_packs(): return calculate_packs_needed(350, 200, 25)"},{"question":"def arrayMerger(list1, list2): Merges two lists by alternating elements from each list. If one list is shorter, append the remaining elements from the longer list at the end. Parameters: - list1: First list - list2: Second list Returns: - merged_list: A new list with elements alternated from list1 and list2 Examples: >>> arrayMerger([1, 2, 3], ['a', 'b', 'c', 'd']) [1, 'a', 2, 'b', 3, 'c', 'd'] >>> arrayMerger([1, 2], ['a', 'b', 'c', 'd']) [1, 'a', 2, 'b', 'c', 'd' pass def test_interleave_same_length_lists(): assert arrayMerger([1, 2, 3], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c'] def test_first_list_longer(): assert arrayMerger([1, 2, 3, 4], ['a', 'b']) == [1, 'a', 2, 'b', 3, 4] def test_second_list_longer(): assert arrayMerger([1, 2], ['a', 'b', 'c', 'd']) == [1, 'a', 2, 'b', 'c', 'd'] def test_empty_first_list(): assert arrayMerger([], ['a', 'b', 'c']) == ['a', 'b', 'c'] def test_empty_second_list(): assert arrayMerger([1, 2, 3], []) == [1, 2, 3] def test_both_lists_empty(): assert arrayMerger([], []) == []","solution":"def arrayMerger(list1, list2): Merges two lists by alternating elements from each list. If one list is shorter, append the remaining elements from the longer list at the end. Parameters: - list1: First list - list2: Second list Returns: - merged_list: A new list with elements alternated from list1 and list2 merged_list = [] i, j = 0, 0 # Interleave elements from both lists while i < len(list1) and j < len(list2): merged_list.append(list1[i]) merged_list.append(list2[j]) i += 1 j += 1 # Append remaining elements from the longer list while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def sort_by_even_odd(arr): Sort the list such that all even numbers come before all odd numbers, while preserving the relative order of the even and odd numbers. >>> sort_by_even_odd([5, 3, 4, 1, 2]) [4, 2, 5, 3, 1] >>> sort_by_even_odd([4, 2, 6, 8]) [4, 2, 6, 8] >>> sort_by_even_odd([5, 3, 9, 1]) [5, 3, 9, 1] >>> sort_by_even_odd([]) [] >>> sort_by_even_odd([2]) [2] >>> sort_by_even_odd([3]) [3] >>> sort_by_even_odd([2, 2, 3, 3]) [2, 2, 3, 3] >>> sort_by_even_odd([2, 4, 6, 1, 3, 5]) [2, 4, 6, 1, 3, 5]","solution":"def sort_by_even_odd(arr): Sort the list such that all even numbers come before all odd numbers, while preserving the relative order of the even and odd numbers. evens = [] odds = [] for num in arr: if num % 2 == 0: evens.append(num) else: odds.append(num) return evens + odds"},{"question":"class Dish: def __init__(self, name, description, price, availability): self.name = name self.description = description self.price = price self.availability = availability def update_availability(self, availability): self.availability = availability class Order: def __init__(self, customer_name, dishes): self.customer_name = customer_name self.dishes = dishes self.total_price = sum(dish.price for dish in dishes) self.status = 'pending' def update_status(self, status): self.status = status class Restaurant: def __init__(self): self.menu = [] self.orders = [] def display_menu(self): Display the current menu with details of each dish. pass def add_dish_to_menu(self, name, description, price, availability): Add a new dish to the menu. pass def place_order(self, customer_name, ordered_dishes_names): Place an order for the customer. pass def update_inventory(self, ordered_dishes): Update the inventory status of dishes based on orders placed. pass def update_order_status(self, order_id, status): Update the status of an existing order. pass def cancel_order(self, order_id): Cancel an existing order and update the inventory. pass # Unit tests def test_add_dish_to_menu(): restaurant = Restaurant() restaurant.add_dish_to_menu(\\"Pasta\\", \\"Creamy Alfredo Pasta\\", 12.99, 'available') menu = restaurant.display_menu() assert len(menu) == 1 assert menu[0]['name'] == \\"Pasta\\" assert menu[0]['price'] == 12.99 assert menu[0]['availability'] == 'available' def test_place_order(): restaurant = Restaurant() restaurant.add_dish_to_menu(\\"Pasta\\", \\"Creamy Alfredo Pasta\\", 12.99, 'available') order = restaurant.place_order(\\"John Doe\\", [\\"Pasta\\"]) assert order.customer_name == \\"John Doe\\" assert len(order.dishes) == 1 assert order.dishes[0].name == \\"Pasta\\" assert order.total_price == 12.99 assert order.status == 'pending' def test_update_inventory(): restaurant = Restaurant() restaurant.add_dish_to_menu(\\"Pasta\\", \\"Creamy Alfredo Pasta\\", 12.99, 'available') restaurant.place_order(\\"John Doe\\", [\\"Pasta\\"]) assert restaurant.menu[0].availability == 'sold out' def test_update_order_status(): restaurant = Restaurant() restaurant.add_dish_to_menu(\\"Pasta\\", \\"Creamy Alfredo Pasta\\", 12.99, 'available') order = restaurant.place_order(\\"John Doe\\", [\\"Pasta\\"]) restaurant.update_order_status(0, 'completed') assert restaurant.orders[0].status == 'completed' def test_cancel_order(): restaurant = Restaurant() restaurant.add_dish_to_menu(\\"Pasta\\", \\"Creamy Alfredo Pasta\\", 12.99, 'available') order = restaurant.place_order(\\"John Doe\\", [\\"Pasta\\"]) restaurant.cancel_order(0) assert len(restaurant.orders) == 0 assert restaurant.menu[0].availability == 'available'","solution":"class Dish: def __init__(self, name, description, price, availability): self.name = name self.description = description self.price = price self.availability = availability def update_availability(self, availability): self.availability = availability class Order: def __init__(self, customer_name, dishes): self.customer_name = customer_name self.dishes = dishes self.total_price = sum(dish.price for dish in dishes) self.status = 'pending' def update_status(self, status): self.status = status class Restaurant: def __init__(self): self.menu = [] self.orders = [] def display_menu(self): return [{'name': dish.name, 'description': dish.description, 'price': dish.price, 'availability': dish.availability} for dish in self.menu] def add_dish_to_menu(self, name, description, price, availability): dish = Dish(name, description, price, availability) self.menu.append(dish) def place_order(self, customer_name, ordered_dishes_names): ordered_dishes = [] for dish_name in ordered_dishes_names: for dish in self.menu: if dish.name == dish_name and dish.availability == 'available': ordered_dishes.append(dish) break else: raise ValueError(f\\"Dish {dish_name} is not available\\") order = Order(customer_name, ordered_dishes) self.orders.append(order) self.update_inventory(ordered_dishes) return order def update_inventory(self, ordered_dishes): for ordered_dish in ordered_dishes: ordered_dish.update_availability('sold out') def update_order_status(self, order_id, status): self.orders[order_id].update_status(status) def cancel_order(self, order_id): for dish in self.orders[order_id].dishes: dish.update_availability('available') del self.orders[order_id]"},{"question":"from typing import List, Tuple def find_closest_pair(arr: List[int]) -> Tuple[int, int]: Write a function in Python that takes a list of integers and returns the two numbers that subtract to give the smallest absolute difference. If there are multiple pairs, return any one pair. Your function should have a time complexity better than O(n^2). :param arr: List of integers :return: Tuple containing two integers that are closest to each other in terms of their difference Examples: >>> find_closest_pair([4, 9, 1, 32, 13]) in [(1, 4), (4, 9)] True >>> find_closest_pair([-5, -2, -14, -1]) == (-2, -1) True pass def test_find_closest_pair_standard(): assert find_closest_pair([4, 9, 1, 32, 13]) in [(1, 4), (4, 9)] def test_find_closest_pair_negative_numbers(): assert find_closest_pair([-5, -2, -14, -1]) == (-2, -1) def test_find_closest_pair_mixed_numbers(): assert find_closest_pair([-1, 1, 3, -4, -2]) == (-2, -1) def test_find_closest_pair_duplicate_numbers(): assert find_closest_pair([1, 3, 4, 4, 2, 0]) == (4, 4) def test_find_closest_pair_only_two_elements(): assert find_closest_pair([10, 20]) == (10, 20) def test_find_closest_pair_large_numbers(): assert find_closest_pair([100000, 99999, 99998, -100000]) == (99998, 99999)","solution":"from typing import List, Tuple def find_closest_pair(arr: List[int]) -> Tuple[int, int]: Returns the two numbers that subtract to give the smallest absolute difference. # Sort the array to bring closest numbers next to each other arr.sort() # Initialize the minimum difference as a large number min_diff = float('inf') closest_pair = (None, None) # Traverse the sorted array and find the closest pair for i in range(len(arr) - 1): diff = abs(arr[i] - arr[i + 1]) if diff < min_diff: min_diff = diff closest_pair = (arr[i], arr[i + 1]) return closest_pair"},{"question":"def rle_encoding(s: str) -> str: Compresses the input string using Run-Length Encoding (RLE) algorithm. >>> rle_encoding(\\"aaaabbbccdaa\\") 'a4b3c2d1a2' >>> rle_encoding(\\"abcd\\") 'a1b1c1d1' >>> rle_encoding(\\"a\\") 'a1' >>> rle_encoding(\\"aaaaaaaaaaaa\\") 'a12' def rle_decoding(s: str) -> str: Reverts the RLE compressed string back to its original form. >>> rle_decoding(\\"a4b3c2d1a2\\") 'aaaabbbccdaa' >>> rle_decoding(\\"a1b1c1d1\\") 'abcd' >>> rle_decoding(\\"a1\\") 'a' >>> rle_decoding(\\"a12\\") 'aaaaaaaaaaaa' ''' from solution import rle_encoding, rle_decoding def test_rle_encoding_empty_string(): assert rle_encoding(\\"\\") == \\"\\" def test_rle_encoding_no_repeats(): assert rle_encoding(\\"abcd\\") == \\"a1b1c1d1\\" def test_rle_encoding_single_character(): assert rle_encoding(\\"a\\") == \\"a1\\" def test_rle_encoding_repeats(): assert rle_encoding(\\"aaaabbbccdaa\\") == \\"a4b3c2d1a2\\" assert rle_encoding(\\"aaaaaaaaaaaa\\") == \\"a12\\" def test_rle_decoding_empty_string(): assert rle_decoding(\\"\\") == \\"\\" def test_rle_decoding_single_character(): assert rle_decoding(\\"a1\\") == \\"a\\" def test_rle_decoding_no_repeats(): assert rle_decoding(\\"a1b1c1d1\\") == \\"abcd\\" def test_rle_decoding_repeats(): assert rle_decoding(\\"a4b3c2d1a2\\") == \\"aaaabbbccdaa\\" assert rle_decoding(\\"a12\\") == \\"aaaaaaaaaaaa\\" def test_rle_cycle(): original = \\"aaaabbbccdaa\\" compressed = rle_encoding(original) decompressed = rle_decoding(compressed) assert decompressed == original def test_rle_cycle_no_repeats(): original = \\"abcd\\" compressed = rle_encoding(original) decompressed = rle_decoding(compressed) assert decompressed == original def test_rle_cycle_single_character(): original = \\"a\\" compressed = rle_encoding(original) decompressed = rle_decoding(compressed) assert decompressed == original '''","solution":"def rle_encoding(s): Compresses the input string using Run-Length Encoding (RLE) algorithm. if not s: return '' encoding = '' prev_char = s[0] count = 1 for char in s[1:]: if char == prev_char: count += 1 else: encoding += prev_char + str(count) prev_char = char count = 1 encoding += prev_char + str(count) return encoding def rle_decoding(s): Reverts the RLE compressed string back to its original form. if not s: return '' decoding = '' i = 0 while i < len(s): char = s[i] count = '' i += 1 while i < len(s) and s[i].isdigit(): count += s[i] i += 1 decoding += char * int(count) return decoding # Example usage: input_strings = [\\"aaaabbbccdaa\\", \\"abcd\\", \\"a\\", \\"aaaaaaaaaaaa\\"] compressed_strings = [rle_encoding(s) for s in input_strings] print(compressed_strings) # Outputs: ['a4b3c2d1a2', 'a1b1c1d1', 'a1', 'a12'] # Decoding to verify decoded_strings = [rle_decoding(s) for s in compressed_strings] print(decoded_strings) # Outputs: ['aaaabbbccdaa', 'abcd', 'a', 'aaaaaaaaaaaa']"},{"question":"import string class WordFrequency: def __init__(self, text): Initializes the class with the provided text. self.text = text self.word_counts = {} def process_text(self): Processes the text to remove punctuation and convert all words to lowercase. translator = str.maketrans('', '', string.punctuation) processed_text = self.text.translate(translator).lower() self.processed_text = processed_text def frequency(self): Returns a dictionary where the keys are words and the values are their corresponding frequencies. words = self.processed_text.split() for word in words: if word in self.word_counts: self.word_counts[word] += 1 else: self.word_counts[word] = 1 return self.word_counts def test_process_text(): wf = WordFrequency(\\"Hello, world! Python is great.\\") wf.process_text() assert wf.processed_text == \\"hello world python is great\\", \\"Text did not process correctly\\" def test_frequency(): wf = WordFrequency(\\"Hello, world! Python is great. Hello again, world!\\") wf.process_text() freq = wf.frequency() expected = { \\"hello\\": 2, \\"world\\": 2, \\"python\\": 1, \\"is\\": 1, \\"great\\": 1, \\"again\\": 1 } assert freq == expected, \\"Frequency count is incorrect\\" def test_empty_text(): wf = WordFrequency(\\"\\") wf.process_text() freq = wf.frequency() assert freq == {}, \\"Frequency count should be empty for empty text\\" def test_single_word(): wf = WordFrequency(\\"test\\") wf.process_text() freq = wf.frequency() expected = {\\"test\\": 1} assert freq == expected, \\"Frequency count for single word is incorrect\\" def test_punctuation_handling(): wf = WordFrequency(\\"Hello, world! Well, hello, world.\\") wf.process_text() freq = wf.frequency() expected = { \\"hello\\": 2, \\"world\\": 2, \\"well\\": 1 } assert freq == expected, \\"Punctuation handling is incorrect\\" # Erroneous code: # It incorrectly removes punctuation by simply replacing punctuation with ' ' (space) # def process_text(self): # for char in string.punctuation: # self.text = self.text.replace(char, ' ') # incorrect handling # self.text = self.text.lower() # This code can leave extra spaces and can mess up word counting","solution":"import string class WordFrequency: def __init__(self, text): self.text = text self.word_counts = {} def process_text(self): # Remove punctuation and convert to lowercase translator = str.maketrans('', '', string.punctuation) processed_text = self.text.translate(translator).lower() self.processed_text = processed_text def frequency(self): words = self.processed_text.split() for word in words: if word in self.word_counts: self.word_counts[word] += 1 else: self.word_counts[word] = 1 return self.word_counts # Erroneous code: # It incorrectly removes punctuation by simply replacing punctuation with ' ' (space) # def process_text(self): # for char in string.punctuation: # self.text = self.text.replace(char, ' ') # incorrect handling # self.text = self.text.lower() # This code can leave extra spaces and can mess up word counting # Corrected code uses str.maketrans and translate"},{"question":"from typing import List def classify_numbers(numbers: List[int]) -> List[List[int]]: Given a list of integers, group these integers into two categories: Group 1: Numbers that are prime. Group 2: Numbers that are composite. The function should return a list containing two lists: the first list should contain all the prime numbers in ascending order, and the second list should contain all the composite numbers in descending order. If a number is neither prime nor composite (e.g., 1), it should be ignored. >>> classify_numbers([4, 2, 5, 3, 9, 15, 1]) [[2, 3, 5], [15, 9, 4]] >>> classify_numbers([2, 2, 2, 4, 4, 4]) [[2], [4]] >>> classify_numbers([10, 20, 30, 40, 50]) [[], [50, 40, 30, 20, 10]] >>> classify_numbers([11, 13, 17]) [[11, 13, 17], []] >>> classify_numbers([0, 1, -1, -2, -3]) [[], []] >>> classify_numbers([16, 16, 8, 8, 4, 4, 2, 2]) [[2], [16, 8, 4]] >>> classify_numbers([23, 25, 27, 29, 31]) [[23, 29, 31], [27, 25]] pass","solution":"from typing import List from math import isqrt def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def classify_numbers(numbers: List[int]) -> List[List[int]]: primes = [] composites = [] seen_primes = set() seen_composites = set() for number in numbers: if number > 1: if is_prime(number): if number not in seen_primes: primes.append(number) seen_primes.add(number) else: if number not in seen_composites: composites.append(number) seen_composites.add(number) primes.sort() composites.sort(reverse=True) return [primes, composites]"},{"question":"def count_integers(input_list): Returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appears in the list. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary with integer keys and their count as values. Raises: ValueError: If input_list is not a list or contains non-integer elements. pass import pytest def test_count_integers_empty_list(): assert count_integers([]) == {} def test_count_integers_single_element(): assert count_integers([1]) == {1: 1} def test_count_integers_multiple_unique_elements(): assert count_integers([1, 2, 3, 4]) == {1: 1, 2: 1, 3: 1, 4: 1} def test_count_integers_multiple_duplicate_elements(): assert count_integers([1, 1, 2, 2, 2, 3]) == {1: 2, 2: 3, 3: 1} def test_count_integers_mixed_elements(): assert count_integers([1, 2, 3, 1, 2, 1]) == {1: 3, 2: 2, 3: 1} def test_count_integers_non_list_input(): with pytest.raises(ValueError, match=\\"Input must be a list\\"): count_integers(\\"not a list\\") def test_count_integers_non_integer_elements(): with pytest.raises(ValueError, match=\\"All elements in the list must be integers\\"): count_integers([1, 2, \\"three\\", 4]) with pytest.raises(ValueError, match=\\"All elements in the list must be integers\\"): count_integers([1, 2, 3.5, 4]) def test_count_integers_mixed_valid_invalid(): with pytest.raises(ValueError, match=\\"All elements in the list must be integers\\"): count_integers([1, 2, 3, 'four', 5]) def test_count_integers_large_list(): large_list = [1] * 1000 + [2] * 2000 + [3] * 3000 expected_output = {1: 1000, 2: 2000, 3: 3000} assert count_integers(large_list) == expected_output","solution":"def count_integers(input_list): Returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appears in the list. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary with integer keys and their count as values. Raises: ValueError: If input_list is not a list or contains non-integer elements. if not isinstance(input_list, list): raise ValueError(\\"Input must be a list\\") count_dict = {} for item in input_list: if not isinstance(item, int): raise ValueError(\\"All elements in the list must be integers\\") if item in count_dict: count_dict[item] += 1 else: count_dict[item] = 1 return count_dict"},{"question":"from typing import List def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: Find the common elements between two sorted lists. Validate inputs to ensure both lists are sorted and contain only integers. Handles edge cases such as empty lists and lists of different lengths. Args: list1, list2 - Lists of integers, both must be sorted. Returns: A list of the common elements between the two lists. >>> find_common_elements([1, 2, 3], [2, 3, 4]) [2, 3] >>> find_common_elements([1, 3, 5], [2, 4, 6]) [] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3], []) [] >>> find_common_elements([1, 2, 2, 3], [2, 2, 3, 4]) [2, 2, 3] if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both inputs must be lists.\\") if not all(isinstance(x, int) for x in list1 + list2): raise ValueError(\\"All elements in the lists must be integers.\\") if not all(list1[i] <= list1[i+1] for i in range(len(list1)-1)): raise ValueError(\\"First list is not sorted.\\") if not all(list2[i] <= list2[i+1] for i in range(len(list2)-1)): raise ValueError(\\"Second list is not sorted.\\") if not list1 or not list2: return [] common_elements = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: common_elements.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common_elements def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merge two sorted lists into a single sorted list without using built-in sorting functions. Validate inputs to ensure both lists contain only integers. Args: list1, list2 - Lists of integers, both should be sorted. Returns: A single sorted list containing all elements from both input lists. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 3], [2, 3, 4]) [1, 2, 2, 3, 3, 4] if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both inputs must be lists.\\") if not all(isinstance(x, int) for x in list1 + list2): raise ValueError(\\"All elements in the lists must be integers.\\") i, j, merged_list = 0, 0, [] while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list","solution":"def find_common_elements(list1, list2): if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both inputs must be lists.\\") if not all(isinstance(x, int) for x in list1 + list2): raise ValueError(\\"All elements in the lists must be integers.\\") if not all(list1[i] <= list1[i+1] for i in range(len(list1)-1)): raise ValueError(\\"First list is not sorted.\\") if not all(list2[i] <= list2[i+1] for i in range(len(list2)-1)): raise ValueError(\\"Second list is not sorted.\\") if not list1 or not list2: return [] common_elements = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: common_elements.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common_elements def merge_sorted_lists(list1, list2): if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both inputs must be lists.\\") if not all(isinstance(x, int) for x in list1 + list2): raise ValueError(\\"All elements in the lists must be integers.\\") i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"class Book: def __init__(self, title: str, author: str, year: int): self._title = title self._author = author self._year = year def get_title(self) -> str: Get the title of the book return self._title def set_title(self, title: str) -> None: Set the title of the book self._title = title def get_author(self) -> str: Get the author of the book return self._author def set_author(self, author: str) -> None: Set the author of the book self._author = author def get_year(self) -> int: Get the year of publication of the book return self._year def set_year(self, year: int) -> None: Set the year of publication of the book self._year = year def __str__(self) -> str: Return the string representation of the book return f\\"'{self._title}' by {self._author} published in {self._year}\\" class Author: def __init__(self, name: str): self._name = name self._books = [] def get_name(self) -> str: Get the name of the author return self._name def get_books(self) -> list: Get the list of books written by the author return self._books def add_book(self, book: Book) -> None: Add a book to the author's bibliography self._books.append(book) def __str__(self) -> str: Return the string representation of the author books = ', '.join(book.get_title() for book in self._books) return f\\"Author: {self._name}, Books: {books}\\" class Library: def __init__(self, name: str): self._name = name self._books = [] def add_book(self, book: Book) -> None: Add a book to the library for b in self._books: if b.get_title() == book.get_title() and b.get_author() == book.get_author() and b.get_year() == book.get_year(): return self._books.append(book) def remove_book(self, book: Book) -> None: Remove a book from the library self._books.remove(book) def get_books(self) -> list: Get the list of books in the library return self._books def find_books_by_author(self, author_name: str) -> list: Find books by a specific author return [book for book in self._books if book.get_author() == author_name] def __str__(self) -> str: Return the string representation of the library books = ', '.join(str(book) for book in self._books) return f\\"Library: {self._name}, Books: {books}\\" def test_book_class(): Test cases for the Book class book = Book(\\"1984\\", \\"George Orwell\\", 1949) assert book.get_title() == \\"1984\\" assert book.get_author() == \\"George Orwell\\" assert book.get_year() == 1949 book.set_title(\\"Animal Farm\\") book.set_author(\\"George Orwell\\") book.set_year(1945) assert book.get_title() == \\"Animal Farm\\" assert book.get_author() == \\"George Orwell\\" assert book.get_year() == 1945 assert str(book) == \\"'Animal Farm' by George Orwell published in 1945\\" def test_author_class(): Test cases for the Author class author = Author(\\"George Orwell\\") assert author.get_name() == \\"George Orwell\\" book1 = Book(\\"1984\\", \\"George Orwell\\", 1949) book2 = Book(\\"Animal Farm\\", \\"George Orwell\\", 1945) author.add_book(book1) author.add_book(book2) assert len(author.get_books()) == 2 assert author.get_books()[0] == book1 assert author.get_books()[1] == book2 assert str(author) == \\"Author: George Orwell, Books: 1984, Animal Farm\\" def test_library_class(): Test cases for the Library class library = Library(\\"City Library\\") assert str(library) == \\"Library: City Library, Books: \\" book1 = Book(\\"1984\\", \\"George Orwell\\", 1949) book2 = Book(\\"Animal Farm\\", \\"George Orwell\\", 1945) library.add_book(book1) library.add_book(book2) assert len(library.get_books()) == 2 assert library.get_books()[0] == book1 assert library.get_books()[1] == book2 assert str(library) == \\"Library: City Library, Books: '1984' by George Orwell published in 1949, 'Animal Farm' by George Orwell published in 1945\\" library.add_book(book1) # Trying to add duplicate assert len(library.get_books()) == 2 # Should still be 2 as duplicates are not added library.remove_book(book1) assert len(library.get_books()) == 1 books_by_orwell = library.find_books_by_author(\\"George Orwell\\") assert len(books_by_orwell) == 1 assert books_by_orwell[0] == book2","solution":"class Book: def __init__(self, title, author, year): self._title = title self._author = author self._year = year def get_title(self): return self._title def set_title(self, title): self._title = title def get_author(self): return self._author def set_author(self, author): self._author = author def get_year(self): return self._year def set_year(self, year): self._year = year def __str__(self): return f\\"'{self._title}' by {self._author} published in {self._year}\\" class Author: def __init__(self, name): self._name = name self._books = [] def get_name(self): return self._name def get_books(self): return self._books def add_book(self, book): if book not in self._books: self._books.append(book) def __str__(self): books = ', '.join(book.get_title() for book in self._books) return f\\"Author: {self._name}, Books: {books}\\" class Library: def __init__(self, name): self._name = name self._books = [] def add_book(self, book): if book not in self._books: self._books.append(book) def remove_book(self, book): if book in self._books: self._books.remove(book) def get_books(self): return self._books def find_books_by_author(self, author_name): return [book for book in self._books if book.get_author() == author_name] def __str__(self): books = ', '.join(str(book) for book in self._books) return f\\"Library: {self._name}, Books: {books}\\""},{"question":"def separate_and_sort_even_odd(input_list: List[int]) -> List[int]: Separates the input list into even and odd numbers, sorts each sublist and returns a merged list starting with even numbers followed by odd numbers. >>> separate_and_sort_even_odd([10, 23, 45, 18, 2, 33, 50, 41]) [2, 10, 18, 50, 23, 33, 41, 45] >>> separate_and_sort_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] >>> separate_and_sort_even_odd([10, 20, 30, 40, 50, 60]) [10, 20, 30, 40, 50, 60] >>> separate_and_sort_even_odd([11, 21, 31, 41, 51, 61]) [11, 21, 31, 41, 51, 61] >>> separate_and_sort_even_odd([]) [] >>> separate_and_sort_even_odd([0, 1, 2, 3, 4, 5]) [0, 2, 4, 1, 3, 5] >>> separate_and_sort_even_odd([2]) [2] >>> separate_and_sort_even_odd([3]) [3]","solution":"def separate_and_sort_even_odd(input_list): Separates the input list into even and odd numbers, sorts each sublist and returns a merged list starting with even numbers followed by odd numbers. evens = sorted([num for num in input_list if num % 2 == 0]) odds = sorted([num for num in input_list if num % 2 != 0]) return evens + odds"},{"question":"import pandas as pd def manipulate_csv(input_csv, output_csv, filter_condition, group_by_column, agg_func): Loads a CSV file, filters rows by a given condition, groups by a specified column, calculates aggregated values, and saves the resulting DataFrame to a new CSV file. >>> manipulate_csv('test_input.csv', 'test_output.csv', \\"Value > 10\\", \\"Category\\", {'Value': 'sum'}) import os import pandas as pd from manipulate_csv import manipulate_csv def test_manipulate_csv(): # Sample data for testing data = { 'Category': ['A', 'A', 'B', 'B', 'C'], 'Value': [10, 20, 10, 5, 30] } input_csv = 'test_input.csv' output_csv = 'test_output.csv' # Create a sample CSV file df = pd.DataFrame(data) df.to_csv(input_csv, index=False) # Define filter condition, group by column, and aggregation function filter_condition = \\"Value > 10\\" group_by_column = \\"Category\\" agg_func = {'Value': 'sum'} # Run the function manipulate_csv(input_csv, output_csv, filter_condition, group_by_column, agg_func) # Load the output CSV file df_result = pd.read_csv(output_csv) # Expected result expected_data = { 'Category': ['A', 'C'], 'Value': [20, 30] } df_expected = pd.DataFrame(expected_data) # Check if the output matches the expected result pd.testing.assert_frame_equal(df_result, df_expected) # Cleanup os.remove(input_csv) os.remove(output_csv) def test_empty_filter_result(): # Sample data for testing data = { 'Category': ['A', 'A', 'B', 'B', 'C'], 'Value': [10, 20, 10, 5, 30] } input_csv = 'test_input.csv' output_csv = 'test_output.csv' # Create a sample CSV file df = pd.DataFrame(data) df.to_csv(input_csv, index=False) # Define filter condition that results in an empty DataFrame filter_condition = \\"Value > 100\\" group_by_column = \\"Category\\" agg_func = {'Value': 'sum'} # Run the function manipulate_csv(input_csv, output_csv, filter_condition, group_by_column, agg_func) # Load the output CSV file df_result = pd.read_csv(output_csv) # Expected result should be an empty DataFrame with the same columns df_expected = pd.DataFrame(columns=['Category', 'Value']) # Check if the output matches the expected result pd.testing.assert_frame_equal(df_result, df_expected) # Cleanup os.remove(input_csv) os.remove(output_csv)","solution":"import pandas as pd def manipulate_csv(input_csv, output_csv, filter_condition, group_by_column, agg_func): Loads a CSV file, filters rows by a given condition, groups by a specified column, calculates aggregated values, and saves the resulting DataFrame to a new CSV file. Args: input_csv (str): The path to the input CSV file. output_csv (str): The path to save the resulting CSV file. filter_condition (str): The condition to filter rows. group_by_column (str): The column to group by. agg_func (dict): The aggregation functions for the grouping. Returns: None try: # Load the CSV file into a DataFrame df = pd.read_csv(input_csv) # Filter the DataFrame by the given condition df_filtered = df.query(filter_condition) # Group by the specified column and calculate aggregated values df_grouped = df_filtered.groupby(group_by_column).agg(agg_func) # Save the resulting DataFrame to a new CSV file df_grouped.to_csv(output_csv) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"def calculate_monthly_expenditure(transactions: list, month: str, year: int) -> dict: Calculate the total expenditure for each category in a given month and year. Parameters: transactions (list): A list of dictionaries representing transactions. month (str): The target month in the format \\"MM\\". year (int): The target year. Returns: dict: A dictionary where the keys are categories and the values are the total expenditure for each category in the given month. Sample Input: transactions = [ {\\"date\\": \\"2023-01-15\\", \\"amount\\": 100.0, \\"type\\": \\"debit\\", \\"category\\": \\"food\\"}, {\\"date\\": \\"2023-01-20\\", \\"amount\\": 150.0, \\"type\\": \\"debit\\", \\"category\\": \\"entertainment\\"}, {\\"date\\": \\"2023-02-10\\", \\"amount\\": 200.0, \\"type\\": \\"debit\\", \\"category\\": \\"utilities\\"}, {\\"date\\": \\"2023-01-30\\", \\"amount\\": 50.0, \\"type\\": \\"debit\\", \\"category\\": \\"food\\"}, {\\"date\\": \\"2023-01-25\\", \\"amount\\": 300.0, \\"type\\": \\"credit\\", \\"category\\": \\"salary\\"}, {\\"date\\": \\"2023-01-28\\", \\"amount\\": 20.0, \\"type\\": \\"debit\\", \\"category\\": \\"transport\\"} ] month = \\"01\\" year = 2023 Sample Output: { \\"food\\": 150.0, \\"entertainment\\": 150.0, \\"transport\\": 20.0 } >>> calculate_monthly_expenditure([ {\\"date\\": \\"2023-01-15\\", \\"amount\\": 100.0, \\"type\\": \\"debit\\", \\"category\\": \\"food\\"}, {\\"date\\": \\"2023-01-20\\", \\"amount\\": 150.0, \\"type\\": \\"debit\\", \\"category\\": \\"entertainment\\"}, {\\"date\\": \\"2023-02-10\\", \\"amount\\": 200.0, \\"type\\": \\"debit\\", \\"category\\": \\"utilities\\"}, {\\"date\\": \\"2023-01-30\\", \\"amount\\": 50.0, \\"type\\": \\"debit\\", \\"category\\": \\"food\\"}, {\\"date\\": \\"2023-01-25\\", \\"amount\\": 300.0, \\"type\\": \\"credit\\", \\"category\\": \\"salary\\"}, {\\"date\\": \\"2023-01-28\\", \\"amount\\": 20.0, \\"type\\": \\"debit\\", \\"category\\": \\"transport\\"} ], \\"01\\", 2023) { \\"food\\": 150.0, \\"entertainment\\": 150.0, \\"transport\\": 20.0 }","solution":"def calculate_monthly_expenditure(transactions: list, month: str, year: int) -> dict: Calculate the total expenditure for each category in the given month and year. Parameters: transactions (list): A list of transaction dictionaries. month (str): The target month in the format \\"MM\\". year (int): The target year. Returns: dict: A dictionary where keys are categories and values are the total expenditure for each category. expenditure = {} for transaction in transactions: date = transaction[\\"date\\"] trans_year, trans_month, _ = date.split(\\"-\\") trans_year = int(trans_year) trans_month = trans_month if trans_year == year and trans_month == month and transaction[\\"type\\"] == \\"debit\\": category = transaction[\\"category\\"] amount = transaction[\\"amount\\"] if category in expenditure: expenditure[category] += amount else: expenditure[category] = amount return expenditure"},{"question":"def longest_palindromic_substring(s: str) -> int: Returns the length of the longest palindromic substring within the input string s. The algorithm should be optimized to run in linear time using Manacher's algorithm. >>> longest_palindromic_substring(\\"babad\\") 3 >>> longest_palindromic_substring(\\"cbbd\\") 2 >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"ac\\") 1 def test_single_character_string(): assert longest_palindromic_substring(\\"a\\") == 1 def test_empty_string(): assert longest_palindromic_substring(\\"\\") == 0 def test_general_case1(): assert longest_palindromic_substring(\\"babad\\") == 3 # \\"bab\\" or \\"aba\\" def test_general_case2(): assert longest_palindromic_substring(\\"cbbd\\") == 2 # \\"bb\\" def test_general_case3(): assert longest_palindromic_substring(\\"abacdfgdcaba\\") == 3 # \\"aba\\" def test_palindrome_string(): assert longest_palindromic_substring(\\"racecar\\") == 7 # \\"racecar\\" def test_non_palindromic_string(): assert longest_palindromic_substring(\\"abcdefg\\") == 1 # \\"a\\" or any single character def test_with_special_characters(): assert longest_palindromic_substring(\\"a#b#c#d#c#b#a\\") == 13 # \\"a#b#c#d#c#b#a\\"","solution":"def longest_palindromic_substring(s): Returns the length of the longest palindromic substring within the input string s. The algorithm should be optimized to run in linear time using Manacher's algorithm. def preprocess_string(s): if not s: return \\"^\\" T = \\"^\\" for char in s: T += \\"#\\" + char T += \\"#\\" return T T = preprocess_string(s) n = len(T) P = [0] * n C = R = 0 for i in range(1, n - 1): i_mirror = 2 * C - i P[i] = (R > i) and min(R - i, P[i_mirror]) or 0 while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 if i + P[i] > R: C, R = i, i + P[i] max_len = max(P) return max_len"},{"question":"import random def roll_dice(num_dice, sides_per_die): Simulates the roll of multiple dice and returns the outcome in a summarized format. Parameters: num_dice (int): Number of dice to roll. sides_per_die (int): Number of sides on each die. Returns: dict: Dictionary where keys are outcomes and values are counts of each outcome. >>> roll_dice(1, 6) # Example output: {1: 0, 2: 0, 3: 1, 4: 0, 5: 0, 6: 0} >>> roll_dice(3, 6) # Example output: {1: 0, 2: 1, 3: 1, 4: 0, 5: 0, 6: 1} >>> roll_dice(5, 8) # Example output: {1: 1, 2: 0, 3: 1, 4: 0, 5: 0, 6: 1, 7: 1, 8: 1} if not isinstance(num_dice, int) or not isinstance(sides_per_die, int): raise ValueError(\\"Both num_dice and sides_per_die must be integers.\\") if num_dice <= 0 or sides_per_die <= 0: raise ValueError(\\"Both num_dice and sides_per_die must be positive integers.\\")","solution":"import random def roll_dice(num_dice, sides_per_die): Simulates the roll of multiple dice and returns the outcome in a summarized format. Parameters: num_dice (int): Number of dice to roll. sides_per_die (int): Number of sides on each die. Returns: dict: Dictionary where keys are outcomes and values are counts of each outcome. if not isinstance(num_dice, int) or not isinstance(sides_per_die, int): raise ValueError(\\"Both num_dice and sides_per_die must be integers.\\") if num_dice <= 0 or sides_per_die <= 0: raise ValueError(\\"Both num_dice and sides_per_die must be positive integers.\\") # Initialize the dictionary with all possible outcomes set to 0 outcome_counts = {i: 0 for i in range(1, sides_per_die + 1)} # Simulate the dice rolls for _ in range(num_dice): roll = random.randint(1, sides_per_die) outcome_counts[roll] += 1 return outcome_counts"},{"question":"def valid_bracket_sequence(s: str) -> bool: Determine whether the given string s is a valid sequence of brackets. A bracket sequence is considered valid if every open bracket has a corresponding closing bracket and the pairs are properly nested. :param s: String composed of brackets '()', '[]', '{}' :return: True if the sequence is valid, False otherwise >>> valid_bracket_sequence(\\"()\\") True >>> valid_bracket_sequence(\\"([{}])\\") True >>> valid_bracket_sequence(\\"(]\\") False >>> valid_bracket_sequence(\\"([)]\\") False from solution import valid_bracket_sequence def test_valid_simple_pairs(): assert valid_bracket_sequence(\\"()\\") == True assert valid_bracket_sequence(\\"[]\\") == True assert valid_bracket_sequence(\\"{}\\") == True def test_valid_nested_pairs(): assert valid_bracket_sequence(\\"([])\\") == True assert valid_bracket_sequence(\\"{[()]}\\") == True assert valid_bracket_sequence(\\"([{}])\\") == True def test_invalid_unmatched_pairs(): assert valid_bracket_sequence(\\"(]\\") == False assert valid_bracket_sequence(\\"([)]\\") == False assert valid_bracket_sequence(\\"({[}\\") == False def test_invalid_incomplete_pairs(): assert valid_bracket_sequence(\\"(\\") == False assert valid_bracket_sequence(\\"[\\") == False assert valid_bracket_sequence(\\"{\\") == False assert valid_bracket_sequence(\\"}\\") == False def test_empty_string(): assert valid_bracket_sequence(\\"\\") == True def test_invalid_characters(): assert valid_bracket_sequence(\\"abc\\") == False assert valid_bracket_sequence(\\"(abc)\\") == False assert valid_bracket_sequence(\\"([a])\\") == False assert valid_bracket_sequence(\\"{[()]}a\\") == False","solution":"def valid_bracket_sequence(s): Determine whether the given string s is a valid sequence of brackets. :param s: String composed of brackets '()', '[]', '{}' :return: True if the sequence is valid, False otherwise stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or bracket_map[char] != stack.pop(): return False else: # Invalid character return False return not stack"},{"question":"from typing import List, Tuple def shortest_path(adj_matrix: List[List[int]], start: int, end: int) -> Tuple[int, List[int]]: Uses Dijkstra's algorithm to find the shortest path in a weighted graph represented by an adjacency matrix from a start vertex to an end vertex. >>> adj_matrix = [ ... [0, 1, 4, 0], ... [0, 0, 2, 6], ... [0, 0, 0, 3], ... [0, 0, 0, 0] ... ] >>> shortest_path(adj_matrix, 0, 3) (6, [0, 1, 2, 3]) >>> adj_matrix = [ ... [0, 1, 4, 0], ... [0, 0, 2, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> shortest_path(adj_matrix, 0, 3) (float('inf'), []) >>> adj_matrix = [ ... [0] ... ] >>> shortest_path(adj_matrix, 0, 0) (0, [0]) >>> adj_matrix = [ ... [0, 10, 0, 30, 100], ... [0, 0, 50, 0, 0], ... [0, 0, 0, 0, 10], ... [0, 0, 20, 0, 60], ... [0, 0, 0, 0, 0] ... ] >>> shortest_path(adj_matrix, 0, 4) (60, [0, 3, 2, 4]) >>> adj_matrix = [ ... [0, 1, 1, 0, 0], ... [0, 0, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 0, 0, 0, 1], ... [0, 0, 0, 0, 0] ... ] >>> result = shortest_path(adj_matrix, 0, 4) >>> result == (3, [0, 1, 3, 4]) or result == (3, [0, 2, 3, 4]) True >>> adj_matrix = [ ... [0, 7, 9, 0, 0, 14], ... [7, 0, 10, 15, 0, 0], ... [9, 10, 0, 11, 0, 2], ... [0, 15, 11, 0, 6, 0], ... [0, 0, 0, 6, 0, 9], ... [14, 0, 2, 0, 9, 0] ... ] >>> shortest_path(adj_matrix, 0, 4) (20, [0, 2, 5, 4])","solution":"from typing import List, Tuple import heapq def shortest_path(adj_matrix: List[List[int]], start: int, end: int) -> Tuple[int, List[int]]: Uses Dijkstra's algorithm to find the shortest path in a weighted graph represented by an adjacency matrix from a start vertex to an end vertex. num_vertices = len(adj_matrix) dist = [float('inf')] * num_vertices dist[start] = 0 prev = [None] * num_vertices priority_queue = [(0, start)] while priority_queue: current_dist, current_vertex = heapq.heappop(priority_queue) if current_dist > dist[current_vertex]: continue for neighbor, weight in enumerate(adj_matrix[current_vertex]): if weight == 0: # There is no edge continue distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance prev[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path path = [] current = end while current is not None: path.insert(0, current) current = prev[current] if dist[end] == float('inf'): return (float('inf'), []) return (dist[end], path)"},{"question":"from typing import List, Dict def anonymize_users(users: List[Dict[str, str]]) -> List[Dict[str, str]]: Takes a list of user dictionaries and anonymizes their names, filters out minors, and adds a 'valid_email' field indicating if the email is valid. >>> users = [ {'id': 1, 'name': 'Alice', 'age': 25, 'email': 'alice@example.com'}, {'id': 2, 'name': 'Bob', 'age': 17, 'email': 'bob@example.com'}, {'id': 3, 'name': 'Carol', 'age': 19, 'email': 'carolexample.com'}, {'id': 4, 'name': 'Dave', 'age': 21, 'email': 'dave@example.c'}, ] >>> anonymize_users(users) [ {'id': 1, 'name': '*****', 'age': 25, 'email': 'alice@example.com', 'valid_email': True}, {'id': 3, 'name': '*****', 'age': 19, 'email': 'carolexample.com', 'valid_email': False}, {'id': 4, 'name': '****', 'age': 21, 'email': 'dave@example.c', 'valid_email': True} ] >>> anonymize_users([]) [] >>> users = [ {'id': 1, 'name': 'Alice', 'age': 15, 'email': 'alice@example.com'}, {'id': 2, 'name': 'Bob', 'age': 16, 'email': 'bob@example.com'} ] >>> anonymize_users(users) [] >>> users = [ {'id': 1, 'name': 'Eve', 'age': 22, 'email': 'eve@com'}, {'id': 2, 'name': 'Frank', 'age': 23, 'email': 'frank@example.c'}, ] >>> anonymize_users(users) [ {'id': 1, 'name': '***', 'age': 22, 'email': 'eve@com', 'valid_email': False}, {'id': 2, 'name': '*****', 'age': 23, 'email': 'frank@example.c', 'valid_email': True} ] pass","solution":"def anonymize_users(users): Takes a list of user dictionaries and anonymizes their names, filters out minors, and adds a 'valid_email' field indicating if the email is valid. def is_valid_email(email): if '@' in email and email.split('@')[1].count('.') >= 1: return True return False modified_users = [] for user in users: if user['age'] >= 18: user['name'] = '*' * len(user['name']) user['valid_email'] = is_valid_email(user['email']) modified_users.append(user) return modified_users"},{"question":"from typing import List, Tuple def min_travelling_distance(cities: List[str], distances: List[Tuple[str, str, int]], start_city: str) -> int: You are given a list of city names and their respective distances from each other. The distances are given as a list of tuples [city1, city2, distance], where distance represents the number of units between city1 and city2. You need to find the minimum total distance to visit all the given cities starting from a specific city. In case there's no way to visit all the cities return -1. >>> min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 4), (\\"C\\", \\"A\\", 3)], \\"A\\") 12 >>> min_travelling_distance([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"C\\", \\"D\\", 3), (\\"D\\", \\"A\\", 4)], \\"A\\") 10 >>> min_travelling_distance([\\"A\\", \\"B\\"], [(\\"A\\", \\"B\\", 6)], \\"A\\") 12 >>> min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 2)], \\"A\\") -1 pass def test_min_travelling_distance(): assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 4), (\\"C\\", \\"A\\", 3)], \\"A\\") == 12 assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"C\\", \\"D\\", 3), (\\"D\\", \\"A\\", 4)], \\"A\\") == 10 assert min_travelling_distance([\\"A\\", \\"B\\"], [(\\"A\\", \\"B\\", 6)], \\"A\\") == 12 assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 2)], \\"A\\") == -1 assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 2), (\\"B\\", \\"C\\", 2), (\\"C\\", \\"A\\", 2)], \\"A\\") == 6 assert min_travelling_distance([\\"A\\"], [], \\"A\\") == 0 assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2)], \\"A\\") == -1 assert min_travelling_distance([\\"A\\", \\"B\\", \\"C\\"], [(\\"A\\", \\"B\\", 7), (\\"A\\", \\"C\\", 10), (\\"B\\", \\"C\\", 5)], \\"C\\") == 22 # Run tests test_min_travelling_distance()","solution":"from typing import List, Tuple def min_travelling_distance(cities: List[str], distances: List[Tuple[str, str, int]], start_city: str) -> int: from itertools import permutations city_indices = {city: i for i, city in enumerate(cities)} n = len(cities) # Construct adjacency matrix dist_matrix = [[float('inf')] * n for _ in range(n)] for u, v, dist in distances: ui, vi = city_indices[u], city_indices[v] dist_matrix[ui][vi] = dist dist_matrix[vi][ui] = dist for i in range(n): dist_matrix[i][i] = 0 def calculate_path_length(path): length = 0 for i in range(len(path) - 1): if dist_matrix[path[i]][path[i+1]] == float('inf'): return float('inf') length += dist_matrix[path[i]][path[i+1]] # Return to the start city if dist_matrix[path[-1]][path[0]] == float('inf'): return float('inf') length += dist_matrix[path[-1]][path[0]] return length start_index = city_indices[start_city] min_distance = float('inf') for perm in permutations(range(n)): if perm[0] == start_index: distance = calculate_path_length(perm) if distance < min_distance: min_distance = distance return min_distance if min_distance != float('inf') else -1"},{"question":"def process_numbers(numbers): Processes a list of integers and returns two lists: one containing the square of all even numbers and another containing the cube of all odd numbers from the input list. Raises ValueError if any item in the list is not an integer. :param numbers: list of integers :return: tuple (list of squares of even numbers, list of cubes of odd numbers) import pytest from solution import process_numbers def test_process_numbers_valid_input(): even_squares, odd_cubes = process_numbers([1, 2, 3, 4, 5, 6]) assert even_squares == [4, 16, 36] assert odd_cubes == [1, 27, 125] def test_process_numbers_empty_list(): even_squares, odd_cubes = process_numbers([]) assert even_squares == [] assert odd_cubes == [] def test_process_numbers_all_even(): even_squares, odd_cubes = process_numbers([2, 4, 6]) assert even_squares == [4, 16, 36] assert odd_cubes == [] def test_process_numbers_all_odd(): even_squares, odd_cubes = process_numbers([1, 3, 5]) assert even_squares == [] assert odd_cubes == [1, 27, 125] def test_process_numbers_mixed_types(): with pytest.raises(ValueError, match=\\"All items in the list must be integers.\\"): process_numbers([1, 2, \\"three\\", 4]) def test_process_numbers_with_zero(): even_squares, odd_cubes = process_numbers([0, 1, 2]) assert even_squares == [0, 4] assert odd_cubes == [1]","solution":"def process_numbers(numbers): Processes a list of integers and returns two lists: one containing the square of all even numbers and another containing the cube of all odd numbers from the input list. Raises ValueError if any item in the list is not an integer. :param numbers: list of integers :return: tuple (list of squares of even numbers, list of cubes of odd numbers) if not all(isinstance(n, int) for n in numbers): raise ValueError(\\"All items in the list must be integers.\\") even_squares = [n**2 for n in numbers if n % 2 == 0] odd_cubes = [n**3 for n in numbers if n % 2 != 0] return even_squares, odd_cubes"},{"question":"def max_substring_sum(nums: List[int], k: int) -> int: Write a function \`max_substring_sum\` that accepts a list of integers and an integer \`k\`. The function should return the maximum sum of any contiguous subarray of length \`k\`. If the length of the list is less than \`k\`, the function should return \`None\`. >>> max_substring_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_substring_sum([1, 4, 2, 10], 5) None >>> max_substring_sum([5], 1) 5 >>> max_substring_sum([1, 2, 3, 4, 5], 5) 15 >>> max_substring_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_substring_sum([2, 1, 5, 1, 2, 9, -1, 4, -2], 4) 17 >>> max_substring_sum([3, 2, 5, 1, 1, 2], 3) 10 >>> max_substring_sum([0, 0, 0, 0], 2) 0","solution":"def max_substring_sum(nums, k): Returns the maximum sum of any contiguous subarray of length k. If the length of the list is less than k, the function returns None. if len(nums) < k: return None # Initial window sum max_sum = sum(nums[:k]) current_sum = max_sum # Slide the window over the rest of the array for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determines whether two given strings are anagrams of each other. Case-insensitive and ignores spaces. Args: s1: First string. s2: Second string. Returns: True if s1 and s2 are anagrams, False otherwise. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"Anagram\\", \\"nag a ram\\") True >>> are_anagrams(\\"The eyes\\", \\"They see\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"Hello\\", \\"World\\") False >>> are_anagrams(\\"test\\", \\"sets\\") False >>> are_anagrams(\\"anagram\\", \\"grammar\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"b\\") False >>> are_anagrams(\\"abc123\\", \\"321cba\\") True >>> are_anagrams(\\"abc123\\", \\"321cb!\\") False >>> are_anagrams(\\"!#@abc\\", \\"cba#@!\\") True","solution":"def are_anagrams(s1, s2): Determines whether two given strings are anagrams of each other. Case-insensitive and ignores spaces. Args: s1: First string. s2: Second string. Returns: True if s1 and s2 are anagrams, False otherwise. def normalize_string(s): return ''.join(char.lower() for char in s if char.isalnum()) normalized_s1 = normalize_string(s1) normalized_s2 = normalize_string(s2) if len(normalized_s1) != len(normalized_s2): return False count = {} for char in normalized_s1: if char in count: count[char] += 1 else: count[char] = 1 for char in normalized_s2: if char in count: count[char] -= 1 if count[char] == 0: del count[char] else: return False return len(count) == 0"},{"question":"from datetime import datetime, timedelta from typing import List class Book: def __init__(self, title: str, author: str, isbn: str, year_published: int): self.title = title self.author = author self.isbn = isbn self.year_published = year_published class DigitalLibrary: def __init__(self, maxLoanPeriod: int): self.books = [] self.maxLoanPeriod = maxLoanPeriod self.loanedBooks = {} def addBook(self, book: Book): This function takes a book object as an argument and adds it to the 'books' list. pass def loanBook(self, isbn: str) -> str: This function takes an 'isbn' as an argument, checks if the book is available (not already loaned out), and if so, adds it to 'loanedBooks' with a calculated due date based on 'maxLoanPeriod'. It returns a confirmation message including the due date. If the book is already loaned out, it prints an error message, \\"Book is already loaned out\\". pass def returnBook(self, isbn: str) -> str: This function takes an 'isbn' as an argument, checks if the book is in 'loanedBooks'. If so, it removes it from 'loanedBooks' and prints \\"Book returned successfully\\". If the book is not found, it prints \\"Book was not loaned out\\". pass def searchBookByTitle(self, title: str) -> List[Book]: This function takes a 'title' as an argument and prints out all books that match the title or partial title. pass import pytest from solution import Book, DigitalLibrary def test_addBook(): library = DigitalLibrary(maxLoanPeriod=14) book = Book('The Great Gatsby', 'F. Scott Fitzgerald', '1234567890', 1925) library.addBook(book) assert len(library.books) == 1 assert library.books[0].title == 'The Great Gatsby' def test_loanBook(): library = DigitalLibrary(maxLoanPeriod=14) book = Book('1984', 'George Orwell', '2345678901', 1949) library.addBook(book) response = library.loanBook('2345678901') assert 'Book loaned out. Due date is' in response assert '2345678901' in library.loanedBooks def test_loanBook_already_loaned(): library = DigitalLibrary(maxLoanPeriod=14) book = Book('To Kill a Mockingbird', 'Harper Lee', '3456789012', 1960) library.addBook(book) library.loanBook('3456789012') response = library.loanBook('3456789012') assert response == 'Book is already loaned out' def test_loanBook_not_found(): library = DigitalLibrary(maxLoanPeriod=14) response = library.loanBook('4567890123') assert response == 'Book not found in the library' def test_returnBook(): library = DigitalLibrary(maxLoanPeriod=14) book = Book('Moby Dick', 'Herman Melville', '5678901234', 1851) library.addBook(book) library.loanBook('5678901234') response = library.returnBook('5678901234') assert response == 'Book returned successfully' assert '5678901234' not in library.loanedBooks def test_returnBook_not_loaned(): library = DigitalLibrary(maxLoanPeriod=14) response = library.returnBook('6789012345') assert response == 'Book was not loaned out' def test_searchBookByTitle(): library = DigitalLibrary(maxLoanPeriod=14) book1 = Book('The Hobbit', 'J.R.R. Tolkien', '7890123456', 1937) book2 = Book('The Lord of the Rings', 'J.R.R. Tolkien', '8901234567', 1954) library.addBook(book1) library.addBook(book2) matches = library.searchBookByTitle('The') assert len(matches) == 2 assert matches[0].title == 'The Hobbit' assert matches[1].title == 'The Lord of the Rings' def test_searchBookByTitle_partial(): library = DigitalLibrary(maxLoanPeriod=14) book = Book('Alice in Wonderland', 'Lewis Carroll', '9012345678', 1865) library.addBook(book) matches = library.searchBookByTitle('Alice') assert len(matches) == 1 assert matches[0].title == 'Alice in Wonderland'","solution":"from datetime import datetime, timedelta class Book: def __init__(self, title, author, isbn, year_published): self.title = title self.author = author self.isbn = isbn self.year_published = year_published class DigitalLibrary: def __init__(self, maxLoanPeriod): self.books = [] self.maxLoanPeriod = maxLoanPeriod self.loanedBooks = {} def addBook(self, book): self.books.append(book) def loanBook(self, isbn): for book in self.books: if book.isbn == isbn: if isbn not in self.loanedBooks: due_date = datetime.now() + timedelta(days=self.maxLoanPeriod) self.loanedBooks[isbn] = due_date return f\\"Book loaned out. Due date is {due_date.strftime('%Y-%m-%d %H:%M:%S')}\\" else: return \\"Book is already loaned out\\" return \\"Book not found in the library\\" def returnBook(self, isbn): if isbn in self.loanedBooks: del self.loanedBooks[isbn] return \\"Book returned successfully\\" else: return \\"Book was not loaned out\\" def searchBookByTitle(self, title): matched_books = [book for book in self.books if title.lower() in book.title.lower()] return matched_books"},{"question":"def parse_log_file(file_path: str) -> dict: Parses a log file with network events and extracts relevant data. Args: file_path (str): The path to the log file. Returns: dict: Parsed log data. def summarize_log_data(parsed_data: dict): Summarizes the parsed log data and prints the results. Args: parsed_data (dict): Parsed log data. # Test cases def test_parse_log_file(): test_log_content = 2023-05-01 10:00:00, user1, LOGIN, Logged in from 192.168.1.1 2023-05-01 10:05:00, user2, LOGIN, Logged in from 192.168.1.2 2023-05-01 10:10:00, user1, LOGOUT, Logged out from 192.168.1.1 2023-05-01 10:20:00, user3, LOGIN, Logged in from 192.168.1.3 2023-05-01 10:30:00, user2, LOGOUT, Logged out from 192.168.1.2 2023-05-01 11:00:00, user3, LOGOUT, Logged out from 192.168.1.3 2023-05-01 11:05:00, user4, LOGIN, Logged in from 192.168.1.4 with open(\\"test_log.txt\\", \\"w\\") as file: file.write(test_log_content) parsed_data = parse_log_file(\\"test_log.txt\\") assert len(parsed_data[\\"unique_logins\\"]) == 4 # user1, user2, user3, user4 assert len(parsed_data[\\"unique_logouts\\"]) == 3 # user1, user2, user3 assert parsed_data[\\"simultaneously_logged_in\\"][-1] == 1 # At the end, only user4 is logged in os.remove(\\"test_log.txt\\") def test_summarize_log_data(capfd): parsed_data = { \\"unique_logins\\": {\\"user1\\", \\"user2\\", \\"user3\\", \\"user4\\"}, \\"unique_logouts\\": {\\"user1\\", \\"user2\\", \\"user3\\"}, \\"simultaneously_logged_in\\": [1, 2, 1, 2, 1, 1, 1] } summarize_log_data(parsed_data) captured = capfd.readouterr() assert \\"Total number of unique users who logged in: 4\\" in captured.out assert \\"Total number of unique users who logged out: 3\\" in captured.out assert \\"Max number of users simultaneously logged in: 2\\" in captured.out","solution":"def parse_log_file(file_path): Parses a log file with network events and extracts relevant data. Args: file_path (str): The path to the log file. Returns: dict: Parsed log data. from datetime import datetime logged_in_users = set() logged_out_users = set() currently_logged_in_users = set() parsed_data = { \\"unique_logins\\": logged_in_users, \\"unique_logouts\\": logged_out_users, \\"simultaneously_logged_in\\": [] } try: with open(file_path, 'r') as file: lines = file.readlines() for line in lines: try: timestamp, user_id, event_type, *detail_message = line.strip().split(', ') if event_type == \\"LOGIN\\": logged_in_users.add(user_id) currently_logged_in_users.add(user_id) elif event_type == \\"LOGOUT\\": logged_out_users.add(user_id) if user_id in currently_logged_in_users: currently_logged_in_users.remove(user_id) else: raise ValueError(f\\"Unknown event type: {event_type}\\") parsed_data[\\"simultaneously_logged_in\\"].append(len(currently_logged_in_users)) except ValueError as e: print(f\\"Error parsing line: {line.strip()} - {e}\\") except FileNotFoundError as e: print(f\\"File not found: {file_path} - {e}\\") return parsed_data def summarize_log_data(parsed_data): Summarizes the parsed log data and prints the results. Args: parsed_data (dict): Parsed log data. unique_logins = parsed_data[\\"unique_logins\\"] unique_logouts = parsed_data[\\"unique_logouts\\"] simultaneously_logged_in = parsed_data[\\"simultaneously_logged_in\\"] print(f\\"Total number of unique users who logged in: {len(unique_logins)}\\") print(f\\"Total number of unique users who logged out: {len(unique_logouts)}\\") print(f\\"Max number of users simultaneously logged in: {max(simultaneously_logged_in) if simultaneously_logged_in else 0}\\")"},{"question":"def convert_to_base(number: int, base: int) -> str: Converts a given decimal integer to its representation in a specified base (between 2 and 16). Parameters: number (int): The non-negative integer to be converted. base (int): The base to convert to. It should be between 2 and 16. Returns: str: The converted number as a string. Examples: >>> convert_to_base(345, 2) '101011001' >>> convert_to_base(345, 16) '159' >>> convert_to_base(345, 8) '531' import pytest def test_convert_to_base_binary(): assert convert_to_base(345, 2) == '101011001' def test_convert_to_base_hexadecimal(): assert convert_to_base(345, 16) == '159' def test_convert_to_base_octal(): assert convert_to_base(345, 8) == '531' def test_convert_to_base_minimum_base(): assert convert_to_base(345, 2) == '101011001' def test_convert_to_base_maximum_base(): assert convert_to_base(345, 16) == '159' def test_convert_zero(): assert convert_to_base(0, 2) == '0' assert convert_to_base(0, 16) == '0' def test_convert_to_base_invalid_base_low(): with pytest.raises(ValueError): convert_to_base(345, 1) def test_convert_to_base_invalid_base_high(): with pytest.raises(ValueError): convert_to_base(345, 17) def test_convert_negative_number(): with pytest.raises(ValueError): convert_to_base(-345, 10) def test_large_number_conversion(): assert convert_to_base(123456789, 16) == '75BCD15'","solution":"def convert_to_base(number: int, base: int) -> str: Converts a given decimal integer to its representation in a specified base (between 2 and 16). Parameters: number (int): The non-negative integer to be converted. base (int): The base to convert to. It should be between 2 and 16. Returns: str: The converted number as a string. if number < 0: raise ValueError(\\"The number must be non-negative.\\") if base < 2 or base > 16: raise ValueError(\\"The base must be between 2 and 16.\\") if number == 0: return \\"0\\" base_digits = \\"0123456789ABCDEF\\" result = [] while number > 0: remainder = number % base result.append(base_digits[remainder]) number //= base result.reverse() return ''.join(result)"},{"question":"def evaluate_expression(expression: str) -> int: Implement a function that takes a string representation of a mathematical expression and returns the evaluated result. The expression will only contain non-negative integers, addition ('+'), subtraction ('-'), multiplication ('*'), and division ('/'). The expression must handle operator precedence correctly. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-2\\") 8 >>> evaluate_expression(\\"4*5\\") 20 >>> evaluate_expression(\\"20/4\\") 5 >>> evaluate_expression(\\"3+5*2-10/2\\") 8 >>> evaluate_expression(\\"2*3+4\\") 10 >>> evaluate_expression(\\"10-4/2\\") 8 >>> evaluate_expression(\\"1+2*3-4/2\\") 5 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"100*2/4\\") 50 >>> evaluate_expression(\\"100+2*12/4\\") 106 >>> evaluate_expression(\\"1000000*2+500000\\") 2500000 >>> evaluate_expression(\\"999999+1\\") 1000000 >>> evaluate_expression(\\"999999999*2\\") 1999999998 >>> evaluate_expression(\\"4/1\\") 4 >>> evaluate_expression(\\"0+0\\") 0 >>> evaluate_expression(\\"3+0*5\\") 3 >>> evaluate_expression(\\"3*0+5\\") 5","solution":"def evaluate_expression(expression: str) -> int: def parse_term(expression, idx): num = 0 while idx < len(expression) and expression[idx].isdigit(): num = num * 10 + int(expression[idx]) idx += 1 return num, idx def apply_operator(left_val, operator, right_val): if operator == '+': return left_val + right_val elif operator == '-': return left_val - right_val elif operator == '*': return left_val * right_val elif operator == '/': return left_val // right_val def parse_expression(expression): idx = 0 current_val, idx = parse_term(expression, idx) while idx < len(expression): operator = expression[idx] idx += 1 next_val, idx = parse_term(expression, idx) if idx < len(expression): next_op = expression[idx] if next_op in '*/' and operator in '+-': while idx < len(expression) and next_op in '*/': next_operator = next_op idx += 1 further_val, idx = parse_term(expression, idx) next_val = apply_operator(next_val, next_operator, further_val) if idx < len(expression): next_op = expression[idx] current_val = apply_operator(current_val, operator, next_val) return current_val return parse_expression(expression)"},{"question":"from collections import OrderedDict from threading import RLock import random class ScalableCache: A scalable, thread-safe cache system that supports different cache replacement policies (LRU, LFU, random). Attributes: capacity (int): Maximum capacity of the cache. policy (str): Cache replacement policy to be used ('LRU', 'LFU', or 'random'). def __init__(self, capacity: int, policy: str = 'LRU'): self.capacity = capacity self.policy = policy self.lock = RLock() if policy == 'LRU' or policy == 'LFU': self.cache = OrderedDict() else: self.cache = {} if policy == 'LFU': self.access_counts = {} def get(self, key: str): Retrieve an item from the cache. Updates the cache policy state as needed. Args: key (str): Key for the item to be retrieved. Returns: The value associated with the key, or None if the key is not in the cache. pass # Implement your logic here def put(self, key: str, value): Add an item to the cache. Evicts an item if the cache is full according to the policy. Args: key (str): Key for the item to be added. value: The value to be associated with the key. pass # Implement your logic here def evict(self): Evict an item from the cache according to the cache policy. pass # Implement your logic here # Unit Tests def test_lru_cache(): cache = ScalableCache(2, 'LRU') cache.put('a', 1) cache.put('b', 2) assert cache.get('a') == 1 # 'a' becomes recently used cache.put('c', 3) assert cache.get('b') is None # 'b' should be evicted assert cache.get('a') == 1 assert cache.get('c') == 3 def test_lfu_cache(): cache = ScalableCache(2, 'LFU') cache.put('a', 1) cache.put('b', 2) assert cache.get('a') == 1 assert cache.get('a') == 1 # 'a' frequency increased cache.put('c', 3) assert cache.get('b') is None # 'b' should be evicted because 'a' has higher frequency assert cache.get('c') == 3 def test_random_replacement_cache(): cache = ScalableCache(2, 'random') cache.put('a', 1) cache.put('b', 2) # Adding a third item, one of 'a' or 'b' must be evicted cache.put('c', 3) assert sum(x is not None for x in (cache.get('a'), cache.get('b'), cache.get('c'))) == 2 def test_thread_safe(): import threading cache = ScalableCache(2, 'LRU') def worker_put(key, value): cache.put(key, value) def worker_get(key): return cache.get(key) threads = [] # Create threads for putting items in the cache for i in range(5): t = threading.Thread(target=worker_put, args=(f'key{i}', i)) threads.append(t) t.start() for t in threads: t.join() # Check final state, as we exceeded capacity only 2 items should be present assert len(cache.cache) == 2 def test_put_and_get(): cache = ScalableCache(2, 'LRU') cache.put('a', 1) cache.put('b', 2) cache.put('a', 2) # Update value of 'a' assert cache.get('a') == 2 # Updated value assert cache.get('b') == 2","solution":"from collections import OrderedDict from threading import Lock, RLock import random class ScalableCache: def __init__(self, capacity: int, policy: str = 'LRU'): self.capacity = capacity self.policy = policy self.lock = RLock() if policy == 'LRU' or policy == 'LRU': self.cache = OrderedDict() elif policy == 'LFU': self.cache = {} self.access_counts = {} else: self.cache = {} def get(self, key: str): with self.lock: if key not in self.cache: return None if self.policy == 'LRU': self.cache.move_to_end(key) elif self.policy == 'LFU': self.access_counts[key] += 1 return self.cache[key] def put(self, key: str, value): with self.lock: if len(self.cache) >= self.capacity: self.evict() self.cache[key] = value if self.policy == 'LRU': self.cache.move_to_end(key) elif self.policy == 'LFU': self.access_counts[key] = self.access_counts.get(key, 0) + 1 def evict(self): if self.policy == 'LRU': self.cache.popitem(last=False) elif self.policy == 'LFU': lfu_key = min(self.access_counts, key=self.access_counts.get) self.cache.pop(lfu_key) self.access_counts.pop(lfu_key) else: # Random Replacement random_key = random.choice(list(self.cache.keys())) self.cache.pop(random_key) # Example usage: # cache = ScalableCache(3, 'LRU') # cache.put('a', 1) # cache.put('b', 2) # print(cache.get('a')) # Outputs 1 # cache.put('c', 3) # cache.put('d', 4) # print(cache.get('b')) # Outputs None, as 'b' would be evicted in an LRU cache"},{"question":"def find_common_elements(list1, list2): Write a Python function that takes two lists of integers as input and returns a list containing the elements that are present in both lists. Your function should handle lists of different lengths and should not include duplicate elements in the result. >>> find_common_elements([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) == [4, 5] >>> find_common_elements([1, 2, 3], [4, 5, 6]) == [] >>> find_common_elements([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_common_elements_with_duplicates(): list1 = [1, 2, 3, 4, 5] list2 = [4, 4, 5, 6, 7, 8] assert sorted(find_common_elements(list1, list2)) == [4, 5] def test_common_elements_no_duplicates(): list1 = [1, 3, 5, 7] list2 = [2, 3, 5, 6] assert sorted(find_common_elements(list1, list2)) == [3, 5] def test_no_common_elements(): list1 = [1, 2, 3] list2 = [4, 5, 6] assert find_common_elements(list1, list2) == [] def test_empty_lists(): list1 = [] list2 = [] assert find_common_elements(list1, list2) == [] def test_one_empty_list(): list1 = [1, 2, 3] list2 = [] assert find_common_elements(list1, list2) == [] def test_identical_lists(): list1 = [1, 2, 3] list2 = [1, 2, 3] assert sorted(find_common_elements(list1, list2)) == [1, 2, 3] def test_lists_with_negative_numbers(): list1 = [-1, 2, -3, 4, 5] list2 = [4, -1, -6, 7, 8] assert sorted(find_common_elements(list1, list2)) == [-1, 4]","solution":"def find_common_elements(list1, list2): Returns a list containing the elements that are present in both list1 and list2, without duplicates. # Convert both lists to sets to remove duplicates and find common elements set1 = set(list1) set2 = set(list2) # Find the intersection of both sets common_elements = set1.intersection(set2) # Convert the set of common elements back to a list return list(common_elements)"},{"question":"class Graph: def __init__(self, n): Initialize the graph with n vertices. self.parent = list(range(n+1)) self.value = [0] * (n + 1) self.component_sum = [0] * (n + 1) def find(self, u): Find the root of vertex u. if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): Union the components of vertices u and v. root_u = self.find(u) root_v = self.find(v) if root_u != root_v: self.parent[root_v] = root_u self.component_sum[root_u] += self.component_sum[root_v] def add_value(self, x, y): Add value y to vertex x. root_x = self.find(x) self.value[x] += y self.component_sum[root_x] += y def get_component_sum(self, x): Retrieve the sum of values in the component containing vertex x. root_x = self.find(x) return self.component_sum[root_x] def process_operations(n, edges, operations): Perform the operations on the graph and return the results of sum queries. >>> process_operations(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 1, 10), (2, 2), (1, 3, 5), (2, 4), (1, 5, 7), (2, 1)]) [10, 15, 22] >>> process_operations(6, [(1, 2), (3, 4), (5, 6)], [(1, 1, 10), (2, 1), (1, 3, 5), (2, 3)]) [10, 5] graph = Graph(n) for u, v in edges: graph.union(u, v) result = [] for operation in operations: if operation[0] == 1: _, x, y = operation graph.add_value(x, y) elif operation[0] == 2: _, x = operation result.append(graph.get_component_sum(x)) return result def test_add_to_vertex(): graph = Graph(5) graph.add_value(1, 10) assert graph.value[1] == 10 assert graph.get_component_sum(1) == 10 def test_union_components(): graph = Graph(5) graph.add_value(1, 10) graph.union(1, 2) assert graph.get_component_sum(2) == 10 def test_connected_component_queries(): n, m, k = 5, 4, 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] operations = [(1, 1, 10), (2, 2), (1, 3, 5), (2, 4), (1, 5, 7), (2, 1)] result = process_operations(n, edges, operations) assert result == [10, 15, 22] def test_disconnected_components(): n, m, k = 6, 3, 4 edges = [(1, 2), (3, 4), (5, 6)] operations = [(1, 1, 10), (2, 1), (1, 3, 5), (2, 3)] result = process_operations(n, edges, operations) assert result == [10, 5]","solution":"class Graph: def __init__(self, n): self.parent = list(range(n+1)) self.value = [0] * (n + 1) self.component_sum = [0] * (n + 1) def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: self.parent[root_v] = root_u self.component_sum[root_u] += self.component_sum[root_v] def add_value(self, x, y): root_x = self.find(x) self.value[x] += y self.component_sum[root_x] += y def get_component_sum(self, x): root_x = self.find(x) return self.component_sum[root_x] def process_operations(n, edges, operations): graph = Graph(n) for u, v in edges: graph.union(u, v) result = [] for operation in operations: if operation[0] == 1: _, x, y = operation graph.add_value(x, y) elif operation[0] == 2: _, x = operation result.append(graph.get_component_sum(x)) return result"},{"question":"import math class TaxiDispatch: def __init__(self): Initialize the TaxiDispatch system with an empty dictionary of drivers. pass def add_driver(self, driver_id: str, location: tuple): Add a new driver to the system with their ID and location. Args: driver_id: A unique identifier for the driver. location: A tuple representing the driver's location in (latitude, longitude). >>> dispatch = TaxiDispatch() >>> dispatch.add_driver('driver1', (37.7749, -122.4194)) >>> 'driver1' in dispatch.drivers True pass def remove_driver(self, driver_id: str): Remove a driver from the system based on their ID. Args: driver_id: A unique identifier for the driver. >>> dispatch = TaxiDispatch() >>> dispatch.add_driver('driver1', (37.7749, -122.4194)) >>> dispatch.remove_driver('driver1') >>> 'driver1' not in dispatch.drivers True pass def haversine_distance(self, loc1: tuple, loc2: tuple) -> float: Calculate the Haversine distance between two geographic locations. Args: loc1: A tuple representing the first location (latitude, longitude). loc2: A tuple representing the second location (latitude, longitude). Returns: The distance in kilometers between the two locations. >>> dispatch = TaxiDispatch() >>> loc1 = (37.7749, -122.4194) # San Francisco >>> loc2 = (34.0522, -118.2437) # Los Angeles >>> abs(dispatch.haversine_distance(loc1, loc2) - 559.234) < 1 True pass def assign_ride_request(self, ride_location: tuple) -> str: Assign an incoming ride request to the nearest available driver. Args: ride_location: A tuple representing the ride's location in (latitude, longitude). Returns: The ID of the closest driver, or None if no drivers are available. >>> dispatch = TaxiDispatch() >>> dispatch.add_driver('driver1', (37.7749, -122.4194)) # San Francisco >>> dispatch.add_driver('driver2', (34.0522, -118.2437)) # Los Angeles >>> dispatch.assign_ride_request((35.0522, -119.2437)) == 'driver2' True >>> 'driver2' not in dispatch.drivers True pass","solution":"from math import radians, cos, sin, sqrt, atan2 class TaxiDispatch: def __init__(self): self.drivers = {} def add_driver(self, driver_id, location): self.drivers[driver_id] = location def remove_driver(self, driver_id): if driver_id in self.drivers: del self.drivers[driver_id] def haversine_distance(self, loc1, loc2): R = 6371 # Radius of the Earth in kilometers lat1, lon1 = loc1 lat2, lon2 = loc2 dlat = radians(lat2 - lat1) dlon = radians(lon2 - lon1) a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2 c = 2 * atan2(sqrt(a), sqrt(1 - a)) distance = R * c return distance def assign_ride_request(self, ride_location): closest_driver = None shortest_distance = float('inf') for driver_id, driver_location in self.drivers.items(): distance = self.haversine_distance(ride_location, driver_location) if distance < shortest_distance: shortest_distance = distance closest_driver = driver_id if closest_driver: self.remove_driver(closest_driver) return closest_driver"},{"question":"def process_integers(integers) -> tuple: Processes a list of integers and returns a tuple: - A list of all positive integers sorted in ascending order. - The product of all negative integers. Parameters: integers (list): A list of integers. Returns: tuple: A tuple with a sorted list of positive integers and the product of negative integers. if not integers: return ([], 0) positives = sorted([num for num in integers if num > 0]) negatives = [num for num in integers if num < 0] negative_product = 1 for num in negatives: negative_product *= num return (positives, negative_product if negatives else 0) # Test Cases def test_process_integers_mixed_values(): result = process_integers([1, -2, 3, -4, 5]) assert result == ([1, 3, 5], 8) def test_process_integers_no_negatives(): result = process_integers([1, 2, 3, 4, 5]) assert result == ([1, 2, 3, 4, 5], 0) def test_process_integers_no_positives(): result = process_integers([-1, -2, -3, -4, -5]) assert result == ([], -120) def test_process_integers_empty_list(): result = process_integers([]) assert result == ([], 0) def test_process_integers_no_pos_no_neg(): result = process_integers([0, 0, 0]) assert result == ([], 0) def test_process_integers_all_zeros(): result = process_integers([0, 0, 0, 0]) assert result == ([], 0) def test_process_integers_mixed_zeros(): result = process_integers([-1, 0, 3, 0, -2, 5]) assert result == ([3, 5], 2)","solution":"def process_integers(integers): Processes a list of integers and returns a tuple: - A list of all positive integers sorted in ascending order. - The product of all negative integers. Parameters: integers (list): A list of integers. Returns: tuple: A tuple with a sorted list of positive integers and the product of negative integers. if not integers: return ([], 0) positives = sorted([num for num in integers if num > 0]) negatives = [num for num in integers if num < 0] negative_product = 1 for num in negatives: negative_product *= num if not negatives: negative_product = 0 return (positives, negative_product)"},{"question":"def minDeliveryTrips(weights: List[int], W: int) -> int: Calculate the minimum number of delivery trips for the drone to deliver all packages. :param weights: List[int] - list of weights of the packages :param W: int - maximum weight the drone can carry in a single trip :return: int - minimum number of trips required >>> minDeliveryTrips([5], 10) 1 >>> minDeliveryTrips([5, 3, 2], 10) 1 >>> minDeliveryTrips([5, 3, 4, 2, 8], 10) 3 >>> minDeliveryTrips([5, 5, 5], 10) 2 >>> minDeliveryTrips([2, 2, 2, 2, 2], 10) 1 >>> minDeliveryTrips([8, 8, 8], 10) 3 >>> minDeliveryTrips([15, 10, 10, 5], 20) 2","solution":"from typing import List def minDeliveryTrips(weights: List[int], W: int) -> int: Calculate the minimum number of delivery trips for the drone to deliver all packages. :param weights: List[int] - list of weights of the packages :param W: int - maximum weight the drone can carry in a single trip :return: int - minimum number of trips required weights.sort(reverse=True) trips = 0 while weights: trips += 1 current_weight = 0 for i in range(len(weights)): if current_weight + weights[i] <= W: current_weight += weights[i] weights[i] = 0 weights = [weight for weight in weights if weight > 0] return trips"},{"question":"class StudentGrades: Manage a dictionary of student names and their corresponding grades. add_student(self, name: str, grade: Union[int, float, str]) -> None: This method takes a student name and grade and adds it to the dictionary. Handles invalid grades as well. compute_average(self) -> float: Computes and returns the average grade of all students. Handles cases with no students or invalid grades. get_student_grade(self, name: str) -> Optional[float]: Takes a student name as input and returns the student's grade if they exist in the dictionary, else None. >>> sg = StudentGrades() >>> sg.add_student('Alice', 85) >>> sg.add_student('Bob', 92) >>> sg.add_student('Charlie', 'Invalid') >>> sg.add_student('Jane', 100) >>> sg.get_student_grade('Alice') 85 >>> sg.get_student_grade('Eve') None >>> abs(sg.compute_average() - 92.33) < 0.01 True def __init__(self): self.students = {} def add_student(self, name, grade): pass def compute_average(self): pass def get_student_grade(self, name): pass def test_add_student(): sg = StudentGrades() sg.add_student('Alice', 85) sg.add_student('Bob', 92) sg.add_student('Charlie', 'Invalid') sg.add_student('Diana', 76) assert sg.get_student_grade('Alice') == 85 assert sg.get_student_grade('Bob') == 92 assert sg.get_student_grade('Charlie') is None assert sg.get_student_grade('Diana') == 76 def test_compute_average(): sg = StudentGrades() sg.add_student('Alice', 85) sg.add_student('Bob', 92) sg.add_student('Charlie', 'Invalid') sg.add_student('Diana', 76) average = sg.compute_average() assert abs(average - 84.33) < 0.01 def test_compute_average_no_students(): sg = StudentGrades() average = sg.compute_average() assert average == 0 def test_get_student_grade(): sg = StudentGrades() sg.add_student('Alice', 85) sg.add_student('Bob', 92) assert sg.get_student_grade('Bob') == 92 assert sg.get_student_grade('Eve') is None","solution":"class StudentGrades: def __init__(self): self.students = {} def add_student(self, name, grade): try: grade = float(grade) self.students[name] = grade except ValueError: pass # Invalid grade ignored def compute_average(self): valid_grades = [grade for grade in self.students.values() if isinstance(grade, (int, float))] if valid_grades: return sum(valid_grades) / len(valid_grades) return 0 def get_student_grade(self, name): return self.students[name] if name in self.students else None"},{"question":"import csv import logging # Configure logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') def calculate_average_price(csv_filename, column_name='price'): Reads an entire CSV file, processes the data, and finds the average value of a specified column. Handles missing or malformed data gracefully by skipping over invalid entries and logging the issue for debug purposes. Args: csv_filename (str): The path to the CSV file. column_name (str): The name of the column to calculate the average value for (default is 'price'). Returns: float: The average value of the specified column. Raises: ValueError: If no valid entries are found for the specified column. >>> calculate_average_price(\\"test.csv\\") 0.7125 >>> calculate_average_price(\\"test.csv\\", column_name='quantity') 11.0 total_price = 0.0 valid_entries = 0 with open(csv_filename, mode='r') as csvfile: csvreader = csv.DictReader(csvfile) for row in csvreader: try: price = float(row[column_name]) total_price += price valid_entries += 1 except (ValueError, KeyError) as e: logging.debug(f\\"Skipping row due to error: {e} - Row data: {row}\\") if valid_entries == 0: raise ValueError(\\"No valid entries found for the specified column\\") average_price = total_price / valid_entries return average_price if __name__ == \\"__main__\\": import pytest from solution import calculate_average_price import os # Helper function to create a temporary CSV file def create_temp_csv(content, filename): with open(filename, 'w') as f: f.write(content) @pytest.fixture def test_csv_file(tmp_path): content = id,product,price,quantity 1,apple,0.50,10 2,orange,0.75,5 3,banana,,8 4,pear,1.00,12 5,grape,malformed,15 6,apple,0.60, filename = os.path.join(tmp_path, 'test.csv') create_temp_csv(content, filename) return filename def test_calculate_average_price(test_csv_file): assert calculate_average_price(test_csv_file) == pytest.approx(0.7125) def test_empty_column_name(test_csv_file): with pytest.raises(ValueError): calculate_average_price(test_csv_file, column_name='') def test_invalid_column_name(test_csv_file): with pytest.raises(ValueError): calculate_average_price(test_csv_file, column_name='nonexistent_column')","solution":"import csv import logging # Configure logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') def calculate_average_price(csv_filename, column_name='price'): total_price = 0.0 valid_entries = 0 with open(csv_filename, mode='r') as csvfile: csvreader = csv.DictReader(csvfile) for row in csvreader: try: price = float(row[column_name]) total_price += price valid_entries += 1 except (ValueError, KeyError) as e: logging.debug(f\\"Skipping row due to error: {e} - Row data: {row}\\") if valid_entries == 0: raise ValueError(\\"No valid entries found for the specified column\\") average_price = total_price / valid_entries return average_price"},{"question":"import pandas as pd def process_large_csv(input_file, output_file, column_name, condition): Processes a large CSV file in chunks, filtering rows where a specific column meets a given condition, and writes the filtered results to a new CSV file. :param input_file: Path to the input CSV file. :param output_file: Path to the output CSV file. :param column_name: The name of the column to apply the filter condition on. :param condition: A function that takes a single argument and returns True if the row should be kept, otherwise False. pass # Test cases def test_process_large_csv(): import os # Create a sample large CSV file for testing data = { 'target_column': list(range(1000000)), 'other_column': ['text'] * 1000000 } df = pd.DataFrame(data) df.to_csv('large_input.csv', index=False) try: process_large_csv('large_input.csv', 'filtered_output.csv', 'target_column', lambda x: x > 500000) # Verify the results filtered_df = pd.read_csv('filtered_output.csv') assert not filtered_df.empty assert all(filtered_df['target_column'] > 500000) finally: try: os.remove('large_input.csv') os.remove('filtered_output.csv') except FileNotFoundError: pass","solution":"import pandas as pd def process_large_csv(input_file, output_file, column_name, condition): Processes a large CSV file in chunks, filtering rows where a specific column meets a given condition, and writes the filtered results to a new CSV file. :param input_file: Path to the input CSV file. :param output_file: Path to the output CSV file. :param column_name: The name of the column to apply the filter condition on. :param condition: A function that takes a single argument and returns True if the row should be kept, otherwise False. chunk_size = 100000 # Number of rows per chunk (adjust as necessary) try: # Initialize the writing of the output CSV file first_chunk = True for chunk in pd.read_csv(input_file, chunksize=chunk_size): # Apply the filter condition to the chunk filtered_chunk = chunk[chunk[column_name].apply(condition)] # Write the filtered chunk to the output CSV file if first_chunk: filtered_chunk.to_csv(output_file, mode='w', index=False) first_chunk = False else: filtered_chunk.to_csv(output_file, mode='a', index=False, header=False) except Exception as e: print(f\\"An error occurred: {e}\\") # Function usage example: # process_large_csv('large_input.csv', 'filtered_output.csv', 'target_column', lambda x: x > 0)"},{"question":"from typing import List, Dict, Any def advanced_string_manipulation_and_analysis(s: str, actions: List[Dict[str, Any]]) -> List[str]: The function processes a given string \`s\` and applies a series of actions (transformations and analyses) defined in the \`actions\` list. Each action is a dictionary that specifies the type of operation to be done, parameters for that operation, and conditions under which the operation should be performed. Possible action types include: 1. \`substring_count\`: Count occurrences of a substring within the string and append the count to the result list. 2. \`substring_replace\`: Replace all occurrences of a substring with another substring if a specified condition is met. 3. \`cipher_shift\`: Shift all characters in the string by a given number according to the Caesar cipher. 4. \`find_anagrams\`: Find all anagrams of a given word within the string (consider spaces or special characters) and return their positions. 5. \`word_frequency\`: Calculate the frequency of each word in the string and append the result as a dictionary. 6. \`pattern_match\`: Identify and return the start indices of all matches of a given regex pattern in the string. The transformations should be applied to the string consecutively. Analysis actions only append their results to a separate list. The function must handle edge cases like empty strings, invalid action types, and unfound substrings gracefully and must raise an appropriate error for any invalid input. Example: >>> actions = [ >>> {\\"type\\": \\"substring_count\\", \\"value\\": \\"hello\\"}, >>> {\\"type\\": \\"substring_replace\\", \\"from\\": \\"world\\", \\"to\\": \\"everyone\\", \\"if_contains\\": \\"!\\"}, >>> {\\"type\\": \\"cipher_shift\\", \\"shift\\": 5}, >>> {\\"type\\": \\"find_anagrams\\", \\"word\\": \\"write\\"}, >>> {\\"type\\": \\"word_frequency\\"}, >>> {\\"type\\": \\"pattern_match\\", \\"pattern\\": r\\"bd{3}b\\"} >>> ] >>> advanced_string_manipulation_and_analysis(\\"hello world! 123 321 write\\", actions) [\\"substring_count: 1\\", \\"cipher_shift: mjqqt btwqi! 678 876 bwnyj\\", \\"find_anagrams: [13]\\", \\"word_frequency: {'hello': 1, 'world': 1, '123': 1, '321': 1, 'write': 1}\\", \\"pattern_match: [10, 14]\\"]","solution":"from typing import List, Dict, Any import re from collections import Counter def caesar_cipher(s: str, shift: int) -> str: result = [] for char in s: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') result.append(chr((ord(char) - shift_base + shift) % 26 + shift_base)) else: result.append(char) return ''.join(result) def find_anagrams_positions(s: str, word: str) -> List[int]: from collections import Counter word_len = len(word) word_counter = Counter(word) current_counter = Counter(s[:word_len-1]) result = [] for i in range(word_len-1, len(s)): current_counter[s[i]] += 1 if current_counter == word_counter: result.append(i - word_len + 1) current_counter[s[i - word_len + 1]] -= 1 if current_counter[s[i - word_len + 1]] == 0: del current_counter[s[i - word_len + 1]] return result def advanced_string_manipulation_and_analysis(s: str, actions: List[Dict[str, Any]]) -> List[str]: results = [] for action in actions: action_type = action.get(\\"type\\") if action_type == \\"substring_count\\": substring = action.get(\\"value\\", \\"\\") count = s.count(substring) results.append(f\\"substring_count: {count}\\") elif action_type == \\"substring_replace\\": if_contains = action.get(\\"if_contains\\", \\"\\") if if_contains in s: s = s.replace(action.get(\\"from\\", \\"\\"), action.get(\\"to\\", \\"\\")) elif action_type == \\"cipher_shift\\": shift = action.get(\\"shift\\", 0) s = caesar_cipher(s, shift) results.append(f\\"cipher_shift: {s}\\") elif action_type == \\"find_anagrams\\": word = action.get(\\"word\\", \\"\\") positions = find_anagrams_positions(s, word) results.append(f\\"find_anagrams: {positions}\\") elif action_type == \\"word_frequency\\": words = re.findall(r'bw+b', s) frequency = Counter(words) results.append(f\\"word_frequency: {dict(frequency)}\\") elif action_type == \\"pattern_match\\": pattern = action.get(\\"pattern\\", \\"\\") matches = [m.start() for m in re.finditer(pattern, s)] results.append(f\\"pattern_match: {matches}\\") else: raise ValueError(f\\"Invalid action type: {action_type}\\") return results"},{"question":"class Inventory: Simulates the inventory system of a small store. Your program should be able to add new items, update the quantity of existing items, and remove items that have a quantity of zero. Each item has a name (string) and a quantity (integer). Ensure your program provides meaningful error messages for invalid operations, such as attempting to remove a non-existent item or updating an item with a negative quantity. def __init__(self): self.items = {} def add_item(self, name, quantity): Adds a new item or updates the quantity of an existing item. :param name: str - The name of the item. :param quantity: int - The quantity of the item to add. :raises ValueError: If the quantity is negative. pass def update_quantity(self, name, quantity): Updates the quantity of an existing item. :param name: str - The name of the item. :param quantity: int - The quantity to add (positive) or remove (negative). :raises KeyError: If the item does not exist. :raises ValueError: If the resulting quantity is negative. pass def remove_item(self, name): Removes an item from the inventory. :param name: str - The name of the item. :raises KeyError: If the item does not exist. pass def get_inventory(self): Returns the current inventory. :return: dict - A dictionary of item names and their quantities. pass # Unit tests import pytest @pytest.fixture def inventory(): return Inventory() def test_add_item_new(inventory): inventory.add_item(\\"apple\\", 10) assert inventory.get_inventory() == {\\"apple\\": 10} def test_add_item_existing(inventory): inventory.add_item(\\"apple\\", 10) inventory.add_item(\\"apple\\", 5) assert inventory.get_inventory() == {\\"apple\\": 15} def test_add_item_negative_quantity(inventory): with pytest.raises(ValueError, match=\\"Quantity cannot be negative\\"): inventory.add_item(\\"apple\\", -5) def test_update_quantity_existing(inventory): inventory.add_item(\\"apple\\", 10) inventory.update_quantity(\\"apple\\", -3) assert inventory.get_inventory() == {\\"apple\\": 7} def test_update_quantity_nonexistent(inventory): with pytest.raises(KeyError, match=\\"Item 'apple' does not exist in inventory\\"): inventory.update_quantity(\\"apple\\", 5) def test_update_quantity_to_negative(inventory): inventory.add_item(\\"apple\\", 10) with pytest.raises(ValueError, match=\\"Cannot update 'apple' to a negative quantity\\"): inventory.update_quantity(\\"apple\\", -11) def test_update_quantity_to_zero(inventory): inventory.add_item(\\"apple\\", 10) inventory.update_quantity(\\"apple\\", -10) assert inventory.get_inventory() == {} def test_remove_item_existing(inventory): inventory.add_item(\\"apple\\", 10) inventory.remove_item(\\"apple\\") assert inventory.get_inventory() == {} def test_remove_item_nonexistent(inventory): with pytest.raises(KeyError, match=\\"Item 'apple' does not exist in inventory\\"): inventory.remove_item(\\"apple\\")","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, quantity): if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") if name in self.items: self.items[name] += quantity else: self.items[name] = quantity def update_quantity(self, name, quantity): if name not in self.items: raise KeyError(f\\"Item '{name}' does not exist in inventory\\") if self.items[name] + quantity < 0: raise ValueError(f\\"Cannot update '{name}' to a negative quantity\\") self.items[name] += quantity if self.items[name] == 0: del self.items[name] def remove_item(self, name): if name not in self.items: raise KeyError(f\\"Item '{name}' does not exist in inventory\\") del self.items[name] def get_inventory(self): return self.items"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): Merges two sorted linked lists into one sorted linked list. :param l1: ListNode, head of the first sorted linked list :param l2: ListNode, head of the second sorted linked list :return: ListNode, head of the merged sorted linked list def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def test_merge_two_sorted_lists(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3, 4]) merged_list = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 1, 2, 3, 4, 4] def test_merge_with_empty_list(): l1 = list_to_linked_list([]) l2 = list_to_linked_list([0]) merged_list = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged_list) == [0] def test_merge_two_empty_lists(): l1 = list_to_linked_list([]) l2 = list_to_linked_list([]) merged_list = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged_list) == [] def test_merge_with_one_element_each(): l1 = list_to_linked_list([2]) l2 = list_to_linked_list([1]) merged_list = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 2] def test_merge_with_identical_elements(): l1 = list_to_linked_list([2, 2]) l2 = list_to_linked_list([2, 2]) merged_list = merge_two_sorted_lists(l1, l2) assert linked_list_to_list(merged_list) == [2, 2, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): Merges two sorted linked lists into one sorted linked list. :param l1: ListNode, head of the first sorted linked list :param l2: ListNode, head of the second sorted linked list :return: ListNode, head of the merged sorted linked list dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next # Computational complexity: # The time complexity of this algorithm is O(n + m) where n and m are the lengths of the two linked lists. # The space complexity is O(1) because we are only using a few extra pointers."},{"question":"from collections import OrderedDict class LRUCache: Implement the LRU (Least Recently Used) cache eviction policy. The cache supports the following operations: - put(key, value): Sets or inserts the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. - get(key): Returns the value if the key exists in the cache, otherwise returns -1. Both operations should be performed in O(1) time complexity, and the cache should be able to handle up to 10^5 operations. Parameters: capacity (int): The maximum capacity of the cache. Example: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 def __init__(self, capacity: int): # Initialize the LRUCache with the given capacity. pass def get(self, key: int) -> int: # Return the value if the key exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: # Set or insert the value if the key is not already present. # Invalidate the least recently used item if the cache reaches its capacity. pass import pytest def test_lru_cache(): cache = LRUCache(2) cache.put(1, 1) # cache is {1=1} cache.put(2, 2) # cache is {1=1, 2=2} assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # LRU key was 2, evicts key 2, cache is {1=1, 3=3} assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # LRU key was 1, evicts key 1, cache is {4=4, 3=3} assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_overwrite(): cache = LRUCache(2) cache.put(1, 1) # cache is {1=1} cache.put(2, 2) # cache is {1=1, 2=2} cache.put(1, 10) # overwrite, cache is {2=2, 1=10} assert cache.get(1) == 10 # returns 10 def test_lru_cache_single_capacity(): cache = LRUCache(1) cache.put(1, 1) # cache is {1=1} assert cache.get(1) == 1 # returns 1 cache.put(2, 2) # evicts key 1, cache is {2=2} assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 def test_lru_cache_evictions(): cache = LRUCache(3) cache.put(1, 1) # cache is {1=1} cache.put(2, 2) # cache is {1=1, 2=2} cache.put(3, 3) # cache is {1=1, 2=2, 3=3} cache.put(4, 4) # evicts key 1, cache is {2=2, 3=3, 4=4} assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_non_existent_key(): cache = LRUCache(2) assert cache.get(1) == -1 # returns -1 (not found) cache.put(1, 1) # cache is {1=1} assert cache.get(2) == -1 # returns -1 (not found)","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"class Library: def __init__(self): Initialize the library with an empty list of books. self.books = [] def add_book(self, title, author, isbn): Adds a new book to the library with the given title, author, and ISBN. Args: title (str): The title of the book. author (str): The author of the book. isbn (str): The ISBN number of the book. Example: >>> library = Library() >>> library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") >>> len(library.books) 1 >>> library.books[0]['title'] 'The Great Gatsby' book = {'title': title, 'author': author, 'ISBN': isbn} self.books.append(book) def remove_book(self, isbn): Removes a book from the library by its ISBN number. Args: isbn (str): The ISBN number of the book to be removed. Example: >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\", \\"0987654321\\") >>> library.remove_book(\\"0987654321\\") >>> len(library.books) 0 for book in self.books: if book['ISBN'] == isbn: self.books.remove(book) return print(\\"Book not found!\\") def search_book(self, search_term): Searches for books by title or author. Args: search_term (str): The search term to look for in the title or author. Returns: list: A list of books that match the search term. Example: >>> library = Library() >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"1111111111\\") >>> results = library.search_book(\\"Mockingbird\\") >>> len(results) 1 >>> results[0]['title'] 'To Kill a Mockingbird' results = [ book for book in self.books if search_term.lower() in book['title'].lower() or search_term.lower() in book['author'].lower() ] return results def display_books(self): Displays all books currently available in the library. Example: >>> library = Library() >>> library.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", \\"3333333333\\") >>> library.display_books() Title: The Catcher in the Rye, Author: J.D. Salinger, ISBN: 3333333333 if not self.books: print(\\"No books in the library\\") for book in self.books: print(f'Title: {book[\\"title\\"]}, Author: {book[\\"author\\"]}, ISBN: {book[\\"ISBN\\"]}') import pytest def test_add_book(): library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\") assert len(library.books) == 1 assert library.books[0]['title'] == \\"The Great Gatsby\\" assert library.books[0]['author'] == \\"F. Scott Fitzgerald\\" assert library.books[0]['ISBN'] == \\"1234567890\\" def test_remove_book(): library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", \\"0987654321\\") library.remove_book(\\"0987654321\\") assert len(library.books) == 0 # Test removing a book that does not exist library.remove_book(\\"0000000000\\") # Should not fail but print \\"Book not found!\\" def test_search_book(): library = Library() library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"1111111111\\") library.add_book(\\"Mockingjay\\", \\"Suzanne Collins\\", \\"2222222222\\") results = library.search_book(\\"Mockingbird\\") assert len(results) == 1 assert results[0]['title'] == \\"To Kill a Mockingbird\\" results = library.search_book(\\"Collins\\") assert len(results) == 1 assert results[0]['title'] == \\"Mockingjay\\" results = library.search_book(\\"Nonexistent\\") assert len(results) == 0 def test_display_books(capfd): library = Library() library.add_book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", \\"3333333333\\") library.add_book(\\"Brave New World\\", \\"Aldous Huxley\\", \\"4444444444\\") library.display_books() captured = capfd.readouterr() assert \\"No books in the library\\" not in captured.out assert \\"The Catcher in the Rye\\" in captured.out assert \\"Brave New World\\" in captured.out # Test display with no books library = Library() library.display_books() captured = capfd.readouterr() assert \\"No books in the library\\" in captured.out","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, isbn): Adds a new book to the library with the given title, author, and ISBN. book = {'title': title, 'author': author, 'ISBN': isbn} self.books.append(book) def remove_book(self, isbn): Removes a book from the library by its ISBN number. for book in self.books: if book['ISBN'] == isbn: self.books.remove(book) return print(\\"Book not found!\\") def search_book(self, search_term): Searches for books by title or author. results = [ book for book in self.books if search_term.lower() in book['title'].lower() or search_term.lower() in book['author'].lower() ] return results def display_books(self): Displays all books currently available in the library. if not self.books: print(\\"No books in the library\\") for book in self.books: print(f'Title: {book[\\"title\\"]}, Author: {book[\\"author\\"]}, ISBN: {book[\\"ISBN\\"]}')"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): Insert a node with the given key into the BST. ... def delete(self, key): Delete the node with the given key from the BST. ... def search(self, key): Search for a node with the given key in the BST. Return True if found, False otherwise. ... def in_order_traversal(self): Perform an in-order traversal of the BST and return the keys. ... def find_minimum(self): Find the node with the minimum key in the BST. ... def find_maximum(self): Find the node with the maximum key in the BST. ... def get_height(self): Find the height of the BST. ... def is_valid(self): Check if the BST is valid. ... # Unit tests def test_insert(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.search(10) == True assert bst.search(5) == True assert bst.search(15) == True def test_delete(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.delete(10) assert bst.search(10) == False assert bst.search(5) == True assert bst.search(15) == True def test_search(): bst = BST() bst.insert(8) bst.insert(3) bst.insert(10) bst.insert(1) assert bst.search(8) == True assert bst.search(3) == True assert bst.search(5) == False def test_in_order_traversal(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) assert bst.in_order_traversal() == [2, 5, 7, 10, 15] def test_find_minimum(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.find_minimum() == 5 bst.delete(5) assert bst.find_minimum() == 10 def test_find_maximum(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.find_maximum() == 15 bst.delete(15) assert bst.find_maximum() == 10 def test_get_height(): bst = BST() assert bst.get_height() == -1 bst.insert(10) assert bst.get_height() == 0 bst.insert(5) bst.insert(15) assert bst.get_height() == 1 def test_is_valid(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) assert bst.is_valid() == True bst.root.left.key = 20 assert bst.is_valid() == False if __name__ == \\"__main__\\": test_insert() test_delete() test_search() test_in_order_traversal() test_find_minimum() test_find_maximum() test_get_height() test_is_valid() print(\\"All tests passed!\\")","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left: self._insert(node.left, key) else: node.left = TreeNode(key) else: if node.right: self._insert(node.right, key) else: node.right = TreeNode(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._minValueNode(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.key == key: return True if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def in_order_traversal(self): keys = [] self._in_order_traversal(self.root, keys) return keys def _in_order_traversal(self, node, keys): if node: self._in_order_traversal(node.left, keys) keys.append(node.key) self._in_order_traversal(node.right, keys) def find_minimum(self): min_node = self._minValueNode(self.root) return min_node.key if min_node else None def _minValueNode(self, node): current = node while current and current.left: current = current.left return current def find_maximum(self): max_node = self._maxValueNode(self.root) return max_node.key if max_node else None def _maxValueNode(self, node): current = node while current and current.right: current = current.right return current def get_height(self): return self._get_height(self.root) def _get_height(self, node): if node is None: return -1 left_height = self._get_height(node.left) right_height = self._get_height(node.right) return max(left_height, right_height) + 1 def is_valid(self): return self._is_valid(self.root, float('-inf'), float('inf')) def _is_valid(self, node, min_key, max_key): if node is None: return True if not(min_key < node.key < max_key): return False return self._is_valid(node.left, min_key, node.key) and self._is_valid(node.right, node.key, max_key)"},{"question":"from abc import ABC, abstractmethod class LibraryItem(ABC): def __init__(self, title, identifier): self._title = title self._identifier = identifier self._is_borrowed = False @abstractmethod def borrow_item(self): Borrow the item if it is available. Return True if the item was successfully borrowed, False otherwise. pass @abstractmethod def return_item(self): Return the item if it is borrowed. Return True if the item was successfully returned, False otherwise. pass def get_title(self): return self._title def get_identifier(self): return self._identifier def is_borrowed(self): return self._is_borrowed class Book(LibraryItem): def __init__(self, title, identifier, author): super().__init__(title, identifier) self._author = author def borrow_item(self): pass def return_item(self): pass def get_author(self): return self._author class Magazine(LibraryItem): def __init__(self, title, identifier, issue_number): super().__init__(title, identifier) self._issue_number = issue_number def borrow_item(self): pass def return_item(self): pass def get_issue_number(self): return self._issue_number class DVD(LibraryItem): def __init__(self, title, identifier, duration): super().__init__(title, identifier) self._duration = duration def borrow_item(self): pass def return_item(self): pass def get_duration(self): return self._duration def main(): # Demonstration of borrowing and returning items item1 = Book(\\"1984\\", \\"B001\\", \\"George Orwell\\") item2 = Magazine(\\"National Geographic\\", \\"M001\\", 202) item3 = DVD(\\"Inception\\", \\"D001\\", 148) item1.borrow_item() item2.return_item() item3.borrow_item() print(f\\"Title: {item1.get_title()}, Identifier: {item1.get_identifier()}, Author: {item1.get_author()}, Borrowed: {item1.is_borrowed()}\\") print(f\\"Title: {item2.get_title()}, Identifier: {item2.get_identifier()}, Issue Number: {item2.get_issue_number()}, Borrowed: {item2.is_borrowed()}\\") print(f\\"Title: {item3.get_title()}, Identifier: {item3.get_identifier()}, Duration: {item3.get_duration()} mins, Borrowed: {item3.is_borrowed()}\\") item1.return_item() item3.return_item() print(\\"--- After Returning ---\\") print(f\\"Borrowed: {item1.is_borrowed()}\\") print(f\\"Borrowed: {item3.is_borrowed()}\\") if __name__ == '__main__': main()","solution":"from abc import ABC, abstractmethod class LibraryItem(ABC): def __init__(self, title, identifier): self._title = title self._identifier = identifier self._is_borrowed = False @abstractmethod def borrow_item(self): pass @abstractmethod def return_item(self): pass def get_title(self): return self._title def get_identifier(self): return self._identifier def is_borrowed(self): return self._is_borrowed class Book(LibraryItem): def __init__(self, title, identifier, author): super().__init__(title, identifier) self._author = author def borrow_item(self): if not self._is_borrowed: self._is_borrowed = True return True return False def return_item(self): if self._is_borrowed: self._is_borrowed = False return True return False def get_author(self): return self._author class Magazine(LibraryItem): def __init__(self, title, identifier, issue_number): super().__init__(title, identifier) self._issue_number = issue_number def borrow_item(self): if not self._is_borrowed: self._is_borrowed = True return True return False def return_item(self): if self._is_borrowed: self._is_borrowed = False return True return False def get_issue_number(self): return self._issue_number class DVD(LibraryItem): def __init__(self, title, identifier, duration): super().__init__(title, identifier) self._duration = duration def borrow_item(self): if not self._is_borrowed: self._is_borrowed = True return True return False def return_item(self): if self._is_borrowed: self._is_borrowed = False return True return False def get_duration(self): return self._duration # Demonstration of borrowing and returning items item1 = Book(\\"1984\\", \\"B001\\", \\"George Orwell\\") item2 = Magazine(\\"National Geographic\\", \\"M001\\", 202) item3 = DVD(\\"Inception\\", \\"D001\\", 148) item1.borrow_item() item2.return_item() item3.borrow_item() print(f\\"Title: {item1.get_title()}, Identifier: {item1.get_identifier()}, Author: {item1.get_author()}, Borrowed: {item1.is_borrowed()}\\") print(f\\"Title: {item2.get_title()}, Identifier: {item2.get_identifier()}, Issue Number: {item2.get_issue_number()}, Borrowed: {item2.is_borrowed()}\\") print(f\\"Title: {item3.get_title()}, Identifier: {item3.get_identifier()}, Duration: {item3.get_duration()} mins, Borrowed: {item3.is_borrowed()}\\") item1.return_item() item3.return_item() print(\\"--- After Returning ---\\") print(f\\"Borrowed: {item1.is_borrowed()}\\") print(f\\"Borrowed: {item3.is_borrowed()}\\")"},{"question":"import socket import threading from typing import List HOST = 'localhost' PORT = 5000 def handle_client(client_socket, addr, username, clients): Handle communication with a connected client. :param client_socket: The socket connected to the client. :param addr: The address of the client. :param username: The username of the client. :param clients: The list of all connected clients. welcome_message = f\\"{username} has joined the chat!\\" broadcast(welcome_message, client_socket, clients) while True: try: message = client_socket.recv(1024).decode() if message: print(f\\"[{username}@{addr}] {message}\\") broadcast(f\\"{username}: {message}\\", client_socket, clients) else: remove_client(client_socket, clients) broadcast(f\\"{username} has left the chat.\\", client_socket, clients) break except: remove_client(client_socket, clients) broadcast(f\\"{username} has left the chat.\\", client_socket, clients) break def broadcast(message, current_client, clients): Broadcast a message to all connected clients except the sender. :param message: The message to send. :param current_client: The client who sent the message. :param clients: The list of all connected clients. for client in clients: if client != current_client: try: client.send(message.encode()) except: remove_client(client, clients) def remove_client(client_socket, clients): Remove a client from the list of connected clients. :param client_socket: The client socket to remove. :param clients: The list of all connected clients. if client_socket in clients: clients.remove(client_socket) def server_program(): Start the chat server and handle incoming client connections. server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind((HOST, PORT)) server_socket.listen(5) print(f\\"Server listening on {HOST}:{PORT}\\") clients: List[socket.socket] = [] while True: client_socket, addr = server_socket.accept() print(f\\"Connection from: {addr}\\") client_socket.send(\\"USERNAME\\".encode()) username = client_socket.recv(1024).decode() clients.append(client_socket) threading.Thread(target=handle_client, args=(client_socket, addr, username, clients)).start() def client_program(): Connect to the chat server and handle sending and receiving messages. client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: client_socket.connect((HOST, PORT)) username = input(\\"Enter your username: \\") client_socket.send(username.encode()) threading.Thread(target=receive_messages, args=(client_socket,)).start() while True: message = input() client_socket.send(message.encode()) if message.lower() == 'bye': client_socket.close() break except socket.error as e: print(\\"Connection error:\\", e) client_socket.close() def receive_messages(client_socket): Receive messages from the server and print them. :param client_socket: The socket connected to the server. while True: try: message = client_socket.recv(1024).decode() if message: print(message) else: break except: break import socket import threading import pytest import time # Assuming the server and client implementations are in a file named 'solution.py' from solution import server_program, client_program def test_server_client_communication(): # Start the server in a separate thread server_thread = threading.Thread(target=server_program) server_thread.daemon = True server_thread.start() # Wait for the server to start time.sleep(1) # Start two clients in separate threads client_thread1 = threading.Thread(target=client_program_simulated, args=(\\"User1\\", \\"Hello from User1\\")) client_thread1.daemon = True client_thread1.start() client_thread2 = threading.Thread(target=client_program_simulated, args=(\\"User2\\", \\"Hello from User2\\")) client_thread2.daemon = True client_thread2.start() # Wait for clients to exchange messages time.sleep(5) assert True # Test passes if no exceptions are raised def client_program_simulated(username, message): Simulate a client interaction with predefined username and message. :param username: The username of the simulated client. :param message: The message to send from the simulated client. client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: client_socket.connect(('localhost', 5000)) client_socket.send(username.encode()) time.sleep(1) client_socket.send(message.encode()) time.sleep(1) client_socket.send(\\"bye\\".encode()) time.sleep(1) client_socket.close() except socket.error as e: print(\\"Connection error:\\", e) client_socket.close() if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"import socket import threading from typing import List # Constants HOST = 'localhost' PORT = 5000 def handle_client(client_socket, addr, username, clients): Handle communication with a connected client. :param client_socket: The socket connected to the client. :param addr: The address of the client. :param username: The username of the client. :param clients: The list of all connected clients. welcome_message = f\\"{username} has joined the chat!\\" broadcast(welcome_message, client_socket, clients) while True: try: message = client_socket.recv(1024).decode() if message: print(f\\"[{username}@{addr}] {message}\\") broadcast(f\\"{username}: {message}\\", client_socket, clients) else: remove_client(client_socket, clients) broadcast(f\\"{username} has left the chat.\\", client_socket, clients) break except: remove_client(client_socket, clients) broadcast(f\\"{username} has left the chat.\\", client_socket, clients) break def broadcast(message, current_client, clients): Broadcast a message to all connected clients except the sender. :param message: The message to send. :param current_client: The client who sent the message. :param clients: The list of all connected clients. for client in clients: if client != current_client: try: client.send(message.encode()) except: remove_client(client, clients) def remove_client(client_socket, clients): Remove a client from the list of connected clients. :param client_socket: The client socket to remove. :param clients: The list of all connected clients. if client_socket in clients: clients.remove(client_socket) def server_program(): Start the chat server and handle incoming client connections. server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind((HOST, PORT)) server_socket.listen(5) print(f\\"Server listening on {HOST}:{PORT}\\") clients: List[socket.socket] = [] while True: client_socket, addr = server_socket.accept() print(f\\"Connection from: {addr}\\") client_socket.send(\\"USERNAME\\".encode()) username = client_socket.recv(1024).decode() clients.append(client_socket) threading.Thread(target=handle_client, args=(client_socket, addr, username, clients)).start() def client_program(): Connect to the chat server and handle sending and receiving messages. client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: client_socket.connect((HOST, PORT)) username = input(\\"Enter your username: \\") client_socket.send(username.encode()) threading.Thread(target=receive_messages, args=(client_socket,)).start() while True: message = input() client_socket.send(message.encode()) if message.lower() == 'bye': client_socket.close() break except socket.error as e: print(\\"Connection error:\\", e) client_socket.close() def receive_messages(client_socket): Receive messages from the server and print them. :param client_socket: The socket connected to the server. while True: try: message = client_socket.recv(1024).decode() if message: print(message) else: break except: break"},{"question":"import os import multiprocessing from collections import Counter import re class FileNotFoundError(Exception): pass def word_count_in_file(file_name: str, chunk_size: int = 1024*1024) -> dict: Reads a large text file and counts the frequency of each word using multiple processes, then merges the results from all processes and returns a dictionary containing words as keys and their frequencies as values. Raises a custom FileNotFoundError if the file does not exist or cannot be opened. >>> word_count_in_file(\\"test_file.txt\\") {\\"hello\\": 30000, \\"world\\": 20000, \\"this\\": 10000, \\"is\\": 10000, \\"a\\": 10000, \\"test\\": 10000, \\"file\\": 10000}","solution":"import os import multiprocessing from collections import Counter import re class FileNotFoundError(Exception): pass def read_chunk(file_name, start, size): with open(file_name, \\"rb\\") as f: f.seek(start) chunk = f.read(size) return chunk def count_words_in_chunk(chunk): chunk = chunk.decode(\\"utf-8\\") words = re.findall(r'bw+b', chunk.lower()) return Counter(words) def word_count_in_file(file_name, chunk_size=1024*1024): if not os.path.exists(file_name): raise FileNotFoundError(f\\"The file {file_name} does not exist or cannot be opened.\\") file_size = os.path.getsize(file_name) chunks = [(file_name, i, min(chunk_size, file_size - i)) for i in range(0, file_size, chunk_size)] with multiprocessing.Pool(processes=multiprocessing.cpu_count()) as pool: counters = pool.starmap(process_chunk, chunks) total_counter = Counter() for counter in counters: total_counter.update(counter) return dict(total_counter) def process_chunk(file_name, start, size): chunk = read_chunk(file_name, start, size) return count_words_in_chunk(chunk)"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a mathematical expression containing addition and multiplication. Parameters: s (str): A string representing the mathematical expression. Returns: int: The result of the expression. >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"0 * 1 + 5 * 2\\") 10 >>> evaluate_expression(\\"2 + 3 + 4\\") 9 >>> evaluate_expression(\\"3 * 3 + 2\\") 11 >>> evaluate_expression(\\"7 * 1 + 0 * 3\\") 7","solution":"def evaluate_expression(s: str) -> int: Evaluate a mathematical expression containing addition and multiplication. Parameters: s (str): A string representing the mathematical expression. Returns: int: The result of the expression. # Remove any whitespace s = s.replace(' ', '') # Convert the expression to a list of tokens tokens = [] i = 0 while i < len(s): if s[i].isdigit(): tokens.append(int(s[i])) else: tokens.append(s[i]) i += 1 # First pass - handle multiplication new_tokens = [] i = 0 while i < len(tokens): if tokens[i] == '*': last_number = new_tokens.pop() new_tokens.append(last_number * tokens[i+1]) i += 2 else: new_tokens.append(tokens[i]) i += 1 # Second pass - handle addition result = 0 i = 0 while i < len(new_tokens): if new_tokens[i] == '+': result += new_tokens[i+1] i += 2 else: result += new_tokens[i] i += 1 return result"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum possible profit from buying and selling the stock based on given prices. If there are fewer than two prices, returns an error message. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 1, 5, 3, 6, 4, 10]) 9 >>> max_profit([7]) \\"Error: Insufficient data points\\" >>> max_profit([]) \\"Error: Insufficient data points\\" >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5, 6]) 5 >>> max_profit([7, 1, 5, 3, 6, 4, 8, 2]) 7","solution":"def max_profit(prices): Returns the maximum possible profit from buying and selling the stock based on given prices. If there are fewer than two prices, returns an error message. if len(prices) < 2: return \\"Error: Insufficient data points\\" min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def square_and_abs(input_list: List[int]) -> List[int]: Returns a new list with each integer squared, ensuring that negative integers are converted to their absolute value before squaring. If the list is empty, the function should return an empty list. >>> square_and_abs([1, 2, 3]) [1, 4, 9] >>> square_and_abs([-1, -2, -3]) [1, 4, 9] >>> square_and_abs([1, -2, 3, -4]) [1, 4, 9, 16] >>> square_and_abs([]) [] >>> square_and_abs([0]) [0] >>> square_and_abs([5]) [25] >>> square_and_abs([-7]) [49] >>> square_and_abs([0, -1, 2, -3, 4]) [0, 1, 4, 9, 16] >>> square_and_abs([100000, -100000]) [10000000000, 10000000000]","solution":"def square_and_abs(input_list): Returns a new list with each integer squared, ensuring that negative integers are converted to their absolute value before squaring. return [abs(x) ** 2 for x in input_list]"},{"question":"def update_inventory(current_inventory, new_shipments): This function updates the existing 'current_inventory' dictionary with the quantities from 'new_shipments'. - current_inventory: Dictionary with item names as keys and their corresponding quantities as values. - new_shipments: List of tuples, each containing an item name and quantity to be added to the inventory. The function should update the quantities of existing items and add new items to the inventory as needed. It should return an updated dictionary representing the modified inventory. >>> update_inventory({'apple': 50, 'banana': 30}, [('orange', 20), ('grapes', 15)]) == {'apple': 50, 'banana': 30, 'orange': 20, 'grapes': 15} >>> update_inventory({'apple': 50, 'banana': 30}, [('apple', 20), ('banana', 15)]) == {'apple': 70, 'banana': 45} >>> update_inventory({'apple': 50, 'banana': 30}, [('apple', 20), ('orange', 10)]) == {'apple': 70, 'banana': 30, 'orange': 10} >>> update_inventory({'apple': 50, 'banana': 30}, []) == {'apple': 50, 'banana': 30} >>> update_inventory({}, [('apple', 20), ('orange', 10)]) == {'apple': 20, 'orange': 10} >>> update_inventory({'apple': 50, 'banana': 30}, [('apple', 0), ('banana', 0)]) == {'apple': 50, 'banana': 30}","solution":"def update_inventory(current_inventory, new_shipments): This function updates the existing 'current_inventory' dictionary with the quantities from 'new_shipments'. - current_inventory: Dictionary with item names as keys and their corresponding quantities as values. - new_shipments: List of tuples, each containing an item name and quantity to be added to the inventory. The function should update the quantities of existing items and add new items to the inventory as needed. It should return an updated dictionary representing the modified inventory. for item, quantity in new_shipments: if item in current_inventory: current_inventory[item] += quantity else: current_inventory[item] = quantity return current_inventory"},{"question":"def has_cycle(graph): Detects if a given directed graph contains a cycle using DFS algorithm. :param graph: A dictionary representing the adjacency list of the graph :return: True if the graph contains a cycle, False otherwise >>> has_cycle({0: [1], 1: [2], 2: [0]}) True >>> has_cycle({0: [1], 1: [2], 2: [3]}) False >>> has_cycle({}) False >>> has_cycle({0: [0]}) True >>> has_cycle({0: [1], 1: [2], 2: [0], 3: [4], 4: []}) True >>> has_cycle({0: [1], 1: [], 2: [3], 3: []}) False >>> has_cycle({0: [1, 2], 1: [3], 2: [3], 3: []}) False >>> has_cycle({0: [1, 2], 1: [2, 3], 2: [3], 3: [1]}) True","solution":"def has_cycle(graph): Detects if a given directed graph contains a cycle using DFS algorithm. :param graph: A dictionary representing the adjacency list of the graph :return: True if the graph contains a cycle, False otherwise def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two indices in the list 'nums' such that the elements at these indices add up to 'target'. :param nums: List of integers :param target: Target integer :return: Tuple containing two indices or an empty tuple if no pair is found >>> find_two_sum_indices([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum_indices([1, 2, 3, 4, 3, 6], 6) (1, 3) >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) () >>> find_two_sum_indices([-3, 4, 3, 90], 0) (0, 2) >>> find_two_sum_indices([3, 3, 4, 4], 6) (0, 1)","solution":"def find_two_sum_indices(nums, target): Finds two indices in the list 'nums' such that the elements at these indices add up to 'target'. :param nums: List of integers :param target: Target integer :return: Tuple containing two indices or an empty tuple if no pair is found num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def first_non_repeated_character(text: str) -> str: Write a function that takes a string of text and returns the first non-repeated character. If all characters in the string are repeated, return an underscore. Ensure the function handles both uppercase and lowercase letters as distinct characters. >>> first_non_repeated_character(\\"teeter\\") == \\"r\\" >>> first_non_repeated_character(\\"total\\") == \\"o\\" >>> first_non_repeated_character(\\"swiss\\") == \\"w\\" >>> first_non_repeated_character(\\"\\") == \\"_\\" >>> first_non_repeated_character(\\"aabbcc\\") == \\"_\\" >>> first_non_repeated_character(\\"zzxxzz\\") == \\"_\\" >>> first_non_repeated_character(\\"a\\") == \\"a\\" >>> first_non_repeated_character(\\"aA\\") == \\"a\\" >>> first_non_repeated_character(\\"Aa\\") == \\"A\\" >>> first_non_repeated_character(\\"abc\\") == \\"a\\" >>> first_non_repeated_character(\\"abac\\") == \\"b\\"","solution":"def first_non_repeated_character(text): Returns the first non-repeated character in the string. If all characters are repeated, returns an underscore. character_count = {} # Count occurrences of each character for char in text: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 # Find the first character with a count of 1 for char in text: if character_count[char] == 1: return char return '_'"},{"question":"def rotate_list(lst: List[int], n: int) -> List[int]: Rotates the list to the right by n positions. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([], 2) [] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1], 3) [1]","solution":"def rotate_list(lst, n): Rotates the list to the right by n positions. if not lst or n <= 0: return lst n = n % len(lst) # Handle cases where n is larger than the length of the list return lst[-n:] + lst[:-n]"},{"question":"def prime_status(numbers: List[int]) -> Dict[int, bool]: Takes a list of integers and returns a dictionary. Keys: original integers from the list. Values: True if the integer is prime, False otherwise. >>> prime_status([2, 3, 5, 7, 11]) == {2: True, 3: True, 5: True, 7: True, 11: True} >>> prime_status([4, 6, 8, 9, 10]) == {4: False, 6: False, 8: False, 9: False, 10: False} >>> prime_status([2, 4, 5, 9, 11]) == {2: True, 4: False, 5: True, 9: False, 11: True} >>> prime_status([-1, 0, 1, 2, 3]) == {-1: False, 0: False, 1: False, 2: True, 3: True} >>> prime_status([]) == {}","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def prime_status(numbers): Takes a list of integers and returns a dictionary. Keys: original integers from the list. Values: True if the integer is prime, False otherwise. return {num: is_prime(num) for num in numbers}"},{"question":"class CourseEnrollmentSystem: Course Enrollment System This system manages course enrollments, allowing for adding/deleting courses, enrolling students, and retrieving course and student information. Example Commands: 1. Add Course system.add_course(\\"CS101\\", \\"Introduction to CS\\") -> \\"Course CS101 added successfully.\\" 2. Delete Course system.delete_course(\\"CS101\\") -> \\"Course CS101 deleted successfully.\\" 3. Enroll Student system.enroll_student(\\"12345\\", \\"CS101\\") -> \\"Student 12345 enrolled in CS101 successfully.\\" 4. Retrieve Course Information system.retrieve_course_information(\\"CS101\\") -> (\\"Students enrolled in CS101:\\", [\\"12345\\"]) 5. Retrieve Student Information system.retrieve_student_information(\\"12345\\") -> (\\"Courses student 12345 is enrolled in:\\", [\\"CS101\\"]) Implement the following methods: - def add_course(self, course_code: str, course_name: str) -> str - def delete_course(self, course_code: str) -> str - def enroll_student(self, student_id: str, course_code: str) -> str - def retrieve_course_information(self, course_code: str) -> (str, List[str]) - def retrieve_student_information(self, student_id: str) -> (str, List[str]) Unit Test Cases: def test_add_course(): system = CourseEnrollmentSystem() result = system.add_course(\\"CS101\\", \\"Introduction to CS\\") assert result == \\"Course CS101 added successfully.\\" result = system.add_course(\\"CS101\\", \\"Advanced CS\\") assert result == \\"Course with code CS101 already exists.\\" def test_delete_course(): system = CourseEnrollmentSystem() system.add_course(\\"CS101\\", \\"Introduction to CS\\") result = system.delete_course(\\"CS101\\") assert result == \\"Course CS101 deleted successfully.\\" result = system.delete_course(\\"CS102\\") assert result == \\"Course with code CS102 does not exist.\\" def test_enroll_student(): system = CourseEnrollmentSystem() system.add_course(\\"CS101\\", \\"Introduction to CS\\") result = system.enroll_student(\\"12345\\", \\"CS101\\") assert result == \\"Student 12345 enrolled in CS101 successfully.\\" result = system.enroll_student(\\"12345\\", \\"CS101\\") assert result == \\"Student 12345 is already enrolled in CS101.\\" result = system.enroll_student(\\"54321\\", \\"CS102\\") assert result == \\"Course with code CS102 does not exist.\\" def test_retrieve_course_information(): system = CourseEnrollmentSystem() system.add_course(\\"CS101\\", \\"Introduction to CS\\") system.enroll_student(\\"12345\\", \\"CS101\\") message, students = system.retrieve_course_information(\\"CS101\\") assert message == \\"Students enrolled in CS101:\\" assert students == [\\"12345\\"] message, students = system.retrieve_course_information(\\"CS102\\") assert message == \\"Course with code CS102 does not exist.\\" assert students == [] def test_retrieve_student_information(): system = CourseEnrollmentSystem() system.add_course(\\"CS101\\", \\"Introduction to CS\\") system.enroll_student(\\"12345\\", \\"CS101\\") message, courses = system.retrieve_student_information(\\"12345\\") assert message == \\"Courses student 12345 is enrolled in:\\" assert courses == [\\"CS101\\"] message, courses = system.retrieve_student_information(\\"54321\\") assert message == \\"Student with id 54321 is not enrolled in any courses.\\" assert courses == [] pass","solution":"class CourseEnrollmentSystem: def __init__(self): self.courses = {} self.student_courses = {} def add_course(self, course_code, course_name): if course_code in self.courses: return f\\"Course with code {course_code} already exists.\\" self.courses[course_code] = {\\"name\\": course_name, \\"students\\": []} return f\\"Course {course_code} added successfully.\\" def delete_course(self, course_code): if course_code not in self.courses: return f\\"Course with code {course_code} does not exist.\\" del self.courses[course_code] return f\\"Course {course_code} deleted successfully.\\" def enroll_student(self, student_id, course_code): if course_code not in self.courses: return f\\"Course with code {course_code} does not exist.\\" if student_id in self.courses[course_code][\\"students\\"]: return f\\"Student {student_id} is already enrolled in {course_code}.\\" self.courses[course_code][\\"students\\"].append(student_id) if student_id not in self.student_courses: self.student_courses[student_id] = [] self.student_courses[student_id].append(course_code) return f\\"Student {student_id} enrolled in {course_code} successfully.\\" def retrieve_course_information(self, course_code): if course_code not in self.courses: return f\\"Course with code {course_code} does not exist.\\", [] students = self.courses[course_code][\\"students\\"] return f\\"Students enrolled in {course_code}:\\", students def retrieve_student_information(self, student_id): if student_id not in self.student_courses: return f\\"Student with id {student_id} is not enrolled in any courses.\\", [] courses = self.student_courses[student_id] return f\\"Courses student {student_id} is enrolled in:\\", courses"},{"question":"class Book: def __init__(self, title: str, author: str, isbn: str): Initialize a Book object. :param title: Title of the book :param author: Author of the book :param isbn: Unique identifier for the book self.title = title self.author = author self.isbn = isbn self.is_checked_out = False def check_out(self): Marks the book as checked out. self.is_checked_out = True def return_book(self): Marks the book as returned. self.is_checked_out = False class Library: def __init__(self): Initialize a Library object. self.inventory = [] def add_book(self, book: Book): Adds a book to the library's inventory. :param book: Book object to add self.inventory.append(book) def remove_book(self, isbn: str): Removes a book with the given ISBN from the library's inventory. :param isbn: ISBN of the book to remove self.inventory = [book for book in self.inventory if book.isbn != isbn] def checkout_book(self, isbn: str): Marks the book with the given ISBN as checked out. :param isbn: ISBN of the book to check out for book in self.inventory: if book.isbn == isbn: book.check_out() break def return_book(self, isbn: str): Marks the book with the given ISBN as returned. :param isbn: ISBN of the book to return for book in self.inventory: if book.isbn == isbn: book.return_book() break def list_books(self): Prints all the books in the library's inventory with their check-out status. for book in self.inventory: status = 'Checked out' if book.is_checked_out else 'Available' print(f\\"Title: {book.title}, Author: {book.author}, ISBN: {book.isbn}, Status: {status}\\") # Example Usage book1 = Book(\\"1984\\", \\"George Orwell\\", \\"1111\\") book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"2222\\") library = Library() library.add_book(book1) library.add_book(book2) library.list_books() library.checkout_book(\\"1111\\") library.list_books() library.return_book(\\"1111\\") library.list_books() library.remove_book(\\"2222\\") library.list_books()","solution":"class Book: def __init__(self, title, author, isbn): self.title = title self.author = author self.isbn = isbn self.is_checked_out = False def check_out(self): self.is_checked_out = True def return_book(self): self.is_checked_out = False class Library: def __init__(self): self.inventory = [] def add_book(self, book): self.inventory.append(book) def remove_book(self, isbn): self.inventory = [book for book in self.inventory if book.isbn != isbn] def checkout_book(self, isbn): for book in self.inventory: if book.isbn == isbn: book.check_out() break def return_book(self, isbn): for book in self.inventory: if book.isbn == isbn: book.return_book() break def list_books(self): book_list = [] for book in self.inventory: status = 'Checked out' if book.is_checked_out else 'Available' book_list.append((book.title, book.author, book.isbn, status)) return book_list # Example Usage (uncomment for manual testing) # book1 = Book(\\"1984\\", \\"George Orwell\\", \\"1111\\") # book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"2222\\") # # library = Library() # library.add_book(book1) # library.add_book(book2) # # print(library.list_books()) # library.checkout_book(\\"1111\\") # print(library.list_books()) # library.return_book(\\"1111\\") # print(library.list_books()) # library.remove_book(\\"2222\\") # print(library.list_books())"},{"question":"def bank_operations(operations): Simulate a very basic banking system with the following operations: deposit, withdraw, and check balance. The system starts with an initial balance of zero. Args: operations (list): A list of dictionaries describing the operations. Returns: list: A list of results for 'check_balance' operations. Example usage: operations = [ {'type': 'deposit', 'amount': 100}, {'type': 'withdraw', 'amount': 50}, {'type': 'check_balance'}, {'type': 'withdraw', 'amount': 60}, {'type': 'check_balance'} ] # The expected output for the example usage should be: [50, 50] balance = 0 results = [] for operation in operations: if operation['type'] == 'deposit': balance += operation['amount'] elif operation['type'] == 'withdraw': if operation['amount'] <= balance: balance -= operation['amount'] elif operation['type'] == 'check_balance': results.append(balance) return results # Test cases def test_bank_operations(): operations = [ {'type': 'deposit', 'amount': 100}, {'type': 'withdraw', 'amount': 50}, {'type': 'check_balance'}, {'type': 'withdraw', 'amount': 60}, {'type': 'check_balance'} ] assert bank_operations(operations) == [50, 50] def test_initial_check_balance(): operations = [ {'type': 'check_balance'} ] assert bank_operations(operations) == [0] def test_deposit_and_check(): operations = [ {'type': 'deposit', 'amount': 200}, {'type': 'check_balance'} ] assert bank_operations(operations) == [200] def test_withdraw_over_balance(): operations = [ {'type': 'deposit', 'amount': 100}, {'type': 'withdraw', 'amount': 150}, {'type': 'check_balance'} ] assert bank_operations(operations) == [100] def test_multiple_operations(): operations = [ {'type': 'deposit', 'amount': 50}, {'type': 'deposit', 'amount': 50}, {'type': 'withdraw', 'amount': 30}, {'type': 'check_balance'}, {'type': 'withdraw', 'amount': 20}, {'type': 'check_balance'}, {'type': 'withdraw', 'amount': 100}, {'type': 'check_balance'} ] assert bank_operations(operations) == [70, 50, 50]","solution":"def bank_operations(operations): balance = 0 results = [] for operation in operations: if operation['type'] == 'deposit': balance += operation['amount'] elif operation['type'] == 'withdraw': if operation['amount'] <= balance: balance -= operation['amount'] elif operation['type'] == 'check_balance': results.append(balance) return results"},{"question":"import os import shutil from datetime import datetime, timedelta def archive_old_logs(base_directory: str): Archives log files older than 7 days in the given directory and its subdirectories. Args: base_directory (str): Path to the base directory containing log files. >>> with tempfile.TemporaryDirectory() as tmpdir: ... os.makedirs(os.path.join(tmpdir, 'app1')) ... os.makedirs(os.path.join(tmpdir, 'app2')) ... os.makedirs(os.path.join(tmpdir, 'archive')) ... ... create_log_file(os.path.join(tmpdir, 'app1', 'error.log'), 10) ... create_log_file(os.path.join(tmpdir, 'app1', 'recent.log'), 5) ... create_log_file(os.path.join(tmpdir, 'app2', 'access.log'), 8) ... create_log_file(os.path.join(tmpdir, 'app2', 'recent_access.log'), 3) ... ... archive_old_logs(tmpdir) ... assert os.path.exists(os.path.join(tmpdir, 'archive', 'error.log')) ... assert os.path.exists(os.path.join(tmpdir, 'archive', 'access.log')) ... assert os.path.exists(os.path.join(tmpdir, 'app1', 'recent.log')) ... assert os.path.exists(os.path.join(tmpdir, 'app2', 'recent_access.log')) ... assert not os.path.exists(os.path.join(tmpdir, 'app1', 'error.log')) ... assert not os.path.exists(os.path.join(tmpdir, 'app2', 'access.log'))","solution":"import os import shutil import time from datetime import datetime, timedelta def archive_old_logs(base_directory): Archives log files older than 7 days in the given directory and its subdirectories. Args: base_directory (str): Path to the base directory containing log files. # Create the archive directory if it doesn't exist archive_dir = os.path.join(base_directory, 'archive') if not os.path.exists(archive_dir): os.makedirs(archive_dir) cutoff_time = datetime.now() - timedelta(days=7) for root, _, files in os.walk(base_directory): for file in files: if file.endswith('.log'): file_path = os.path.join(root, file) file_mod_time = datetime.fromtimestamp(os.path.getmtime(file_path)) if file_mod_time < cutoff_time: shutil.move(file_path, os.path.join(archive_dir, file))"},{"question":"def diagonal_wave(matrix: List[List[int]]) -> List[int]: Traverse a matrix in a diagonal wave order starting from the top-left corner. Given a matrix of integers, output a list of its values traversed in a diagonal wave order. Parameters: matrix (List[List[int]]): A 2D list of integers Returns: List[int]: A list of integers that represents the matrix elements in diagonal wave order. Examples: >>> diagonal_wave([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> diagonal_wave([ ... [1, 2], ... [3, 4] ... ]) [1, 2, 3, 4] pass # Unit tests def test_diagonal_wave_3x3(): assert diagonal_wave([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 4, 7, 5, 3, 6, 8, 9] def test_diagonal_wave_1x1(): assert diagonal_wave([ [1] ]) == [1] def test_diagonal_wave_2x2(): assert diagonal_wave([ [1, 2], [3, 4] ]) == [1, 2, 3, 4] def test_diagonal_wave_4x4(): assert diagonal_wave([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == [1, 2, 5, 9, 6, 3, 4, 7, 10, 13, 14, 11, 8, 12, 15, 16] def test_diagonal_wave_3x2(): assert diagonal_wave([ [1, 2], [3, 4], [5, 6] ]) == [1, 2, 3, 5, 4, 6] def test_diagonal_wave_2x3(): assert diagonal_wave([ [1, 2, 3], [4, 5, 6] ]) == [1, 2, 4, 5, 3, 6] def test_diagonal_wave_custom_case(): assert diagonal_wave([ [1, 2, 3], [4, 5, 6] ]) == [1, 2, 4, 5, 3, 6] def test_diagonal_wave_empty_matrix(): assert diagonal_wave([]) == [] def test_diagonal_wave_single_row(): assert diagonal_wave([[1, 2, 3, 4]]) == [1, 2, 3, 4] def test_diagonal_wave_single_column(): assert diagonal_wave([ [1], [2], [3], [4] ]) == [1, 2, 3, 4]","solution":"def diagonal_wave(matrix): if not matrix or not matrix[0]: return [] n, m = len(matrix), len(matrix[0]) result = [] for wave in range(n + m - 1): if wave % 2 == 0: # For even wave index, move diagonally down-left row = min(wave, n - 1) col = max(0, wave - n + 1) while row >= 0 and col < m: result.append(matrix[row][col]) row -= 1 col += 1 else: # For odd wave index, move diagonally up-right col = min(wave, m - 1) row = max(0, wave - m + 1) while col >= 0 and row < n: result.append(matrix[row][col]) row += 1 col -= 1 return result"},{"question":"import pandas as pd import re def find_invalid_rows(csv_file, pattern, column): Identifies and returns rows containing invalid data patterns using regular expressions. Parameters: csv_file (str): The path to the CSV file. pattern (str): The regular expression pattern to check for invalid data. column (str): The column to check for the pattern. Returns: pandas.DataFrame: A DataFrame containing only rows with invalid data. Example: >>> csv_content = \\"\\"\\"id,name,email ... 1,John Doe,john.doe@example.com ... 2,Jane Smith,jane.smithexample.com ... 3,Bob Johnson,boby@example.com ... 4,Alice Brown,alice.brown-example.com ... \\"\\"\\" >>> from io import StringIO >>> csv_file = StringIO(csv_content) >>> pattern = r'^[w.-]+@[w.-]+.w+' >>> column = 'email' >>> find_invalid_rows(csv_file, pattern, column) id name email 1 2 Jane Smith jane.smithexample.com 3 4 Alice Brown alice.brown-example.com","solution":"import pandas as pd import re def find_invalid_rows(csv_file, pattern, column): Identifies and returns rows containing invalid data patterns using regular expressions. Parameters: csv_file (str): The path to the CSV file. pattern (str): The regular expression pattern to check for invalid data. column (str): The column to check for the pattern. Returns: pandas.DataFrame: A DataFrame containing only rows with invalid data. # Read the CSV file into a DataFrame df = pd.read_csv(csv_file) # Compile the regular expression pattern regex = re.compile(pattern) # Identify rows with invalid data invalid_rows = df[~df[column].apply(lambda x: bool(regex.match(str(x))))] return invalid_rows"},{"question":"def reverse_even_numbers(nums): Returns a new list containing only the even numbers from the original list, but in reverse order. If the input list contains non-integer values, an error is raised. >>> reverse_even_numbers([1, 2, 3, 4, 5, 6]) == [6, 4, 2] >>> reverse_even_numbers([1, 3, 5]) == [] >>> reverse_even_numbers([]) == [] >>> reverse_even_numbers([2, '3', 4]) # Raises ValueError","solution":"def reverse_even_numbers(nums): Returns a new list containing only the even numbers from the original list, but in reverse order. If the input list contains non-integer values, an error is raised. if not all(isinstance(num, int) for num in nums): raise ValueError(\\"All elements in the list must be integers.\\") even_nums_reversed = [num for num in reversed(nums) if num % 2 == 0] return even_nums_reversed # Example usage print(reverse_even_numbers([1, 2, 3, 4, 5, 6])) # Output: [6, 4, 2] print(reverse_even_numbers([1, 3, 5])) # Output: [] print(reverse_even_numbers([])) # Output: []"},{"question":"import re def evaluate_expression(expression: str) -> float: Write a Python function that takes a string containing a mathematical expression (e.g., \\"2+3*4-5/2\\") and evaluates it as a floating point number. The function should correctly handle the order of operations (i.e., multiplication and division before addition and subtraction). Use only basic Python libraries and avoid using \`eval\` for security reasons. >>> evaluate_expression(\\"2+3\\") == 5.0 >>> evaluate_expression(\\"5-2\\") == 3.0 >>> evaluate_expression(\\"3*4\\") == 12.0 >>> evaluate_expression(\\"10/2\\") == 5.0 >>> evaluate_expression(\\"2+3*4-5/2\\") == 11.5 >>> evaluate_expression(\\"10+2*3-4/2+5*6-3/3\\") == 43.0 >>> evaluate_expression(\\" 2 + 3 * 4 - 5 / 2 \\") == 11.5 >>> evaluate_expression(\\"2.5*2+3.0/2\\") == 6.5","solution":"import re def evaluate_expression(expression): Evaluates a mathematical expression string and returns the result as a floating point number. Handles order of operations: multiplication and division before addition and subtraction. def parse_term(term): # Split the term by multiplication and division operations parts = re.split(r'(*|/)', term) result = float(parts[0]) i = 1 while i < len(parts): if parts[i] == '*': result *= float(parts[i + 1]) elif parts[i] == '/': result /= float(parts[i + 1]) i += 2 return result # Split the expression by addition and subtraction operations terms = re.split(r'(+|-)', expression) result = parse_term(terms[0]) i = 1 while i < len(terms): if terms[i] == '+': result += parse_term(terms[i + 1]) elif terms[i] == '-': result -= parse_term(terms[i + 1]) i += 2 return result"},{"question":"def maxProduct(nums): Given an array of positive integers, find a contiguous subarray that has the maximum product of its elements. It is guaranteed that the length of the array is at least 1. >>> print(maxProduct([2,3,-2,4])) # Output: 6 (subarray => [2,3]) >>> print(maxProduct([-2,0,-1])) # Output: 0 (subarray => [0]) >>> print(maxProduct([-2,3,-4])) # Output: 24 (subarray => [3,-4])","solution":"def maxProduct(nums): Returns the maximum product of a contiguous subarray. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"import re from typing import List def extract_emails(text: str) -> List[str]: Extracts and returns a list of email addresses found within the input text. Args: text (str): The input text containing email addresses. Returns: list: A list of found email addresses, or an empty list if no email is found. >>> extract_emails(\\"Please contact us at support@example.com and sales@example.co.uk for further information.\\") ['support@example.com', 'sales@example.co.uk'] >>> extract_emails(\\"There are no email addresses in this text.\\") [] >>> extract_emails(\\"Send your feedback to user.name+filter@example.com!\\") ['user.name+filter@example.com'] >>> extract_emails(\\"Please contact john.doe@mail.example.com for further information.\\") ['john.doe@mail.example.com'] >>> extract_emails(\\"Please contact Support@Example.com and sales@Example.Org for more.\\") ['Support@Example.com', 'sales@Example.Org'] >>> extract_emails(\\"This is not an email: support@@example.com, neither is this: john.doe@ example .com\\") []","solution":"import re def extract_emails(text): Extracts and returns a list of email addresses found within the input text. Args: text (str): The input text containing email addresses. Returns: list: A list of found email addresses, or an empty list if no email is found. # Define the regular expression pattern for matching email addresses email_pattern = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}', re.IGNORECASE) # Find all occurrences of the email pattern in the input text found_emails = email_pattern.findall(text) return found_emails"},{"question":"def extract_values(dict_list: list, key: str) -> list: Given a list of dictionaries and a key, returns a list of values associated with the specified key from each dictionary. If a dictionary does not contain the specified key, it is skipped. Args: dict_list (list): List of dictionaries key (str): Key to look for in dictionaries Returns: list: List of values associated with the key >>> extract_values([{'a': 1, 'b': 2}, {'a': 3, 'c': 4}, {'a': 5, 'b': 6}], 'a') [1, 3, 5] >>> extract_values([{'a': 1, 'b': 2}, {'a': 3, 'c': 4}, {'a': 5, 'b': 6}], 'd') [] >>> extract_values([{'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'a': 5, 'b': 6}], 'a') [1, 5] >>> extract_values([{'x': 10, 'y': 20}, {'x': 30, 'z': 40}, {'x': 50, 'y': 60}], 'x') [10, 30, 50] >>> extract_values([], 'a') []","solution":"def extract_values(dict_list, key): Given a list of dictionaries and a key, returns a list of values associated with the specified key from each dictionary. If a dictionary does not contain the specified key, it is skipped. Args: dict_list (list): List of dictionaries key (str): Key to look for in dictionaries Returns: list: List of values associated with the key return [d[key] for d in dict_list if key in d]"},{"question":"def eval_expression(expression: str) -> str: Evaluates a mathematical expression containing integers and the operators '+', '*' following the standard order of operations (multiplication before addition). Handles potential syntax errors by returning appropriate error messages. >>> eval_expression(\\"\\") \\"Empty expression\\" >>> eval_expression(\\"42\\") 42 >>> eval_expression(\\"2 + 3\\") 5 >>> eval_expression(\\"4 * 5\\") 20 >>> eval_expression(\\"2 + 3 * 4\\") 14 >>> eval_expression(\\" 2 + 3 * 4 \\") 14 >>> eval_expression(\\"2 + 3 + 4\\") 9 >>> eval_expression(\\"2 * 3 * 4\\") 24 >>> eval_expression(\\"2 + a * 3\\") \\"Invalid characters in expression\\" >>> eval_expression(\\"2 + * 3\\") \\"Invalid expression\\" >>> eval_expression(\\"2 // 3\\") \\"Invalid characters in expression\\"","solution":"import re def eval_expression(expression): Evaluates a mathematical expression containing integers and the operators '+', '*' following the standard order of operations (multiplication before addition). Args: expression (str): The input mathematical expression as a string. Returns: int/str: The result of the evaluated expression or an error message if the input is invalid. if not expression: return \\"Empty expression\\" # Check for invalid characters if not re.match(r'^[0-9+*s]+', expression): return \\"Invalid characters in expression\\" try: parts = re.split(r'(+)', expression.replace(' ', '')) for i in range(len(parts)): if '*' in parts[i]: parts[i] = str(eval(parts[i])) return eval(''.join(parts)) except (SyntaxError, TypeError, ValueError): return \\"Invalid expression\\""},{"question":"def nth_largest_unique_element(numbers, n): Returns the n-th largest unique element from a given list of numbers. :param numbers: List of numbers (integers or floats). :param n: The n-th largest unique element to be returned. :return: The n-th largest unique element. :raises ValueError: If the input list is empty, has fewer than n unique elements, or contains non-numeric values.","solution":"def nth_largest_unique_element(numbers, n): Returns the n-th largest unique element from a given list of numbers. :param numbers: List of numbers (integers or floats). :param n: The n-th largest unique element to be returned. :return: The n-th largest unique element. :raises ValueError: If the input list is empty, has fewer than n unique elements, or contains non-numeric values. if not numbers: raise ValueError(\\"The input list is empty.\\") unique_numbers = set() for num in numbers: if not isinstance(num, (int, float)): raise ValueError(\\"The input list contains non-numeric values.\\") unique_numbers.add(num) sorted_unique_numbers = sorted(unique_numbers, reverse=True) if len(sorted_unique_numbers) < n: raise ValueError(f\\"The input list has fewer than {n} unique elements.\\") return sorted_unique_numbers[n-1]"},{"question":"def classify_boxes(weights): Classify boxes into categories and find the heaviest and lightest boxes. Parameters: weights (list): List of box weights in kilograms. Returns: dict: A dictionary with the number of boxes in each category and the weights of the heaviest and lightest boxes. categories = {'Light': 0, 'Medium': 0, 'Heavy': 0} min_weight = float('inf') max_weight = float('-inf') # Your implementation here return { 'categories': categories, 'heaviest': max_weight, 'lightest': min_weight } from solution import classify_boxes def test_classify_empty_list(): result = classify_boxes([]) assert result['categories'] == {'Light': 0, 'Medium': 0, 'Heavy': 0} assert result['heaviest'] == float('-inf') assert result['lightest'] == float('inf') def test_classify_boxes_light_only(): result = classify_boxes([1, 3, 7, 9, 10]) assert result['categories'] == {'Light': 5, 'Medium': 0, 'Heavy': 0} assert result['heaviest'] == 10 assert result['lightest'] == 1 def test_classify_boxes_medium_only(): result = classify_boxes([11, 12, 15, 18, 20]) assert result['categories'] == {'Light': 0, 'Medium': 5, 'Heavy': 0} assert result['heaviest'] == 20 assert result['lightest'] == 11 def test_classify_boxes_heavy_only(): result = classify_boxes([21, 25, 30, 35]) assert result['categories'] == {'Light': 0, 'Medium': 0, 'Heavy': 4} assert result['heaviest'] == 35 assert result['lightest'] == 21 def test_classify_mixed_boxes(): weights = [1, 11, 5, 21, 10, 15, 30, 8, 22] result = classify_boxes(weights) assert result['categories'] == {'Light': 4, 'Medium': 2, 'Heavy': 3} assert result['heaviest'] == 30 assert result['lightest'] == 1","solution":"def classify_boxes(weights): Classify boxes into categories and find the heaviest and lightest boxes. Parameters: weights (list): List of box weights in kilograms. Returns: dict: A dictionary with the number of boxes in each category and the weights of the heaviest and lightest boxes. categories = {'Light': 0, 'Medium': 0, 'Heavy': 0} min_weight = float('inf') max_weight = float('-inf') for weight in weights: if weight <= 10: categories['Light'] += 1 elif 10 < weight <= 20: categories['Medium'] += 1 else: categories['Heavy'] += 1 if weight < min_weight: min_weight = weight if weight > max_weight: max_weight = weight return { 'categories': categories, 'heaviest': max_weight, 'lightest': min_weight }"},{"question":"class FileSystem: def __init__(self): self.files = {} def create(self, file_path, content): Create a new file with the specified file_path and content. If the file already exists, overwrite the content. >>> fs = FileSystem() >>> fs.create(\\"/file1\\", \\"content1\\") >>> fs.read(\\"/file1\\") 'content1' pass def read(self, file_path): Read the content of the specified file. If the file does not exist, return an error message \\"File not found\\". >>> fs = FileSystem() >>> fs.read(\\"/non_existent_file\\") 'File not found' pass def delete(self, file_path): Delete the specified file. If the file does not exist, return an error message \\"File not found\\". >>> fs = FileSystem() >>> fs.create(\\"/file1\\", \\"content1\\") >>> fs.delete(\\"/file1\\") >>> fs.read(\\"/file1\\") 'File not found' pass def move(self, source_path, destination_path): Move the file from source_path to destination_path. If the source file does not exist, return an error message \\"File not found\\". If the destination file already exists, overwrite it. >>> fs = FileSystem() >>> fs.create(\\"/file1\\", \\"content1\\") >>> fs.move(\\"/file1\\", \\"/file2\\") >>> fs.read(\\"/file1\\") 'File not found' >>> fs.read(\\"/file2\\") 'content1' pass","solution":"class FileSystem: def __init__(self): self.files = {} def create(self, file_path, content): self.files[file_path] = content def read(self, file_path): return self.files.get(file_path, \\"File not found\\") def delete(self, file_path): if file_path in self.files: del self.files[file_path] else: return \\"File not found\\" def move(self, source_path, destination_path): if source_path in self.files: self.files[destination_path] = self.files[source_path] del self.files[source_path] else: return \\"File not found\\""},{"question":"def sum_of_unique_twos(lst: List[int]) -> int: Compute the sum of unique integers that occur exactly twice in the provided list. Args: lst (List[int]): The list of integers. Returns: int: The sum of the unique integers that appear exactly twice. >>> sum_of_unique_twos([]) == 0 >>> sum_of_unique_twos([1, 2, 3, 4, 5]) == 0 >>> sum_of_unique_twos([1, 1, 2, 2, 3, 3]) == 6 >>> sum_of_unique_twos([1, 2, 2, 3, 4, 4, 4, 5, 6, 6]) == 8 >>> sum_of_unique_twos([1, 1]) == 1 >>> sum_of_unique_twos([1, 2, 2, 3, 3, 3, 3, 4, 4, 5]) == 6","solution":"def sum_of_unique_twos(lst): Compute the sum of unique integers that occur exactly twice in the provided list. Args: lst (List[int]): The list of integers. Returns: int: The sum of the unique integers that appear exactly twice. counts = {} for num in lst: if num in counts: counts[num] += 1 else: counts[num] = 1 result = 0 for num, count in counts.items(): if count == 2: result += num return result"},{"question":"def top_scorer(scores): Returns the username(s) of the highest scorer(s) with their total points. :param scores: Dictionary with usernames as keys and lists of integers representing points as values :return: List of usernames with the highest total points pass # Unit tests def test_single_top_scorer(): assert top_scorer({ \\"alice\\": [10, 20, 30], \\"bob\\": [5, 25, 35], \\"charlie\\": [20, 20, 20] }) == [\\"bob\\"] def test_multiple_top_scorers(): assert top_scorer({ \\"alice\\": [10, 20, 30], \\"bob\\": [15, 25, 20], \\"charlie\\": [25, 15, 20] }) == [\\"alice\\", \\"bob\\", \\"charlie\\"] def test_no_scores(): assert top_scorer({}) == [] def test_single_entry(): assert top_scorer({ \\"alice\\": [10, 20, 30] }) == [\\"alice\\"] def test_multiple_entries_same_total(): assert top_scorer({ \\"alice\\": [10, 20], \\"bob\\": [15, 15], \\"charlie\\": [5, 25] }) == [\\"alice\\", \\"bob\\", \\"charlie\\"] if __name__ == \\"__main__\\": test_single_top_scorer() test_multiple_top_scorers() test_no_scores() test_single_entry() test_multiple_entries_same_total() print(\\"All tests passed.\\")","solution":"def top_scorer(scores): Returns the username(s) of the highest scorer(s) with their total points. :param scores: Dictionary with usernames as keys and lists of integers representing points as values :return: List of usernames with the highest total points max_score = -1 top_scorers = [] for username, points in scores.items(): total_points = sum(points) if total_points > max_score: max_score = total_points top_scorers = [username] elif total_points == max_score: top_scorers.append(username) return top_scorers"},{"question":"class Book: def __init__(self, book_id, title, author): self.book_id = book_id self.title = title self.author = author self.is_available = True self.issued_to = None self.date_of_issue = None class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author): Adds a new book to the library. Args: book_id (int): Unique identifier for the book. title (str): Title of the book. author (str): Author of the book. Returns: str: Success or error message. pass def remove_book(self, book_id): Removes a book from the library if it is available. Args: book_id (int): Unique identifier for the book. Returns: str: Success or error message. pass def issue_book(self, book_id, member_name, issue_date): Issues a book to a member if it is available. Args: book_id (int): Unique identifier for the book. member_name (str): Name of the member. issue_date (str): Date of issue in YYYY-MM-DD format. Returns: str: Success or error message. pass def return_book(self, book_id): Returns a book to the library. Args: book_id (int): Unique identifier for the book. Returns: str: Success or error message. pass def display_books(self): Displays all books in the library with their status. Returns: list: A list of strings describing each book and its status. pass # Unit Tests import pytest def test_add_book(): lib = Library() assert lib.add_book(1001, \\"Python Programming\\", \\"John Doe\\") == \\"Book added successfully.\\" assert lib.add_book(1001, \\"Advanced Python\\", \\"Jane Smith\\") == \\"Book with this ID already exists.\\" def test_remove_book(): lib = Library() lib.add_book(1001, \\"Python Programming\\", \\"John Doe\\") assert lib.remove_book(1001) == \\"Book removed successfully.\\" assert lib.remove_book(1002) == \\"Book ID not found.\\" lib.add_book(1003, \\"Advanced Python\\", \\"Jane Smith\\") lib.issue_book(1003, \\"Alice\\", \\"2023-10-01\\") assert lib.remove_book(1003) == \\"Book is currently issued and can't be removed.\\" def test_issue_book(): lib = Library() lib.add_book(1001, \\"Python Programming\\", \\"John Doe\\") assert lib.issue_book(1001, \\"Alice\\", \\"2023-10-01\\") == \\"Book issued successfully.\\" assert lib.issue_book(1001, \\"Bob\\", \\"2023-10-02\\") == \\"Book is already issued.\\" assert lib.issue_book(1002, \\"Charlie\\", \\"2023-10-03\\") == \\"Book ID not found.\\" def test_return_book(): lib = Library() lib.add_book(1001, \\"Python Programming\\", \\"John Doe\\") lib.issue_book(1001, \\"Alice\\", \\"2023-10-01\\") assert lib.return_book(1001) == \\"Book returned successfully.\\" assert lib.return_book(1002) == \\"Book ID not found.\\" def test_display_books(): lib = Library() lib.add_book(1001, \\"Python Programming\\", \\"John Doe\\") lib.add_book(1002, \\"Advanced Python\\", \\"Jane Smith\\") lib.issue_book(1001, \\"Alice\\", \\"2023-10-01\\") expected_display = [ \\"ID: 1001, Title: Python Programming, Author: John Doe, Status: Issued to Alice on 2023-10-01\\", \\"ID: 1002, Title: Advanced Python, Author: Jane Smith, Status: Available\\" ] assert lib.display_books() == expected_display","solution":"from datetime import datetime class Book: def __init__(self, book_id, title, author): self.book_id = book_id self.title = title self.author = author self.is_available = True self.issued_to = None self.date_of_issue = None class Library: def __init__(self): self.books = {} def add_book(self, book_id, title, author): if book_id in self.books: return \\"Book with this ID already exists.\\" new_book = Book(book_id, title, author) self.books[book_id] = new_book return \\"Book added successfully.\\" def remove_book(self, book_id): if book_id not in self.books: return \\"Book ID not found.\\" if not self.books[book_id].is_available: return \\"Book is currently issued and can't be removed.\\" del self.books[book_id] return \\"Book removed successfully.\\" def issue_book(self, book_id, member_name, issue_date): if book_id not in self.books: return \\"Book ID not found.\\" if not self.books[book_id].is_available: return \\"Book is already issued.\\" self.books[book_id].is_available = False self.books[book_id].issued_to = member_name self.books[book_id].date_of_issue = issue_date return \\"Book issued successfully.\\" def return_book(self, book_id): if book_id not in self.books: return \\"Book ID not found.\\" self.books[book_id].is_available = True self.books[book_id].issued_to = None self.books[book_id].date_of_issue = None return \\"Book returned successfully.\\" def display_books(self): result = [] for book in self.books.values(): if book.is_available: result.append(f\\"ID: {book.book_id}, Title: {book.title}, Author: {book.author}, Status: Available\\") else: result.append(f\\"ID: {book.book_id}, Title: {book.title}, Author: {book.author}, Status: Issued to {book.issued_to} on {book.date_of_issue}\\") return result"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression containing positive integers and the operators +, -, *, /, and parentheses for changing precedence. Returns the evaluation result or an error message for invalid input. >>> evaluate_expression('2 + 3') == 5 >>> evaluate_expression('10 - 5') == 5 >>> evaluate_expression('3 * 4') == 12 >>> evaluate_expression('12 / 4') == 3 >>> evaluate_expression('2 + 3 * 4') == 14 >>> evaluate_expression('(2 + 3) * 4') == 20 >>> evaluate_expression('10 + 2 * 6') == 22 >>> evaluate_expression('100 * 2 + 12') == 212 >>> evaluate_expression('100 * ( 2 + 12 )') == 1400 >>> evaluate_expression('100 * ( 2 + 12 ) / 14') == 100 >>> evaluate_expression('10 / 0') == 'Error: Division by zero' >>> evaluate_expression('10 +') == 'Error: Invalid input' >>> evaluate_expression('(10 + 5') == 'Error: Invalid input'","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing positive integers and the operators +, -, *, /, and parentheses for changing precedence. Returns the evaluation result or an error message for invalid input. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b if b != 0 else 'Error: Division by zero' def is_number(n): try: int(n) return True except ValueError: return False def shunting_yard(exp): values = [] ops = [] i = 0 while i < len(exp): if exp[i] == ' ': i += 1 continue elif exp[i] == '(': ops.append(exp[i]) elif is_number(exp[i]): val = 0 while i < len(exp) and is_number(exp[i]): val = val * 10 + int(exp[i]) i += 1 values.append(val) i -= 1 elif exp[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(exp[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(exp[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] try: result = shunting_yard(expression) if isinstance(result, str) and 'Error' in result: return result return float(result) except Exception as e: return \\"Error: Invalid input\\""},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists([], []) []","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 # Traverse both lists and merge them in sorted order while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Include remaining elements from list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Include remaining elements from list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def combination_sum2(candidates: List[int], target: int) -> List[List[int]]: Design a function that takes a list of integers and a target integer, and returns all unique combinations of elements (of any length) from the list that sum up to the target value. Each number in the list may only be used once in each combination. The function should return a list of lists, where each inner list is a unique combination that sums up to the target. The combinations should be listed in lexicographic order (sorted order). >>> combination_sum2([10,1,2,7,6,1,5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([2,5,2,1,2], 5) [[1, 2, 2], [5]] from typing import List def test_combination_sum2_example1(): candidates = [10,1,2,7,6,1,5] target = 8 result = combination_sum2(candidates, target) expected = [ [1,1,6], [1,2,5], [1,7], [2,6] ] assert result == expected def test_combination_sum2_example2(): candidates = [2,5,2,1,2] target = 5 result = combination_sum2(candidates, target) expected = [ [1,2,2], [5] ] assert result == expected def test_combination_sum2_empty_candidates(): candidates = [] target = 5 result = combination_sum2(candidates, target) expected = [] assert result == expected def test_combination_sum2_no_combinations(): candidates = [1, 2, 3] target = 7 result = combination_sum2(candidates, target) expected = [] assert result == expected def test_combination_sum2_negative_target(): candidates = [1, 2, 3] target = -1 result = combination_sum2(candidates, target) expected = [] assert result == expected","solution":"def combination_sum2(candidates, target): candidates.sort() results = [] def backtrack(start, target, comb): if target == 0: results.append(list(comb)) return if target < 0: return prev = -1 for i in range(start, len(candidates)): if candidates[i] == prev: continue if candidates[i] > target: break comb.append(candidates[i]) backtrack(i + 1, target - candidates[i], comb) comb.pop() prev = candidates[i] backtrack(0, target, []) return results"},{"question":"def is_prime(num): Helper function to determine if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primes_and_smallest(nums): Returns a list of prime numbers from the input list and the smallest prime number. :param nums: List of integers. :return: Tuple containing a list of prime numbers and the smallest prime number. If no prime numbers are found, returns an empty list and None. >>> find_primes_and_smallest([]) == ([], None) >>> find_primes_and_smallest([1, 4, 6, 8, 9, 10]) == ([], None) >>> find_primes_and_smallest([2, 3, 5, 7, 11]) == ([2, 3, 5, 7, 11], 2) >>> find_primes_and_smallest([10, 15, 3, 20, 7, 12]) == ([3, 7], 3) >>> find_primes_and_smallest([13]) == ([13], 13) >>> find_primes_and_smallest(list(range(1, 100))) == ([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97], 2)","solution":"def is_prime(num): Helper function to determine if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primes_and_smallest(nums): Returns a list of prime numbers from the input list and the smallest prime number. :param nums: List of integers. :return: Tuple containing a list of prime numbers and the smallest prime number. If no prime numbers are found, returns an empty list and None. primes = [num for num in nums if is_prime(num)] if primes: return primes, min(primes) else: return [], None # Time Complexity Explanation: # The time complexity of the \`is_prime\` function is O(sqrt(n)) where n is the number being checked. # The overall time complexity of the \`find_primes_and_smallest\` function is O(m * sqrt(n)), # where m is the number of elements in the input list and n is the average size of the numbers."},{"question":"def count_unique_characters(s: str) -> dict: Returns a dictionary with the count of each unique character in the string, ignoring case. >>> count_unique_characters(\\"Programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> count_unique_characters(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> count_unique_characters(\\"aaaa\\") {'a': 4} >>> count_unique_characters(\\"\\") {} >>> count_unique_characters(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_unique_characters(\\"1234!@\\") {'1': 1, '2': 1, '3': 1, '4': 1, '!': 1, '@': 1}","solution":"def count_unique_characters(s): Returns a dictionary with the count of each unique character in the string, ignoring case. :param s: Input string :type s: str :return: Dictionary of character counts :rtype: dict s = s.lower() char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def flatten_dict(d, parent_key=()): Flattens a nested dictionary so that keys are tuples representing the path to each leaf node, and values are the corresponding leaf node values. Args: d (dict): The nested dictionary to flatten. parent_key (tuple): The current path (used for recursion). Returns: dict: The flattened dictionary. items = {} Placeholder for Solution # for k, v in d.items(): new_key = parent_key + (k,) if isinstance(v, dict): items.update(flatten_dict(v, new_key)) else: items[new_key] = v return items def erroneous_flatten_dict(d, parent_key=\\"\\"): Attempts to flatten a nested dictionary but fails due to a common mistake. Args: d (dict): The nested dictionary to flatten. parent_key (str): The current path (used for recursion). Returns: dict: The flattened dictionary. items = {} Placeholder for Erroneous Code # for k, v in d.items(): new_key = parent_key + \\".\\" + k if parent_key else k if isinstance(v, dict): items.update(erroneous_flatten_dict(v, new_key)) else: items[new_key] = v return items def test_flatten_simple_dict(): assert flatten_dict({'a': 1, 'b': 2}) == {('a',): 1, ('b',): 2} def test_flatten_nested_dict(): assert flatten_dict({'a': {'b': 2}}) == {('a', 'b'): 2} def test_flatten_complex_nested_dict(): nested_dict = { 'a': { 'b': { 'c': 1 }, 'd': 2 }, 'e': 3 } expected = { ('a', 'b', 'c'): 1, ('a', 'd'): 2, ('e',): 3 } assert flatten_dict(nested_dict) == expected def test_erroneous_code(): assert erroneous_flatten_dict({'a': {'b.c': 2}}) == {'a.b.c': 2} def test_flatten_with_non_string_keys(): input_dict = { 1: { 2: { 3: 4 } } } expected = { (1, 2, 3): 4 } assert flatten_dict(input_dict) == expected def main(): test_flatten_simple_dict() test_flatten_nested_dict() test_flatten_complex_nested_dict() test_erroneous_code() test_flatten_with_non_string_keys() print(\\"All test cases passed!\\") main()","solution":"def flatten_dict(d, parent_key=()): Flattens a nested dictionary so that keys are tuples representing the path to each leaf node, and values are the corresponding leaf node values. Args: d (dict): The nested dictionary to flatten. parent_key (tuple): The current path (used for recursion). Returns: dict: The flattened dictionary. items = {} for k, v in d.items(): new_key = parent_key + (k,) if isinstance(v, dict): items.update(flatten_dict(v, new_key)) else: items[new_key] = v return items # Erroneous Code def erroneous_flatten_dict(d, parent_key=\\"\\"): Attempts to flatten a nested dictionary but fails due to a common mistake. Args: d (dict): The nested dictionary to flatten. parent_key (str): The current path (used for recursion). Returns: dict: The flattened dictionary. items = {} for k, v in d.items(): new_key = parent_key + \\".\\" + k if parent_key else k if isinstance(v, dict): items.update(erroneous_flatten_dict(v, new_key)) else: items[new_key] = v return items # Mistake: Using string concatenation and '.' as separator instead of tuples. # This can cause issues when keys have '.' in them or when performing operations that depend on immutable keys."},{"question":"def allocate_resources(zones, available_resources): Allocate resources to zones based on priority using a greedy algorithm. zones: List of dictionaries representing each zone with a requirement and priority. Example: [{'zone': 'A', 'priority': 5, 'requirements': {'food': 10, 'water': 20}}, ...] available_resources: Dictionary representing available resources. Example: {'food': 100, 'water': 50, 'medical': 30, 'shelter': 20} Returns: A list of allocation plans and the total satisfaction score. pass from allocate_resources import allocate_resources def test_allocate_resources_basic(): zones = [ {'zone': 'A', 'priority': 5, 'requirements': {'food': 5, 'water': 10}}, {'zone': 'B', 'priority': 3, 'requirements': {'food': 8, 'water': 5}}, {'zone': 'C', 'priority': 8, 'requirements': {'food': 2, 'water': 4}} ] available_resources = {'food': 10, 'water': 15} allocation_plan, score = allocate_resources(zones, available_resources) assert allocation_plan == [ {'zone': 'C', 'allocation': {'food': 2, 'water': 4}}, {'zone': 'A', 'allocation': {'food': 5, 'water': 10}}, {'zone': 'B', 'allocation': {'food': 3, 'water': 1}} ] assert score == 5*5 + 10*5 + 2*8 + 4*8 + 3*3 + 1*3 def test_excess_resources(): zones = [ {'zone': 'A', 'priority': 2, 'requirements': {'food': 1}}, {'zone': 'B', 'priority': 5, 'requirements': {'food': 2}} ] available_resources = {'food': 10} allocation_plan, score = allocate_resources(zones, available_resources) assert allocation_plan == [ {'zone': 'B', 'allocation': {'food': 2}}, {'zone': 'A', 'allocation': {'food': 1}} ] assert score == 2*5 + 1*2 def test_insufficient_resources(): zones = [ {'zone': 'A', 'priority': 4, 'requirements': {'food': 5, 'water': 8}}, {'zone': 'B', 'priority': 1, 'requirements': {'food': 6, 'water': 2}} ] available_resources = {'food': 7, 'water': 5} allocation_plan, score = allocate_resources(zones, available_resources) assert allocation_plan == [ {'zone': 'A', 'allocation': {'food': 5, 'water': 5}}, {'zone': 'B', 'allocation': {'food': 2, 'water': 0}} ] assert score == 4*5 + 4*5 + 1*2 def test_equal_priority(): zones = [ {'zone': 'A', 'priority': 4, 'requirements': {'food': 5}}, {'zone': 'B', 'priority': 4, 'requirements': {'food': 6}} ] available_resources = {'food': 5} allocation_plan, score = allocate_resources(zones, available_resources) assert allocation_plan in [ [{'zone': 'A', 'allocation': {'food': 5}}, {'zone': 'B', 'allocation': {'food': 0}}], [{'zone': 'B', 'allocation': {'food': 5}}, {'zone': 'A', 'allocation': {'food': 0}}] ] assert score in [4*5, 4*5] def test_multiple_resources(): zones = [ {'zone': 'A', 'priority': 2, 'requirements': {'food': 2, 'water': 1}}, {'zone': 'B', 'priority': 6, 'requirements': {'food': 1, 'water': 4}} ] available_resources = {'food': 3, 'water': 4} allocation_plan, score = allocate_resources(zones, available_resources) assert allocation_plan == [ {'zone': 'B', 'allocation': {'food': 1, 'water': 4}}, {'zone': 'A', 'allocation': {'food': 2, 'water': 0}} ] assert score == 1*6 + 4*6 + 2*2","solution":"# Implementation of the solution based on the given task specification import heapq def allocate_resources(zones, available_resources): Allocate resources to zones based on priority using a greedy algorithm. zones: List of dictionaries representing each zone with a requirement and priority. Example: [{'zone': 'A', 'priority': 5, 'requirements': {'food': 10, 'water': 20}}, ...] available_resources: Dictionary representing available resources. Example: {'food': 100, 'water': 50, 'medical': 30, 'shelter': 20} Returns: A list of allocation plans and the total satisfaction score. # Create a max-heap based on priority zones = sorted(zones, key=lambda x: -x['priority']) allocation_plan = [] total_satisfaction_score = 0 # First pass: Allocate resources based on priority for zone in zones: allocation = {} satisfaction = 0 for resource, req_amount in zone['requirements'].items(): if available_resources.get(resource, 0) >= req_amount: allocation[resource] = req_amount available_resources[resource] -= req_amount satisfaction += req_amount * zone['priority'] else: allocation[resource] = available_resources.get(resource, 0) satisfaction += available_resources.get(resource, 0) * zone['priority'] available_resources[resource] = 0 allocation_plan.append({ 'zone': zone['zone'], 'allocation': allocation }) total_satisfaction_score += satisfaction return allocation_plan, total_satisfaction_score"},{"question":"import re def basic_calculator(expression: str) -> float: Simulates a basic calculator that can handle addition, subtraction, multiplication, and division operations, following the order of operations. Parameters: expression (str): A string containing the mathematical expression. Returns: float or str: The calculated result as a floating-point number, or an appropriate error message if the input is invalid. Examples: >>> basic_calculator(\\"3 + 5\\") == 8.0 >>> basic_calculator(\\"10 - 3\\") == 7.0 >>> basic_calculator(\\"4 * 5\\") == 20.0 >>> basic_calculator(\\"20 / 4\\") == 5.0 >>> basic_calculator(\\"2 + 3 * 4\\") == 14.0 >>> basic_calculator(\\"10 + 2 * 6\\") == 22.0 >>> basic_calculator(\\"100 * 2 + 12\\") == 212.0 >>> basic_calculator(\\"100 * ( 2 + 12 )\\") == 1400.0 >>> basic_calculator(\\"100 * ( 2 + 12 ) / 14\\") == 100.0 >>> basic_calculator(\\"(1 + 2) * 3\\") == 9.0 >>> basic_calculator(\\"5 / 0\\") == \\"Error: Division by zero.\\" >>> basic_calculator(\\"5+abc\\") == \\"Error: Invalid characters in expression.\\" >>> basic_calculator(\\"5 + * 2\\") == \\"Error: Invalid expression. invalid syntax (<string>, line 1)\\"","solution":"import re def basic_calculator(expression): Simulates a basic calculator that can handle addition, subtraction, multiplication, and division operations, following the order of operations. Parameters: expression (str): A string containing the mathematical expression. Returns: float or str: The calculated result as a floating-point number, or an appropriate error message if the input is invalid. # Clean the expression to remove unwanted spaces expression = expression.replace(' ', '') # Basic input validation if not re.match(r'^[d+-*/.()]+', expression): return \\"Error: Invalid characters in expression.\\" try: # Using eval to calculate the expression following the order of operations result = eval(expression) return float(result) except ZeroDivisionError: return \\"Error: Division by zero.\\" except Exception as e: return f\\"Error: Invalid expression. {str(e)}\\""},{"question":"def longest_arith_seq_length(arr: List[int]) -> int: Design a function that accepts a list of integers and returns the length of the longest subsequence that forms an arithmetic progression. The function should handle both positive and negative integers. An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3 >>> longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8]) 4 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([5]) 1 >>> longest_arith_seq_length([5, 10, 22, 13]) 2 >>> longest_arith_seq_length([-3, -1, 1, 3, 5, 7]) 6 >>> longest_arith_seq_length([5, 5, 5, 5, 5]) 5","solution":"def longest_arith_seq_length(arr): if not arr: return 0 if len(arr) == 1: return 1 n = len(arr) dp = [{} for _ in range(n)] max_len = 1 for j in range(1, n): for i in range(j): diff = arr[j] - arr[i] if diff in dp[i]: dp[j][diff] = dp[i][diff] + 1 else: dp[j][diff] = 2 max_len = max(max_len, dp[j][diff]) return max_len"},{"question":"def process_transactions(initial_balance, transactions): Function to process a list of financial transactions. :param initial_balance: float, initial amount of money :param transactions: list of tuples, each containing a string ('deposit' or 'withdraw') and a float :return: float, the final balance after processing all valid transactions Example: >>> process_transactions(100.0, [('deposit', 50.0), ('withdraw', 25.0)]) 125.0 >>> process_transactions(100.0, [('withdraw', 200.0), ('deposit', 50.0)]) 150.0 >>> process_transactions(100.0, [('deposit', 'invalid_amount'), ('withdraw', 50.0)]) 50.0 >>> process_transactions(100.0, [('transfer', 50.0), ('deposit', 25.0)]) 125.0 >>> process_transactions(100.0, [('invalid_structure',)]) 100.0 pass # Example test cases print(process_transactions(100.0, [('deposit', 50.0), ('withdraw', 25.0), ('withdraw', 150.0), ('deposit', 'not_a_number'), ('transfer', 100.0)]))","solution":"def process_transactions(initial_balance, transactions): Function to process a list of financial transactions. :param initial_balance: float, initial amount of money :param transactions: list of tuples, each containing a string ('deposit' or 'withdraw') and a float :return: float, the final balance after processing all valid transactions for transaction in transactions: try: operation, amount = transaction if operation not in ['deposit', 'withdraw']: print(f\\"Unknown transaction type '{operation}' skipped.\\") continue if not isinstance(amount, (float, int)): print(f\\"Invalid amount value '{amount}' skipped.\\") continue if operation == 'deposit': initial_balance += amount elif operation == 'withdraw': if initial_balance - amount < 0: print(\\"Insufficient funds for withdraw, transaction skipped.\\") else: initial_balance -= amount except ValueError: print(\\"Invalid transaction structure, skipped.\\") return initial_balance"},{"question":"import random def guessing_game(): Runs a number guessing game where the user has to guess a randomly generated number between 1 and 50. number_to_guess = random.randint(1, 50) attempts = 0 while True: try: guess = int(input(\\"Guess the number (between 1 and 50): \\")) attempts += 1 if guess < 1 or guess > 50: print(\\"Please guess a number within the range.\\") continue if guess < number_to_guess: print(\\"Too low. Try again.\\") elif guess > number_to_guess: print(\\"Too high. Try again.\\") else: print(f\\"Correct! It took you {attempts} attempts.\\") break except ValueError: print(\\"Invalid input. Please enter an integer.\\")","solution":"import random def guessing_game(): Runs a number guessing game where the user has to guess a randomly generated number between 1 and 50. number_to_guess = random.randint(1, 50) attempts = 0 while True: try: guess = int(input(\\"Guess the number (between 1 and 50): \\")) attempts += 1 if guess < 1 or guess > 50: print(\\"Please guess a number within the range.\\") continue if guess < number_to_guess: print(\\"Too low. Try again.\\") elif guess > number_to_guess: print(\\"Too high. Try again.\\") else: print(f\\"Correct! It took you {attempts} attempts.\\") break except ValueError: print(\\"Invalid input. Please enter an integer.\\") # Uncomment to test the guessing game interactively # guessing_game()"},{"question":"from typing import List def longestLexicographicalPath(grid: List[str]) -> int: You are given a grid of characters where each cell contains a character from a-z. Find the longest path in the grid where each consecutive character is lexicographically greater than the previous one. The path can start from any cell, and you can move in any of the four directions: up, down, left, or right. Return the length of the longest path. >>> grid = [ ... \\"abcd\\", ... \\"bcda\\", ... \\"cdef\\", ... \\"dabc\\" ... ] >>> longestLexicographicalPath(grid) 6 >>> grid = [ ... \\"a\\", ... \\"b\\", ... \\"c\\", ... \\"d\\" ... ] >>> longestLexicographicalPath(grid) 4","solution":"from typing import List, Tuple def longestLexicographicalPath(grid: List[str]) -> int: rows = len(grid) cols = len(grid[0]) dp = [[-1] * cols for _ in range(rows)] # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x: int, y: int) -> int: if dp[x][y] != -1: return dp[x][y] max_length = 1 # each cell is a path of length 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and ord(grid[nx][ny]) == ord(grid[x][y]) + 1: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return dp[x][y] longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"from typing import List from collections import Counter def word_frequency(words: List[str]) -> List[str]: Takes a list of words and returns a list of words sorted by their frequency in descending order. If two words have the same frequency, they are sorted alphabetically. >>> word_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) [\\"apple\\", \\"banana\\", \\"orange\\"] >>> word_frequency([\\"apple\\"]) [\\"apple\\"] >>> word_frequency([\\"apple\\", \\"banana\\", \\"orange\\"]) [\\"apple\\", \\"banana\\", \\"orange\\"] >>> word_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> word_frequency([\\"banana\\", \\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"banana\\"]) [\\"banana\\", \\"apple\\", \\"orange\\"]","solution":"from collections import Counter from typing import List def word_frequency(words: List[str]) -> List[str]: Takes a list of words and returns a list of words sorted by their frequency in descending order. If two words have the same frequency, they are sorted alphabetically. word_count = Counter(words) sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return [word for word, _ in sorted_words]"},{"question":"def max_possible_result(expression: str) -> int: Returns the maximum possible result by properly placing parentheses into the mathematical expression consisting of positive integers, '+' and '*' operators only. >>> max_possible_result(\\"2+3*2\\") 10 >>> max_possible_result(\\"1+2*3+4*5\\") 105 >>> max_possible_result(\\"1+2\\") 3 >>> max_possible_result(\\"2*3\\") 6 >>> max_possible_result(\\"2\\") 2 >>> max_possible_result(\\"2*3+4\\") 14 >>> max_possible_result(\\"2+3*4\\") 20 >>> max_possible_result(\\"1*2+3*4\\") 20","solution":"def max_possible_result(expression): Returns the maximum possible result by properly placing parentheses into the mathematical expression consisting of positive integers, '+' and '*' operators only. # Cache for memoization memo = {} def compute(left, right): # Base Case: If the substring is a single number, convert and return it. if left == right: return int(expression[left]) # If the result is already computed, return it from the memo table. if (left, right) in memo: return memo[(left, right)] max_result = float('-inf') # Traverse every operator in the substring for i in range(left, right): if expression[i] == '+' or expression[i] == '*': left_result = compute(left, i - 1) right_result = compute(i + 1, right) if expression[i] == '+': result = left_result + right_result elif expression[i] == '*': result = left_result * right_result max_result = max(max_result, result) memo[(left, right)] = max_result return max_result return compute(0, len(expression) - 1)"},{"question":"import re from typing import List, Dict def sentiment_analysis(reviews: List[str]) -> Dict[str, List[str]]: Analyzes the sentiments of product reviews and categorizes them into positive and negative. Args: reviews (list of str): A list of product reviews. Returns: dict: A dictionary with 'positive' and 'negative' keys mapping to lists of reviews. >>> sentiment_analysis([\\"Great product!\\", \\"Excellent quality.\\", \\"Fantastic service!\\"]) {'positive': [\\"Great product!\\", \\"Excellent quality.\\", \\"Fantastic service!\\"], 'negative': []} >>> sentiment_analysis([\\"Bad experience.\\", \\"Terrible product.\\", \\"Worst purchase ever.\\"]) {'positive': [], 'negative': [\\"Bad experience.\\", \\"Terrible product.\\", \\"Worst purchase ever.\\"]} >>> sentiment_analysis([\\"Good purchase!\\", \\"Horrible support.\\", \\"Amazing features.\\", \\"Poor build quality.\\"]) {'positive': [\\"Good purchase!\\", \\"Amazing features.\\"], 'negative': [\\"Horrible support.\\", \\"Poor build quality.\\"]} >>> sentiment_analysis([\\"This product is okay.\\", \\"Just an average item.\\"]) {'positive': [], 'negative': []} >>> sentiment_analysis([\\"I absolutely LOVE this!\\", \\"I hate it so much...\\"]) {'positive': [\\"I absolutely LOVE this!\\"], 'negative': [\\"I hate it so much...\\"]} >>> sentiment_analysis([\\"This is amazing!!!\\", \\"Terrible, just terrible...\\"]) {'positive': [\\"This is amazing!!!\\"], 'negative': [\\"Terrible, just terrible...\\"]}","solution":"import re def sentiment_analysis(reviews): Analyzes the sentiments of product reviews and categorizes them into positive and negative. Args: reviews (list of str): A list of product reviews. Returns: dict: A dictionary with 'positive' and 'negative' keys mapping to lists of reviews. # Predefined positive and negative words positive_words = {'good', 'great', 'excellent', 'amazing', 'fantastic', 'superb', 'love'} negative_words = {'bad', 'terrible', 'poor', 'horrible', 'awful', 'worst', 'hate'} # Result dictionary sentiments = {'positive': [], 'negative': []} for review in reviews: # Clean and split the review into words, handling case insensitivity and punctuation words = re.findall(r'bw+b', review.lower()) if any(word in positive_words for word in words): sentiments['positive'].append(review) elif any(word in negative_words for word in words): sentiments['negative'].append(review) return sentiments"},{"question":"def process_ages(ages): Processes a list of ages to compute age differences, average age, and median age. Args: ages (list): A list of integers representing ages. Returns: tuple: A tuple containing the list of age differences, average age, and median age. >>> process_ages([25, 30, 35, 40, 45]) ([0, 5, 10, 15, 20], 35, 35) >>> process_ages([]) ([], None, None) >>> process_ages([25]) ([0], 25, 25) >>> process_ages([25, 30, 35, 40]) ([0, 5, 10, 15], 32.5, 32.5) >>> process_ages([-5, 0, 5, 10]) ([0, 5, 10, 15], 2.5, 2.5)","solution":"def process_ages(ages): Processes a list of ages to compute age differences, average age, and median age. Args: ages (list): A list of integers representing ages. Returns: tuple: A tuple containing the list of age differences, average age, and median age. if not ages: return ([], None, None) min_age = min(ages) age_differences = [age - min_age for age in ages] average_age = sum(ages) / len(ages) sorted_ages = sorted(ages) n = len(ages) if n % 2 == 0: median_age = (sorted_ages[n//2 - 1] + sorted_ages[n//2]) / 2 else: median_age = sorted_ages[n//2] return (age_differences, average_age, median_age)"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping intervals and return a list of merged intervals. If any interval has the start time greater than the end time, raises a ValueError. >>> merge_intervals([(1, 3), (2, 6), (8, 10), (9, 18)]) [(1, 6), (8, 18)] >>> merge_intervals([(3, 1), (5, 10)]) ValueError: Interval (3, 1) is invalid because the start time is greater than the end time.","solution":"def merge_intervals(intervals): if not intervals: return intervals # Sort intervals by start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for interval in intervals: start, end = interval if start > end: raise ValueError(f\\"Interval ({start}, {end}) is invalid because the start time is greater than the end time.\\") if start <= current_end: # Overlapping intervals current_end = max(current_end, end) else: # Non-overlapping interval, add the previous interval to the merged list merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"def sum_tuples(data): Takes a list of tuples where each tuple contains a string and a number, and returns a dictionary where the keys are the strings from the tuples and the values are the sums of the numbers corresponding to each string. >>> sum_tuples([('apple', 1)]) {'apple': 1} >>> sum_tuples([('apple', 1), ('banana', 2), ('apple', 3), ('banana', 4), ('cherry', 5)]) {'apple': 4, 'banana': 6, 'cherry': 5} >>> sum_tuples([]) {} >>> sum_tuples([('apple', 1), ('apple', 2), ('apple', 3)]) {'apple': 6} >>> sum_tuples([('apple', -1), ('banana', -2), ('apple', -3), ('banana', 4)]) {'apple': -4, 'banana': 2}","solution":"def sum_tuples(data): Takes a list of tuples where each tuple contains a string and a number, and returns a dictionary where the keys are the strings from the tuples and the values are the sums of the numbers corresponding to each string. result = {} for key, value in data: if key in result: result[key] += value else: result[key] = value return result"},{"question":"from typing import List def first_missing_positive(nums: List[int]) -> int: Given an array of integers, find the first missing positive integer in linear time and constant space. You can modify the input array in-place. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) # First step is to separate positive numbers from non-positive numbers for i in range(n): while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]: # Swap nums[i] with nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # After rearrangement, the first index which doesn't have the correct number means it is missing for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers in the range 1 to n are present, the missing number is n + 1 return n + 1"},{"question":"from threading import Lock, Thread import random import time class Bank: def __init__(self): self.accounts = {} self.lock = Lock() self.next_account_number = 1 def create_account(self): Creates a new account with a unique account number. Returns the new account number. pass def deposit(self, account_number, amount): Deposits the specified amount into the account with the given account number. Returns True if successful, False otherwise. pass def withdraw(self, account_number, amount): Withdraws the specified amount from the account with the given account number, ensuring the account balance doesn't become negative. Returns True if successful, False otherwise. pass def transfer(self, from_account, to_account, amount): Transfers the specified amount from one account to another. Returns True if successful, False otherwise. pass def get_balance(self, account_number): Returns the balance of the account with the given account number. pass # Testing the implementation import pytest def test_create_account(): bank = Bank() account_number = bank.create_account() assert account_number == 1 account_balance = bank.get_balance(account_number) assert account_balance == 0 def test_deposit_withdraw(): bank = Bank() account_number = bank.create_account() assert bank.deposit(account_number, 100) == True assert bank.get_balance(account_number) == 100 assert bank.withdraw(account_number, 50) == True assert bank.get_balance(account_number) == 50 assert bank.withdraw(account_number, 100) == False def test_transfer(): bank = Bank() acc1 = bank.create_account() acc2 = bank.create_account() bank.deposit(acc1, 100) assert bank.transfer(acc1, acc2, 50) == True assert bank.get_balance(acc1) == 50 assert bank.get_balance(acc2) == 50 assert bank.transfer(acc1, acc2, 60) == False def test_concurrent_operations(): bank = Bank() acc1 = bank.create_account() acc2 = bank.create_account() acc3 = bank.create_account() def random_operations(bank, account_numbers): for _ in range(100): operation = random.choice(['deposit', 'withdraw', 'transfer']) account = random.choice(account_numbers) amount = random.randint(1, 50) if operation == 'deposit': bank.deposit(account, amount) elif operation == 'withdraw': bank.withdraw(account, amount) elif operation == 'transfer': target_account = random.choice(account_numbers) if account != target_account: bank.transfer(account, target_account, amount) time.sleep(0.01) threads = [ Thread(target=random_operations, args=(bank, [acc1, acc2, acc3])), Thread(target=random_operations, args=(bank, [acc1, acc2, acc3])), Thread(target=random_operations, args=(bank, [acc1, acc2, acc3])) ] for t in threads: t.start() for t in threads: t.join() total_balance = bank.get_balance(acc1) + bank.get_balance(acc2) + bank.get_balance(acc3) assert total_balance >= 0 # Ensure total balance is non-negative pytest.main(['-v'])","solution":"from threading import Lock class Bank: def __init__(self): self.accounts = {} self.lock = Lock() self.next_account_number = 1 def create_account(self): with self.lock: account_number = self.next_account_number self.accounts[account_number] = 0 self.next_account_number += 1 return account_number def deposit(self, account_number, amount): with self.lock: if account_number in self.accounts: self.accounts[account_number] += amount return True else: return False def withdraw(self, account_number, amount): with self.lock: if account_number in self.accounts and self.accounts[account_number] >= amount: self.accounts[account_number] -= amount return True else: return False def transfer(self, from_account, to_account, amount): with self.lock: if from_account in self.accounts and to_account in self.accounts: if self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount return True return False def get_balance(self, account_number): with self.lock: if account_number in self.accounts: return self.accounts[account_number] else: return None"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the characters of each word in a given sentence while maintaining the word order. Example: >>> reverse_words_in_sentence(\\"Hello World\\") 'olleH dlroW' >>> reverse_words_in_sentence(\\"OpenAI rocks\\") 'IAnepO skcor' >>> reverse_words_in_sentence(\\"Python\\") 'nohtyP' >>> reverse_words_in_sentence(\\"\\") '' >>> reverse_words_in_sentence(\\"Hello, World!\\") ',olleH !dlroW'","solution":"def reverse_words_in_sentence(sentence): Reverses the characters of each word in the sentence while maintaining the word order. Parameters: sentence (str): The input sentence to be transformed. Returns: str: The sentence with each word reversed. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def gcd(x, y): Calculate the greatest common divisor (GCD) of x and y using the Euclidean algorithm. pass def least_common_multiple(a, b): Calculate and return the least common multiple (LCM) of two positive integers a and b using the relationship between LCM and GCD. Raise ValueError if a or b are not positive integers. >>> least_common_multiple(4, 5) 20 >>> least_common_multiple(10, 15) 30 >>> least_common_multiple(3, 7) 21 >>> least_common_multiple(6, 8) 24 >>> least_common_multiple(100, 25) 100 >>> least_common_multiple(21, 6) 42 >>> least_common_multiple(1, 5) 5 >>> least_common_multiple(1, 1) 1 pass","solution":"def gcd(x, y): Calculate the greatest common divisor of x and y using the Euclidean algorithm. while y: x, y = y, x % y return x def least_common_multiple(a, b): Calculate and return the least common multiple (LCM) of two positive integers a and b using the relationship between LCM and GCD. LCM(a, b) = abs(a*b) // GCD(a, b). if a <= 0 or b <= 0: raise ValueError(\\"Input values must be positive integers.\\") gcd_value = gcd(a, b) return abs(a * b) // gcd_value"},{"question":"def split_list(arr): Given a list of integers, split the list into two sublists such that the difference between the sum of the first sublist and the sum of the second sublist is minimized. Your program should return the two sublists. >>> split_list([1, 1, 1, 1, 1, 1]) ([1, 1, 1], [1, 1, 1]) >>> split_list([5, 8, 6, 7, 3]) ([3, 8], [5, 6, 7]) >>> split_list([10]) ([10], []) >>> split_list([]) ([], []) >>> split_list([10, 20, 30, 40, 50]) ([20, 30], [10, 40, 50])","solution":"def split_list(arr): Given a list of integers, split the list into two sublists such that the difference between the sum of the two sublists is minimized. The function returns the two sublists. n = len(arr) total_sum = sum(arr) target_sum = total_sum // 2 # Create a DP array dp = [[False] * (target_sum + 1) for _ in range(n + 1)] # Initialize DP array for i in range(n + 1): dp[i][0] = True # Fill the DP array for i in range(1, n + 1): for j in range(1, target_sum + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the maximum value where subset is possible and has the closest value to target_sum closest_sum = 0 for j in range(target_sum, -1, -1): if dp[n][j]: closest_sum = j break # Traceback to find the elements of each subset subset1 = [] subset2 = arr[:] w = closest_sum for i in range(n, 0, -1): if not dp[i-1][w] and w != 0: subset1.append(arr[i-1]) subset2.remove(arr[i-1]) w -= arr[i-1] return subset1, subset2"},{"question":"def char_frequency(s: str) -> dict: Returns the frequency of each alphabetic character in the string s. Ignores case sensitivity and excludes non-alphabetical characters. >>> char_frequency(\\"Hello, World! 123\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"12345!@#%\\") {} >>> char_frequency(\\"aaaaa\\") {'a': 5} >>> char_frequency(\\"AaAaA\\") {'a': 5} >>> char_frequency(\\"Hello!!!\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> alphabet = 'abcdefghijklmnopqrstuvwxyz' >>> char_frequency(alphabet) {char: 1 for char in alphabet} >>> char_frequency(\\"a 1b2 c3\\") {'a': 1, 'b': 1, 'c': 1}","solution":"def char_frequency(s: str) -> dict: Returns a dictionary containing the frequency of each alphabetic character in the string s. Case is ignored, and non-alphabetical characters are excluded. freq = {} for char in s.lower(): if char.isalpha(): if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"def filter_primes(numbers: List[int]) -> List[int]: Create a function that accepts a list of integers and returns a new list containing only the prime numbers from the original list. The function should efficiently check for primality to ensure optimal performance for large lists. >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([1, 4, 6, 8, 9, 10]) [] >>> filter_primes([1, 2, 4, 5, 6, 7, 15, 17, 19, 20, 21]) [2, 5, 7, 17, 19] >>> filter_primes([]) [] >>> input_numbers = list(range(100)) >>> expected_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> filter_primes(input_numbers) == expected_primes True","solution":"def is_prime(n): Check if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the input list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def three_sum_closest(nums: List[int], target: int) -> List[int]: Returns a list of three integers in nums that sum up closest to the target. If nums contains fewer than three integers, return an empty list. >>> three_sum_closest([-1, 2, 1, -4], 1) [-1, 2, 1] >>> three_sum_closest([1, 2], 3) [] >>> sorted(three_sum_closest([1, 1, -1, -1, 3], 3)) sorted([-1, 1, 3])","solution":"from typing import List def three_sum_closest(nums: List[int], target: int) -> List[int]: Returns a list of three integers in nums that sum up closest to the target. If nums contains fewer than three integers, return an empty list. if len(nums) < 3: return [] nums.sort() closest_sum = float('inf') closest_triplet = [] for i in range(len(nums) - 2): left = i + 1 right = len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum closest_triplet = [nums[i], nums[left], nums[right]] if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_triplet return closest_triplet"},{"question":"import csv class TicketBookingSystem: Design a Python class that simulates a ticket booking system for an event. The system should manage seat reservations, ensuring that no duplicate bookings are made for the same seat. The program should read the initial seating arrangement from a CSV file, which includes the seat number, row, and whether the seat is available or booked. Users should be able to: - View available seats. - Reserve a seat by entering the seat number. - Cancel a reservation by entering the seat number. - Save the updated seating arrangement back to the CSV file. Implement proper error checking to handle invalid seat numbers, duplicated reservations, and cancellations for seats that are not yet reserved. Optimize the program to handle operations efficiently even with a large seating arrangement. Provide a simple command-line interface for the user to interact with the system. >>> csv_file = 'test_seating.csv' >>> system = TicketBookingSystem(csv_file) >>> system.view_available_seats() {'A1': {'row': '1', 'available': True}, 'B1': {'row': '2', 'available': True}, 'B2': {'row': '2', 'available': True}} >>> system.reserve_seat('A1') >>> system.view_available_seats() {'B1': {'row': '2', 'available': True}, 'B2': {'row': '2', 'available': True}} >>> system.cancel_reservation('A1') >>> system.view_available_seats() {'A1': {'row': '1', 'available': True}, 'B1': {'row': '2', 'available': True}, 'B2': {'row': '2', 'available': True}} def __init__(self, csv_file): pass def _load_seats(self): pass def save_seats(self): pass def view_available_seats(self): pass def reserve_seat(self, seat_number): pass def cancel_reservation(self, seat_number): pass","solution":"import csv class TicketBookingSystem: def __init__(self, csv_file): self.csv_file = csv_file self.seats = self._load_seats() def _load_seats(self): seats = {} with open(self.csv_file, mode='r') as file: reader = csv.DictReader(file) for row in reader: seats[row['seat_number']] = { 'row': row['row'], 'available': row['available'] == 'yes' } return seats def save_seats(self): fieldnames = ['seat_number', 'row', 'available'] with open(self.csv_file, mode='w', newline='') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() for seat_number, data in self.seats.items(): writer.writerow({ 'seat_number': seat_number, 'row': data['row'], 'available': 'yes' if data['available'] else 'no' }) def view_available_seats(self): return {seat_number: data for seat_number, data in self.seats.items() if data['available']} def reserve_seat(self, seat_number): if seat_number not in self.seats: raise ValueError(\\"Invalid seat number.\\") if not self.seats[seat_number]['available']: raise ValueError(\\"Seat already booked.\\") self.seats[seat_number]['available'] = False def cancel_reservation(self, seat_number): if seat_number not in self.seats: raise ValueError(\\"Invalid seat number.\\") if self.seats[seat_number]['available']: raise ValueError(\\"Seat is not booked.\\") self.seats[seat_number]['available'] = True"},{"question":"from typing import List, Tuple def remove_duplicates(lst: List[int]) -> Tuple[List[int], Tuple[int, int]]: Removes duplicates from the given list while maintaining order of first occurrences, and returns a tuple (number of duplicates removed, length of list after removal). Args: lst (List[int]): The list of integers from which to remove duplicates. Returns: Tuple: A tuple containing the number of duplicates removed and the final length of the list. pass # Test cases def test_remove_duplicates_basic(): unique_list, result = remove_duplicates([4, 5, 6, 4, 7, 8, 5, 9, 6]) assert unique_list == [4, 5, 6, 7, 8, 9] assert result == (3, 6) def test_remove_duplicates_no_duplicates(): unique_list, result = remove_duplicates([1, 2, 3, 4, 5]) assert unique_list == [1, 2, 3, 4, 5] assert result == (0, 5) def test_remove_duplicates_all_duplicates(): unique_list, result = remove_duplicates([1, 1, 1, 1]) assert unique_list == [1] assert result == (3, 1) def test_remove_duplicates_empty_list(): unique_list, result = remove_duplicates([]) assert unique_list == [] assert result == (0, 0) def test_remove_duplicates_single_element(): unique_list, result = remove_duplicates([7]) assert unique_list == [7] assert result == (0, 1) def test_remove_duplicates_mixed_elements(): unique_list, result = remove_duplicates([10, 22, 11, 22, 33, 10, 44]) assert unique_list == [10, 22, 11, 33, 44] assert result == (2, 5)","solution":"def remove_duplicates(lst): Removes duplicates from the given list while maintaining order of first occurrences, and returns a tuple (number of duplicates removed, length of list after removal). Args: lst (List[int]): The list of integers from which to remove duplicates. Returns: Tuple: A tuple containing the number of duplicates removed and the final length of the list. seen = set() unique_list = [] duplicates_removed = 0 for item in lst: if item not in seen: unique_list.append(item) seen.add(item) else: duplicates_removed += 1 return unique_list, (duplicates_removed, len(unique_list))"},{"question":"import re from typing import List def extract_alphabetical_substrings(s: str) -> List[str]: Identifies continuous alphabetical characters in a string and returns a list of these substrings. Args: s (str): Input string. Returns: List[str]: List of continuous alphabetical substrings. # Write your code here # Unit Tests def test_extract_alphabetical_substrings_basic(): assert extract_alphabetical_substrings(\\"Hello123World45Programming78\\") == [\\"Hello\\", \\"World\\", \\"Programming\\"] def test_extract_alphabetical_substrings_with_only_numbers(): assert extract_alphabetical_substrings(\\"1234567890\\") == [] def test_extract_alphabetical_substrings_empty_string(): assert extract_alphabetical_substrings(\\"\\") == [] def test_extract_alphabetical_substrings_with_only_letters(): assert extract_alphabetical_substrings(\\"JustSomeWords\\") == [\\"JustSomeWords\\"] def test_extract_alphabetical_substrings_mixed_characters(): assert extract_alphabetical_substrings(\\"This@Is&Sparta!\\") == [\\"This\\", \\"Is\\", \\"Sparta\\"] def test_extract_alphabetical_substrings_with_spaces(): assert extract_alphabetical_substrings(\\"Hello 123 World 456 Programming 789\\") == [\\"Hello\\", \\"World\\", \\"Programming\\"] def test_extract_alphabetical_substrings_with_underscore(): assert extract_alphabetical_substrings(\\"hello_world\\") == [\\"hello\\", \\"world\\"]","solution":"import re def extract_alphabetical_substrings(s): Identifies continuous alphabetical characters in a string and returns a list of these substrings. Args: s (str): Input string. Returns: List[str]: List of continuous alphabetical substrings. return re.findall(r'[a-zA-Z]+', s)"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Write a function named \`max_subarray_sum\` that takes a list of integers as input and returns the maximum sum of any contiguous subarray within the list. Implement the function using Kadane’s Algorithm. The function should handle cases where all the elements of the list are negative, returning the highest negative number in such scenarios. Include error handling for empty lists by raising a \`ValueError\` with an appropriate error message. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4]) -2 >>> max_subarray_sum([4]) 4 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: The input list is empty.","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within the list. Uses Kadane's Algorithm. if not nums: raise ValueError(\\"The input list is empty.\\") max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def eval_infix(expression: str) -> float: Evaluates a mathematical expression in infix notation with basic operations and respects the standard operator precedence. >>> eval_infix(\\"3 + 2\\") == 5 >>> eval_infix(\\"3 + 2 * 2\\") == 7 >>> eval_infix(\\"3 + 2 * 2 - 1 / 4\\") == 6.75 >>> eval_infix(\\" 3 + 2 * 2 \\") == 7 >>> eval_infix(\\"2 * 3 + 4 * 5 - 6 / 3\\") == 2 * 3 + 4 * 5 - 6 / 3 >>> eval_infix(\\"4 / 0\\") # raises ZeroDivisionError >>> eval_infix(\\"3 + abc\\") # raises ValueError","solution":"def eval_infix(expression): Evaluates a mathematical expression in infix notation with basic operations and respects the standard operator precedence. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': if right == 0: raise ZeroDivisionError(\\"division by zero\\") values.append(left / right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] in ('+', '-', '*', '/'): while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) else: raise ValueError(f\\"Invalid character in expression: {expression[i]}\\") i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def manage_orders(inventory, orders, prices): Manage customer orders in a small bakery, updating inventory and calculating total revenue. Parameters: inventory (list): A list of tuples where each tuple contains an item name and its quantity. orders (list): A list of tuples where each tuple contains an item name and the quantity ordered. prices (dict): A dictionary with item names as keys and their prices as values. Returns: dict: Updated inventory list. float: Total revenue generated. list: List of unfulfilled orders with reasons. Example: >>> inventory = [(\\"bread\\", 10), (\\"milk\\", 20)] >>> orders = [(\\"bread\\", 2), (\\"milk\\", 5)] >>> prices = {\\"bread\\": 2, \\"milk\\": 1.5} >>> manage_orders(inventory, orders, prices) ([(\\"bread\\", 8), (\\"milk\\", 15)], 11.5, []) pass # Incorrect example def manage_orders(inventory, orders, prices): revenue = 0 for order in orders: item, quantity = order if item not in inventory: return f\\"Item {item} not found in inventory\\" if inventory[item] < quantity: return f\\"Insufficient quantity for item {item}\\" inventory[item] -= quantity revenue += prices[item] * quantity return inventory, revenue # Incorrect usage of dictionary and no handling for missing items in price dictionary. inventory = {\\"bread\\": 10, \\"milk\\": 20} orders = [(\\"bread\\", 2), (\\"milk\\", 5), (\\"butter\\", 1)] prices = {\\"bread\\": 2, \\"milk\\": 1.5} print(manage_orders(inventory, orders, prices))","solution":"def manage_orders(inventory, orders, prices): Manage customer orders in a small bakery, updating inventory and calculating total revenue. Parameters: inventory (list): A list of tuples where each tuple contains an item name and its quantity. orders (list): A list of tuples where each tuple contains an item name and the quantity ordered. prices (dict): A dictionary with item names as keys and their prices as values. Returns: dict: Updated inventory list. float: Total revenue generated. list: List of unfulfilled orders with reasons. inventory_dict = dict(inventory) revenue = 0 unfulfilled_orders = [] for item, quantity in orders: if item not in inventory_dict: unfulfilled_orders.append((item, quantity, \\"Item not found in inventory\\")) continue if type(quantity) is not int or quantity <= 0: unfulfilled_orders.append((item, quantity, \\"Invalid quantity\\")) continue if item not in prices: unfulfilled_orders.append((item, quantity, \\"Item not found in price list\\")) continue if inventory_dict[item] < quantity: unfulfilled_orders.append((item, quantity, \\"Insufficient quantity in inventory\\")) continue # Process valid order inventory_dict[item] -= quantity revenue += prices[item] * quantity updated_inventory = list(inventory_dict.items()) return updated_inventory, revenue, unfulfilled_orders"},{"question":"def longest_identical_char_substring(inputString: str) -> str: Derives the longest substring consisting of identical characters. >>> longest_identical_char_substring(\\"\\") \\"\\" >>> longest_identical_char_substring(\\"a\\") \\"a\\" >>> longest_identical_char_substring(\\"aa\\") \\"aa\\" >>> longest_identical_char_substring(\\"aaaabbcc\\") \\"aaaa\\" >>> longest_identical_char_substring(\\"aabbbcc\\") \\"bbb\\" >>> longest_identical_char_substring(\\"aabbcccc\\") \\"cccc\\" >>> longest_identical_char_substring(\\"aabbbccdaaaa\\") \\"aaaa\\" >>> longest_identical_char_substring(\\"ababab\\") \\"a\\"","solution":"def longest_identical_char_substring(inputString): Derives the longest substring consisting of identical characters. Parameters: inputString (str): The string to analyze. Returns: str: The longest substring consisting of identical characters. if not inputString: return \\"\\" max_char = inputString[0] max_length = 1 current_char = inputString[0] current_length = 1 for i in range(1, len(inputString)): if inputString[i] == current_char: current_length += 1 else: if current_length > max_length: max_length = current_length max_char = current_char current_char = inputString[i] current_length = 1 # Check the last run if current_length > max_length: return current_char * current_length else: return max_char * max_length"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns all unique quadruples [a, b, c, d] in the array such that a + b + c + d = target. The solution set must not contain duplicate quadruples. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([-3, -2, -1, 0, 0, 1, 2, 3], 0) [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> four_sum([1, 2, 3], 6) []","solution":"def four_sum(nums, target): Returns all unique quadruples [a, b, c, d] in nums such that a + b + c + d = target. The solution set must not contain duplicate quadruples. nums.sort() quadruples = [] n = len(nums) if n < 4: return quadruples for i in range(n - 3): if i > 0 and nums[i] == nums[i-1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j-1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruples.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruples"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Takes a list of integers and returns the list with all duplicate numbers removed. Maintains the order of the first occurrence of each number. Args: lst (List[int]): List of integers Returns: List[int]: List of integers with duplicates removed Examples: >>> remove_duplicates([4, 5, 4, 6, 7, 6, 8]) [4, 5, 6, 7, 8] >>> remove_duplicates([1, 2, 3, 2, 1, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([9, 8, 7, 6, 5]) [9, 8, 7, 6, 5] >>> remove_duplicates([1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([-1, -2, -3, -2, -1, 4, 5]) [-1, -2, -3, 4, 5] >>> remove_duplicates([0, -1, -2, -1, 0, 1, 2]) [0, -1, -2, 1, 2]","solution":"def remove_duplicates(lst): Takes a list of integers and returns a list with all duplicate numbers removed. Maintains the order of the first occurrence of each number. Args: lst (list): List of integers Returns: list: List of integers with duplicates removed result = [] for number in lst: if number not in result: result.append(number) return result"},{"question":"import pandas as pd from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from sklearn.metrics import r2_score import matplotlib.pyplot as plt def load_data(file_path): Load CSV data into a pandas DataFrame. >>> data = load_data('house_data.csv') >>> data.shape[1] 5 pass def create_model(data): Creates a linear regression model based on the input data. >>> data = pd.DataFrame({ ... 'square_footage': [1000, 2000], ... 'num_bedrooms': [2, 3], ... 'num_bathrooms': [1, 2], ... 'location': ['A', 'B'], ... 'price': [100000, 200000] ... }) >>> model, predictions, actual, r_squared = create_model(data) >>> len(predictions) == len(actual) True pass def plot_histogram(predictions): Plots a histogram of the predicted house prices. >>> predictions = [100000, 200000, 300000] >>> plot_histogram(predictions) pass","solution":"import pandas as pd from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from sklearn.metrics import r2_score import matplotlib.pyplot as plt def load_data(file_path): Load CSV data into a pandas DataFrame. return pd.read_csv(file_path) def create_model(data): Creates a linear regression model based on the input data. # Select features and target variable from the data features = data[['square_footage', 'num_bedrooms', 'num_bathrooms', 'location']] target = data['price'] # For simplicity, let's convert categorical data to dummy/indicator variables features = pd.get_dummies(features, drop_first=True) # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42) # Create and train the linear regression model model = LinearRegression() model.fit(X_train, y_train) y_pred = model.predict(X_test) # Calculate R-squared value r_squared = r2_score(y_test, y_pred) # Return the model, predictions, and R-squared value return model, y_pred, y_test, r_squared def plot_histogram(predictions): Plots a histogram of the predicted house prices. plt.hist(predictions, bins=50, edgecolor='k') plt.xlabel('Predicted Price') plt.ylabel('Frequency') plt.title('Histogram of Predicted House Prices') plt.show() # Example usage: # file_path = 'house_data.csv' # data = load_data(file_path) # model, predictions, actual, r_squared = create_model(data) # plot_histogram(predictions) # print(f'R-squared value: {r_squared}')"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string s, return the longest palindromic substring in s. A palindrome is a string that reads the same forward and backward. >>> longest_palindromic_substring(\\"babad\\") # \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") # \\"bb\\" def test_single_character_string(): assert longest_palindromic_substring(\\"a\\") == \\"a\\" def test_two_character_string(): assert longest_palindromic_substring(\\"bb\\") == \\"bb\\" assert longest_palindromic_substring(\\"ab\\") == \\"a\\" def test_string_with_palindrome(): assert longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" def test_palindrome_at_edges(): assert longest_palindromic_substring(\\"abccba\\") == \\"abccba\\" assert longest_palindromic_substring(\\"abacdfgfdcaba\\") == \\"abacdfgfdcaba\\" def test_no_palindrome_longer_than_one(): assert longest_palindromic_substring(\\"abc\\") == \\"a\\" assert longest_palindromic_substring(\\"12345\\") == \\"1\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. n = len(s) if n <= 1: return s start, end = 0, 0 def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): left1, right1 = expand_around_center(i, i) left2, right2 = expand_around_center(i, i + 1) if right1 - left1 > end - start: start, end = left1, right1 if right2 - left2 > end - start: start, end = left2, right2 return s[start:end + 1]"},{"question":"def min_operations_to_palindrome(s: str) -> int: Calculate the minimum number of operations required to convert a given string into a palindrome. An operation is defined as changing one letter of the string to any other letter. >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"abba\\") 0 >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"abcde\\") 2 >>> min_operations_to_palindrome(\\"\\") 0 >>> min_operations_to_palindrome(\\"a\\") 0 >>> min_operations_to_palindrome(\\"abccba\\") 0 >>> min_operations_to_palindrome(\\"abcd\\") 2","solution":"def min_operations_to_palindrome(s): Calculate the minimum number of operations required to convert a given string into a palindrome. An operation is defined as changing one letter of the string to any other letter. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> str: Find the longest common subsequence (LCS) between two strings. The function takes two strings, \`s1\` and \`s2\`, and returns the LCS as a string. If there are multiple LCS of the same length, return any one of them. Example: >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") == \\"BCAB\\" >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" >>> longest_common_subsequence(\\"AAAA\\", \\"AA\\") == \\"AA\\" # Your code here from solution import longest_common_subsequence def test_example_case1(): assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") == \\"BCAB\\" def test_example_case2(): assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" def test_example_case3(): assert longest_common_subsequence(\\"AAAA\\", \\"AA\\") == \\"AA\\" def test_no_common_subsequence(): assert longest_common_subsequence(\\"ABC\\", \\"XYZ\\") == \\"\\" def test_identical_strings(): assert longest_common_subsequence(\\"ABC\\", \\"ABC\\") == \\"ABC\\" def test_empty_string(): assert longest_common_subsequence(\\"\\", \\"ABC\\") == \\"\\" assert longest_common_subsequence(\\"ABC\\", \\"\\") == \\"\\" def test_subsequence_at_start(): assert longest_common_subsequence(\\"ABCD\\", \\"AB\\") == \\"AB\\" def test_subsequence_at_end(): assert longest_common_subsequence(\\"ABCD\\", \\"CD\\") == \\"CD\\"","solution":"def longest_common_subsequence(s1: str, s2: str) -> str: Finds and returns the longest common subsequence (LCS) between two strings. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the LCS from the dp table i, j = m, n lcs = [] while i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: lcs.append(s1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] >= dp[i][j - 1]: i -= 1 else: j -= 1 # The lcs list will contain the LCS characters in reverse order return \\"\\".join(reversed(lcs))"},{"question":"def find_median_sorted_arrays(arr1: List[int], arr2: List[int]) -> float: Create a function \`find_median_sorted_arrays\` that takes in two sorted arrays of integers \`arr1\` and \`arr2\`, and returns the median of the combined sorted array. The overall run-time complexity should be O(log(min(n,m))), where \`n\` and \`m\` are the lengths of \`arr1\` and \`arr2\` respectively. >>> find_median_sorted_arrays([1, 3], [2]) == 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) == 2.5 >>> find_median_sorted_arrays([1, 2, 2], [2, 2, 3]) == 2.0 >>> find_median_sorted_arrays([1, 1, 1], [1, 1, 1]) == 1.0 >>> find_median_sorted_arrays([], [1]) == 1.0 >>> find_median_sorted_arrays([2], []) == 2.0","solution":"def find_median_sorted_arrays(arr1, arr2): Returns the median of two sorted arrays. :param arr1: List[int], a sorted array of integers :param arr2: List[int], a sorted array of integers :return: float, the median of the two sorted arrays if len(arr1) > len(arr2): arr1, arr2 = arr2, arr1 x, y = len(arr1), len(arr2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float('-inf') if partitionX == 0 else arr1[partitionX - 1] minX = float('inf') if partitionX == x else arr1[partitionX] maxY = float('-inf') if partitionY == 0 else arr2[partitionY - 1] minY = float('inf') if partitionY == y else arr2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not sorted\\")"},{"question":"def flatten(lst): Flattens a nested list of arbitrary depth. Parameters: lst (list): A nested list which can contain other lists Returns: list: A flattened list with no nested structures >>> flatten([]) == [] >>> flatten([1]) == [1] >>> flatten([[1]]) == [1] >>> flatten([1, 2, 3]) == [1, 2, 3] >>> flatten([1, [2, 3], 4]) == [1, 2, 3, 4] >>> flatten([1, [2, [3, [4, 5]], 6], 7]) == [1, 2, 3, 4, 5, 6, 7] >>> flatten([1, 'a', [2.5, ['b', 3], 4]]) == [1, 'a', 2.5, 'b', 3, 4] >>> flatten([[1, 2], [3], 4]) == [1, 2, 3, 4] >>> flatten([1, [2, [3, [4, [5, 6]]]], 7, [8, [9, 10]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"def flatten(lst): Flattens a nested list of arbitrary depth. Parameters: lst (list): A nested list which can contain other lists Returns: list: A flattened list with no nested structures flattened_list = [] def _flatten(sub_lst): for item in sub_lst: if isinstance(item, list): _flatten(item) else: flattened_list.append(item) _flatten(lst) return flattened_list"},{"question":"def remove_vowels(s: str) -> str: Removes all vowels (a, e, i, o, u) from the input string s. >>> remove_vowels(\\"aeiouAEIOU\\") \\"\\" >>> remove_vowels(\\"bcdfgBCDFG\\") \\"bcdfgBCDFG\\" >>> remove_vowels(\\"Hello World\\") \\"Hll Wrld\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"123!@#aeiouAEIOU\\") \\"123!@#\\" >>> remove_vowels(\\"A quick brown FOX\\") \\" qck brwn FX\\"","solution":"def remove_vowels(s): Removes all vowels (a, e, i, o, u) from the input string s. vowels = 'aeiouAEIOU' return ''.join(char for char in s if char not in vowels)"},{"question":"from typing import List, Union, Any def find_prime_numbers(nums: List[Union[int, Any]]) -> List[int]: Return a list of all prime numbers from the input list while handling exceptions. Raises a ValueError if any non-integer or negative integer is found in the list. >>> find_prime_numbers([3, 'a', 4]) Error >>> find_prime_numbers([2, 13, -7, 4]) Error >>> find_prime_numbers([2, 13, 4]) [2, 13]","solution":"from typing import List, Union, Any def find_prime_numbers(nums: List[Union[int, Any]]) -> List[int]: Return a list of all prime numbers from the input list while handling exceptions. Raises a ValueError if any non-integer or negative integer is found in the list. def is_prime(n: int) -> bool: if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True primes = [] for num in nums: if not isinstance(num, int): raise ValueError(\\"Input contains non-integer element(s).\\") if num < 0: raise ValueError(\\"Input contains negative integer value(s).\\") if is_prime(num): primes.append(num) return primes"},{"question":"def rotate_right(lst, k): Rotates the elements of the list lst to the right by k positions. :param lst: List of elements to be rotated. :param k: Number of positions to rotate the list. :return: The rotated list. >>> rotate_right([], 3) == [] >>> rotate_right([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_right([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] >>> rotate_right([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> rotate_right([1], 3) == [1] >>> rotate_right([1, 2, 3, 4, 5], 100) == [1, 2, 3, 4, 5]","solution":"def rotate_right(lst, k): Rotates the elements of the list lst to the right by k positions. :param lst: List of elements to be rotated. :param k: Number of positions to rotate the list. :return: The rotated list. if not lst: return lst # Handle cases where k is greater than the length of the list k = k % len(lst) return lst[-k:] + lst[:-k]"},{"question":"import random from typing import Dict def roll_die(n: int) -> Dict[int, int]: Simulates rolling a six-sided die n times and counts the frequency of each face value. Parameters: n (int): Number of times to roll the die Returns: dict: Counts of each face value (1 through 6) >>> roll_die(0) {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0} >>> roll_die(-5) {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0} >>> result = roll_die(10) >>> sum(result.values()) == 10 True >>> for value in result.keys(): ... 0 <= result[value] <= 10 True >>> result = roll_die(1000) >>> sum(result.values()) == 1000 True >>> for value in result.keys(): ... 0 <= result[value] <= 1000 True >>> result = roll_die(6000) >>> for count in result.values(): ... 800 < count < 1200 True","solution":"import random def roll_die(n): Simulates rolling a six-sided die n times and counts the frequency of each face value. Parameters: n (int): Number of times to roll the die Returns: dict: Counts of each face value (1 through 6) if n <= 0: return {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0} counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0} for _ in range(n): roll = random.randint(1, 6) counts[roll] += 1 return counts"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the string contains a valid sequence of correctly matched and nested parentheses. Args: s (str): The string containing parentheses Returns: bool: True if the sequence is valid, False otherwise. >>> is_valid_parentheses(\\"(){}[]\\") == True >>> is_valid_parentheses(\\"([{}])\\") == True >>> is_valid_parentheses(\\"(}\\") == False >>> is_valid_parentheses(\\"[(])\\") == False >>> is_valid_parentheses(\\"[({})](]\\") == False","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the string contains a valid sequence of correctly matched and nested parentheses. Args: s (str): The string containing parentheses Returns: bool: True if the sequence is valid, False otherwise. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def create_temperature_dataframe(temperatures): Create a DataFrame with 'time' and 'temperature' columns. Parameters: temperatures (list): A list of 24 float numbers representing temperatures for each hour of the day. Returns: pd.DataFrame: A pandas DataFrame with 'time' and 'temperature' columns. pass # Implementation here def plot_temperature(df): Plot a line graph with 'time' on the x-axis and 'temperature' on the y-axis. Parameters: df (pd.DataFrame): A pandas DataFrame with 'time' and 'temperature' columns. pass # Implementation here # Sample usage # temperatures = np.linspace(10.0, 20.0, 24) # df = create_temperature_dataframe(temperatures) # plot_temperature(df)","solution":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def create_temperature_dataframe(temperatures): Create a DataFrame with 'time' and 'temperature' columns. Parameters: temperatures (list): A list of 24 float numbers representing temperatures for each hour of the day. Returns: pd.DataFrame: A pandas DataFrame with 'time' and 'temperature' columns. if len(temperatures) != 24: raise ValueError(\\"Temperature list must have 24 elements.\\") df = pd.DataFrame({ 'time': np.arange(24), 'temperature': temperatures }) return df def plot_temperature(df): Plot a line graph with 'time' on the x-axis and 'temperature' on the y-axis. Parameters: df (pd.DataFrame): A pandas DataFrame with 'time' and 'temperature' columns. plt.figure(figsize=(10, 6)) plt.plot(df['time'], df['temperature'], color='blue', linestyle='--') plt.xlabel(\\"Time (hours)\\") plt.ylabel(\\"Temperature (°C)\\") plt.title(\\"Temperature Throughout the Day\\") plt.grid(True) plt.savefig(\\"temperature_plot.png\\") plt.show()"},{"question":"def factorial_array(arr): Returns a new array where each element is the factorial of the corresponding element in the input array. ( >>> factorial_array([1, 2, 3, 4, 5]) [1, 2, 6, 24, 120] >>> factorial_array([0, 1, 2]) [1, 1, 2]","solution":"def factorial_array(arr): Returns a new array where each element is the factorial of the corresponding element in the input array. def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result return [factorial(x) for x in arr]"},{"question":"def count_subarrays_with_sum(nums, target): Returns the number of contiguous subarrays that sum up to a given target value. >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([], 0) 0 >>> count_subarrays_with_sum([10], 10) 1 >>> count_subarrays_with_sum([10], 5) 0 >>> count_subarrays_with_sum([-1, -1, 1], -1) 3 >>> count_subarrays_with_sum([1, 2, 3, -3, 4], 3) 3 >>> count_subarrays_with_sum([1, 2, 3], 7) 0","solution":"def count_subarrays_with_sum(nums, target): Returns the number of contiguous subarrays that sum up to a given target value. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if (current_sum - target) in sum_map: count += sum_map[current_sum - target] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"import math from typing import Tuple def find_roots(a: int, b: int, c: int) -> Tuple[float, ...]: Returns a tuple containing the real roots of the quadratic equation ax^2 + bx + c = 0. If there are no real roots, return an empty tuple. >>> find_roots(1, 0, 1) () >>> find_roots(1, 2, 5) () >>> find_roots(1, -2, 1) (1.0,) >>> find_roots(4, 4, 1) (-0.5,) >>> find_roots(1, -3, 2) (1.0, 2.0) >>> find_roots(1, 0, -4) (-2.0, 2.0)","solution":"import math def find_roots(a, b, c): Returns a tuple containing the real roots of the quadratic equation ax^2 + bx + c = 0. If there are no real roots, return an empty tuple. discriminant = b**2 - 4*a*c if discriminant < 0: return () elif discriminant == 0: root = -b / (2*a) return (root,) else: root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (root1, root2)"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays of integers into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([-5, -3, 0, 2], [-4, -2, 1, 3]) [-5, -4, -3, -2, 0, 1, 2, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. i, j = 0, 0 merged_array = [] while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def calculate_balance(transactions): Calculate the net balance given a list of transaction strings. Each transaction is in the format \\"type:amount\\", where type can be \\"credit\\" or \\"debit\\". Parameters: transactions (list of str): List of transaction strings. Returns: int: The net balance after processing all transactions.","solution":"def calculate_balance(transactions): Calculate the net balance given a list of transaction strings. Each transaction is in the format \\"type:amount\\", where type can be \\"credit\\" or \\"debit\\". Parameters: transactions (list of str): List of transaction strings. Returns: int: The net balance after processing all transactions. balance = 0 for transaction in transactions: type, amount = transaction.split(':') amount = int(amount) if type == \\"credit\\": balance += amount elif type == \\"debit\\": balance -= amount return balance"},{"question":"def fizzbuzz(): Returns a list of strings where numbers from 1 to 100 are replaced with \\"Fizz\\" for multiples of 3, \\"Buzz\\" for multiples of 5, and \\"FizzBuzz\\" for multiples of both 3 and 5. All other numbers are kept as strings. >>> result = fizzbuzz() >>> result[2] 'Fizz' >>> result[4] 'Buzz' >>> result[14] 'FizzBuzz' >>> result[0] '1' >>> result[99] 'Buzz' >>> result[29] 'FizzBuzz' >>> result[58] '59' >>> len(result) 100","solution":"def fizzbuzz(): Prints \\"Fizz\\" for numbers divisible by 3, \\"Buzz\\" for numbers divisible by 5, \\"FizzBuzz\\" for numbers divisible by both 3 and 5, and the number itself otherwise. result = [] for i in range(1, 101): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def sort_timestamps(timestamps: List[str]) -> List[str]: Sorts a list of timestamps in chronological order. :param timestamps: List of timestamp strings in the format \\"YYYY-MM-DD HH:MM:SS\\" :return: List of sorted timestamp strings >>> sort_timestamps([ ... \\"2023-03-15 13:45:00\\", ... \\"2022-11-08 09:20:30\\", ... \\"2023-01-22 17:05:55\\", ... \\"2021-05-25 14:50:05\\" ... ]) == [ ... \\"2021-05-25 14:50:05\\", ... \\"2022-11-08 09:20:30\\", ... \\"2023-01-22 17:05:55\\", ... \\"2023-03-15 13:45:00\\" ... ]","solution":"def sort_timestamps(timestamps): Sorts a list of timestamps in chronological order. :param timestamps: List of timestamp strings in the format \\"YYYY-MM-DD HH:MM:SS\\" :return: List of sorted timestamp strings # Sort the timestamps using Python's built-in sorted function sorted_timestamps = sorted(timestamps) return sorted_timestamps"},{"question":"from typing import List import pytest def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: This function finds the length of the longest substring that contains at most 'k' distinct characters. If 'k' is zero or the string is empty, the function returns 0. The function raises a ValueError for invalid inputs. Examples: >>> longest_substring_with_k_distinct_chars(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"\\", 2) 0 >>> longest_substring_with_k_distinct_chars(\\"abcba\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"aaaa\\", 1) 4 >>> longest_substring_with_k_distinct_chars(\\"aaaa\\", 2) 4 >>> longest_substring_with_k_distinct_chars(\\"abc\\", 10) 3 Raises: ValueError: If 'k' is not an integer, 'k' is negative, or the input string contains non-lowercase characters. def test_valid_cases(): assert longest_substring_with_k_distinct_chars(\\"abcba\\", 2) == 3 assert longest_substring_with_k_distinct_chars(\\"eceba\\", 2) == 3 assert longest_substring_with_k_distinct_chars(\\"aa\\", 1) == 2 def test_empty_string(): assert longest_substring_with_k_distinct_chars(\\"\\", 2) == 0 def test_zero_k(): assert longest_substring_with_k_distinct_chars(\\"abcba\\", 0) == 0 def test_single_character_string(): assert longest_substring_with_k_distinct_chars(\\"aaaa\\", 1) == 4 def test_all_identical_characters(): assert longest_substring_with_k_distinct_chars(\\"aaaa\\", 2) == 4 def test_large_string(): large_string = \\"a\\" * 100000 + \\"b\\" * 100000 assert longest_substring_with_k_distinct_chars(large_string, 1) == 100000 def test_k_greater_than_distinct_characters(): assert longest_substring_with_k_distinct_chars(\\"abc\\", 10) == 3 def test_erroneous_inputs(): with pytest.raises(ValueError, match=\\"k must be an integer\\"): longest_substring_with_k_distinct_chars(\\"abcba\\", \\"2\\") with pytest.raises(ValueError, match=\\"k must be non-negative\\"): longest_substring_with_k_distinct_chars(\\"abcba\\", -1) with pytest.raises(ValueError, match=\\"Input string must contain only lowercase letters\\"): longest_substring_with_k_distinct_chars(\\"abcBA\\", 2) with pytest.raises(ValueError, match=\\"Input string must contain only lowercase letters\\"): longest_substring_with_k_distinct_chars(\\"abcd1\\", 2)","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring that contains at most 'k' distinct characters. Handles erroneous inputs by raising ValueError. if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") if k < 0: raise ValueError(\\"k must be non-negative\\") if not isinstance(s, str) or any(not c.islower() for c in s): raise ValueError(\\"Input string must contain only lowercase letters\\") if k == 0 or not s: return 0 char_count = {} start = 0 max_length = 0 for end in range(len(s)): if s[end] in char_count: char_count[s[end]] += 1 else: char_count[s[end]] = 1 while len(char_count) > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"import os from typing import List def find_files(directory: str, extension: str) -> List[str]: Find all files with a specific extension within a given directory and its subdirectories. Args: directory (str): The path to the directory to search within. extension (str): The file extension to search for (e.g., '.txt', '.py'). Returns: List[str]: A list of full paths to the files that match the extension. >>> find_files('test_dir', '.txt') ['test_dir/file1.txt', 'test_dir/sub_dir/file3.txt'] >>> find_files('test_dir', '.py') ['test_dir/file2.py', 'test_dir/sub_dir/file4.py'] import os import tempfile import pytest def test_find_files_txt(): with tempfile.TemporaryDirectory() as temp_dir: file_structure = [ 'file1.txt', 'file2.py', 'sub_dir/file3.txt', 'sub_dir/file4.py' ] for path in file_structure: full_path = os.path.join(temp_dir, path) os.makedirs(os.path.dirname(full_path), exist_ok=True) with open(full_path, 'w') as f: f.write(\\"Test file contents\\") expected = [ os.path.join(temp_dir, 'file1.txt'), os.path.join(temp_dir, 'sub_dir/file3.txt') ] result = find_files(temp_dir, '.txt') assert sorted(result) == sorted(expected) def test_find_files_py(): with tempfile.TemporaryDirectory() as temp_dir: file_structure = [ 'file1.txt', 'file2.py', 'sub_dir/file3.txt', 'sub_dir/file4.py' ] for path in file_structure: full_path = os.path.join(temp_dir, path) os.makedirs(os.path.dirname(full_path), exist_ok=True) with open(full_path, 'w') as f: f.write(\\"Test file contents\\") expected = [ os.path.join(temp_dir, 'file2.py'), os.path.join(temp_dir, 'sub_dir/file4.py') ] result = find_files(temp_dir, '.py') assert sorted(result) == sorted(expected) def test_find_files_case_insensitive(): with tempfile.TemporaryDirectory() as temp_dir: file_structure = [ 'file1.TXT', 'file2.Py' ] for path in file_structure: full_path = os.path.join(temp_dir, path) os.makedirs(os.path.dirname(full_path), exist_ok=True) with open(full_path, 'w') as f: f.write(\\"Test file contents\\") expected_txt = [os.path.join(temp_dir, 'file1.TXT')] result_txt = find_files(temp_dir, '.txt') assert sorted(result_txt) == sorted(expected_txt) expected_py = [os.path.join(temp_dir, 'file2.Py')] result_py = find_files(temp_dir, '.py') assert sorted(result_py) == sorted(expected_py) def test_find_files_no_matches(): with tempfile.TemporaryDirectory() as temp_dir: file_structure = [ 'file1.txt', 'file2.txt' ] for path in file_structure: full_path = os.path.join(temp_dir, path) os.makedirs(os.path.dirname(full_path), exist_ok=True) with open(full_path, 'w') as f: f.write(\\"Test file contents\\") result = find_files(temp_dir, '.py') assert result == []","solution":"import os from typing import List def find_files(directory: str, extension: str) -> List[str]: Find all files with a specific extension within a given directory and its subdirectories. Args: directory (str): The path to the directory to search within. extension (str): The file extension to search for (e.g., '.txt', '.py'). Returns: List[str]: A list of full paths to the files that match the extension. matching_files = [] for root, _, files in os.walk(directory): for file in files: if file.lower().endswith(extension.lower()): matching_files.append(os.path.join(root, file)) return matching_files"},{"question":"def max_profit_with_two_transactions(prices: List[int]) -> int: Simulate a simplified stock trading system to maximize profit with at most two transactions. Args: prices: A list of integers representing stock prices on consecutive days. Returns: An integer representing the maximum profit that can be achieved by making at most two transactions. If no profit is possible, return 0. >>> max_profit_with_two_transactions([7,6,4,3,1]) == 0 >>> max_profit_with_two_transactions([5]) == 0 >>> max_profit_with_two_transactions([7, 7]) == 0 >>> max_profit_with_two_transactions([1, 5]) == 4 >>> max_profit_with_two_transactions([3,3,5,0,0,3,1,4]) == 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5, 6]) == 5 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == 8 >>> max_profit_with_two_transactions([5, 1, 3, 2, 6, 4, 8, 2, 10]) == 15","solution":"def max_profit_with_two_transactions(prices): if not prices or len(prices) < 2: return 0 n = len(prices) # Initialize arrays for the maximum profit up to day i left_profits = [0] * n right_profits = [0] * n # Fill the left_profits array with maximum profit until each day min_price = prices[0] for i in range(1, n): left_profits[i] = max(left_profits[i-1], prices[i] - min_price) min_price = min(min_price, prices[i]) # Fill the right_profits array with maximum profit from each day to the end max_price = prices[-1] for i in range(n-2, -1, -1): right_profits[i] = max(right_profits[i+1], max_price - prices[i]) max_price = max(max_price, prices[i]) # Combine the profits to find the maximum profit with two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"def findLongestSequence(arr: List[int]) -> int: Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Ensure the solution has a time complexity of O(n). >>> findLongestSequence([]) 0 >>> findLongestSequence([5]) 1 >>> findLongestSequence([10, 20, 30]) 1 >>> findLongestSequence([1, 2, 3, 4, 5]) 5 >>> findLongestSequence([100, 4, 200, 1, 3, 2]) 4 >>> findLongestSequence([1, 2, 2, 3, 4]) 4 >>> findLongestSequence([0, -1, -2, -3, 2, 1, 4, 3]) 8","solution":"def findLongestSequence(arr): This function returns the length of the longest consecutive elements sequence. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"class LoginSystem: A class that simulates a basic login system for a small web application. >>> system = LoginSystem({'user1': 'password1', 'user2': 'password2'}) >>> system.login('user1', 'password1') 'Login successful' >>> system.login('user1', 'wrongpassword') 'Login failed' >>> system.login('User1', 'password1') 'Login failed' >>> system.login('user1', 'wrongpassword') 'Login failed' >>> system.login('user1', 'wrongpassword') 'Login failed' >>> system.login('user1', 'wrongpassword') 'User is locked out' >>> system.login('user1', 'password1') 'Login failed' >>> system.login('user1', 'wrongpassword') 'Login failed' >>> system.login('user1', 'password1') 'Login successful' >>> system.login('user1', 'wrongpassword') 'Login failed' def __init__(self, users): Initialize the login system with a dictionary of usernames and passwords. self.users = users self.failed_attempts = {} self.locked_users = {} def login(self, username, password): Checks the username and password against the predefined users dictionary. Returns \\"Login successful\\" if the credentials are correct. Returns \\"Login failed\\" otherwise. Locks the user out after three consecutive failed attempts.","solution":"class LoginSystem: def __init__(self, users): Initialize the login system with a dictionary of usernames and passwords. self.users = users self.failed_attempts = {} self.locked_users = {} def login(self, username, password): Checks the username and password against the predefined users dictionary. Returns \\"Login successful\\" if the credentials are correct. Returns \\"Login failed\\" otherwise. Locks the user out after three consecutive failed attempts. # Check if the user is currently locked out if username in self.locked_users and self.locked_users[username]: return \\"User is locked out\\" # Validate the credentials if username in self.users and self.users[username] == password: self.failed_attempts.pop(username, None) # Reset failed attempts on successful login return \\"Login successful\\" else: # Record the failed attempt if username in self.failed_attempts: self.failed_attempts[username] += 1 else: self.failed_attempts[username] = 1 # Lock the user out after 3 failed attempts if self.failed_attempts[username] >= 3: self.locked_users[username] = True return \\"Login failed\\""},{"question":"def find_pair_with_sum(nums, target): Finds indices of two numbers in the list that add up to the target sum. Args: nums (list of int): List of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers if they exist, else None. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) (1, 2) >>> find_pair_with_sum([3, 3], 6) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4], 8) None >>> find_pair_with_sum([1, 2, 3, 6, 7], 8) (1, 3) >>> find_pair_with_sum([1], 2) None >>> find_pair_with_sum([5, 6, 2], 20) None","solution":"def find_pair_with_sum(nums, target): Finds indices of two numbers in the list that add up to the target sum. Args: nums (list of int): List of integers. target (int): The target sum. Returns: tuple: A tuple containing the indices of the two numbers if they exist, else None. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"def bookstore_operations(inventory, operations): Simulate an online bookstore inventory system. >>> inventory = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5), (\\"1984\\", \\"George Orwell\\", 8), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) ] >>> operations = [ {'operation': 'add', 'title': 'Brave New World', 'author': 'Aldous Huxley', 'copies': 7}, {'operation': 'remove', 'title': '1984'}, {'operation': 'search', 'title': 'The Great Gatsby'}, {'operation': 'search', 'title': 'Moby Dick'} ] >>> bookstore_operations(inventory, operations) ([(\\"F. Scott Fitzgerald\\", 5), \\"Book not found\\"], [(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3), (\\"Brave New World\\", \\"Aldous Huxley\\", 7)])","solution":"def bookstore_operations(inventory, operations): Simulate an online bookstore inventory system. result = [] for op in operations: if op['operation'] == 'add': title = op['title'] author = op['author'] copies = op['copies'] updated = False for i, book in enumerate(inventory): if book[0] == title: inventory[i] = (book[0], book[1], book[2] + copies) updated = True break if not updated: inventory.append((title, author, copies)) elif op['operation'] == 'remove': title = op['title'] inventory = [book for book in inventory if book[0] != title] elif op['operation'] == 'search': title = op['title'] found = False for book in inventory: if book[0] == title: result.append((book[1], book[2])) found = True break if not found: result.append(\\"Book not found\\") return result, inventory"},{"question":"def is_valid_email(email: str) -> bool: Determines if a given string is a valid email address. The function should follow these rules: 1. The email should start with a sequence of alphanumeric characters (including underscores, periods, and hyphens). 2. The sequence should be followed by the '@' symbol. 3. After the '@' symbol, there should be a domain name which follows the pattern of alphanumeric characters separated by a single period (e.g., 'domain.com' or 'sub.domain.com'). 4. The domain name must not end with a period. Examples: >>> is_valid_email(\\"user.name@test-domain.com\\") True >>> is_valid_email(\\"user@.com\\") False","solution":"import re def is_valid_email(email): Checks if the given email follows the specified email address rules. Parameters: email (str): The email address to validate. Returns: bool: True if the email is valid, False otherwise. email_regex = re.compile( r'^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+' ) if email_regex.match(email): local_part, domain_part = email.split('@') if \\"..\\" in domain_part or domain_part.endswith(\\".\\"): return False return True return False"},{"question":"from typing import List def maxSubarrayLength(arr: List[int], d: int) -> int: Returns the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to d. >>> maxSubarrayLength([1, 5, 6, 7, 8, 10, 12, 14, 15], 3) 4 >>> maxSubarrayLength([10, 1, 2, 4, 7, 2], 5) 4 >>> maxSubarrayLength([], 3) 0 >>> maxSubarrayLength([10], 3) 1 >>> maxSubarrayLength([7, 7, 7, 7, 7], 0) 5 >>> maxSubarrayLength([1, 2, 3, 4, 5], 100) 5 >>> maxSubarrayLength([1, 10, 20, 30, 40], 5) 1 >>> maxSubarrayLength([1, 3, 6, 8, 10, 12, 15], 4) 3 pass def test_example_1(): arr = [1, 5, 6, 7, 8, 10, 12, 14, 15] d = 3 assert maxSubarrayLength(arr, d) == 4 def test_example_2(): arr = [10, 1, 2, 4, 7, 2] d = 5 assert maxSubarrayLength(arr, d) == 4 def test_empty_array(): arr = [] d = 3 assert maxSubarrayLength(arr, d) == 0 def test_single_element_array(): arr = [10] d = 3 assert maxSubarrayLength(arr, d) == 1 def test_all_elements_same(): arr = [7, 7, 7, 7, 7] d = 0 assert maxSubarrayLength(arr, d) == 5 def test_large_d_value(): arr = [1, 2, 3, 4, 5] d = 100 assert maxSubarrayLength(arr, d) == 5 def test_no_valid_subarray(): arr = [1, 10, 20, 30, 40] d = 5 assert maxSubarrayLength(arr, d) == 1 def test_subarray_at_end(): arr = [1, 3, 6, 8, 10, 12, 15] d = 4 assert maxSubarrayLength(arr, d) == 3","solution":"from collections import deque def maxSubarrayLength(arr, d): Returns the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to d. if not arr: return 0 min_queue = deque() max_queue = deque() left = 0 max_len = 0 for right, num in enumerate(arr): while min_queue and num < min_queue[-1]: min_queue.pop() min_queue.append(num) while max_queue and num > max_queue[-1]: max_queue.pop() max_queue.append(num) while max_queue[0] - min_queue[0] > d: if arr[left] == min_queue[0]: min_queue.popleft() if arr[left] == max_queue[0]: max_queue.popleft() left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def spell_checker(valid_words: List[str], paragraph: str) -> List[str]: This function returns a list of words from the given \`paragraph\` that are not found in the \`valid_words\` list. Parameters: - valid_words (List[str]): A list of valid words. - paragraph (str): A paragraph of text to be checked. Returns: - List[str]: A list of misspelled or invalid words in the paragraph.","solution":"import re from typing import List def spell_checker(valid_words: List[str], paragraph: str) -> List[str]: This function returns a list of words from the given \`paragraph\` that are not found in the \`valid_words\` list. Parameters: - valid_words (List[str]): A list of valid words. - paragraph (str): A paragraph of text to be checked. Returns: - List[str]: A list of misspelled or invalid words in the paragraph. # Convert the list of valid words to a set of lowercase words for fast lookup valid_words_set = set(word.lower() for word in valid_words) # Use regex to extract words from paragraph, ignoring punctuation words_in_paragraph = re.findall(r'bw+b', paragraph.lower()) # Collect words that are not in the valid_words_set invalid_words = [word for word in words_in_paragraph if word not in valid_words_set] return invalid_words"},{"question":"def ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int: Determine the length of the shortest transformation sequence from \`beginWord\` to \`endWord\` where: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the wordList. If no such sequence exists, returns 0. >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> ladderLength(\\"abc\\", \\"def\\", [\\"dbc\\", \\"dec\\", \\"dgc\\", \\"dft\\"]) 0","solution":"from collections import deque def ladderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord. If no such sequence exists, returns 0. if endWord not in wordList: return 0 wordList = set(wordList) queue = deque([(beginWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def find_top_students(students, N): Returns a list of the top N students with the highest scores. If two students have the same score, prioritize them by their names in alphabetical order. Parameters: students (list of tuples): Each tuple consists of a student's name and their math score. N (int): The number of top students to return. Returns: list: A list of names of the top N students. >>> find_top_students([('John', 88), ('Emma', 95), ('Lucas', 95), ('Olivia', 92)], 3) ['Emma', 'Lucas', 'Olivia'] >>> find_top_students([('John', 88), ('Emma', 95)], 3) ['Emma', 'John'] >>> find_top_students([('John', 88), ('Emma', 88), ('Lucas', 88)], 2) ['Emma', 'John'] >>> find_top_students([('Victoria', 88), ('Emma', 88), ('Lucas', 88), ('Alice', 88)], 3) ['Alice', 'Emma', 'Lucas'] >>> find_top_students([('John', 88)], 1) ['John'] >>> find_top_students([], 3) []","solution":"def find_top_students(students, N): Returns a list of the top N students with the highest scores. If two students have the same score, prioritize them by their names in alphabetical order. Parameters: students (list of tuples): Each tuple consists of a student's name and their math score. N (int): The number of top students to return. Returns: list: A list of names of the top N students. # Sort the student tuples first by score in descending order then by name in ascending order sorted_students = sorted(students, key=lambda x: (-x[1], x[0])) # Extract the names of the top N students top_students_names = [student[0] for student in sorted_students[:N]] return top_students_names"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression involving addition and multiplication while respecting the order of operations (multiplication before addition). >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"2*3+4*5\\") == 26 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"2+3*4+5*6\\") == 44 >>> evaluate_expression(\\"2*3*4\\") == 24 >>> evaluate_expression(\\"2+3+4\\") == 9 >>> evaluate_expression(\\"\\") == 0 >>> evaluate_expression(\\"02+3*4\\") == 14","solution":"def evaluate_expression(expression): Evaluates a mathematical expression involving addition and multiplication while respecting the order of operations (multiplication before addition). Parameters: expression (str): The mathematical expression as a string. Returns: int: The evaluated result of the expression. if not expression: return 0 # Split expression by addition addition_parts = expression.split('+') total_sum = 0 for part in addition_parts: # Split each part by multiplication and multiply the numbers multiplication_parts = map(int, part.split('*')) product = 1 for num in multiplication_parts: product *= num total_sum += product return total_sum"},{"question":"def square_list(numbers: List[int]) -> List[int]: Given a list of integers, returns a new list with each integer squared. >>> square_list([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> square_list([-1, -2, -3]) [1, 4, 9] >>> square_list([]) []","solution":"def square_list(numbers): Given a list of integers, returns a new list with each integer squared. result = [] for number in numbers: result.append(number * number) return result"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two integers a and b using the Euclidean algorithm. Handles both positive and negative values for a and b. >>> gcd(48, 18) == 6 >>> gcd(-48, 18) == 6 >>> gcd(48, -18) == 6 >>> gcd(-48, -18) == 6 >>> gcd(13, 7) == 1 >>> gcd(100, 25) == 25 >>> gcd(123456, 789012) == 12 >>> gcd(999, 999) == 999 >>> gcd(-1, -999) == 1 >>> gcd(1, -999) == 1","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of two integers a and b using the Euclidean algorithm. Handles both positive and negative values for a and b. # Ensure a and b are positive a, b = abs(a), abs(b) while b: a, b = b, a % b return a"},{"question":"from collections import deque from typing import Dict, List def bfs(graph: Dict[str, List[str]], start: str) -> List[str]: Perform BFS on the graph starting from the given start node and return the list of nodes in the order they are visited. >>> graph = { ... 'A' : ['B', 'C'], ... 'B' : ['D', 'E'], ... 'C' : ['F'], ... 'D' : [], ... 'E' : ['F'], ... 'F' : [] ... } >>> bfs(graph, 'A') ['A', 'B', 'C', 'D', 'E', 'F']","solution":"from collections import deque def bfs(graph, start): Perform BFS on the graph starting from the given start node and return the list of nodes in the order they are visited. visited = [] # List to keep track of visited nodes queue = deque([start]) # Initialize the queue with the start node while queue: node = queue.popleft() # Dequeue a node if node not in visited: visited.append(node) # Mark it as visited queue.extend(graph[node]) # Enqueue non-visited adjacent nodes return visited"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abccbaabccba\\") == 3 >>> length_of_longest_substring(\\"tmmzuxt\\") == 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. start = 0 max_length = 0 char_map = {} for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Write a Python function that takes a list of integers and rearranges the elements to form the largest possible integer. The function should return this largest integer as a string. Assume the input list will contain only non-negative integers. Examples: >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1, 20, 23, 4, 8]) '8423201' def test_largest_number_basic(): assert largest_number([3, 30, 34, 5, 9]) == '9534330' assert largest_number([1, 20, 23, 4, 8]) == '8423201' def test_largest_number_single_element(): assert largest_number([5]) == '5' assert largest_number([0]) == '0' def test_largest_number_all_zeros(): assert largest_number([0, 0, 0, 0]) == '0' def test_largest_number_mixed_zeros_and_numbers(): assert largest_number([0, 0, 1, 0]) == '1000' def test_largest_number_same_digits(): assert largest_number([11, 1]) == '111' def test_largest_number_multiple_digit_same_numbers(): assert largest_number([420, 42, 423]) == '42423420'","solution":"from functools import cmp_to_key def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 def largest_number(nums): if not nums: return \\"\\" # Convert the numbers to strings for comparison nums_str = list(map(str, nums)) # Sort the numbers based on the comparison nums_str.sort(key=cmp_to_key(compare)) # Join sorted numbers into the largest number as string largest_num = ''.join(nums_str) # Edge case: when the array consists of only zeros, return '0' return largest_num if largest_num[0] != '0' else '0'"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Takes an integer array as input and returns a new array where each element at index 'i' is the product of all the values in the original array except the one at 'i'. You must solve this problem without using the division operation and in O(n) time complexity. Args: nums (list): List of integers. Returns: list: List of integers where each element is the product of all other elements in the input list except the current element. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([42]) [1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([]) []","solution":"def product_except_self(nums): Takes an integer array as input and returns a new array where each element at index 'i' is the product of all the values in the original array except the one at 'i'. Args: nums (list): List of integers. Returns: list: List of integers where each element is the product of all other elements in the input list except the current element. n = len(nums) if n == 0: return [] result = [1] * n # Compute prefix products prefix = 1 for i in range(n): result[i] = prefix prefix *= nums[i] # Compute suffix products and combine with prefix products suffix = 1 for i in range(n-1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def reverse_string(s: str) -> str: Returns the input string with its characters reversed. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"madam\\") \\"madam\\" >>> reverse_string(\\"Hello, World!\\") \\"!dlroW ,olleH\\"","solution":"def reverse_string(s): Returns the input string with its characters reversed. Parameters: s (str): The input string. Returns: str: The reversed string. return s[::-1]"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> None: Rotates the given n x n 2D matrix 90 degrees clockwise in place. >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ >>> [5, 1, 9, 11], >>> [2, 4, 8, 10], >>> [13, 3, 6, 7], >>> [15, 14, 12, 16] >>> ] >>> rotate_matrix_90_clockwise(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n 2D matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element top = matrix[i][j] # Move left to top matrix[i][j] = matrix[n - 1 - j][i] # Move bottom to left matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] # Move right to bottom matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] # Move top to right matrix[j][n - 1 - i] = top"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Given a string s and a list of words, return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]) [0, 9] Example 2: >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] Note: - The order of words does not matter. - You may assume no duplicated words in words. - 1 <= s.length <= 10^4 - 1 <= words.length <= 5000 - 1 <= words[i].length <= 30","solution":"def findSubstring(s, words): from collections import Counter if not s or not words: return [] word_length = len(words[0]) word_count = len(words) total_words_length = word_length * word_count words_counter = Counter(words) result = [] for i in range(word_length): left = i current_counter = Counter() count = 0 for j in range(i, len(s) - word_length + 1, word_length): word = s[j:j + word_length] if word in words_counter: current_counter[word] += 1 count += 1 while current_counter[word] > words_counter[word]: current_counter[s[left:left + word_length]] -= 1 left += word_length count -= 1 if count == word_count: result.append(left) else: current_counter = Counter() count = 0 left = j + word_length return result"},{"question":"from typing import List def count_pairs(A: List[int], k: int) -> int: Returns the number of distinct pairs (i, j) in array A where (A[i] + A[j]) % k == 0. Args: A: List of integers k: Integer, the divisor value Returns: int: Number of such pairs pass # Unit tests def test_example_1(): assert count_pairs([2, 5, 3, 1, 4], 3) == 4, \\"Test case example 1 failed\\" def test_example_2(): assert count_pairs([1, 2, 3, 4, 5], 2) == 4, \\"Test case example 2 failed\\" def test_all_elements_same(): assert count_pairs([3, 3, 3, 3], 3) == 6, \\"Test case all elements same failed\\" # (n * (n-1)) / 2 for n=4 def test_no_valid_pairs(): assert count_pairs([1, 2, 3], 10) == 0, \\"Test case no valid pairs failed\\" def test_large_numbers(): assert count_pairs([1000000000, 1000000001, 999999999], 5) == 1, \\"Test case large numbers failed\\" # Pairs: (1000000000, 1000000001)","solution":"def count_pairs(A, k): Returns the number of distinct pairs (i, j) in array A where (A[i] + A[j]) % k == 0. Args: A: List of integers k: Integer, the divisor value Returns: int: Number of such pairs from collections import defaultdict mod_count = defaultdict(int) # Count occurrences of remainders when elements are divided by k for num in A: remainder = num % k mod_count[remainder] += 1 count = 0 # Iterate through each pair of remainders for i in range(k): # Calculate the other remainder that can pair with remainder \`i\` complement = (k - i) % k if complement >= i: if i == complement: # If i and complement are same, then count pairs within that group count += (mod_count[i] * (mod_count[i] - 1)) // 2 else: # For different remainders, count cross-pairing count += mod_count[i] * mod_count[complement] return count"},{"question":"def find_n_primes_in_range(start: int, end: int, N: int) -> list: Determines the first N prime numbers in the given range [start, end] and returns them as a list. If there are fewer than N prime numbers in the given range, returns all found prime numbers. Parameters: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). N (int): The number of prime numbers to return. Returns: list: A list of the first N prime numbers in the specified range. Example: >>> find_n_primes_in_range(10, 50, 5) [11, 13, 17, 19, 23] >>> find_n_primes_in_range(20, 30, 4) [23, 29]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_n_primes_in_range(start: int, end: int, N: int) -> list: Finds the first N primes in the given range [start, end]. If there are fewer than N primes, return all found primes. primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) if len(primes) == N: break return primes"},{"question":"def is_prime(n: int) -> bool: Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-1) False >>> is_prime(17) True >>> is_prime(18) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the original list. >>> filter_primes([]) [] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([4, 6, 7, 9, 11, 13, 14]) [7, 11, 13] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([-3, -2, -1, 0, 1, 2, 3]) [2, 3]","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): Construct a Binary Search Tree (BST) from the given preorder traversal list. >>> bstFromPreorder([8, 5, 1, 7, 10, 12]).val 8 >>> bstFromPreorder([1, 2]).val 1 >>> bstFromPreorder([3, 2, 1]).val 3 pass def bstToList(root): Convert a Binary Search Tree (BST) to a list representation. >>> bstToList(bstFromPreorder([8, 5, 1, 7, 10, 12])) [8, 5, 10, 1, 7, None, 12] >>> bstToList(bstFromPreorder([1, 2])) [1, None, 2] >>> bstToList(bstFromPreorder([3, 2, 1])) [3, 2, None, 1] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, parent = TreeNode(value), None while stack and stack[-1].val < value: parent = stack.pop() if parent: parent.right = node else: stack[-1].left = node stack.append(node) return root def bstToList(root): if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] is None: result.pop() return result"},{"question":"def number_to_words(num: int) -> str: Write a Python function that takes an integer as input and returns a string of the number spelled out in English words. The function should be able to handle numbers from 0 to 999,999. Requirements: 1. If the input is 0, the function should return \\"zero\\". 2. Numbers less than 20 should be handled as special cases (e.g., 13 -> \\"thirteen\\"). 3. Tens place (20, 30, ... 90) should be handled as special cases (e.g., 20 -> \\"twenty\\"). 4. Hundreds and thousands should be constructed by combining the appropriate strings (e.g., 123 -> \\"one hundred twenty-three\\", 3456 -> \\"three thousand four hundred fifty-six\\"). 5. The function should handle both single words and hyphenated words correctly (e.g., 21 -> \\"twenty-one\\"). Examples: >>> number_to_words(123) \\"one hundred twenty-three\\" >>> number_to_words(45) \\"forty-five\\" >>> number_to_words(1000) \\"one thousand\\" >>> number_to_words(100000) \\"one hundred thousand\\"","solution":"def number_to_words(num): Converts an integer into its English words representation. if num == 0: return \\"zero\\" def one_to_nineteen(n): return [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"][n] def tens(n): return [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"][n] def two_digit_number_to_words(n): if n < 20: return one_to_nineteen(n) else: return tens(n // 10) + (\\"-\\" + one_to_nineteen(n % 10) if n % 10 != 0 else \\"\\") def three_digit_number_to_words(n): return (one_to_nineteen(n // 100) + \\" hundred\\" + (\\" \\" + two_digit_number_to_words(n % 100) if n % 100 != 0 else \\"\\") if n >= 100 else two_digit_number_to_words(n)) if num < 1000: return three_digit_number_to_words(num) else: thousand_part = num // 1000 rest_part = num % 1000 return (three_digit_number_to_words(thousand_part) + \\" thousand\\" + (\\" \\" + three_digit_number_to_words(rest_part) if rest_part != 0 else \\"\\"))"},{"question":"def count_unique_ips(ip_list): Returns the count of unique IP addresses in the list. >>> count_unique_ips(['192.168.1.1', '192.168.1.2', '192.168.1.1', '192.168.1.3', '192.168.1.2']) 3 >>> count_unique_ips([]) 0 >>> count_unique_ips(['192.168.1.1', '192.168.1.2', '192.168.1.3']) 3 >>> count_unique_ips(['192.168.1.1', '192.168.1.1', '192.168.1.1']) 1 >>> count_unique_ips(['192.168.1.1']) 1","solution":"def count_unique_ips(ip_list): Returns the count of unique IP addresses in the list. return len(set(ip_list))"},{"question":"def calculate_trivia_questions(total_activities: int) -> int: Returns the number of trivia questions based on the given ratio and total activities. >>> calculate_trivia_questions(40) == 15 >>> calculate_trivia_questions(16) == 6 >>> calculate_trivia_questions(0) == 0 >>> calculate_trivia_questions(80) == 30 >>> calculate_trivia_questions(8) == 3","solution":"def calculate_trivia_questions(total_activities): Returns the number of trivia questions based on the given ratio and total activities. # Ratio of trivia questions to physical challenges trivia_ratio = 3 physical_ratio = 5 # Total ratio parts total_ratio_parts = trivia_ratio + physical_ratio # Total number of physical challenges physical_challenges = (total_activities / total_ratio_parts) * physical_ratio # Total number of trivia questions trivia_questions = (total_activities / total_ratio_parts) * trivia_ratio return int(trivia_questions)"},{"question":"def are_parentheses_balanced(expression: str) -> bool: Develop a function that takes a string representing an arithmetic expression and returns True if the parentheses within the expression are balanced, and False otherwise. The function should correctly handle nested parentheses. >>> are_parentheses_balanced(\\"((2 + 3) * 5)\\") True >>> are_parentheses_balanced(\\"(2 + 3) * (5\\") False >>> are_parentheses_balanced(\\"2 + 3 * 5\\") True >>> are_parentheses_balanced(\\"\\") True >>> are_parentheses_balanced(\\"(\\") False >>> are_parentheses_balanced(\\")\\") False >>> are_parentheses_balanced(\\"((3 + 2) * (5 - 1))\\") True >>> are_parentheses_balanced(\\"(3 + (4 * 5)\\") False >>> are_parentheses_balanced(\\"(1+(2*(3+(4/(5+6)))))\\") True >>> are_parentheses_balanced(\\"(1+(2*(3+(4/(5+6))))\\") False","solution":"def are_parentheses_balanced(expression): Returns True if the parentheses in the expression are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def find_max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of stock prices. Ensures that the buy operation occurs before the sell operation. If no transaction can be made, returns 0. Examples: >>> find_max_profit([]) == 0 >>> find_max_profit([5]) == 0 >>> find_max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> find_max_profit([7, 5, 3, 2]) == 0 >>> find_max_profit([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0 >>> find_max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 8 >>> find_max_profit([10, 20, 5, 12, 6, 15, 3, 7, 9]) == 10","solution":"from typing import List def find_max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of stock prices. Ensures that the buy operation occurs before the sell operation. If no transaction can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def generate_synonym_sentences(target: str, synonyms: list) -> list: Generate a list of all possible strings by replacing words from the target string with their synonyms. >>> generate_synonym_sentences(\\"I feel happy today\\", [['happy', 'pleased', 'content'], ['today', 'now', 'this moment']]) ['I feel happy today', 'I feel happy now', 'I feel happy this moment', 'I feel pleased today', 'I feel pleased now', 'I feel pleased this moment', 'I feel content today', 'I feel content now', 'I feel content this moment'] >>> generate_synonym_sentences(\\"Life is beautiful\\", [['happy', 'pleased', 'content'], ['today', 'now', 'this moment']]) [\\"Life is beautiful\\"] >>> generate_synonym_sentences(\\"Stay happy\\", [['happy', 'pleased', 'content']]) ['Stay happy', 'Stay pleased', 'Stay content'] >>> generate_synonym_sentences(\\"\\", [['happy', 'pleased', 'content']]) Traceback (most recent call last): ... ValueError: Invalid input. Ensure target is a non-empty string and synonyms is a list of lists. >>> generate_synonym_sentences(\\"I feel happy today\\", \\"not a list of lists\\") Traceback (most recent call last): ... ValueError: Invalid input. Ensure target is a non-empty string and synonyms is a list of lists. >>> generate_synonym_sentences(\\"I feel happy today\\", []) [\\"I feel happy today\\"]","solution":"def generate_synonym_sentences(target: str, synonyms: list) -> list: # Helper function to find synonym sets for a word def find_synonyms(word): for synonym_set in synonyms: if word in synonym_set: return synonym_set return [word] # Splitting target string into words words = target.split() # For each word, retrieve synonyms or use the word itself synonym_options = [find_synonyms(word) for word in words] # Recursive function to generate combinations def generate_combinations(options, index=0, current_sentence=[]): if index == len(options): return [' '.join(current_sentence)] combinations = [] for synonym in options[index]: combinations += generate_combinations(options, index + 1, current_sentence + [synonym]) return combinations # Error handling for improper inputs if not isinstance(target, str) or not isinstance(synonyms, list) or len(target) == 0: raise ValueError(\\"Invalid input. Ensure target is a non-empty string and synonyms is a list of lists.\\") # Generating all combinations return generate_combinations(synonym_options) # Sample usage target = \\"I feel happy today\\" synonyms = [['happy', 'pleased', 'content'], ['today', 'now', 'this moment']] print(generate_synonym_sentences(target, synonyms))"},{"question":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[str, List[Tuple[str, int]]], start: str, target: str) -> Tuple[List[str], float]: Find the shortest path from a given start location to a target location using Dijkstra's algorithm. Args: graph: A weighted, undirected graph where nodes represent locations and edges represent the travel time between them. start: The starting location. target: The target location. Returns: A tuple containing the shortest path as a list of locations, and the total distance of this path. >>> dijkstra({'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)]}, 'A', 'D') (['A', 'B', 'C', 'D'], 4) >>> dijkstra({'A': [('B', 3)], 'B': [('A', 3)], 'C': [('D', 1)], 'D': [('C', 1)]}, 'A', 'D') ([], float('inf')) >>> dijkstra({'A': []}, 'A', 'A') (['A'], 0) >>> dijkstra({'A': [('B', 1)], 'B': [('A', 1), ('C', 2)], 'C': [('B', 2), ('A', 3)]}, 'A', 'C') (['A', 'B', 'C'], 3) >>> dijkstra({'A': [('B', 2), ('C', 1)], 'B': [('A', 2), ('D', 3), ('E', 4)], 'C': [('A', 1), ('D', 1)], 'D': [('B', 3), ('C', 1), ('E', 1)], 'E': [('B', 4), ('D', 1)]}, 'A', 'E') (['A', 'C', 'D', 'E'], 3)","solution":"import heapq def dijkstra(graph, start, target): def relax(u, v, weight): if distances[v] > distances[u] + weight: distances[v] = distances[u] + weight predecessors[v] = u heapq.heappush(pq, (distances[v], v)) distances = {node: float('inf') for node in graph} distances[start] = 0 predecessors = {node: None for node in graph} pq = [(0, start)] visited = set() while pq: current_distance, u = heapq.heappop(pq) if u in visited: continue visited.add(u) if u == target: break for neighbor, weight in graph[u]: if neighbor not in visited: relax(u, neighbor, weight) # Build the shortest path path = [] current_node = target while current_node is not None: path.append(current_node) current_node = predecessors[current_node] path = path[::-1] if distances[target] == float('inf'): return [], float('inf') # Return empty path and \\"infinite\\" distance if target is unreachable return path, distances[target] graph = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] } start = 'A' target = 'D' shortest_path, distance = dijkstra(graph, start, target) print(f'Shortest path: {shortest_path}, Distance: {distance}')"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 from solution import length_of_longest_substring def test_length_of_longest_substring(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 # \\"abc\\" assert length_of_longest_substring(\\"bbbbb\\") == 1 # \\"b\\" assert length_of_longest_substring(\\"pwwkew\\") == 3 # \\"wke\\" assert length_of_longest_substring(\\"\\") == 0 # \\"\\" assert length_of_longest_substring(\\" \\") == 1 # \\" \\" assert length_of_longest_substring(\\"au\\") == 2 # \\"au\\" assert length_of_longest_substring(\\"dvdf\\") == 3 # \\"vdf\\" assert length_of_longest_substring(\\"aab\\") == 2 # \\"ab\\" assert length_of_longest_substring(\\"abcabcbb\\") == 3 # \\"abc\\" assert length_of_longest_substring(\\"abcdefgh\\") == 8 # \\"abcdefgh\\"","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. if not s: return 0 left, longest = 0, 0 seen = {} for right, char in enumerate(s): if char in seen and seen[char] >= left: left = seen[char] + 1 seen[char] = right longest = max(longest, right - left + 1) return longest"},{"question":"def is_palindrome(s: str) -> bool: Return True if the string is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome('') True >>> is_palindrome('A man, a plan, a canal: Panama') True >>> is_palindrome('race a car') False >>> is_palindrome('No lemon, no melon') True >>> is_palindrome('12321') True >>> is_palindrome('1a2b2a1') True >>> is_palindrome('!@#') True from solution import is_palindrome def test_empty_string(): assert is_palindrome('') == True def test_single_character(): assert is_palindrome('a') == True def test_simple_palindrome(): assert is_palindrome('racecar') == True def test_longer_palindrome_with_punctuation(): assert is_palindrome('A man, a plan, a canal: Panama') == True def test_not_a_palindrome(): assert is_palindrome('race a car') == False def test_palindrome_with_mixed_cases(): assert is_palindrome('No lemon, no melon') == True def test_palindrome_with_numbers(): assert is_palindrome('12321') == True assert is_palindrome('1a2b2a1') == True def test_non_alphanumeric_characters(): assert is_palindrome('!@#') == True","solution":"def is_palindrome(s: str) -> bool: Return True if the string is a palindrome, ignoring case and non-alphanumeric characters. # Convert to lowercase and filter out non-alphanumeric characters. filtered_chars = [char.lower() for char in s if char.isalnum()] # Initialize two pointers. left, right = 0, len(filtered_chars) - 1 # Use the two-pointer technique to check for palindrome. while left < right: if filtered_chars[left] != filtered_chars[right]: return False left += 1 right -= 1 return True"},{"question":"def most_frequent_character(s: str) -> str: Analyzes a string to identify the most frequently occurring character. Ignores spaces and punctuation, and is case-insensitive. Returns the most frequently occurring character based on the criteria mentioned. >>> most_frequent_character(\\"Hello World!\\") 'l' >>> most_frequent_character(\\"A quick brown fox jumps over the lazy dog.\\") 'o' >>> most_frequent_character(\\"To be or not to be, that is the question.\\") 't'","solution":"def most_frequent_character(s): Analyzes a string to identify the most frequently occurring character. Ignores spaces and punctuation, and is case-insensitive. Returns the most frequently occurring character based on the criteria mentioned. # Convert string to lower case and initialize a frequency dictionary s = s.lower() frequency = {} for char in s: if char.isalpha(): # Ignore non-alphabetic characters if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Initialize a variable to track the most frequent character and its count most_frequent = None max_count = 0 for char in s: if char.isalpha() and frequency[char] > max_count: most_frequent = char max_count = frequency[char] return most_frequent"},{"question":"class ManageData: A class to manage a fixed-size list of elements with methods to update and retrieve values. Example Usage: >>> data_manager = ManageData(15) >>> data_manager.update_value(5, 10) >>> print(data_manager.get_value(5)) # Output should be 10 >>> data_manager.reset() >>> print(data_manager.get_value(5)) # Output should be 0 (default state) def __init__(self, size): Initialize the list to the given size with all elements set to 0. :param size: integer size of the internal list def update_value(self, index, value): Update the value at the specific position. :param index: integer index at which to update the value :param value: value to set at the specified index def get_value(self, index): Retrieve the value from the specific position. :param index: integer index from which to retrieve the value :return: value at the specified index def reset(self): Reset all elements in the list back to 0.","solution":"class ManageData: def __init__(self, size): Initialize the list to the given size with all elements set to 0. :param size: integer size of the internal list self.size = size self.data = [0] * size def update_value(self, index, value): Update the value at the specific position. :param index: integer index at which to update the value :param value: value to set at the specified index if 0 <= index < self.size: self.data[index] = value else: raise IndexError(\\"Index out of range\\") def get_value(self, index): Retrieve the value from the specific position. :param index: integer index from which to retrieve the value :return: value at the specified index if 0 <= index < self.size: return self.data[index] else: raise IndexError(\\"Index out of range\\") def reset(self): Reset all elements in the list back to 0. self.data = [0] * self.size"},{"question":"def custom_sort(s: str) -> str: Given a string consisting of lowercase letters, uppercase letters, and digits, sort the characters in the following order: lowercase letters, uppercase letters, and digits. Each category should also be sorted within itself. The function should return the sorted string. >>> custom_sort(\\"d3Cba1A2Bc\\") 'abcdABC123' >>> custom_sort(\\"abcde\\") 'abcde' >>> custom_sort(\\"ABCDE\\") 'ABCDE' >>> custom_sort(\\"54321\\") '12345' >>> custom_sort(\\"\\") '' >>> custom_sort(\\"aA1bB2cC3\\") 'abcABC123' >>> custom_sort(\\"aA123bcB456\\") 'abcAB123456'","solution":"def custom_sort(s: str) -> str: Sorts the given string such that lowercase letters come first, followed by uppercase letters and then digits. Each category is sorted within itself. lower = sorted([char for char in s if char.islower()]) upper = sorted([char for char in s if char.isupper()]) digit = sorted([char for char in s if char.isdigit()]) return ''.join(lower + upper + digit)"},{"question":"class ShoppingCart: A class to represent a simple online store with a shopping cart feature. Methods: add_item(name: str, price: float, quantity: int = 1): Adds an item to the cart. remove_item(name: str, quantity:int = 1): Removes a specified quantity of an item from the cart. total_price() -> float: Returns the total price of items in the cart. apply_discount_code(code: str) -> float: Applies a discount code and returns the total price after discount. >>> cart = ShoppingCart() >>> cart.add_item(\\"Apple\\", 1.00, 3) >>> cart.total_price() 3.0 >>> cart.add_item(\\"Banana\\", 0.50, 2) >>> cart.total_price() 4.0 >>> cart.apply_discount_code(\\"DISCOUNT10\\") 3.6 import pytest from solution import ShoppingCart def test_add_item(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.00, 3) assert cart.items == [{'name': 'Apple', 'price': 1.00, 'quantity': 3}] cart.add_item(\\"Apple\\", 1.00, 2) assert cart.items == [{'name': 'Apple', 'price': 1.00, 'quantity': 5}] cart.add_item(\\"Banana\\", 0.50, 2) assert cart.items == [{'name': 'Apple', 'price': 1.00, 'quantity': 5}, {'name': 'Banana', 'price': 0.50, 'quantity': 2}] def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.00, 5) cart.add_item(\\"Banana\\", 0.50, 2) cart.remove_item(\\"Apple\\", 2) assert cart.items == [{'name': 'Apple', 'price': 1.00, 'quantity': 3}, {'name': 'Banana', 'price': 0.50, 'quantity': 2}] cart.remove_item(\\"Apple\\", 3) assert cart.items == [{'name': 'Banana', 'price': 0.50, 'quantity': 2}] cart.remove_item(\\"Banana\\", 1) assert cart.items == [{'name': 'Banana', 'price': 0.50, 'quantity': 1}] cart.remove_item(\\"Banana\\", 1) assert cart.items == [] def test_total_price(): cart = ShoppingCart() assert cart.total_price() == 0 cart.add_item(\\"Apple\\", 1.00, 5) cart.add_item(\\"Banana\\", 0.50, 2) assert cart.total_price() == 5.00 + 1.00 def test_apply_discount_code(): cart = ShoppingCart() cart.add_item(\\"Apple\\", 1.00, 5) # 5 cart.add_item(\\"Banana\\", 0.50, 2) # 1 assert cart.total_price() == 6.00 total_after_discount = cart.apply_discount_code(\\"DISCOUNT10\\") assert total_after_discount == 5.40 # 6 - 10% of 6 total_after_discount = cart.apply_discount_code(\\"DISCOUNT20\\") assert total_after_discount == 4.80 # 6 - 20% of 6 total_after_discount = cart.apply_discount_code(\\"INVALID\\") assert total_after_discount == -1 # Invalid discount","solution":"class ShoppingCart: def __init__(self): self.items = [] self.valid_discount_codes = { \\"DISCOUNT10\\": 10, \\"DISCOUNT20\\": 20, } def add_item(self, name, price, quantity=1): for item in self.items: if item['name'] == name: item['quantity'] += quantity return self.items.append({'name': name, 'price': price, 'quantity': quantity}) def remove_item(self, name, quantity=1): for item in self.items: if item['name'] == name: if item['quantity'] <= quantity: self.items.remove(item) else: item['quantity'] -= quantity return def total_price(self): return sum(item['price'] * item['quantity'] for item in self.items) def apply_discount_code(self, code): if code in self.valid_discount_codes: discount_percentage = self.valid_discount_codes[code] total = self.total_price() discount_amount = total * (discount_percentage / 100) return total - discount_amount else: return -1 # Indicates invalid discount code"},{"question":"def is_valid_ipv4_address(address: str) -> bool: Checks if the input string is a valid IPv4 address. An IPv4 address consists of four groups of numbers separated by periods. Each group contains 1 to 3 digits, and the value of each group can range from 0 to 255. Args: address (str): The input string to check. Returns: bool: True if the input string is a valid IPv4 address, False otherwise. Examples: >>> is_valid_ipv4_address(\\"192.168.1.1\\") True >>> is_valid_ipv4_address(\\"0.0.0.0\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"256.256.256.256\\") False >>> is_valid_ipv4_address(\\"192.168.1\\") False","solution":"def is_valid_ipv4_address(address): Checks if the input string is a valid IPv4 address. An IPv4 address consists of four groups of numbers separated by periods. Each group contains 1 to 3 digits, and the value of each group can range from 0 to 255. Args: address (str): The input string to check. Returns: bool: True if the input string is a valid IPv4 address, False otherwise. parts = address.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False num = int(part) if not (0 <= num <= 255): return False if len(part) > 1 and part[0] == '0': return False return True"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to its integer equivalent. The Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. These symbols can be combined to form larger numbers. This function converts the Roman numeral string to the corresponding integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 pass # Example usage: print(roman_to_int(\\"III\\")) # Output: 3 print(roman_to_int(\\"IV\\")) # Output: 4 print(roman_to_int(\\"IX\\")) # Output: 9 print(roman_to_int(\\"LVIII\\")) # Output: 58 print(roman_to_int(\\"MCMXCIV\\")) # Output: 1994","solution":"def roman_to_int(s): Convert a Roman numeral string to its integer equivalent. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in s[::-1]: # Reverse iterate through the string value = roman_to_int_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def flatten_nested_dict(nested_dict: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary and constructs paths with dot notation. Args: - nested_dict (dict): The nested dictionary to flatten. - parent_key (str): The base key for constructing paths in the flattened dictionary (used for recursion). - sep (str): Separator to use between keys in the path. Returns: - dict: A new dictionary with flattened paths as keys. >>> flatten_nested_dict({'a': {'b': {'c': 1}, 'd': 2}, 'e': 3}) {'a.b.c': 1, 'a.d': 2, 'e': 3} >>> flatten_nested_dict({}) {} >>> flatten_nested_dict({'a': {'b': {'c': 1}}, 'd': 2}, sep='-') {'a-b-c': 1, 'd': 2}","solution":"def flatten_nested_dict(nested_dict, parent_key='', sep='.'): Flattens a nested dictionary and constructs paths with dot notation. Args: - nested_dict (dict): The nested dictionary to flatten. - parent_key (str): The base key for constructing paths in the flattened dictionary (used for recursion). - sep (str): Separator to use between keys in the path. Returns: - dict: A new dictionary with flattened paths as keys. flattened_dict = {} for k, v in nested_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): flattened_dict.update(flatten_nested_dict(v, new_key, sep)) else: flattened_dict[new_key] = v return flattened_dict"},{"question":"from typing import List, Dict, Optional def filter_and_sort_books(books: List[Dict[str, str]], genre: Optional[str] = None, sort_by: str = \\"title\\", descending: bool = False) -> List[Dict[str, str]]: Filters and sorts a list of books based on the specified genre and sort criteria. Parameters: books (List[Dict[str, str]]): List of books where each book is represented by a dictionary. genre (Optional[str]): The genre to filter the books by. If None, no filtering is applied. Default is None. sort_by (str): The field to sort the books by. It can be \\"title\\", \\"author\\", or \\"year\\". Default is \\"title\\". descending (bool): If True, sorts in descending order. Default is False. Returns: List[Dict[str, str]]: The filtered and sorted list of books. >>> books = [ ... {\\"title\\": \\"Book A\\", \\"author\\": \\"Author X\\", \\"year\\": 2005, \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"Book B\\", \\"author\\": \\"Author Y\\", \\"year\\": 2010, \\"genre\\": \\"Non-Fiction\\"}, ... {\\"title\\": \\"Book C\\", \\"author\\": \\"Author Z\\", \\"year\\": 2000, \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"Book D\\", \\"author\\": \\"Author X\\", \\"year\\": 1995, \\"genre\\": \\"Science\\"} ... ] >>> filter_and_sort_books(books, genre=\\"Fiction\\", sort_by=\\"year\\", descending=True) [{'title': 'Book A', 'author': 'Author X', 'year': 2005, 'genre': 'Fiction'}, {'title': 'Book C', 'author': 'Author Z', 'year': 2000, 'genre': 'Fiction'}] >>> filter_and_sort_books(books, sort_by=\\"title\\", descending=False) [{'title': 'Book A', 'author': 'Author X', 'year': 2005, 'genre': 'Fiction'}, {'title': 'Book B', 'author': 'Author Y', 'year': 2010, 'genre': 'Non-Fiction'}, {'title': 'Book C', 'author': 'Author Z', 'year': 2000, 'genre': 'Fiction'}, {'title': 'Book D', 'author': 'Author X', 'year': 1995, 'genre': 'Science'}] >>> filter_and_sort_books(books, genre=\\"Non-Fiction\\", sort_by=\\"author\\", descending=False) [{'title': 'Book B', 'author': 'Author Y', 'year': 2010, 'genre': 'Non-Fiction'}] >>> filter_and_sort_books(books, genre=\\"Fiction\\", sort_by=\\"author\\", descending=True) [{'title': 'Book C', 'author': 'Author Z', 'year': 2000, 'genre': 'Fiction'}, {'title': 'Book A', 'author': 'Author X', 'year': 2005, 'genre': 'Fiction'}] pass","solution":"from typing import List, Dict, Optional def filter_and_sort_books(books: List[Dict[str, str]], genre: Optional[str] = None, sort_by: str = \\"title\\", descending: bool = False) -> List[Dict[str, str]]: Filters and sorts a list of books based on the specified genre and sort criteria. Parameters: books (List[Dict[str, str]]): List of books where each book is represented by a dictionary. genre (Optional[str]): The genre to filter the books by. If None, no filtering is applied. Default is None. sort_by (str): The field to sort the books by. It can be \\"title\\", \\"author\\", or \\"year\\". Default is \\"title\\". descending (bool): If True, sorts in descending order. Default is False. Returns: List[Dict[str, str]]: The filtered and sorted list of books. # Filter books by genre if specified if genre: books = [book for book in books if book['genre'].lower() == genre.lower()] # Sort books by the specified field sorted_books = sorted(books, key=lambda book: book[sort_by], reverse=descending) return sorted_books"},{"question":"from typing import List, Optional def second_largest(nums: List[int]) -> Optional[int]: Returns the second largest unique integer in the list. If the list contains less than two distinct integers, return None. >>> second_largest([6, 2, 9, 6, 1]) == 6 >>> second_largest([3, 3, 3]) == None >>> second_largest([4]) == None >>> second_largest([7, 7, 7, 5, 5]) == 5 >>> second_largest([-1, -2, -3, -4]) == -2 >>> second_largest([]) == None >>> second_largest([1, 2]) == 1 >>> second_largest([5, 5]) == None >>> second_largest(list(range(100))) == 98","solution":"def second_largest(nums): Returns the second largest unique integer in the list. If the list contains less than two distinct integers, returns None. unique_nums = set(nums) if len(unique_nums) < 2: return None sorted_nums = sorted(unique_nums, reverse=True) return sorted_nums[1] # Example usage: # print(second_largest([6, 2, 9, 6, 1])) # Should return 6 # print(second_largest([3, 3, 3])) # Should return None # print(second_largest([4])) # Should return None # print(second_largest([7, 7, 7, 5, 5])) # Should return 5"},{"question":"def reverse_words(sentence: str) -> str: Reverse the words within a given sentence while maintaining their original order. >>> reverse_words(\\"Hello World from OpenAI\\") \\"OpenAI from World Hello\\" >>> reverse_words(\\"OpenAI\\") \\"OpenAI\\" >>> reverse_words(\\"Hello World\\") \\"World Hello\\" >>> reverse_words(\\"Python is great for AI\\") \\"AI for great is Python\\" >>> reverse_words(\\"\\") \\"\\"","solution":"def reverse_words(sentence): Reverse the words within a given sentence. Args: sentence (str): The input sentence with words delimited by a single space. Returns: str: The sentence with words reversed but in their original order. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a sentence reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams from the list of words. Args: words (List[str]): A list of strings containing words. Returns: List[List[str]]: A list of lists, where each sublist contains anagrams grouped together. >>> group_anagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']) [['ate', 'eat', 'tea'], ['nat', 'tan'], ['bat']] >>> group_anagrams(['cat', 'dog', 'bird']) [['cat'], ['dog'], ['bird']] >>> group_anagrams(['abc', 'bca', 'cab', 'bac']) [['abc', 'bac', 'bca', 'cab']] >>> group_anagrams([]) [] >>> group_anagrams(['word']) [['word']] >>> group_anagrams(['abc', 'bca', 'abc', 'cab']) [['abc', 'bca', 'cab']]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams from the list of words. Args: words (List[str]): A list of strings containing words. Returns: List[List[str]]: A list of lists, where each sublist contains anagrams grouped together. anagrams = defaultdict(list) for word in words: sorted_word = tuple(sorted(word)) anagrams[sorted_word].append(word) # Sort each group alphabetically and make sure groups don't contain duplicates grouped_anagrams = [sorted(list(set(group))) for group in anagrams.values()] return grouped_anagrams"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"nurses run\\") True >>> is_palindrome(\\"@!Madam!@\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False","solution":"import re def is_palindrome(s): Returns True if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1]"},{"question":"def longest_substring_with_2_distinct_chars(s: str) -> str: Returns the longest substring that contains at most 2 distinct characters. >>> longest_substring_with_2_distinct_chars(\\"eceba\\") \\"ece\\" >>> longest_substring_with_2_distinct_chars(\\"ccaabbb\\") \\"aabbb\\"","solution":"def longest_substring_with_2_distinct_chars(s): Returns the longest substring that contains at most 2 distinct characters. Args: s (str): Input string Returns: str: The longest substring with at most 2 distinct characters start, max_length, max_substr = 0, 0, \\"\\" char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substr = s[start:end + 1] return max_substr"},{"question":"def longest_word(s: str) -> str: Returns the longest word in the input string. In case of multiple words with the same maximum length, returns the first one that appears. >>> longest_word(\\"hello\\") == \\"hello\\" >>> longest_word(\\"Write a function to find the longest word\\") == \\"function\\" >>> longest_word(\\"cat bat\\") == \\"cat\\" >>> longest_word(\\"jumped over a lazy dog\\") == \\"jumped\\" >>> longest_word(\\"\\") == \\"\\"","solution":"def longest_word(s: str) -> str: Returns the longest word in the input string. In case of multiple words with the same maximum length, returns the first one that appears. words = s.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def squares_of_even_numbers_greater_than_50(lst: List[int]) -> List[int]: Returns a list of squares of the even numbers in \`lst\`, but only if their square is greater than 50. >>> squares_of_even_numbers_greater_than_50([3, 4, 7, 8, 12, 15, 2]) == [64, 144] >>> squares_of_even_numbers_greater_than_50([3, -4, 7, -8, -12, 15, 2]) == [64, 144]","solution":"def squares_of_even_numbers_greater_than_50(lst): Returns a list of squares of the even numbers in \`lst\`, but only if their square is greater than 50. return [x**2 for x in lst if x % 2 == 0 and x**2 > 50]"},{"question":"def top_movies(movie_ids: List[int], reviews: List[Tuple[int, int, int]], N: int) -> List[int]: Identify the N movies with the highest average ratings. Args: movie_ids (List[int]): A list of unique integers representing movie IDs. reviews (List[Tuple[int, int, int]]): A list of tuples where each tuple (movie_id, user_id, rating) represents a review. Ratings are integers from 1 to 10. N (int): Number of movies with the highest average rating to return. Returns: List[int]: A list of N integers representing movie IDs with the highest average ratings. Example: >>> movie_ids = [1, 2, 3, 4] >>> reviews = [(1, 1, 5), (1, 2, 7), (2, 1, 10), (2, 2, 8), (3, 1, 6)] >>> N = 2 >>> top_movies(movie_ids, reviews, N) [2, 1] pass # Test Cases def test_basic_case(): movie_ids = [1, 2, 3, 4] reviews = [(1, 1, 5), (1, 2, 7), (2, 1, 10), (2, 2, 8), (3, 1, 6)] N = 2 assert top_movies(movie_ids, reviews, N) == [2, 1] def test_with_all_movies_reviewed(): movie_ids = [1, 2] reviews = [(1, 1, 10), (2, 1, 8), (2, 2, 9)] N = 1 assert top_movies(movie_ids, reviews, N) == [1] def test_movies_with_no_reviews(): movie_ids = [1, 2, 3] reviews = [(1, 1, 5)] N = 2 assert top_movies(movie_ids, reviews, N) == [1, 2] def test_more_requests_than_movies(): movie_ids = [1, 2, 3] reviews = [(1, 1, 5), (2, 1, 8), (3, 1, 9)] N = 5 assert top_movies(movie_ids, reviews, N) == [3, 2, 1] def test_tie_in_average_rating(): movie_ids = [1, 2, 3] reviews = [(1, 1, 5), (2, 1, 5), (3, 1, 10)] N = 2 assert top_movies(movie_ids, reviews, N) == [3, 1]","solution":"from typing import List, Tuple from collections import defaultdict def top_movies(movie_ids: List[int], reviews: List[Tuple[int, int, int]], N: int) -> List[int]: movie_ratings = defaultdict(list) # Aggregate ratings for each movie for movie_id, user_id, rating in reviews: movie_ratings[movie_id].append(rating) # Calculate average ratings avg_ratings = [] for movie_id in movie_ids: if movie_id in movie_ratings: avg_rating = sum(movie_ratings[movie_id]) / len(movie_ratings[movie_id]) avg_ratings.append((avg_rating, movie_id)) else: avg_ratings.append((0, movie_id)) # Consider movies with no reviews having 0 average rating # Sort by average rating (descending), then by movie_id (ascending) avg_ratings.sort(key=lambda x: (-x[0], x[1])) # Extract the top N movie IDs top_movie_ids = [movie_id for _, movie_id in avg_ratings[:N]] return top_movie_ids"},{"question":"def find_primes(n): Returns a list of all prime numbers up to n (inclusive). >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(1) [] >>> find_primes(2) [2] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(0) [] >>> find_primes(-10) [] >>> find_primes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def find_primes(n): Returns a list of all prime numbers up to n (inclusive). if n < 2: return [] primes = [] for num in range(2, n+1): is_prime = True for i in range(2, int(num**0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def int_to_binary(n: int) -> str: Converts an integer to its binary representation without leading zeros. >>> int_to_binary(13) == \\"1101\\" >>> int_to_binary(7) == \\"111\\" >>> int_to_binary(1) == \\"1\\" >>> int_to_binary(0) == \\"0\\" >>> int_to_binary(1023) == \\"1111111111\\" >>> int_to_binary(8) == \\"1000\\" >>> int_to_binary(16) == \\"10000\\" >>> int_to_binary(19) == \\"10011\\" pass","solution":"def int_to_binary(n): Converts an integer to its binary representation without leading zeros. Parameters: n (int): The integer to convert. Returns: str: The binary representation of the integer. if n == 0: return \\"0\\" return bin(n)[2:]"},{"question":"def flatten_nested_list(nested_list): Flattens a nested list into a dictionary with keys representing paths to the values. Args: nested_list (list): The nested list to be flattened. Returns: dict: A flattened dictionary with keys as paths. >>> flatten_nested_list([1, 2, 3]) {'0': 1, '1': 2, '2': 3} >>> flatten_nested_list([1, [2, 3]]) {'0': 1, '1_0': 2, '1_1': 3} >>> flatten_nested_list([[1, 2], [3, [4, 5]], 6]) {'0_0': 1, '0_1': 2, '1_0': 3, '1_1_0': 4, '1_1_1': 5, '2': 6}","solution":"def flatten_nested_list(nested_list): Flattens a nested list into a dictionary with keys representing paths to the values. Args: nested_list (list): The nested list to be flattened. Returns: dict: A flattened dictionary with keys as paths. flat_dict = {} def recurse(curr_list, path): for i, item in enumerate(curr_list): new_path = path + [i] if isinstance(item, list): recurse(item, new_path) else: key = \\"_\\".join(map(str, new_path)) flat_dict[key] = item recurse(nested_list, []) return flat_dict"},{"question":"def find_indices(s: str, char: str) -> list: Create a Python function that takes two arguments: a string and a character. The function should return a list of indices representing the positions in the string where the character is found in lowercase, ignoring any instances where the character is uppercase. If the character is not found in the string, return an empty list. The function should be case-sensitive for the character to be searched. Args: s (str): The input string. char (str): The character to be searched for. Returns: list: A list of indices where the character is found in the string. Examples: >>> find_indices(\\"Hello\\", \\"e\\") [1] >>> find_indices(\\"Hello World\\", \\"o\\") [4, 7] >>> find_indices(\\"Hello World\\", \\"z\\") [] >>> find_indices(\\"Hello World\\", \\"O\\") [] >>> find_indices(\\"Hello hello\\", \\"H\\") [0] >>> find_indices(\\"Hello hello\\", \\"h\\") [6] >>> find_indices(\\"\\", \\"a\\") []","solution":"def find_indices(s, char): Returns a list of indices representing the positions in the string \`s\` where the character \`char\` is found in lowercase. Args: s (str): The input string. char (str): The character to be searched for. Returns: list: A list of indices where the character is found in the string. return [index for index, c in enumerate(s) if c == char]"},{"question":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False i = 3 while i * i <= n: if n % i == 0: return False i += 2 return True def nearest_smaller_prime(n: int) -> int: If n is prime, returns the nearest prime number that is smaller than n. If n is not prime, returns n itself. >>> nearest_smaller_prime(10) 10 >>> nearest_smaller_prime(11) 7 >>> nearest_smaller_prime(17) 13","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False i = 3 while i * i <= n: if n % i == 0: return False i += 2 return True def nearest_smaller_prime(n): If n is prime, returns the nearest prime number that is smaller than n. If n is not prime, returns n itself. if not is_prime(n): return n candidate = n - 1 while candidate > 1: if is_prime(candidate): return candidate candidate -= 1 return -1 # Return -1 if no smaller prime is found, which should not happen for n > 2"},{"question":"def cumulative_sum(arr): Takes a list of integers and returns a new list where each element is the sum of itself and all previous elements in the list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([]) [] >>> cumulative_sum([-1, 2, -3, 4]) [-1, 1, -2, 2] >>> cumulative_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> cumulative_sum([5]) [5]","solution":"def cumulative_sum(arr): Takes a list of integers and returns a new list where each element is the sum of itself and all previous elements in the list. Args: arr (list): List of integers. Returns: list: List of cumulative sums. if not arr: return [] result = [] current_sum = 0 for num in arr: current_sum += num result.append(current_sum) return result"},{"question":"def is_palindrome(s: str) -> bool: Determines whether the given string is a palindrome. Ignores spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"hello\\") == False pass def longest_palindrome(s: str) -> str: Returns the longest palindromic substring in the given string. If there are multiple substrings of the same length, returns the first one. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" pass","solution":"def is_palindrome(s: str) -> bool: Determines whether the given string is a palindrome. Ignores spaces, punctuation, and capitalization. # Normalize the string by removing non-alphanumeric characters and converting to lowercase cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string reads the same forward and backward return cleaned_s == cleaned_s[::-1] def longest_palindrome(s: str) -> str: Returns the longest palindromic substring in the given string. If there are multiple substrings of the same length, returns the first one. n = len(s) if n == 0: return \\"\\" # Initialize the DP table to store palindromic substrings information dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # Single character substrings are palindromes for i in range(n): dp[i][i] = True # Check for 2-character substrings for i in range(n-1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for substrings longer than 2 characters for length in range(3, n + 1): # length of substring for i in range(n - length + 1): j = i + length - 1 # ending index of substring if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"def multiply_digits(input_string: str) -> str: Returns a new string where the digits in the input string are multiplied by 2, and alphabetical characters remain unchanged. Parameters: input_string (str): The input string containing a mix of alphabetical characters and digits. Returns: str: The transformed string with digits multiplied by 2. >>> multiply_digits(\\"a1b2c3\\") 'a2b4c6' >>> multiply_digits(\\"\\") '' >>> multiply_digits(\\"abc\\") 'abc' >>> multiply_digits(\\"1234\\") '2468' >>> multiply_digits(\\"0a1b02\\") '0a2b04'","solution":"def multiply_digits(input_string): Returns a new string where the digits in the input string are multiplied by 2, and alphabetical characters remain unchanged. Parameters: input_string (str): The input string containing a mix of alphabetical characters and digits. Returns: str: The transformed string with digits multiplied by 2. result = [] for char in input_string: if char.isdigit(): result.append(str(int(char) * 2)) else: result.append(char) return ''.join(result)"},{"question":"def maximum_product_of_three(nums): Given a list of integers, find the maximum product of any three numbers. >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) 300","solution":"def maximum_product_of_three(nums): Returns the maximum product that can be obtained from any three numbers in the list. if len(nums) < 3: raise ValueError(\\"The input list must have at least three numbers.\\") # Initialize variables to store the three largest and two smallest numbers max1 = max2 = max3 = float('-inf') min1 = min2 = float('inf') for num in nums: # Update the maximum values if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num # Update the minimum values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # Calculate the maximum product of three numbers return max(max1 * max2 * max3, max1 * min1 * min2)"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Determines if there are two distinct elements in the array whose sum equals the target value. Returns their indices if such elements are found, otherwise returns an empty list. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Determines if there are two distinct elements in the array whose sum equals the target value. Returns their indices if such elements are found, otherwise returns an empty list. :param nums: List[int] :param target: int :return: List[int] num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i return []"},{"question":"def count_and_max(nums): Takes a list of integers and returns a dictionary with the count of each unique integer (converted to positive) and the maximum integer value in the list (also converted to positive). >>> count_and_max([1, 2, 3, 2, 1, 4]) {\\"count\\": {1: 2, 2: 2, 3: 1, 4: 1}, \\"max\\": 4} >>> count_and_max([-1, -2, -3, -1, -2, -3, -2]) {\\"count\\": {1: 2, 2: 3, 3: 2}, \\"max\\": 3} >>> count_and_max([1, -1, 2, -2, 3]) {\\"count\\": {1: 2, 2: 2, 3: 1}, \\"max\\": 3} >>> count_and_max([0, 0, 0]) {\\"count\\": {0: 3}, \\"max\\": 0} >>> count_and_max([]) {\\"count\\": {}, \\"max\\": None}","solution":"def count_and_max(nums): Takes a list of integers and returns a dictionary with the count of each unique integer (converted to positive) and the maximum integer value in the list (also converted to positive). positive_nums = [abs(num) for num in nums] num_count = {} for num in positive_nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 max_value = max(positive_nums) if positive_nums else None return {\\"count\\": num_count, \\"max\\": max_value}"},{"question":"def longest_substring(s: str, char: str) -> str: Returns the longest substring that starts and ends with the given character. If the character does not appear in the string, returns an empty string. >>> longest_substring(\\"a\\", \\"a\\") == \\"a\\" >>> longest_substring(\\"hello\\", \\"z\\") == \\"\\" >>> longest_substring(\\"abcdaefag\\", \\"a\\") == \\"abcdaefa\\" >>> longest_substring(\\"abacada\\", \\"a\\") == \\"abacada\\" >>> longest_substring(\\"abcad\\", \\"a\\") == \\"abca\\" >>> longest_substring(\\"\\", \\"a\\") == \\"\\" >>> longest_substring(\\"abcdefg\\", \\"c\\") == \\"c\\"","solution":"def longest_substring(s, char): Returns the longest substring that starts and ends with the given character. If the character does not appear in the string, returns an empty string. if char not in s: return \\"\\" start_index = s.find(char) end_index = s.rfind(char) if start_index == end_index: return s[start_index] return s[start_index:end_index + 1]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string with addition and multiplication, respecting the order of operations. Returns the evaluated result or an error message if the expression is invalid. >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"10+5*2+6\\") 26 >>> evaluate_expression(\\"3+2*\\") \\"Invalid expression\\"","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string with addition and multiplication, respecting the order of operations. Returns the evaluated result or an error message if the expression is invalid. import re # Check if the expression is valid (only contains digits, '+', and '*') if not re.fullmatch(r'[0-9+*]+', expression) or re.search(r'[+*]{2,}', expression) or expression[-1] in '+*': return \\"Invalid expression\\" # Split the expression into parts by '+' addition_parts = expression.split('+') # Function to handle multiplication within a part def evaluate_multiplication(part): components = part.split('*') result = 1 for component in components: result *= int(component) return result # Evaluate each part and sum them up result = 0 for part in addition_parts: result += evaluate_multiplication(part) return result"},{"question":"import asyncio import aiohttp API_ENDPOINTS = [ 'https://api.example.com/data/source1', 'https://api.example.com/data/source2', # Add more API endpoints as needed ] def clean_data(data): Cleans received data. Implement specific data cleaning logic here. # Example data cleaning logic cleaned_data = {key: value for key, value in data.items() if value is not None} return cleaned_data def aggregate_data(data_list): Aggregates data from multiple sources. # Implement aggregation logic here pass def generate_insights(aggregated_data): Generates actionable insights from aggregated data. # Implement insight generation logic here pass async def fetch_data(session, url): Fetch data asynchronously. try: async with session.get(url) as response: if response.status == 200: data = await response.json() cleaned_data = clean_data(data) return cleaned_data else: return None except aiohttp.ClientError: return None async def gather_data(): tasks = [] async with aiohttp.ClientSession() as session: for url in API_ENDPOINTS: tasks.append(fetch_data(session, url)) results = await asyncio.gather(*tasks) return [res for res in results if res is not None] def process_data(): loop = asyncio.get_event_loop() data_list = loop.run_until_complete(gather_data()) aggregated_data = aggregate_data(data_list) insights = generate_insights(aggregated_data) return insights if __name__ == \\"__main__\\": insights = process_data()","solution":"import requests import asyncio import aiohttp import concurrent.futures from datetime import datetime import logging logging.basicConfig(level=logging.INFO) API_ENDPOINTS = [ 'https://api.example.com/data/source1', 'https://api.example.com/data/source2', # Add more API endpoints as needed ] def clean_data(data): Cleans received data. Implement specific data cleaning logic here. # Example data cleaning logic cleaned_data = {key: value for key, value in data.items() if value is not None} return cleaned_data def aggregate_data(data_list): Aggregates data from multiple sources. aggregated_data = {} for data in data_list: for key, value in data.items(): if key not in aggregated_data: aggregated_data[key] = [] aggregated_data[key].append(value) # Example aggregation: Compute average for each key for key in aggregated_data: aggregated_data[key] = sum(aggregated_data[key]) / len(aggregated_data[key]) return aggregated_data def generate_insights(aggregated_data): Generates actionable insights from aggregated data. insights = {} for key, value in aggregated_data.items(): if value > 100: # Example threshold for generating insights insights[key] = 'High' else: insights[key] = 'Normal' return insights async def fetch_data(session, url): Fetch data asynchronously. try: async with session.get(url) as response: if response.status == 200: data = await response.json() cleaned_data = clean_data(data) logging.info(f\\"Fetched and cleaned data from {url}\\") return cleaned_data else: logging.error(f\\"Failed to fetch data from {url}: {response.status}\\") return None except aiohttp.ClientError as e: logging.error(f\\"Client error while fetching data from {url}: {e}\\") return None async def gather_data(): tasks = [] async with aiohttp.ClientSession() as session: for url in API_ENDPOINTS: tasks.append(fetch_data(session, url)) results = await asyncio.gather(*tasks) return [res for res in results if res is not None] def process_data(): loop = asyncio.get_event_loop() data_list = loop.run_until_complete(gather_data()) aggregated_data = aggregate_data(data_list) insights = generate_insights(aggregated_data) return insights if __name__ == \\"__main__\\": insights = process_data() logging.info(f\\"Generated insights: {insights}\\")"},{"question":"def above_average_students(students: List[Dict[str, Union[str, int]]]) -> List[str]: Returns a list of names of students whose score is above the average score of all the students in the list. The returned list is sorted in ascending order. :param students: List of dictionaries with 'name' and 'score' keys :return: List of names with above average scores, sorted alphabetically >>> above_average_students([ {'name': 'Alice', 'score': 90}, {'name': 'Bob', 'score': 80}, {'name': 'Charlie', 'score': 85}, {'name': 'David', 'score': 70} ]) ['Alice', 'Charlie'] >>> above_average_students([]) [] >>> above_average_students([{'name': 'Alice', 'score': 90}]) [] >>> above_average_students([ {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 85}, {'name': 'Charlie', 'score': 85} ]) [] >>> above_average_students([{'name': 'Alice', 'score': 60}, {'name': 'Bob', 'score': 70}]) ['Bob']","solution":"def above_average_students(students): Returns a list of names of students whose score is above the average score of all the students in the list. The returned list is sorted in ascending order. :param students: List of dictionaries with 'name' and 'score' keys :return: List of names of students with above average scores, sorted alphabetically if not students: return [] total_score = sum(student['score'] for student in students) average_score = total_score / len(students) above_avg_students = [student['name'] for student in students if student['score'] > average_score] return sorted(above_avg_students)"},{"question":"def square_positives(nums): Write a function that receives a list of integers and returns a new list containing the square of each number, but only if the original number was positive. Return \\"Invalid input\\" if the input is not a list. Return \\"All inputs were non-positive or invalid integers\\" if no valid integers meet the required conditions. Ensure that numbers are squared in the order they appear in the input list. >>> square_positives([1, -2, 3, 'a', 0, 4]) == [1, 9, 16] >>> square_positives([2, 3, 5]) == [4, 9, 25] >>> square_positives([-2, -3, -5, 'a', 0]) == \\"All inputs were non-positive or invalid integers\\" >>> square_positives('not a list') == \\"Invalid input\\" >>> square_positives({'key': 'value'}) == \\"Invalid input\\" >>> square_positives(None) == \\"Invalid input\\" >>> square_positives([]) == \\"All inputs were non-positive or invalid integers\\" >>> square_positives([-1, -4, 0, 'abc']) == \\"All inputs were non-positive or invalid integers\\"","solution":"def square_positives(nums): if not isinstance(nums, list): return \\"Invalid input\\" result = [] for num in nums: if isinstance(num, int) and num > 0: result.append(num ** 2) if not result: return \\"All inputs were non-positive or invalid integers\\" return result"},{"question":"def calculate_row_sums(matrix): Calculates the sum of each row in the 2D matrix and stores the sums in a list called row_sums. Args: matrix (list of list of int): The 2D matrix to process Returns: list of int: List containing sums of each row Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> calculate_row_sums(matrix) [6, 15, 24]","solution":"def calculate_row_sums(matrix): Calculates the sum of each row in the 2D matrix and stores the sums in a list called row_sums. Args: matrix (list of list of int): The 2D matrix to process Returns: list of int: List containing sums of each row row_sums = [sum(row) for row in matrix] return row_sums # Example usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] row_sums = calculate_row_sums(matrix) print(row_sums) # Output should be [6, 15, 24]"},{"question":"def dynamic_web_application(frontend_technology, cloud_service, ai_capability): Simulates the integration of a dynamic web application using specified frontend technology, cloud service, and AI capability. Args: frontend_technology (str): The frontend technology used (e.g., Angular). cloud_service (str): The cloud service for backend integration (e.g., Google Cloud). ai_capability (str): The AI capability for processing and analyzing data (e.g., Machine Learning). Returns: str: A string describing the successful integration. # Implementation here # Unit tests def test_successful_integration(): result = dynamic_web_application(\\"Angular\\", \\"Google Cloud\\", \\"Machine Learning\\") assert result == \\"Successfully built a dynamic web application using Angular with Google Cloud's ML capabilities.\\" def test_invalid_frontend_technology(): result = dynamic_web_application(\\"React\\", \\"Google Cloud\\", \\"Machine Learning\\") assert result == \\"Failed to integrate the specified technologies.\\" def test_invalid_cloud_service(): result = dynamic_web_application(\\"Angular\\", \\"AWS\\", \\"Machine Learning\\") assert result == \\"Failed to integrate the specified technologies.\\" def test_invalid_ai_capability(): result = dynamic_web_application(\\"Angular\\", \\"Google Cloud\\", \\"Deep Learning\\") assert result == \\"Failed to integrate the specified technologies.\\" def test_all_invalid(): result = dynamic_web_application(\\"Vue.js\\", \\"Azure\\", \\"Natural Language Processing\\") assert result == \\"Failed to integrate the specified technologies.\\"","solution":"def dynamic_web_application(frontend_technology, cloud_service, ai_capability): Simulates the integration of a dynamic web application using specified frontend technology, cloud service, and AI capability. Args: frontend_technology (str): The frontend technology used (e.g., Angular). cloud_service (str): The cloud service for backend integration (e.g., Google Cloud). ai_capability (str): The AI capability for processing and analyzing data (e.g., Machine Learning). Returns: str: A string describing the successful integration. if frontend_technology.lower() == \\"angular\\" and cloud_service.lower() == \\"google cloud\\" and ai_capability.lower() == \\"machine learning\\": return \\"Successfully built a dynamic web application using Angular with Google Cloud's ML capabilities.\\" else: return \\"Failed to integrate the specified technologies.\\""},{"question":"def is_palindrome(s: str) -> bool: Determine whether an input string is a palindrome. A string is considered a palindrome if it reads the same backward as forward. The input string will only contain lowercase alphabetical characters. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, False otherwise. return s == s[::-1]"},{"question":"def find_indices(nums, target): Returns the indices of the two numbers in the array that add up to the target. Uses a hash map to achieve O(n) time complexity. >>> find_indices([2, 7, 11, 15], 9) [0, 1] >>> find_indices([3, 2, 4], 6) [1, 2] >>> find_indices([3, 3], 6) [0, 1] >>> find_indices([1, 2, 3, 4, 5], 10) None >>> find_indices([-1, -2, -3, -4, -5], -8) [2, 4]","solution":"def find_indices(nums, target): Returns the indices of the two numbers in the array that add up to the target. Uses a hash map to achieve O(n) time complexity. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return None"},{"question":"def get_prime_subset(nums: List[int]) -> List[int]: Returns a subset of the input list consisting of prime elements in descending order. >>> get_prime_subset([10, 3, 7, 4, 11, 20]) [11, 7, 3] >>> get_prime_subset([2, 3, 5, 7, 11]) [11, 7, 5, 3, 2] >>> get_prime_subset([4, 6, 8, 10, 12]) []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def get_prime_subset(nums): Returns a subset of the input list consisting of prime elements in descending order. primes = [num for num in nums if is_prime(num)] return sorted(primes, reverse=True)"},{"question":"def find_difference(lst): Returns the difference between the largest and smallest numbers in the list. If the list is empty, returns zero. >>> find_difference([10, 2, 5, 78, 34]) 76 >>> find_difference([]) 0 >>> find_difference([5]) 0 >>> find_difference([7, 7, 7, 7]) 0 >>> find_difference([-10, 0, 10, 20, -20]) 40 >>> find_difference([1, 2, 3, 4, 5, 6]) 5 >>> find_difference([100000, 1, 100]) 99999 # Your code here","solution":"def find_difference(lst): Returns the difference between the largest and smallest numbers in the list. If the list is empty, returns zero. if not lst: return 0 return max(lst) - min(lst)"},{"question":"def process_file(file_path): Read a text file containing a list of integers (one per line) and performs the following tasks: 1. Identifies and prints the smallest and largest integers in the list. 2. Calculates and prints the average of the integers. 3. Generates and prints a new list where each integer is replaced by the square of the difference between the integer and the average. 4. Ensures error handling for cases where the file might not exist or contains non-integer values, with appropriate error messages. >>> process_file(\\"test.txt\\") The smallest integer: 1 The largest integer: 5 The average of the integers: 3.0 List of squared differences: [4.0, 1.0, 0.0, 1.0, 4.0] import os from io import StringIO import sys def test_normal_case(tmp_path): d = tmp_path / \\"sub\\" d.mkdir() file_path = d / \\"test.txt\\" file_path.write_text(\\"1n2n3n4n5n\\") old_stdout = sys.stdout sys.stdout = my_stdout = StringIO() process_file(file_path) sys.stdout = old_stdout output = my_stdout.getvalue().strip().split('n') assert \\"The smallest integer: 1\\" in output assert \\"The largest integer: 5\\" in output assert \\"The average of the integers: 3.0\\" in output assert \\"List of squared differences: [4.0, 1.0, 0.0, 1.0, 4.0]\\" in output def test_empty_file(tmp_path): d = tmp_path / \\"sub\\" d.mkdir() file_path = d / \\"test.txt\\" file_path.write_text(\\"\\") old_stdout = sys.stdout sys.stdout = my_stdout = StringIO() process_file(file_path) sys.stdout = old_stdout output = my_stdout.getvalue().strip() assert output == \\"The file is empty.\\" def test_non_existent_file(tmp_path): file_path = tmp_path / \\"non_existent.txt\\" old_stdout = sys.stdout sys.stdout = my_stdout = StringIO() process_file(file_path) sys.stdout = old_stdout output = my_stdout.getvalue().strip() assert output == \\"Error: The file does not exist.\\" def test_non_integer_values(tmp_path): d = tmp_path / \\"sub\\" d.mkdir() file_path = d / \\"test.txt\\" file_path.write_text(\\"1n2nthreen4n5n\\") old_stdout = sys.stdout sys.stdout = my_stdout = StringIO() process_file(file_path) sys.stdout = old_stdout output = my_stdout.getvalue().strip() assert output == \\"Error: The file contains non-integer values.\\"","solution":"def process_file(file_path): try: with open(file_path, 'r') as file: numbers = [int(line.strip()) for line in file] if not numbers: print(\\"The file is empty.\\") return smallest = min(numbers) largest = max(numbers) average = sum(numbers) / len(numbers) squared_diffs = [(num - average) ** 2 for num in numbers] print(f\\"The smallest integer: {smallest}\\") print(f\\"The largest integer: {largest}\\") print(f\\"The average of the integers: {average}\\") print(f\\"List of squared differences: {squared_diffs}\\") except FileNotFoundError: print(\\"Error: The file does not exist.\\") except ValueError: print(\\"Error: The file contains non-integer values.\\")"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Removes consecutive duplicate characters from a string s. :param s: str, input string :return: str, with consecutive duplicates removed >>> remove_consecutive_duplicates(\\"aabbccddeeff\\") == \\"abcdef\\" >>> remove_consecutive_duplicates(\\"aaAAaaBBbb\\") == \\"aAaBb\\" >>> remove_consecutive_duplicates(\\"mississippi\\") == \\"misisipi\\" >>> remove_consecutive_duplicates(\\"\\") == \\"\\" >>> remove_consecutive_duplicates(\\"abc\\") == \\"abc\\" >>> remove_consecutive_duplicates(\\"a\\") == \\"a\\" >>> remove_consecutive_duplicates(\\"1122334455\\") == \\"12345\\" >>> remove_consecutive_duplicates(\\"!!@@\\") == \\"!@#\\" >>> remove_consecutive_duplicates(\\"abababab\\") == \\"abababab\\" >>> remove_consecutive_duplicates(\\"aAaAaAa\\") == \\"aAaAaAa\\"","solution":"def remove_consecutive_duplicates(s): Removes consecutive duplicate characters from a string s. :param s: str, input string :return: str, with consecutive duplicates removed if not s: return \\"\\" result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def cumulative_sum(lst): Returns a new list with each element being the cumulative sum of the elements up to that index. >>> cumulative_sum([1, 2, 3, 4]) == [1, 3, 6, 10] >>> cumulative_sum([]) == [] >>> cumulative_sum([5]) == [5] >>> cumulative_sum([0, 0, 0, 0]) == [0, 0, 0, 0] >>> cumulative_sum([1, -1, 2, -2, 3, -3]) == [1, 0, 2, 0, 3, 0] >>> cumulative_sum([2, -1, 3, 0, -2, 4]) == [2, 1, 4, 4, 2, 6]","solution":"def cumulative_sum(lst): Returns a new list with each element being the cumulative sum of the elements up to that index. Parameters: lst (list): A list of integers. Returns: list: A list where each element is the cumulative sum up to that index. if not lst: return [] cum_sum = [lst[0]] for i in range(1, len(lst)): cum_sum.append(cum_sum[-1] + lst[i]) return cum_sum"},{"question":"from typing import List def find_longest_substring(s: str) -> str: Returns the longest substring without repeating characters. If multiple substrings have the same maximum length, returns the one which appears first. >>> find_longest_substring(\\"abrkaabcdefghijjxxx\\") == \\"abcdefghij\\" >>> find_longest_substring(\\"abcdefg\\") == \\"abcdefg\\" >>> find_longest_substring(\\"aaaaa\\") == \\"a\\" >>> find_longest_substring(\\"abcdabcbb\\") == \\"abcd\\" >>> find_longest_substring(\\"bbbbbabcdefg\\") == \\"abcdefg\\" >>> find_longest_substring(\\"abcabcbb\\") == \\"abc\\" >>> find_longest_substring(\\"bbabcde\\") == \\"abcde\\"","solution":"def find_longest_substring(s): Returns the longest substring without repeating characters. If multiple substrings have the same maximum length, returns the one which appears first. start = 0 max_length = 0 max_start = 0 seen = {} for i, char in enumerate(s): if char in seen and seen[char] >= start: start = seen[char] + 1 seen[char] = i if i - start + 1 > max_length: max_length = i - start + 1 max_start = start return s[max_start:max_start + max_length]"},{"question":"def is_prime(number: int) -> bool: Returns True if the number is a prime, else False. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(17) True >>> is_prime(18) False pass def filter_primes(numbers: list[int]) -> list[int]: Filters the list of integers, returning only the prime numbers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([1, 2, 3, 4, 5]) [2, 3, 5] >>> filter_primes([10, 12, 15, 21, 22]) [] >>> filter_primes([17, 19, 23, 29, 31, 37]) [17, 19, 23, 29, 31, 37] >>> filter_primes([15, 20, 25, 30, 35, 40]) [] >>> filter_primes([31, 32, 33, 34, 35, 36, 37]) [31, 37] >>> filter_primes([]) [] >>> filter_primes([3]) [3] >>> filter_primes([4]) [] pass","solution":"def is_prime(number: int) -> bool: Returns True if the number is a prime, else False. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True def filter_primes(numbers: list[int]) -> list[int]: Filters the list of integers, returning only the prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"import time class TrafficLight: def __init__(self): Initialize the traffic light with the durations for each color self.colors = [\\"Red\\", \\"Green\\", \\"Yellow\\"] self.durations = {\\"Red\\": 7, \\"Green\\": 5, \\"Yellow\\": 2} def simulate(self): Simulate the traffic light by cycling through the colors for color in self.colors: duration = self.durations[color] for remaining_time in range(duration, 0, -1): print(f\\"Light: {color}, Time remaining: {remaining_time} seconds\\") time.sleep(1) def start(self): Start the traffic light simulation print(\\"Traffic Light Simulation Started\\") self.simulate() print(\\"Traffic Light Simulation Ended\\")","solution":"import time class TrafficLight: def __init__(self): # Initialize the traffic light with the durations for each color self.colors = [\\"Red\\", \\"Green\\", \\"Yellow\\"] self.durations = {\\"Red\\": 7, \\"Green\\": 5, \\"Yellow\\": 2} def simulate(self): # Simulate the traffic light by cycling through the colors for color in self.colors: duration = self.durations[color] for remaining_time in range(duration, 0, -1): print(f\\"Light: {color}, Time remaining: {remaining_time} seconds\\") time.sleep(1) def start(self): print(\\"Traffic Light Simulation Started\\") self.simulate() print(\\"Traffic Light Simulation Ended\\")"},{"question":"def compound_interest(principal, rate, time): Given principal amount, annual interest rate, and time in years, calculates and returns the compound interest assuming it's compounded annually. >>> compound_interest(1000, 5, 2) 1102.5 >>> compound_interest(0, 5, 2) 0 >>> compound_interest(1000, 0, 2) 1000 >>> compound_interest(1000, 5, 0) 1000","solution":"def compound_interest(principal, rate, time): Given principal amount, annual interest rate, and time in years, calculates and returns the compound interest assuming it's compounded annually. if not isinstance(principal, (int, float)) or principal < 0: raise ValueError(\\"Principal must be a non-negative number.\\") if not isinstance(rate, (int, float)) or rate < 0: raise ValueError(\\"Rate of interest must be a non-negative number.\\") if not isinstance(time, (int, float)) or time < 0: raise ValueError(\\"Time duration must be a non-negative number.\\") return principal * (1 + rate / 100) ** time"},{"question":"def employee_bonus(emp_id): Calculate the employee bonus for part-time and full-time employees. For part-time employees (even IDs), multiply the ID by the sum of all even digits within the ID. For full-time employees (odd IDs), multiply the ID by the sum of all odd digits within the ID. The function also needs to handle edge cases and ensure robust error handling. Parameters: emp_id (int): positive employee ID Returns: int: calculated bonus based on the rules defined Raises: ValueError: if emp_id is not a positive integer >>> employee_bonus(246) 2952 >>> employee_bonus(135) 1215 >>> employee_bonus(1) 1 >>> employee_bonus(2) 4 >>> employee_bonus(\\"123\\") Traceback (most recent call last): ... ValueError: Employee ID must be a positive integer >>> employee_bonus(-1) Traceback (most recent call last): ... ValueError: Employee ID must be a positive integer >>> employee_bonus(0) Traceback (most recent call last): ... ValueError: Employee ID must be a positive integer # Your code here","solution":"def employee_bonus(emp_id): Calculate the employee bonus for part-time and full-time employees. Parameters: emp_id (int): positive employee ID Returns: int: calculated bonus based on the rules defined Raises: ValueError: if emp_id is not a positive integer if not isinstance(emp_id, int) or emp_id <= 0: raise ValueError(\\"Employee ID must be a positive integer\\") emp_id_str = str(emp_id) if emp_id % 2 == 0: # Part-time employee sum_even_digits = sum(int(digit) for digit in emp_id_str if int(digit) % 2 == 0) bonus = emp_id * sum_even_digits else: # Full-time employee sum_odd_digits = sum(int(digit) for digit in emp_id_str if int(digit) % 2 != 0) bonus = emp_id * sum_odd_digits return bonus"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverse the order of words in a sentence while preserving the original order of characters within each word, and ensure that multiple spaces between words are reduced to a single space, and leading or trailing spaces are removed. >>> reverse_words_in_sentence(\\" Hello world this is an example \\") \\"example an is this world Hello\\" >>> reverse_words_in_sentence(\\"Hello\\") \\"Hello\\" >>> reverse_words_in_sentence(\\" multiple spaces here \\") \\"here spaces multiple\\" >>> reverse_words_in_sentence(\\" trailing and leading spaces \\") \\"spaces leading and trailing\\" >>> reverse_words_in_sentence(\\"NoSpaces\\") \\"NoSpaces\\" >>> reverse_words_in_sentence(\\" \\") \\"\\" >>> reverse_words_in_sentence(\\"\\") \\"\\"","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the order of words in the sentence while preserving the order of characters within each word. Extra spaces between words are reduced to a single space, and leading or trailing spaces are removed. Parameters: sentence (str): The input sentence. Returns: str: The sentence with words reversed and extra spaces removed. # Split the sentence by spaces and filter out any empty strings words = [word for word in sentence.split(' ') if word] # Reverse the order of the words and join them with a single space reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def organize_students(course_list): Takes a list of nested lists where each nested list contains a course name followed by student names. Returns a dictionary where the keys are department names and the values are lists of unique student names sorted alphabetically across all courses belonging to that department. >>> organize_students([ [\\"CS101\\", \\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"cs102\\", \\"David\\", \\"Eve\\", \\"Alice\\"], [\\"MATH101\\", \\"Frank\\", \\"Grace\\"], [\\"Math102\\", \\"Eve\\", \\"Bob\\", \\"Grace\\"], ]) {'CS1': ['alice', 'bob', 'charlie', 'david', 'eve'], 'MAT': ['bob', 'eve', 'frank', 'grace']} >>> organize_students([ [\\"CS101\\", \\"ALICE\\", \\"bob\\", \\"Charlie\\"], [\\"cs102\\", \\"DAVID\\", \\"Eve\\", \\"Alice\\"], [\\"CS103\\", \\"Alice\\", \\"BOB\\"] ]) {'CS1': ['alice', 'bob', 'charlie', 'david', 'eve']} >>> organize_students([]) {} >>> organize_students([ [\\"PHYS101\\", \\"Isaac\\", \\"Albert\\"] ]) {'PHY': ['albert', 'isaac']} >>> organize_students([ [\\"CHEM101\\", \\"Marie\\", \\"Linus\\"], [\\"BIO101\\", \\"Rosalind\\", \\"Watson\\"], [\\"BIO102\\", \\"Crick\\", \\"Rosalind\\"], [\\"CHEM102\\", \\"Curie\\", \\"Linus\\"] ]) {'CHE': ['curie', 'linus', 'marie'], 'BIO': ['crick', 'rosalind', 'watson']} from collections import defaultdict department_dict = defaultdict(set) for course in course_list: course_name = course[0] students = course[1:] department_name = course_name[:3].upper() for student in students: department_dict[department_name].add(student.lower()) result_dict = {} for key, value in department_dict.items(): result_dict[key] = sorted(value) return result_dict","solution":"def organize_students(course_list): Takes a list of nested lists where each nested list contains a course name followed by student names. Returns a dictionary where the keys are department names and the values are lists of unique student names sorted alphabetically across all courses belonging to that department. from collections import defaultdict department_dict = defaultdict(set) for course in course_list: course_name = course[0] students = course[1:] department_name = course_name[:3].upper() for student in students: department_dict[department_name].add(student.lower()) result_dict = {} for key, value in department_dict.items(): result_dict[key] = sorted(value) return result_dict"},{"question":"def find_min_max(values: List[int]) -> Tuple[int, int]: Design a function that, given a list of integer values, identifies and returns the maximum and minimum values from the list as a tuple. >>> find_min_max([7, 2, 9, 4, 1, 5]) (1, 9) >>> find_min_max([42]) (42, 42) >>> find_min_max([1, 2, 3, 4, 5, 6, 7, 8, 9]) (1, 9) >>> find_min_max([9, 8, 7, 6, 5, 4, 3, 2, 1]) (1, 9) >>> find_min_max([-1, -5, -3, -7]) (-7, -1) >>> find_min_max([-10, 0, 10, -20, 20]) (-20, 20) >>> find_min_max([4, 4, 4, 4]) (4, 4) >>> find_min_max([]) Traceback (most recent call last): ... ValueError: The list is empty","solution":"def find_min_max(values): Returns the minimum and maximum values from a list of integers as a tuple. if not values: raise ValueError(\\"The list is empty\\") min_val = max_val = values[0] for value in values[1:]: if value < min_val: min_val = value if value > max_val: max_val = value return (min_val, max_val)"},{"question":"def reverse_words(s: str) -> str: Reverses each word in the string s while maintaining the original order of words. Parameters: s (str): The input string. Returns: str: The transformed string with each word reversed. Example: >>> reverse_words(\\"Hello\\") 'olleH' >>> reverse_words(\\"Hello World!\\") 'olleH !dlroW' >>> reverse_words(\\"Hello World!\\") 'olleH !dlroW' >>> reverse_words(\\"Hello, World!\\") ',olleH !dlroW' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") ' ' >>> reverse_words(\\"ThIs Is A TeSt!\\") 'sIhT sI A !tSeT'","solution":"def reverse_words(s): Reverses each word in the string s while maintaining the original order of words. Parameters: s (str): The input string. Returns: str: The transformed string with each word reversed. words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def move_zeroes(nums: list): Moves all zeroes in the list 'nums' to the end while maintaining the order of non-zero elements. The operation should be performed in-place with optimal time and space complexity. Examples: >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 1] >>> move_zeroes(nums) >>> nums [1, 0, 0] >>> nums = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0] >>> move_zeroes(nums) >>> nums [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]","solution":"def move_zeroes(nums: list): Moves all zeroes in the list 'nums' to the end while maintaining the order of non-zero elements. The operation should be performed in-place with optimal time and space complexity. zero_index = 0 # position to put the next non-zero element for i in range(len(nums)): if nums[i] != 0: nums[zero_index], nums[i] = nums[i], nums[zero_index] zero_index += 1"},{"question":"def extract_file_extension(file_name: str) -> str: This function should return the file extension of the provided file name. >>> extract_file_extension(\\"example.txt\\") 'txt' >>> extract_file_extension(\\"document.pdf\\") 'pdf' >>> extract_file_extension(\\"my.homework.docx\\") 'docx' >>> extract_file_extension(\\"archive.tar.gz\\") 'gz'","solution":"def extract_file_extension(file_name: str) -> str: This function should return the file extension of the provided file name. >>> extract_file_extension(\\"example.txt\\") 'txt' >>> extract_file_extension(\\"document.pdf\\") 'pdf' >>> extract_file_extension(\\"my.homework.docx\\") 'docx' >>> extract_file_extension(\\"archive.tar.gz\\") 'gz' extension_start = -1 for i in range(len(file_name)): if file_name[i] == '.': extension_start = i extension = \\"\\" for i in range(extension_start + 1, len(file_name)): extension += file_name[i] return extension"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aabbcc\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} start = 0 max_length = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"import re def is_palindrome(s: str) -> bool: Checks whether a given string is a palindrome, ignoring spaces, punctuation, and case. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Madam\\") True >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"a man a plan a canal panama\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"world\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True","solution":"import re def is_palindrome(s): Checks whether a given string is a palindrome, ignoring spaces, punctuation, and case. cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_s == cleaned_s[::-1]"},{"question":"def reverse_words_order_and_characters(string: str) -> str: Reverses the words in the string while maintaining the order of characters within each word. >>> reverse_words_order_and_characters(\\"hello world this is a test\\") \\"olleh dlrow siht si a tset\\" >>> reverse_words_order_and_characters(\\"a b c\\") \\"a b c\\" >>> reverse_words_order_and_characters(\\"one two three\\") \\"eno owt eerht\\" >>> reverse_words_order_and_characters(\\"abc def ghi\\") \\"cba fed ihg\\" >>> reverse_words_order_and_characters(\\"singleword\\") \\"drowelgnis\\" >>> reverse_words_order_and_characters(\\"\\") \\"\\" >>> reverse_words_order_and_characters(\\" a \\") \\"a\\"","solution":"def reverse_words_order_and_characters(string): Reverses the words in the string while maintaining the order of characters within each word. words = string.split() reversed_words = [word[::-1] for word in words] reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def num_decodings(s: str) -> int: Implement a function that takes a string containing digits and returns the number of possible ways to decode it, based on the mapping 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. >>> num_decodings(\\"12\\") == 2 >>> num_decodings(\\"226\\") == 3 >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"10\\") == 1","solution":"def num_decodings(s: str) -> int: Returns the number of possible ways to decode the input string. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if s[i-1] != '0': dp[i] += dp[i-1] two_digit = int(s[i-2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. # Write your implementation here def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. :param lst: List of integers :return: List of prime integers >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10, 12]) [] >>> filter_primes([]) [] >>> filter_primes([-3, -2, 0, 1, 2, 3, 4]) [2, 3] # Write your implementation here","solution":"def is_prime(n): Check if a number is prime if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(lst): Returns a list containing only the prime numbers from the input list. :param lst: List of integers :return: List of prime integers return [x for x in lst if is_prime(x)]"},{"question":"def is_valid(s: str) -> bool: Determine if the string s consisting only of characters '(', ')', '{', '}', '[' and ']', is valid. >>> is_valid(\\"()\\") True >>> is_valid(\\"()[]{}\\") True >>> is_valid(\\"(]\\") False >>> is_valid(\\"([)]\\") False >>> is_valid(\\"{[]}\\") True","solution":"def is_valid(s): Returns true if the input string has valid parentheses, otherwise false. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket: top_element = stack.pop() if stack else '#' if matching_bracket[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"import re from collections import Counter def count_words(text: str) -> dict: Write a function that takes in a string of text containing words and punctuations. The function should filter out any punctuation and only retain alphabetic characters and spaces. It should then count and return the number of each unique word in the text, case-insensitively. Words should be considered the same regardless of their case (e.g., \\"Apple\\" and \\"apple\\" should be counted as the same word). >>> count_words(\\"Hello, world! Hello... HELLO.\\") {\\"hello\\": 3, \\"world\\": 1} >>> count_words(\\"It's a test! A test, I say; a TEST!\\") {\\"its\\": 1, \\"a\\": 3, \\"test\\": 3, \\"i\\": 1, \\"say\\": 1} >>> count_words(\\"Apple apple APPLE!\\") {\\"apple\\": 3} def test_single_sentence(): assert count_words(\\"Hello, world! Hello... HELLO.\\") == { \\"hello\\": 3, \\"world\\": 1 } def test_punctuation(): assert count_words(\\"It's a test! A test, I say; a TEST!\\") == { \\"its\\": 1, \\"a\\": 3, \\"test\\": 3, \\"i\\": 1, \\"say\\": 1 } def test_mixed_case(): assert count_words(\\"Apple apple APPLE!\\") == { \\"apple\\": 3 } def test_empty_string(): assert count_words(\\"\\") == {} def test_no_punctuation(): assert count_words(\\"This is a simple test case with no punctuation\\") == { \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"simple\\": 1, \\"test\\": 1, \\"case\\": 1, \\"with\\": 1, \\"no\\": 1, \\"punctuation\\": 1 } def test_only_punctuation(): assert count_words(\\"!!!...,,,;;;:::\\") == {}","solution":"import re from collections import Counter def count_words(text: str) -> dict: This function takes a string of text, removes punctuation, and returns a dictionary with the count of each unique word, case-insensitively. # Remove punctuation using regex text = re.sub(r'[^ws]', '', text) # Convert text to lowercase text = text.lower() # Split the text into words words = text.split() # Count the words word_count = Counter(words) return dict(word_count)"},{"question":"def find_next_fibonacci(n: int) -> int: Calculate the smallest Fibonacci number greater than a given number n. >>> find_next_fibonacci(21) 34 >>> find_next_fibonacci(50) 55 >>> find_next_fibonacci(0) 1 >>> find_next_fibonacci(1) 2 >>> find_next_fibonacci(10000) 10946","solution":"def find_next_fibonacci(n): Returns the smallest Fibonacci number greater than a given number n. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") a, b = 0, 1 while b <= n: a, b = b, a + b return b"},{"question":"def elements_greater_than_average(lst: List[int]) -> List[int]: Returns a list of elements that are greater than the average of the original list. >>> elements_greater_than_average([4, 8, 2, 6, 1, 9]) [8, 6, 9] >>> elements_greater_than_average([5, 5, 5, 5]) [] >>> elements_greater_than_average([]) [] >>> elements_greater_than_average([10]) [] >>> elements_greater_than_average([-10, -5, 0, 5, 10]) [5, 10] >>> elements_greater_than_average([-10, -8, -6, -4]) [-6, -4] pass","solution":"def elements_greater_than_average(lst): Returns a list of elements that are greater than the average of the original list. if not lst: return [] average = sum(lst) / len(lst) return [x for x in lst if x > average]"},{"question":"def decrement_binaries(binaries: List[str]) -> List[str]: Takes a list of strings representing binary numbers and returns a new list where each binary number has been decreased by one. If the binary number is '0', it should remain '0'. >>> decrement_binaries(['101']) ['100'] >>> decrement_binaries(['0010', '0001']) ['0001', '0000'] >>> decrement_binaries(['0']) ['0'] >>> decrement_binaries(['101', '0010', '0001', '0']) ['100', '0001', '0000', '0'] >>> decrement_binaries(['0', '0', '0']) ['0', '0', '0'] >>> decrement_binaries(['100000']) ['011111']","solution":"def decrement_binaries(binaries): Takes a list of strings representing binary numbers and returns a new list where each binary number has been decreased by one. If the binary number is '0', it should remain '0'. result = [] for binary in binaries: if binary == '0': result.append('0') continue decimal = int(binary, 2) if decimal == 0: result.append('0') else: decremented_decimal = decimal - 1 decremented_binary = bin(decremented_decimal)[2:] leading_zeros = len(binary) - len(decremented_binary) result.append('0' * leading_zeros + decremented_binary) return result"},{"question":"import pandas as pd def sort_dataframe(df: pd.DataFrame) -> pd.DataFrame: Returns a new DataFrame sorted by 'score' in descending order. If scores are tied, it sorts by 'age' in ascending order. Parameters: df (pd.DataFrame): The input DataFrame with columns 'name', 'age', and 'score'. Returns: pd.DataFrame: The sorted DataFrame.","solution":"import pandas as pd def sort_dataframe(df): Returns a new DataFrame sorted by 'score' in descending order. If scores are tied, it sorts by 'age' in ascending order. Parameters: df (pd.DataFrame): The input DataFrame with columns 'name', 'age', and 'score'. Returns: pd.DataFrame: The sorted DataFrame. return df.sort_values(by=['score', 'age'], ascending=[False, True])"},{"question":"def find_maximal_rectangle(matrix): Create a function find_maximal_rectangle that accepts a 2D binary matrix filled with 0’s and 1’s and finds the largest rectangle containing only 1’s. Return its area. Make sure to handle edge cases such as an empty matrix or matrix with no 1's. Arguments: matrix -- 2D list of integers (0 or 1) Returns: int -- area of the largest rectangle containing only 1's >>> find_maximal_rectangle([]) 0 >>> find_maximal_rectangle([[]]) 0 >>> find_maximal_rectangle([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> find_maximal_rectangle([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> find_maximal_rectangle([[1, 1], [1, 1]]) 4 >>> find_maximal_rectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 6","solution":"def find_maximal_rectangle(matrix): Finds the largest rectangle containing only 1's in a binary matrix and returns its area. Arguments: matrix -- 2D list of integers (0 or 1) Returns: int -- area of the largest rectangle containing only 1's if not matrix or not matrix[0]: return 0 def largest_histogram_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area n, m = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): if matrix[i][j] == 1: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"def quicksort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the quicksort algorithm. >>> quicksort([]) == [] >>> quicksort([1]) == [1] >>> quicksort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> quicksort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> quicksort([4, 2, 2, 8, 7, 3, 3, 3, 1]) == [1, 2, 2, 3, 3, 3, 4, 7, 8] >>> quicksort([0, -1, -2, -3, 2, 1, 3]) == [-3, -2, -1, 0, 1, 2, 3] >>> quicksort([5, -3, 2, 0, -1, 4, -2]) == [-3, -2, -1, 0, 2, 4, 5]","solution":"def quicksort(arr): Sorts a list of integers in ascending order using the quicksort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"def reverse_words_preserve_positions(s: str) -> str: Reverses the characters in each word of the string s, but preserves the original positions of the words. >>> reverse_words_preserve_positions(\\"hello\\") \\"olleh\\" >>> reverse_words_preserve_positions(\\"world\\") \\"dlrow\\" >>> reverse_words_preserve_positions(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_preserve_positions(\\"goodbye cruel world\\") \\"eybdoog leurc dlrow\\" >>> reverse_words_preserve_positions(\\"hello, world!\\") \\",olleh !dlrow\\" >>> reverse_words_preserve_positions(\\"It's a beautiful day.\\") \\"s'tI a lufituaeb .yad\\" >>> reverse_words_preserve_positions(\\" hello world \\") \\" olleh dlrow \\" >>> reverse_words_preserve_positions(\\"multiple spaces\\") \\"elpitlum secaps\\" >>> reverse_words_preserve_positions(\\"\\") \\"\\" >>> reverse_words_preserve_positions(\\" \\") \\" \\"","solution":"def reverse_words_preserve_positions(s): Reverses the characters in each word of the string s, but preserves the original positions of the words. words = s.split(' ') reversed_words = [''.join(reversed(word)) for word in words] return ' '.join(reversed_words)"},{"question":"def has_cycle(graph): Detects whether a given directed graph contains a cycle. :param graph: Dict representing an adjacency list of a directed graph :return: Boolean, True if there is a cycle, False otherwise >>> has_cycle({'A': ['B'], 'B': ['C'], 'C': ['A']}) True >>> has_cycle({'A': ['B', 'C'], 'B': ['C'], 'C': []}) False","solution":"def has_cycle(graph): Detects whether a given directed graph contains a cycle. :param graph: Dict representing an adjacency list of a directed graph :return: Boolean, True if there is a cycle, False otherwise def visit(node): if node in temp_marked: return True if node in visited: return False temp_marked.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True temp_marked.remove(node) visited.add(node) return False visited = set() temp_marked = set() for node in graph: if visit(node): return True return False"},{"question":"from typing import List def binary_search(arr: List[int], target: int) -> bool: Implements a binary search algorithm to determine if a target value exists within a sorted array of integers. >>> binary_search([], 1) False >>> binary_search([1], 1) True >>> binary_search([1], 2) False >>> binary_search([1, 2, 3, 4, 5], 3) True >>> binary_search([1, 2, 3, 4, 5], 6) False >>> binary_search([1, 2, 3, 4, 5], 2) True >>> binary_search([1, 2, 3, 4, 5], 4) True >>> binary_search([1, 2, 3, 4, 5], 1) True >>> binary_search([1, 2, 3, 4, 5], 5) True","solution":"def binary_search(arr, target): Performs binary search on a sorted array to determine if the target value exists. Parameters: arr (list of int): The sorted list of integers. target (int): The integer target value to search for. Returns: bool: True if the target value is found, False otherwise. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return True elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"def longest_substring_two_distinct(s: str) -> str: Returns the longest substring that contains at most two distinct characters. :param s: The input string. :return: The longest substring with at most two distinct characters. pass def test_longest_substring_two_distinct_all_same(): assert longest_substring_two_distinct(\\"aaaa\\") == \\"aaaa\\" def test_longest_substring_two_distinct_two_diff(): assert longest_substring_two_distinct(\\"aabbcc\\") == \\"aabb\\" def test_longest_substring_two_distinct_multiple_options(): result = longest_substring_two_distinct(\\"eceba\\") assert result == \\"ece\\" or result == \\"ba\\" def test_longest_substring_two_distinct_edge_case_empty(): assert longest_substring_two_distinct(\\"\\") == \\"\\" def test_longest_substring_two_distinct_edge_case_one_char(): assert longest_substring_two_distinct(\\"a\\") == \\"a\\" def test_longest_substring_two_distinct_long_input(): assert longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") == \\"bcbbbbcccb\\" def test_longest_substring_two_distinct_complex_case(): assert longest_substring_two_distinct(\\"abaccc\\") == \\"accc\\"","solution":"def longest_substring_two_distinct(s): Returns the longest substring that contains at most two distinct characters. :param s: The input string. :return: The longest substring with at most two distinct characters. from collections import defaultdict n = len(s) if n == 0: return \\"\\" left = 0 max_len = 0 max_substr = \\"\\" char_map = defaultdict(int) for right in range(n): char_map[s[right]] += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substr = s[left:right+1] return max_substr"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray and the subarray itself. >>> max_subarray_sum([1, 2, 3, 4, 5]) (15, [1, 2, 3, 4, 5]) >>> max_subarray_sum([-1, -2, -3, -4, -5]) (-1, [-1]) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> max_subarray_sum([5]) (5, [5]) >>> max_subarray_sum([-5]) (-5, [-5]) >>> max_subarray_sum([]) (0, [])","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray and the subarray itself. if not arr: return 0, [] max_sum = current_sum = arr[0] start = end = s = 0 for i in range(1, len(arr)): if current_sum + arr[i] > arr[i]: current_sum += arr[i] else: current_sum = arr[i] s = i if current_sum > max_sum: max_sum = current_sum start = s end = i return max_sum, arr[start:end+1]"},{"question":"def unique_in_order(lst: List) -> List: Returns a list with the unique elements of lst while preserving their original order. >>> unique_in_order([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_in_order(['a', 'b', 'a', 'c', 'd', 'd']) ['a', 'b', 'c', 'd'] >>> unique_in_order([1, '2', 2, '2', 3, '3']) [1, '2', 2, 3, '3']","solution":"def unique_in_order(lst): Returns a list with the unique elements of lst while preserving their original order. seen = set() unique_list = [] for item in lst: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Uses sliding window technique for efficient implementation. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\" \\") == 1 >>> length_of_longest_substring(\\"au\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"123abc!@#123!\\") == 9 >>> length_of_longest_substring(\\"!@#123!@#\\") == 6 >>> length_of_longest_substring(\\"a\\" * 100000) == 1 >>> length_of_longest_substring(\\"ab\\" * 50000) == 2","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Uses sliding window technique for efficient implementation. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def distribute_tasks(tasks: List[int]) -> Tuple[List[int], List[int]]: Distribute tasks between two machines to minimize the total workload difference. >>> distribute_tasks([10, 20, 15, 5, 25]) ([15, 10, 5], [20, 25]) >>> distribute_tasks([10]) ([10], []) >>> distribute_tasks([10, 10]) ([10], [10]) pass # Add your implementation here # Test cases def test_distribute_tasks_basic(): tasks = [10, 20, 15, 5, 25] machine1, machine2 = distribute_tasks(tasks) assert abs(sum(machine1) - sum(machine2)) <= 25 def test_distribute_tasks_single_task(): tasks = [10] machine1, machine2 = distribute_tasks(tasks) assert (sum(machine1) == 10 and sum(machine2) == 0) or (sum(machine1) == 0 and sum(machine2) == 10) def test_distribute_tasks_two_equal_tasks(): tasks = [10, 10] machine1, machine2 = distribute_tasks(tasks) assert abs(sum(machine1) - sum(machine2)) == 0 def test_distribute_tasks_multiple_tasks(): tasks = [20, 5, 10, 15, 30, 5] machine1, machine2 = distribute_tasks(tasks) assert abs(sum(machine1) - sum(machine2)) <= 15 def test_distribute_tasks_complex(): tasks = [12, 11, 13, 5, 10, 14, 6] machine1, machine2 = distribute_tasks(tasks) assert abs(sum(machine1) - sum(machine2)) <= 5 def test_distribute_tasks_large_difference(): tasks = [1000, 1] machine1, machine2 = distribute_tasks(tasks) assert (sum(machine1) == 1000 and sum(machine2) == 1) or (sum(machine1) == 1 and sum(machine2) == 1000) if __name__ == \\"__main__\\": test_distribute_tasks_basic() test_distribute_tasks_single_task() test_distribute_tasks_two_equal_tasks() test_distribute_tasks_multiple_tasks() test_distribute_tasks_complex() test_distribute_tasks_large_difference()","solution":"def distribute_tasks(tasks): Distributes tasks between two machines to minimize the total workload difference. total_workload = sum(tasks) target = total_workload // 2 dp = [[False] * (target + 1) for _ in range(len(tasks) + 1)] dp[0][0] = True for i in range(1, len(tasks) + 1): for j in range(target + 1): if j >= tasks[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - tasks[i - 1]] else: dp[i][j] = dp[i - 1][j] for i in range(target, -1, -1): if dp[len(tasks)][i]: closest_sum = i break machine1 = [] machine2 = [] w = closest_sum for i in range(len(tasks), 0, -1): if dp[i-1][w]: machine2.append(tasks[i-1]) else: machine1.append(tasks[i-1]) w -= tasks[i-1] return machine1, machine2"},{"question":"from collections import deque def bfs(graph, start): Perform a Breadth-First Search on the given graph starting from the 'start' node. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (any): The starting node for the BFS traversal. Returns: list: A list of nodes in the order they were visited during the BFS traversal. # Implement the BFS algorithm here def test_bfs_basic(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } assert bfs(graph, 'A') == ['A', 'B', 'C', 'D', 'E', 'F'] def test_bfs_directed(): graph = { 'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': ['F'], 'F': [] } assert bfs(graph, 'A') == ['A', 'B', 'C', 'D', 'E', 'F'] def test_bfs_isolated_node(): graph = { 'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C'], 'E': [] } assert bfs(graph, 'A') == ['A', 'B'] assert bfs(graph, 'C') == ['C', 'D'] assert bfs(graph, 'E') == ['E'] def test_bfs_single_node(): graph = { 'A': [] } assert bfs(graph, 'A') == ['A'] def test_bfs_with_cycles(): graph = { 'A': ['B'], 'B': ['C', 'D'], 'C': ['A', 'E'], 'D': ['F'], 'E': ['F'], 'F': ['C'] } assert bfs(graph, 'A') == ['A', 'B', 'C', 'D', 'E', 'F'] def test_bfs_disconnected(): graph = { 'A': ['B'], 'B': ['A'], 'C': ['D'], 'D': ['C'] } assert bfs(graph, 'A') == ['A', 'B'] assert bfs(graph, 'C') == ['C', 'D']","solution":"from collections import deque def bfs(graph, start): Perform a Breadth-First Search on the given graph starting from the 'start' node. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (any): The starting node for the BFS traversal. Returns: list: A list of nodes in the order they were visited during the BFS traversal. visited = set() queue = deque([start]) order_of_visit = [] while queue: current_node = queue.popleft() if current_node not in visited: visited.add(current_node) order_of_visit.append(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append(neighbor) return order_of_visit"},{"question":"import re def sum_of_numbers_in_string(s: str) -> int: Takes a string as input and returns the sum of numbers within the string. The input string contains both letters and digits, where the numbers can be either single-digit or multi-digit. Parameters: s (str): Input string containing both letters and digits. Returns: int: Sum of all numbers found in the string. >>> sum_of_numbers_in_string(\\"abc123xy7ab89\\") # 123 + 7 + 89 219 >>> sum_of_numbers_in_string(\\"a1b2c3d4\\") # 1 + 2 + 3 + 4 10 >>> sum_of_numbers_in_string(\\"abcdxyz\\") # no numbers 0 >>> sum_of_numbers_in_string(\\"1234567890\\") # whole number 1234567890 >>> sum_of_numbers_in_string(\\"a123x7b89y\\") # 123 + 7 + 89 219 >>> sum_of_numbers_in_string(\\"\\") # empty string 0","solution":"import re def sum_of_numbers_in_string(s): Returns the sum of numbers within the input string. Parameters: s (str): Input string containing both letters and digits. Returns: int: Sum of all numbers found in the string. numbers = re.findall(r'd+', s) return sum(int(num) for num in numbers)"},{"question":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Returns a dictionary where the keys are unique words (case-insensitive) and the values are their frequencies of occurrence in the text. Punctuation marks are ignored. >>> word_frequency(\\"The quick brown fox jumps over the lazy dog\\") {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> word_frequency(\\"Hello, world! Hello...\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"Apple apple apple\\") {'apple': 3} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"!!!,,,...\\") {} >>> word_frequency(\\"Python 3.8 is great; Python is versatile.\\") {'python': 2, '3': 1, '8': 1, 'is': 2, 'great': 1, 'versatile': 1}","solution":"import re from collections import defaultdict def word_frequency(text): Returns a dictionary where the keys are unique words (case-insensitive) and the values are their frequencies of occurrence in the text. Punctuation marks are ignored. text = text.lower() # Convert text to lowercase to ignore case differences words = re.findall(r'bw+b', text) # Extract words using regex ignoring punctuation freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"def remove_duplicates(lst): Removes duplicates from a list while preserving order of elements. :param lst: List of elements with possible duplicates. :return: List of elements without duplicates, maintaining original order. pass def test_remove_duplicates_basic(): assert remove_duplicates([1, 3, 2, 1, 4, 3, 5, 6, 1]) == [1, 3, 2, 4, 5, 6] def test_remove_duplicates_empty(): assert remove_duplicates([]) == [] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_strings(): assert remove_duplicates(['a', 'b', 'a', 'c', 'b']) == ['a', 'b', 'c'] def test_remove_duplicates_mixed_types(): assert remove_duplicates([1, 'a', 1, 'b', 'a']) == [1, 'a', 'b']","solution":"def remove_duplicates(lst): Removes duplicates from a list while preserving order of elements. :param lst: List of elements with possible duplicates. :return: List of elements without duplicates, maintaining original order. result = [] seen = {} for item in lst: if item not in seen: result.append(item) seen[item] = True return result"},{"question":"def word_length_count(words: List[str]) -> dict: Returns a dictionary with word lengths as keys and the number of words of those lengths as values. The function is case-insensitive. >>> word_length_count([\\"apple\\", \\"Banana\\", \\"cat\\", \\"DOG\\", \\"Elephant\\"]) {5: 1, 6: 1, 3: 2, 8: 1} >>> word_length_count([\\"APPLE\\", \\"BANANA\\", \\"CAT\\", \\"DOG\\", \\"ELEPHANT\\"]) {5: 1, 6: 1, 3: 2, 8: 1} >>> word_length_count([\\"apple\\", \\"banana\\", \\"cat\\", \\"dog\\", \\"elephant\\"]) {5: 1, 6: 1, 3: 2, 8: 1} >>> word_length_count([]) {} >>> word_length_count([\\"apple\\"]) {5: 1} >>> word_length_count([\\"a\\", \\"b\\", \\"c\\"]) {1: 3}","solution":"def word_length_count(words): Returns a dictionary with word lengths as keys and the number of words of those lengths as values. The function is case-insensitive. word_length_dict = {} for word in words: word_length = len(word) if word_length in word_length_dict: word_length_dict[word_length] += 1 else: word_length_dict[word_length] = 1 return word_length_dict"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"def find_max_sum_subarray(arr, k): Returns the maximum sum of any subarray of length k in a circular linked list representation. Examples: >>> find_max_sum_subarray([1, 2, 3, 4, 5], 3) 12 >>> find_max_sum_subarray([8, -1, 3, 4], 2) 12 >>> find_max_sum_subarray([8, -1, 3, 4], 3) 15 >>> find_max_sum_subarray([-1, -2, -3, -4], 2) -3 >>> find_max_sum_subarray([5], 1) 5 >>> find_max_sum_subarray([], 3) 0 >>> find_max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> find_max_sum_subarray([1, 2, 3, 4, 5], 0) 0 >>> find_max_sum_subarray([1, 2, 3, 4, 5], 6) 0","solution":"def find_max_sum_subarray(arr, k): Returns the maximum sum of any subarray of length k in a circular linked list representation. n = len(arr) if n == 0 or k <= 0 or k > n: return 0 # Compute the sum of the first subarray of length k current_sum = sum(arr[:k]) max_sum = current_sum # Use sliding window technique to find the max sum in circular manner for i in range(1, n): current_sum = current_sum - arr[i-1] + arr[(i + k - 1) % n] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_words(words: List[str]) -> List[str]: Given a list of words, return the words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. >>> find_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> find_words([\\"HELLO\\", \\"aLaSka\\", \\"dAD\\", \\"PEACE\\"]) [\\"aLaSka\\", \\"dAD\\"] >>> find_words([\\"q\\", \\"as\\", \\"zxcv\\"]) [\\"q\\", \\"as\\", \\"zxcv\\"] >>> find_words([\\"aPpLe\\", \\"PeAr\\", \\"Banana\\"]) [] >>> find_words([]) [] >>> find_words([\\"top\\", \\"ASK\\", \\"pop\\", \\"Keys\\"]) [\\"top\\", \\"ASK\\", \\"pop\\"]","solution":"def find_words(words): Given a list of words, return the words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. rows = [ set(\\"qwertyuiop\\"), set(\\"asdfghjkl\\"), set(\\"zxcvbnm\\") ] def can_be_typed_on_one_row(word): lowercase_word = word.lower() for row in rows: if set(lowercase_word).issubset(row): return True return False return [word for word in words if can_be_typed_on_one_row(word)]"},{"question":"class ShoppingCart: A simple e-commerce cart system that allows adding, removing, viewing items, and calculating the total cost of the cart. Each item in the cart is represented as a dictionary with keys: 'name' (string), 'price' (float), and 'quantity' (int). The cart is initialized as an empty list of items. Methods: - add_item(name, price, quantity): Adds an item to the cart. If the item already exists in the cart, it updates the quantity and price. - remove_item(name): Removes an item from the cart by its name. - view_cart(): Returns the list of items currently in the cart. - total_cost(): Returns the total cost of all items in the cart. Example usage: >>> cart = ShoppingCart() >>> cart.add_item(\\"apple\\", 0.5, 10) >>> cart.add_item(\\"banana\\", 0.3, 5) >>> cart.view_cart() [{'name': 'apple', 'price': 0.5, 'quantity': 10}, {'name': 'banana', 'price': 0.3, 'quantity': 5}] >>> cart.total_cost() 6.5 >>> cart.remove_item(\\"apple\\") >>> cart.view_cart() [{'name': 'banana', 'price': 0.3, 'quantity': 5}] >>> cart.total_cost() 1.5 def __init__(self): pass def add_item(self, name, price, quantity): pass def remove_item(self, name): pass def view_cart(self): pass def total_cost(self): pass","solution":"class ShoppingCart: def __init__(self): self.cart = [] def add_item(self, name, price, quantity): # Check if the item already exists in the cart for item in self.cart: if item['name'] == name: item['price'] = price item['quantity'] += quantity return # If not, add new item self.cart.append({'name': name, 'price': price, 'quantity': quantity}) def remove_item(self, name): # Remove the item from the cart if it exists self.cart = [item for item in self.cart if item['name'] != name] def view_cart(self): return self.cart def total_cost(self): # Calculate the total cost by summing the cost of each item return sum(item['price'] * item['quantity'] for item in self.cart)"},{"question":"def valid_palindrome(s: str) -> bool: Determine if a string can be a palindrome by removing at most one character. >>> valid_palindrome(\\"abca\\") == True >>> valid_palindrome(\\"racecar\\") == True >>> valid_palindrome(\\"deed\\") == True >>> valid_palindrome(\\"abcd\\") == False >>> valid_palindrome(\\"a\\") == True >>> valid_palindrome(\\"aa\\") == True >>> valid_palindrome(\\"ab\\") == True >>> valid_palindrome(\\"\\") == True >>> valid_palindrome(\\"a\\" * (10**5 - 1) + \\"b\\") == True >>> valid_palindrome(\\"a\\" * (10**5 - 1) + \\"bc\\") == False","solution":"def valid_palindrome(s: str) -> bool: Determine if a string can be a palindrome by removing at most one character. def is_palindrome_range(i, j): Helper function to check if s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (i+j)//2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_cestor(root: TreeNode, p: int, q: int) -> TreeNode: Function to find the lowest common ancestor (LCA) of two given nodes in a BST. Assumes that both nodes are present in the BST and that their values are unique. :param root: TreeNode, the root of the BST. :param p: int, value of the first node. :param q: int, value of the second node. :return: TreeNode, the LCA of the two nodes. >>> root = TreeNode(6) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(4) >>> root.left.right.left = TreeNode(3) >>> root.left.right.right = TreeNode(5) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> lowest_common_cestor(root, 2, 8).val 6 >>> lowest_common_cestor(root, 2, 4).val 2 >>> lowest_common_cestor(root, 5, 4).val 4 >>> lowest_common_cestor(root, 0, 5).val 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_cestor(root, p, q): Function to find the lowest common ancestor (LCA) of two given nodes in a BST. Assumes that both nodes are present in the BST and that their values are unique. :param root: TreeNode, the root of the BST. :param p: int, value of the first node. :param q: int, value of the second node. :return: TreeNode, the LCA of the two nodes. current = root while current: # if both p and q are smaller than current node, LCA is in the left subtree if p < current.val and q < current.val: current = current.left # if both p and q are greater than current node, LCA is in the right subtree elif p > current.val and q > current.val: current = current.right else: # we found the split point, i.e., the LCA node return current return None"},{"question":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to the given integer using the Sieve of Eratosthenes algorithm. Args: n (int): The upper limit to check for prime numbers. Returns: List[int]: A list of prime numbers less than or equal to n. Examples: >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] # Initialize a boolean array with True values prime = [True] * (n + 1) prime[0], prime[1] = False, False # 0 and 1 are not prime numbers for p in range(2, int(n**0.5) + 1): if prime[p]: for multiple in range(p * p, n + 1, p): prime[multiple] = False # Collecting all prime numbers primes = [num for num, is_prime in enumerate(prime) if is_prime] return primes"},{"question":"def reverse_string(s: str) -> str: Returns the string with its characters in reverse order. >>> reverse_string(\\"abcdef\\") 'fedcba' >>> reverse_string(\\"\\") '' >>> reverse_string(\\"a\\") 'a' >>> reverse_string(\\"racecar\\") 'racecar' >>> reverse_string(\\"hello world\\") 'dlrow olleh' >>> reverse_string(\\"a!@ 3\\") '3 @!a'","solution":"def reverse_string(s): Returns the string with its characters in reverse order. return s[::-1]"},{"question":"import math from typing import Tuple def ellipse_area_and_circumference(a: float, b: float) -> Tuple[float, float]: Calculate the area and circumference of an ellipse. Parameters: a (float): semi-major axis b (float): semi-minor axis Returns: tuple: (area, circumference) >>> ellipse_area_and_circumference(1, 1) (math.pi, 2 * math.pi) >>> ellipse_area_and_circumference(10, 5) (50 * math.pi, math.pi * (3*(10 + 5) - math.sqrt((3*10 + 5)*(10 + 3*5)))) >>> ellipse_area_and_circumference(0.5, 0.25) (0.125 * math.pi, math.pi * (3*(0.5 + 0.25) - math.sqrt((3*0.5 + 0.25)*(0.5 + 3*0.25)))) >>> ellipse_area_and_circumference(3, 3) (9 * math.pi, 2 * math.pi * 3) >>> ellipse_area_and_circumference(0, 0) (0, 0) # Your code goes here","solution":"import math def ellipse_area_and_circumference(a, b): Calculate the area and circumference of an ellipse. Parameters: a (float): semi-major axis b (float): semi-minor axis Returns: tuple: (area, circumference) # Calculate area area = math.pi * a * b # Approximate circumference using the given formula circumference = math.pi * (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b))) return area, circumference"},{"question":"from typing import List import math class Shape: def area(self): Calculate the area of the shape. This method should be overridden by subclasses. raise NotImplementedError(\\"Subclasses should implement this!\\") class Circle(Shape): def __init__(self, radius: float): self._radius = radius def area(self): Calculate and return the area of the circle. pass class Rectangle(Shape): def __init__(self, width: float, height: float): self._width = width self._height = height def area(self): Calculate and return the area of the rectangle. pass class Triangle(Shape): def __init__(self, base: float, height: float): self._base = base self._height = height def area(self): Calculate and return the area of the triangle. pass class ShapeCollection: def __init__(self): self._shapes: List[Shape] = [] def add_shape(self, shape: Shape): Add a new shape to the collection. pass def total_area(self): Compute and return the total area of all the shapes in the collection. pass","solution":"from typing import List import math class Shape: def area(self): raise NotImplementedError(\\"Subclasses should implement this!\\") class Circle(Shape): def __init__(self, radius: float): self._radius = radius def area(self): return math.pi * (self._radius ** 2) class Rectangle(Shape): def __init__(self, width: float, height: float): self._width = width self._height = height def area(self): return self._width * self._height class Triangle(Shape): def __init__(self, base: float, height: float): self._base = base self._height = height def area(self): return 0.5 * self._base * self._height class ShapeCollection: def __init__(self): self._shapes: List[Shape] = [] def add_shape(self, shape: Shape): self._shapes.append(shape) def total_area(self): return sum(shape.area() for shape in self._shapes)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring spaces, punctuation, and case. pass def filter_palindromes(strings: List[str]) -> List[str]: Returns a list of strings that are palindromes. >>> filter_palindromes([\\"racecar\\", \\"hello\\", \\"madam\\"]) [\\"racecar\\", \\"madam\\"] >>> filter_palindromes([\\"A man, a plan, a canal, Panama\\", \\"No lemon, no melon\\", \\"Was it a car or a cat I saw?\\"]) [\\"A man, a plan, a canal, Panama\\", \\"No lemon, no melon\\", \\"Was it a car or a cat I saw?\\"] pass","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and case. # Using regex to remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned == cleaned[::-1] def filter_palindromes(strings): Returns a list of strings that are palindromes. return [s for s in strings if is_palindrome(s)]"},{"question":"def group_anagrams(strs: List[str]) -> List[List[str]]: Groups the given list of strings into anagram groups. Each group contains words that are anagrams of each other. Parameters: strs (list of str): The list of words to be grouped. Returns: list of list of str: List of groups, each containing anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\",\\"tea\\",\\"ate\\"], [\\"tan\\",\\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"a\\", \\"b\\", \\"a\\"]) [[\\"a\\", \\"a\\"], [\\"b\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"abcd\\", \\"dcba\\", \\"bacd\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"abcd\\", \\"dcba\\", \\"bacd\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups the given list of strings into anagram groups. Each group contains words that are anagrams of each other. Parameters: strs (list of str): The list of words to be grouped. Returns: list of list of str: List of groups, each containing anagrams. anagram_map = defaultdict(list) for s in strs: sorted_s = \\"\\".join(sorted(s)) anagram_map[sorted_s].append(s) return list(anagram_map.values())"},{"question":"def count_occurrences(lst): Returns a list of tuples, each containing an integer from the input list and its count of occurrences in the list. The output list is sorted by the integers in ascending order. :param lst: List of integers :return: List of tuples (integer, count) >>> count_occurrences([]) == [] >>> count_occurrences([5]) == [(5, 1)] >>> count_occurrences([1, 1, 1, 1]) == [(1, 4)] >>> count_occurrences([4, 2, 2, 8, 3, 3, 3, 1]) == [(1, 1), (2, 2), (3, 3), (4, 1), (8, 1)] >>> count_occurrences([1, 2, 2, 3, 3, 3, 4, 8]) == [(1, 1), (2, 2), (3, 3), (4, 1), (8, 1)] >>> count_occurrences([8, 4, 3, 3, 3, 2, 2, 1]) == [(1, 1), (2, 2), (3, 3), (4, 1), (8, 1)] >>> count_occurrences([3, 1, 2, 1, 2, 3, 1]) == [(1, 3), (2, 2), (3, 2)]","solution":"def count_occurrences(lst): Returns a list of tuples, each containing an integer from the input list and its count of occurrences in the list. The output list is sorted by the integers in ascending order. :param lst: List of integers :return: List of tuples (integer, count) from collections import Counter counts = Counter(lst) return sorted(counts.items())"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string (case insensitive). In case of tie, returns the character that appears first. Ignores non-alphabetic characters. >>> most_frequent_character(\\"Hello World!\\") 'l' >>> most_frequent_character(\\"aabbccddee\\") 'a' >>> most_frequent_character(\\"!@#%^&\\") '' # You can use the following unit tests to ensure your function works as expected. def test_most_frequent_character_case_insensitive(): assert most_frequent_character(\\"Hello World!\\") == 'l' def test_most_frequent_character_tie(): assert most_frequent_character(\\"aabbccddee\\") == 'a' def test_most_frequent_character_no_alphabetic(): assert most_frequent_character(\\"!@#%^&\\") == '' def test_most_frequent_character_mixed_case(): assert most_frequent_character(\\"AaBbCcDdEe\\") == 'a' def test_most_frequent_character_single_character(): assert most_frequent_character(\\"a\\") == 'a' assert most_frequent_character(\\"A\\") == 'a' def test_most_frequent_character_long_string(): assert most_frequent_character(\\"abcdefghijklmnopqrstuvwxyz\\" * 100) == 'a' def test_most_frequent_character_empty_string(): assert most_frequent_character(\\"\\") == ''","solution":"def most_frequent_character(s: str) -> str: from collections import Counter # Preprocess string: remove non-alphabetic characters and make it lower case filtered_s = [char.lower() for char in s if char.isalpha()] if not filtered_s: return '' # Create a Counter object to count the frequencies of each character character_count = Counter(filtered_s) # Find the maximum frequency and the corresponding character most_frequent = max(character_count, key=lambda char: (character_count[char], -filtered_s.index(char))) return most_frequent"},{"question":"def get_prime_numbers(numbers): Returns a list of prime numbers from the input list of integers. >>> get_prime_numbers([10, 11, 15, 18, 19, 21, 23]) [11, 19, 23] >>> get_prime_numbers([4, 6, 8, 10, 12]) [] >>> get_prime_numbers([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> get_prime_numbers([]) [] >>> get_prime_numbers([-1, 0, 1, 2, 3, 4, 5]) [2, 3, 5]","solution":"def get_prime_numbers(numbers): Returns a list of prime numbers from the input list of integers. def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True return [num for num in numbers if is_prime(num)] # Example usage: numbers = [10, 11, 15, 18, 19, 21, 23] print(get_prime_numbers(numbers)) # Output: [11, 19, 23]"},{"question":"def remove_vowels(s: str) -> str: Accepts a string and returns a new string with all vowels removed. The function is case insensitive. >>> remove_vowels(\\"Hello\\") 'Hll' >>> remove_vowels(\\"HeLLo WoRLd\\") 'HLL WRLd' >>> remove_vowels(\\"bcdfg\\") 'bcdfg' >>> remove_vowels(\\"aeiouAEIOU\\") '' >>> remove_vowels(\\"123!@#bcdfg\\") '123!@#bcdfg' >>> remove_vowels(\\"\\") ''","solution":"def remove_vowels(s): Returns a new string with all vowels removed. It is case insensitive. vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def find_insertion_index(arr, value): Create a functionality that returns the index where 'value' can be inserted into 'arr' to maintain the sorted order. The array 'arr' will always be sorted in ascending order and will contain unique values. Examples: >>> find_insertion_index([1, 3, 5, 6], 5) 2 >>> find_insertion_index([1, 3, 5, 6], 2) 1 >>> find_insertion_index([1, 3, 5, 6], 7) 4 >>> find_insertion_index([1, 3, 5, 6], 0) 0","solution":"def find_insertion_index(arr, value): Returns the index where 'value' can be inserted into 'arr' to maintain the sorted order. The array 'arr' is sorted in ascending order and contains unique values. :param arr: List[int] - A sorted list of unique integers. :param value: int - The value to insert. :return: int - The index where 'value' should be inserted. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < value: left = mid + 1 else: right = mid return left"},{"question":"from typing import List, Optional, Tuple def pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Find a pair of indices of the elements in the list that add up to the target sum. Returns a tuple containing the pair of indices or None if no such pair exists. >>> pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> pair_with_sum([1, 2, 3, 4, 5], 10) None","solution":"def pair_with_sum(nums, target): Finds two numbers in nums that add up to the target sum and returns their indices as a tuple. If no such pair exists, returns None. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"from datetime import datetime def days_between_dates(date1: str, date2: str) -> int: Returns the absolute number of days between two dates given in 'YYYY-MM-DD' format. The function should handle leap years, different month lengths, and ensure the result is always non-negative regardless of the order of input dates. Additionally, include error handling to manage cases where the input does not match the required format or represents an invalid date. >>> days_between_dates(\\"2023-10-12\\", \\"2023-10-12\\") 0 >>> days_between_dates(\\"2023-10-11\\", \\"2023-10-12\\") 1 >>> days_between_dates(\\"2020-02-28\\", \\"2020-03-01\\") 2 >>> days_between_dates(\\"2022-01-01\\", \\"2023-01-01\\") 365 >>> days_between_dates(\\"2023-10-12\\", \\"2023-10-10\\") 2 import pytest def test_same_date(): assert days_between_dates(\\"2023-10-12\\", \\"2023-10-12\\") == 0 def test_one_day_difference(): assert days_between_dates(\\"2023-10-11\\", \\"2023-10-12\\") == 1 def test_leap_year(): assert days_between_dates(\\"2020-02-28\\", \\"2020-03-01\\") == 2 def test_different_years(): assert days_between_dates(\\"2022-01-01\\", \\"2023-01-01\\") == 365 def test_reverse_dates(): assert days_between_dates(\\"2023-10-12\\", \\"2023-10-10\\") == 2 def test_invalid_date_format(): with pytest.raises(ValueError): days_between_dates(\\"2023/10/12\\", \\"2023-10-12\\") def test_invalid_date_value(): with pytest.raises(ValueError): days_between_dates(\\"2023-02-30\\", \\"2023-10-12\\") def test_other_invalid_date(): with pytest.raises(ValueError): days_between_dates(\\"abcd-ef-gh\\", \\"ijkl-mn-op\\")","solution":"from datetime import datetime def days_between_dates(date1, date2): Returns the absolute number of days between two dates given in 'YYYY-MM-DD' format. try: date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) return abs((d2 - d1).days) except ValueError: raise ValueError(\\"Invalid date format or invalid date provided.\\")"},{"question":"def sieve_of_eratosthenes(n: int) -> list: Write a function that takes an integer \`n\` and returns a list of all prime numbers less than \`n\`. Ensure your function is optimized for performance, considering the computational cost of frequent prime checks. The time complexity of the Sieve of Eratosthenes algorithm is O(n log log n). Parameters: n (int): The number up to which primes are to be found (exclusive). Returns: list: A list of all primes less than n. Examples: >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. The time complexity of this algorithm is O(n log log n). Parameters: n (int): The number up to which primes are to be found (exclusive). Returns: list: A list of all primes less than n. if n <= 2: return [] # Create a boolean array \\"prime[0..n-1]\\" and initialize all entries as True. prime = [True] * n p = 2 while p * p < n: if prime[p]: # Update all multiples of p as False indicating non-prime for i in range(p * p, n, p): prime[i] = False p += 1 # Collect all prime numbers return [p for p in range(2, n) if prime[p]] # Example usage # print(sieve_of_eratosthenes(30)) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"},{"question":"def merge_and_sort(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers and returns the merged list sorted in ascending order. >>> merge_and_sort([3, 1, 4], [2, 6, 5]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort([], []) [] >>> merge_and_sort([3, 1, 4], []) [1, 3, 4] >>> merge_and_sort([], [2, 6, 5]) [2, 5, 6] >>> merge_and_sort([1], [2]) [1, 2] >>> merge_and_sort([2], [1]) [1, 2] >>> merge_and_sort([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_and_sort([1000, 5000, 10000], [2000, 7000, 6000]) [1000, 2000, 5000, 6000, 7000, 10000] >>> merge_and_sort([3, 3, 3], [2, 3, 5]) [2, 3, 3, 3, 3, 5]","solution":"def merge_and_sort(list1, list2): Merges two lists and sorts them using merge sort algorithm. Returns the sorted merged list. merged_list = list1 + list2 return merge_sort(merged_list) def merge_sort(lst): if len(lst) <= 1: return lst mid = len(lst) // 2 left_half = merge_sort(lst[:mid]) right_half = merge_sort(lst[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_list = [] left_index = right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"import typing from typing import List def product_except_self(nums: List[int]) -> List[int]: Function that takes a list of integers and returns a new list where each integer is replaced by the product of all other integers in the original list except the integer at that position. Ensure that your function operates with a time complexity of O(n). Args: nums: List of integers Returns: A list of integers Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([1, 0, 3, 0]) [0, 0, 0, 0]","solution":"def product_except_self(nums): Returns a list where each element is the product of all elements in nums except itself. Args: nums: List of integers Returns: A list of integers n = len(nums) if n == 0: return [] # Generate prefix products prefix_products = [1] * n for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Generate suffix products and output using prefix products suffix_product = 1 for i in range(n - 1, -1, -1): prefix_products[i] *= suffix_product suffix_product *= nums[i] return prefix_products"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> (int, str): Returns the length of the longest common subsequence (LCS) and the actual LCS between two strings. >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") (4, \\"GTAB\\") >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") (0, \\"\\") >>> longest_common_subsequence(\\"A\\", \\"A\\") (1, \\"A\\") >>> longest_common_subsequence(\\"ABC\\", \\"AB\\") (2, \\"AB\\") >>> longest_common_subsequence(\\"AAB\\", \\"ABA\\") (2, any_valid_LCS) # Replace 'any_valid_LCS' with any one of \\"AA\\", \\"AB\\", \\"BA\\"","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence (LCS) and the actual LCS between two strings. m, n = len(str1), len(str2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table in bottom-up fashion. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # The length of LCS is dp[m][n] lcs_length = dp[m][n] # To reconstruct the LCS index = lcs_length lcs = [''] * (index+1) lcs[index] = \\"\\" i, j = m, n while i > 0 and j > 0: if str1[i-1] == str2[j-1]: lcs[index-1] = str1[i-1] i -= 1 j -= 1 index -= 1 elif dp[i-1][j] > dp[i][j-1]: i -= 1 else: j -= 1 return lcs_length, ''.join(lcs[:lcs_length]) # Example usage: length, subsequence = longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") print(length) # Expected 4 print(subsequence) # Expected \\"GTAB\\""},{"question":"def find_second_smallest(nums): Given an unordered list of positive integers, find and return the second smallest number in the list. If there is no second smallest number, return None. >>> find_second_smallest([4, 1, 7, 3, 2, 9]) 2 >>> find_second_smallest([6, 4, 2, 8, 4, 6, 2]) 4 >>> find_second_smallest([5, 5, 5, 5]) None >>> find_second_smallest([7]) None >>> find_second_smallest([]) None >>> find_second_smallest(list(range(1001))) 1","solution":"def find_second_smallest(nums): if not nums or len(nums) < 2: return None first_min = float('inf') second_min = float('inf') for num in nums: if num < first_min: second_min = first_min first_min = num elif first_min < num < second_min: second_min = num if second_min == float('inf'): return None return second_min"},{"question":"def group_consecutive(nums: List[int]) -> List[List[int]]: Groups a list of integers into sublists where each sublist contains only consecutive numbers. Duplicates are allowed, and the order of appearance is maintained. Args: nums (list): A list of integers. Returns: list: A list of sublists containing consecutive integers. >>> group_consecutive([1, 2, 2, 3, 7, 8, 9, 11, 13, 14, 15]) [[1, 2, 2, 3], [7, 8, 9], [11], [13, 14, 15]] >>> group_consecutive([1, 1, 2, 2, 2, 3, 4, 5, 6, 6]) [[1, 1, 2, 2, 2, 3, 4, 5, 6, 6]] >>> group_consecutive([4]) [[4]] >>> group_consecutive([]) [] >>> group_consecutive([10, 20, 30]) [[10], [20], [30]] >>> group_consecutive([1, 2, 3, 4, 5]) [[1, 2, 3, 4, 5]] >>> group_consecutive([5, 5, 6, 7, 10, 11, 12]) [[5, 5, 6, 7], [10, 11, 12]]","solution":"def group_consecutive(nums): Groups a list of integers into sublists where each sublist contains only consecutive numbers. Duplicates are allowed, and the order of appearance is maintained. Args: nums (list): A list of integers. Returns: list: A list of sublists containing consecutive integers. if not nums: return [] result = [] current_group = [nums[0]] for i in range(1, len(nums)): if nums[i] == nums[i-1] + 1 or nums[i] == nums[i-1]: current_group.append(nums[i]) else: result.append(current_group) current_group = [nums[i]] result.append(current_group) return result"},{"question":"def infix_to_postfix(expression: str) -> str: Converts an infix mathematical expression to postfix notation. >>> infix_to_postfix(\\"3+4\\") \\"34+\\" >>> infix_to_postfix(\\"2*(5+1)\\") \\"251+*\\" >>> infix_to_postfix(\\"(1+2)*(3+4)\\") \\"12+34+*\\" pass def evaluate_postfix(postfix_expr: str) -> int: Evaluates a postfix mathematical expression. >>> evaluate_postfix(\\"34+\\") 7 >>> evaluate_postfix(\\"251+*\\") 12 >>> evaluate_postfix(\\"12+34+*\\") 21 pass def process_expressions(expressions: List[str]) -> Dict[str, Union[int, str]]: Converts infix expressions to postfix and evaluates them. >>> process_expressions([\\"3+4\\", \\"2*(5+1)\\", \\"(1+2)*(3+4)\\"]) { \\"3+4\\": 7, \\"2*(5+1)\\": 12, \\"(1+2)*(3+4)\\": 21 } >>> process_expressions([\\"3/0\\", \\"(1+2)*(4/(2-2))\\"]) { \\"3/0\\": \\"Error: Division by zero\\", \\"(1+2)*(4/(2-2))\\": \\"Error: Division by zero\\" } >>> process_expressions([\\"1+2/+3\\"]) { \\"1+2/+3\\": \\"Error: pop from empty list\\" } >>> process_expressions([\\"((1+2)\\"]) { \\"((1+2)\\": \\"Error: pop from empty list\\" } >>> process_expressions([\\"1+*2\\"]) { \\"1+*2\\": \\"Error: pop from empty list\\" } pass","solution":"def infix_to_postfix(expression): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} stack = [] postfix = [] for char in expression: if char.isdigit(): postfix.append(char) elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': postfix.append(stack.pop()) stack.pop() else: while stack and stack[-1] != '(' and precedence[stack[-1]] >= precedence[char]: postfix.append(stack.pop()) stack.append(char) while stack: postfix.append(stack.pop()) return ''.join(postfix) def evaluate_postfix(postfix_expr): stack = [] for char in postfix_expr: if char.isdigit(): stack.append(int(char)) else: b = stack.pop() a = stack.pop() if char == '+': stack.append(a + b) elif char == '-': stack.append(a - b) elif char == '*': stack.append(a * b) elif char == '/': if b == 0: return \\"Error: Division by zero\\" stack.append(a / b) return stack.pop() def process_expressions(expressions): results = {} for expr in expressions: try: postfix_expr = infix_to_postfix(expr) result = evaluate_postfix(postfix_expr) results[expr] = result except Exception as e: results[expr] = f\\"Error: {str(e)}\\" return results"},{"question":"def evaluate_expression(expression: str) -> float: Create a function in Python called 'evaluate_expression' that takes in a string representing a mathematical expression (containing non-negative integers and the operators +, -, *, and / without spaces) and returns the result of the expression as a float. Ensure that the function correctly handles the order of operations (parentheses can be ignored for this problem). The function should raise a ValueError if the input string is not a valid mathematical expression. >>> evaluate_expression('2+3') 5.0 >>> evaluate_expression('10-4') 6.0 >>> evaluate_expression('6*4') 24.0 >>> evaluate_expression('20/4') 5.0 >>> evaluate_expression('2+3*4-5/1') 9.0 >>> evaluate_expression('5/2') 2.5 >>> evaluate_expression('5+4*10/2-1') 24.0 # Your code here","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, and / without spaces, and returns the result as a float. try: # Evaluate the expression using Python's eval function result = eval(expression) return float(result) except: # Raise a ValueError if the expression is invalid raise ValueError(\\"Invalid mathematical expression\\")"},{"question":"def rearrange_and_sort(arr: List[int]) -> List[int]: Devise a function that takes an unsorted list of unique integers and returns a new list with the integers sorted in ascending order, but rearranges every second element to its negative value. >>> rearrange_and_sort([3]) [3] >>> rearrange_and_sort([2, 8]) [2, -8] >>> rearrange_and_sort([3, 1, 4, 2]) [1, -2, 3, -4] >>> rearrange_and_sort([-1, -5, -3]) [-5, 3, -1] >>> rearrange_and_sort([5, -1, 3, 0]) [-1, 0, 3, -5]","solution":"def rearrange_and_sort(arr): This function takes an unsorted list of unique integers and returns a new list: elements are sorted in ascending order, but every second element is its negative value. sorted_arr = sorted(arr) for i in range(1, len(sorted_arr), 2): sorted_arr[i] = -sorted_arr[i] return sorted_arr"},{"question":"def longest_zero_sum_subarray(arr): Returns the length of the longest subarray with a sum of zero. >>> longest_zero_sum_subarray([1, -1, 3, 2, -2, -3, 4]) 6 >>> longest_zero_sum_subarray([]) 0 >>> longest_zero_sum_subarray([1, 2, 3]) 0 >>> longest_zero_sum_subarray([1, -1, 2, -2]) 4 >>> longest_zero_sum_subarray([1, -1, 1, -1, 1, -1]) 6 >>> longest_zero_sum_subarray([0]) 1 >>> longest_zero_sum_subarray([0, 0, 0, 0]) 4","solution":"def longest_zero_sum_subarray(arr): Returns the length of the longest subarray with a sum of zero. sum_to_index = {} max_length = 0 current_sum = 0 for i, num in enumerate(arr): current_sum += num if current_sum == 0: max_length = i + 1 if current_sum in sum_to_index: max_length = max(max_length, i - sum_to_index[current_sum]) else: sum_to_index[current_sum] = i return max_length"},{"question":"def validate_stack_operations(operations: List[str]) -> bool: Validates a sequence of stack operations. Parameters: operations (list): A list of strings where \\"PUSH\\" adds an element to the stack and \\"POP\\" removes an element from the stack. Returns: bool: True if the sequence of operations is valid, False otherwise. >>> validate_stack_operations([\\"PUSH\\", \\"PUSH\\", \\"POP\\", \\"PUSH\\", \\"POP\\"]) True >>> validate_stack_operations([\\"POP\\"]) False >>> validate_stack_operations([\\"PUSH\\", \\"POP\\", \\"PUSH\\", \\"PUSH\\", \\"POP\\", \\"POP\\", \\"PUSH\\"]) True >>> validate_stack_operations([]) True >>> validate_stack_operations([\\"PUSH\\", \\"PUSH\\", \\"POP\\", \\"POP\\", \\"POP\\"]) False","solution":"def validate_stack_operations(operations): Validates a sequence of stack operations. Parameters: operations (list): A list of strings where \\"PUSH\\" adds an element to the stack and \\"POP\\" removes an element from the stack. Returns: bool: True if the sequence of operations is valid, False otherwise. stack_size = 0 for operation in operations: if operation == \\"PUSH\\": stack_size += 1 elif operation == \\"POP\\": if stack_size == 0: return False stack_size -= 1 return True"},{"question":"def find_pairs_with_sum(arr: List[int], target_sum: int) -> Set[Tuple[int, int]]: Finds all unique pairs of elements in the array whose sum equals the target sum. Each pair is returned as a tuple and added to a set. >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 1, 9], 10) == {(1, 9), (3, 7), (2, 8)} >>> find_pairs_with_sum([1, 2, 3, 4, 5], 6) == {(1, 5), (2, 4)} >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) == set() >>> find_pairs_with_sum([2, 2, 2, 2], 4) == {(2, 2)} >>> find_pairs_with_sum([], 10) == set()","solution":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs of elements in the array whose sum equals the target sum. Each pair is returned as a tuple and added to a set. seen = set() output = set() for num in arr: complement = target_sum - num if complement in seen: pair = tuple(sorted((num, complement))) output.add(pair) seen.add(num) return output"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Given an array of unique integers, return the lexicographically next permutation of the numbers. If such arrangement is not possible, return the array sorted in ascending order. Example 1: >>> next_permutation([1,2,3]) [1, 3, 2] Example 2: >>> next_permutation([3,2,1]) [1, 2, 3] Example 3: >>> next_permutation([1, 1, 5]) [1, 5, 1] Example 4: >>> next_permutation([1,3,2]) [2, 1, 3] Example 5: >>> next_permutation([5, 3, 4, 2, 1]) [5, 4, 1, 2, 3] Constraints: \`1 <= nums.length <= 100\` \`0 <= nums[i] <= 100\`","solution":"def next_permutation(nums): Modifies nums in-place to the lexicographically next permutation and returns it. If such arrangement is not possible, returns the array sorted in ascending order. n = len(nums) # Step 1: Find the longest non-increasing suffix i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # Step 2: If the array is entirely non-increasing, return the sorted array if i == -1: nums.sort() return nums # Step 3: Find the rightmost element that exceeds nums[i] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 4: Swap elements at i and j nums[i], nums[j] = nums[j], nums[i] # Step 5: Reverse the suffix nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def first_non_repeating_character(s: str) -> str: Given a string, finds the first non-repeating character. If all characters repeat, return an empty string. Ignore spaces and consider uppercase and lowercase characters as distinct. >>> first_non_repeating_character(\\"Swiss cheese\\") 'S' >>> first_non_repeating_character(\\"abracadabra\\") 'c' >>> first_non_repeating_character(\\"aA\\") 'a' >>> first_non_repeating_character(\\"aabbcc\\") '' >>> first_non_repeating_character(\\"a bb c\\") 'a' def test_non_repeating_character(): assert first_non_repeating_character(\\"Swiss cheese\\") == 'S' assert first_non_repeating_character(\\"abracadabra\\") == 'c' assert first_non_repeating_character(\\"aA\\") == 'a' assert first_non_repeating_character(\\"aabbcc\\") == '' assert first_non_repeating_character(\\"a bb c\\") == 'a' def test_non_repeating_character_with_spaces(): assert first_non_repeating_character(\\" a b a B \\") == 'b' assert first_non_repeating_character(\\" test te \\") == 's' assert first_non_repeating_character(\\" space space \\") == '' def test_non_repeating_character_empty_string(): assert first_non_repeating_character(\\"\\") == '' def test_non_repeating_character_single_char(): assert first_non_repeating_character(\\"x\\") == 'x' assert first_non_repeating_character(\\"Y\\") == 'Y'","solution":"def first_non_repeating_character(s: str) -> str: Given a string, finds the first non-repeating character. If all characters repeat, return an empty string. Ignore spaces and consider uppercase and lowercase characters as distinct. from collections import Counter # Remove spaces and count character frequencies s_no_spaces = s.replace(\\" \\", \\"\\") char_count = Counter(s_no_spaces) # Find the first non-repeating character for char in s_no_spaces: if char_count[char] == 1: return char return \\"\\""},{"question":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(15) 1307674368000 >>> factorial(20) 2432902008176640000 >>> factorial(30) 265252859812191058636308480000000","solution":"def factorial(n): Returns the factorial of a non-negative integer n. Uses an iterative approach to prevent recursion depth error. result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def greatest_difference(nums: List[int]) -> int: Returns the greatest difference between any two elements in the list. >>> greatest_difference([3, 10, 5, 25]) == 22 >>> greatest_difference([-10, -5, -2, -25]) == 23 >>> greatest_difference([-10, 0, 5, 25]) == 35 >>> greatest_difference([5]) == 0 >>> greatest_difference([]) == 0 >>> greatest_difference([5, 5, 5, 5]) == 0","solution":"def greatest_difference(nums): Returns the greatest difference between any two elements in the list. if not nums or len(nums) < 2: return 0 min_num = min(nums) max_num = max(nums) return max_num - min_num"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Given an array of integers representing the heights of a histogram's bars, returns the area of the largest rectangle in the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([6, 5, 4, 3, 2, 1]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5, 6]) 12 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([0, 0, 0, 0]) 0 >>> largestRectangleArea([i for i in range(10000)]) 25000000 from typing import List def largestRectangleArea(heights: List[int]) -> int:","solution":"def largestRectangleArea(heights): Given an array of integers representing the heights of a histogram's bars, returns the area of the largest rectangle in the histogram. max_area = 0 stack = [] index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def find_unique_triplets(arr: List[int], target_sum: int) -> List[List[int]]: Write a function find_unique_triplets(arr, target_sum) that finds all unique triplets in a list of integers arr that add up to a given target_sum. A triplet (a, b, c) is considered unique if no two triplets contain the same set of three numbers, regardless of their order. The function should return a list of these unique triplets. >>> find_unique_triplets([12, 3, 6, 1, 6, 9], 24) [[3, 9, 12], [6, 6, 12]] >>> find_unique_triplets([1, 2, 3, 4, 5], 50) [] >>> find_unique_triplets([1, 2, 3, 4, 5], 6) [[1, 2, 3]] >>> find_unique_triplets([1, 0, -1, 2, -2, 3], 0) [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] >>> find_unique_triplets([1, 2, 2, 3, 3, 4], 9) [[2, 3, 4]] >>> find_unique_triplets([-1000000, -999999, 1999999, 0, 1], 0) [[-1000000, -999999, 1999999]] >>> find_unique_triplets([1, 2], 3) []","solution":"from typing import List def find_unique_triplets(arr: List[int], target_sum: int) -> List[List[int]]: arr.sort() triplets = set() # Using a set to automatically handle duplicates for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif current_sum < target_sum: left += 1 else: right -= 1 return [list(triplet) for triplet in triplets]"},{"question":"def caesar_cipher(message: str, shift: int) -> str: Encrypts the message by shifting each letter by the provided shift value using the Caesar cipher. Non-letter characters remain unaffected. >>> caesar_cipher(\\"\\", 5) == \\"\\" >>> caesar_cipher(\\"abc\\", 1) == \\"bcd\\" >>> caesar_cipher(\\"ABC\\", 1) == \\"BCD\\" >>> caesar_cipher(\\"xyz\\", 3) == \\"abc\\" >>> caesar_cipher(\\"bcd\\", -1) == \\"abc\\" >>> caesar_cipher(\\"BCD\\", -1) == \\"ABC\\" >>> caesar_cipher(\\"abc\\", -3) == \\"xyz\\" >>> caesar_cipher(\\"AbC\\", 2) == \\"CdE\\" >>> caesar_cipher(\\"abc! 123\\", 1) == \\"bcd! 123\\" >>> caesar_cipher(\\"XYZ! 789\\", 3) == \\"ABC! 789\\" >>> caesar_cipher(\\"Hello, World!\\", 5) == \\"Mjqqt, Btwqi!\\" >>> caesar_cipher(\\"abc\\", 27) == \\"bcd\\" >>> caesar_cipher(\\"ABC\\", 52) == \\"ABC\\" >>> caesar_cipher(\\"xyz\\", 53) == \\"yza\\" >>> caesar_cipher(\\"cde\\", -27) == \\"bcd\\" >>> caesar_cipher(\\"BCD\\", -52) == \\"BCD\\" >>> caesar_cipher(\\"yza\\", -53) == \\"xyz\\" Args: message (str): the input message to be encoded. shift (int): the shift value for the Caesar cipher. Returns: str: the encoded message.","solution":"def caesar_cipher(message, shift): Encrypts the message by shifting each letter by the provided shift value using the Caesar cipher. Non-letter characters remain unaffected. Args: message (str): the input message to be encoded. shift (int): the shift value for the Caesar cipher. Returns: str: the encoded message. encrypted_message = [] for char in message: if char.isalpha(): shift_base = ord('A') if char.isupper() else ord('a') encrypted_char = chr((ord(char) - shift_base + shift) % 26 + shift_base) encrypted_message.append(encrypted_char) else: encrypted_message.append(char) return ''.join(encrypted_message)"},{"question":"def longest_distinct_subarray(arr: List[int]) -> int: Returns the length of the longest subarray containing only distinct elements. >>> longest_distinct_subarray([1, 2, 3, 4, 5]) 5 >>> longest_distinct_subarray([1, 1, 1, 1]) 1 >>> longest_distinct_subarray([1, 2, 1, 3, 4, 2, 3]) 4 >>> longest_distinct_subarray([1, 1, 2, 2, 3, 3, 4, 4]) 2 >>> longest_distinct_subarray([]) 0 >>> longest_distinct_subarray([7]) 1 >>> longest_distinct_subarray([1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7]) 7 >>> longest_distinct_subarray([1, 2, 3, 1, 2, 3]) 3 >>> longest_distinct_subarray([1, 2, 3, 1, 2, 3, 4, 5]) 5","solution":"def longest_distinct_subarray(arr): Returns the length of the longest subarray containing only distinct elements. max_len = 0 start = 0 seen = {} for end, value in enumerate(arr): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def findClosestElements(nums: List[int], target: int, k: int) -> List[int]: Find the k closest integers to the target in a sorted list of integers. The result should be sorted in non-decreasing order. In case of a tie, the smaller elements are preferred. >>> findClosestElements([1, 2, 3, 4, 5], 3, 2) [2, 3] >>> findClosestElements([0, 1, 2, 3, 4, 5, 6], 5, 4) [3, 4, 5, 6] >>> findClosestElements([1, 2, 3, 4, 5], -1, 3) [1, 2, 3]","solution":"from typing import List def findClosestElements(nums: List[int], target: int, k: int) -> List[int]: # Binary search to find the insertion point left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 # Initializing two pointers for the closest k elements index = left left, right = index - 1, index # Find k closest elements result = [] while k > 0: if left < 0: result.append(nums[right]) right += 1 elif right >= len(nums): result.append(nums[left]) left -= 1 elif abs(nums[left] - target) <= abs(nums[right] - target): result.append(nums[left]) left -= 1 else: result.append(nums[right]) right += 1 k -= 1 # Return sorted result result.sort() return result"},{"question":"def count_strings(strings: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary where the keys are the unique strings from the list and the values are the number of times each string appears. :param strings: List of strings :return: Dictionary with string counts >>> count_strings(['a', 'b', 'c']) {'a': 1, 'b': 1, 'c': 1} >>> count_strings(['a', 'a', 'b', 'b', 'b', 'c', 'c']) {'a': 2, 'b': 3, 'c': 2} >>> count_strings([]) {} >>> count_strings(['a']) {'a': 1} >>> count_strings(['a', 'A', 'b', 'B', 'A', 'b']) {'a': 1, 'A': 2, 'b': 2, 'B': 1} >>> count_strings(['!', '@', '#', '!', '!']) {'!': 3, '@': 1, '#': 1}","solution":"def count_strings(strings): Takes a list of strings and returns a dictionary where the keys are the unique strings from the list and the values are the number of times each string appears. :param strings: List of strings :return: Dictionary with string counts string_counts = {} for s in strings: if s in string_counts: string_counts[s] += 1 else: string_counts[s] = 1 return string_counts"},{"question":"def sort_string_mix(s: str) -> str: Write a function in Python that takes a string containing a mixture of digits and lowercase letters and returns the string sorted in such a way that all digits come before the letters, while preserving their relative order. >>> sort_string_mix(\\"a1b2c3\\") \\"123abc\\" >>> sort_string_mix(\\"z3y2x1\\") \\"321zyx\\" >>> sort_string_mix(\\"a2b1c3d\\") \\"213abcd\\"","solution":"def sort_string_mix(s: str) -> str: # Separate digits and letters while maintaining their relative order digits = [char for char in s if char.isdigit()] letters = [char for char in s if char.isalpha()] # Concatenate digits followed by letters return ''.join(digits + letters)"},{"question":"def shift_characters(s: str) -> str: Takes a string as input and returns a new string where each character is replaced by the next character in the ASCII sequence. If a character is 'z' or 'Z', it wraps around to 'a' or 'A' respectively. >>> shift_characters(\\"abc\\") 'bcd' >>> shift_characters(\\"xyz\\") 'yza' >>> shift_characters(\\"XYZ\\") 'YZA' >>> shift_characters(\\"aBcXyZ\\") 'bCdYzA' >>> shift_characters(\\"123\\") '234' >>> shift_characters(\\"!@#\\") '\\"A' >>> shift_characters(\\"\\") ''","solution":"def shift_characters(s): Takes a string as input and returns a new string where each character is replaced by the next character in the ASCII sequence. If a character is 'z' or 'Z', it wraps around to 'a' or 'A' respectively. result = [] for char in s: if char == 'z': result.append('a') elif char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def second_largest(arr: List[int]) -> Optional[int]: Create a function that takes an integer array as input and returns the second largest element in the array. If the array has fewer than two unique elements, return None. >>> second_largest([3, 1, 4, 1, 5, 9]) == 5 >>> second_largest([1]) == None >>> second_largest([1, 1]) == None >>> second_largest([1, 2]) == 1 >>> second_largest([1, 2, 2, 2, 3]) == 2 >>> second_largest([-1, -2, -3, -4, -5]) == -2 >>> second_largest([10, -10, 20, 20, 15]) == 15 >>> second_largest([5, 5, 5]) == None >>> second_largest(list(range(1000))) == 998","solution":"def second_largest(arr): Returns the second largest unique element in the array. If the array has fewer than two unique elements, return None. if len(arr) < 2: return None unique_elements = list(set(arr)) if len(unique_elements) < 2: return None unique_elements.sort(reverse=True) return unique_elements[1]"},{"question":"def sum_of_odds(numbers: List[int]) -> int: Returns the sum of all odd numbers in the provided list. :param numbers: List of integers :return: Sum of the odd numbers >>> sum_of_odds([10, 3, 5, 12, 17, 6, 8]) 25 >>> sum_of_odds([1, 3, 5, 7]) 16 >>> sum_of_odds([2, 4, 6, 8]) 0 >>> sum_of_odds([]) 0 >>> sum_of_odds([-3, -2, -1, 2, 3, 4, 5]) 4 >>> sum_of_odds([7]) 7 >>> sum_of_odds([8]) 0 >>> sum_of_odds([100, 200, 300]) 0 >>> sum_of_odds(list(range(1, 101))) 2500","solution":"def sum_of_odds(numbers): Returns the sum of all odd numbers in the provided list. :param numbers: List of integers :return: Sum of the odd numbers total = 0 for number in numbers: if number % 2 != 0: total += number return total"},{"question":"def jaccard_similarity(set1, set2): Calculate the Jaccard similarity between two sets of strings. Parameters: set1: A set of strings. set2: A set of strings. Returns: A float representing the Jaccard similarity between the two sets. >>> jaccard_similarity({\\"apple\\", \\"banana\\", \\"cherry\\"}, {\\"banana\\", \\"cherry\\", \\"date\\"}) 0.5 >>> jaccard_similarity({\\"apple\\", \\"banana\\"}, {\\"cherry\\", \\"date\\"}) 0.0 >>> jaccard_similarity({\\"apple\\", \\"banana\\", \\"cherry\\"}, {\\"apple\\", \\"banana\\", \\"cherry\\"}) 1.0 >>> jaccard_similarity(set(), set()) 0.0 >>> jaccard_similarity({\\"apple\\", \\"banana\\"}, set()) 0.0 >>> jaccard_similarity({\\"apple\\", \\"banana\\", \\"kiwi\\"}, {\\"banana\\", \\"date\\", \\"kiwi\\"}) 0.5","solution":"def jaccard_similarity(set1, set2): Calculate the Jaccard similarity between two sets of strings. Parameters: set1: A set of strings. set2: A set of strings. Returns: A float representing the Jaccard similarity between the two sets. intersection = len(set1.intersection(set2)) union = len(set1.union(set2)) if union == 0: return 0.0 # Cannot divide by zero, so similarity is 0 if both sets are empty return intersection / union"},{"question":"from collections import defaultdict import numpy as np class MusicRecommender: def __init__(self): Initialize the Music Recommender with necessary data structures. self.user_listening_history = defaultdict(list) self.track_features = defaultdict(dict) self.user_feedback = defaultdict(dict) def add_listening_history(self, user_id, track_id): Add a track to the user's listening history. Args: user_id (int): The ID of the user. track_id (str): The ID of the track. self.user_listening_history[user_id].append(track_id) def add_track_features(self, track_id, features): Add features for a track. Args: track_id (str): The ID of the track. features (dict): The features of the track (e.g., genres). self.track_features[track_id] = features def add_user_feedback(self, user_id, track_id, rating): Add user feedback for a track. Args: user_id (int): The ID of the user. track_id (str): The ID of the track. rating (int): The rating given to the track by the user. self.user_feedback[user_id][track_id] = rating def recommend(self, user_id, top_n=10): Generate music recommendations for a user. Args: user_id (int): The ID of the user. top_n (int): The number of top recommendations to return. Returns: list: A list of recommended track IDs. user_history = self.user_listening_history[user_id] track_scores = defaultdict(float) # Collaborative filtering and content-based filtering would be implemented here sorted_tracks = sorted(track_scores.items(), key=lambda item: item[1], reverse=True) recommended_tracks = [track for track, score in sorted_tracks[:top_n]] return recommended_tracks","solution":"from collections import defaultdict import numpy as np class MusicRecommender: def __init__(self): self.user_listening_history = defaultdict(list) self.track_features = defaultdict(dict) self.user_feedback = defaultdict(dict) def add_listening_history(self, user_id, track_id): self.user_listening_history[user_id].append(track_id) def add_track_features(self, track_id, features): self.track_features[track_id] = features def add_user_feedback(self, user_id, track_id, rating): self.user_feedback[user_id][track_id] = rating def _get_genre_similarity(self, track_id1, track_id2): genres1 = self.track_features[track_id1].get('genres', []) genres2 = self.track_features[track_id2].get('genres', []) return len(set(genres1) & set(genres2)) / len(set(genres1) | set(genres2)) def _get_user_similarity(self, user_id1, user_id2): set1 = set(self.user_listening_history[user_id1]) set2 = set(self.user_listening_history[user_id2]) return len(set1 & set2) / len(set1 | set2) def recommend(self, user_id, top_n=10): user_history = self.user_listening_history[user_id] track_scores = defaultdict(float) for hist_track in user_history: for track, features in self.track_features.items(): if track not in user_history: genre_similarity = self._get_genre_similarity(hist_track, track) track_scores[track] += genre_similarity user_similarity_scores = defaultdict(float) for other_user in self.user_listening_history: if other_user != user_id: similarity = self._get_user_similarity(user_id, other_user) user_similarity_scores[other_user] = similarity for other_user, similarity in user_similarity_scores.items(): for track in self.user_listening_history[other_user]: if track not in user_history: track_scores[track] += similarity sorted_tracks = sorted(track_scores.items(), key=lambda item: item[1], reverse=True) recommended_tracks = [track for track, score in sorted_tracks[:top_n]] return recommended_tracks"},{"question":"def filter_strings_by_length(strings, n): Design a Python function that takes in a list of strings and an integer \`n\`. The function should return a list of strings that are exactly \`n\` characters long. If the list contains any non-string elements, raise a \`ValueError\` with a message \\"List contains non-string elements\\". Additionally, if there are no strings of length \`n\` in the input list, return an empty list. >>> filter_strings_by_length([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"fig\\"], 5) [\\"apple\\"] >>> filter_strings_by_length([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"fig\\"], 7) [] >>> filter_strings_by_length([\\"app@e\\", \\"ban@na\\", \\"ki!i\\", \\"f#g\\"], 5) [\\"app@e\\"] >>> filter_strings_by_length([\\" one \\", \\"two\\", \\" four \\"], 5) [\\" one \\"] >>> filter_strings_by_length([], 3) [] >>> filter_strings_by_length([\\"apple\\", 123, \\"kiwi\\"], 5) # Raises ValueError ValueError: List contains non-string elements","solution":"def filter_strings_by_length(strings, n): Returns a list of strings that have exactly n characters from the input list. Parameters: strings (list): List of strings to be filtered. n (int): The length of strings to filter by. Returns: list: List of strings that are exactly n characters long. Raises: ValueError: If the input list contains non-string elements. if not all(isinstance(s, str) for s in strings): raise ValueError(\\"List contains non-string elements\\") return [s for s in strings if len(s) == n]"},{"question":"def reverse_integer(x: int) -> int: Reverse digits of a 32-bit signed integer. Return 0 when the reversed integer overflows. Examples: >>> reverse_integer(123) 321 >>> reverse_integer(-123) -321 >>> reverse_integer(120) 21 >>> reverse_integer(1534236469) 0 # because the reversed integer overflows pass def test_reverse_integer(): assert reverse_integer(123) == 321 assert reverse_integer(-123) == -321 assert reverse_integer(120) == 21 assert reverse_integer(0) == 0 assert reverse_integer(1534236469) == 0 # This should cause overflow assert reverse_integer(-1534236469) == 0 # This should cause overflow def test_reverse_integer_single_digit(): assert reverse_integer(5) == 5 assert reverse_integer(-1) == -1 def test_reverse_integer_edge_cases(): assert reverse_integer(1463847412) == 2147483641 assert reverse_integer(-1463847412) == -2147483641 assert reverse_integer(2147483647) == 0 # This should cause overflow assert reverse_integer(-2147483648) == 0 # This should cause overflow","solution":"def reverse_integer(x): Reverse digits of a 32-bit signed integer. Return 0 when the reversed integer overflows. INT_MAX = 2**31 - 1 INT_MIN = -2**31 sign = -1 if x < 0 else 1 x *= sign reversed_int = 0 while x != 0: pop = x % 10 x //= 10 if reversed_int > (INT_MAX - pop) // 10: return 0 reversed_int = reversed_int * 10 + pop return sign * reversed_int"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given a list of integers, find all unique triplets in the list which gives the sum of zero. :param nums: List[int] :return: List[List[int]] >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, 0, 1], [-1, -1, 2]] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([-5, -4, -3, -2, -1]) [] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([3, -2, 1, 0, -1, 2, -1, -4, 4]) [[-4, 0, 4], [-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1]] >>> three_sum([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]]","solution":"def three_sum(nums): Given a list of integers, find all unique triplets in the list which gives the sum of zero. :param nums: List[int] :return: List[List[int]] nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: # Skip duplicate elements continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return triplets"},{"question":"def double_non_negatives(lst): Takes a list of integers and returns a new list that contains only the non-negative integers from the original list doubled, while maintaining their original order. >>> double_non_negatives([1, 2, -3, 4, -5]) == [2, 4, 8] >>> double_non_negatives([-1, -2, -3]) == [] >>> double_non_negatives([]) == [] >>> double_non_negatives([5, -10, 0]) == [10, 0] >>> double_non_negatives([-7, 7, -8, 8]) == [14, 16]","solution":"def double_non_negatives(lst): Takes a list of integers and returns a new list that contains only the non-negative integers from the original list doubled, while maintaining their original order. result = [] for num in lst: if num >= 0: result.append(num * 2) return result"},{"question":"def get_employee_salaries_with_dept_avg(): Returns a SQL query to fetch each employee's salary along with the average salary of the department they belong to using a window function. return # Placeholder for the required query","solution":"def get_employee_salaries_with_dept_avg(): Returns a SQL query to fetch each employee's salary along with the average salary of the department they belong to using a window function. return ''' SELECT emp_id, salary, AVG(salary) OVER (PARTITION BY dept_id) AS dept_avg_salary FROM employees; '''"},{"question":"def infix_to_postfix(expression: str) -> str: Converts an infix expression to postfix notation. Args: expression (str): A string containing a mathematical expression in infix notation. Returns: str: A string containing the expression in postfix notation. Examples: >>> infix_to_postfix(\\"3 + 5\\") \\"3 5 +\\" >>> infix_to_postfix(\\"3 + 5 * 2\\") \\"3 5 2 * +\\" >>> infix_to_postfix(\\"3 + 5 * 2 - 8 / 4\\") \\"3 5 2 * + 8 4 / -\\" >>> infix_to_postfix(\\"( 3 + 5 ) * 2\\") \\"3 5 + 2 *\\" >>> infix_to_postfix(\\"( 3 + ( 5 * 2 ) ) - 8\\") \\"3 5 2 * + 8 -\\" >>> infix_to_postfix(\\"4\\") \\"4\\"","solution":"def infix_to_postfix(expression): Converts an infix expression to postfix notation. Args: expression (str): A string containing a mathematical expression in infix notation. Returns: str: A string containing the expression in postfix notation. precedence = {'+':1, '-':1, '*':2, '/':2} def is_operator(c): return c in precedence def precedence_of(c): return precedence[c] def infix_to_postfix_conversion(expression): output = [] stack = [] for char in expression.split(): if char.isdigit(): output.append(char) elif is_operator(char): while (stack and stack[-1] != '(' and precedence_of(stack[-1]) >= precedence_of(char)): output.append(stack.pop()) stack.append(char) elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # pop '(' from stack while stack: output.append(stack.pop()) return ' '.join(output) return infix_to_postfix_conversion(expression)"},{"question":"def find_unique_elements(lst: List[int]) -> List[int]: Returns a new list containing only the elements that appear exactly once in the input list. >>> find_unique_elements([4, 5, 6, 7, 8, 4, 5, 9]) [6, 7, 8, 9] >>> find_unique_elements([1, 1, 2, 2, 3, 3]) [] >>> find_unique_elements([-1, -2, -1, 3, 4, 3]) [-2, 4] >>> find_unique_elements([10, -10, 20, -20, 30]) [10, -10, 20, -20, 30]","solution":"def find_unique_elements(lst): Returns a new list containing only the elements that are unique in the input list. from collections import Counter element_counts = Counter(lst) unique_elements = [x for x in lst if element_counts[x] == 1] return unique_elements"},{"question":"def invert_dictionary(d): Inverts a dictionary so that keys are values and values are lists of keys that had the same value. Parameters: d (dict): Input dictionary with hashable keys and values. Returns: dict: Inverted dictionary with values from the input dict as keys and the keys from the input as list values. >>> invert_dictionary({'a': 1, 'b': 2, 'c': 1, 'd': 3}) {1: ['a', 'c'], 2: ['b'], 3: ['d']} >>> invert_dictionary({'a': 'apple', 'b': 'banana', 'c': 'apple'}) {'apple': ['a', 'c'], 'banana': ['b']} >>> invert_dictionary({}) {}","solution":"def invert_dictionary(d): Inverts a dictionary so that keys are values and values are lists of keys that had the same value. Parameters: d (dict): Input dictionary with hashable keys and values. Returns: dict: Inverted dictionary with values from the input dict as keys and the keys from the input as list values. inverted = {} for key, value in d.items(): if value in inverted: inverted[value].append(key) else: inverted[value] = [key] return inverted"},{"question":"def sum_even_in_range(a: int, b: int) -> int: Returns the sum of all even numbers in the given range [a, b], inclusive. >>> sum_even_in_range(1, 10) 30 >>> sum_even_in_range(10, 1) 30 >>> sum_even_in_range(-10, 10) 0","solution":"def sum_even_in_range(a, b): Returns the sum of all even numbers in the given range [a, b], inclusive. # Make sure that a is less than or equal to b for proper range creation if a > b: a, b = b, a sum_evens = 0 for number in range(a, b + 1): if number % 2 == 0: sum_evens += number return sum_evens"},{"question":"def balanced_brackets(s: str) -> bool: Returns True if the input string s containing only the characters '(', ')', '{', '}', '[' and ']' is balanced. Otherwise, returns False. >>> balanced_brackets(\\"(){}[]\\") True >>> balanced_brackets(\\"([{}])\\") True >>> balanced_brackets(\\"(}\\") False >>> balanced_brackets(\\"({[})\\") False","solution":"def balanced_brackets(s): Returns True if the input string s containing only the characters '(', ')', '{', '}', '[' and ']' is balanced. Otherwise, returns False. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: # Character is not one of the allowed brackets return False return stack == []"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the subarray with the maximum sum in a list of integers and returns that sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([3, -1, -1, -1, 5]) == 5 >>> max_subarray_sum([-3, -2, -1, -2]) == -1 >>> max_subarray_sum([100]) == 100 >>> max_subarray_sum([-10, -9, -8, -7]) == -7 >>> max_subarray_sum([10, -9, 8, -7, 6, -5, 4, -3, 2, -1]) == 10 # Your solution here","solution":"def max_subarray_sum(nums): Finds the subarray with the maximum sum in a list of integers and returns that sum. :param nums: List[int], a list of integers :return: int, the sum of the subarray with the maximum sum if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def factorial(n: int) -> int: Returns the factorial of a given non-negative integer n. Returns 1 if n is 0. For negative integers, raises a ValueError. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(2) == 2 >>> factorial(3) == 6 >>> factorial(4) == 24 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(20) == 2432902008176640000 >>> factorial(-1) # Raises ValueError","solution":"def factorial(n): Returns the factorial of a given non-negative integer n. Returns 1 if n is 0. For negative integers, raises a ValueError. if n < 0: raise ValueError(\\"Factorial is not defined for negative numbers.\\") result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a number n is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(13) True pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([2, 4, 6, 7, 8, 11, 13]) [2, 7, 11, 13] >>> filter_primes([100, 101, 102, 103, 104]) [101, 103] pass","solution":"def is_prime(n): Determines if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"import string from collections import defaultdict def count_word_frequencies(file_path): Counts the frequency of each word in a text file, ignoring punctuation and case. Args: file_path (str): Path to the text file. Returns: dict: A dictionary where keys are words and values are their frequencies. pass # Unit Tests import tempfile import os def test_count_word_frequencies_single_word(): content = \\"hello\\" temp_file = tempfile.NamedTemporaryFile(delete=False) try: with open(temp_file.name, 'w') as file: file.write(content) result = count_word_frequencies(temp_file.name) assert result == {\\"hello\\": 1} finally: os.remove(temp_file.name) def test_count_word_frequencies_multiple_words(): content = \\"Hello world! Hello again.\\" temp_file = tempfile.NamedTemporaryFile(delete=False) try: with open(temp_file.name, 'w') as file: file.write(content) result = count_word_frequencies(temp_file.name) assert result == {\\"hello\\": 2, \\"world\\": 1, \\"again\\": 1} finally: os.remove(temp_file.name) def test_count_word_frequencies_empty_file(): content = \\"\\" temp_file = tempfile.NamedTemporaryFile(delete=False) try: with open(temp_file.name, 'w') as file: file.write(content) result = count_word_frequencies(temp_file.name) assert result == {} finally: os.remove(temp_file.name) def test_count_word_frequencies_punctuation_handling(): content = \\"Hello, world! This is a test. Test, test, and test.\\" temp_file = tempfile.NamedTemporaryFile(delete=False) try: with open(temp_file.name, 'w') as file: file.write(content) result = count_word_frequencies(temp_file.name) assert result == {\\"hello\\": 1, \\"world\\": 1, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"test\\": 4, \\"and\\": 1} finally: os.remove(temp_file.name) def test_count_word_frequencies_mixed_case(): content = \\"Hello hello HELLO\\" temp_file = tempfile.NamedTemporaryFile(delete=False) try: with open(temp_file.name, 'w') as file: file.write(content) result = count_word_frequencies(temp_file.name) assert result == {\\"hello\\": 3} finally: os.remove(temp_file.name)","solution":"import string from collections import defaultdict def count_word_frequencies(file_path): Counts the frequency of each word in a text file, ignoring punctuation and case. Args: file_path (str): Path to the text file. Returns: dict: A dictionary where keys are words and values are their frequencies. word_freq = defaultdict(int) # Open and read the file with open(file_path, 'r', encoding='utf-8') as file: for line in file: # Remove punctuation and convert to lowercase line = line.translate(str.maketrans('', '', string.punctuation)).lower() words = line.split() # Count each word for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if a palindrome permutation exists, False otherwise. Examples: >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"Aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> can_form_palindrome(\\"12321\\") True >>> can_form_palindrome(\\"123456\\") False","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if a palindrome permutation exists, False otherwise. # Use a dictionary to count the frequency of each character char_count = {} for char in s: char = char.lower() # Normalize the case if char.isalnum(): # Consider only alphanumeric characters if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count characters with odd occurrences odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"class ParkingSystem: Implement a ParkingSystem class. The parking system has three types of slots: big, medium, and small. Each type has a given number of available slots initially. The class should provide methods for: - Parking a car of a specific type. - Removing a parked car of a specific type. - Checking available slots for a specific type of car. >>> ps = ParkingSystem(3, 3, 3) >>> ps.addCar(1) True >>> ps.addCar(2) True >>> ps.addCar(3) True >>> ps.addCar(1) True >>> ps.addCar(1) True >>> ps.addCar(1) False >>> ps.removeCar(1) True >>> ps.availableSlots(1) 2 def __init__(self, big: int, medium: int, small: int): pass def addCar(self, carType: int) -> bool: pass def removeCar(self, carType: int) -> bool: pass def availableSlots(self, carType: int) -> int: pass","solution":"class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.spaces = { 1: big, 2: medium, 3: small } self.occupied_spaces = { 1: 0, 2: 0, 3: 0 } def addCar(self, carType: int) -> bool: if self.occupied_spaces[carType] < self.spaces[carType]: self.occupied_spaces[carType] += 1 return True return False def removeCar(self, carType: int) -> bool: if self.occupied_spaces[carType] > 0: self.occupied_spaces[carType] -= 1 return True return False def availableSlots(self, carType: int) -> int: return self.spaces[carType] - self.occupied_spaces[carType]"},{"question":"from typing import List def sum_of_two_largest_unique_integers(lst: List[int]) -> int: Returns the sum of the two largest unique integers in the list. If there are fewer than two unique integers, return 0. >>> sum_of_two_largest_unique_integers([1, 2, 3, 4, 5]) 9 >>> sum_of_two_largest_unique_integers([5, 5, 5]) 0 >>> sum_of_two_largest_unique_integers([10, 10, 9, 8]) 19 >>> sum_of_two_largest_unique_integers([]) 0 >>> sum_of_two_largest_unique_integers([-1, -2, -3, -4, -5]) -3 >>> sum_of_two_largest_unique_integers(list(range(1, 1000001))) 1999999","solution":"def sum_of_two_largest_unique_integers(lst): Returns the sum of the two largest unique integers in the list. If there are fewer than two unique integers, returns 0. unique_integers = set(lst) if len(unique_integers) < 2: return 0 largest = second_largest = float('-inf') for num in unique_integers: if num > largest: second_largest = largest largest = num elif num > second_largest: second_largest = num return largest + second_largest"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if a binary tree is balanced. A tree is balanced if the depth of the two subtrees of every node never differs by more than 1. :param root: TreeNode, the root of the binary tree :return: Boolean, True if the tree is balanced, False otherwise >>> tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> is_balanced(tree) True >>> tree = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), None) >>> is_balanced(tree) False >>> is_balanced(None) True >>> tree = TreeNode(1) >>> is_balanced(tree) True >>> tree = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8), None), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> is_balanced(tree) True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. A tree is balanced if the depth of the two subtrees of every node never differs by more than 1. :param root: TreeNode, the root of the binary tree :return: Boolean, True if the tree is balanced, False otherwise def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 current_balance = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balance return height_and_balance(root)[1]"},{"question":"from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Rotate the list to the right by k positions. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40, 50], 3) [30, 40, 50, 10, 20] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40, 50], 8) [30, 40, 50, 10, 20] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([10, 20, 30, 40, 50], 5) [10, 20, 30, 40, 50] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([10, 20, 30, 40, 50], 0) [10, 20, 30, 40, 50] >>> rotate_list([], 3) [] >>> rotate_list([], 0) [] >>> rotate_list([1], 3) [1] >>> rotate_list([10], 0) [10]","solution":"def rotate_list(lst, k): Rotates the list to the right by k positions. if not lst or k <= 0: return lst n = len(lst) k = k % n # Handle cases where k is larger than the list's length return lst[-k:] + lst[:-k]"},{"question":"def longest_alphabetical_word(sentence: str) -> str: Given a string of words, find the longest word in which all the characters appear in order in the alphabet. If there are multiple words of the same length, return the first one. The words are separated by spaces, and the input string will contain only lowercase letters and spaces. >>> longest_alphabetical_word(\\"hello abcdefg xzy\\") == \\"abcdefg\\" >>> longest_alphabetical_word(\\"email abc defgh\\") == \\"defgh\\" >>> longest_alphabetical_word(\\"az by cx\\") == \\"az\\" pass","solution":"def longest_alphabetical_word(sentence: str) -> str: def is_alphabetical(word): return all(word[i] <= word[i+1] for i in range(len(word) - 1)) words = sentence.split() max_length = 0 longest_word = \\"\\" for word in words: if is_alphabetical(word) and len(word) > max_length: max_length = len(word) longest_word = word return longest_word"},{"question":"def isMagicSquare(matrix: List[List[int]]) -> int: Check if the given matrix is a magic square. >>> isMagicSquare([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == 1 >>> isMagicSquare([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 >>> isMagicSquare([[1]]) == 1 >>> isMagicSquare([[1, 1], [1, 1]]) == 0 >>> isMagicSquare([[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]) == 1 >>> isMagicSquare([[16, 3, 2, 13], [5, 10, 12, 8], [9, 6, 7, 11], [4, 15, 14, 1]]) == 0 pass","solution":"def isMagicSquare(matrix): Check if the given matrix is a magic square. Parameters: matrix (list of list of int): A 2D array representing the square matrix. Returns: int: 1 if the matrix is a magic square, 0 otherwise. n = len(matrix) magic_sum = n * (n*n + 1) // 2 # Check rows and columns for i in range(n): if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(n)) != magic_sum: return 0 # Check diagonals if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-i-1] for i in range(n)) != magic_sum: return 0 # Check that all numbers from 1 to n^2 are present expected_numbers = set(range(1, n*n + 1)) actual_numbers = set() for row in matrix: actual_numbers.update(row) if expected_numbers != actual_numbers: return 0 return 1"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index i is the product of all the numbers in the original list except the one at index i. Achieved without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 10]) [10, 5] >>> product_except_self([100, 200, 300]) [60000, 30000, 20000]","solution":"def product_except_self(nums): Returns a list such that each element at index i is the product of all the numbers in the original list except the one at index i. Achieved without using division and in O(n) time complexity. length = len(nums) # Initialize the result array where we'll store our results. result = [1] * length # Calculate the prefix products and store them in result. prefix_product = 1 for i in range(length): result[i] = prefix_product prefix_product *= nums[i] # Calculate the postfix products and multiply with the result. postfix_product = 1 for i in range(length - 1, -1, -1): result[i] *= postfix_product postfix_product *= nums[i] return result"},{"question":"def find_event_days(days_past): Given a list of integers representing the number of days since an event occurred, return a list of strings representing the day of the week each event happened. Assume today is Monday. >>> find_event_days([0, 1, 2, 3, 4, 5, 6]) ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] >>> find_event_days([7, 8, 9, 10, 11, 12, 13]) ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] >>> find_event_days([14, 15, 16, 20, 25]) ['Monday', 'Tuesday', 'Wednesday', 'Sunday', 'Friday'] >>> find_event_days([-1, -2, -3, -4, -5, -6]) ['Sunday', 'Saturday', 'Friday', 'Thursday', 'Wednesday', 'Tuesday'] >>> find_event_days([]) []","solution":"def find_event_days(days_past): Given a list of integers representing the number of days since an event occurred, return a list of strings representing the day of the week each event happened. Assume today is Monday. days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] return [days_of_week[day % 7] for day in days_past]"},{"question":"def find_pair_with_sum(numbers: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Returns a tuple of two integers from the list that add up to the target sum, or None if no such pair exists. This function has a time complexity of O(n). >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None","solution":"def find_pair_with_sum(numbers, target_sum): Returns a tuple of two integers from the list that add up to the target sum, or None if no such pair exists. This function has a time complexity of O(n). seen_numbers = {} for number in numbers: complement = target_sum - number if complement in seen_numbers: return (complement, number) seen_numbers[number] = True return None"},{"question":"from typing import List, Tuple def find_anagram_pairs(words: List[str]) -> List[Tuple[str, str]]: Returns a list of tuples, each containing two words that are anagrams of each other. Args: words (list of str): The list of words to be checked. Returns: list of tuples: A list of tuples where each tuple contains two anagram words. >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"apple\\"]) [(\\"listen\\", \\"silent\\")] >>> find_anagram_pairs([\\"hello\\", \\"world\\", \\"python\\"]) [] >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gooogle\\"]) [(\\"listen\\", \\"silent\\"), (\\"listen\\", \\"enlist\\"), (\\"listen\\", \\"inlets\\"), (\\"silent\\", \\"enlist\\"), (\\"silent\\", \\"inlets\\"), (\\"enlist\\", \\"inlets\\")] >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"Enlist\\"]) [] >>> find_anagram_pairs([]) [] >>> find_anagram_pairs([\\"word\\"]) []","solution":"from collections import defaultdict def find_anagram_pairs(words): Returns a list of tuples, each containing two words that are anagrams of each other. Args: words (list of str): The list of words to be checked. Returns: list of tuples: A list of tuples where each tuple contains two anagram words. anagrams = defaultdict(list) for word in words: # Sort the word and use it as the key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) anagram_pairs = [] for group in anagrams.values(): if len(group) > 1: # Create tuples of anagram pairs for i in range(len(group)): for j in range(i + 1, len(group)): anagram_pairs.append((group[i], group[j])) return anagram_pairs"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers that add up to the target number. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 3, 4, 2], 6) [2, 3] >>> two_sum([10, 20, 30, 40, 50], 90) [3, 4] >>> two_sum([1, 2], 3) [0, 1]","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target number. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def primes_up_to(n: int) -> list: Returns a list of all prime numbers up to n in ascending order. >>> primes_up_to(1) [] >>> primes_up_to(10) [2, 3, 5, 7] >>> primes_up_to(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_up_to(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_up_to(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> primes_up_to(11) [2, 3, 5, 7, 11]","solution":"def primes_up_to(n): Returns a list of all prime numbers up to n (inclusive). Parameters: n (int): The upper limit to generate prime numbers. Returns: list: A list of prime numbers up to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"def factorial(n): Explain the concept of recursive algorithms by providing a detailed example of calculating the factorial of a number. Discuss the base case and recursive case. Compare the recursive solution with an iterative approach, highlighting the trade-offs in terms of time complexity and space complexity. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 if n == 0: return 1 else: return n * factorial(n - 1) def factorial_iterative(n): Returns the factorial of a non-negative integer n using an iterative approach. >>> factorial_iterative(0) 1 >>> factorial_iterative(1) 1 >>> factorial_iterative(5) 120 >>> factorial_iterative(10) 3628800 result = 1 for i in range(1, n + 1): result *= i return result","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 else: return n * factorial(n - 1) # Iterative approach: def factorial_iterative(n): Returns the factorial of a non-negative integer n using an iterative approach. result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: You are given a matrix of integers where each row is sorted in ascending order from left to right. Your task is to write a function that searches for a target value in this matrix. The function should return the position of the target in the format \`(row_index, col_index)\` if it is found, otherwise return \`(-1, -1)\`. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> target = 5 >>> search_matrix(matrix, target) (1, 1) >>> target = 20 >>> search_matrix(matrix, target) (-1, -1) pass","solution":"from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] < target: row += 1 else: col -= 1 return (-1, -1)"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: List of lists where each list represents a row of the n x n matrix. def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_clockwise(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix_90_clockwise(matrix) expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix_90_clockwise(matrix) expected = [ [3, 1], [4, 2] ] assert matrix == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix_90_clockwise(matrix) expected = [ [1] ] assert matrix == expected","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. :param matrix: List of lists where each list represents a row of the n x n matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def quicksort(arr): Sorts a list of integers in ascending order using the QuickSort algorithm. Parameters: arr (list): A list of integers. Returns: list: The sorted list in ascending order. pass # Test cases def test_quicksort_empty_list(): assert quicksort([]) == [] def test_quicksort_single_element(): assert quicksort([1]) == [1] def test_quicksort_identical_elements(): assert quicksort([5, 5, 5, 5]) == [5, 5, 5, 5] def test_quicksort_sorted_list(): assert quicksort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_quicksort_unsorted_list(): assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] def test_quicksort_reversed_list(): assert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_quicksort_mixed_signs(): assert quicksort([3, -1, 4, -2, 0]) == [-2, -1, 0, 3, 4]","solution":"def quicksort(arr): Sorts a list of integers in ascending order using the QuickSort algorithm. Parameters: arr (list): A list of integers. Returns: list: The sorted list in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"import heapq from typing import List def minimum_obstacles(grid: List[List[int]]) -> int: Returns the minimum number of obstacles that should be removed to create a path from the top-left corner to the bottom-right corner. >>> minimum_obstacles([[0, 1, 1], [1, 1, 0], [1, 1, 0]]) 2 >>> minimum_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> minimum_obstacles([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 3","solution":"import heapq def minimum_obstacles(grid): Returns the minimum number of obstacles that should be removed to create a path from the top-left corner to the bottom-right corner. m, n = len(grid), len(grid[0]) # Directions array for moving up, down, left, or right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Min-heap to keep track of cells by the number of obstacles cleared heap = [(0, 0, 0)] # (obstacles_removed, row, col) visited = [[False for _ in range(n)] for _ in range(m)] while heap: obstacles, x, y = heapq.heappop(heap) # If we reach the bottom-right corner if x == m - 1 and y == n - 1: return obstacles if visited[x][y]: continue visited[x][y] = True # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: heapq.heappush(heap, (obstacles + grid[nx][ny], nx, ny)) return -1 # Should never reach here as there is always a path"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit achievable by making a single buy and sell transaction. Args: prices (list of int): List of prices representing the stock price on each day. Returns: int: Maximum profit achievable. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([10, 7, 5, 3, 6, 8, 2, 4]) 5 >>> max_profit([]) 0 >>> max_profit([3, 3, 3, 3, 3]) 0","solution":"def max_profit(prices): Calculate the maximum profit achievable by making a single buy and sell transaction. Args: prices (list of int): List of prices representing the stock price on each day. Returns: int: Maximum profit achievable. if not prices: return 0 max_profit = 0 min_price = prices[0] for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def process_list(numbers): This function processes a list of integers and returns a new list where each element is: - Squared if the element is even. - Cubed if the element is odd. Parameters: numbers (list): A list of integers. Returns: list: A new list where each element is transformed as specified. pass # Test cases def test_process_list_positive_numbers(): assert process_list([1, 2, 3, 4]) == [1, 4, 27, 16] def test_process_list_with_zero(): assert process_list([0, 1, 2, 3, 4]) == [0, 1, 4, 27, 16] def test_process_list_negative_numbers(): assert process_list([-1, -2, -3, -4]) == [-1, 4, -27, 16] def test_process_list_mixed_sign_numbers(): assert process_list([1, -2, 3, -4, 0]) == [1, 4, 27, 16, 0] def test_process_list_empty(): assert process_list([]) == []","solution":"def process_list(numbers): This function processes a list of integers and returns a new list where each element is: - Squared if the element is even. - Cubed if the element is odd. Parameters: numbers (list): A list of integers. Returns: list: A new list where each element is transformed as specified. return [x**2 if x % 2 == 0 else x**3 for x in numbers]"},{"question":"def is_prime(n: int) -> bool: Returns True if the number n is a prime number, otherwise False. pass def filter_primes(nums: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([]) [] >>> filter_primes([4, 6, 8, 9, 10, 12]) [] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([29]) [29] >>> filter_primes([30]) [] >>> filter_primes([29, 77, 97, 85, 19]) [29, 97, 19] pass","solution":"from math import isqrt def is_prime(n): Returns True if the number n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(nums): Returns a list of prime numbers from the given list of integers. return [num for num in nums if is_prime(num)]"},{"question":"from collections import deque def is_palindrome(s: str) -> bool: Implement a function to check if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. The function should use a deque for efficient removal of elements from both ends. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\" \\") == True >>> is_palindrome(\\"madam\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Able was I, ere I saw Elba\\") == True >>> is_palindrome(\\"hello world\\") == False","solution":"from collections import deque def is_palindrome(s: str) -> bool: Returns whether the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. # Initialize an empty deque dq = deque() # Populate the deque with alphanumeric characters in lowercase for char in s: if char.isalnum(): dq.append(char.lower()) # Check palindrome by comparing the ends while len(dq) > 1: if dq.popleft() != dq.pop(): return False return True"},{"question":"def reverse_string(s: str) -> str: Returns the string with its characters in reversed order. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"world\\") \\"dlrow\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"abcd\\") \\"dcba\\" >>> reverse_string(\\"12345\\") \\"54321\\" >>> reverse_string(\\"racecar\\") \\"racecar\\" >>> reverse_string(\\"!@#%^&*()\\") \\")(*&^%#@!\\" >>> reverse_string(\\"The quick brown fox jumps over the lazy dog\\") \\"god yzal eht revo spmuj xof nworb kciuq ehT\\"","solution":"def reverse_string(s: str) -> str: Returns the string with its characters in reversed order. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Write a function that takes two strings as input and returns a boolean indicating whether the first string is an anagram of the second string. Ignore case and spaces, and assume the strings contain only alphabetic characters. >>> is_anagram(\\"Listen\\", \\"Silent\\") # returns True >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") # returns True >>> is_anagram(\\"Dormitory\\", \\"Dirty room\\") # returns True >>> is_anagram(\\"Hello\\", \\"World\\") # returns False >>> is_anagram(\\"Aabbcc\\", \\"aabbccc\\") # returns False >>> is_anagram(\\"\\", \\"\\") # returns True >>> is_anagram(\\"a\\", \\"aa\\") # returns False","solution":"def is_anagram(str1, str2): Returns True if str1 is an anagram of str2, False otherwise. Ignores case and spaces. clean_str1 = ''.join(str1.lower().split()) clean_str2 = ''.join(str2.lower().split()) return sorted(clean_str1) == sorted(clean_str2)"},{"question":"def longest_unique_substtr(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string. >>> longest_unique_substtr(\\"abcabcbb\\") == 3 >>> longest_unique_substtr(\\"abcdef\\") == 6 >>> longest_unique_substtr(\\"aaaaaa\\") == 1 >>> longest_unique_substtr(\\"pwwkew\\") == 3 >>> longest_unique_substtr(\\"\\") == 0 >>> longest_unique_substtr(\\"b\\") == 1 >>> longest_unique_substtr(\\"au\\") == 2 >>> longest_unique_substtr(\\"abcbda\\") == 4","solution":"def longest_unique_substtr(s): Returns the length of the longest substring without repeating characters in the given string. n = len(s) char_index_map = {} longest = 0 start = 0 for i in range(n): if s[i] in char_index_map: start = max(start, char_index_map[s[i]] + 1) char_index_map[s[i]] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List from collections import Counter def top_ten_frequent(nums: List[int]) -> List[int]: Returns a list of the ten most frequent elements in descending order of their frequency. Tied elements are ordered in ascending order. >>> top_ten_frequent([1, 3, 3, 2, 1, 4, 4, 4, 5, 6, 6, 6, 6, 3, 3, 3, 3, 5, 5, 1]) [3, 6, 1, 4, 5, 2] >>> top_ten_frequent([]) [] >>> top_ten_frequent([1]) [1] >>> top_ten_frequent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> top_ten_frequent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> top_ten_frequent([1] * 5000 + [2] * 4000 + [3] * 3000 + [4] * 2000 + [5] * 1000 + [6, 7, 8, 9, 10] * 500 + [11, 12, 13, 14, 15, 16]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"from collections import Counter def top_ten_frequent(nums): Returns a list of the ten most frequent elements in descending order of their frequency. Tied elements are ordered in ascending order. if not nums: return [] # Calculate the frequency of each element using Counter frequency = Counter(nums) # Sort items based on frequency (high to low) and then by value (low to high) sorted_freq = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Extract the top 10 elements return [item[0] for item in sorted_freq[:10]]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the given string can be rearranged into a palindrome. >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"rejected\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"abab\\") == True >>> can_form_palindrome(\\"abc\\") == False","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged into a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged into a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd count return odd_count <= 1"},{"question":"def most_frequent_integer(arr): Determine the integer that appears the most frequently in the list. If multiple integers have the same highest frequency, return the smallest one. >>> most_frequent_integer([5]) == 5 >>> most_frequent_integer([1, 2, 3, 4]) == 1 >>> most_frequent_integer([1, 2, 2, 3, 3]) == 2 >>> most_frequent_integer([4, 4, 5, 5, 6]) == 4 >>> most_frequent_integer([7, 7, 7, 7]) == 7 >>> most_frequent_integer([]) == None >>> most_frequent_integer([-1, -1, 0, 0, 1]) == -1 >>> most_frequent_integer([-1, 0, 0, 1, 1]) == 0 >>> most_frequent_integer([-1, -2, -2, -3]) == -2 # Your code here","solution":"def most_frequent_integer(arr): Returns the integer that appears the most frequently in the list. If there are multiple integers with the same highest frequency, return the smallest one. from collections import Counter if not arr: return None counter = Counter(arr) max_frequency = max(counter.values()) candidates = [key for key, value in counter.items() if value == max_frequency] return min(candidates)"},{"question":"from itertools import permutations from typing import List def unique_permutations(s: str) -> List[str]: Develop a Python function that generates all possible permutations of a given string. Ensure that your function handles strings with duplicate characters by including each unique permutation only once in the result. >>> unique_permutations(\\"\\") == [\\"\\"] >>> unique_permutations(\\"a\\") == [\\"a\\"] >>> unique_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] >>> unique_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] >>> unique_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> unique_permutations(\\"aabc\\") == [\\"aabc\\", \\"aacb\\", \\"abac\\", \\"abca\\", \\"acab\\", \\"acba\\", \\"baac\\", \\"baca\\", \\"bcaa\\", \\"caab\\", \\"caba\\", \\"cbaa\\"]","solution":"from itertools import permutations def unique_permutations(s): Returns a list of all unique permutations of the given string s. return sorted(set(''.join(p) for p in permutations(s)))"},{"question":"def register_user(data): Mock function to simulate user registration. >>> register_user({'username': 'testuser', 'email': 'testuser@example.com', 'password': 'securepassword'}) ({\\"message\\": \\"User created successfully!\\"}, 201) >>> register_user({'username': 'testuser'}) ({\\"error\\": \\"Missing required fields\\"}, 400)","solution":"def register_user(data): Mock function to simulate user registration. username = data.get('username') email = data.get('email') password = data.get('password') if username and email and password: # Simulate user creation return {'message': 'User created successfully!'}, 201 else: return {'error': 'Missing required fields'}, 400"},{"question":"def find_char_indices(s: str, char: str) -> list: Returns a list of indices where the character appears in the string. If the character does not exist in the string, returns an empty list. :param s: str - The string to search within. :param char: str - The character to search for. :return: list of int - The list of indices where the character appears. >>> find_char_indices(\\"\\", \\"a\\") [] >>> find_char_indices(\\"hello\\", \\"z\\") [] >>> find_char_indices(\\"hello\\", \\"e\\") [1] >>> find_char_indices(\\"hello world\\", \\"o\\") [4, 7] >>> find_char_indices(\\"space bar\\", \\" \\") [5] >>> find_char_indices(\\"aAaAaA\\", \\"a\\") [0, 2, 4] >>> find_char_indices(\\"aAaAaA\\", \\"A\\") [1, 3, 5]","solution":"def find_char_indices(s, char): Returns a list of indices where the character appears in the string. If the character does not exist in the string, returns an empty list. :param s: str - The string to search within. :param char: str - The character to search for. :return: list of int - The list of indices where the character appears. return [i for i, c in enumerate(s) if c == char]"},{"question":"def is_prime(n: int) -> bool: Returns True if the input integer is a prime number, otherwise returns False. The input integer will be in the range of 1 to 1000000. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(20) False >>> is_prime(104729) True >>> is_prime(1000000) False","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def is_palindrome(s): Determines if a given string is a palindrome, ignoring case, spaces, and non-alphanumeric characters. Returns a boolean value. If the input is not a string, returns a meaningful error message. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"RaceCar\\") == True >>> is_palindrome(\\"A man, a plan, a canal: Panama!\\") == True >>> is_palindrome(12345) == \\"Input must be a string.\\"","solution":"import re def is_palindrome(s): Determines if a given string is a palindrome, ignoring case, spaces, and non-alphanumeric characters. Returns a boolean value. If the input is not a string, returns a meaningful error message. if not isinstance(s, str): return \\"Input must be a string.\\" # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is a palindrome return cleaned == cleaned[::-1]"},{"question":"class ShoppingCart: A simple shopping cart system for an online store that supports adding items, removing items, calculating the total cost, and applying discount codes. >>> cart = ShoppingCart() >>> cart.add_item(\\"apple\\", 1.00, 3) >>> cart.add_item(\\"banana\\", 0.50, 2) >>> cart.apply_discount(\\"DISCOUNT10\\") 3.6 >>> cart.apply_discount(\\"DISCOUNT20\\") 3.2 def __init__(self): self.items = [] def add_item(self, name, price, quantity): pass def remove_item(self, name): pass def total_cost(self): pass def apply_discount(self, discount_code): pass def test_add_item(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.00, 3) assert len(cart.items) == 1 def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.00, 3) cart.remove_item(\\"apple\\") assert not cart.items def test_total_cost(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.00, 3) cart.add_item(\\"banana\\", 0.50, 2) assert cart.total_cost() == 4.0 def test_apply_discount(): cart = ShoppingCart() cart.add_item(\\"apple\\", 1.00, 3) cart.add_item(\\"banana\\", 0.50, 2) assert cart.apply_discount(\\"DISCOUNT10\\") == 3.6 assert cart.apply_discount(\\"DISCOUNT20\\") == 3.2","solution":"class ShoppingCart: def __init__(self): self.items = [] def add_item(self, name, price, quantity): self.items.append({'name': name, 'price': price, 'quantity': quantity}) def remove_item(self, name): self.items = [item for item in self.items if item['name'] != name] def total_cost(self): total = sum(item['price'] * item['quantity'] for item in self.items) return total def apply_discount(self, discount_code): total = self.total_cost() if discount_code == \\"DISCOUNT10\\": total = total * 0.9 elif discount_code == \\"DISCOUNT20\\": total = total * 0.8 return total"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2 to 9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"27\\") [\\"ap\\", \\"aq\\", \\"ar\\", \\"as\\", \\"bp\\", \\"bq\\", \\"br\\", \\"bs\\", \\"cp\\", \\"cq\\", \\"cr\\", \\"cs\\"] >>> letter_combinations(\\"22\\") [\\"aa\\", \\"ab\\", \\"ac\\", \\"ba\\", \\"bb\\", \\"bc\\", \\"ca\\", \\"cb\\", \\"cc\\"] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' }","solution":"def letter_combinations(digits): Returns all possible letter combinations that the given digits could represent. if not digits: return [] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return letters = phone_mapping[digits[index]] for letter in letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def calculate_active_time(activities: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculates the total active time for each user given their login and logout activities. Parameters: activities (list of tuples): Each tuple contains a user ID, an activity type ('login'/'logout'), and a timestamp. Returns: dict: A dictionary where keys are user IDs and values are total active times in seconds.","solution":"def calculate_active_time(activities): Calculates the total active time for each user given their login and logout activities. Parameters: activities (list of tuples): Each tuple contains a user ID, an activity type ('login'/'logout'), and a timestamp. Returns: dict: A dictionary where keys are user IDs and values are total active times in seconds. user_times = {} login_times = {} for user_id, activity_type, timestamp in activities: if activity_type == 'login': login_times[user_id] = timestamp elif activity_type == 'logout': if user_id in login_times: active_time = timestamp - login_times[user_id] if user_id in user_times: user_times[user_id] += active_time else: user_times[user_id] = active_time del login_times[user_id] return user_times"},{"question":"from typing import List def find_second_largest(nums: List[int]) -> int: Given a list of integers, finds and returns the second largest element in the list. If the list contains less than two unique elements, raises a ValueError. >>> find_second_largest([2, 3, 1, 4, 4, 5]) == 4 >>> find_second_largest([10, 20, 20, 30]) == 20 >>> find_second_largest([1]) raises ValueError >>> find_second_largest([5, 5, 5]) raises ValueError >>> find_second_largest([-1, -2, 3, 3, 2, 1]) == 2 >>> find_second_largest([-10, -20, -30, -40, -10, -20]) == -20 >>> find_second_largest([1000, 5000, 10000, 5000, 20000, 10000, 20000]) == 10000 pass","solution":"def find_second_largest(nums): Returns the second largest unique element in the list. If the list contains less than two unique elements, raises a ValueError. unique_nums = list(set(nums)) if len(unique_nums) < 2: raise ValueError(\\"List must contain at least two unique elements\\") unique_nums.sort() return unique_nums[-2]"},{"question":"def filter_and_sort_evens(arr): Takes an array of integers and returns a new array containing only the even integers, sorted in ascending order. Parameters: arr (list): A list of integers. Returns: list: A new list containing only even integers sorted in ascending order. Examples: >>> filter_and_sort_evens([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_and_sort_evens([1, 3, 5, 7, 9]) [] >>> filter_and_sort_evens([6, 2, 5, 8, 11, 4]) [2, 4, 6, 8] >>> filter_and_sort_evens([0, -4, -10, 15, 23]) [-10, -4, 0] >>> filter_and_sort_evens([]) [] >>> filter_and_sort_evens([1, 1, 1, 1]) [] >>> filter_and_sort_evens([-2, -4, -6, -8]) [-8, -6, -4, -2]","solution":"def filter_and_sort_evens(arr): Takes an array of integers and returns a new array containing only the even integers, sorted in ascending order. Parameters: arr (list): A list of integers. Returns: list: A new list containing only even integers sorted in ascending order. even_integers = [x for x in arr if x % 2 == 0] even_integers.sort() return even_integers"},{"question":"def int_to_roman(num: int) -> str: Converts a given integer to its corresponding Roman numeral representation. >>> int_to_roman(3549) 'MMMDXLIX' >>> int_to_roman(1) 'I' >>> int_to_roman(44) 'XLIV' >>> int_to_roman(3999) 'MMMCMXCIX' >>> int_to_roman(500) 'D' >>> int_to_roman(1000) 'M' >>> int_to_roman(0) ''","solution":"def int_to_roman(num): Converts an integer to its corresponding Roman numeral representation. # Define the Roman numeral mapping for each place value val_map = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] roman_numeral = '' for (value, symbol) in val_map: while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"def max_subarray_sum(input_list: List[int]) -> int: Function to find the maximum sum of any contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5","solution":"def max_subarray_sum(input_list): Function to find the maximum sum of any contiguous subarray using Kadane's Algorithm. if not input_list: return 0 max_current = max_global = input_list[0] for num in input_list[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive sequence of elements in an unsorted array of integers. The solution has a linear time complexity O(n). >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([10, 11, 12, 15, 16, 14, 13]) 7 >>> longest_consecutive([1, 2, 2, 3, 4]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([5]) 1 >>> longest_consecutive([10, 30, 20, 40]) 1 >>> longest_consecutive([-1, 0, 1, 2, -3, -2]) 6","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive sequence of elements in an unsorted array of integers. The solution has a linear time complexity O(n). if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # only check for the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> List[int]: Returns the longest increasing subsequence of a list of integers. >>> longest_increasing_subsequence([]) == [] >>> longest_increasing_subsequence([1]) == [1] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == [1] >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == [2, 3, 7, 18] >>> longest_increasing_subsequence([0, 3, 1, 6, 2, 2, 7]) == [0, 1, 2, 7] pass","solution":"from bisect import bisect_left def longest_increasing_subsequence(nums): Returns the longest increasing subsequence of a list of integers. if not nums: return [] # Subsequence holding the ends of the longest increasing subsequence at each point sub = [] for num in nums: pos = bisect_left(sub, num) # If num is greater than all elements in sub, append it. if pos == len(sub): sub.append(num) else: # Otherwise replace the element at the found position sub[pos] = num return sub"},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Find the length of the longest substring of a given string that contains at most k distinct characters. >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"\\", 1) 0 >>> longest_substring_with_k_distinct_chars(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"abcd\\", 4) 4 >>> longest_substring_with_k_distinct_chars(\\"abcd\\", 3) 3 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 2) 4 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 10) 6 >>> longest_substring_with_k_distinct_chars(\\"a\\", 1) 1 >>> longest_substring_with_k_distinct_chars(\\"a\\", 10) 1 >>> longest_substring_with_k_distinct_chars(\\"abcde\\", 5) 5","solution":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: if k == 0 or not s: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def filter_above_average(lst): Develop a Python function that takes a list of integers and returns a new list containing only the elements that are greater than the average value of the original list. Ensure that the input list has at least one element and no more than 1000 elements. Example: >>> filter_above_average([1, 2, 3, 4, 5]) [4, 5] >>> filter_above_average([10, 20, 30]) [20, 30] >>> filter_above_average([5, 5, 5, 5]) []","solution":"def filter_above_average(lst): Returns a new list containing only the elements that are greater than the average value of the original list. :param lst: List of integers :return: List of integers greater than the average value if not lst: raise ValueError(\\"Input list must contain at least one element.\\") average = sum(lst) / len(lst) return [x for x in lst if x > average]"},{"question":"def product_of_evens_modulo(nums: List[int]) -> int: Compute the product of all even numbers in a given list of integers, excluding numbers greater than 50, and then return the result modulo 1000000007. >>> product_of_evens_modulo([12, 18, 25, 32, 45, 60, 72, 80]) == 6912 >>> product_of_evens_modulo([]) == 1 >>> product_of_evens_modulo([25, 45, 65, 75]) == 1 >>> product_of_evens_modulo([51, 60, 72, 80]) == 1 >>> product_of_evens_modulo([2, 4, 51, 52, 18, 20]) == 2880 >>> product_of_evens_modulo([40, 45, 50, 60, 70, 80]) == 2000","solution":"def product_of_evens_modulo(nums): Computes the product of all even numbers in the given list \`nums\`, excluding numbers greater than 50 and returns the result modulo 1000000007. MOD = 1000000007 product = 1 for num in nums: if num % 2 == 0 and num <= 50: product = (product * num) % MOD return product"},{"question":"def square_positive_numbers(lst: List[int]) -> List[int]: This function takes a list of integers as input and returns a new list containing the squares of all the positive integers in the original list. Negative integers and zeros will be excluded from the new list. Parameters: lst (list): A list of integers Returns: list: A new list containing the squares of all the positive integers in the original list Examples: >>> square_positive_numbers([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> square_positive_numbers([-1, -2, -3, -4, -5]) [] >>> square_positive_numbers([-1, 2, -3, 4, 0]) [4, 16]","solution":"def square_positive_numbers(lst): This function takes a list of integers as input and returns a new list containing the squares of all the positive integers in the original list. Negative integers and zeros will be excluded from the new list. Parameters: lst (list): A list of integers Returns: list: A new list containing the squares of all the positive integers in the original list return [x**2 for x in lst if x > 0]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the given mathematical expression and returns the result. The expression can contain integer numbers, +, -, *, and / operators, and whitespace will be handled appropriately. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3 + 5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluates the given mathematical expression and returns the result. The expression can contain integer numbers, +, -, *, and / operators, and whitespace will be handled appropriately. try: # Using eval to directly evaluate the expression return int(eval(expression)) except (SyntaxError, NameError, ZeroDivisionError): raise ValueError(\\"Invalid input expression\\") # Example usage: # print(evaluate_expression(\\"3 + 2 * 2\\")) # Should output 7 # print(evaluate_expression(\\" 3/2 \\")) # Should output 1 # print(evaluate_expression(\\" 3 + 5 / 2 \\"))# Should output 5"},{"question":"import random def guess_number_game(): Simulate a simple text-based game where the user guesses a randomly generated number between 1 and 100. Provide feedback indicating whether the guessed number is too high, too low, or correct. Allow the user to continue guessing until the correct number is found. Count the number of attempts taken by the user to guess the number correctly and display this count at the end. # Example test cases # Since this function involves interaction, it is recommended to run these tests manually or use mock inputs. # Test case: Correct on first try # Mock random to return 42, input to return '42', expect: \\"Correct! You've guessed the number in 1 attempts.\\" # Test case: Too low then correct # Mock random to return 50, input to return ['20', '50'], expect: \\"Too low!\\", \\"Correct! You've guessed the number in 2 attempts.\\" # Test case: Too high then correct # Mock random to return 30, input to return ['60', '30'], expect: \\"Too high!\\", \\"Correct! You've guessed the number in 2 attempts.\\" # Test case: Multiple attempts # Mock random to return 25, input to return ['10', '20', '30', '25'], expect: \\"Too low!\\", \\"Too low!\\", \\"Too high!\\", \\"Correct! You've guessed the number in 4 attempts.\\"","solution":"import random def guess_number_game(): Simulate a text-based game where the user guesses a randomly generated number between 1 and 100. Provide feedback for each guess and count the number of attempts until the correct number is guessed. number_to_guess = random.randint(1, 100) attempts = 0 while True: guess = int(input(\\"Guess the number between 1 and 100: \\")) attempts += 1 if guess < number_to_guess: print(\\"Too low!\\") elif guess > number_to_guess: print(\\"Too high!\\") else: print(f\\"Correct! You've guessed the number in {attempts} attempts.\\") break"},{"question":"def format_number_with_commas(n: int) -> str: Takes an integer n (1 ≤ n ≤ 10^9) as input and returns a string representing the number with commas as thousands separators. >>> format_number_with_commas(1234567890) '1,234,567,890' >>> format_number_with_commas(1000) '1,000' >>> format_number_with_commas(123) '123'","solution":"def format_number_with_commas(n): Returns the string of the integer n with commas as thousands separators. return f\\"{n:,}\\""},{"question":"def tail(file_path: str, num_lines: int = 10) -> str: Emulates the UNIX \`tail\` command. Reads the last \`num_lines\` lines from the file at \`file_path\`. Parameters: file_path (str): The path to the text file. num_lines (int, optional): The number of lines to tail. Defaults to 10. Returns: str: The last \`num_lines\` lines of the file as a single string. >>> import os >>> import tempfile >>> data = \\"n\\".join(f\\"Line {i}\\" for i in range(1, 21)) >>> with tempfile.NamedTemporaryFile(delete=False) as tmp_file: ... tmp_file.write(data.encode()) ... tmp_file_path = tmp_file.name >>> tail(tmp_file_path, 10) 'Line 11nLine 12nLine 13nLine 14nLine 15nLine 16nLine 17nLine 18nLine 19nLine 20' >>> tail(tmp_file_path, 5) 'Line 16nLine 17nLine 18nLine 19nLine 20' >>> tail(tmp_file_path, 20) 'Line 1nLine 2nLine 3nLine 4nLine 5nLine 6nLine 7nLine 8nLine 9nLine 10nLine 11nLine 12nLine 13nLine 14nLine 15nLine 16nLine 17nLine 18nLine 19nLine 20' >>> os.remove(tmp_file_path)","solution":"def tail(file_path, num_lines=10): Emulates the UNIX \`tail\` command. Reads the last \`num_lines\` lines from the file at \`file_path\`. with open(file_path, 'rb') as f: # Move to the end of the file f.seek(0, 2) file_size = f.tell() buffer_size = 1024 buffer = b'' blocked_lines = [] # Search for lines in the file, starting from the end while len(blocked_lines) <= num_lines and file_size > 0: if file_size < buffer_size: buffer_size = file_size file_size -= buffer_size f.seek(file_size) buffer = f.read(buffer_size) + buffer blocked_lines = buffer.split(b'n') # Join the last \`num_lines\` lines return b'n'.join(blocked_lines[-num_lines:]).decode('utf-8')"},{"question":"def process_numbers(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the squares of the even integers and the cubes of the odd integers. The output list should maintain the original order of input elements. Parameters: numbers (list): A list of integers. Returns: list: A new list with processed integers. >>> process_numbers([2, 4, 6]) [4, 16, 36] >>> process_numbers([1, 3, 5]) [1, 27, 125] >>> process_numbers([1, 2, 3, 4, 5]) [1, 4, 27, 16, 125] >>> process_numbers([]) [] >>> process_numbers([-1, -2, -3, -4, 0]) [-1, 4, -27, 16, 0] >>> process_numbers([2]) [4] >>> process_numbers([3]) [27]","solution":"def process_numbers(numbers): Returns a new list containing the squares of the even integers and the cubes of the odd integers from the input list. Parameters: numbers (list): A list of integers. Returns: list: A new list with processed integers. result = [] for num in numbers: if num % 2 == 0: result.append(num ** 2) else: result.append(num ** 3) return result"},{"question":"def elevator_system(commands): Simulates an elevator system in a building. Parameters: commands (List[str]): A list of commands in the format specified (i.e., \\"CALL <floor_number>\\" or \\"DESTINATION <floor_number>\\"). Returns: List[int]: The sequence of floors that the elevator travels through. from solution import elevator_system def test_elevator_system_basic(): commands = [\\"CALL 3\\", \\"CALL 5\\", \\"DESTINATION 2\\", \\"CALL 1\\", \\"DESTINATION 4\\", \\"DESTINATION 6\\"] assert elevator_system(commands) == [0, 1, 2, 3, 4, 5, 6] def test_elevator_system_single_call(): commands = [\\"CALL 0\\"] assert elevator_system(commands) == [0] def test_elevator_system_single_destination(): commands = [\\"DESTINATION 2\\"] assert elevator_system(commands) == [0, 2] def test_elevator_system_mixed(): commands = [\\"CALL 4\\", \\"DESTINATION 2\\", \\"CALL 1\\", \\"CALL 3\\", \\"DESTINATION 5\\"] assert elevator_system(commands) == [0, 1, 2, 3, 4, 5] def test_elevator_system_repeat_calls(): commands = [\\"CALL 2\\", \\"CALL 2\\", \\"DESTINATION 2\\", \\"CALL 3\\", \\"CALL 1\\", \\"DESTINATION 4\\", \\"DESTINATION 4\\"] assert elevator_system(commands) == [0, 1, 2, 3, 4]","solution":"def elevator_system(commands): Simulates an elevator system in a building. Parameters: commands (List[str]): A list of commands in the format specified (i.e., \\"CALL <floor_number>\\" or \\"DESTINATION <floor_number>\\"). Returns: List[int]: The sequence of floors that the elevator travels through. current_floor = 0 floors_visited = [current_floor] call_queue = [] destination_queue = [] for command in commands: cmd, floor = command.split() floor = int(floor) if cmd == \\"CALL\\": if floor not in call_queue and floor not in destination_queue: call_queue.append(floor) elif cmd == \\"DESTINATION\\": if floor not in destination_queue: destination_queue.append(floor) all_floors = sorted(set(call_queue + destination_queue)) for floor in all_floors: if floor not in floors_visited: floors_visited.append(floor) return floors_visited"},{"question":"def group_by_roots(paths: List[str]) -> Dict[str, List[str]]: Group folder paths by root directories. Args: paths (List[str]): List of folder paths. Returns: Dict[str, List[str]]: Dictionary grouping paths by their root directories. Examples: >>> paths = [ >>> \\"root/dir1/subdir1/file1.txt\\", >>> \\"root/dir1/subdir2/file2.txt\\", >>> \\"root/dir2/file3.txt\\", >>> \\"root/dir2/file4.txt\\", >>> \\"root2/file5.txt\\" >>> ] >>> group_by_roots(paths) { \\"root\\": [ \\"root/dir1/subdir1/file1.txt\\", \\"root/dir1/subdir2/file2.txt\\", \\"root/dir2/file3.txt\\", \\"root/dir2/file4.txt\\" ], \\"root2\\": [\\"root2/file5.txt\\"] } >>> paths = [ >>> \\"a/b/c/d/e.txt\\", >>> \\"a/b/f/g.txt\\", >>> \\"a/h.txt\\", >>> \\"b/i/j.txt\\", >>> \\"c/k.txt\\" >>> ] >>> group_by_roots(paths) { \\"a\\": [\\"a/b/c/d/e.txt\\", \\"a/b/f/g.txt\\", \\"a/h.txt\\"], \\"b\\": [\\"b/i/j.txt\\"], \\"c\\": [\\"c/k.txt\\"] }","solution":"def group_by_roots(paths): Group folder paths by root directories. Args: paths (List[str]): List of folder paths. Returns: Dict[str, List[str]]: Dictionary grouping paths by their root directories. root_dict = {} for path in paths: # Extract the root directory root = path.split('/')[0] if root not in root_dict: root_dict[root] = [] root_dict[root].append(path) return root_dict"},{"question":"def sum_even_numbers(lst): Recursively calculates the sum of all even numbers in the input list. >>> sum_even_numbers([1, 2, 3, 4, 5, 6]) == 12 >>> sum_even_numbers([1, 3, 5, 7]) == 0 >>> sum_even_numbers([]) == 0 >>> sum_even_numbers([2, 4, 6, 8]) == 20 >>> sum_even_numbers([-2, -3, -4, -5, -6]) == -12 >>> sum_even_numbers([2]) == 2 >>> sum_even_numbers([3]) == 0","solution":"def sum_even_numbers(lst): Recursively calculates the sum of all even numbers in the input list. if not lst: return 0 first, rest = lst[0], lst[1:] if first % 2 == 0: return first + sum_even_numbers(rest) else: return sum_even_numbers(rest) # Example usage input_list = [1, 2, 3, 4, 5, 6] sum_of_evens = sum_even_numbers(input_list)"},{"question":"def merge_unique_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists into a single list containing only unique elements, sorted in ascending order. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: A sorted list with unique elements from both input lists. >>> merge_unique_lists([1, 3, 5, 7], [2, 3, 5, 8, 9]) [1, 2, 3, 5, 7, 8, 9] >>> merge_unique_lists([1, 2, 2, 3], [3, 4, 4, 5]) [1, 2, 3, 4, 5]","solution":"def merge_unique_lists(list1, list2): Merges two lists into a single list containing only unique elements, sorted in ascending order. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: A sorted list with unique elements from both input lists. merged_set = set(list1).union(set(list2)) sorted_list = sorted(merged_set) return sorted_list"},{"question":"def highest_product_of_three(nums: List[int]) -> int: Returns the highest product of any three numbers in the list. Raises a ValueError if the list contains less than three integers. >>> highest_product_of_three([1, 2, 3, 4]) 24 >>> highest_product_of_three([-10, -10, 1, 3, 2]) 300 >>> highest_product_of_three([-1, -2, -3, -4]) -6 >>> highest_product_of_three([-10, 1, 3, 2, -10, 2, 5]) 500 >>> highest_product_of_three([1, 2]) Traceback (most recent call last): ... ValueError: List must contain at least three integers >>> highest_product_of_three([1, 10, 2]) 20 >>> highest_product_of_three([-1, -2, 3]) 6 >>> highest_product_of_three([0, 0, 3]) 0 >>> highest_product_of_three([-1, 0, 1]) 0 pass","solution":"def highest_product_of_three(nums): Returns the highest product of any three numbers in the list. Raises a ValueError if the list contains less than three integers. if len(nums) < 3: raise ValueError(\\"List must contain at least three integers\\") nums.sort() # The highest product of three numbers can be the product of: # 1. The three largest numbers # 2. The two smallest numbers (which can be negative) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into one sorted list. Raises TypeError if non-integer items are found in the input lists. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 3, 3, 5], [2, 2, 4, 6]) [1, 2, 2, 3, 3, 4, 5, 6] pass","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into one sorted list. Raises TypeError if non-integer items are found in the input lists. if not all(isinstance(x, int) for x in arr1): raise TypeError(\\"arr1 contains non-integer items\\") if not all(isinstance(x, int) for x in arr2): raise TypeError(\\"arr2 contains non-integer items\\") i, j = 0, 0 merged_list = [] while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_list.append(arr1[i]) i += 1 else: merged_list.append(arr2[j]) j += 1 while i < len(arr1): merged_list.append(arr1[i]) i += 1 while j < len(arr2): merged_list.append(arr2[j]) j += 1 return merged_list"},{"question":"def find_intersection_and_sort(array1, array2): Create a function that finds the intersection of two arrays and returns a new array containing the intersecting elements, sorted in ascending order. Do not use any built-in sorting functions. Implement your own sorting algorithm for this purpose. Args: array1 (List[int]): First input array. array2 (List[int]): Second input array. Returns: List[int]: Sorted array containing the intersecting elements of array1 and array2. Example: >>> find_intersection_and_sort([4, 9, 5, 3, 7], [9, 4, 9, 8, 3, 4]) [3, 4, 9] >>> find_intersection_and_sort([1, 2, 3], [4, 5, 6]) [] pass","solution":"def find_intersection_and_sort(array1, array2): Returns a sorted array containing the intersecting elements of array1 and array2. def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) # Find the intersection of the two arrays intersection = list(set(array1) & set(array2)) # Sort the intersection using the custom quicksort function return quicksort(intersection) # Example usage: # array1 = [4, 9, 5, 3, 7] # array2 = [9, 4, 9, 8, 3, 4] # print(find_intersection_and_sort(array1, array2)) # Output: [3, 4, 9]"},{"question":"def generate_fibonacci(n): Generates a list of Fibonacci numbers up to the given count n. >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(2) [0, 1]","solution":"def generate_fibonacci(n): Generates a list of Fibonacci numbers up to the given count n. if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_series = [0, 1] for i in range(2, n): next_value = fib_series[-1] + fib_series[-2] fib_series.append(next_value) return fib_series # Usage: # print(generate_fibonacci(10)) # Expected output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # print(generate_fibonacci(0)) # Expected output: [] # print(generate_fibonacci(1)) # Expected output: [0] # print(generate_fibonacci(2)) # Expected output: [0, 1]"},{"question":"def check_hello(s: str) -> bool: Determine whether 'hello' exists within the given string, case-insensitive. Parameters: s (str): Input string to be checked. Returns: bool: True if 'hello' is found within the string, False otherwise. >>> check_hello('This is a hello world') == True >>> check_hello('Hello world') == True >>> check_hello('I am saying hello') == True >>> check_hello('HeLLo World') == True >>> check_hello('This is just a test string') == False >>> check_hello('') == False","solution":"def check_hello(s): Determine whether 'hello' exists within the given string, case-insensitive. Parameters: s (str): Input string to be checked. Returns: bool: True if 'hello' is found within the string, False otherwise. # Convert the string to lower case and check for the substring 'hello' return 'hello' in s.lower()"},{"question":"def transform_string(s: str) -> str: Transforms a string by replacing each letter with the next letter in the alphabet (wrapping 'z' to 'a') and each digit with the next digit (wrapping '9' to '0'). >>> transform_string('abcdefghijklmnopqrstuvwxyz') 'bcdefghijklmnopqrstuvwxyza' >>> transform_string('0123456789') '1234567890' >>> transform_string('abc123xyz') 'bcd234yza' >>> transform_string('hello world! 123') 'ifmmp xpsme! 234' >>> transform_string('') '' >>> transform_string('z9') 'a0'","solution":"def transform_string(s): Transforms a string by replacing each letter with the next letter in the alphabet (wrapping 'z' to 'a') and each digit with the next digit (wrapping '9' to '0'). transformed = [] for char in s: if char.isalpha(): if char == 'z': transformed.append('a') else: transformed.append(chr(ord(char) + 1)) elif char.isdigit(): if char == '9': transformed.append('0') else: transformed.append(chr(ord(char) + 1)) else: # For non-alphanumeric characters, keep the same character transformed.append(char) return ''.join(transformed)"},{"question":"def filter_items_by_quantity(input_dict): Returns a dictionary with items that have a quantity greater than 5. Parameters: input_dict (dict): A dictionary where the keys are strings representing items and the values are integers representing the quantities of those items. Returns: dict: A dictionary with items that have a quantity greater than 5. Example: >>> input_data = { ... \\"apples\\": 10, ... \\"bananas\\": 4, ... \\"oranges\\": 7, ... \\"pears\\": 2 ... } >>> filter_items_by_quantity(input_data) {'apples': 10, 'oranges': 7}","solution":"def filter_items_by_quantity(input_dict): Returns a dictionary with items that have a quantity greater than 5. Parameters: input_dict (dict): A dictionary where the keys are strings representing items and the values are integers representing the quantities of those items. Returns: dict: A dictionary with items that have a quantity greater than 5. return {key: value for key, value in input_dict.items() if value > 5}"},{"question":"def is_origin(moves: str) -> bool: Write a function that determines if the sequence of moves returns to the original starting position. 'U' for up, 'D' for down, 'L' for left, 'R' for right. The function should return True if the moves return to the origin, else return False. >>> is_origin(\\"UDLR\\") True >>> is_origin(\\"UUDD\\") True >>> is_origin(\\"LRLR\\") True >>> is_origin(\\"U\\") False >>> is_origin(\\"D\\") False >>> is_origin(\\"L\\") False >>> is_origin(\\"R\\") False >>> is_origin(\\"UUDDLLRR\\") True >>> is_origin(\\"UUDLLRR\\") False >>> is_origin(\\"\\") True","solution":"def is_origin(moves): Determines if the sequence of moves returns to the original starting position. 'U' for up, 'D' for down, 'L' for left, 'R' for right. Returns True if the moves return to the origin, False otherwise. # Initial position x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 # Check if returned to origin return x == 0 and y == 0"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence while maintaining the original spacing and punctuation. Args: sentence (str): The input sentence to be reversed. Returns: str: The sentence with words reversed but original punctuation and spacing preserved. >>> reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" >>> reverse_words(\\" Hello, world! \\") == \\" world! Hello, \\" >>> reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" >>> reverse_words(\\"This is a test. Do you agree?\\") == \\"agree? you Do test. a is This\\" >>> reverse_words(\\"Testing, indeed, properly.\\") == \\"properly. indeed, Testing,\\" >>> reverse_words(\\"Hello!\\") == \\"Hello!\\" >>> reverse_words(\\"A\\") == \\"A\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\" \\"","solution":"import re def reverse_words(sentence): Reverses the words in a given sentence while maintaining the original spacing and punctuation. Args: sentence (str): The input sentence to be reversed. Returns: str: The sentence with words reversed but original punctuation and spacing preserved. # Using regular expression to identify words and spaces words = re.findall(r'S+|s+', sentence) # Extracting only the words word_list = [word for word in words if word.strip()] # Reversing the list of words reversed_words = word_list[::-1] # Creating a mapping for original indexes of words and spaces word_index = 0 result = [] for item in words: if item.strip(): result.append(reversed_words[word_index]) word_index += 1 else: result.append(item) return ''.join(result)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Return all unique pairs of integers from the list that sum up to the target integer. Each pair (a, b) should be in non-descending order (a <= b). The set of pairs should be in lexicographical order and free of duplicates. Examples: >>> find_pairs([2, 4, 3, 5, 7, -1, 2, -3, 0, 2], 4) [(-3, 7), (-1, 5), (0, 4), (2, 2)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([1, 2, 2, 2, 3, 4], 5) [(1, 4), (2, 3)]","solution":"def find_pairs(nums, target): Return all unique pairs of integers from the list that sum up to the target integer. Each pair (a, b) should be in non-descending order (a <= b). The set of pairs should be in lexicographical order and free of duplicates. nums = sorted(nums) pairs = set() num_dict = {} for num in nums: complement = target - num if complement in num_dict: pair = tuple(sorted((num, complement))) pairs.add(pair) num_dict[num] = True return sorted(pairs)"},{"question":"class InsufficientFundsException(Exception): pass class AccountNotFoundException(Exception): pass class InvalidOperationException(Exception): pass class Account: A class to represent a bank account. Attributes: account_id (str): Unique identifier for the account. balance (float): Current balance of the account. transactions (list): Record of all transactions. def __init__(self, account_id): self.account_id = account_id self.balance = 0 self.transactions = [] def deposit(self, amount): Deposits an amount to the account balance. Args: amount (float): The amount to deposit. Returns: float: The updated account balance. Raises: InvalidOperationException: If amount is less than or equal to zero. pass def withdraw(self, amount): Withdraws an amount from the account balance. Args: amount (float): The amount to withdraw. Returns: float: The updated account balance. Raises: InvalidOperationException: If amount is less than or equal to zero. InsufficientFundsException: If the balance is insufficient for the withdrawal. pass def get_balance(self): Returns the current account balance. Returns: float: The current account balance. pass def get_summary(self): Provides a summary of the account including total deposits, withdrawals, and current balance. Returns: dict: A summary report with total deposits, total withdrawals, and current balance. pass class Bank: A class to represent a bank. Attributes: accounts (dict): A dictionary to store accounts using account ID as key. def __init__(self): self.accounts = {} def create_account(self, account_id): Creates a new account with the given account ID. Args: account_id (str): A unique identifier for the new account. Returns: Account: The newly created account. Raises: InvalidOperationException: If an account with the same ID already exists. pass def get_account(self, account_id): Retrieves an account by its ID. Args: account_id (str): The unique identifier of the account. Returns: Account: The account object with the given ID. Raises: AccountNotFoundException: If the account is not found. pass","solution":"class InsufficientFundsException(Exception): pass class AccountNotFoundException(Exception): pass class InvalidOperationException(Exception): pass class Account: def __init__(self, account_id): self.account_id = account_id self.balance = 0 self.transactions = [] def deposit(self, amount): if amount <= 0: raise InvalidOperationException(\\"Deposit amount must be positive\\") self.balance += amount self.transactions.append(('Deposit', amount)) return self.balance def withdraw(self, amount): if amount <= 0: raise InvalidOperationException(\\"Withdrawal amount must be positive\\") if amount > self.balance: raise InsufficientFundsException(\\"Insufficient funds for this withdrawal\\") self.balance -= amount self.transactions.append(('Withdrawal', amount)) return self.balance def get_balance(self): return self.balance def get_summary(self): deposits = sum(amount for action, amount in self.transactions if action == 'Deposit') withdrawals = sum(amount for action, amount in self.transactions if action == 'Withdrawal') return { 'total_deposits': deposits, 'total_withdrawals': withdrawals, 'current_balance': self.balance } class Bank: def __init__(self): self.accounts = {} def create_account(self, account_id): if account_id in self.accounts: raise InvalidOperationException(\\"Account already exists\\") self.accounts[account_id] = Account(account_id) return self.accounts[account_id] def get_account(self, account_id): if account_id not in self.accounts: raise AccountNotFoundException(\\"Account not found\\") return self.accounts[account_id]"},{"question":"def explain_bcnf_and_3nf(): Provides an explanation of Boyce-Codd Normal Form (BCNF) and its differences from the Third Normal Form (3NF). Also includes an example of a relational schema that is in 3NF but not in BCNF, and the steps to convert that schema to BCNF. >>> explanation = explain_bcnf_and_3nf() >>> \\"Boyce-Codd Normal Form (BCNF)\\" in explanation True >>> \\"Third Normal Form (3NF)\\" in explanation True >>> \\"Example of a relational schema that is in 3NF but not in BCNF:\\" in explanation True >>> \\"Steps to convert to BCNF:\\" in explanation True >>> \\"Consider the relation R\\" in explanation True >>> \\"A -> B\\" in explanation True >>> \\"B -> C\\" in explanation True >>> \\"Decompose the relation into:\\" in explanation True >>> \\"R1(A, B)\\" in explanation True >>> \\"R2(B, C)\\" in explanation True # Your implementation here","solution":"def explain_bcnf_and_3nf(): Provides an explanation of Boyce-Codd Normal Form (BCNF) and its differences from the Third Normal Form (3NF). Also includes an example of a relational schema that is in 3NF but not in BCNF, and the steps to convert that schema to BCNF. explanation = Boyce-Codd Normal Form (BCNF) is a stronger version of the Third Normal Form (3NF). It deals with certain types of anomalies that are not covered by 3NF. - **Third Normal Form (3NF):** A relation is in 3NF if it is in 2NF and no transitive dependency exists, meaning non-prime attributes are not dependent on other non-prime attributes. - **Boyce-Codd Normal Form (BCNF):** A relation is in BCNF if it is in 3NF and, for every functional dependency (X -> Y), X is a superkey. This removes the anomalies that can be present even in 3NF. **Example of a relational schema that is in 3NF but not in BCNF:** Consider the relation R (A, B, C) with the following functional dependencies: 1. A -> B 2. B -> C **Checking 3NF:** - The relation is in 2NF as every non-key attribute is fully functionally dependent on the primary key. - Attribute C is non-prime and B -> C, with B as prime attribute (B is not a candidate key here). Since no non-prime attribute depends on another non-prime attribute, the relation is in 3NF. **Checking BCNF:** - For A -> B, A is a candidate key (superkey). - For B -> C, B is not a superkey. Thus, the relation is not in BCNF. **Steps to convert to BCNF:** 1. Decompose the relation into: - R1(A, B) - R2(B, C) 2. Now both R1 and R2 are in BCNF: - In R1, A is the superkey for A -> B. - In R2, B is the superkey for B -> C. This eliminates the anomaly present in the original schema. return explanation"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Assumes both input arrays are sorted. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: A new sorted array containing all elements from arr1 and arr2. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-3, -2, -1], [-4, 0, 2]) [-4, -3, -2, -1, 0, 2] >>> merge_sorted_arrays([-5, -3, -1, 0], [1, 4, 5, 8]) [-5, -3, -1, 0, 1, 4, 5, 8] >>> merge_sorted_arrays([1, 1, 2, 2], [1, 3, 4]) [1, 1, 1, 2, 2, 3, 4] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Assumes both input arrays are sorted. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: A new sorted array containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 n, m = len(arr1), len(arr2) while i < n and j < m: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 while i < n: merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2 while j < m: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Given a list of integers, returns a new list containing only the elements that appear more than once in the original list, maintaining the order of their first appearance. >>> find_duplicates([4, 5, 6, 4, 7, 8, 6, 6, 9, 10, 4]) [4, 6] >>> find_duplicates([1, 2, 3, 4, 5]) []","solution":"def find_duplicates(nums): Given a list of integers, returns a new list containing only the elements that appear more than once in the original list, maintaining the order of their first appearance. seen = set() duplicates = set() result = [] for num in nums: if num in seen: duplicates.add(num) else: seen.add(num) for num in nums: if num in duplicates and num not in result: result.append(num) return result"},{"question":"def reverse_string_with_spaces(input_string: str) -> str: Returns a new string that is the reverse of the original string while maintaining the positions of all spaces. >>> reverse_string_with_spaces(\\"a b c d\\") == \\"d c b a\\" >>> reverse_string_with_spaces(\\"a b c\\") == \\"c b a\\" >>> reverse_string_with_spaces(\\"abcd\\") == \\"dcba\\" >>> reverse_string_with_spaces(\\" \\") == \\" \\" >>> reverse_string_with_spaces(\\"\\") == \\"\\" >>> reverse_string_with_spaces(\\" hello \\") == \\" olleh \\"","solution":"def reverse_string_with_spaces(input_string): Returns a new string that is the reverse of the original string while maintaining the positions of all spaces. # Extract the characters which are not spaces non_space_chars = [char for char in input_string if char != ' '] # Reverse the list of non-space characters non_space_chars.reverse() # Use an iterator to track position of non-space characters char_iter = iter(non_space_chars) # Construct the result keeping spaces in their original positions result = ''.join(next(char_iter) if char != ' ' else ' ' for char in input_string) return result"},{"question":"def double_alphanumeric_characters(s: str) -> str: Returns a new string where each alphanumeric character in the input string s is doubled. Non-alphanumeric characters are preserved as they are. >>> double_alphanumeric_characters(\\"hello\\") == \\"hheelllloo\\" >>> double_alphanumeric_characters(\\"hello world\\") == \\"hheelllloo wwoorrlldd\\" >>> double_alphanumeric_characters(\\"hello! 123\\") == \\"hheelllloo! 112233\\" >>> double_alphanumeric_characters(\\"\\") == \\"\\" >>> double_alphanumeric_characters(\\"!@#%^\\") == \\"!@#%^\\" >>> double_alphanumeric_characters(\\"PyThon3.8\\") == \\"PPyyTThhoonn33.88\\" pass","solution":"def double_alphanumeric_characters(s): Returns a new string where each alphanumeric character in the input string s is doubled. Non-alphanumeric characters are preserved as they are. return ''.join([ch * 2 if ch.isalnum() else ch for ch in s])"},{"question":"def generate_invoice(orders: list) -> list: Aggregates the total quantities for each unique item across all orders and sorts the items alphabetically by their names. The function returns the sorted list of items and their corresponding total quantities. Parameters: orders (list of dict): A list of dictionaries, where each dictionary represents a customer order. Each order dictionary contains items as keys and their quantities as values. Returns: list of tuple: A sorted list of tuples, each containing an item and its total quantity.","solution":"def generate_invoice(orders): Aggregates the total quantities for each unique item across all orders and sorts the items alphabetically by their names. The function returns the sorted list of items and their corresponding total quantities. Parameters: orders (list of dict): A list of dictionaries, where each dictionary represents a customer order. Each order dictionary contains items as keys and their quantities as values. Returns: list of tuple: A sorted list of tuples, each containing an item and its total quantity. from collections import defaultdict # Use a defaultdict to accumulate item quantities summary = defaultdict(int) for order in orders: for item, quantity in order.items(): summary[item] += quantity # Convert the summary dictionary to a sorted list of tuples invoice = sorted(summary.items()) return invoice"},{"question":"from typing import List def neighboring_diff(lst: List[int]) -> List[int]: Calculate the absolute differences between each pair of neighboring elements in the list. Args: lst (List[int]): List of integers. Returns: List[int]: List of absolute differences. Examples: >>> neighboring_diff([1, 3, 6, 10]) [2, 3, 4] >>> neighboring_diff([-1, -3, -6, -10]) [2, 3, 4] >>> neighboring_diff([1, -3, 6, -10]) [4, 9, 16] >>> neighboring_diff([5]) [] >>> neighboring_diff([]) [] >>> neighboring_diff([0, 0, 0]) [0, 0] >>> neighboring_diff([1000000000, -2000000000, 3000000000]) [3000000000, 5000000000]","solution":"from typing import List def neighboring_diff(lst: List[int]) -> List[int]: Calculate the absolute differences between each pair of neighboring elements in the list. Args: lst (List[int]): List of integers. Returns: List[int]: List of absolute differences. if not all(isinstance(i, int) for i in lst): raise ValueError(\\"All elements in the list must be integers.\\") if len(lst) < 2: return [] return [abs(lst[i] - lst[i + 1]) for i in range(len(lst) - 1)]"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the prime numbers from the original list. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([15, 17, 19, 23, 24, 28, 30, 31]) == [17, 19, 23, 31] >>> filter_primes([11, 13, 14, 15, 16, 17, 18]) == [11, 13, 17] pass def test_filter_primes_mixed_numbers(): assert filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] def test_filter_primes_no_primes(): assert filter_primes([4, 6, 8, 10, 15, 22]) == [] def test_filter_primes_all_primes(): assert filter_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] def test_filter_primes_with_negative(): assert filter_primes([-2, 0, 1, 2, 3, 4]) == [2, 3] def test_filter_primes_large_prime(): assert filter_primes([29, 15, 18, 23, 102]) == [29, 23]","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def sort_users(users_list: List[tuple]) -> List[tuple]: This function sorts a list of users by descending age, and by name alphabetically in case of a tie. It raises a ValueError if any entries are invalid (not a tuple or tuple with incorrect types). >>> sort_users([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 30)]) [('Alice', 30), ('Charlie', 30), ('Bob', 25)] >>> sort_users([(\\"Zoe\\", 25), (\\"Alice\\", 25), (\\"Charlie\\", 25)]) [('Alice', 25), ('Charlie', 25), ('Zoe', 25)] >>> sort_users([(\\"Alice\\", 30), (\\"Bob\\", \\"twenty\\"), (\\"Charlie\\", 30)]) Traceback (most recent call last): ... ValueError: Invalid entry found: ('Bob', 'twenty'). Each entry should be a tuple of (name, age) where name is a string and age is an integer. >>> sort_users([(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 30), (\\"David\\", 20)]) [('Alice', 30), ('Charlie', 30), ('Bob', 25), ('David', 20)] >>> sort_users([]) []","solution":"def sort_users(users_list): This function sorts a list of users by descending age, and by name alphabetically in case of a tie. It raises a ValueError if any entry is invalid. # Validate entries for entry in users_list: if not (isinstance(entry, tuple) and len(entry) == 2 and isinstance(entry[0], str) and isinstance(entry[1], int)): raise ValueError(f\\"Invalid entry found: {entry}. Each entry should be a tuple of (name, age) where name is a string and age is an integer.\\") # Sort users first by age in descending order, then by name in ascending order sorted_list = sorted(users_list, key=lambda x: (-x[1], x[0])) return sorted_list"},{"question":"def strings_to_length_dict(strings: List[str]) -> Dict[str, int]: Implement a function that takes a list of strings and returns a dictionary where the keys are the strings, and the values are the lengths of those strings. Ensure the function handles empty strings and duplicate strings correctly, with each string's length being accurately represented. >>> strings_to_length_dict([\\"hello\\"]) == {\\"hello\\": 5} >>> strings_to_length_dict([\\"hi\\", \\"world\\", \\"python\\"]) == {\\"hi\\": 2, \\"world\\": 5, \\"python\\": 6} >>> strings_to_length_dict([\\"\\", \\"test\\"]) == {\\"\\": 0, \\"test\\": 4} >>> strings_to_length_dict([\\"apple\\", \\"apple\\", \\"banana\\"]) == {\\"apple\\": 5, \\"banana\\": 6} >>> strings_to_length_dict([]) == {} >>> strings_to_length_dict([\\"\\", \\"\\", \\"\\"]) == {\\"\\": 0}","solution":"def strings_to_length_dict(strings): Returns a dictionary where the keys are the strings from the input list, and the values are the lengths of those strings. Parameters: strings (list): list of strings Returns: dict: dictionary with strings as keys and their lengths as values return {string: len(string) for string in strings}"},{"question":"from typing import List, Tuple def generate_combinations(items: List[str], n: int) -> List[Tuple[str]]: Generates all possible combinations of \`n\` items from the list \`items\`. Parameters: items (list): The list of items to combine. n (int): The number of items in each combination. Returns: list: A list of tuples, each containing a unique combination of \`n\` items from \`items\`. >>> generate_combinations(['apple', 'banana', 'cherry'], 2) [('apple', 'banana'), ('apple', 'cherry'), ('banana', 'cherry')] >>> generate_combinations(['apple', 'banana', 'cherry'], 3) [('apple', 'banana', 'cherry')] >>> generate_combinations(['apple', 'banana', 'cherry'], 1) [('apple',), ('banana',), ('cherry',)] >>> generate_combinations([], 1) [] >>> generate_combinations(['apple', 'banana'], 3) [] >>> generate_combinations(['apple', 'banana'], 0) [()] >>> generate_combinations(['apple', 'apple', 'banana'], 2) [('apple', 'apple'), ('apple', 'banana'), ('apple', 'banana')] >>> generate_combinations(['apple', 'banana'], -1) []","solution":"from itertools import combinations def generate_combinations(items, n): Generates all possible combinations of \`n\` items from the list \`items\`. Parameters: items (list): The list of items to combine. n (int): The number of items in each combination. Returns: list: A list of tuples, each containing a unique combination of \`n\` items from \`items\`. if n > len(items) or n < 0: return [] return sorted(combinations(sorted(items), n))"},{"question":"from typing import List def is_path_exist(grid: List[List[str]]) -> bool: Determine whether there is a path from the top-left corner to the bottom-right corner of a grid, moving only up, down, left, or right, without passing through any obstacles. >>> is_path_exist([['.','.','.','#'], ['#','.','#','.'], ['.','.','.','.'], ['#','#','.','.']]) True >>> is_path_exist([['.','#'], ['#','.']]) False >>> is_path_exist([['.']]) True >>> is_path_exist([['.','.','.','#'], ['#','.','#','.'], ['#','#','.','.'], ['.','.','#','.']]) False >>> is_path_exist([['.','.','.'], ['.','.','.'], ['.','.','.']]) True","solution":"from typing import List def is_path_exist(grid: List[List[str]]) -> bool: def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != '.': return False if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return True grid[x][y] = '#' # mark as visited # Explore all four directions: down, up, right, left if dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1): return True return False return dfs(0, 0)"},{"question":"import pandas as pd import matplotlib.pyplot as plt import numpy as np def plot_total_sales_with_error_bars(df): Using the pandas and matplotlib libraries, create a bar chart that shows the total sales revenue for each product category in a given dataset. The dataset contains a \\"category\\" column representing the category of the product and a \\"sales\\" column representing the sales revenue for each product. Additionally: 1. The chart should have an appropriate title and labels for the x-axis and y-axis. 2. The bars should be color-coded based on the categories, and a legend should be included to explain the color coding. 3. Annotations should be added to the top of each bar to display the exact total sales revenue for each category. 4. The categories should be sorted in descending order based on total sales revenue. 5. Extend the solution to include the standard deviation of the sales within each category as error bars on the bar chart. Parameters: df (pd.DataFrame): DataFrame containing 'category' and 'sales' columns.","solution":"import pandas as pd import matplotlib.pyplot as plt import numpy as np def plot_total_sales_with_error_bars(df): Plots a bar chart with total sales revenue for each product category. Includes error bars representing the standard deviation of sales within each category. Parameters: df (pd.DataFrame): DataFrame containing 'category' and 'sales' columns. # Group by category and calculate total sales and standard deviation summary = df.groupby('category').agg({'sales': ['sum', 'std']}) summary.columns = ['total_sales', 'std_dev'] summary = summary.sort_values(by='total_sales', ascending=False) categories = summary.index total_sales = summary['total_sales'] std_dev = summary['std_dev'] # Plotting fig, ax = plt.subplots() bars = ax.bar(categories, total_sales, yerr=std_dev, capsize=5) # Add title and labels ax.set_title('Total Sales Revenue by Category') ax.set_xlabel('Category') ax.set_ylabel('Total Sales Revenue') # Annotate bars with total sales values for bar in bars: height = bar.get_height() ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height), xytext=(0, 3), # 3 points vertical offset textcoords=\\"offset points\\", ha='center', va='bottom') # Add legend and show plot ax.legend([bars], ['Total Sales'], loc='best') plt.xticks(rotation=45) plt.show()"},{"question":"def reorder_array(arr: List[int]) -> None: Reorders the array such that all even numbers appear before all the odd numbers. The relative order among even and odd numbers should remain the same. This function modifies the array in-place. >>> arr = [4, 3, 2, 5, 7, 8] >>> reorder_array(arr) >>> arr [4, 2, 8, 3, 5, 7] >>> arr = [1, 11, 2, 8, 3] >>> reorder_array(arr) >>> arr [2, 8, 1, 11, 3] # Your code here # Example usage: arr = [4, 3, 2, 5, 7, 8] reorder_array(arr) print(arr) # Output: [4, 2, 8, 3, 5, 7] # Unit tests def test_reorder_all_even(): arr = [4, 2, 6, 8] reorder_array(arr) assert arr == [4, 2, 6, 8] def test_reorder_all_odd(): arr = [3, 7, 5, 9] reorder_array(arr) assert arr == [3, 7, 5, 9] def test_reorder_even_before_odd(): arr = [4, 3, 2, 5, 7, 8] reorder_array(arr) assert arr == [4, 2, 8, 3, 5, 7] def test_reorder_mixed_start_with_odd(): arr = [1, 11, 2, 8, 3] reorder_array(arr) assert arr == [2, 8, 1, 11, 3] def test_reorder_single_element(): arr = [1] reorder_array(arr) assert arr == [1] arr = [2] reorder_array(arr) assert arr == [2] def test_reorder_empty_array(): arr = [] reorder_array(arr) assert arr == []","solution":"def reorder_array(arr): Reorders the array such that all even numbers appear before all the odd numbers. The relative order among even and odd numbers should remain the same. This function modifies the array in-place. even_index = 0 for i in range(len(arr)): if arr[i] % 2 == 0: arr.insert(even_index, arr.pop(i)) even_index += 1 return arr"},{"question":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path into its canonical path. >>> simplify_path('/home//foo/') '/home/foo' >>> simplify_path('/a/./b/../../c/') '/c' >>> simplify_path('/../') '/' >>> simplify_path('/home//../bar') '/bar'","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path into its canonical path. parts = path.split('/') stack = [] for part in parts: if part == '..': if stack: stack.pop() elif part and part != '.': stack.append(part) return '/' + '/'.join(stack)"},{"question":"def shortest_unique_substring_length(s: str) -> int: Returns the length of the shortest substring containing at least one of each unique letter present in the given string s. >>> shortest_unique_substring_length(\\"aabcbcdbca\\") 4 >>> shortest_unique_substring_length(\\"aaab\\") 2 >>> shortest_unique_substring_length(\\"aba\\") 2 >>> shortest_unique_substring_length(\\"a\\") 1 >>> shortest_unique_substring_length(\\"abcdef\\") 6 >>> shortest_unique_substring_length(\\"abcabcabc\\") 3 >>> shortest_unique_substring_length(\\"aaaaa\\") 1 >>> shortest_unique_substring_length(\\"abcdefghij\\"*10) 10","solution":"def shortest_unique_substring_length(s: str) -> int: Returns the length of the shortest substring containing at least one of each unique letter present in the given string s. unique_chars = set(s) char_count = {} min_length = len(s) start = 0 for end, char in enumerate(s): # Add current char to the count dictionary char_count[char] = char_count.get(char, 0) + 1 # Shrink the window from the start when all unique characters are included while len(char_count) == len(unique_chars): min_length = min(min_length, end - start + 1) # Remove the start character from the count dictionary char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 return min_length"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluates a given Reverse Polish Notation (RPN) expression and returns the result. >>> evaluate_rpn(\\"3 4 +\\") 7 >>> evaluate_rpn(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_rpn(\\"3 4 *\\") 12 >>> evaluate_rpn(\\"8 4 /\\") 2 >>> evaluate_rpn(\\"5 9 + 2 * 6 /\\") 4 >>> evaluate_rpn(\\"-3 -4 +\\") -7 >>> evaluate_rpn(\\"-3 4 -\\") -7 >>> evaluate_rpn(\\"42\\") 42 >>> evaluate_rpn(\\"7 -3 /\\") -2","solution":"def evaluate_rpn(expression): Evaluates a given Reverse Polish Notation (RPN) expression and returns the result. tokens = expression.split() stack = [] for token in tokens: if token.isdigit() or (token.startswith('-') and token[1:].isdigit()): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Ensure integer division mimics Python 2's behavior of floor division for negative results stack.append(int(a / b)) return stack[0]"},{"question":"def generate_product_goals() -> list: Returns a list of product goals based on the given requirements. pass # Implement the logic here def generate_user_stories() -> list: Returns a list of user stories based on the given requirements. pass # Implement the logic here def generate_competitive_analysis() -> list: Returns a list of competitive analysis for different weather apps. pass # Implement the logic here def generate_requirement_pool() -> list: Returns a list of prioritized requirements. pass # Implement the logic here # Unit Tests def test_generate_product_goals(): expected = [ \\"Create a system to process real-time weather data from multiple global weather stations.\\", \\"Provide a graphical interface for data visualization and station selection.\\", \\"Ensure detailed reporting for various weather parameters.\\" ] assert generate_product_goals() == expected def test_generate_user_stories(): expected = [ \\"As a user, I want to select a weather station from a map so I can view its data.\\", \\"As a user, I want to see temperature graphs over time to analyze trends.\\", \\"As a user, I want to view humidity and wind speed data for better context.\\" ] assert generate_user_stories() == expected def test_generate_competitive_analysis(): expected = [ \\"WeatherBug: Offers real-time weather data and forecasts with map visualizations.\\", \\"AccuWeather: Provides detailed weather reports and interactive maps.\\", \\"Weather.com: Real-time updates and detailed weather parameters with a user-friendly interface.\\", \\"Dark Sky: Known for its hyperlocal weather reports and sleek user interface.\\", \\"Weather Underground: Combines personal weather stations data with powerful visualization features.\\" ] assert generate_competitive_analysis() == expected def test_generate_requirement_pool(): expected = [ (\\"Implement real-time data ingestion from multiple weather stations\\", \\"P0\\"), (\\"Develop a graphical user interface for station selection\\", \\"P0\\"), (\\"Create detailed reports for temperature, humidity, and wind speed\\", \\"P1\\"), (\\"Ensure smooth running and scalability of the system\\", \\"P2\\") ] assert generate_requirement_pool() == expected","solution":"def generate_product_goals(): Returns a list of product goals based on the given requirements. return [ \\"Create a system to process real-time weather data from multiple global weather stations.\\", \\"Provide a graphical interface for data visualization and station selection.\\", \\"Ensure detailed reporting for various weather parameters.\\" ] def generate_user_stories(): Returns a list of user stories based on the given requirements. return [ \\"As a user, I want to select a weather station from a map so I can view its data.\\", \\"As a user, I want to see temperature graphs over time to analyze trends.\\", \\"As a user, I want to view humidity and wind speed data for better context.\\" ] def generate_competitive_analysis(): Returns a list of competitive analysis for different weather apps. return [ \\"WeatherBug: Offers real-time weather data and forecasts with map visualizations.\\", \\"AccuWeather: Provides detailed weather reports and interactive maps.\\", \\"Weather.com: Real-time updates and detailed weather parameters with a user-friendly interface.\\", \\"Dark Sky: Known for its hyperlocal weather reports and sleek user interface.\\", \\"Weather Underground: Combines personal weather stations data with powerful visualization features.\\", ] def generate_requirement_pool(): Returns a list of prioritized requirements. return [ (\\"Implement real-time data ingestion from multiple weather stations\\", \\"P0\\"), (\\"Develop a graphical user interface for station selection\\", \\"P0\\"), (\\"Create detailed reports for temperature, humidity, and wind speed\\", \\"P1\\"), (\\"Ensure smooth running and scalability of the system\\", \\"P2\\"), ]"},{"question":"def common_chars(str1: str, str2: str) -> str: Write a function that takes two strings as input and returns a new string that contains only the characters that appear in both strings, sorted in alphabetical order. Ensure that the function is case-insensitive, but the returned string should be in lower case. >>> common_chars('abc', 'bcd') 'bc' >>> common_chars('AbC', 'BcD') 'bc' >>> common_chars('abc', 'xyz') '' >>> common_chars('abc', 'cba') 'abc' >>> common_chars('aaabbbccc', 'ccbbaa') 'abc' >>> common_chars('aaAAabBBccc', 'CBBbaaAA') 'abc'","solution":"def common_chars(str1, str2): Returns a new string containing only the characters that appear in both input strings, sorted in alphabetical order. The function is case-insensitive, and the returned string is in lower case. # Convert both strings to lower case str1 = str1.lower() str2 = str2.lower() # Get the intersection of both sets of characters common_set = set(str1) & set(str2) # Convert the set to a sorted list and then join into a string return ''.join(sorted(common_set))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def replace_value(head, target, new_val): Replace all occurrences of 'target' value in the linked list with 'new_val'. The function should traverse the linked list only once. Parameters: head (ListNode): The head node of the linked list. target (int): The value to be replaced. new_val (int): The value to replace the target with. Returns: ListNode: The head of the modified linked list. Example: >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(2) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> result = replace_value(node1, 2, 3) >>> while result: print(result.val, end=\\" -> \\") result = result.next Output: 1 -> 3 -> 3 -> 4 ->","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def replace_value(head, target, new_val): Replace all occurrences of 'target' value in the linked list with 'new_val'. The function should traverse the linked list only once. Parameters: head (ListNode): The head node of the linked list. target (int): The value to be replaced. new_val (int): The value to replace the target with. Returns: ListNode: The head of the modified linked list. Example: >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(2) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> result = replace_value(node1, 2, 3) >>> while result: print(result.val, end=\\" -> \\") result = result.next Output: 1 -> 3 -> 3 -> 4 -> current = head while current is not None: if current.val == target: current.val = new_val current = current.next return head"},{"question":"def three_sum_triplet_exists(nums: List[int], target: int) -> bool: Returns True if there are three distinct elements in the array that add up to the target sum. Otherwise, returns False. >>> three_sum_triplet_exists([1, 2, 3, 4, 5], 9) True >>> three_sum_triplet_exists([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum_triplet_exists([1, 2, 4, 5, 6], 50) False >>> three_sum_triplet_exists([1, 2, 3], 10) False >>> three_sum_triplet_exists([1, 2, -3, 4, -2], 0) True >>> three_sum_triplet_exists([-5, -4, -3, -2, -1, 0], -10) True >>> three_sum_triplet_exists([1], 10) False >>> three_sum_triplet_exists([1, 2], 3) False >>> three_sum_triplet_exists([1, 1, 1, 1, 1], 3) True >>> three_sum_triplet_exists([1, 1, 1, 1, 1], 5) False","solution":"def three_sum_triplet_exists(nums, target): Returns True if there are three distinct elements in the array that add up to the target sum. Otherwise, returns False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def sort_negatives_first(nums): Sorts a list such that all negative numbers come before positive numbers while maintaining their relative order. Args: nums: List of integers Returns: None: The list is modified in place. def is_sorted_negatives_first(nums): Helper function to verify if the list is sorted such that all negative numbers come before positive numbers while preserving their relative order. Args: nums: List of integers Returns: bool: True if the list is sorted as required, False otherwise. from solution import sort_negatives_first, is_sorted_negatives_first def test_sort_negatives_first(): nums = [3, -2, -5, 7, 9, -1, 4] sort_negatives_first(nums) assert nums == [-2, -5, -1, 3, 7, 9, 4] def test_sort_negatives_first_empty(): nums = [] sort_negatives_first(nums) assert nums == [] def test_sort_negatives_first_all_positive(): nums = [3, 7, 9, 4] sort_negatives_first(nums) assert nums == [3, 7, 9, 4] def test_sort_negatives_first_all_negative(): nums = [-3, -2, -9, -4] sort_negatives_first(nums) assert nums == [-3, -2, -9, -4] def test_is_sorted_negatives_first(): nums = [-2, -5, -1, 3, 7, 9, 4] assert is_sorted_negatives_first(nums) == True def test_is_sorted_negatives_first_not_sorted(): nums = [3, -5, 7, -2, 9, -1, 4] assert is_sorted_negatives_first(nums) == False def test_is_sorted_negatives_first_empty(): nums = [] assert is_sorted_negatives_first(nums) == True def test_is_sorted_negatives_first_all_positive(): nums = [3, 7, 9, 4] assert is_sorted_negatives_first(nums) == True def test_is_sorted_negatives_first_all_negative(): nums = [-3, -2, -9, -4] assert is_sorted_negatives_first(nums) == True","solution":"def sort_negatives_first(nums): Sorts a list such that all negative numbers come before positive numbers while maintaining their relative order. Args: nums: List of integers Returns: None: The list is modified in place. if not nums: return # Stable partition in-place using O(1) extra space n = len(nums) i = 0 # Start from the beginning for j in range(n): if nums[j] < 0: nums.insert(i, nums.pop(j)) i += 1 def is_sorted_negatives_first(nums): Helper function to verify if the list is sorted such that all negative numbers come before positive numbers while preserving their relative order. Args: nums: List of integers Returns: bool: True if the list is sorted as required, False otherwise. found_positive = False for num in nums: if num >= 0: found_positive = True elif found_positive: return False return True"},{"question":"def interval_contains_value(intervals, value): Determines whether the value falls within any of the given intervals. Parameters: intervals (list of tuples): List of integer intervals represented as tuples (start, end). value (int): The integer value to be checked. Returns: tuple or None: The interval that contains the value if found, otherwise None. >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 3) == (1, 5) >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 12) == (10, 15) >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 22) == (20, 25) >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 6) == None >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 5) == (1, 5) >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 10) == (10, 15) >>> interval_contains_value([(1, 5), (10, 15), (20, 25)], 25) == (20, 25) >>> interval_contains_value([], 3) == None","solution":"def interval_contains_value(intervals, value): Determines whether the value falls within any of the given intervals. Parameters: intervals (list of tuples): List of integer intervals represented as tuples (start, end). value (int): The integer value to be checked. Returns: tuple or None: The interval that contains the value if found, otherwise None. for interval in intervals: if interval[0] <= value <= interval[1]: return interval return None"},{"question":"def filter_and_increase_even_numbers(numbers): Takes a list of integers and returns a new list containing only the even numbers from the original list, each increased by 5. >>> filter_and_increase_even_numbers([1, 2, 3, 4, 5, 6]) [7, 9, 11] >>> filter_and_increase_even_numbers([1, 3, 5, 7]) [] >>> filter_and_increase_even_numbers([2, 4, 6, 8]) [7, 9, 11, 13] >>> filter_and_increase_even_numbers([]) [] >>> filter_and_increase_even_numbers([-2, -4, -6]) [3, 1, -1]","solution":"def filter_and_increase_even_numbers(numbers): Takes a list of integers and returns a new list containing only the even numbers from the original list, each increased by 5. return [num + 5 for num in numbers if num % 2 == 0]"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. If the list is empty, return 0. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([0, 0, 0, 0]) == 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray within the given list. If the list is empty, return 0. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def matrix_multiplication(matrix1, matrix2): Performs matrix multiplication on two given matrices. Arguments: matrix1 -- A 2-dimensional list representing the first matrix. matrix2 -- A 2-dimensional list representing the second matrix. Returns: A 2-dimensional list representing the product of the two matrices. Examples: >>> matrix_multiplication([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiplication([[2, -1], [0, 1]], [[3, 4], [-2, 5]]) [[8, 3], [-2, 5]]","solution":"def matrix_multiplication(matrix1, matrix2): Performs matrix multiplication on two given matrices. Arguments: matrix1 -- A 2-dimensional list representing the first matrix. matrix2 -- A 2-dimensional list representing the second matrix. Returns: A 2-dimensional list representing the product of the two matrices. rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) cols_matrix2 = len(matrix2[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"def evaluate_expression(expression: str) -> int: Parses and evaluates a simple mathematical expression given as a string. Supports integer numbers, addition (+), and multiplication (*), with proper handling of operator precedence and parentheses. >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"((2+3)*(4+1))\\") 25 >>> evaluate_expression(\\"2*(3+5) + 3*(4+1)\\") 31 >>> evaluate_expression(\\" 2 * ( 3 + 5 ) + 3 * ( 4 + 1 ) \\") 31","solution":"def evaluate_expression(expression): Parses and evaluates a simple mathematical expression given as a string. Supports integer numbers, addition (+), and multiplication (*), with proper handling of operator precedence and parentheses. def parse_expr(tokens): def parse_term(tokens): token = tokens.pop(0) if token == '(': expr_value = parse_expr(tokens) tokens.pop(0) # Remove closing parenthesis return expr_value else: return int(token) def parse_factor(tokens): term_value = parse_term(tokens) while tokens and tokens[0] == '*': tokens.pop(0) term_value *= parse_term(tokens) return term_value expr_value = parse_factor(tokens) while tokens and tokens[0] == '+': tokens.pop(0) expr_value += parse_factor(tokens) return expr_value tokens = [] i = 0 while i < len(expression): if expression[i] in '0123456789': j = i while j < len(expression) and expression[j] in '0123456789': j += 1 tokens.append(expression[i:j]) i = j elif expression[i] in '+*()': tokens.append(expression[i]) i += 1 else: i += 1 # Ignore whitespace return parse_expr(tokens)"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([1, 4, 6, 8, 10]) [] >>> filter_primes([1, 2, 3, 4, 5, 6, 7]) [2, 3, 5, 7] >>> filter_primes([]) [] >>> filter_primes([2, 3, 'a', 5]) Traceback (most recent call last): ... ValueError: All elements in the input list must be integers","solution":"def is_prime(num): Helper function to check if a number is prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. Parameters: numbers (list): A list of integers. Returns: list: A list containing only the prime numbers from the input list. if not all(isinstance(n, int) for n in numbers): raise ValueError(\\"All elements in the input list must be integers\\") return [num for num in numbers if is_prime(num)]"},{"question":"def unique_pairs(n: int) -> List[Tuple[int, int]]: Write a function that takes an integer \`n\` and returns a list of all unique pairs \`(a, b)\` such that \`1 <= a < b <= n\` and \`a * b\` is even. The returned list should be sorted in ascending order based on the first element \`a\`. Use only basic programming constructs and avoid using pre-built sorting functions.","solution":"def unique_pairs(n): Returns a list of all unique pairs (a, b) such that 1 <= a < b <= n and a * b is even. The list is sorted in ascending order based on the first element \`a\`. pairs = [] for a in range(1, n): for b in range(a + 1, n + 1): if (a * b) % 2 == 0: pairs.append((a, b)) return pairs"},{"question":"def find_misspelled_words(correct_words: List[str], text: str) -> List[str]: Implement a function that mimics the behavior of a basic spell checker. The function will receive a list of correct words and a string containing a paragraph of text. It should output a list of words from the paragraph that are misspelled. Assume that the input text contains only alphabetic characters and spaces, and words are separated by a single space. Case sensitivity should be ignored (i.e., assume all inputs are in lowercase). >>> find_misspelled_words([\\"this\\", \\"is\\", \\"a\\", \\"test\\"], \\"this is a test\\") [] >>> find_misspelled_words([\\"correct\\", \\"spelling\\", \\"list\\", \\"of\\", \\"words\\"], \\"this is a test\\") [\\"this\\", \\"is\\", \\"a\\", \\"test\\"] >>> find_misspelled_words([\\"this\\", \\"is\\", \\"a\\", \\"correct\\", \\"test\\"], \\"this is a spell checker test\\") [\\"spell\\", \\"checker\\"] >>> find_misspelled_words([\\"this\\", \\"is\\", \\"a\\", \\"test\\"], \\"\\") [] >>> find_misspelled_words([], \\"this is a test\\") [\\"this\\", \\"is\\", \\"a\\", \\"test\\"] >>> find_misspelled_words([\\"THIS\\", \\"IS\\", \\"A\\", \\"TEST\\"], \\"this is a test\\") [\\"this\\", \\"is\\", \\"a\\", \\"test\\"]","solution":"from typing import List def find_misspelled_words(correct_words: List[str], text: str) -> List[str]: # Convert the list of correct words to a set for O(1) average time complexity lookups correct_set = set(correct_words) # Split the text into individual words words = text.split() # Check each word in the text against the set of correct words misspelled_words = [word for word in words if word not in correct_set] return misspelled_words"},{"question":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Returns the sum of the elements on the main and secondary diagonals of a square matrix. Args: matrix (List[List[int]]): A square matrix represented as a list of lists. Returns: int: The sum of the elements on the main and secondary diagonals of the matrix. Example: >>> matrix_diagonal_sum([[5]]) 10 >>> matrix_diagonal_sum([[1, 2], [3, 4]]) 10 >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 30 pass def test_matrix_diagonal_sum_1x1(): matrix = [[5]] assert matrix_diagonal_sum(matrix) == 10 def test_matrix_diagonal_sum_2x2(): matrix = [ [1, 2], [3, 4] ] assert matrix_diagonal_sum(matrix) == 10 def test_matrix_diagonal_sum_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert matrix_diagonal_sum(matrix) == 30 def test_matrix_diagonal_sum_unsquared(): matrix = [ [1, 2], [3, 4], [5, 6] ] try: matrix_diagonal_sum(matrix) except IndexError: assert True # An error is expected since it is not a square matrix def test_matrix_diagonal_sum_large(): import numpy as np np.random.seed(0) matrix = np.random.randint(0, 100, size=(1000, 1000)).tolist() main_diagonal_sum = sum(matrix[i][i] for i in range(1000)) secondary_diagonal_sum = sum(matrix[i][1000-1-i] for i in range(1000)) expected_sum = main_diagonal_sum + secondary_diagonal_sum assert matrix_diagonal_sum(matrix) == expected_sum","solution":"def matrix_diagonal_sum(matrix): Returns the sum of the elements on the main and secondary diagonals of a square matrix. n = len(matrix) main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return main_diagonal_sum + secondary_diagonal_sum"},{"question":"def compute_sequence(n): Given a number n, computes the nth value in a sequence where each element is the sum of its immediate predecessor (n-1) and the double of the predecessor before that (n-2). Ensure the function handles edge cases and does not exceed a recursion depth of 1000. >>> compute_sequence(1) 1 >>> compute_sequence(2) 2 >>> compute_sequence(3) 4 >>> compute_sequence(4) 8 >>> compute_sequence(5) 16","solution":"def compute_sequence(n): Given a number n, this function computes the nth value in a sequence where each element is the sum of its immediate predecessor (n-1) and the double of the predecessor before that (n-2). # Base cases if n == 1: return 1 if n == 2: return 2 # Recurrence relation of the sequence: seq(n) = seq(n-1) + 2 * seq(n-2) return compute_sequence(n-1) + 2 * compute_sequence(n-2)"},{"question":"def is_subsequence(s: str, t: str) -> bool: Check if string \`s\` is a subsequence of string \`t\`. A subsequence means all characters of \`s\` appear in \`t\` in the same order, but not necessarily consecutively. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"\\", \\"ahbgdc\\") True >>> is_subsequence(\\"ahbgdc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"abcdef\\", \\"abc\\") False >>> is_subsequence(\\"abc\\", \\"\\") False >>> is_subsequence(\\"\\", \\"\\") True >>> is_subsequence(\\"a\\", \\"a\\") True >>> is_subsequence(\\"a\\", \\"b\\") False >>> is_subsequence(\\"a\\", \\"ba\\") True","solution":"def is_subsequence(s: str, t: str) -> bool: Check if string \`s\` is a subsequence of string \`t\`. A subsequence means all characters of \`s\` appear in \`t\` in the same order, but not necessarily consecutively. :param s: The string to check if it is a subsequence. :param t: The string to check against. :return: True if \`s\` is a subsequence of \`t\`, otherwise False. t_iter = iter(t) return all(char in t_iter for char in s)"},{"question":"from typing import List def find_longest_string(strings: List[str]) -> str: Accepts a list of strings and returns the longest string. If there are multiple strings of the same maximum length, it returns the first one that appears in the list. Example: >>> find_longest_string([\\"apple\\", \\"banana\\", \\"peach\\"]) 'banana' >>> find_longest_string([\\"car\\", \\"train\\", \\"airplane\\"]) 'airplane' >>> find_longest_string([]) ''","solution":"from typing import List def find_longest_string(strings: List[str]) -> str: Accepts a list of strings and returns the longest string. If there are multiple strings of the same maximum length, it returns the first one that appears in the list. if not strings: return \\"\\" max_length = 0 longest_string = \\"\\" for string in strings: if len(string) > max_length: max_length = len(string) longest_string = string return longest_string"},{"question":"def find_longest_word(words: List[str]) -> str: Returns the longest word in the list of words. In case of a tie, returns the word that appears first. If the list is empty, returns an empty string. >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) \\"banana\\" >>> find_longest_word([\\"cat\\", \\"dog\\", \\"elephant\\", \\"bat\\"]) \\"elephant\\" >>> find_longest_word([]) \\"\\" >>> find_longest_word([\\"unique\\"]) \\"unique\\" >>> find_longest_word([\\"ant\\", \\"bat\\", \\"cat\\"]) \\"ant\\" >>> find_longest_word([\\"a\\", \\"apple\\", \\"bananaaaa\\", \\"cat\\", \\"bananaa\\"]) \\"bananaaaa\\"","solution":"def find_longest_word(words): Returns the longest word in the list of words. In case of a tie, returns the word that appears first. If the list is empty, returns an empty string. if not words: return \\"\\" longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression involving addition, subtraction, multiplication, and division, while considering the order of operations. Handles error checking for invalid characters, division by zero, and mismatched parentheses. >>> evaluate_expression(\\"3 + 5 × (2 − 8)\\") -13.0 >>> evaluate_expression(\\"8 ÷ 0\\") Traceback (most recent call last): ... ValueError: Invalid mathematical expression >>> evaluate_expression(\\"2 + a\\") Traceback (most recent call last): ... ValueError: Invalid mathematical expression >>> evaluate_expression(\\"3 + (5 × 2\\") Traceback (most recent call last): ... ValueError: Invalid mathematical expression","solution":"def evaluate_expression(expression): Evaluates a mathematical expression involving addition, subtraction, multiplication, and division, while considering the order of operations. try: # Replace the custom multiply and divide symbols with Python's operators expression = expression.replace('×', '*').replace('÷', '/') # Evaluate the expression safely using eval result = eval(expression) return float(result) except (SyntaxError, NameError, ZeroDivisionError): raise ValueError(\\"Invalid mathematical expression\\")"},{"question":"class CircularQueue: A circular queue implementation. Attributes: size (int): The size of the queue. queue (List[int]): List to store queue elements. front (int): Front index of the queue. rear (int): Rear index of the queue. Methods: is_empty() -> bool: Check if the queue is empty. is_full() -> bool: Check if the queue is full. enqueue(item: int) -> None: Add an item to the queue. dequeue() -> int: Remove and return an item from the queue. Example: >>> q = CircularQueue(3) >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) >>> str(q) 'CircularQueue: 1 -> 2 -> 3' >>> q.dequeue() 1 >>> str(q) 'CircularQueue: 2 -> 3' def __init__(self, size): self.size = size self.queue = [None] * size self.front = self.rear = -1 def is_empty(self): pass def is_full(self): pass def enqueue(self, item): pass def dequeue(self): pass def __str__(self): pass","solution":"class CircularQueue: def __init__(self, size): self.size = size self.queue = [None] * size self.front = self.rear = -1 def is_empty(self): return self.front == -1 def is_full(self): return (self.rear + 1) % self.size == self.front def enqueue(self, item): if self.is_full(): raise Exception(\\"Queue is full\\") if self.front == -1: # queue is empty self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = item def dequeue(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") item = self.queue[self.front] if self.front == self.rear: # queue has only one element self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return item def __str__(self): if self.is_empty(): return \\"CircularQueue is empty\\" items = [] i = self.front while True: items.append(self.queue[i]) if i == self.rear: break i = (i + 1) % self.size return \\"CircularQueue: \\" + ' -> '.join(map(str, items))"},{"question":"class BankAccount: def __init__(self, account_number: int, owner: str, initial_balance: float = 0.0): Initialize a BankAccount instance. :param account_number: Unique account number :param owner: Name of the account owner :param initial_balance: Initial balance of the account pass def deposit(self, amount: float): Deposit money into the account. :param amount: Amount to be deposited pass def withdraw(self, amount: float): Withdraw money from the account. :param amount: Amount to be withdrawn pass def transfer(self, to_account: 'BankAccount', amount: float): Transfer money to another account. :param to_account: The account to transfer money to :param amount: Amount to be transferred pass def get_balance(self) -> float: Get the balance of the account. :return: The current balance pass class Bank: def __init__(self): Initialize a Bank instance. pass def create_account(self, owner: str) -> BankAccount: Create a new bank account. :param owner: Name of the account owner :return: The created bank account pass def get_account(self, account_number: int) -> BankAccount: Retrieve an account by account number. :param account_number: The account number :return: The bank account pass import pytest def test_create_bank_account(): account = BankAccount(1, \\"Alice\\", 100.0) assert account.account_number == 1 assert account.owner == \\"Alice\\" assert account.get_balance() == 100.0 def test_deposit(): account = BankAccount(1, \\"Alice\\") account.deposit(50) assert account.get_balance() == 50 with pytest.raises(ValueError): account.deposit(-50) def test_withdraw(): account = BankAccount(1, \\"Alice\\", 100) account.withdraw(50) assert account.get_balance() == 50 with pytest.raises(ValueError): account.withdraw(200) with pytest.raises(ValueError): account.withdraw(-50) def test_transfer(): account1 = BankAccount(1, \\"Alice\\", 100) account2 = BankAccount(2, \\"Bob\\", 50) account1.transfer(account2, 50) assert account1.get_balance() == 50 assert account2.get_balance() == 100 with pytest.raises(ValueError): account1.transfer(account2, 100) def test_create_bank(): bank = Bank() assert len(bank.accounts) == 0 account = bank.create_account(\\"Alice\\") assert account.owner == \\"Alice\\" assert account.account_number == 1 assert len(bank.accounts) == 1 assert bank.get_account(1) == account with pytest.raises(ValueError): bank.get_account(99)","solution":"class BankAccount: def __init__(self, account_number: int, owner: str, initial_balance: float = 0.0): self.account_number = account_number self.owner = owner self.balance = initial_balance def deposit(self, amount: float): if amount > 0: self.balance += amount else: raise ValueError(\\"Deposit amount must be positive\\") def withdraw(self, amount: float): if amount > self.balance: raise ValueError(\\"Insufficient funds\\") elif amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") else: self.balance -= amount def transfer(self, to_account: 'BankAccount', amount: float): self.withdraw(amount) to_account.deposit(amount) def get_balance(self) -> float: return self.balance class Bank: def __init__(self): self.accounts = [] def create_account(self, owner: str) -> BankAccount: account_number = len(self.accounts) + 1 new_account = BankAccount(account_number, owner) self.accounts.append(new_account) return new_account def get_account(self, account_number: int) -> BankAccount: for account in self.accounts: if account.account_number == account_number: return account raise ValueError(\\"Account not found\\")"},{"question":"import string from collections import Counter from typing import List, Tuple def most_frequent_words(file_path: str, top_n: int) -> List[Tuple[str, int]]: Analyzes and finds the top N most frequent words in a given text file. Args: - file_path (str): The path to the text file. - top_n (int): The number of top frequent words to return. Returns: - List[Tuple[str, int]]: A list of tuples containing the most frequent words and their counts. >>> result = most_frequent_words(\\"sample_text.txt\\", 5) >>> assert result == [('the', 20), ('and', 18), ('to', 15), ('of', 12), ('a', 10)] pass # Unit tests import pytest def create_test_file(content, file_path='test_file.txt'): with open(file_path, 'w') as file: file.write(content) def test_most_frequent_words_single_occurrence(): content = \\"apple orange banana\\" create_test_file(content) result = most_frequent_words('test_file.txt', 3) expected = [('apple', 1), ('orange', 1), ('banana', 1)] assert result == expected def test_most_frequent_words_multiple_occurrences(): content = \\"apple orange banana apple orange apple\\" create_test_file(content) result = most_frequent_words('test_file.txt', 2) expected = [('apple', 3), ('orange', 2)] assert result == expected def test_most_frequent_words_with_punctuation(): content = \\"apple, orange! banana- apple; orange, apple.\\" create_test_file(content) result = most_frequent_words('test_file.txt', 2) expected = [('apple', 3), ('orange', 2)] assert result == expected def test_most_frequent_words_large_top_n(): content = \\"apple orange banana apple orange apple banana orange\\" create_test_file(content) result = most_frequent_words('test_file.txt', 10) expected = [('apple', 3), ('orange', 3), ('banana', 2)] assert result == expected def test_most_frequent_words_with_different_cases(): content = \\"Apple orange Banana apple Orange apple\\" create_test_file(content) result = most_frequent_words('test_file.txt', 2) expected = [('apple', 3), ('orange', 2)] assert result == expected def test_most_frequent_words_with_empty_file(): create_test_file('') result = most_frequent_words('test_file.txt', 3) expected = [] assert result == expected def test_most_frequent_words_with_special_characters(): content = \\"@apple #orange banana apple^ &orange* apple( orange)\\" create_test_file(content) result = most_frequent_words('test_file.txt', 2) expected = [('apple', 3), ('orange', 3)] assert result == expected def test_most_frequent_words_top_n_exceeds_unique_words(): content = \\"apple orange banana\\" create_test_file(content) result = most_frequent_words('test_file.txt', 5) expected = [('apple', 1), ('orange', 1), ('banana', 1)] assert result == expected","solution":"import string from collections import Counter def most_frequent_words(file_path, top_n): Analyzes and finds the top N most frequent words in a given text file. Args: - file_path (str): The path to the text file. - top_n (int): The number of top frequent words to return. Returns: - List[Tuple[str, int]]: A list of tuples containing the most frequent words and their counts. # Initialize a counter to keep track of word frequencies word_count = Counter() # Define translation table to remove punctuation translation_table = str.maketrans('', '', string.punctuation) with open(file_path, 'r', encoding='utf-8') as file: for line in file: # Remove punctuation and normalize to lower-case cleaned_line = line.translate(translation_table).lower() # Split line into words and update word count words = cleaned_line.split() word_count.update(words) # Return the top N most common words return word_count.most_common(top_n)"},{"question":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target_sum: int) -> List[Tuple[int, int]]: Finds all unique pairs in the list that sum up to the target sum. Each pair is returned in ascending order within the tuple and the result list maintains the order of first occurrence. >>> find_pairs_with_sum([2, 4, 3, 7, 1, 5, 2], 6) [(2, 4), (1, 5)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([2, 3, 4, 3, 2, 5, 1], 5) [(2, 3), (1, 4)] >>> find_pairs_with_sum([1], 2) [] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([1, 1, 1, 1, 1], 2) [(1, 1)]","solution":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs in the list that sum up to the target sum. Each pair is returned in ascending order and the result list maintains the order of first occurrence. seen = {} result = [] seen_pairs = set() for i in range(len(arr)): complement = target_sum - arr[i] if complement in seen: pair = tuple(sorted((arr[i], complement))) if pair not in seen_pairs: result.append(pair) seen_pairs.add(pair) seen[arr[i]] = i return result"},{"question":"def longest_mountain(arr: List[int]) -> int: Given a list of integers, returns the length of the longest mountain. A \\"mountain\\" subarray is defined as a subarray where elements increase to a peak and then decrease. The length of the mountain must be at least 3. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([1, 2, 3, 4, 5]) 0 >>> longest_mountain([0, 2, 0]) 3 >>> longest_mountain([2, 2, 2, 2, 2]) 0 >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 0, 6, 3, 2, 0, 8, 7, 1]) 5 >>> longest_mountain([2, 1]) 0 >>> longest_mountain([5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5]) 0 >>> longest_mountain([0, 1, 2, 3, 4]) 0 pass","solution":"def longest_mountain(arr): Returns the length of the longest mountain in the array. n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right + 1] < arr[right]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"from typing import List def find_peak_element(arr: List[int]) -> int: Finds the index of a peak element in the list. A peak element is defined as an element that is greater than its neighbors. Boundaries of the list count as negative infinity. :param arr: List of integers :return: Index of a peak element pass # Example usage: # >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) # 1 or 5 # >>> find_peak_element([1, 2, 3, 1]) # 2","solution":"from typing import List def find_peak_element(arr: List[int]) -> int: Finds the index of a peak element in the list. A peak element is defined as an element that is greater than its neighbors. Boundaries of the list count as negative infinity. :param arr: List of integers :return: Index of a peak element n = len(arr) def binary_search(low: int, high: int) -> int: if low == high: return low mid = (low + high) // 2 if arr[mid] > arr[mid + 1]: return binary_search(low, mid) else: return binary_search(mid + 1, high) return binary_search(0, n - 1)"},{"question":"def closest_three_sum(arr, target): Find three distinct elements in the array such that the sum of the three elements is closest to the target value. Return the sum of the three integers. You may assume that each input would have exactly one solution. >>> closest_three_sum([1, 2, -1, 4], 1) 2 >>> closest_three_sum([0, 0, 0], 1) 0 >>> closest_three_sum([-1, 2, 1, -4], 1) 2 >>> closest_three_sum([1, 1, 1, 0], 100) 3 >>> closest_three_sum([1, -1, -1, 0], -1) -1 >>> closest_three_sum([1, 2, 4, 8, 16, 32, 64, 128], 82) 82","solution":"def closest_three_sum(arr, target): arr.sort() closest_sum = float('inf') closest_diff = float('inf') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"def find_pair_with_sum(integers, target_sum): Finds the pair of integers in the array that add up to the target sum. Returns the pair as a tuple (a, b) such that a <= b. If no such pair exists, returns an empty tuple. >>> find_pair_with_sum([2, 7, 11, 15, 1, 8], 9) == (1, 8) >>> find_pair_with_sum([2, 7, 11, 5], 20) == () >>> find_pair_with_sum([1, 2, 3, 4, 5, 6], 7) == (1, 6) >>> find_pair_with_sum([-1, 1, 2, 3, -2], 1) == (-2, 3) >>> find_pair_with_sum([], 5) == () >>> find_pair_with_sum([5], 5) == ()","solution":"def find_pair_with_sum(integers, target_sum): Finds the pair of integers in the array that add up to the target sum. Returns the pair as a tuple (a, b) such that a <= b. If no such pair exists, returns an empty tuple. nums = {} result = [] # Traverse the list for num in integers: complement = target_sum - num # Check if the complement exists in the dictionary if complement in nums: result.append((min(num, complement), max(num, complement))) # Add the number to the dictionary nums[num] = True # Sort the result based on the conditions mentioned if result: result.sort() return result[0] else: return ()"},{"question":"from datetime import datetime from typing import List, Tuple def compute_overlap_minutes(appointments: List[Tuple[str, str]]) -> int: Returns the total time in minutes when all appointments overlap. :param appointments: List of tuples where each tuple is (start_time, end_time) with time in \\"HH:MM\\" 24-hour format. :return: Total overlapping time in minutes. pass def convert_to_minutes(t: str) -> int: Convert a time string in \\"HH:MM\\" format to minutes past midnight. :param t: Time string in \\"HH:MM\\" format :return: Equivalent minutes past midnight. pass def test_no_overlap(): appointments = [('09:00', '10:00'), ('11:00', '12:00'), ('13:00', '14:00')] assert compute_overlap_minutes(appointments) == 0 def test_full_overlap(): appointments = [('09:00', '12:00'), ('10:00', '11:00')] assert compute_overlap_minutes(appointments) == 60 def test_partial_overlap(): appointments = [('09:00', '12:30'), ('11:15', '14:00'), ('10:00', '11:45')] assert compute_overlap_minutes(appointments) == 30 def test_identical_times(): # Identical start and end times appointments = [('09:00', '10:00'), ('09:00', '10:00'), ('09:00', '10:00')] assert compute_overlap_minutes(appointments) == 60 def test_nested_appointments(): # One appointment entirely within another appointments = [('09:00', '12:00'), ('10:00', '11:00'), ('10:30', '11:30')] assert compute_overlap_minutes(appointments) == 30 def test_overlapping_at_end(): appointments = [('09:00', '10:30'), ('10:00', '11:00')] assert compute_overlap_minutes(appointments) == 30","solution":"from datetime import datetime def compute_overlap_minutes(appointments): Returns the total time in minutes when all appointments overlap. :param appointments: List of tuples where each tuple is (start_time, end_time) with time in \\"HH:MM\\" 24-hour format. :return: Total overlapping time in minutes. # Convert time intervals into minutes since start of the day intervals = [(convert_to_minutes(start), convert_to_minutes(end)) for start, end in appointments] # Find the latest start time and earliest end time max_start = max(start for start, end in intervals) min_end = min(end for start, end in intervals) # Calculate the overlapping time overlap = max(0, min_end - max_start) return overlap def convert_to_minutes(t): Convert a time string in \\"HH:MM\\" format to minutes past midnight. :param t: Time string in \\"HH:MM\\" format :return: Equivalent minutes past midnight. dt = datetime.strptime(t, \\"%H:%M\\") return dt.hour * 60 + dt.minute"},{"question":"def find_unique_numbers(arr, return_type='unique'): This function finds unique numbers in an array that are not repeated. If return_type is 'unique', it returns the set of unique numbers. If return_type is 'duplicates', it returns the set of duplicate numbers. :param arr: List of integers :param return_type: 'unique' or 'duplicates' :return: Set of integers >>> find_unique_numbers([4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1]) {2, 5, 6, 7, 9} >>> find_unique_numbers([4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1], 'unique') {2, 5, 6, 7, 9} >>> find_unique_numbers([4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1], 'duplicates') {8, 1, 4} >>> find_unique_numbers([4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1], 'invalid') ValueError: Invalid return_type. Must be 'unique' or 'duplicates'. # Implement the function here. def test_find_unique_numbers_default(): numbers = [4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1] assert find_unique_numbers(numbers) == {2, 5, 6, 7, 9} def test_find_unique_numbers_unique(): numbers = [4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1] assert find_unique_numbers(numbers, 'unique') == {2, 5, 6, 7, 9} def test_find_unique_numbers_duplicates(): numbers = [4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1] assert find_unique_numbers(numbers, 'duplicates') == {8, 1, 4} def test_find_unique_numbers_invalid_return_type(): numbers = [4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1] try: find_unique_numbers(numbers, 'invalid') assert False, \\"Expected ValueError\\" except ValueError: assert True","solution":"def find_unique_numbers(arr, return_type='unique'): This function finds unique numbers in the array that are not repeated. If return_type is 'unique', it returns the set of unique numbers. If return_type is 'duplicates', it returns the set of duplicate numbers. :param arr: List of integers :param return_type: 'unique' or 'duplicates' :return: Set of integers unique = set() duplicates = set() for num in arr: if num not in unique: unique.add(num) else: duplicates.add(num) if return_type == 'unique': return unique - duplicates elif return_type == 'duplicates': return duplicates else: raise ValueError(\\"Invalid return_type. Must be 'unique' or 'duplicates'.\\") numbers = [4, 5, 6, 7, 8, 8, 9, 4, 2, 1, 1] print(find_unique_numbers(numbers)) print(find_unique_numbers(numbers, 'duplicates'))"},{"question":"def factorial(n: int) -> int: Returns the factorial of the given non-negative integer n using recursion. >>> factorial(0) 1 >>> factorial(5) 120 >>> factorial(1) 1 >>> try: ... factorial(-5) ... except ValueError as e: ... str(e) == \\"Factorial is not defined for negative numbers.\\"","solution":"def factorial(n): Returns the factorial of the given non-negative integer n. if n < 0: raise ValueError(\\"Factorial is not defined for negative numbers.\\") if n == 0: return 1 else: return n * factorial(n - 1)"},{"question":"class User: def __init__(self, name: str): Initialize a user with a name and an empty list of friends. def add_friend(self, friend: 'User'): Add a friend to the user's friends list if not already added. def remove_friend(self, friend: 'User'): Remove a friend from the user's friends list if they exist. def get_friends_names(self) -> List[str]: Return a list of names of the user's friends. >>> john = User(\\"John\\") >>> doe = User(\\"Doe\\") >>> jane = User(\\"Jane\\") >>> john.add_friend(doe) >>> john.add_friend(jane) >>> john.get_friends_names() ['Doe', 'Jane'] >>> john.remove_friend(doe) >>> john.get_friends_names() ['Jane'] >>> john.remove_friend(doe) # Doe is not a friend >>> john.get_friends_names() ['Jane'] >>> jane = User(\\"Jane\\") >>> jane.get_friends_names() []","solution":"class User: def __init__(self, name): self.name = name self.friends = [] def add_friend(self, friend): if friend not in self.friends: self.friends.append(friend) def remove_friend(self, friend): if friend in self.friends: self.friends.remove(friend) def get_friends_names(self): return [friend.name for friend in self.friends]"},{"question":"def get_people_above_age(people: List[Dict[str, Any]], age_limit: int) -> List[str]: Returns a list of names of people who are above the given age limit. >>> people = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 25}, ... {\\"name\\": \\"Bob\\", \\"age\\": 20}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 30}, ... {\\"name\\": \\"Dave\\", \\"age\\": 22}, ... {\\"name\\": None, \\"age\\": 28}, # Invalid entry ... {\\"name\\": \\"Eve\\", \\"age\\": None}, # Invalid entry ... {\\"name\\": \\"Frank\\", \\"age\\": \\"twenty\\"}, # Invalid entry ... ] >>> get_people_above_age(people, 22) ['Alice', 'Charlie'] >>> get_people_above_age(people, 25) ['Charlie'] >>> get_people_above_age(people, 30) [] >>> get_people_above_age([], 22) [] result = [] for person in people: try: name = person.get('name') age = person.get('age') if name is None: raise ValueError(\\"Missing 'name' key for a person.\\") if age is None: raise ValueError(f\\"Missing 'age' key for person {name}.\\") if not isinstance(age, int): raise ValueError(f\\"Non-integer 'age' value for person {name}.\\") if age > age_limit: result.append(name) except ValueError as ve: print(f\\"Error: {ve}\\") return result","solution":"def get_people_above_age(people, age_limit): Returns a list of names of people who are above the given age_limit. result = [] for person in people: try: name = person.get('name') age = person.get('age') if name is None: raise ValueError(\\"Missing 'name' key for a person.\\") if age is None: raise ValueError(f\\"Missing 'age' key for person {name}.\\") if not isinstance(age, int): raise ValueError(f\\"Non-integer 'age' value for person {name}.\\") if age > age_limit: result.append(name) except ValueError as ve: print(f\\"Error: {ve}\\") return result"},{"question":"def roman_to_int(s: str) -> int: Converts a Roman numeral string to its integer equivalent. Example: >>> roman_to_int('XIV') 14 >>> roman_to_int('XXVII') 27 :param s: Roman numeral string :return: Integer equivalent","solution":"def roman_to_int(s): Converts a Roman numeral string to its integer equivalent. :param s: Roman numeral string :return: Integer equivalent roman_dict = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_dict[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def find_nested_key(nested_dict: dict, target_key: str): Finds the value associated with the target key in a nested dictionary. If the target key is not found, returns \\"Key not found\\". Args: nested_dict (dict): The nested dictionary to search. target_key (str): The key to find in the nested dictionary. Returns: The value associated with the target key, or \\"Key not found\\" if the key is not in the dictionary. >>> find_nested_key({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}, 'e') 3 >>> find_nested_key({'a': {'b': 4}, 'c': 5}, 'z') 'Key not found' >>> find_nested_key({'root_key': 42, 'nested': {'key': 'value'}}, 'root_key') 42 >>> find_nested_key({}, 'any_key') 'Key not found' >>> find_nested_key({'level1': {'level2': {'level3': {'level4': 'deep_value'}}}}, 'level4') 'deep_value'","solution":"def find_nested_key(nested_dict, target_key): Finds the value associated with the target key in a nested dictionary. If the target key is not found, returns \\"Key not found\\". Args: nested_dict (dict): The nested dictionary to search. target_key (str): The key to find in the nested dictionary. Returns: The value associated with the target key, or \\"Key not found\\" if the key is not in the dictionary. if target_key in nested_dict: return nested_dict[target_key] for key, value in nested_dict.items(): if isinstance(value, dict): result = find_nested_key(value, target_key) if result != \\"Key not found\\": return result return \\"Key not found\\""},{"question":"def group_strings_by_length(strings): Group strings by their length. Parameters: strings (list): A list of strings Returns: dict: A dictionary where keys are string lengths and values are lists of strings with that length pass # Unit tests def test_group_strings_by_length_empty_list(): assert group_strings_by_length([]) == {} def test_group_strings_by_length_single_length(): assert group_strings_by_length([\\"a\\", \\"b\\", \\"c\\"]) == {1: [\\"a\\", \\"b\\", \\"c\\"]} def test_group_strings_by_length_multiple_lengths(): assert group_strings_by_length([\\"a\\", \\"bc\\", \\"def\\", \\"g\\", \\"hi\\", \\"jkl\\"]) == { 1: [\\"a\\", \\"g\\"], 2: [\\"bc\\", \\"hi\\"], 3: [\\"def\\", \\"jkl\\"] } def test_group_strings_by_length_mixed_case(): assert group_strings_by_length([\\"a\\", \\"A\\", \\"bc\\", \\"BC\\"]) == { 1: [\\"a\\", \\"A\\"], 2: [\\"bc\\", \\"BC\\"] } def test_group_strings_by_length_with_empty_string(): assert group_strings_by_length([\\"\\", \\"a\\", \\"abc\\"]) == { 0: [\\"\\"], 1: [\\"a\\"], 3: [\\"abc\\"] } def test_group_strings_by_length_maintain_order(): assert group_strings_by_length([\\"abc\\", \\"def\\", \\"a\\", \\"g\\", \\"hi\\", \\"a\\"]) == { 3: [\\"abc\\", \\"def\\"], 1: [\\"a\\", \\"g\\", \\"a\\"], 2: [\\"hi\\"] }","solution":"def group_strings_by_length(strings): Groups strings by their length. Parameters: strings (list): A list of strings Returns: dict: A dictionary where keys are string lengths and values are lists of strings with that length lengths = {} for string in strings: length = len(string) if length not in lengths: lengths[length] = [] lengths[length].append(string) return lengths"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using memoization to improve efficiency. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(15) 610 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040","solution":"def fibonacci(n, memo=None): Returns the nth Fibonacci number using memoization to improve efficiency. if memo is None: memo = {} if n in memo: return memo[n] if n == 0: return 0 elif n == 1: return 1 memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n]"},{"question":"def filter_and_square_odd_numbers(numbers: List[int]) -> List[int]: Returns a list with the squares of the odd numbers from the input list. >>> filter_and_square_odd_numbers([1, 2, 3, 4, 5]) [1, 9, 25] >>> filter_and_square_odd_numbers([2, 4, 6, 8]) []","solution":"def filter_and_square_odd_numbers(numbers): Returns a list with the squares of the odd numbers from the input list. :param numbers: List of integers :return: List of squares of odd numbers return [n ** 2 for n in numbers if n % 2 != 0]"},{"question":"def unique_elements(arr): Returns a list containing only the first occurrence of unique integers, preserving their order. Parameters: arr (list): A list of integers. Returns: list: A list of unique integers in the order of their first occurrence. >>> unique_elements([1, 3, 3, 2, 1, 4, 5, 4, 2]) [1, 3, 2, 4, 5] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 1, 1, 1]) [1] >>> unique_elements([]) [] >>> unique_elements([99]) [99] >>> data = [i // 2 for i in range(20000)] >>> unique_elements(data) == list(range(10000)) True","solution":"def unique_elements(arr): Returns a list containing only the first occurrence of unique integers, preserving their order. Parameters: arr (list): A list of integers. Returns: list: A list of unique integers in the order of their first occurrence. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"from typing import List, Union def sort_list_or_report_duplicates(lst: List[int]) -> Union[List[int], str]: Accepts a list of integers and returns the list sorted in ascending order. If the list contains duplicate numbers, returns 'Duplicate numbers found'. :param lst: List of integers :return: Sorted list or string indicating duplicates >>> sort_list_or_report_duplicates([3, 1, 2]) [1, 2, 3] >>> sort_list_or_report_duplicates([1, 2, 2, 3]) 'Duplicate numbers found' >>> sort_list_or_report_duplicates([]) [] >>> sort_list_or_report_duplicates([1]) [1] >>> sort_list_or_report_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> sort_list_or_report_duplicates([0, -1, -2, 3, 2, 1]) [-2, -1, 0, 1, 2, 3] >>> sort_list_or_report_duplicates([0, -1, -1, -2, 3]) 'Duplicate numbers found'","solution":"def sort_list_or_report_duplicates(lst): Accepts a list of integers and returns the list sorted in ascending order. If the list contains duplicate numbers, returns \\"Duplicate numbers found\\". :param lst: List of integers :return: Sorted list or string indicating duplicates if len(lst) != len(set(lst)): return \\"Duplicate numbers found\\" return sorted(lst)"},{"question":"def largest_palindrome_product() -> int: Finds the largest palindrome made from the product of two 3-digit numbers. >>> largest_palindrome_product() == 906609","solution":"def largest_palindrome_product(): Finds the largest palindrome made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if product <= max_palindrome: break # Since j decreases, the products will not get larger if str(product) == str(product)[::-1]: # Check if the product is a palindrome max_palindrome = product return max_palindrome"},{"question":"def is_horizontally_symmetric(matrix: List[str]) -> bool: Checks if the given matrix is horizontally symmetric. Args: matrix (list of str): A list of strings representing rows of the matrix. Returns: bool: True if the matrix is horizontally symmetric, False otherwise. Example: >>> is_horizontally_symmetric([\\"abc\\", \\"def\\", \\"abc\\"]) True >>> is_horizontally_symmetric([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\", \\"abcd\\"]) False >>> is_horizontally_symmetric([\\"abcd\\", \\"wxyz\\", \\"zyxw\\", \\"dcba\\"]) True","solution":"def is_horizontally_symmetric(matrix): Checks if the given matrix is horizontally symmetric. Args: matrix (list of str): A list of strings representing rows of the matrix. Returns: bool: True if the matrix is horizontally symmetric, False otherwise. n = len(matrix) # Check each row with its corresponding symmetric row from the bottom for i in range(n // 2): if matrix[i] != matrix[n - 1 - i]: return False return True"},{"question":"def is_sum_of_consecutive_integers(n: int) -> bool: Determines whether the integer n can be expressed as the sum of two or more consecutive positive integers. >>> is_sum_of_consecutive_integers(15) True >>> is_sum_of_consecutive_integers(8) False def test_is_sum_of_consecutive_integers(): assert is_sum_of_consecutive_integers(15) == True assert is_sum_of_consecutive_integers(9) == True assert is_sum_of_consecutive_integers(10) == True assert is_sum_of_consecutive_integers(8) == False assert is_sum_of_consecutive_integers(16) == False assert is_sum_of_consecutive_integers(32) == False assert is_sum_of_consecutive_integers(10**9) == True assert is_sum_of_consecutive_integers(2) == False assert is_sum_of_consecutive_integers(3) == True assert is_sum_of_consecutive_integers(1) == False","solution":"def is_sum_of_consecutive_integers(n: int) -> bool: Determines whether the integer n can be expressed as the sum of two or more consecutive positive integers. A number can be expressed as the sum of two or more consecutive integers if and only if it is not a power of 2. # If n is a power of 2, it cannot be expressed as the sum of two or more consecutive positive integers. return (n & (n - 1)) != 0"},{"question":"def find_chapter(chapters: List[int], page: int) -> int: Returns the chapter number that starts on the given page number. :param chapters: List[int], representing the number of pages in each chapter :param page: int, the page number to be checked :return: int, the chapter number, or -1 if the page number is out of range >>> find_chapter([10, 15, 20, 25], 1) == 1 >>> find_chapter([10, 15, 20, 25], 30) == 3 >>> find_chapter([10, 15, 20, 25], 100) == -1","solution":"def find_chapter(chapters, page): Returns the chapter number that starts on the given page number. :param chapters: List[int], representing the number of pages in each chapter :param page: int, the page number to be checked :return: int, the chapter number, or -1 if the page number is out of range if page < 1: return -1 current_page = 1 for i, chapter_length in enumerate(chapters): if current_page <= page < current_page + chapter_length: return i + 1 current_page += chapter_length return -1"},{"question":"def is_valid_ipv4(ip: str) -> bool: Determine if a given string is a valid IPv4 address. >>> is_valid_ipv4(\\"192.168.1.1\\") True >>> is_valid_ipv4(\\"0.0.0.0\\") True >>> is_valid_ipv4(\\"255.255.255.255\\") True >>> is_valid_ipv4(\\"172.16.254.1\\") True >>> is_valid_ipv4(\\"256.256.256.256\\") False >>> is_valid_ipv4(\\"192.168.1\\") False >>> is_valid_ipv4(\\"192.168.1.1.1\\") False >>> is_valid_ipv4(\\"192.168.01.1\\") False >>> is_valid_ipv4(\\"192.168.1.a\\") False >>> is_valid_ipv4(\\"192.168.1.256\\") False >>> is_valid_ipv4(\\"192.168.1.-1\\") False >>> is_valid_ipv4(\\"\\") False >>> is_valid_ipv4(\\"192.168.1.1 \\") False >>> is_valid_ipv4(\\" 192.168.1.1\\") False >>> is_valid_ipv4(\\"123.045.067.089\\") False","solution":"def is_valid_ipv4(ip): Determine if a given string is a valid IPv4 address. parts = ip.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False if len(part) > 1 and part[0] == '0': return False if not 0 <= int(part) <= 255: return False return True"},{"question":"def duplicate_encoder(actual_str: str) -> str: Encodes the input string such that each character in the original string is replaced with ')' if that character appears more than once in the original string, or '(' if that character appears only once. The function treats the string case-insensitively. >>> duplicate_encoder(\\"din\\") \\"(((\\" >>> duplicate_encoder(\\"recede\\") \\"()()()\\" >>> duplicate_encoder(\\"Success\\") \\")())())\\" >>> duplicate_encoder(\\"(( @\\") \\"))((\\"","solution":"def duplicate_encoder(actual_str): Encodes the input string such that each character in the original string is replaced with ')' if that character appears more than once in the original string, or '(' if that character appears only once. The function treats the string case-insensitively. actual_str_lower = actual_str.lower() char_counts = {} # Count the occurrence of each character in the lowercased string for char in actual_str_lower: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Build the result string based on the counts result = \\"\\" for char in actual_str_lower: if char_counts[char] > 1: result += \\")\\" else: result += \\"(\\" return result"},{"question":"def has_pair_with_sum(arr: List[int], k: int) -> bool: Returns True if there are two distinct elements in arr that add up to k, else False. >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1, 3, 2, 4], 6) True >>> has_pair_with_sum([1, 0, -1, 2], 1) True","solution":"def has_pair_with_sum(arr, k): Returns True if there are two distinct elements in arr that add up to k, else False. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def word_frequency(file_path: str) -> List[Tuple[str, int]]: Reads a text file and calculates the frequency of each word in that file. The function outputs each word along with its frequency, sorted in descending order based on frequency. If two words have the same frequency, they are sorted in alphabetical order. The function disregards the case (i.e., 'Word' and 'word' are considered the same). >>> word_frequency(\\"example.txt\\") [('word', 2), ('example', 1)]","solution":"from collections import Counter import re def word_frequency(file_path): Reads a text file and calculates the frequency of each word, then returns a sorted list of tuples with word and its frequency. with open(file_path, 'r') as file: text = file.read().lower() words = re.findall(r'bw+b', text) word_count = Counter(words) sorted_word_count = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return sorted_word_count"},{"question":"from typing import List, Dict def count_strings(strings_list: List[str]) -> Dict[str, int]: Returns a dictionary where the keys are the strings from the input list and the values are the counts of each string, excluding strings that appear only once. >>> count_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"strawberry\\"]) {\\"apple\\": 3, \\"banana\\": 2} >>> count_strings([\\"apple\\", \\"banana\\", \\"orange\\", \\"strawberry\\"]) {} >>> count_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\"]) {\\"apple\\": 2} >>> count_strings([]) {} >>> count_strings([\\"apple\\", \\"apple\\", \\"apple\\"]) {\\"apple\\": 3}","solution":"def count_strings(strings_list): Returns a dictionary where the keys are the strings from the input list and the values are the counts of each string, excluding strings that appear only once. from collections import Counter string_counts = Counter(strings_list) return {string: count for string, count in string_counts.items() if count > 1}"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parentheses. Example: >>> evaluate_expression(\\"3 + (2 * 2)\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parentheses. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_ops(values, ops): right = values.pop() left = values.pop() op = ops.pop() values.append(operate(left, right, op)) values, ops = [], [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': ops.append('(') elif expression[i] == ')': while ops and ops[-1] != '(': apply_ops(values, ops) ops.pop() elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 else: while (ops and precedence(ops[-1]) >= precedence(expression[i])): apply_ops(values, ops) ops.append(expression[i]) i += 1 while ops: apply_ops(values, ops) return values[0]"},{"question":"def merge_and_sort_strings(input_list: List[str]) -> List[int]: Takes a list of strings where each string is a sequence of comma-separated integers. Converts each string into a sorted list of integers and merges them into a single sorted list without duplicates. Args: input_list (list of str): List of comma-separated integer strings. Returns: list: Sorted list of integers without duplicates. >>> merge_and_sort_strings([\\"1,2,3,4,5\\"]) == [1, 2, 3, 4, 5] >>> merge_and_sort_strings([\\"1,3,5,7\\", \\"2,4,6,8\\", \\"5,6\\"]) == [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_and_sort_strings([\\"1,2,2,3,3\\", \\"3,4,4,5,5\\"]) == [1, 2, 3, 4, 5] >>> merge_and_sort_strings([]) == [] >>> merge_and_sort_strings([\\"1\\", \\"2\\", \\"3\\"]) == [1, 2, 3] >>> merge_and_sort_strings([\\"-1,-2,3,4\\", \\"2,-3,0\\"]) == [-3, -2, -1, 0, 2, 3, 4]","solution":"def merge_and_sort_strings(input_list): Takes a list of strings where each string is a sequence of comma-separated integers. Converts each string into a sorted list of integers and merges them into a single sorted list without duplicates. Args: input_list (list of str): List of comma-separated integer strings. Returns: list: Sorted list of integers without duplicates. merged_set = set() for item in input_list: numbers = map(int, item.split(',')) merged_set.update(numbers) return sorted(merged_set)"},{"question":"def clean_strings(string_list, punctuation_marks): Returns a list of strings where punctuation marks are removed, strings are converted to lowercase, and strings containing numeric digits are filtered out. :param string_list: List of strings to clean. :param punctuation_marks: List of punctuation marks to remove. :return: cleaned list of strings. >>> clean_strings([\\"Hello, World!\\", \\"Python3.0 is great\\", \\"Data-Science!\\"], [\\",\\", \\".\\", \\"-\\", \\"!\\"]) [\\"hello world\\", \\"datascience\\"] >>> clean_strings([\\"Python3.0 is great\\"], [\\".\\", \\"-\\"]) [] >>> clean_strings([\\"HELLO, WoRLd!\\"], [\\",\\", \\"!\\"]) [\\"hello world\\"] >>> clean_strings([\\"Hello, World!\\"], [\\",\\", \\"!\\"]) [\\"hello world\\"] >>> clean_strings([], [\\",\\"]) [] >>> clean_strings([\\"hello\\"], []) [\\"hello\\"] >>> clean_strings([\\"Hello World\\"], [\\".\\"]) [\\"hello world\\"]","solution":"def clean_strings(string_list, punctuation_marks): Returns a list of strings where punctuation marks are removed, strings are converted to lowercase, and strings containing numeric digits are filtered out. :param string_list: List of strings to clean. :param punctuation_marks: List of punctuation marks to remove. :return: cleaned list of strings. cleaned_strings = [] for string in string_list: # Remove punctuation marks for mark in punctuation_marks: string = string.replace(mark, \\"\\") # Convert to lowercase string = string.lower() # Filter out strings containing numeric digits if not any(char.isdigit() for char in string): cleaned_strings.append(string) return cleaned_strings"},{"question":"def group_by_key(list_of_dicts, key): Groups a list of dictionaries by a specified key. Parameters: list_of_dicts (list): List of dictionaries to be grouped. key (str): The key to group the dictionaries by. Returns: dict: A dictionary where the keys are the unique values found in the input dictionaries under the specified key, and the values are lists of dictionaries that have the corresponding key value. Dictionaries without the specified key are grouped under 'Undefined'. Raises: ValueError: If the list_of_dicts is not a list or if key is not a string. Example: >>> group_by_key([{\\"name\\": \\"Alice\\", \\"role\\": \\"Engineer\\"}, {\\"name\\": \\"Bob\\", \\"role\\": \\"Manager\\"}, {\\"name\\": \\"Charlie\\", \\"role\\": \\"Engineer\\"}], \\"role\\") { \\"Engineer\\": [ {\\"name\\": \\"Alice\\", \\"role\\": \\"Engineer\\"}, {\\"name\\": \\"Charlie\\", \\"role\\": \\"Engineer\\"} ], \\"Manager\\": [ {\\"name\\": \\"Bob\\", \\"role\\": \\"Manager\\"} ] } >>> group_by_key([{\\"name\\": \\"Alice\\", \\"role\\": \\"Engineer\\"}, {\\"name\\": \\"Bob\\"}, {\\"name\\": \\"Charlie\\", \\"role\\": \\"Engineer\\"}], \\"role\\") { \\"Engineer\\": [ {\\"name\\": \\"Alice\\", \\"role\\": \\"Engineer\\"}, {\\"name\\": \\"Charlie\\", \\"role\\": \\"Engineer\\"} ], \\"Undefined\\": [ {\\"name\\": \\"Bob\\"} ] }","solution":"def group_by_key(list_of_dicts, key): Groups a list of dictionaries by a specified key. Parameters: list_of_dicts (list): List of dictionaries to be grouped. key (str): The key to group the dictionaries by. Returns: dict: A dictionary where the keys are the unique values found in the input dictionaries under the specified key, and the values are lists of dictionaries that have the corresponding key value. Dictionaries without the specified key are grouped under 'Undefined'. Raises: ValueError: If the list_of_dicts is not a list or if key is not a string. if not isinstance(list_of_dicts, list): raise ValueError(\\"The first argument must be a list of dictionaries.\\") if not isinstance(key, str): raise ValueError(\\"The key must be a string.\\") if not all(isinstance(d, dict) for d in list_of_dicts): raise ValueError(\\"All elements of the list must be dictionaries.\\") grouped_dict = {} for dictionary in list_of_dicts: value = dictionary.get(key, \\"Undefined\\") if value not in grouped_dict: grouped_dict[value] = [] grouped_dict[value].append(dictionary) return grouped_dict"},{"question":"from typing import List def find_substring_anagrams(s: str, p: str) -> List[int]: Write a Python function that finds all the start indices of \`p\`'s anagrams in \`s\`. The function should return a list of starting indices of the anagrams. An anagram is defined as a rearrangement of characters, so you should identify all possible permutations of \`p\` within \`s\`. >>> find_substring_anagrams(\\"cbaebabacd\\", \\"abc\\") == [0, 6] >>> find_substring_anagrams(\\"abcdefg\\", \\"hij\\") == [] >>> find_substring_anagrams(\\"aaaaaaaaaa\\", \\"aaa\\") == [0, 1, 2, 3, 4, 5, 6, 7] >>> find_substring_anagrams(\\"a\\", \\"a\\") == [0] >>> find_substring_anagrams(\\"a\\", \\"b\\") == [] >>> find_substring_anagrams(\\"ababa\\", \\"aba\\") == [0, 2]","solution":"from typing import List def find_substring_anagrams(s: str, p: str) -> List[int]: from collections import Counter len_s, len_p = len(s), len(p) # Special case where p is longer than s, no anagram is possible if len_p > len_s: return [] p_count = Counter(p) s_count = Counter(s[:len_p-1]) result_indices = [] for i in range(len_p-1, len_s): # add the new character to the current window s_count[s[i]] += 1 # Check if we have a valid anagram if s_count == p_count: result_indices.append(i - len_p + 1) # remove the first character of the current window for next iteration s_count[s[i - len_p + 1]] -= 1 if s_count[s[i - len_p + 1]] == 0: del s_count[s[i - len_p + 1]] return result_indices"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers nums and an integer target, returns the first two integers that sum up to the target value. If no such pair exists, returns an empty list. :param nums: List[int] - list of integers :param target: int - target sum value :return: List[int] - list with the first two integers that sum up to target >>> two_sum([2, 7, 11, 15], 9) [2, 7] >>> two_sum([3, 2, 4], 6) [2, 4] >>> two_sum([3, 3], 6) [3, 3] >>> two_sum([], 10) [] >>> two_sum([1, 2, 3, 4, 5], 10) [] >>> two_sum([1, 2, 3, 4, 5], 9) [4, 5] >>> two_sum([0, 0, 1, 2], 0) [0, 0]","solution":"def two_sum(nums, target): Given a list of integers nums and an integer target, returns the first two integers that sum up to the target value. If no such pair exists, returns an empty list. :param nums: List[int] - list of integers :param target: int - target sum value :return: List[int] - list with the first two integers that sum up to target seen = {} for num in nums: complement = target - num if complement in seen: return [complement, num] seen[num] = True return []"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if any two distinct integers in the list sum up to the target value. :param nums: List of integers :param target: Target sum value :return: True if a pair exists that sums to the target value, False otherwise >>> has_pair_with_sum([2, 7, 11, 15], 9) == True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([3, 1, 4, 2, 5, 3], 6) == True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) == True >>> has_pair_with_sum([-1, 2, -3, 4, -5], 1) == True >>> has_pair_with_sum([-1, 2, -3, 4, -5], -2) == False >>> has_pair_with_sum([1, 2, 3, -1, -2], 0) == True >>> has_pair_with_sum([1, 1, 1, 1, 1], 2) == True >>> has_pair_with_sum([1, 2, 3, 4, 5], 5) == True >>> has_pair_with_sum([1, 1, 1, 1], 3) == False","solution":"def has_pair_with_sum(nums, target): Determines if any two distinct integers in the list sum up to the target value. :param nums: List of integers :param target: Target sum value :return: True if a pair exists that sums to the target value, False otherwise seen = set() for num in nums: needed = target - num if needed in seen: return True seen.add(num) return False"},{"question":"from typing import List, Dict, Any def filter_dicts(input_list: List[Dict[str, Any]], target_key: str) -> List[Dict[str, Any]]: Filters a list of dictionaries to retain only the target key and its corresponding value. Parameters: input_list (List[Dict[str, Any]]): The list of dictionaries to be filtered. target_key (str): The key that should be retained in new dictionaries. Returns: List[Dict[str, Any]]: A new list of dictionaries containing only the target key and its value. Dictionaries from the input list that do not contain the target key are omitted. Examples: >>> filter_dicts([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}], 'a') [{'a': 1}, {'a': 3}] >>> filter_dicts([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}], 'c') [] >>> filter_dicts([{'a': 1, 'b': 2}, {'b': 4, 'c': 5}], 'b') [{'b': 2}, {'b': 4}] >>> filter_dicts([{'a': 1, 'b': 2}, {'c': 5}, {'a': 6}], 'a') [{'a': 1}, {'a': 6}] >>> filter_dicts([], 'a') []","solution":"from typing import List, Dict, Any def filter_dicts(input_list: List[Dict[str, Any]], target_key: str) -> List[Dict[str, Any]]: Filters a list of dictionaries to retain only the target key and its corresponding value. Parameters: input_list (List[Dict[str, Any]]): The list of dictionaries to be filtered. target_key (str): The key that should be retained in new dictionaries. Returns: List[Dict[str, Any]]: A new list of dictionaries containing only the target key and its value. Dictionaries from the input list that do not contain the target key are omitted. filtered_list = [] for d in input_list: if target_key in d: filtered_list.append({target_key: d[target_key]}) return filtered_list"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. >>> longest_substring_k_distinct(\\"araaci\\", 2) 4 >>> longest_substring_k_distinct(\\"araaci\\", 1) 2 >>> longest_substring_k_distinct(\\"cbbebi\\", 3) 5","solution":"def longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_frequency = {} left = 0 max_length = 0 for right in range(len(s)): right_char = s[right] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[left] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def first_non_repeating_character(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no such character exists, return -1. >>> first_non_repeating_character(\\"loveleetcode\\") 2 >>> first_non_repeating_character(\\"aabbcc\\") -1 >>> first_non_repeating_character(\\"aabbccdeeffg\\") 6 >>> first_non_repeating_character(\\"abcdef\\") 0 >>> first_non_repeating_character(\\"a\\") 0 >>> first_non_repeating_character(\\"\\") -1 >>> large_str = \\"a\\" * 9999 + \\"b\\" >>> first_non_repeating_character(large_str) 9999","solution":"def first_non_repeating_character(s): Returns the index of the first non-repeating character in the string s. If no such character exists, return -1. # Create a frequency dictionary char_count = {} # Count the occurrence of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the index of the first character that has a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def separate_and_uppercase(input_string): Separates letters and digits from the input string, converts letters to uppercase, and returns the new formatted string. Args: input_string (str): The string containing a mix of letters and digits. Returns: str: A new string with letters in uppercase followed by digits. Raises: TypeError: If input is not a string. Example: >>> separate_and_uppercase(\\"a1b2c3\\") 'ABC123' >>> separate_and_uppercase(\\"abcXYZ\\") 'ABCXYZ' >>> separate_and_uppercase(\\"12345\\") '12345' >>> separate_and_uppercase(\\"a1!b2#\\") 'AB12' >>> separate_and_uppercase(\\"\\") '' import pytest from solution import separate_and_uppercase def test_normal_case(): assert separate_and_uppercase(\\"a1b2c3\\") == \\"ABC123\\" def test_all_letters(): assert separate_and_uppercase(\\"abcXYZ\\") == \\"ABCXYZ\\" def test_all_digits(): assert separate_and_uppercase(\\"123456\\") == \\"123456\\" def test_mixed_chars(): assert separate_and_uppercase(\\"a1!b2#\\") == \\"AB12\\" def test_empty_string(): assert separate_and_uppercase(\\"\\") == \\"\\" def test_no_digits(): assert separate_and_uppercase(\\"abc\\") == \\"ABC\\" def test_no_letters(): assert separate_and_uppercase(\\"12345\\") == \\"12345\\" def test_input_not_string(): with pytest.raises(TypeError): separate_and_uppercase(12345) def test_input_list_instead_string(): with pytest.raises(TypeError): separate_and_uppercase(['a', '1'])","solution":"def separate_and_uppercase(input_string): Separates letters and digits from the input string, converts letters to uppercase, and returns the new formatted string. Args: input_string (str): The string containing a mix of letters and digits. Returns: str: A new string with letters in uppercase followed by digits. Raises: TypeError: If input is not a string. if not isinstance(input_string, str): raise TypeError(\\"Input must be a string\\") letters = [] digits = [] for char in input_string: if char.isalpha(): letters.append(char.upper()) elif char.isdigit(): digits.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def count_unique_integers(lst: List[int]) -> dict: Returns a dictionary with the count of each unique integer in the list. Args: lst (list): List of integers. Returns: dict: Dictionary with integers as keys and their counts as values. >>> count_unique_integers([2, 3, 2, 3, 4, 2]) {2: 3, 3: 2, 4: 1} >>> count_unique_integers([]) {} >>> count_unique_integers([1, 2, 3, 4]) {1: 1, 2: 1, 3: 1, 4: 1} >>> count_unique_integers([5, 5, 5, 5]) {5: 4} >>> count_unique_integers([1, 2, 1, 2, 3, 3, 1]) {1: 3, 2: 2, 3: 2}","solution":"def count_unique_integers(lst): Returns a dictionary with the count of each unique integer in the list. Args: lst (list): List of integers. Returns: dict: Dictionary with integers as keys and their counts as values. count_dict = {} for num in lst: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 return count_dict"},{"question":"class TextEditor: A simple text editor with undo functionality. def __init__(self): self.text = \\"\\" self.history = [] def append(self, text: str): Appends the string \`text\` to the end of the current text. pass def delete(self, k: int): Deletes the last \`k\` characters from the current text. pass def print(self): Prints the current text. pass def undo(self): Reverts the last append or delete operation. pass # Sample usage editor = TextEditor() editor.append(\\"example\\") editor.print() # Outputs: \\"example\\"","solution":"class TextEditor: def __init__(self): self.text = \\"\\" # Stack to store the state of text for undo operations self.history = [] def append(self, text: str): self.history.append(self.text) self.text += text def delete(self, k: int): self.history.append(self.text) self.text = self.text[:-k] def get_text(self): # Added this method for testing purposes return self.text def undo(self): if self.history: self.text = self.history.pop()"},{"question":"def transform_string(s: str, k: int) -> str: Takes a string s and an integer k, and returns a new string where every k-th character is converted to uppercase. If the string is shorter than k, returns the original string. >>> transform_string(\\"abcdef\\", 2) 'aBcDeF' >>> transform_string(\\"hello\\", 3) 'heLlo' >>> transform_string(\\"world\\", 6) 'world' # Your implementation here","solution":"def transform_string(s: str, k: int) -> str: Takes a string s and an integer k, and returns a new string where every k-th character is converted to uppercase. If the string is shorter than k, returns the original string. if k <= 0 or k > len(s): return s transformed = list(s) for i in range(k-1, len(s), k): transformed[i] = transformed[i].upper() return ''.join(transformed)"},{"question":"def compute_average_temperatures(file_path): This function reads a file of weather data and computes the average temperature for each day. :param file_path: str: path to the weather data file :return: dict: a dictionary where keys are dates and values are average temperatures Example: >>> compute_average_temperatures(\\"weather_data.txt\\") {\\"2023-01-01\\": 15.0, \\"2023-01-02\\": 15.0} averages = {} counts = {} # Continue reading and processing the file to compute the averages import pytest from solution import compute_average_temperatures def test_compute_average_temperatures_valid_data(tmp_path): weather_data = \\"2023-01-01 10.0n2023-01-01 20.0n2023-01-02 15.0n\\" file_path = tmp_path / \\"weather_data.txt\\" file_path.write_text(weather_data) result = compute_average_temperatures(file_path) assert result == {\\"2023-01-01\\": 15.0, \\"2023-01-02\\": 15.0} def test_compute_average_temperatures_with_empty_file(tmp_path): file_path = tmp_path / \\"empty_weather_data.txt\\" file_path.write_text(\\"\\") result = compute_average_temperatures(file_path) assert result == {} def test_compute_average_temperatures_with_malformed_data(tmp_path): weather_data = \\"2023-01-01 10.0n2023-01-01 twentyn2023-01-02 15.0nmalformed line\\" file_path = tmp_path / \\"malformed_weather_data.txt\\" file_path.write_text(weather_data) result = compute_average_temperatures(file_path) assert result == {\\"2023-01-01\\": 10.0, \\"2023-01-02\\": 15.0} def test_compute_average_temperatures_file_not_found(): result = compute_average_temperatures(\\"non_existent_file.txt\\") assert result == {} def test_compute_average_temperatures_mixed_good_and_bad_data(tmp_path): weather_data = \\"2023-01-01 10.0n2023-01-01 twentyn2023-01-02 15.0n2023-01-01 30.0n2023-01-03 25.0nanother malformed line\\" file_path = tmp_path / \\"mixed_weather_data.txt\\" file_path.write_text(weather_data) result = compute_average_temperatures(file_path) assert result == {\\"2023-01-01\\": 20.0, \\"2023-01-02\\": 15.0, \\"2023-01-03\\": 25.0} def test_compute_average_temperatures_all_malformed_lines(tmp_path): weather_data = \\"wrong formatnanother invalid linen2023-01-01 notanumbern\\" file_path = tmp_path / \\"all_malformed_data.txt\\" file_path.write_text(weather_data) result = compute_average_temperatures(file_path) assert result == {}","solution":"def compute_average_temperatures(file_path): This function reads a file of weather data and computes the average temperature for each day. :param file_path: str: path to the weather data file :return: dict: a dictionary where keys are dates and values are average temperatures averages = {} counts = {} try: with open(file_path, 'r') as file: for line in file: parts = line.strip().split() if len(parts) != 2: continue date, temp_str = parts try: temperature = float(temp_str) except ValueError: continue if date in averages: averages[date] += temperature counts[date] += 1 else: averages[date] = temperature counts[date] = 1 for date in averages: averages[date] /= counts[date] except FileNotFoundError: print(f\\"File {file_path} not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return averages"},{"question":"from typing import List def kth_smallest(nums: List[int], k: int) -> int: Finds the k-th smallest element in the list nums. Raises ValueError if the input is invalid. >>> kth_smallest([3, 2, 1, 5, 4], 2) 2 >>> kth_smallest([3, 2, 1, 5, 4], 1) 1 >>> kth_smallest([3, 2, 1, 5, 4], 5) 5 >>> kth_smallest([], 1) raises ValueError >>> kth_smallest([3, 1, 4, 2], 0) raises ValueError >>> kth_smallest([3, 3, 3, 3], 3) 3 >>> kth_smallest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 6) 6 >>> kth_smallest([1, 1, 1, 1, 1], 3) 1 >>> kth_smallest([-5, 3, 0, 2], 1) -5","solution":"from typing import List def kth_smallest(nums: List[int], k: int) -> int: Finds the k-th smallest element in the list nums using the Quickselect algorithm. Raises ValueError if the input is invalid. if not nums: raise ValueError(\\"Empty list provided\\") if k < 1 or k > len(nums): raise ValueError(\\"k is out of valid range\\") def quickselect(l, r, k): pivot = nums[r] p = l for j in range(l, r): if nums[j] <= pivot: nums[p], nums[j] = nums[j], nums[p] p += 1 nums[p], nums[r] = nums[r], nums[p] if p == k: return nums[p] elif p < k: return quickselect(p + 1, r, k) else: return quickselect(l, p - 1, k) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Returns a new list containing only the unique elements from the original list in the order they first appeared. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([]) [] >>> unique_elements([10]) [10] >>> unique_elements([6, 6, 6, 6, 6]) [6] >>> unique_elements([3, 2, 1, 2, 3]) [3, 2, 1] pass","solution":"def unique_elements(lst): Returns a new list containing only the unique elements from the original list in the order they first appeared. seen = {} unique_lst = [] for item in lst: if item not in seen: unique_lst.append(item) seen[item] = True return unique_lst"},{"question":"def findLIS(nums: [int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> findLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> findLIS([1, 2, 3, 4, 5]) == 5 >>> findLIS([5, 4, 3, 2, 1]) == 1 >>> findLIS([0, 1, 0, 3, 2, 3]) == 4 >>> findLIS([]) == 0","solution":"def findLIS(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import sys sys.setrecursionlimit(1500) def factorial(n: int) -> int: Compute the factorial of a given non-negative integer. Handles large inputs efficiently by checking for possible integer overflow. Implements a solution that makes use of recursion while preventing stack overflow for exceptionally large integers. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(100) == math.factorial(100) if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n <= 1: return 1 return n * factorial(n - 1)","solution":"import sys sys.setrecursionlimit(1500) def factorial(n): Returns the factorial of a given non-negative integer n. Handles large inputs efficiently by checking for maximum recursion depth. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n <= 1: return 1 return n * factorial(n - 1)"},{"question":"def pair_sum(nums: List[int], target_sum: int) -> List[Tuple[int, int]]: Returns a list of unique pairs of integers from the list that add up to the target_sum. Each pair is returned as a tuple; the list is sorted in ascending order based on the first element of each pair. >>> pair_sum([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> pair_sum([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> pair_sum([1, 1, 2, 2], 3) [(1, 2)] >>> pair_sum([1, 2, 3], 7) []","solution":"def pair_sum(nums, target_sum): Returns a list of unique pairs of integers from the list that add up to the target_sum. Each pair is returned as a tuple; the list is sorted in ascending order based on the first element of each pair. seen = set() pairs = set() for num in nums: complement = target_sum - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs)"},{"question":"from typing import List def rearrange_string(s: str) -> str: Write a Python function that takes a string as input and returns the string with all its characters rearranged such that no two adjacent characters are the same. If it's not possible to rearrange the string in this manner, return an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") ''","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If not possible, returns an empty string. if not s: return \\"\\" # Count the frequency of each character counter = Counter(s) max_heap = [] # Build a max heap of the counts for char, count in counter.items(): heappush(max_heap, (-count, char)) prev_char, prev_count = \\"\\", 0 result = [] while max_heap: count, char = heappop(max_heap) # Append the current char to the result and update the count result.append(char) if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update prev_char and decrement count prev_char = char prev_count = count + 1 rearranged = ''.join(result) # If the length of the rearranged string is different from the original, return empty string return rearranged if len(rearranged) == len(s) else \\"\\""},{"question":"def count_characters(input_string: str) -> dict: Write a Python function that, given a string, returns a dictionary mapping each unique character in the string to the number of occurrences of that character, excluding any spaces. The function should be case-sensitive, treating 'a' and 'A' as distinct characters. >>> count_characters(\\"Hello\\") == {'H': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters(\\"Hello World\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> count_characters(\\"aAaA\\") == {'a': 2, 'A': 2} >>> count_characters(\\"\\") == {} >>> count_characters(\\" \\") == {} >>> count_characters(\\"Hello, World!\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1}","solution":"def count_characters(input_string): Returns a dictionary mapping each unique character in the input_string to the number of occurrences of that character, excluding spaces. The function is case-sensitive. char_counts = {} for char in input_string: if char != ' ': if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 return char_counts"},{"question":"class TargetNotFoundException(Exception): def __init__(self, message=\\"Target number not reachable with any two numbers in the list\\"): self.message = message super().__init__(self.message) def two_sum(nums, target): Returns the indices of the two numbers in the list such that they add up to the target number. Uses a dictionary for efficient lookup. # Erroneous code containing exactly 3 bugs def buggy_two_sum(nums, target): Erroneous implementation that has 3 bugs for the candidate to identify and fix. num_map = {} for i, num in enumerate(nums): complement = num_map[target - num] # Bug 1: Incorrect usage of num_map for complement if complement: # Bug 2: Incorrect condition to check if complement found return [i, complement] # Bug 3: Returning indices in wrong order/not using correct indices num_map[num] = i raise TargetNotFoundException() # Unit tests def test_two_sum_positive_case(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_negative_numbers(): assert two_sum([-3, 4, 3, 90], 0) == [0, 2] def test_two_sum_with_zero(): assert two_sum([0, 4, 3, 0], 0) == [0, 3] def test_two_sum_large_list(): assert two_sum(list(range(1, 10001)) + [10001], 20001) == [9999, 10000] def test_two_sum_no_solution(): try: two_sum([1, 2, 3, 4, 5], 10) except TargetNotFoundException as e: assert str(e) == \\"Target number not reachable with any two numbers in the list\\"","solution":"class TargetNotFoundException(Exception): def __init__(self, message=\\"Target number not reachable with any two numbers in the list\\"): self.message = message super().__init__(self.message) def two_sum(nums, target): Returns the indices of the two numbers in the list such that they add up to the target number. Uses a dictionary for efficient lookup. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i raise TargetNotFoundException()"},{"question":"from typing import List def calculate_min_payment(prices: List[int], percent_discount: int, flat_discount: int, min_percent_amount: int, min_flat_amount: int, flat_min_limit: int) -> float: Calculate the minimum total payment after applying the most beneficial discount that qualifies based on given constraints. >>> calculate_min_payment([100, 200, 300], 20, 100, 500, 200, 50) 480.0 >>> calculate_min_payment([50, 50, 100], 10, 50, 100, 100, 20) 150.0","solution":"from typing import List def calculate_min_payment(prices: List[int], percent_discount: int, flat_discount: int, min_percent_amount: int, min_flat_amount: int, flat_min_limit: int) -> float: total_amount = sum(prices) # Calculate percentage discount percent_discounted = total_amount if total_amount >= min_percent_amount: percent_discounted = total_amount * ((100 - percent_discount) / 100.0) # Calculate flat rate discount flat_discounted = total_amount if total_amount >= min_flat_amount: flat_discounted = max(total_amount - flat_discount, flat_min_limit) # Calculate BOGO discount bogo_discounted = total_amount from collections import Counter product_counter = Counter(prices) for price, count in product_counter.items(): bogo_discounted -= (count // 2) * price # Find the minimum payment with eligible discounts min_payment = min(percent_discounted, flat_discounted, bogo_discounted) return round(min_payment, 2)"},{"question":"def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose the given matrix. Parameters: matrix (list of list of int): The matrix to be transposed. Returns: list of list of int: The transposed matrix. Example: >>> transpose([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]]","solution":"def transpose(matrix): Returns the transpose of the given matrix. Parameters: matrix (list of list of int): The matrix to be transposed. Returns: list of list of int: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"def square_elements_standard_loop(input_list): Returns a new list with each integer squared using a standard loop. >>> square_elements_standard_loop([1, 2, 3]) [1, 4, 9] >>> square_elements_standard_loop([-1, -2, -3]) [1, 4, 9] pass def square_elements_list_comprehension(input_list): Returns a new list with each integer squared using a list comprehension. >>> square_elements_list_comprehension([1, 2, 3]) [1, 4, 9] >>> square_elements_list_comprehension([-1, -2, -3]) [1, 4, 9] pass","solution":"def square_elements_standard_loop(input_list): Returns a new list with each integer squared using a standard loop. if not isinstance(input_list, list): raise ValueError(\\"Input must be a list\\") squared_list = [] for item in input_list: if not isinstance(item, int): raise ValueError(\\"All elements in the list must be integers\\") squared_list.append(item ** 2) return squared_list def square_elements_list_comprehension(input_list): Returns a new list with each integer squared using a list comprehension. if not isinstance(input_list, list): raise ValueError(\\"Input must be a list\\") return [item ** 2 if isinstance(item, int) else ValueError(\\"All elements in the list must be integers\\") for item in input_list]"},{"question":"def merge_and_deduplicate_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list without duplicates. >>> merge_and_deduplicate_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_deduplicate_sorted_lists([1, 2, 3], [2, 3, 4]) [1, 2, 3, 4] >>> merge_and_deduplicate_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> merge_and_deduplicate_sorted_lists([], []) [] >>> merge_and_deduplicate_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_and_deduplicate_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_and_deduplicate_sorted_lists([1], [2]) [1, 2] >>> merge_and_deduplicate_sorted_lists([1], [1]) [1]","solution":"def merge_and_deduplicate_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list without duplicates. :param list1: List[int] - First sorted list. :param list2: List[int] - Second sorted list. :return: List[int] - Merged and deduplicated sorted list. merged_list = sorted(set(list1) | set(list2)) return merged_list"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple such substrings with the same maximum length, returns the one that appears first. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_unique_substring(\\"aab\\") == \\"ab\\" >>> longest_unique_substring(\\"dvdf\\") == \\"vdf\\"","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. If there are multiple such substrings with the same maximum length, returns the one that appears first. if not s: return \\"\\" start, max_len, max_start = 0, 0, 0 char_index_map = {} for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end if end - start + 1 > max_len: max_len = end - start + 1 max_start = start return s[max_start:max_start + max_len]"},{"question":"def find_palindromic_substrings(s: str) -> list: Returns a list of all unique palindromic substrings contained within the input string. Use efficient algorithms to ensure the function works well with long strings. Examples: >>> find_palindromic_substrings(\\"aba\\") ['a', 'b', 'aba'] >>> find_palindromic_substrings(\\"racecar\\") ['r', 'a', 'c', 'e', 'aceca', 'cec', 'racecar'] >>> find_palindromic_substrings(\\"abcd\\") ['a', 'b', 'c', 'd'] >>> find_palindromic_substrings(\\"aaaa\\") ['a', 'aa', 'aaa', 'aaaa'] >>> find_palindromic_substrings(\\"\\") []","solution":"def find_palindromic_substrings(s): Returns a list of all unique palindromic substrings contained within the input string. palindromic_substrings = set() def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: palindromic_substrings.add(s[left:right+1]) left -= 1 right += 1 for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return list(palindromic_substrings)"},{"question":"def find_peak_indices(nums): Returns the indices of all peak elements in the list. A peak element is greater than its neighbors. Examples: >>> find_peak_indices([1, 3, 2, 4, 1]) [1, 3] >>> find_peak_indices([10, 9, 8, 7]) [0] >>> find_peak_indices([1, 2, 3, 4, 5]) [4]","solution":"def find_peak_indices(nums): Returns the indices of all peak elements in the list. A peak element is greater than its neighbors. if not nums: return [] peak_indices = [] length = len(nums) for i in range(length): if i == 0: if length == 1 or nums[i] > nums[i + 1]: peak_indices.append(i) elif i == length - 1: if nums[i] > nums[i - 1]: peak_indices.append(i) else: if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: peak_indices.append(i) return peak_indices"},{"question":"def sum_of_unique_abs_pairs(nums): This function takes in a list of integers \`nums\` and returns the sum of the absolute values of the unique pairs of integers that add up to zero. >>> sum_of_unique_abs_pairs([1, -1, 2, -2, 3, 1, -1]) 6 >>> sum_of_unique_abs_pairs([3, -3, -3, 3, 2, 2]) 6 >>> sum_of_unique_abs_pairs([1, 2, 3]) 0","solution":"def sum_of_unique_abs_pairs(nums): This function takes in a list of integers \`nums\` and returns the sum of the absolute values of the unique pairs of integers that add up to zero. :param nums: List[int] - a list of integers. :return: int - the sum of the absolute values of the unique pairs adding to zero. num_set = set(nums) result = 0 for num in num_set: if -num in num_set and num > 0: result += abs(num) return result * 2"},{"question":"from typing import List def can_reach_end(steps: List[int]) -> bool: Determine if it is possible to reach the last index of the array starting from the first index. >>> can_reach_end([2, 3, 1, 1, 4]) True >>> can_reach_end([3, 2, 1, 0, 4]) False def test_example_cases(): assert can_reach_end([2, 3, 1, 1, 4]) == True assert can_reach_end([3, 2, 1, 0, 4]) == False def test_single_element(): assert can_reach_end([0]) == True def test_two_elements_possible(): assert can_reach_end([1, 0]) == True def test_two_elements_not_possible(): assert can_reach_end([0, 1]) == False def test_reachability_with_larger_steps(): assert can_reach_end([5, 0, 0, 0, 0, 0]) == True def test_stuck_in_middle(): assert can_reach_end([1, 2, 1, 0, 0, 0]) == False def test_empty_array(): assert can_reach_end([]) == False def test_max_jump_at_beginning(): assert can_reach_end([6, 1, 1, 1, 1, 1, 0]) == True def test_insufficient_jump(): assert can_reach_end([1, 1, 1, 1, 1, 0, 5]) == False def test_reachability_with_long_array(): assert can_reach_end([1] * 100000 + [0]) == True","solution":"from typing import List def can_reach_end(steps: List[int]) -> bool: max_reachable = 0 for i, step in enumerate(steps): if i > max_reachable: return False max_reachable = max(max_reachable, i + step) if max_reachable >= len(steps) - 1: return True return False"},{"question":"def greater_than_mean(lst: List[int]) -> List[int]: Returns a new list containing only the elements that are greater than the arithmetic mean of the original list. :param lst: List of integers :return: List of integers greater than the arithmetic mean >>> greater_than_mean([1, 1, 1, 1]) == [] >>> greater_than_mean([1, 2, 3, 4, 5]) == [4, 5] >>> greater_than_mean([3, 3, 3, 3]) == [] >>> greater_than_mean([]) == [] >>> greater_than_mean([-1, -2, -3, -4, -5]) == [-1, -2] >>> greater_than_mean([10]) == [] >>> greater_than_mean([1, 2, 3, 0, 6, 7, 8, -1, 4, 3]) == [6, 7, 8, 4]","solution":"def greater_than_mean(lst): Returns a new list containing only the elements that are greater than the arithmetic mean of the original list. :param lst: List of integers :return: List of integers greater than the arithmetic mean if not lst: return [] mean = sum(lst) / len(lst) result = [x for x in lst if x > mean] return result"},{"question":"def move_zeroes(nums: List[int]) -> None: Moves all zeroes in an unsorted array of integers to the end while maintaining the relative order of the non-zero elements. Args: nums (List[int]): The list of integers to be rearranged. Returns: None: The function modifies the list in-place. Example: >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([1, 3, 12, 0, 0]) [1, 3, 12, 0, 0] >>> move_zeroes([0, 0, 1, 0, 3, 12]) [1, 3, 12, 0, 0, 0] >>> move_zeroes([1, 2, 3, 4]) [1, 2, 3, 4] >>> move_zeroes([0, 0, 0, 0]) [0, 0, 0, 0] >>> move_zeroes([1]) [1] >>> move_zeroes([0]) [0]","solution":"def move_zeroes(nums): Moves all zeroes in an unsorted array of integers to the end while maintaining the relative order of the non-zero elements. Args: nums (List[int]): The list of integers to be rearranged. Returns: None: The function modifies the list in-place. last_non_zero_found_at = 0 for current in range(len(nums)): if nums[current] != 0: nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at] last_non_zero_found_at += 1 return nums"},{"question":"import re from collections import defaultdict def char_frequency_combined(str1, str2): Implement a Python function that accepts two string arguments and returns a dictionary where the keys are the characters present in both strings, and the values are the number of times each character appears in both strings combined. The function handles case insensitivity and ignores any non-alphabetical characters. >>> char_frequency_combined(\\"hello\\", \\"world\\") {'l': 3, 'o': 2} >>> char_frequency_combined(\\"Hello!!!\\", \\"World...\\") {'l': 3, 'o': 2} >>> char_frequency_combined(\\"abc\\", \\"xyz\\") {} >>> char_frequency_combined(\\"apple\\", \\"apple\\") {'a': 2, 'p': 4, 'l': 2, 'e': 2} >>> char_frequency_combined(\\"\\", \\"\\") {} >>> char_frequency_combined(\\"hello\\", \\"\\") {} >>> char_frequency_combined(\\"a1b2c3\\", \\"c3b2a1\\") {'a': 2, 'b': 2, 'c': 2} >>> char_frequency_combined(\\"AaAaA\\", \\"aaa\\") {'a': 8}","solution":"import re from collections import defaultdict def char_frequency_combined(str1, str2): Returns a dictionary where the keys are the characters present in both strings, and the values are the number of times each character appears in both strings combined. The function is case-insensitive and ignores non-alphabetical characters. str1 = re.sub(r'[^a-zA-Z]', '', str1).lower() str2 = re.sub(r'[^a-zA-Z]', '', str2).lower() char_count = defaultdict(int) for char in str1: char_count[char] += 1 for char in str2: char_count[char] += 1 # Only retain entries that are present in both strings common_chars = set(str1) & set(str2) result = {char: count for char, count in char_count.items() if char in common_chars} return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-1) == False def filter_primes(numbers: List[int]) -> List[int]: Filters the prime numbers from a list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 29]) == [11, 13, 17, 19, 23, 29] >>> filter_primes([4, 6, 8, 10, 12]) == [] >>> filter_primes([3, 5, 7, 11, 13, 15, 16, 23]) == [3, 5, 7, 11, 13, 23] >>> filter_primes([0, -1, -3, 29, 37]) == [29, 37]","solution":"def is_prime(n): Checks if a number is prime. :param n: An integer to check for primality. :return: True if n is prime, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_primes(numbers): Filters the prime numbers from a list of integers. :param numbers: A list of integers. :return: A list of prime integers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def are_anagrams(string1: str, string2: str) -> bool: Returns True if string1 and string2 are anagrams of each other, ignoring case and spaces, and without using any in-built sorting methods. Args: string1 (str): The first string. string2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"Conversation\\", \\"Voices Rant On\\") True >>> are_anagrams(\\"Dormitory\\", \\"Dirty Room\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"a gentleman\\", \\"elegant man!!\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"\\", \\"a\\") False","solution":"def are_anagrams(string1, string2): Returns True if string1 and string2 are anagrams of each other, ignoring case and spaces. Args: string1 (str): The first string. string2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Normalize strings: convert to lowercase and remove spaces. s1 = string1.replace(\\" \\", \\"\\").lower() s2 = string2.replace(\\" \\", \\"\\").lower() # Create dictionaries to count character frequencies char_count1 = {} char_count2 = {} # Count characters for the first string for char in s1: if char in char_count1: char_count1[char] += 1 else: char_count1[char] = 1 # Count characters for the second string for char in s2: if char in char_count2: char_count2[char] += 1 else: char_count2[char] = 1 # Compare the two dictionaries return char_count1 == char_count2"},{"question":"def reverse_sentence(sentence: str) -> str: Write a function that takes a sentence as input and returns the sentence reversed at the word level while preserving the order of characters within each word. Do not use any built-in reversing functions. Handle punctuation correctly as part of the word it is attached to. >>> reverse_sentence(\\"Hello\\") \\"Hello\\" >>> reverse_sentence(\\"Hello world!\\") \\"world! Hello\\" >>> reverse_sentence(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_sentence(\\"Hello, world! This is an example.\\") \\"example. an is This world! Hello,\\" >>> reverse_sentence(\\"test test test\\") \\"test test test\\"","solution":"def reverse_sentence(sentence): Returns the sentence reversed at the word level while preserving the order of characters within each word. words = sentence.split() reversed_words = words[::-1] reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"from typing import List def combination_sum_2(candidates: List[int], target: int) -> List[List[int]]: Find all unique combinations of elements within the array that sum up exactly to the target. Each number in the array may only be used once in the combination. The solution set must not contain duplicate combinations. >>> combination_sum_2([10,1,2,7,6,1,5], 8) [[1,1,6], [1,2,5], [1,7], [2,6]] >>> combination_sum_2([1], 1) [[1]] >>> combination_sum_2([5], 1) [] >>> combination_sum_2([2,4,6,8], 3) [] >>> combination_sum_2([1, 1, 1, 1, 6], 7) [[1, 6]] >>> combination_sum_2([2,3,5], 8) [[3, 5]]","solution":"def combination_sum_2(candidates, target): def backtrack(start, end, temp_list): if sum(temp_list) == target: if temp_list not in result: result.append(list(temp_list)) return if sum(temp_list) > target: return for i in range(start, end): if i > start and candidates[i] == candidates[i - 1]: continue temp_list.append(candidates[i]) backtrack(i + 1, end, temp_list) temp_list.pop() candidates.sort() result = [] backtrack(0, len(candidates), []) return result"},{"question":"def merge_dictionaries(dicts: List[dict]) -> dict: Merges a list of dictionaries into a single dictionary. In case of key conflicts, the value from the dictionary that appears later in the list will overwrite the previous ones. :param dicts: List of dictionaries to merge :return: A single merged dictionary >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2}, {\\"c\\": 3, \\"d\\": 4}]) == {\\"a\\": 1, \\"b\\": 2, \\"c\\": 3, \\"d\\": 4} >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2, \\"c\\": 3}, {\\"b\\": 3, \\"d\\": 4}, {\\"a\\": 5, \\"e\\": 6}]) == {\\"a\\": 5, \\"b\\": 3, \\"c\\": 3, \\"d\\": 4, \\"e\\": 6} >>> merge_dictionaries([]) == {} >>> merge_dictionaries([{\\"a\\": 1, \\"b\\": 2}]) == {\\"a\\": 1, \\"b\\": 2} >>> merge_dictionaries([{\\"a\\": 1}, {}, {\\"b\\": 2}]) == {\\"a\\": 1, \\"b\\": 2}","solution":"def merge_dictionaries(dicts): Merges a list of dictionaries into a single dictionary. In case of key conflicts, the value from the dictionary that appears later in the list will overwrite the previous ones. :param dicts: List of dictionaries to merge :return: A single merged dictionary merged_dict = {} for d in dicts: merged_dict.update(d) return merged_dict"},{"question":"def sum_of_primes(n: int) -> int: Function to calculate the sum of all prime numbers up to a given integer n. Params: n : int : the upper limit up to which primes need to be summed Returns: int : the sum of all prime numbers up to and including n Example: >>> sum_of_primes(10) 17 >>> sum_of_primes(1) 0 >>> sum_of_primes(30) 129 from sum_of_primes import sum_of_primes def test_sum_of_primes_negative_input(): assert sum_of_primes(-10) == 0 def test_sum_of_primes_zero_and_one(): assert sum_of_primes(0) == 0 assert sum_of_primes(1) == 0 def test_sum_of_primes_no_primes(): assert sum_of_primes(2) == 2 def test_sum_of_primes_small_input(): assert sum_of_primes(10) == 17 # 2 + 3 + 5 + 7 = 17 def test_sum_of_primes_larger_input(): assert sum_of_primes(30) == 129 # 2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29 = 129 def test_sum_of_primes_large_input_efficiency(): result = sum_of_primes(1000) expected_result = 76127 # Precomputed sum of primes up to 1000 assert result == expected_result def test_sum_of_primes_prime_upper_bound(): assert sum_of_primes(13) == 41 # 2 + 3 + 5 + 7 + 11 + 13 = 41","solution":"def sum_of_primes(n): Returns the sum of all prime numbers up to and including n. If n is less than 2, returns 0. if n < 2: return 0 primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 total = 0 for p in range(2, n + 1): if primes[p]: total += p return total"},{"question":"def rotate_list(lst, steps): Rotates the elements of a given list to the right by a specified number of steps. :param lst: List of integers to be rotated. :param steps: Non-negative integer specifying the number of steps to rotate. :return: Rotated list. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([6, 7, 8, 9], 1) [9, 6, 7, 8] >>> rotate_list([0, 1, 2], 4) [2, 0, 1]","solution":"def rotate_list(lst, steps): Rotates the elements of a given list to the right by a specified number of steps. :param lst: List of integers to be rotated. :param steps: Non-negative integer specifying the number of steps to rotate. :return: Rotated list. if not lst: return lst steps = steps % len(lst) # ensures that steps exceed the length of the list wraps around properly return lst[-steps:] + lst[:-steps]"},{"question":"def add_item(inventory: list, name: str, price: float, quantity: int): Add a new item to the inventory or update the quantity if the item already exists. Args: inventory (list): The inventory list. name (str): The name of the item. price (float): The price of the item. quantity (int): The quantity of the item to add. # Your code here def generate_report(inventory: list) -> list: Generate a report of the current inventory. Args: inventory (list): The inventory list. Returns: list: A list of dictionaries representing the current inventory. # Your code here # Unit test examples def test_add_new_item(): inventory = [ [\\"apple\\", 0.50, 10], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] add_item(inventory, \\"grape\\", 0.70, 7) assert inventory == [ [\\"apple\\", 0.50, 10], [\\"banana\\", 0.30, 5], [\\"grape\\", 0.70, 7], [\\"orange\\", 0.60, 8] ] def test_update_existing_item(): inventory = [ [\\"apple\\", 0.50, 10], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] add_item(inventory, \\"apple\\", 0.50, 5) assert inventory == [ [\\"apple\\", 0.50, 15], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] def test_generate_report(): inventory = [ [\\"apple\\", 0.50, 10], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] report = generate_report(inventory) expected_report = [ {'name': 'apple', 'price': 0.50, 'quantity': 10}, {'name': 'banana', 'price': 0.30, 'quantity': 5}, {'name': 'orange', 'price': 0.60, 'quantity': 8} ] assert report == expected_report def test_add_item_different_price_same_name(): inventory = [ [\\"apple\\", 0.50, 10], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] add_item(inventory, \\"apple\\", 0.60, 5) assert inventory == [ [\\"apple\\", 0.50, 10], [\\"apple\\", 0.60, 5], [\\"banana\\", 0.30, 5], [\\"orange\\", 0.60, 8] ] def test_update_existing_item_different_price(): inventory = [ [\\"apple\\", 0.50, 10], [\\"apple\\", 0.60, 5] ] add_item(inventory, \\"apple\\", 0.60, -3) assert inventory == [ [\\"apple\\", 0.50, 10], [\\"apple\\", 0.60, 2] ]","solution":"def add_item(inventory, name, price, quantity): Add a new item to the inventory or update the quantity if the item already exists. found = False for item in inventory: if item[0] == name: if item[1] == price: item[2] += quantity found = True break if not found: inventory.append([name, price, quantity]) inventory.sort(key=lambda x: x[0]) def generate_report(inventory): Generate a report of the current inventory. report = [] for item in inventory: report.append({ 'name': item[0], 'price': item[1], 'quantity': item[2] }) return report"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head: ListNode) -> ListNode: Reverses a singly linked list in place. :param head: ListNode - the head of the singly linked list :return: ListNode - the head of the reversed singly linked list pass # Unit Tests def nodes_to_list(head: ListNode) -> list: Helper function to convert a linked list to a regular list for easier comparison in tests. result = [] current = head while current: result.append(current.val) current = current.next return result def list_to_nodes(values: list) -> ListNode: Helper function to convert a regular list to a linked list for easier setup in tests. if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def test_reverseLinkedList_empty_list(): assert reverseLinkedList(None) is None def test_reverseLinkedList_single_element_list(): head = list_to_nodes([1]) reversed_head = reverseLinkedList(head) assert nodes_to_list(reversed_head) == [1] def test_reverseLinkedList_multiple_elements(): head = list_to_nodes([1, 2, 3, 4, 5]) reversed_head = reverseLinkedList(head) assert nodes_to_list(reversed_head) == [5, 4, 3, 2, 1] def test_reverseLinkedList_two_elements(): head = list_to_nodes([1, 2]) reversed_head = reverseLinkedList(head) assert nodes_to_list(reversed_head) == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head: ListNode) -> ListNode: Reverses a singly linked list in place. :param head: ListNode - the head of the singly linked list :return: ListNode - the head of the reversed singly linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels (a, e, i, o, u) in the given string. >>> count_vowels(\\"hello\\") == 2 >>> count_vowels(\\"world\\") == 1 >>> count_vowels(\\"AEIOU\\") == 5 def count_vowels_in_list(strings: List[str]) -> List[int]: Returns a list of counts of vowels in each string of the input list. >>> count_vowels_in_list([\\"hello\\", \\"world\\", \\"AEIOU\\"]) == [2, 1, 5] >>> count_vowels_in_list([\\"\\", \\"bcdfg\\", \\"aeiou\\"]) == [0, 0, 5]","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the given string. vowels = set('aeiou') return sum(1 for char in s.lower() if char in vowels) def count_vowels_in_list(strings): Returns a list of counts of vowels in each string of the input list. return [count_vowels(s) for s in strings]"},{"question":"def is_palindrome(s: str) -> bool: Evaluates whether a given string is a valid palindrome, disregarding spaces and punctuation. The function is case insensitive. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"!!!\\") True >>> is_palindrome(\\"MadamInEdenImAdam\\") True >>> is_palindrome(\\"Madam In Eden, I'm Adam\\") True","solution":"def is_palindrome(s): Returns True if the given string is a palindrome, ignoring spaces and punctuation. The function is case insensitive. import re # Convert to lowercase s = s.lower() # Remove all non-alphanumeric characters s = re.sub(r'[^a-z0-9]', '', s) # Check if the string is equal to its reverse return s == s[::-1]"},{"question":"import time from functools import lru_cache from typing import Union def factorial(n: Union[int, float]) -> Union[int, str]: Calculate the factorial of a given non-negative integer n. Handles erroneous input scenarios such as negative integers or non-integers by returning an appropriate error message. >>> factorial(5) 120 >>> factorial(0) 1 >>> factorial(-1) 'Error: Factorial of a negative number doesn't exist.' >>> factorial(3.5) 'Error: Input must be an integer.' @lru_cache(maxsize=None) def memoized_factorial(n: Union[int, float]) -> Union[int, str]: Calculate the factorial of a given non-negative integer n with memoization. Handles erroneous input scenarios such as negative integers or non-integers by returning an appropriate error message. >>> memoized_factorial(5) 120 >>> memoized_factorial(0) 1 >>> memoized_factorial(-1) 'Error: Factorial of a negative number doesn't exist.' >>> memoized_factorial(3.5) 'Error: Input must be an integer.' # Measure performance start_time = time.time() for i in range(11): factorial(i) end_time = time.time() time_without_memoization = end_time - start_time start_time = time.time() for i in range(11): memoized_factorial(i) end_time = time.time() time_with_memoization = end_time - start_time print(f\\"Time taken without memoization: {time_without_memoization} seconds\\") print(f\\"Time taken with memoization: {time_with_memoization} seconds\\")","solution":"import time from functools import lru_cache def factorial(n): if not isinstance(n, int): return \\"Error: Input must be an integer.\\" if n < 0: return \\"Error: Factorial of a negative number doesn't exist.\\" if n == 0 or n == 1: return 1 else: result = 1 for i in range(2, n + 1): result *= i return result @lru_cache(maxsize=None) def memoized_factorial(n): if not isinstance(n, int): return \\"Error: Input must be an integer.\\" if n < 0: return \\"Error: Factorial of a negative number doesn't exist.\\" if n == 0 or n == 1: return 1 return n * memoized_factorial(n - 1) # Measure performance start_time = time.time() for i in range(11): factorial(i) end_time = time.time() time_without_memoization = end_time - start_time start_time = time.time() for i in range(11): memoized_factorial(i) end_time = time.time() time_with_memoization = end_time - start_time print(f\\"Time taken without memoization: {time_without_memoization} seconds\\") print(f\\"Time taken with memoization: {time_with_memoization} seconds\\")"},{"question":"def find_books_in_same_section(library, book_id1, book_id2): Given the identifiers of two books, returns a list of all book IDs located in the same section as these two books. Parameters: library (dict): Dictionary mapping each book ID to its full location path. book_id1 (str): The first book ID. book_id2 (str): The second book ID. Returns: list: List of book IDs in the same section as both input books in ascending order. Returns an empty list if any book ID is not present in the dictionary or the books are not in the same section.","solution":"def find_books_in_same_section(library, book_id1, book_id2): Given the identifiers of two books, returns a list of all book IDs located in the same section as these two books. Parameters: library (dict): Dictionary mapping each book ID to its full location path. book_id1 (str): The first book ID. book_id2 (str): The second book ID. Returns: list: List of book IDs in the same section as both input books in ascending order. Returns an empty list if any book ID is not present in the dictionary or the books are not in the same section. # Validate if both book IDs are present in the dictionary if book_id1 not in library or book_id2 not in library: return [] # Split the location path to get floor, section and shelf location1 = library[book_id1].split(\\" > \\") location2 = library[book_id2].split(\\" > \\") # Check if both books are in the same section if location1[:2] != location2[:2]: return [] same_section_books = [ book_id for book_id, location in library.items() if location.split(\\" > \\")[:2] == location1[:2] ] return sorted(same_section_books) # Test the function with example input # library = { # \\"B001\\": \\"1st Floor > A > Shelf 1\\", # \\"B002\\": \\"1st Floor > A > Shelf 2\\", # \\"B003\\": \\"1st Floor > B > Shelf 1\\", # \\"B004\\": \\"2nd Floor > C > Shelf 1\\", # \\"B005\\": \\"1st Floor > A > Shelf 3\\" # } # # book_id1 = \\"B001\\" # book_id2 = \\"B005\\" # # The function should return: [\\"B001\\", \\"B002\\", \\"B005\\"] # # book_id1 = \\"B001\\" # book_id2 = \\"B003\\" # # The function should return: []"},{"question":"def evaluate_postfix(expression: str) -> int: Evaluates a postfix (Reverse Polish Notation) expression. >>> evaluate_postfix(\\"3 4 + 2 * 7 /\\") == 2 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") == 14 >>> evaluate_postfix(\\"2 3 1 * + 9 -\\") == -4 >>> evaluate_postfix(\\"42\\") == 42 >>> evaluate_postfix(\\"10 5 -\\") == 5 >>> evaluate_postfix(\\"7 3 *\\") == 21 >>> evaluate_postfix(\\"8 2 /\\") == 4 >>> evaluate_postfix(\\"3 -4 +\\") == -1 >>> evaluate_postfix(\\"3 5 -\\") == -2","solution":"def evaluate_postfix(expression): Evaluates a postfix (Reverse Polish Notation) expression. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Integer division truncating towards zero else: stack.append(int(token)) return stack[0]"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams from the input list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: A list of grouped anagrams. Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] >>> group_anagrams([\\"Eat\\", \\"Tea\\", \\"tan\\", \\"Ate\\", \\"nat\\", \\"bat\\"]) [['Eat', 'Tea', 'Ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"bAt\\", \\"Tab\\", \\"bat\\"]) [[\\"bAt\\", \\"Tab\\", \\"bat\\"]]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams from the input list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: A list of grouped anagrams. anagrams = defaultdict(list) for word in words: # Sort the characters in the word and convert to lowercase sorted_word = ''.join(sorted(word.lower())) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"from typing import List def unique_permutations_without_consecutive(s: str) -> List[str]: Generates all unique permutations of the string \`s\` that do not contain consecutive identical characters. The result is sorted in lexicographical order. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[str]: A sorted list of unique permutations without consecutive identical characters. pass def test_example_1(): assert unique_permutations_without_consecutive(\\"aab\\") == [\\"aba\\"] def test_example_2(): assert unique_permutations_without_consecutive(\\"aaa\\") == [] def test_example_3(): assert unique_permutations_without_consecutive(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_single_character(): assert unique_permutations_without_consecutive(\\"a\\") == [\\"a\\"] def test_double_same_characters(): assert unique_permutations_without_consecutive(\\"aa\\") == [] def test_double_different_characters(): assert unique_permutations_without_consecutive(\\"ab\\") == [\\"ab\\", \\"ba\\"] def test_all_duplicates(): assert unique_permutations_without_consecutive(\\"bbbb\\") == [] def test_no_consecutive_identical(): assert unique_permutations_without_consecutive(\\"abcd\\") == [ \\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\" ]","solution":"from itertools import permutations def unique_permutations_without_consecutive(s): Generates all unique permutations of the string \`s\` that do not contain consecutive identical characters. unique_perms = set(permutations(s)) valid_perms = [] for perm in unique_perms: valid = True for i in range(1, len(perm)): if perm[i] == perm[i-1]: valid = False break if valid: valid_perms.append(\\"\\".join(perm)) return sorted(valid_perms)"},{"question":"def reverse_words(input_str: str) -> str: Reverses the order of words in a given string, removing any extra spaces. Parameters: input_str (str): The string of words separated by spaces. Returns: str: The string with the order of words reversed and extra spaces removed. >>> reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"Python\\") == \\"Python\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\"Hello WORLD\\") == \\"WORLD Hello\\"","solution":"def reverse_words(input_str): Reverses the order of words in a given string, removing any extra spaces. Parameters: input_str (str): The string of words separated by spaces. Returns: str: The string with the order of words reversed and extra spaces removed. # Split the string by spaces to get the words, automatically removing extra spaces words = input_str.split() # Reverse the list of words reversed_words = words[::-1] # Join the words back into a string with a single space result = ' '.join(reversed_words) return result"},{"question":"import sympy as sp def optimize_garden(): Calculate the optimal dimensions of the garden to maximize the total enclosed area. The garden is enclosed with fencing, and then subdivided into two rectangular plots. The total length of fencing available is 200 meters. Returns: (float, float, float): Optimal dimensions (length L, width W) and the maximum area. Examples: >>> L, W, max_area = optimize_garden() >>> (2 * L + 3 * W - 200).evalf() == 0 True >>> L > 0 True >>> W > 0 True >>> max_area > 0 True","solution":"import sympy as sp def optimize_garden(): L, W = sp.symbols('L W', real=True, positive=True) # Perimeter constraint perimeter_eq = 2 * L + 3 * W - 200 # Solve the perimeter constraint for L L_expr = sp.solve(perimeter_eq, L)[0] # Area expression A = L * W area_expr = L_expr * W # Take derivative of area with respect to W derivative_area = sp.diff(area_expr, W) # Solve the critical points, where the derivative is 0 critical_points = sp.solve(derivative_area, W) # Verify and select the critical point that maximizes the area second_derivative = sp.diff(derivative_area, W) max_area = 0 optimal_W = None optimal_L = None for w in critical_points: if second_derivative.subs(W, w) < 0: # Second derivative test for max L_val = L_expr.subs(W, w) area_val = area_expr.subs(W, w) if area_val > max_area: max_area = area_val optimal_W = w optimal_L = L_val return optimal_L.evalf(), optimal_W.evalf(), max_area.evalf() # Test the function optimize_garden()"},{"question":"def fibonacci(n): Generator function to yield the Fibonacci sequence up to the given number 'n'. >>> list(fibonacci(8)) [0, 1, 1, 2, 3, 5, 8] >>> list(fibonacci(0)) [0]","solution":"def fibonacci(n): Generator function to yield the Fibonacci sequence up to the given number 'n'. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") a, b = 0, 1 while a <= n: yield a a, b = b, a + b"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each element is replaced by the product of all the other integers in the original list, except the element at the current position. Do not use division in your solution. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([10]) [0] >>> product_except_self([]) [] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([2, 2, 2, 2]) [8, 8, 8, 8] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] ...","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] if n == 1: return [0] # product of empty set for single element res = [1] * n left = [1] * n right = [1] * n for i in range(1, n): left[i] = left[i - 1] * nums[i - 1] for i in reversed(range(n - 1)): right[i] = right[i + 1] * nums[i + 1] for i in range(n): res[i] = left[i] * right[i] return res"},{"question":"def max_profit(stock_prices): Returns the maximum profit that can be achieved by buying and selling one share of stock. If no profit can be made, returns 0. >>> max_profit([100]) 0 >>> max_profit([100, 90, 80, 70]) 0 >>> max_profit([100, 180, 260]) 160 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([7, 6, 4, 3, 1, 8]) 7","solution":"def max_profit(stock_prices): Returns the maximum profit that can be achieved by buying and selling one share of stock. If no profit can be made, returns 0. if not stock_prices or len(stock_prices) < 2: return 0 min_price = stock_prices[0] max_profit = 0 for price in stock_prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def string_with_max_length(strings: List[str]) -> str: Returns the string with the maximum length from the list of strings. If there are multiple strings with the same maximum length, the one appearing last is returned. If the list is empty, returns an appropriate message. >>> string_with_max_length([\\"hello\\"]) \\"hello\\" >>> string_with_max_length([\\"hi\\", \\"hello\\", \\"hey\\"]) \\"hello\\" >>> string_with_max_length([\\"abcd\\", \\"xyz\\", \\"abcd\\"]) \\"abcd\\" >>> string_with_max_length([]) \\"List is empty\\" >>> string_with_max_length([\\"a\\", \\" \\", \\"abc\\"]) \\"abc\\" >>> string_with_max_length([\\"one\\", \\"two\\", \\"six\\", \\"ten\\"]) \\"ten\\"","solution":"def string_with_max_length(strings): Returns the string with the maximum length from the list of strings. If there are multiple strings with the same maximum length, the one appearing last is returned. If the list is empty, returns an appropriate message. if not strings: return \\"List is empty\\" max_length = -1 result_string = \\"\\" for s in strings: if len(s) >= max_length: max_length = len(s) result_string = s return result_string"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if a binary tree is height-balanced. A height-balanced binary tree is defined as: A binary tree in which the depth of the two subtrees of every node never differs by more than 1. Input: root: TreeNode - The root of a binary tree. Output: bool - True if the binary tree is height-balanced, and False otherwise. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"def index_of_second_largest(nums: List[int]) -> int: Returns the index of the second largest element in the list of integers. If the second largest element does not exist, returns -1. >>> index_of_second_largest([3, 1, 4, 4, 5]) 2 >>> index_of_second_largest([1, 1, 1, 2]) 0 >>> index_of_second_largest([10, 15, 20, 5]) 1 >>> index_of_second_largest([4, 3, 2, 1]) 1 >>> index_of_second_largest([1]) -1 >>> index_of_second_largest([1, 1, 1, 1]) -1 >>> index_of_second_largest([-10, -20, -5]) 0 >>> index_of_second_largest([10, -20, 30, 5, 0]) 0 >>> index_of_second_largest([1, 2]) 0 >>> index_of_second_largest([2, 1]) 1 >>> index_of_second_largest([]) -1","solution":"def index_of_second_largest(nums): Returns the index of the second largest element in the list of integers. If the second largest element does not exist, returns -1. if len(nums) < 2: return -1 first = second = float('-inf') first_index = second_index = -1 for i, num in enumerate(nums): if num > first: second, second_index = first, first_index first, first_index = num, i elif first > num > second: second, second_index = num, i return second_index"},{"question":"def group_students_by_grade(student_info): Groups students by their grades, with names sorted alphabetically within each grade group. :param student_info: List of strings where each string is in the form \\"name:grade\\". :return: Dictionary with grades as keys and lists of student names as values. Example: >>> group_students_by_grade([\\"Alice:85\\", \\"Bob:90\\", \\"Charlie:85\\", \\"David:95\\", \\"Eve:85\\", \\"Frank:90\\"]) { '85': ['Alice', 'Charlie', 'Eve'], '90': ['Bob', 'Frank'], '95': ['David'] } >>> group_students_by_grade([\\"Eve:85\\", \\"Charlie:85\\", \\"Alice:85\\", \\"David:95\\", \\"Frank:90\\", \\"Bob:90\\"]) { '85': ['Alice', 'Charlie', 'Eve'], '90': ['Bob', 'Frank'], '95': ['David'] } >>> group_students_by_grade([]) {} >>> group_students_by_grade([\\"Alice:85\\"]) { '85': ['Alice'] }","solution":"def group_students_by_grade(student_info): Groups students by their grades, with names sorted alphabetically within each grade group. :param student_info: List of strings where each string is in the form \\"name:grade\\". :return: Dictionary with grades as keys and lists of student names as values. grade_dict = {} for info in student_info: name, grade = info.split(':') if grade not in grade_dict: grade_dict[grade] = [] grade_dict[grade].append(name) for grade in grade_dict: grade_dict[grade].sort() return grade_dict # Analysis of time complexity: # Suppose we have n students # - Splitting each string in the input list takes O(n) time # - Inserting each name into the dictionary takes O(1) time on average, for a total of O(n) time # - Sorting the names within each grade group takes O(k log k) time where k is the number of students in that particular grade group # If there are g unique grades, and assuming names are evenly distributed, then each sorting step approximates O((n/g) log(n/g)) # Overall, the dominant time complexity term is O(n log n) considering sorting of all names."},{"question":"def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a new list containing only the elements that are present in both lists. Each element in the resulting list appears only once. >>> list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4] >>> list_intersection([1, 2, 3], [4, 5, 6]) == [] >>> list_intersection([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3] >>> list_intersection([], [1, 2, 3]) == [] >>> list_intersection([1, 2, 3], []) == [] >>> list_intersection([], []) == [] >>> list_intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3]","solution":"def list_intersection(list1, list2): Returns a new list containing only the elements that are present in both list1 and list2. Each element in the resulting list appears only once. return list(set(list1).intersection(set(list2)))"},{"question":"def max_adjacent_product(nums): Identifies the largest product of any pair of adjacent elements in a given list of integers. Args: nums (List[int]): A list of integers. Returns: int: The largest product of any pair of adjacent elements. Raises: ValueError: If the list contains fewer than two elements. >>> max_adjacent_product([3, 6, -2, -5, 7, 3]) 21 >>> max_adjacent_product([1, 2]) 2 >>> max_adjacent_product([0, 0, 0, 0]) 0 >>> max_adjacent_product([1000, 100, 10, 100000, 100]) 10000000 from solution import max_adjacent_product import pytest def test_max_adjacent_product_with_positive_numbers(): assert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21 def test_max_adjacent_product_with_mixed_numbers(): assert max_adjacent_product([1, 2, 3, 4, -1, 6, 7, -8, 9]) == 42 def test_max_adjacent_product_with_all_negative_numbers(): assert max_adjacent_product([-1, -2, -3, -4, -5]) == 20 def test_max_adjacent_product_with_all_zeros(): assert max_adjacent_product([0, 0, 0, 0]) == 0 def test_max_adjacent_product_with_single_pair(): assert max_adjacent_product([1, 2]) == 2 def test_max_adjacent_product_with_large_integers(): assert max_adjacent_product([1000, 100, 10, 100000, 100]) == 10000000 def test_max_adjacent_product_error_with_fewer_than_two_elements(): with pytest.raises(ValueError): max_adjacent_product([5]) def test_max_adjacent_product_with_pairs_negative_zero(): assert max_adjacent_product([-4, -2, 0, 3]) == 8","solution":"def max_adjacent_product(nums): Returns the largest product of any pair of adjacent elements in the given list of integers. if len(nums) < 2: raise ValueError(\\"List must contain at least two elements\\") max_product = nums[0] * nums[1] for i in range(1, len(nums) - 1): product = nums[i] * nums[i + 1] if product > max_product: max_product = product return max_product # Explanation: # The provided code does not correctly handle cases when all products are negative or when the largest # product is negative but the initial max_product is set to 0, which can incorrectly influence the # result. The corrected version initializes max_product to the product of the first pair of adjacent # elements to correctly handle all possible cases."},{"question":"def get_second_largest(numbers): Return the second largest unique number in the list. If the list is empty or contains less than 2 unique numbers, return None. >>> get_second_largest([1, 2, 3, 4, 5]) == 4 >>> get_second_largest([1, 2, 3, 4, 4, 4]) == 3 >>> get_second_largest([]) == None >>> get_second_largest([5]) == None >>> get_second_largest([2, 2, 2, 2]) == None >>> get_second_largest([-1, -2, -3, -4]) == -2 >>> get_second_largest([3, 10, 3, 6, 7, 10]) == 7","solution":"def get_second_largest(numbers): if not numbers: return None unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"import json import requests def fetch_and_parse(api_url, key): Fetches data from a given API endpoint, and parses the JSON response to extract and return the values of a specified key. If the key is not present, returns an empty list. Handles exceptions for network errors and invalid JSON responses gracefully. :param api_url: str, URL of the API endpoint :param key: str, Key whose values need to be extracted from the JSON response :return: list, Values associated with the specified key, or None in case of error >>> fetch_and_parse('http://valid.url', 'key') == [1, 2, 3] >>> fetch_and_parse('http://valid.url', 'missing_key') == [] >>> fetch_and_parse('http://invalid.json.url', 'key') is None >>> fetch_and_parse('http://network.error.url', 'key') is None","solution":"import json import requests def fetch_and_parse(api_url, key): Fetches data from a given API endpoint, and parses the JSON response to extract and return the values of a specified key. :param api_url: str, URL of the API endpoint :param key: str, Key whose values need to be extracted from the JSON response :return: list, Values associated with the specified key try: response = requests.get(api_url) response.raise_for_status() # Raises HTTPError for bad responses data = response.json() # Takes the JSON-encoded content of a response if key not in data: return [] return data[key] except requests.exceptions.RequestException as e: print(f\\"Request error: {e}\\") return None except json.JSONDecodeError as e: print(f\\"JSON decode error: {e}\\") return None"},{"question":"def reverse_and_capitalize(sentence: str) -> str: This function reverses the order of the words in the given sentence, capitalizes the first letter of each word, and removes any extra spaces between words. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The modified string with words reversed, capitalized, and extra spaces removed. >>> reverse_and_capitalize(\\"hello\\") \\"Hello\\" >>> reverse_and_capitalize(\\"hello world\\") \\"World Hello\\" >>> reverse_and_capitalize(\\" hello world \\") \\"World Hello\\" >>> reverse_and_capitalize(\\"HELLO WORLD\\") \\"World Hello\\" >>> reverse_and_capitalize(\\"HeLLo WoRLd\\") \\"World Hello\\" >>> reverse_and_capitalize(\\"\\") \\"\\" >>> reverse_and_capitalize(\\" \\") \\"\\"","solution":"def reverse_and_capitalize(sentence): This function reverses the order of the words in the given sentence, capitalizes the first letter of each word, and removes any extra spaces between words. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The modified string with words reversed, capitalized, and extra spaces removed. words = sentence.split(' ') reversed_words = [] for word in words: if word.strip(): # Skip empty strings resulting from extra spaces reversed_words.insert(0, word.strip().capitalize()) return ' '.join(reversed_words)"},{"question":"class SimpleTextEditor: def __init__(self): self.text_buffer = \\"\\" self.history = [] def add_text(self, text): Appends the given text to the current text buffer. def delete_text(self, n): Deletes the last 'n' characters from the current text buffer. If 'n' is greater than the length of the current text buffer, it clears the entire buffer. def undo(self): Reverts the text buffer to the state before the last operation. def get_text(self): Returns the current state of the text buffer. return self.text_buffer # Example test cases def test_add_text(): editor = SimpleTextEditor() editor.add_text(\\"hello\\") assert editor.get_text() == \\"hello\\" editor.add_text(\\" world\\") assert editor.get_text() == \\"hello world\\" def test_delete_text(): editor = SimpleTextEditor() editor.add_text(\\"hello world\\") editor.delete_text(5) assert editor.get_text() == \\"hello \\" editor.delete_text(10) assert editor.get_text() == \\"\\" def test_undo_addition(): editor = SimpleTextEditor() editor.add_text(\\"hello\\") editor.add_text(\\" world\\") editor.undo() assert editor.get_text() == \\"hello\\" editor.undo() assert editor.get_text() == \\"\\" def test_undo_deletion(): editor = SimpleTextEditor() editor.add_text(\\"hello world\\") editor.delete_text(5) editor.undo() assert editor.get_text() == \\"hello world\\" editor.delete_text(11) editor.undo() assert editor.get_text() == \\"hello world\\" def test_mixed_operations(): editor = SimpleTextEditor() editor.add_text(\\"hello\\") editor.add_text(\\" world\\") assert editor.get_text() == \\"hello world\\" editor.delete_text(6) assert editor.get_text() == \\"hello\\" editor.undo() assert editor.get_text() == \\"hello world\\" editor.undo() assert editor.get_text() == \\"hello\\" editor.undo() assert editor.get_text() == \\"\\"","solution":"class SimpleTextEditor: def __init__(self): self.text_buffer = \\"\\" self.history = [] def add_text(self, text): Appends the given text to the current text buffer and records the operation in the history stack. self.history.append((self.text_buffer,)) self.text_buffer += text def delete_text(self, n): Deletes the last 'n' characters from the current text buffer and records the operation in the history stack. If 'n' is greater than the length of the current text buffer, it clears the entire buffer. self.history.append((self.text_buffer,)) self.text_buffer = self.text_buffer[:-n] def undo(self): Reverts the text buffer to the state before the last operation. if self.history: self.text_buffer = self.history.pop()[0] def get_text(self): Returns the current state of the text buffer. return self.text_buffer"},{"question":"class VendingMachine: A class to simulate a vending machine. Attributes: inventory (dict): Dictionary of items in the vending machine. money_inserted (float): Total amount of money inserted by the user. selected_item (dict): Currently selected item. Methods: display_items(): Displays available items. select_item(code): Selects an item based on the code. insert_money(amount): Inserts money into the machine. dispense_item(): Dispenses the selected item if enough money is inserted. cancel_transaction(): Cancels the transaction and returns inserted money. def __init__(self, inventory): Initializes the vending machine with an inventory of items. pass def display_items(self): Displays the items available in the vending machine. pass def select_item(self, code): Allows the user to select an item by its code. pass def insert_money(self, amount): Allows the user to insert money. pass def dispense_item(self): Dispenses the selected item if sufficient money has been inserted. pass def cancel_transaction(self): Cancels the ongoing transaction and returns inserted money. pass","solution":"class VendingMachine: def __init__(self, inventory): Initializes the vending machine with an inventory of items. Each item is a dictionary with 'name', 'price', 'code', and 'stock'. self.inventory = {item['code']: item for item in inventory} self.money_inserted = 0.0 self.selected_item = None def display_items(self): Displays the items available in the vending machine. for item in self.inventory.values(): print(f\\"Code: {item['code']}, Name: {item['name']}, Price: {item['price']:.2f}, Stock: {item['stock']}\\") def select_item(self, code): Allows the user to select an item by its code. if code not in self.inventory: raise ValueError(\\"Invalid item code\\") item = self.inventory[code] if item['stock'] <= 0: raise ValueError(f\\"Item {item['name']} is out of stock\\") self.selected_item = item print(f\\"Selected item: {self.selected_item['name']}\\") def insert_money(self, amount): Allows the user to insert money. if amount <= 0: raise ValueError(\\"Inserted amount must be greater than zero\\") self.money_inserted += amount print(f\\"Inserted money: {self.money_inserted:.2f}\\") def dispense_item(self): Dispenses the selected item if sufficient money has been inserted. if not self.selected_item: raise ValueError(\\"No item selected\\") item_price = self.selected_item['price'] if self.money_inserted < item_price: shortfall = item_price - self.money_inserted print(f\\"Insufficient money. Insert {shortfall:.2f} more.\\") return self.inventory[self.selected_item['code']]['stock'] -= 1 change = self.money_inserted - item_price self.money_inserted = 0.0 dispensed_item = self.selected_item self.selected_item = None print(f\\"Dispensed: {dispensed_item['name']}\\") if change > 0: print(f\\"Return change: {change:.2f}\\") return dispensed_item['name'], change def cancel_transaction(self): Cancels the ongoing transaction and returns inserted money. change = self.money_inserted self.money_inserted = 0.0 self.selected_item = None print(f\\"Transaction canceled. Return money: {change:.2f}\\") return change"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given positive integer n recursively. The function takes a single argument n (0 ≤ n ≤ 10) and returns the factorial of n. If n equals 0, the factorial is defined as 1. Ensure to handle the base case in your recursion to prevent infinite loops or errors. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 >>> factorial(5) 120 >>> factorial(6) 720 >>> factorial(7) 5040 >>> factorial(8) 40320 >>> factorial(9) 362880 >>> factorial(10) 3628800","solution":"def factorial(n): Returns the factorial of a given positive integer n using recursion. if n == 0: return 1 else: return n * factorial(n - 1)"},{"question":"import sqlite3 def get_products_above_threshold(threshold): Retrieves all items from the 'products' table that have a quantity greater than the specified threshold. Parameters: - threshold (int): The quantity threshold. Returns: - list of dicts: A list of dictionaries containing the product details with keys 'id', 'name', 'quantity', and 'price'. pass import pytest @pytest.fixture def setup_database(): connection = sqlite3.connect('inventory.db') cursor = connection.cursor() # Create the products table cursor.execute(''' CREATE TABLE products ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, quantity INTEGER NOT NULL, price REAL NOT NULL ) ''') # Insert some sample data products = [ (1, 'Product A', 50, 29.99), (2, 'Product B', 20, 19.99), (3, 'Product C', 75, 39.99), (4, 'Product D', 10, 9.99) ] cursor.executemany('INSERT INTO products (id, name, quantity, price) VALUES (?, ?, ?, ?)', products) connection.commit() yield # Teardown database cursor.execute('DROP TABLE products') connection.commit() connection.close() def test_get_products_above_threshold(setup_database): products = get_products_above_threshold(30) assert len(products) == 2 assert products[0]['name'] == 'Product A' assert products[1]['name'] == 'Product C' def test_get_products_above_threshold_than_large_value(setup_database): products = get_products_above_threshold(100) assert len(products) == 0 def test_get_products_above_threshold_all_match(setup_database): products = get_products_above_threshold(5) assert len(products) == 4 def test_get_products_above_threshold_only_one(setup_database): products = get_products_above_threshold(70) assert len(products) == 1 assert products[0]['name'] == 'Product C'","solution":"import sqlite3 def get_products_above_threshold(threshold): Retrieves all items from the 'products' table that have a quantity greater than the specified threshold. Parameters: - threshold (int): The quantity threshold. Returns: - list of dicts: A list of dictionaries containing the product details with keys 'id', 'name', 'quantity', and 'price'. connection = sqlite3.connect('inventory.db') cursor = connection.cursor() query = SELECT id, name, quantity, price FROM products WHERE quantity > ? cursor.execute(query, (threshold,)) rows = cursor.fetchall() # Convert the result to a list of dictionaries products = [] for row in rows: product = { 'id': row[0], 'name': row[1], 'quantity': row[2], 'price': row[3] } products.append(product) # Close the connection cursor.close() connection.close() return products"},{"question":"def transform_list(nums: list) -> list: Transforms the list such that elements at even indices are multiplied by two and elements at odd indices are replaced by their negation. Examples: >>> transform_list([1]) [2] >>> transform_list([-1]) [-2] >>> transform_list([1, 2]) [2, -2] >>> transform_list([0, 5]) [0, -5] >>> transform_list([1, 2, 3, 4, 5, 6]) [2, -2, 6, -4, 10, -6] >>> transform_list([-1, -2, -3, -4, -5, -6]) [-2, 2, -6, 4, -10, 6] >>> transform_list([100, -100, 200, -200]) [200, 100, 400, 200] >>> transform_list([1, -2, 3, -4]) [2, 2, 6, 4] >>> transform_list([-1, 2, -3, 4]) [-2, -2, -6, -4]","solution":"def transform_list(nums: list) -> list: Transforms the list such that elements at even indices are multiplied by two and elements at odd indices are replaced by their negation. transformed = [] for i, num in enumerate(nums): if i % 2 == 0: transformed.append(num * 2) else: transformed.append(-num) return transformed"},{"question":"def findMajorityElement(nums: List[int]) -> int: Returns the majority element that appears more than 50% of the time in the array \`nums\`. If no such element exists, returns None. >>> findMajorityElement([3, 2, 3]) 3 >>> findMajorityElement([2, 2, 1, 1, 1, 2, 2]) 2 >>> findMajorityElement([1, 2, 3, 4]) None","solution":"def findMajorityElement(nums): Returns the majority element that appears more than 50% of the time in the array \`nums\`. If no such element exists, returns None. if not nums: return None count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify the candidate if nums.count(candidate) > len(nums) // 2: return candidate else: return None"},{"question":"import pandas as pd import numpy as np def correct_skewed_features(df, skew_threshold=1.0): Identifies numerical columns in the DataFrame with skewness above the given threshold and applies a log transformation to reduce the skewness. Returns the summary statistics of the skewed features before and after the transformation. Parameters: df (pd.DataFrame): The input DataFrame. skew_threshold (float): The skewness threshold above which log transformation is applied. Returns: pd.DataFrame: Summary statistics of the skewed features before transformation. pd.DataFrame: Summary statistics of the skewed features after transformation. Example: >>> data = { >>> 'normal_dist': np.random.normal(loc=0, scale=1, size=1000), >>> 'skewed_dist': np.random.exponential(scale=2, size=1000) >>> } >>> df = pd.DataFrame(data) >>> before_trans, after_trans = correct_skewed_features(df, skew_threshold=1.0)","solution":"import pandas as pd import numpy as np def correct_skewed_features(df, skew_threshold=1.0): Identifies numerical columns in the DataFrame with skewness above the given threshold and applies a log transformation to reduce the skewness. Returns the summary statistics of the skewed features before and after the transformation. Parameters: df (pd.DataFrame): The input DataFrame. skew_threshold (float): The skewness threshold above which log transformation is applied. Returns: pd.DataFrame: Summary statistics of the skewed features before transformation. pd.DataFrame: Summary statistics of the skewed features after transformation. skewed_cols = df.select_dtypes(include=[np.number]).apply(lambda x: x.skew()).abs() skewed_cols = skewed_cols[skewed_cols > skew_threshold].index if len(skewed_cols) == 0: return pd.DataFrame(), pd.DataFrame() before_transformation = df[skewed_cols].describe().transpose() # Apply log transformation to skewed columns df[skewed_cols] = df[skewed_cols].apply(lambda x: np.log1p(x)) after_transformation = df[skewed_cols].describe().transpose() return before_transformation, after_transformation"},{"question":"from typing import List def findLongestConsecutiveSequence(nums: List[int]) -> int: Given an array of integers, find the length of the longest consecutive sequence of elements. Consecutive elements can be in any order but must be consecutive numbers. You must solve it with a time complexity of O(n). Example: >>> findLongestConsecutiveSequence([100, 4, 200, 1, 3, 2]) 4 >>> findLongestConsecutiveSequence([]) 0 >>> findLongestConsecutiveSequence([5]) 1 >>> findLongestConsecutiveSequence([7, 8]) 2 >>> findLongestConsecutiveSequence([1, 2, 2, 3, 4]) 4 >>> findLongestConsecutiveSequence([10, 1, 3, 5, 2, 4]) 5 >>> findLongestConsecutiveSequence([-1, -2, -3, -4, 1, 2, 3]) 4","solution":"def findLongestConsecutiveSequence(nums): Returns the length of the longest consecutive sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Check if the number is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Determine if a word exists in a 2D grid of characters. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> board = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> exist(board, \\"ABCCED\\") True >>> exist(board, \\"SEE\\") True >>> exist(board, \\"ABCB\\") False","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) def backtrack(r: int, c: int, suffix: str) -> bool: if len(suffix) == 0: return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != suffix[0]: return False ret = False board[r][c] = \\"#\\" for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ret = backtrack(r + row_offset, c + col_offset, suffix[1:]) if ret: break board[r][c] = suffix[0] return ret for row in range(rows): for col in range(cols): if backtrack(row, col, word): return True return False"},{"question":"from typing import List def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are common to both input lists without any duplicates. >>> sorted(common_elements([1, 2, 2, 3, 4], [3, 4, 4, 5, 6])) == [3, 4] >>> common_elements([1, 2, 3], [4, 5, 6]) == [] >>> sorted(common_elements([10, 20, 30, 40], [30, 40, 50, 60])) == [30, 40] >>> common_elements([], [1, 2, 3]) == [] >>> common_elements([1, 2, 3], []) == [] >>> common_elements([], []) == [] >>> sorted(common_elements([7, 8, 9], [9, 8])) == [8, 9]","solution":"def common_elements(list1, list2): Returns a list of integers that are common to both input lists without any duplicates. set1 = set(list1) set2 = set(list2) common = set1 & set2 return list(common)"},{"question":"class InventoryManager: A class to simulate the inventory management system of a small retail store. Methods: add_item(name: str, quantity: int, price: float) -> None remove_item(name: str) -> None view_inventory() -> Dict[str, Dict[str, float]] total_inventory_value() -> float >>> inv_manager = InventoryManager() >>> inv_manager.add_item(\\"apple\\", 10, 0.5) >>> inv_manager.add_item(\\"banana\\", 15, 0.3) >>> inv_manager.view_inventory() {'apple': {'quantity': 10, 'price': 0.5}, 'banana': {'quantity': 15, 'price': 0.3}} >>> inv_manager.remove_item(\\"apple\\") >>> inv_manager.view_inventory() {'banana': {'quantity': 15, 'price': 0.3}} >>> inv_manager.total_inventory_value() 4.5 def __init__(self): self.inventory = {} def add_item(self, name, quantity, price): pass def remove_item(self, name): pass def view_inventory(self): pass def total_inventory_value(self): pass # Test cases def test_add_item(): inv_manager = InventoryManager() inv_manager.add_item(\\"apple\\", 10, 0.5) assert inv_manager.view_inventory() == {\\"apple\\": {\\"quantity\\": 10, \\"price\\": 0.5}} def test_remove_item(): inv_manager = InventoryManager() inv_manager.add_item(\\"apple\\", 10, 0.5) inv_manager.remove_item(\\"apple\\") assert inv_manager.view_inventory() == {} def test_total_inventory_value(): inv_manager = InventoryManager() inv_manager.add_item(\\"apple\\", 10, 0.5) inv_manager.add_item(\\"orange\\", 20, 0.75) assert inv_manager.total_inventory_value() == 20 * 0.75 + 10 * 0.5 def test_view_inventory(): inv_manager = InventoryManager() inv_manager.add_item(\\"apple\\", 10, 0.5) inv_manager.add_item(\\"banana\\", 15, 0.3) expected_inventory = { \\"apple\\": {\\"quantity\\": 10, \\"price\\": 0.5}, \\"banana\\": {\\"quantity\\": 15, \\"price\\": 0.3} } assert inv_manager.view_inventory() == expected_inventory def test_add_item_increase_quantity(): inv_manager = InventoryManager() inv_manager.add_item(\\"apple\\", 10, 0.5) inv_manager.add_item(\\"apple\\", 5, 0.5) expected_inventory = { \\"apple\\": {\\"quantity\\": 15, \\"price\\": 0.5} } assert inv_manager.view_inventory() == expected_inventory","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, name, quantity, price): if name in self.inventory: self.inventory[name][\\"quantity\\"] += quantity else: self.inventory[name] = {\\"quantity\\": quantity, \\"price\\": price} def remove_item(self, name): if name in self.inventory: del self.inventory[name] def view_inventory(self): return self.inventory def total_inventory_value(self): total_value = 0 for item in self.inventory.values(): total_value += item[\\"quantity\\"] * item[\\"price\\"] return total_value # Example usage: # Create InventoryManager object inv_manager = InventoryManager() # Add items inv_manager.add_item(\\"apple\\", 10, 0.5) inv_manager.add_item(\\"orange\\", 20, 0.75) # Remove an item inv_manager.remove_item(\\"apple\\") # Get total inventory value print(inv_manager.total_inventory_value()) # Output: 15.00"},{"question":"def filter_and_square_evens(lst: list) -> list: Filters out the string elements from the input list and returns a new list containing the squared values of the even integers from the original list. Parameters: lst (list): A list of mixed integer and string elements. Returns: list: A list containing the squared values of the even integers from the original list. >>> filter_and_square_evens([1, 'a', 2, 'b', 3, 4, 5, 'c']) [4, 16] >>> filter_and_square_evens(['a', 'b', 'c']) [] >>> filter_and_square_evens([1, 3, 5, 'x', 'y']) [] >>> filter_and_square_evens([2, 4, 6, 8]) [4, 16, 36, 64] >>> filter_and_square_evens([]) [] >>> filter_and_square_evens([10, 11, 'twleve', 13, 14, 'fifteen']) [100, 196]","solution":"def filter_and_square_evens(lst): Filters out the string elements from the input list and returns a new list containing the squared values of the even integers from the original list. Parameters: lst (list): A list of mixed integer and string elements. Returns: list: A list containing the squared values of the even integers from the original list. return [x**2 for x in lst if isinstance(x, int) and x % 2 == 0]"},{"question":"def merge_dictionaries(input_list: List[Dict[str, Any]], key_name: str) -> List[Dict[str, Any]]: Merge dictionaries in the input list based on the specified key. If multiple dictionaries have the same value for the key, their non-key values are combined into a list. Args: input_list (list): List of dictionaries. key_name (str): The key name to merge dictionaries by. Returns: list: A new list of dictionaries with merged results. >>> merge_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}, {'id': 1, 'value': 'c'}], 'id') [{'id': 1, 'value': ['a', 'c']}, {'id': 2, 'value': ['b']}] >>> merge_dictionaries([], 'id') [] >>> merge_dictionaries([{'id': 1, 'value': 'a'}], 'id') [{'id': 1, 'value': ['a']}] >>> merge_dictionaries([{'id': 1, 'value': 'a'}, {'id': 2, 'value': 'b'}], 'id') [{'id': 1, 'value': ['a']}, {'id': 2, 'value': ['b']}] >>> merge_dictionaries([{'id': 1, 'value': 'a', 'type': 'alpha'}, {'id': 2, 'value': 'b', 'type': 'beta'}, {'id': 1, 'value': 'c', 'type': 'gamma'}], 'id') [{'id': 1, 'value': ['a', 'c'], 'type': ['alpha', 'gamma']}, {'id': 2, 'value': ['b'], 'type': ['beta']}] >>> merge_dictionaries([{'name': 'Alice', 'value': 'x'}, {'name': 'Bob', 'value': 'y'}, {'name': 'Alice', 'value': 'z'}], 'name') [{'name': 'Alice', 'value': ['x', 'z']}, {'name': 'Bob', 'value': ['y']}]","solution":"def merge_dictionaries(input_list, key_name): Merge dictionaries in the input list based on the specified key. If multiple dictionaries have the same value for the key, their non-key values are combined into a list. Args: input_list (list): List of dictionaries. key_name (str): The key name to merge dictionaries by. Returns: list: A new list of dictionaries with merged results. if not input_list: return [] merged_dict = {} for item in input_list: key_value = item[key_name] if key_value not in merged_dict: merged_dict[key_value] = {k: [v] for k, v in item.items() if k != key_name} else: for k, v in item.items(): if k != key_name: merged_dict[key_value][k].append(v) return [{key_name: k, **{nk: nv for nk, nv in v.items()}} for k, v in merged_dict.items()]"},{"question":"from typing import List, Dict def find_keys_with_multiples(input_dict: Dict[int, List[int]]) -> List[int]: Identifies all keys whose list contains at least one number that is a multiple of that key. Returns a sorted list of these keys in ascending order. >>> find_keys_with_multiples({2: [3, 4, 5, 8], 3: [6, 9, 2, 3], 5: [10, 15, 20], 7: [8, 14, 21]}) == [2, 3, 5, 7] >>> find_keys_with_multiples({2: [3, 5, 7], 3: [1, 2, 4], 5: [1, 2, 3], 7: [1, 2, 3]}) == [] >>> find_keys_with_multiples({2: [2, 4, 6, 8], 3: [3, 6, 9], 5: [5, 10, 15], 4: [4, 8, 12]}) == [2, 3, 4, 5] >>> find_keys_with_multiples({6: [7, 12, 18], 8: [16, 5, 6], 10: [5, 3, 20], 9: [7, 15]}) == [6, 8, 10] >>> find_keys_with_multiples({}) == []","solution":"def find_keys_with_multiples(input_dict): Identifies all keys whose list contains at least one number that is a multiple of that key. Returns a sorted list of these keys in ascending order. result_keys = [] for key, values in input_dict.items(): if any(value % key == 0 for value in values): result_keys.append(key) return sorted(result_keys)"}]`),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},I={class:"search-container"},S={class:"card-container"},B={key:0,class:"empty-state"},D=["disabled"],N={key:0},z={key:1};function j(i,e,l,m,n,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",I,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):u("",!0)]),t("div",S,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",B,' No results found for "'+d(n.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(s(),r("span",z,"Loading...")):(s(),r("span",N,"See more"))],8,D)):u("",!0)])}const P=_(F,[["render",j],["__scopeId","data-v-a4d886e3"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/24.md","filePath":"grok/24.md"}'),M={name:"grok/24.md"},G=Object.assign(M,{setup(i){return(e,l)=>(s(),r("div",null,[k(P)]))}});export{O as __pageData,G as default};
