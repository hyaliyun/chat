import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const N=c(k,[["render",A],["__scopeId","data-v-e6a8940f"]]),O=JSON.parse('[{"question":"# Coding Assessment: Enhanced Path Splitter Function Objective Write a function to split a given file path or URL into its directory part and file name part. The function should handle different path delimiters used in various operating systems (both forward slashes `/` and backslashes ``). Input * A string representing the file path or URL. Output * A list containing two strings: 1. Directory part of the path. 2. File name part of the path. Constraints * The input path will be a non-empty string. * The path may contain any combination of forward slashes (`/`) and backslashes (``). * Assume the path follows standard conventions for directories and filenames. Requirements * Your solution should: * Efficiently handle paths with mixed delimiters. * Correctly manage edge cases, including paths ending with a delimiter and single filenames with no directory component. * Perform with a time complexity of O(n) and space complexity of O(n), where n is the length of the input string. # Examples: 1. For an input path: ``` \\"C:UsersDocumentsreport.txt\\" ``` Your function should output: ```python [\\"C:UsersDocuments\\", \\"report.txt\\"] ``` 2. For an input path: ``` \\"https://example.com/files/sample.pdf\\" ``` Your function should output: ```python [\\"https://example.com/files\\", \\"sample.pdf\\"] ``` 3. For an input path: ``` \\"filename\\" ``` Your function should output: ```python [\\"\\", \\"filename\\"] ``` Function Signature ```python def enhanced_split(path: str) -> list: pass ``` Implement the `enhanced_split` function to satisfy the above requirements.","solution":"def enhanced_split(path: str) -> list: Splits the given path into directory part and file name part. Args: path (str): The file path or URL to split. Returns: list: A list containing the directory part and the file name part. if not path: return [\\"\\", \\"\\"] # Normalize the path by replacing backslashes with forward slashes normalized_path = path.replace(\'\', \'/\') # Find the last slash last_slash_index = normalized_path.rfind(\'/\') # Extract directory and filename if last_slash_index == -1: # No slashes found; the whole path is the filename directory = \\"\\" filename = path else: directory = path[:last_slash_index] filename = path[last_slash_index + 1:] return [directory, filename]"},{"question":"# Context You are tasked with creating and manipulating symbolic algebraic expressions in the form of polynomials. This involves working with individual monomials and polynomials, supporting operations such as addition, subtraction, multiplication, division, and variable substitution. # Objective Implement two new operations for polynomials: 1. **Monomial Multiplication with Power**: Implement a method to multiply a monomial by itself for a given number of times (i.e., raising it to a power). Ensure it handles edge cases like zero power and negative powers appropriately. 2. **Simplify Polynomial**: Implement a method that combines like terms in a polynomial post any operation to enhance performance and correctness. This method should consolidate monomials having the same variables and powers into a single term. # Function Specifications 1. `Monomial.__pow__(self, power: int) -> Monomial`: - **Input**: - `power` (int): The exponent to which the monomial should be raised. - **Output**: - Returns a new `Monomial` instance representing the monomial raised to the given power. - **Constraints**: - The power should be an integer. - Handle edge cases like zero and negative powers appropriately. - **Example**: ```python Monomial({1: 2}, 3) ** 3 -> Monomial({1: 6}, 27) ``` 2. `Polynomial.simplify(self) -> Polynomial`: - **Input**: None. - **Output**: - Returns a new `Polynomial` instance that consolidates like terms (monomials with the same variables and powers) into a single term. - **Constraints**: - Only merge terms that are exactly like. - Handle polynomials with zero terms appropriately. - **Example**: ```python Polynomial([Monomial({1: 2}, 3), Monomial({1: 2}, 4)]) -> Polynomial([Monomial({1: 2}, 7)]) ``` # Your Task 1. Implement the `__pow__` method in the `Monomial` class. 2. Implement the `simplify` method in the `Polynomial` class. 3. Write appropriate unit tests to ensure the correctness including edge cases.","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # dictionary representing variables and their exponents (e.g., {1: 2} for x1^2) self.coefficient = coefficient # coefficient of the monomial def __pow__(self, power): if power < 0: raise ValueError(\\"Negative powers are not supported for monomials.\\") if power == 0: return Monomial({}, 1) # Any monomial to the power of 0 is 1 new_exponents = {var: exp * power for var, exp in self.exponents.items()} new_coefficient = self.coefficient ** power return Monomial(new_exponents, new_coefficient) def __repr__(self): return f\'Monomial({self.exponents}, {self.coefficient})\' class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial instances def simplify(self): simplified_terms = {} for monomial in self.monomials: exp_tuple = tuple(sorted(monomial.exponents.items())) if exp_tuple in simplified_terms: simplified_terms[exp_tuple].coefficient += monomial.coefficient else: simplified_terms[exp_tuple] = Monomial(dict(monomial.exponents), monomial.coefficient) # Remove monomials with a coefficient of zero self.monomials = [monomial for monomial in simplified_terms.values() if monomial.coefficient != 0] return self def __repr__(self): return f\'Polynomial({self.monomials})\'"},{"question":"Enhanced Path-Finding Objective Given an undirected, unweighted graph represented as an adjacency list, implement a function that finds all the unique shortest paths between a pair of nodes. Function Signature ```python def find_all_shortest_paths(graph: dict, start: str, end: str) -> list: Finds all unique shortest paths between start and end nodes in an undirected graph. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (str): The starting node. end (str): The ending node. Returns: list: A list of lists, each containing a unique shortest path from start to end. Example: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\', \'G\'], \'D\': [\'B\'], \'E\': [\'B\', \'H\'], \'F\': [\'C\'], \'G\': [\'C\'], \'H\': [\'E\'] } find_all_shortest_paths(graph, \'A\', \'H\') should return [[\'A\', \'B\', \'E\', \'H\']] pass ``` Constraints 1. The graph is undirected and unweighted. 2. If no path exists, return an empty list. 3. The input graph may contain cycles. 4. Node names are unique and represented as strings. 5. The solution should efficiently handle graphs with up to 100 nodes. Performance Requirements The algorithm should be optimized to avoid redundant recursive calls and infinite loops in cyclical graphs. Utilize appropriate data structures to ensure that the solution is optimized for both time and space. Additional Context This problem simulates a real-world application of routing in networks, where multiple shortest paths may need to be considered to ensure redundancy and reliability.","solution":"from collections import deque def find_all_shortest_paths(graph: dict, start: str, end: str) -> list: Finds all unique shortest paths between start and end nodes in an undirected graph. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (str): The starting node. end (str): The ending node. Returns: list: A list of lists, each containing a unique shortest path from start to end. Example: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\', \'G\'], \'D\': [\'B\'], \'E\': [\'B\', \'H\'], \'F\': [\'C\'], \'G\': [\'C\'], \'H\': [\'E\'] } find_all_shortest_paths(graph, \'A\', \'H\') should return [[\'A\', \'B\', \'E\', \'H\']] def bfs_paths(graph, start, end): queue = deque([(start, [start])]) visited = {start: 0} # Node to distance mapping shortest_paths = [] shortest_length = float(\'inf\') while queue: node, path = queue.popleft() if len(path) > shortest_length: continue for neighbor in graph.get(node, []): if neighbor not in path: new_path = path + [neighbor] if neighbor == end: if len(new_path) < shortest_length: shortest_paths = [new_path] shortest_length = len(new_path) elif len(new_path) == shortest_length: shortest_paths.append(new_path) elif len(new_path) <= shortest_length: queue.append((neighbor, new_path)) return shortest_paths return bfs_paths(graph, start, end)"},{"question":"Josephus Sequence Generator **Scenario**: In a historical simulation, soldiers are seated in a circle. Every k-th soldier is eliminated in a sequence until only one soldier remains. This problem models that elimination process. **Task**: Implement a function to generate and return the sequence of eliminated soldiers. **Function Signature**: ```python def josephus_sequence(n: int, k: int) -> List[int]: pass ``` # Input * `n (int)`: The number of soldiers (n > 0) * `k (int)`: Specifies that every k-th person is eliminated (k > 0) # Output * `List[int]`: A list representing the order of eliminations until all soldiers are removed. # Example ```python assert josephus_sequence(7, 3) == [3, 6, 2, 7, 5, 1, 4] ``` # Constraints & Performance Requirements * Handle up to 10,000 soldiers efficiently. * Avoid using excessive extra memory. # Notes 1. Ensure your solution works for small and large values of `n`. 2. Consider modular arithmetic for circular iterations.","solution":"from typing import List def josephus_sequence(n: int, k: int) -> List[int]: Generates and returns the sequence of eliminated soldiers in the Josephus problem. :param n: Number of soldiers :param k: Every k-th soldier will be eliminated :return: List of soldiers in the order they are eliminated soldiers = list(range(1, n + 1)) elimination_sequence = [] index = 0 while soldiers: index = (index + k - 1) % len(soldiers) elimination_sequence.append(soldiers.pop(index)) return elimination_sequence"},{"question":"**Objective**: Write a function that takes two binary trees and checks if they are identical in structure and node values. This function should be implemented using an iterative approach. **Function Signature**: ```python def is_same_tree_iterative(tree_p, tree_q): pass ``` **Input**: - `tree_p`: The root node of the first binary tree (instance of `TreeNode` or `None` for an empty tree). - `tree_q`: The root node of the second binary tree (instance of `TreeNode` or `None` for an empty tree). **Output**: - Returns a boolean value `True` if the trees are identical, `False` otherwise. **Constraints**: 1. The number of nodes in each tree is in the range [0, 1000]. 2. Node values are integers. **Requirements**: - Use an iterative approach (e.g., using a stack or queue) to check the tree equality. - Ensure that the solution is efficient and avoids unnecessary comparisons. - Handle all edge cases notably when one or both trees are empty. **Example**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Trees # Tree 1: 1 Tree 2: 1 # / / # 2 3 2 3 tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree_iterative(tree1, tree2) == True # Example Trees # Tree 1: 1 # / # 2 3 # Tree 2: 1 # / # 2 4 tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(4)) assert is_same_tree_iterative(tree1, tree2) == False ``` To support student understanding, mention that using a stack or queue for the iterative comparison will help manage memory use more efficiently compared to recursive depth expansion.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree_iterative(tree_p, tree_q): Return True if both binary trees are identical in structure and node values, otherwise False. # Use a stack to manage nodes to compare stack = [(tree_p, tree_q)] while stack: node1, node2 = stack.pop() if not node1 and not node2: # Both nodes are empty, continue to next pair continue if not node1 or not node2: # One node is empty, meaning structure is different return False if node1.val != node2.val: # Node values are different return False # Push children nodes to stack for next comparison stack.append((node1.right, node2.right)) stack.append((node1.left, node2.left)) return True"},{"question":"# Run-Length Encoding & Decoding Problem Description Run-length encoding (RLE) is a simple compression algorithm that encodes a stream of data by counting consecutive occurrences of the same value. Run-length decoding reconstructs the original data from the encoded format. Implement run-length encoding and decoding functions that handle strings of alphabetic characters. Function Signature Implement two functions: - `rle_encode(input: str) -> str` - `rle_decode(input: str) -> str` Input - **rle_encode**: - A single string `input` containing alphabetic characters (a-z, A-Z). Length will be within the range [0, 10^6]. - **rle_decode**: - A single string `input` representing the encoded data. It will be a valid RLE encoded string (e.g., \\"4a1b3c\\"). Output - **rle_encode** returns the encoded string representing the run-length encoded data. - **rle_decode** returns the decoded string reconstructed from the encoded data. Constraints - The encoded string will not contain more than 10^6 characters. - Handle all cases, including empty strings and strings with no repeating characters. Examples ```python # Example 1 print(rle_encode(\\"aaabccddddd\\")) # Output: \\"3a1b2c5d\\" print(rle_decode(\\"3a1b2c5d\\")) # Output: \\"aaabccddddd\\" # Example 2 print(rle_encode(\\"abcdef\\")) # Output: \\"1a1b1c1d1e1f\\" print(rle_decode(\\"1a1b1c1d1e1f\\")) # Output: \\"abcdef\\" # Example 3 print(rle_encode(\\"aaa\\")) # Output: \\"3a\\" print(rle_decode(\\"3a\\")) # Output: \\"aaa\\" ``` Requirements * Implement error handling for edge cases such as empty input. * Ensure efficiency in both encoding and decoding according to time and space constraints given. Important Notes * Avoid using external libraries for RLE. * Focus on clean and optimized code. * Ensure your solution handles and reports errors gracefully, especially for decoding non-valid RLE inputs.","solution":"def rle_encode(input: str) -> str: Encode the given string using Run-Length Encoding (RLE). :param input: The string to be encoded. :return: The Run-Length Encoded string. if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char # Add the last group encoded.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded) def rle_decode(input: str) -> str: Decode the given string from Run-Length Encoding (RLE). :param input: The RLE encoded string. :return: The decoded string. if not input: return \\"\\" decoded = [] count_str = \\"\\" for char in input: if char.isdigit(): count_str += char else: count = int(count_str) decoded.append(char * count) count_str = \\"\\" return \'\'.join(decoded)"},{"question":"**Question: Implement a Modified Quick Sort** # Problem Statement You are required to create a function `modified_quick_sort` that sorts an array of integers. The function must include additional enhancements for optimizing the pivot selection to avoid the worst-case performance. Specifically, you should use the **median-of-three** method to choose the pivot. # Input - An unordered list of integers `arr`. # Output - A new list of integers sorted in ascending order. # Requirements 1. Implement the **modified_quick_sort** function in Python. 2. Use the **median-of-three** method to choose the pivot during the partition phase. This means the pivot should be chosen as the median of the first, middle, and last elements of the sub-array. 3. Ensure the function does not modify the input list `arr` directly. # Function Signature ```python def modified_quick_sort(arr: list) -> list: # Your implementation here ``` # Example ```python arr = [34, 7, 23, 32, 5, 62] sorted_arr = modified_quick_sort(arr) print(sorted_arr) # Output should be [5, 7, 23, 32, 34, 62] ``` # Constraints - The input list can have up to `10^5` elements. - Elements in the list are within the range of `-10^6` to `10^6`. # Additional Information - The function should use an efficient pivot selection to minimize the chance of encountering the worst-case scenario. - Do not use Python\'s in-built sorting functions. # Tips - Consider implementing a helper function for the median-of-three logic. - The pivot selection should be well-documented within your implementation. - Think about recursion depth issues and try to minimize the recursion depth if possible.","solution":"def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quick_sort_helper(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quick_sort_helper(arr, low, pivot_index - 1) quick_sort_helper(arr, pivot_index + 1, high) def modified_quick_sort(arr): sorted_arr = arr[:] quick_sort_helper(sorted_arr, 0, len(sorted_arr) - 1) return sorted_arr"},{"question":"# Objective: Implement an enhanced version of the Selection Sort algorithm with additional checks and considerations for simulation and efficiency. # Problem Description: You are given an unsorted array of integers. Your task is to implement a function `enhanced_selection_sort(arr, simulation=False)` that: 1. Sorts the array using an enhanced selection sort algorithm. 2. Optionally performs output simulation, displaying the array state after each iteration. 3. Includes early termination to stop further processing if no swaps occur during an entire pass (indicating the array is already sorted). # Function Signature: ```python def enhanced_selection_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` # Input: - `arr` (List[int]): A list of integers to be sorted. - `simulation` (bool): A flag to indicate if simulation steps should be printed. Default is `False`. # Output: - Returns the sorted list of integers. # Constraints: - The length of the list will be between 0 and 10^4. - Each integer in the list will be in the range [-10^6, 10^6]. # Performance Requirements: - Time Complexity: O(n^2) in worst-case, reduced impact with early termination for partially/fully sorted arrays. - Space Complexity: O(1) additional space. # Example: ```python # Example usage arr = [64, 25, 12, 22, 11] sorted_arr = enhanced_selection_sort(arr, simulation=True) print(\\"Sorted Array:\\", sorted_arr) ``` Output (when simulation=True): ``` iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 Sorted Array: [11, 12, 22, 25, 64] ``` # Note: Your implementation should also handle cases where: - The list is initially empty. - All elements in the list are identical. - The list is already sorted before sorting.","solution":"from typing import List def enhanced_selection_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) for i in range(n): min_index = i swapped = False for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] swapped = True if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"# Tree Postorder Traversal Algorithm Implementation Problem Statement Given a binary tree, implement both iterative and recursive algorithms to traverse the tree in postorder traversal. The postorder traversal visits nodes in the following order: left subtree, right subtree, root node. Input * The input is the root node of a binary tree. * A class `Node` is provided where: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * The output should be a list of node values in the order they were traversed. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are unique. Performance Requirements * The solution should have a time complexity of O(n), where n is the number of nodes in the binary tree. * The space complexity should be optimized as much as possible. Implementation * Implement the iterative approach in a function `postorder_iterative(root)`. * Implement the recursive approach in a function `postorder_recursive(root)`. # Function Signatures ```python def postorder_iterative(root: Node) -> list: pass def postorder_recursive(root: Node) -> list: pass ``` # Example Input ```python root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) ``` Output ```python postorder_iterative(root) # Output: [4, 5, 2, 3, 1] postorder_recursive(root) # Output: [4, 5, 2, 3, 1] ``` # Additional Notes * Ensure both approaches handle the edge case of an empty tree gracefully. * Validate your implementations with various tree structures to ensure correctness and efficiency.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_recursive(root: Node) -> list: def helper(node): if not node: return [] return helper(node.left) + helper(node.right) + [node.val] return helper(root) def postorder_iterative(root: Node) -> list: if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"Context: You are tasked with developing a function that duplicates each element in a given stack. There are two approaches provided—one uses an additional stack and the other uses a queue. Task: Implement two functions based on the given descriptions: - `first_stutter(stack: List[int]) -> List[int]`: Uses an additional stack to achieve the goal. - `second_stutter(stack: List[int]) -> List[int]`: Uses a queue to achieve the goal. Each function takes a list of integers as input representing the stack (where the end of the list is considered the top of the stack) and should return the modified stack with each value duplicated. Requirements: 1. **Input**: A list of integers representing the stack. 2. **Output**: A list of integers with each original element duplicated. 3. **Constraints**: - The input list length will not exceed 10,000. - The values in the list will be integers in the range of -1,000,000 to 1,000,000. 4. **Performance**: Implementations should aim to perform operations in O(n) time complexity and use O(n) auxiliary space. # Examples: Input: `stack = [3, 7, 1, 14, 9]` Output for `first_stutter`: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` Output for `second_stutter`: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` Input: `stack = []` Output for `first_stutter`: `[]` Output for `second_stutter`: `[]` Additional Information: - Provide accurate comments and code documentation. - Ensure your code handles edge cases appropriately. - Explain the steps and thought process during the implementation. Happy coding!","solution":"from collections import deque from typing import List def first_stutter(stack: List[int]) -> List[int]: Duplicates each element in the stack using an additional stack. if not stack: return stack additional_stack = [] # Pop elements from original stack and push duplicated elements to the additional stack while stack: item = stack.pop() additional_stack.append(item) additional_stack.append(item) # Move elements back to the original stack while additional_stack: stack.append(additional_stack.pop()) return stack def second_stutter(stack: List[int]) -> List[int]: Duplicates each element in the stack using a queue. if not stack: return stack q = deque() # Pop elements from the stack and enqueue duplicated elements while stack: item = stack.pop() q.appendleft(item) q.appendleft(item) # Dequeue elements back to the original stack while q: stack.append(q.popleft()) return stack"},{"question":"Implementing and Enhancing Nearest Neighbor Algorithm You have been given a task to implement the nearest neighbor algorithm. The algorithm is used to classify a query point based on its similarity to points in a training set. The training set consists of multi-dimensional feature vectors, each associated with a specific class label. Function Signature: ```python def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: Finds the nearest neighbor for the point x in the training set tSet. Arguments: x: A tuple representing the query point\'s feature vector. tSet: A dictionary where keys are tuples representing points in the training set, and values are class labels associated with these points. Returns: The class label corresponding to the nearest neighbor in the training set. ``` # Input: - `x` is a tuple of floating-point numbers representing the query point. - `tSet` is a dictionary where keys are tuples representing points in a training set, and values are their respective class labels. # Output: - Expected output is the class label (corresponding to the nearest neighbor\'s class in `tSet`). # Constraints: - All vectors in `x` and `tSet` will have the same dimensionality. - The training set will contain at least one point. # Requirements: 1. **Edge Cases**: Handle the scenario where the training set has only one point. 2. **Error Handling**: Include assertions or checks to ensure no None or NaN values are present. 3. **Performance**: Optimize the distance calculations as much as possible. # Example: ```python query_point = (2.0, 3.0) training_set = { (1.0, 2.0): \'A\', (4.0, 6.0): \'B\', (2.5, 1.0): \'C\' } output = nearest_neighbor(query_point, training_set) print(output) # Should output \'A\' as the nearest neighbor ``` Implement the nearest neighbor algorithm considering the above constraints and requirements. Also, ensure the code is readable and well-documented.","solution":"from typing import Tuple, Dict, Any import math import numpy as np def euclidean_distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float: Calculates the Euclidean distance between two multi-dimensional points. return math.sqrt(sum((a_i - b_i) ** 2 for a_i, b_i in zip(a, b))) def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: Finds the nearest neighbor for the point x in the training set tSet. Arguments: x: A tuple representing the query point\'s feature vector. tSet: A dictionary where keys are tuples representing points in the training set, and values are class labels associated with these points. Returns: The class label corresponding to the nearest neighbor in the training set. # Ensure the query point and training set are not empty or have invalid values if not x or not tSet: raise ValueError(\\"Query point and training set cannot be empty\\") if any(value is None for value in x): raise ValueError(\\"Query point contains None values\\") if any(key is None or any(value is None for value in key) or tSet[key] is None for key in tSet): raise ValueError(\\"Training set contains None values\\") # Find the nearest neighbor closest_point = min(tSet.keys(), key=lambda point: euclidean_distance(x, point)) return tSet[closest_point]"},{"question":"# Question Context You have decided to implement a feature in a text editor that allows users to highlight key terms within their documents. Each key term should be surrounded by square brackets `[ ]` in the document. If a word matches more than one key term, the longest key term should be selected. Task Write a function `highlight_terms(words, symbols)` that processes a list of words and a list of symbols and returns the words with appropriate symbols highlighted. Input * `words`: List of strings `[str1, str2, ...]` representing the document text. * `symbols`: List of strings `[sym1, sym2, ...]` representing the key terms to highlight. Output * Return a list of strings where each string in `words` has the longest matching symbol surrounded by square brackets. Constraints * Assume that all strings in the words and symbols lists contain only uppercase or lowercase English letters. * If a word matches no symbol, it should be returned as is. Examples ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] highlight_terms(words, symbols) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Performance Requirement The solution should be efficient with a focus on minimizing time complexity using appropriate data structures. Implementation Details Consider using advanced data structures like Trie to optimize the symbol search process.","solution":"def highlight_terms(words, symbols): Highlight key terms in a list of words with the longest matching symbol within square brackets. # Sort symbols by length in descending order to prioritize longer symbols symbols.sort(key=len, reverse=True) def find_and_replace(word): for symbol in symbols: if symbol in word: # Replace the first occurrence of the symbol surrounded by square brackets return word.replace(symbol, f\'[{symbol}]\', 1) return word return [find_and_replace(word) for word in words]"},{"question":"# Question: Enhanced Graph Pathfinding You are given an unweighted directed graph represented as an adjacency list, along with two nodes, start, and end. Your task is to implement a function that finds the longest simple path (a simple path that does not repeat any nodes) from start to end. Function Signature ```python def find_longest_path(graph: dict, start: str, end: str) -> list: Find the longest simple path from start to end in the given graph. pass ``` # Input - **graph**: A dictionary representing the unweighted directed graph where keys are node identifiers (strings) and values are lists of adjacent nodes (strings). - **start**: The starting node identifier (string). - **end**: The ending node identifier (string). # Output - A list of node identifiers (strings) representing the longest simple path from start to end. Return an empty list if no such path exists. # Constraints - The graph may contain cycles. - All node identifiers in the graph are unique and represented as non-empty strings. - There is no upper limit on the size of the graph, but it is guaranteed that the maximum path length for any graph will not exceed 10,000 nodes. # Performance Requirements - Your solution should handle graphs with up to 10,000 nodes efficiently. - Focus on minimizing both time and space complexity, considering the constraints. Example 1. Input: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\', \'E\'], \'D\': [\'E\'], \'E\': [] } start = \'A\' end = \'E\' ``` Output: `[\'A\', \'B\', \'C\', \'D\', \'E\']` 2. Input: ```python graph = { \'x\': [\'y\'], \'y\': [], \'z\': [\'x\'] } start = \'z\' end = \'y\' ``` Output: `[\'z\', \'x\', \'y\']` 3. Input: ```python graph = { \'p\': [\'q\', \'r\'], \'q\': [\'r\'], \'r\': [] } start = \'p\' end = \'r\' ``` Output: `[\'p\', \'q\', \'r\']` # Notes - You should ensure not to revisit any node in the same path to avoid cycles. - If there are multiple longest paths of the same length, return any one of them.","solution":"def find_longest_path(graph: dict, start: str, end: str) -> list: Finds the longest simple path from start to end in the given graph. def dfs(node, current_path, visited): # Add current node to the path and mark it as visited current_path.append(node) visited.add(node) # If we have reached the end node, check if it\'s the longest path if node == end: nonlocal longest_path if len(current_path) > len(longest_path): longest_path = list(current_path) else: # Recurse for all adjacent vertices for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, current_path, visited) # Backtrack: remove the current node from the path and mark it as unvisited current_path.pop() visited.remove(node) longest_path = [] dfs(start, [], set()) return longest_path"},{"question":"# Scenario You are working on a large-scale data analysis project involving very high-dimensional but sparse vectors. You need to design a more memory-efficient way to store these vectors and calculate their dot products rapidly. Given the nature of your work, efficiency and optimization are crucial. # Task Write a function `sparse_dot_product` that takes two dense vectors, converts them into a space-efficient representation, and computes their dot product. Your implementation must handle very large vectors efficiently. # Requirements 1. **Function Signature**: ```python def sparse_dot_product(vector1: List[float], vector2: List[float]) -> float: ``` 2. **Input**: - Two lists of floating-point numbers representing the dense vectors. 3. **Output**: - A single floating-point number representing the dot product of the two vectors. 4. **Constraints**: - The lengths of the input vectors are equal. - The vectors are valid and consists of float numbers. 5. **Performance**: - Your solution should be optimized for time complexity O(n) for conversion and O(min(n1, n2)) for dot product computation. # Additional Details - Consider edge cases such as complete zero vectors, vectors of different lengths (you may assume they will be truncated to the length of the shorter vector), and high dimensions with very few non-zero elements. - Ensure your code handles large inputs efficiently to avoid performance bottlenecks. # Example ```python assert sparse_dot_product([0, 2, 0, 0, 3], [4, 5, 0, 0, 6]) == 28.0 assert sparse_dot_product([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]) == 0.0 ```","solution":"from typing import List def sparse_dot_product(vector1: List[float], vector2: List[float]) -> float: def to_sparse_vector(vector): return {i: val for i, val in enumerate(vector) if val != 0} sparse_vector1 = to_sparse_vector(vector1) sparse_vector2 = to_sparse_vector(vector2) dot_product = 0.0 for idx, val in sparse_vector1.items(): if idx in sparse_vector2: dot_product += val * sparse_vector2[idx] return dot_product"},{"question":"**Context**: You have been assigned to work on a real-time data analytics system. One of the critical functionalities of this system is to provide a smooth, real-time moving average of incoming data points, with a fixed-size sliding window. **Problem Statement**: Design and implement a class that efficiently computes the moving average of a stream of integers. You should use a sliding window to keep the last `n` integers and return the moving average of the integers within that window. **Task**: Implement the `FixedWindowMovingAverage` class to provide the following functionalities: 1. **Initialization**: Takes an integer `size` that sets the sliding window size. 2. **next(val: int) -> float**: Takes an integer as input and returns the moving average of the last `n` integers in the window. **Input**: - `size`: An integer greater than 0, initializing the window size. - Multiple calls to `next(val)`, each with an integer `val`. **Output**: - For each call to `next(val)`, return the moving average as a floating-point number. **Constraints**: - The integer values for `val` can be any valid positive or negative integers. - The solution should handle at least 1,000,000 elements efficiently. **Example**: ```python fma = FixedWindowMovingAverage(3) assert fma.next(1) == 1 assert fma.next(10) == 5.5 # (1 + 10) / 2 assert fma.next(3) == 4.666666666666667 # (1 + 10 + 3) / 3 assert fma.next(5) == 6 # (10 + 3 + 5) / 3 ``` **Notes**: - Pay special attention to edge cases like when the number of values is fewer than the window size. - Ensure that your implementation is efficient and can handle large numbers of incoming data points.","solution":"from collections import deque class FixedWindowMovingAverage: def __init__(self, size: int): Initialize the FixedWindowMovingAverage with a specified window size. self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: Add a new value to the window and calculate the moving average. if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"You are tasked with enhancing the given Binary Search Tree (BST) implementation. The BST currently supports insertion, searching, and size calculation. Additionally, it provides preorder, inorder, and postorder traversal. # Requirements: 1. **Deletion Method**: Implement a method to delete a node from the BST. The method signature should be: ```python def delete(self, data: int) -> bool: ``` This method should remove the node containing the value `data` from the BST. The deletion should maintain the BST properties. Return `True` if the node was successfully deleted, and `False` if the node was not found. 2. **Balanced Tree Check**: Implement a method to determine if the BST is balanced. A tree is balanced if the height of the left and right subtrees of every node differ by no more than 1. The method signature should be: ```python def is_balanced(self) -> bool: ``` This method should return `True` if the tree is balanced, otherwise return `False`. # Input and Output Formats * **Input**: - Integer values for insertion and search. - Integer value for deletion. * **Output**: - `True` or `False` for search and delete methods. - Integer representing the size for the size method. - `True` or `False` for the balance check method. - Preorder, inorder, or postorder traversal as specified. # Performance Requirements Implementations should aim for average-case time complexities of: - (O(log N)) for insertion, search, and deletion. - (O(N)) for size calculation, and preorder, inorder, and postorder traversals. - (O(N)) for balance check. # Constraints 1. The BST should handle integers. 2. Duplicates should not be allowed. 3. The tree can handle up to 10,000 nodes efficiently. # Scenario Consider a scenario where you have a set of elements that you need to store in a BST for efficient retrieval. You need to frequently insert, search, delete elements, and also need to ensure that the tree is balanced for optimal performance. # Example For a given BST with the elements inserted in this order: [10, 15, 6, 4, 9, 12, 24, 7, 20, 30, 18]: - Inorder Traversal should give: `4 6 7 9 10 12 15 18 20 24 30` - Searching for 24 should return `True` - Deleting 24, the inorder traversal should be: `4 6 7 9 10 12 15 18 20 30` - Check whether the tree is balanced or not.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) elif key > node.val: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None or node.val == key: return node is not None if key < node.val: return self._search(node.left, key) return self._search(node.right, key) def delete(self, data: int) -> bool: self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, key): if node is None: return node, False deleted = False if key == node.val: deleted = True if node.left and node.right: # Node with two children successor = self._find_min(node.right) node.val = successor.val node.right, _ = self._delete(node.right, successor.val) elif node.left: node = node.left else: node = node.right elif key < node.val: node.left, deleted = self._delete(node.left, key) else: node.right, deleted = self._delete(node.right, key) return node, deleted def _find_min(self, node): while node.left is not None: node = node.left return node def is_balanced(self) -> bool: return self._is_balanced(self.root) def _is_balanced(self, node): def height(n): if n is None: return 0 return max(height(n.left), height(n.right)) + 1 if node is None: return True left_height = height(node.left) right_height = height(node.right) return abs(left_height - right_height) <= 1 and self._is_balanced(node.left) and self._is_balanced(node.right) def inorder(self): return self._inorder(self.root) def _inorder(self, node): result = [] if node: result = self._inorder(node.left) result.append(node.val) result = result + self._inorder(node.right) return result"},{"question":"# Moving Average with Optimized Sum Maintenance Objective To implement a Moving Average class that optimally computes the moving average of integers in a sliding window. You should maintain and update the sum efficiently without recalculating it from scratch. Requirements * Implement the class `MovingAverageOptimized` with: - An `__init__` method to initialize the data structure with a given size. - A `next` method to add a new integer to the moving window and return the current moving average. * Optimize the `next` method by maintaining a running sum for all elements in the window. Function Signatures ```python class MovingAverageOptimized: def __init__(self, size: int): Initialize the data structure with size. :param size: int pass def next(self, val: int) -> float: Add a new value to the moving window and return the moving average. :param val: int :return: float pass ``` Constraints: * `1 <= size <= 10000` * `-10^5 <= val <= 10^5`, where val is the value passed to the `next` method. * It is guaranteed that there will be at least one call to `next`. Example: ```plaintext m = MovingAverageOptimized(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` Performance: * Your implementation should have an amortized O(1) time complexity for each call to `next`.","solution":"from collections import deque class MovingAverageOptimized: def __init__(self, size: int): Initialize the data structure with size. :param size: int self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Add a new value to the moving window and return the moving average. :param val: int :return: float self.window.append(val) self.window_sum += val if len(self.window) > self.size: self.window_sum -= self.window.popleft() return self.window_sum / len(self.window)"},{"question":"# Secure Key Exchange Function Scenario: Imagine you are developing a secure messaging application. You need to implement a function that will securely exchange cryptographic keys between two users, Alice and Bob, using the Diffie-Hellman key exchange algorithm. You must ensure that both users obtain the same shared secret key without exposing their private keys. The function must verify the validity of input parameters such as prime numbers and primitive roots. Task: Implement a function `secure_key_exchange(a: int, p: int) -> bool` that: * Validates that (p) is a prime number. * Validates that (a) is a primitive root of (p). * Generates private and public keys for both Alice and Bob. * Computes the shared secret key for both parties. * Returns `True` if both shared secret keys are identical, and `False` otherwise. Function Signature: ```python def secure_key_exchange(a: int, p: int) -> bool: ``` **Input:** * `a` (int): A potential primitive root of (p). * `p` (int): A large prime number. **Output:** * `True` if successful key exchange with matching shared keys, otherwise `False`. **Constraints:** - (2 leq a leq 10^6). - (2 leq p leq 10^6). Requirements: 1. **Efficiency**: Ensure the implementation efficiently checks primality, finds primitive roots, and performs key exchange within the constraints. 2. **Handle Edge Cases**: Ensure appropriate handling of edge cases like non-prime (p) and invalid (a). 3. **Security**: Do not expose private keys in any form. Example: ```python # Example usage: result = secure_key_exchange(2, 13) print(result) # Output: True ```","solution":"import random from sympy import isprime, primitive_root def secure_key_exchange(a: int, p: int) -> bool: Performs a secure key exchange using Diffie-Hellman algorithm. :param a: A potential primitive root of p. :param p: A large prime number. :return: True if key exchange is successful with matching shared keys, False otherwise. if not isprime(p): return False try: # Validate a is a primitive root modulo p if primitive_root(p) != a: return False except ValueError: return False # Generate private keys for Alice and Bob private_key_alice = random.randint(1, p-1) private_key_bob = random.randint(1, p-1) # Generate public keys for Alice and Bob public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Generate shared secret keys for Alice and Bob shared_secret_alice = pow(public_key_bob, private_key_alice, p) shared_secret_bob = pow(public_key_alice, private_key_bob, p) # Return True if both shared secrets match, False otherwise return shared_secret_alice == shared_secret_bob"},{"question":"# Question You have been given the task to enhance the current implementation of the `WordDictionary` class by ensuring it can efficiently manage both adding words and searching for words including those with wildcard characters (`.`). The goal is to optimize the wildcard search by minimizing the recursive overhead without compromising functionality. Requirements: 1. **Function Definitions**: - `add_word(word: str) -> None`: Adds a word to the dictionary. - `search(word: str) -> bool`: Searches for a word in the dictionary. The word can also include the wildcard character (`.`), representing any letter. 2. **Input and Output**: - **add_word**: Takes a string `word`, adds it to the dictionary. - **search**: Takes a string `word`, returns `True` if it exists in the dictionary (or matches including wildcards), `False` otherwise. 3. **Constraints**: - Word lengths: 1 ≤ len(word) ≤ 500 - Only lowercase letters. Scenario: Imagine you are building an autocompletion service for a large text-based application. You are asked to implement a word dictionary where users can add words. Users should also be able to search for words, even if they do not remember exact spellings, utilizing placeholders (wildcards). Performance: - While the worst-case scenario analysis shows O(m^n) for searches with wildcards, attempt to reduce the recursive overhead through optimizations. Example: ```python word_dictionary = WordDictionary() word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") assert word_dictionary.search(\\"pad\\") == False assert word_dictionary.search(\\"bad\\") == True assert word_dictionary.search(\\".ad\\") == True assert word_dictionary.search(\\"b..\\") == True ``` Optimized Solution: You are encouraged to optimize the wildcard search more efficiently than the baseline implementations provided: ```python class TrieNode: def __init__(self, letter, is_terminal=False): self.children = {} self.letter = letter self.is_terminal = is_terminal class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word: str) -> None: # Implement this method def search(self, word: str) -> bool: # Implement this method ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_terminal = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_terminal = True def search(self, word: str) -> bool: def dfs(node, idx): if idx == len(word): return node.is_terminal if word[idx] == \'.\': for child in node.children.values(): if dfs(child, idx + 1): return True return False else: if word[idx] in node.children: return dfs(node.children[word[idx]], idx + 1) else: return False return dfs(self.root, 0)"},{"question":"You are given a dataset represented as a list of integers, and you need to filter out values that lie outside a specific range. Your task is to implement the function `filter_range` that processes this dataset according to the specified minimum and maximum limits. # Function Signature ```python def filter_range(arr: List[int], min_val: Optional[int], max_val: Optional[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers representing the dataset. * `min_val` (Optional[int]): The minimum value to include in the output list (inclusive). If None, the lower bound is considered as the minimum element in the array. * `max_val` (Optional[int]): The maximum value to include in the output list (inclusive). If None, the upper bound is considered as the maximum element in the array. # Output * Returns a list (List[int]) of integers within the given range `[min_val, max_val]`. # Constraints * The array `arr` can have up to 10^5 elements. * The values of `min_val` and `max_val` can be positive or negative integers or None. * If `arr` is empty, return an empty list. # Performance Requirements * Your implementation should have a time complexity of O(n), where n is the number of elements in the input list. # Examples 1. Example 1: ``` filter_range([1, 2, 3, 4, 5], None, 3) Output: [1, 2, 3] ``` 2. Example 2: ``` filter_range([10, 20, 30, 40, 50], 15, None) Output: [20, 30, 40, 50] ``` 3. Example 3: ``` filter_range([7, 8, 9, 10, 11], 12, 14) Output: [] ``` # Additional Context Imagine you are building a data visualization tool where you need to ensure that only data points within a specific range are shown on a graph. By using the `filter_range` function, you can prepare the data correctly to display only relevant points, thus maintaining clarity and focus in your visual representation.","solution":"from typing import List, Optional def filter_range(arr: List[int], min_val: Optional[int], max_val: Optional[int]) -> List[int]: Filters the array elements to include only those within the given range [min_val, max_val]. Parameters: arr (List[int]): The input list of integers. min_val (Optional[int]): The minimum value to include in the output list (inclusive). max_val (Optional[int]): The maximum value to include in the output list (inclusive). Returns: List[int]: A list of integers within the given range. if not arr: return [] if min_val is None: min_val = min(arr) if max_val is None: max_val = max(arr) return [x for x in arr if min_val <= x <= max_val]"},{"question":"# Coding Assessment Task: Advanced Radix Sort Implementation Scenario Imagine you are part of a team tasked with developing a high-performance sorting utility for a large dataset containing various integers. Your team decided to use Radix Sort due to its efficiency with non-comparative sorting. However, your task is to handle a broader range of data, including negative integers, and ensure optimal performance. Task Implement an advanced version of the Radix Sort algorithm that can handle both positive and negative integers. Your implementation should sort the integers in ascending order and simulate the sorting process. Function Signature ```python def advanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ... ``` Input - `arr`: List of integers (positive and negative). - `simulation`: Boolean flag (default is `False`). If set to `True`, your function should print the intermediary steps of sorting (as a simulation). Output - Returns a sorted list of integers in ascending order. Example ```python arr = [170, 45, 75, -90, 802, -24, 2, 66] print(advanced_radix_sort(arr, simulation=True)) # Expected output steps (not exact but simulation should show progress): # iteration 0 (pos numbers): 170 45 75 802 2 66 # iteration 1 (neg numbers): -90 -24 # iteration 1: 2 45 66 75 802 170 # iteration 2: -24 -90 2 45 66 75 170 802 # Sorted List: [-90, -24, 2, 45, 66, 75, 170, 802] ``` Constraints - Ensure your solution handles: - Lists with negative integers correctly. - Large input size efficiently. - Avoid using additional libraries beyond Python\'s built-in modules. Performance Requirements - Maintain the time complexity in O(nk + n) where `n` is the number of elements and `k` is the maximum number of digits in the numbers after considering negatives. - Optimize space complexity as much as possible while ensuring readability.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool=False) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 if simulation: print(f\\"After sorting by digit {exp}: {output}\\") for i in range(n): arr[i] = output[i] return arr def advanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return arr pos_arr = [num for num in arr if num >= 0] neg_arr = [-num for num in arr if num < 0] if simulation: print(f\\"Initial positive array: {pos_arr}\\") print(f\\"Initial negative array: {neg_arr}\\") if pos_arr: max1 = max(pos_arr) exp = 1 while max1 // exp > 0: pos_arr = counting_sort(pos_arr, exp, simulation) exp *= 10 if neg_arr: max2 = max(neg_arr) exp = 1 while max2 / exp > 0: neg_arr = counting_sort(neg_arr, exp, simulation) exp *= 10 neg_arr = [-num for num in reversed(neg_arr)] sorted_arr = neg_arr + pos_arr if simulation: print(f\\"Sorted array: {sorted_arr}\\") return sorted_arr"},{"question":"Combinatorial Problems: Efficient nCr Calculation # Context: You are tasked with creating a function to calculate the number of ways to choose r items from a set of n items, commonly denoted as nCr. This computation is essential in various fields including statistics, combinatorial optimization, and resource allocation. To enhance efficiency, it\'s crucial to implement this function using a method that leverages memoization to reduce redundant calculations. # Problem Statement: Implement a function `efficient_combination(n: int, r: int) -> int` to compute the value of nCr using memoization efficiently. # Input: - An integer `n` representing the total number of items (0 ≤ n ≤ 30). - An integer `r` representing the number of items to choose (0 ≤ r ≤ n). # Output: - Return an integer representing the number of ways to choose r items from n items. # Constraints: - You must implement the function using a recursive approach enhanced with memoization. - Handle edge cases where `r` is 0, `r` equals `n`, or `r` exceeds `n`. # Example: ```python def efficient_combination(n: int, r: int) -> int: # Implement your solution here pass # Example Usage assert efficient_combination(5, 3) == 10, \\"Test case 1 failed\\" assert efficient_combination(6, 6) == 1, \\"Test case 2 failed\\" assert efficient_combination(7, 0) == 1, \\"Test case 3 failed\\" assert efficient_combination(0, 0) == 1, \\"Test case 4 failed\\" assert efficient_combination(30, 15) == 155117520, \\"Test case 5 failed\\" ``` # Guidance: 1. Use a dictionary or other appropriate data structure to store previously computed results. 2. Verify edge cases and handle them efficiently. 3. Optimize the recursive function to avoid excessive memory usage, if necessary.","solution":"def efficient_combination(n: int, r: int, memo=None) -> int: if memo is None: memo = {} # Base cases if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] # Recursive calculation with memoization memo[(n, r)] = efficient_combination(n-1, r-1, memo) + efficient_combination(n-1, r, memo) return memo[(n, r)]"},{"question":"# Rabin-Karp Enhanced String Matching You\'re provided with a rolling hash implementation used within the Rabin-Karp algorithm to search for a pattern in a given text. This algorithm is efficient for average cases but can suffer from hash collisions. You need to extend the provided Rabin-Karp algorithm to handle the concept of **multiple occurrences** of the pattern in the text. Instead of returning the first occurrence, your function should return all starting indices where the pattern is found in the text. If the pattern is not found, the function should return an empty list. Function Signature ```python def rabin_karp_multiple(word: str, text: str) -> list: pass ``` Input - **word**: A string representing the pattern to be searched. (`1 <= len(word) <= 1000`) - **text**: A string representing the text where the search is performed. (`1 <= len(text) <= 10000`) Output - A list of integers representing the starting indices where the pattern occurs in the text. If the pattern is not found, return an empty list. Example ```python text = \\"ababcabcababc\\" word = \\"abc\\" assert rabin_karp_multiple(word, text) == [2, 5, 10] text = \\"aaaaaa\\" word = \\"aaa\\" assert rabin_karp_multiple(word, text) == [0, 1, 2, 3] text = \\"test\\" word = \\"xyz\\" assert rabin_karp_multiple(word, text) == [] ``` Constraints - Focus on performance, handle both large texts and large patterns effectively. - Assume the text and patterns contain only lowercase English letters. Good luck, and ensure your solution considers the core principles and optimizations as outlined in the Rabin-Karp algorithm analysis.","solution":"def rabin_karp_multiple(word: str, text: str) -> list: def hash(s): h = 0 for char in s: h = h * base + ord(char) return h if not word or not text or len(word) > len(text): return [] base = 256 # A prime number commonly used as a base for hash functions modulo = 101 # A prime number to mod the hash value to avoid overflow word_len = len(word) text_len = len(text) word_hash = hash(word) % modulo current_hash = hash(text[:word_len]) % modulo # Compute base^(word_len-1) % modulo high_order = (base ** (word_len - 1)) % modulo occurrences = [] for i in range(text_len - word_len + 1): if current_hash == word_hash: # Only check if hashes match if text[i:i + word_len] == word: occurrences.append(i) if i < text_len - word_len: # Roll the hash: remove the leading digit, add the trailing digit current_hash = (current_hash - ord(text[i]) * high_order) % modulo current_hash = (current_hash * base + ord(text[i + word_len])) % modulo current_hash = (current_hash + modulo) % modulo # ensure non-negative return occurrences"},{"question":"# Question: Pythagorean Theorem Function Given the lengths of two out of the three sides of a right-angled triangle, write a function `pythagorean_third_side` that returns the length of the third side. You will be given exactly one side marked as unknown with a `\\"?\\"`. Your function should handle any invalid inputs gracefully by raising appropriate errors. Function Signature ```python def pythagorean_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: pass ``` Input * `opposite` (str): the length of the opposite side, given as a string. It will be a number or `\\"?\\"` if unknown. * `adjacent` (str): the length of the adjacent side, given as a string. It will be a number or `\\"?\\"` if unknown. * `hypotenuse` (str): the length of the hypotenuse side, given as a string. It will be a number or `\\"?\\"` if unknown. Output * (str): a string providing the length of the unknown side in the format `\\"{Side} = {Length}\\"`. Constraints - All provided numeric side lengths will be non-negative floats or integers. - Only one side will be marked as unknown (`\\"?\\"`). Examples ```python print(pythagorean_third_side(\\"3\\", \\"4\\", \\"?\\")) # Output: \\"Hypotenuse = 5.0\\" print(pythagorean_third_side(\\"3\\", \\"?\\", \\"5\\")) # Output: \\"Adjacent = 4.0\\" print(pythagorean_third_side(\\"?\\", \\"4\\", \\"5\\")) # Output: \\"Opposite = 3.0\\" ``` Performance Requirements * The function should run in constant time O(1) and use a constant amount of space O(1). Hints * Recall and use the Pythagorean Theorem: `a^2 + b^2 = c^2`. * Remember to validate inputs and handle cases where side lengths may not be valid right-angled triangle side lengths.","solution":"import math def pythagorean_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: try: if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) if hypotenuse <= adjacent: raise ValueError(\\"Invalid input: hypotenuse must be the longest side.\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" elif adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) if hypotenuse <= opposite: raise ValueError(\\"Invalid input: hypotenuse must be the longest side.\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\" elif hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" else: raise ValueError(\\"Exactly one side must be unknown.\\") except ValueError as e: return str(e)"},{"question":"Enhanced Counting Sort You are given an array of integers that may include both negative and positive numbers. Your task is to implement an enhanced version of the counting sort algorithm that can handle this array efficiently and sort it in ascending order. Function Signature ```python def enhanced_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, which can be both positive and negative. * (1 leq text{len(arr)} leq 10^6) * (-10^6 leq arr[i] leq 10^6 ) # Output * Returns a list of integers sorted in ascending order. # Constraints * Optimize for both time and space. * Consider edge cases like a list with all the same elements or an empty list. * Ensure the sorting is stable, i.e., the relative order of equal elements is preserved. # Example ```python # Example 1 arr = [4, 2, -3, 5, 2] enhanced_counting_sort(arr) # Output: [-3, 2, 2, 4, 5] # Example 2 arr = [] enhanced_counting_sort(arr) # Output: [] # Example 3 arr = [7, 7, 7, 7] enhanced_counting_sort(arr) # Output: [7, 7, 7, 7] ``` **Hint**: Carefully handle negative numbers and ensure that the cumulative count array is constructed correctly.","solution":"from typing import List def enhanced_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 count = [0] * range_size output = [0] * len(arr) for number in arr: count[number - min_val] += 1 for i in range(1, range_size): count[i] += count[i - 1] for number in reversed(arr): output[count[number - min_val] - 1] = number count[number - min_val] -= 1 return output"},{"question":"# Rotate Matrix by 90 Degrees Clockwise You are given an n x n 2D matrix representing an image. Your task is to rotate the matrix by 90 degrees in a clockwise direction, in-place. # Requirements * **Function Signature**: ```python def rotate(matrix: List[List[int]]) -> None: pass ``` * The function will rotate the input matrix in-place and return nothing. # Input * An n x n 2D list where 1<= n <= 1000 and matrix[i][j] is an integer in the range [-10^9, 10^9]. # Output * The matrix should be modified in-place with the elements rotated by 90 degrees clockwise. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(matrix) print(matrix) # The output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Constraints 1. You must perform the rotation in-place. 2. The input matrix will always be a square matrix (i.e., the number of rows equals the number of columns). # Notes * Pay attention to edge cases such as empty matrices or matrices with a single element. * Ensure your solution adheres to the required time and space complexities.","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotates the input n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Reverse the rows of the matrix matrix.reverse() # Swap elements along the diagonals for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Scenario You are tasked with creating a program to simulate a simplified ticket vending machine accepting a sequence of inputs and determining whether it reaches an accepting state for a valid ticket generating sequence. Your program will mimic a Deterministic Finite Automaton (DFA). # Problem Statement Write a function `is_accepting_dfa(transitions, start, finals, string)` to simulate a DFA and check if the input string is accepted by the DFA. # Function Signature ```python def is_accepting_dfa(transitions: Dict[int, Dict[str, int]], start: int, finals: List[int], string: str) -> bool: ``` # Input * `transitions`: A dictionary where keys are current states, values are dictionaries mapping each input symbol to the next state. * `start`: An integer representing the starting state. * `finals`: A list of integers representing accepting states. * `string`: A string consisting of the sequence of input symbols processed. # Output * Returns a boolean value `True` if the DFA accepts the string, otherwise returns `False`. # Constraints * The length of `string` will be between `0` and `10^6`. * Each state and transition will be valid and in defined ranges. * Only characters present in the `transitions` dictionary keys should appear in the input string. # Example ```python transitions = { 1: {\'a\': 2, \'b\': 1}, 2: {\'a\': 2, \'b\': 3}, 3: {\'a\': 3, \'b\': 3} } start = 1 finals = [3] string = \\"ababb\\" assert is_accepting_dfa(transitions, start, finals, string) == True ``` # Performance Requirements The implementation should handle large strings efficiently with a time complexity O(n) and constant space complexity O(1).","solution":"def is_accepting_dfa(transitions, start, finals, string): Determines if a given string is accepted by a DFA. Parameters: transitions (dict): The transition dictionary of the DFA. start (int): The starting state of the DFA. finals (list): The list of accepting states. string (str): The input string to be checked. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for symbol in string: if symbol in transitions[current_state]: current_state = transitions[current_state][symbol] else: return False return current_state in finals"},{"question":"# AVL Tree Implementation and Query You are tasked with implementing an AVL Tree, a self-balancing binary search tree, to handle insertion, search, and in-order traversal operations while maintaining the tree\'s balance. Implement the following AVL Tree methods in Python: 1. `insert(key: int) -> None`: Insert a new integer key into the AVL Tree. 2. `search(key: int) -> bool`: Check if a given integer key exists in the tree. Returns `True` if the key exists, otherwise `False`. 3. `in_order_traverse() -> List[int]`: Return the elements of the tree in ascending order. # Constraints: - The tree will contain no more than (10^5) elements. - Insertion of duplicate keys is not allowed. If attempted, the tree remains unchanged. - Operations (`insert`, `search`, and `in_order_traverse`) should operate within O(log n) time complexity. # Example: ```python tree = AvlTree() tree.insert(10) tree.insert(20) tree.insert(5) assert tree.search(10) == True assert tree.search(15) == False assert tree.in_order_traverse() == [5, 10, 20] ``` # Implementation Guidelines: - Use the provided `TreeNode` class where necessary. - Ensure the tree balances itself after each insertion by re-balancing operations. - Handle edge cases such as insertion of already existing keys by ignoring them.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): # Perform the normal BST rotation if not root: return TreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) elif key > root.key: root.right = self.insert(root.right, key) else: # Duplicate keys are not allowed return root # Update height of this ancestor node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Get the balance factor balance = self.get_balance(root) # If node becomes unbalanced, then there are 4 cases # Case 1 - Left Left if balance > 1 and key < root.left.key: return self.right_rotate(root) # Case 2 - Right Right if balance < -1 and key > root.right.key: return self.left_rotate(root) # Case 3 - Left Right if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Case 4 - Right Left if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def search(self, root, key): if root is None or root.key == key: return root is not None if key < root.key: return self.search(root.left, key) return self.search(root.right, key) def in_order_traverse(self, root): res = [] if root: res = self.in_order_traverse(root.left) res.append(root.key) res = res + self.in_order_traverse(root.right) return res def left_rotate(self, z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) # Return the new root return y def right_rotate(self, z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) # Return the new root return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) class AVLTreeInterface: def __init__(self): self.tree = AvlTree() self.root = None def insert(self, key): self.root = self.tree.insert(self.root, key) def search(self, key): return self.tree.search(self.root, key) def in_order_traverse(self): return self.tree.in_order_traverse(self.root)"},{"question":"You are given a grid of size N x M where each cell represents either \'1\' (land) or \'0\' (water). An island is a maximal set of connected \'1\'s (land) cells, which are connected either horizontally or vertically. Your task is to write a function `num_islands(grid: List[List[str]]) -> int` that returns the number of islands in the grid. # Input Format - The input is a list of lists `grid` representing the 2d grid map, where the value of each element is either \'1\' (land) or \'0\' (water). # Output Format - Return an integer representing the number of distinct islands. # Constraints 1. ( 1 leq N, M leq 300 ) 2. Each cell in the grid is either \'0\' or \'1\'. # Example ```python grid = [ [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ] print(num_islands(grid)) # Output: 1 grid = [ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ] print(num_islands(grid)) # Output: 3 ``` # Performance Requirement Your solution should efficiently handle grids up to the maximum constraint size (300x300). # Function Signature ```python def num_islands(grid: List[List[str]]) -> int: ``` Note: In your solution, you should avoid mutating the input grid and should handle large inputs efficiently.","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: if not grid: return 0 n = len(grid) m = len(grid[0]) visit = [[False for _ in range(m)] for _ in range(n)] def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == \'0\' or visit[i][j]: return visit[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == \'1\' and not visit[i][j]: dfs(i, j) count += 1 return count"},{"question":"Problem Statement You are given a square matrix represented by a list of lists. Implement four transformation functions for the matrix: 1. `rotate_clockwise(matrix)`: Create and return a new matrix that is the original matrix rotated 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Create and return a new matrix that is the original matrix rotated 90 degrees counterclockwise. 3. `top_left_diagonal_mirror(matrix)`: Create and return a new matrix which is the mirror image of the original matrix across the top-left to bottom-right diagonal. 4. `bottom_left_diagonal_mirror(matrix)`: Create and return a new matrix which is the mirror image across the bottom-left to top-right diagonal. Function Definitions ```python def rotate_clockwise(matrix): # Your code here def rotate_counterclockwise(matrix): # Your code here def top_left_diagonal_mirror(matrix): # Your code here def bottom_left_diagonal_mirror(matrix): # Your code here ``` Input Format ```text Each function will receive a single argument: * `matrix` (list of lists of integers): A square matrix with `n` rows and `n` columns (1 <= n <= 100). Note: You can assume the input matrix contains integers. ``` Output Format ```text Each function will return a new matrix (list of lists of integers) after the respective transformation. ``` Constraints - You cannot modify the input matrix in place. - You must handle edge cases like empty matrices or single-element matrices. - Aim to achieve the best time and space complexity. Example Here is an example to assist with your implementation: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Expected outputs rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] top_left_diagonal_mirror(matrix) == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] bottom_left_diagonal_mirror(matrix) == [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Implement these transformation functions ensuring correct and efficient handling of different matrix inputs.","solution":"def rotate_clockwise(matrix): Returns a new matrix that is the input matrix rotated 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Returns a new matrix that is the input matrix rotated 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_diagonal_mirror(matrix): Returns a new matrix which is the mirror image of the input matrix across the top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_diagonal_mirror(matrix): Returns a new matrix which is the mirror image of the input matrix across the bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"**Scenario**: A software developer is creating a typing tutor application. One feature involves verifying if words can be typed using only one row of an American keyboard. Your task is to implement a function that filters words based on this criterion. **Task**: Write a function `find_keyboard_row(words)` that takes a list of strings `words` and returns a list of those strings that can be typed using letters from only one row of an American keyboard. The function should be case-insensitive. # Input: * `words` (List[str]): A list of words to be checked. # Output: * List[str]: A list containing words that can be formed using one keyboard row. # Constraints: 1. Each word will contain only letters (a-z and/or A-Z). 2. Function should be case-insensitive. # Example: ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Additional Information: The rows of the keyboard you should consider are: 1. Row 1: \\"qwertyuiop\\" 2. Row 2: \\"asdfghjkl\\" 3. Row 3: \\"zxcvbnm\\" # Function Signature: ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` # Performance Requirements: - The function should be optimized for a large number of words (up to 10^4). - Ensure case-insensitivity and correct handling of mixed-case inputs.","solution":"def find_keyboard_row(words): Returns a list of words that can be typed using letters from only one row of an American keyboard. keyboard_rows = [ set(\\"qwertyuiop\\"), set(\\"asdfghjkl\\"), set(\\"zxcvbnm\\") ] result = [] for word in words: lower_word = word.lower() for row in keyboard_rows: if all(letter in row for letter in lower_word): result.append(word) break return result"},{"question":"# Advanced Queue Implementation Challenge You are hired to optimize a task scheduling system using the queue data structure. In this system, tasks are stored in a queue based on their arrival times. However, to manage resources effectively, the system should prioritize task execution based on their priority levels. Higher priority tasks should be dequeued and executed first, even if they arrive later than lower priority tasks. You are provided with two initial implementations (`ArrayQueue` and `LinkedListQueue`). Your task is to implement a `PriorityQueue` which extends the queue data structure to handle priorities. # Requirements 1. **Function - `enqueue(task, priority)`**: Enqueue a task with a given priority. Higher numbers indicate higher priority. 2. **Function - `dequeue()`**: Dequeue and return the highest priority task. In case of a tie, follow the FIFO order for tasks with the same priority. 3. **Function - `peek()`**: Return the highest priority task without removing it. 4. **Function - `size()`**: Return the total number of tasks in the queue. 5. **Function - `isEmpty()`**: Return True if there are no tasks in the queue, else False. # Expected Input and Output * `enqueue(task, priority)`: Adds a task to the queue. * `dequeue() -> str`: Returns and removes the highest priority task from the queue. * `peek() -> str`: Returns the highest priority task without removing it. * `size() -> int`: Returns the number of tasks in the queue. * `isEmpty() -> bool`: Returns True if the queue is empty, False otherwise. # Constraints * The priority will be an integer. * Tasks will be represented as strings. * Aim for O(log n) time complexity for enqueue and dequeue operations. # Example Scenario ```python # Initialize the PriorityQueue pq = PriorityQueue() # Enqueue tasks pq.enqueue(\\"Task1\\", 1) pq.enqueue(\\"Task2\\", 3) pq.enqueue(\\"Task3\\", 2) # Expected Output for dequeue print(pq.dequeue()) # \\"Task2\\" print(pq.dequeue()) # \\"Task3\\" print(pq.dequeue()) # \\"Task1\\" print(pq.isEmpty()) # True ``` # Implementation Details Implement the `PriorityQueue` using a heap (binary heap) to maintain efficient priority management and ensure that both enqueue and dequeue operations are optimized for performance.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] self._counter = 0 def enqueue(self, task, priority): heapq.heappush(self._heap, (-priority, self._counter, task)) self._counter += 1 def dequeue(self): if self._heap: return heapq.heappop(self._heap)[2] else: return None def peek(self): if self._heap: return self._heap[0][2] else: return None def size(self): return len(self._heap) def isEmpty(self): return len(self._heap) == 0"},{"question":"# Abbreviation Generator Challenge You are tasked with writing a function to generate all possible abbreviations of a given word. An abbreviation is created by replacing non-overlapping substrings of the word with their respective lengths. For instance, the word \\"word\\" can be abbreviated as \\"word\\" (no abbreviation), \\"wor1\\", \\"wo1d\\", \\"w1rd\\", \\"w2d\\", and so on. Your function should follow these requirements: **Function Signature**: ```python def generate_abbreviations(word: str) -> List[str]: ``` **Input**: - `word` (str): A string representing the word for which you need to generate abbreviations. The string will contain only lowercase English letters and have a length between 1 and 20. **Output**: - A list of strings representing all possible abbreviations of the input word. **Example**: ```python assert generate_abbreviations(\\"word\\") == [ \'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\' ] ``` **Constraints**: - The function must generate all possible abbreviations. - The order in which the abbreviations are listed does not matter. **Evaluation Criteria**: - **Correctness**: The generated abbreviations must be correct and complete. - **Efficiency**: The solution should handle the maximum constraint efficiently. - **Edge Cases**: The function should correctly handle special cases like very short words. Implement the function accordingly and ensure it meets the above requirements. Use backtracking to explore all potential variations of abbreviations.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: res = [] def backtrack(pos: int, cur: str, count: int): if pos == len(word): if count > 0: cur += str(count) res.append(cur) else: # Skip the current character and increase the count backtrack(pos + 1, cur, count + 1) # Include the current character and reset the count backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) backtrack(0, \\"\\", 0) return res"},{"question":"You are provided with a Markov Chain represented as a dictionary where each state maps to another dictionary of potential next states and their respective probabilities. Your task is to implement a function to generate the sequence of states starting from a given initial state, for a specified number of steps. # Function Signature ```python def generate_sequence(chain: Dict[str, Dict[str, float]], initial_state: str, steps: int) -> List[str]: Generates a sequence of states from a Markov chain given an initial state and number of steps. Parameters: - chain (Dict[str, Dict[str, float]]): The Markov chain represented as a dictionary. - initial_state (str): The initial state to start the sequence. - steps (int): The number of steps to transition through the Markov chain. Returns: - List[str]: A list of states representing the sequence through the Markov chain. pass ``` # Input Parameters * `chain`: A dictionary representing the Markov chain where the keys are current states, and values are dictionaries of next states with their probabilities. * `initial_state`: A string representing the starting state. * `steps`: An integer representing the number of steps to generate the sequence. # Output * A list of strings representing the sequence of states generated through the Markov chain from the `initial_state` for the given number of `steps`. # Constraints 1. The sum of probabilities for next states for each state in the chain dictionary is 1. 2. The chain dictionary contains at least one state and one transition. 3. The initial state is a valid key in the chain dictionary. 4. The number of steps is a positive integer. # Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.7, \'B\': 0.3} } initial_state = \'A\' steps = 5 print(generate_sequence(chain, initial_state, steps)) # Possible Output: [\'A\', \'A\', \'B\', \'A\', \'B\'] ``` # Notes * Use the random module to generate transitions. * Consider edge cases such as self-loops or a state with high transition probability to itself. * Ensure the output sequence length matches the number of steps requested.","solution":"import random from typing import Dict, List def generate_sequence(chain: Dict[str, Dict[str, float]], initial_state: str, steps: int) -> List[str]: Generates a sequence of states from a Markov chain given an initial state and number of steps. Parameters: - chain (Dict[str, Dict[str, float]]): The Markov chain represented as a dictionary. - initial_state (str): The initial state to start the sequence. - steps (int): The number of steps to transition through the Markov chain. Returns: - List[str]: A list of states representing the sequence through the Markov chain. sequence = [initial_state] current_state = initial_state for _ in range(steps): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] sequence.append(current_state) return sequence"},{"question":"You have been hired by a cybersecurity firm to implement a core mathematical function which is crucial for their encryption software. Specifically, you need to write a function that computes (base^exponent) % mod efficiently. This technique is a fundamental part of many encryption algorithms, ensuring that even with very large numbers, the computation remains feasible and efficient. Your Task: Implement the function `secure_modular_exponential(base: int, exponent: int, mod: int) -> int` which takes three integer arguments: `base`, `exponent`, and `mod`, and returns the result of `(base^exponent) % mod`. Constraints: 1. `0 <= base <= 10^9` 2. `0 <= exponent <= 10^9` 3. `1 <= mod <= 10^9` Requirements: * Your solution should have a logarithmic time complexity with respect to the exponent. * Handle edge cases appropriately. * Ensure that your solution does not suffer from integer overflow issues due to large input values. Function Signature: ```python def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: pass ``` Example: ```python # Example 1: base = 2 exponent = 10 mod = 1000 print(secure_modular_exponential(base, exponent, mod)) # Output: 24 # Example 2: base = 4 exponent = 13 mod = 497 print(secure_modular_exponential(base, exponent, mod)) # Output: 445 ``` # Additional Information: For any number `a`, `a^0` should return 1 modulo `mod` by definition.","solution":"def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: if mod == 1: return 0 result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Question: Implement Advanced String Reversal Given a string `s`, write a function `advanced_reverse(s: str) -> str` that reverses the string using an approach that minimizes the time complexity without compromising on space complexity significantly. You should evaluate the four provided string reversal implementations and come up with your own implementation that combines their strengths. Your implementation should be able to handle: 1. Strings containing only letters. 2. Very large strings efficiently considering both time and space complexities. 3. Edge cases such as empty strings or single character strings. Complete the following function: ```python def advanced_reverse(s: str) -> str: # Your code here # Example Usage print(advanced_reverse(\\"hello\\")) # Output: \\"olleh\\" print(advanced_reverse(\\"a\\")) # Output: \\"a\\" print(advanced_reverse(\\"\\")) # Output: \\"\\" ``` **Constraints:** - The input string `s` will have a length up to 10^6. - You are expected to analyze and decide an optimal way considering the provided code snippets. **Performance Requirement:** Your solution should preferably be O(n) in time complexity and O(n) in space complexity where n is the length of the string.","solution":"def advanced_reverse(s: str) -> str: Reverses the input string `s` using an efficient approach. return s[::-1]"},{"question":"# Matrix Decomposition Challenge You are required to implement the Crout Matrix Decomposition algorithm. Your implementation should decompose a given matrix ( A ) into two matrices ( L ) (lower triangular matrix) and ( U ) (upper triangular matrix) such that ( L times U = A ). Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` Input * A single parameter, `A`, which is a 2D list of floats representing the matrix. * The given matrix `A` is guaranteed to be square (n x n). Output * Return a tuple containing two 2D lists `L` and `U`, which are the lower and upper triangular matrices, respectively. Constraints * 1 ≤ ( n ) ≤ 100 * The matrix contains floating point numbers. Performance Requirements * Your solution must handle the decomposition in ( O(n^3) ) time complexity. * Implement safeguards to handle near-zero divisors in the calculation process. Example ```python # Example Input A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8], ] # Expected Output L = [ [1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0], ] U = [ [1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0], ] ``` Notes 1. Ensure that the elements are of type float in the output matrices. 2. Verify that ( L times U ) results in the original matrix ( A ).","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): sum_L = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_L for i in range(j+1, n): sum_U = sum(L[j][k] * U[k][i] for k in range(j)) if L[j][j] == 0: raise ZeroDivisionError(\\"Zero element on diagonal. The matrix should be non-singular.\\") U[j][i] = (A[j][i] - sum_U) / L[j][j] return L, U"},{"question":"# Question: Implementing and Testing the Atbash Cipher Objective You are tasked with implementing the Atbash cipher, a simple substitution cipher, and writing a test suite to verify its correct behavior. Instructions 1. Implement the function `atbash` which translates a given string using the Atbash cipher. 2. Write a function `test_atbash` to conduct unit tests, ensuring your implementation correctly handles various cases. Function Definition ```python def atbash(s: str) -> str: Translate the string `s` using the Atbash cipher. Parameters: s (str): The input string to be translated. Returns: str: The translated string using the Atbash cipher. pass # Your implementation here def test_atbash(): Test the atbash function with multiple test cases to ensure correct behavior. Includes edge cases and typical use cases. pass # Your implementation here ``` Constraints * The input string `s` can contain letters (both uppercase and lowercase), digits, punctuation, and whitespace. * The cipher should only alter alphabetical characters. Example ```python assert atbash(\\"Attack at dawn!\\") == \\"Zggzxp zg wzdm!\\" assert atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash(\\"1234\\") == \\"1234\\" assert atbash(\\"a\\") == \\"z\\" assert atbash(\\"z\\") == \\"a\\" ``` Performance Requirements * Function should handle strings up to 10,000 characters efficiently. Implement the function and the test suite, ensuring to cover edge cases, mixed-case scenarios, input with special characters, and performance with large inputs.","solution":"def atbash(s: str) -> str: Translate the string `s` using the Atbash cipher. Parameters: s (str): The input string to be translated. Returns: str: The translated string using the Atbash cipher. def translate_char(c): if \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) elif \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) else: return c return \'\'.join(translate_char(c) for c in s)"},{"question":"# Task You need to extend the provided `DirectedGraph` class by implementing a method called `has_cycle` that checks if there are any cycles within the graph. This method should return `True` if a cycle is present and `False` otherwise. Function Signature ```python class DirectedGraph: # existing implementation def has_cycle(self) -> bool: pass ``` # Detailed Requirements 1. **Input**: - The graph is represented using the existing `DirectedGraph` structure. - The nodes and edges are already added to the graph using class methods. 2. **Output**: - Return `True` if the graph contains a cycle. - Return `False` otherwise. 3. **Constraints**: - The graph does not need to be connected. - You must not alter the existing structure of the node, edge, or graph classes. # Example Consider the following directed graph: ```python graph = DirectedGraph({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], # This creates a cycle (A -> B -> C -> A) \'D\': [\'E\'], \'E\': [] }) ``` - Calling `graph.has_cycle()` should return `True` because a cycle exists within the nodes `A`, `B`, and `C`. For a graph with no cycles: ```python graph = DirectedGraph({ \'A\': [\'B\'], \'B\': [], \'C\': [\'D\'], \'D\': [] }) ``` - Calling `graph.has_cycle()` should return `False`. # Notes - You might want to use Depth-First Search (DFS) for detecting cycles. - Ensure that you take care of visited nodes properly to prevent infinite loops.","solution":"class DirectedGraph: def __init__(self, adjacency_list=None): self.adjacency_list = adjacency_list if adjacency_list is not None else {} def has_cycle_util(self, node, visited, rec_stack): Utilizes DFS to detect cycles in the graph. visited[node] = True rec_stack[node] = True for neighbor in self.adjacency_list.get(node, []): if not visited[neighbor]: if self.has_cycle_util(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False def has_cycle(self) -> bool: Returns True if the graph contains a cycle, False otherwise. visited = {node: False for node in self.adjacency_list} rec_stack = {node: False for node in self.adjacency_list} for node in self.adjacency_list: if not visited[node]: if self.has_cycle_util(node, visited, rec_stack): return True return False"},{"question":"# Pattern Matching with Substring Mapping Scenario You are tasked with developing a function that determines if a given `string` follows a specific `pattern`. The `pattern` consists of lowercase letters, each representing a unique segment of the `string`. Your function should find a bijective (one-to-one and onto) mapping from each character in the `pattern` to a non-empty substring in the `string`. Your task is to implement this function to verify whether such a pattern is possible. The function should return `True` if the string follows the pattern, otherwise `False`. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` Input - `pattern` (str): A pattern containing only lowercase letters. - `string` (str): A string containing only lowercase letters. Output - Returns `True` if the string follows the pattern, otherwise `False`. Constraints - Both `pattern` and `string` will contain only lowercase letters. - The length of the `pattern` and `string` will be less than or equal to 20. Example ```python pattern = \\"abab\\" string = \\"redblueredblue\\" # Returns True pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" # Returns True pattern = \\"aabb\\" string = \\"xyzabcxzyabc\\" # Returns False ``` Hints 1. Use a backtracking approach where you try all possible substring partitions. 2. Use a dictionary to maintain your pattern to string segment mappings and ensure consistency through the recursion. Good luck, and ensure to consider edge cases such as empty strings, repetitive characters in the pattern, and unequal lengths of pattern and string!","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_to_s_map, s_to_p_map): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): substring = string[s_idx:end] if pattern_char in p_to_s_map: if p_to_s_map[pattern_char] != substring: continue if backtrack(p_idx + 1, s_idx + len(substring), p_to_s_map, s_to_p_map): return True else: if substring in s_to_p_map and s_to_p_map[substring] != pattern_char: continue p_to_s_map[pattern_char] = substring s_to_p_map[substring] = pattern_char if backtrack(p_idx + 1, s_idx + len(substring), p_to_s_map, s_to_p_map): return True del p_to_s_map[pattern_char] del s_to_p_map[substring] return False return backtrack(0, 0, {}, {})"},{"question":"**Scenario**: You are working for a company that processes large log files with timestamped records. You are tasked to find the most recent occurrence of a particular event ID in these sorted log entries. **Task**: Write a function `last_occurrence` that finds the last occurrence of a target element in a sorted list. The list is sorted in increasing order. # Function Specification ```python def last_occurrence(array: List[int], query: int) -> int: Finds the index of the last occurrence of query in array. Parameters: array (List[int]): a list of integers sorted in non-decreasing order. query (int): the target integer to find in the array. Returns: int: The index of the last occurrence of query in the array; If query is not present, return -1. ``` # Input 1. `array`: A list of integers ( (0 leq text{len(array)} leq 10^6) ) 2. `query`: A single integer ( (-10^9 leq text{query} leq 10^9) ) # Output * Return the index (0-based) of the last occurrence of the query in the list. * If the query is not found in the array, return -1. # Constraint * The array is sorted in non-decreasing order. # Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 print(last_occurrence(array, query)) # Output: 3 # Example 2 array = [1, 2, 3, 4, 5] query = 6 print(last_occurrence(array, query)) # Output: -1 ``` # Notes * Use binary search to achieve the best time complexity. * Think of edge cases such as when the array is empty, when the query is not present, or when all elements are equal to the query.","solution":"def last_occurrence(array, query): Finds the index of the last occurrence of query in array. Parameters: array (list of int): a list of integers sorted in non-decreasing order. query (int): the target integer to find in the array. Returns: int: The index of the last occurrence of query in the array; If query is not present, return -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question: Implement a Custom Sort based on Comb Sort Context: You have been provided an implementation of the Comb Sort algorithm. However, you notice that its performance can often be suboptimal due to the static shrink factor of 1.3 and the generic gap calculation approach. Write a function that enhances the provided Comb Sort algorithm. The improvements should focus on dynamically adjusting the shrink factor and potentially optimizing smaller gap transitions to make the sort more efficient, especially on partially sorted arrays. Function Signature: ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: ``` Input: * `arr` - a list of integers to be sorted. Output: * Returns a new list with the elements sorted in ascending order. Constraints: * The list `arr` can have up to (10^5) elements. * Elements of `arr` will be integers within the range ([-10^6, 10^6]). Requirements: * The solution should be optimized for performance. * Handle edge cases efficiently, such as empty arrays and arrays with identical elements. * You are not allowed to use built-in sorting functions like `sorted()` or `sort()`. Example: ```python assert enhanced_comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert enhanced_comb_sort([]) == [] assert enhanced_comb_sort([1]) == [1] assert enhanced_comb_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] ```","solution":"from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrink factor more dynamically changing return (gap * 10) // 13 if gap > 1 else 1 n = len(arr) gap = n sorted = False while not sorted: old_gap = gap gap = get_next_gap(gap) if gap <= 1: gap = max(1, (old_gap * 10) // 13) sorted = gap == 1 for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"**Context**: You are tasked with designing a simulation system to manage a series of requests coming into a server. Your system needs an efficient queue implementation to handle several operations, including enqueueing requests, dequeueing them for processing, and querying the current status of the queue. This has to be designed using both array and linked list data structures. **Task**: Implement a `CircularQueue` class which inherits from the provided `AbstractQueue` class. The `CircularQueue` should support the following operations: - `enqueue(item)` - Adds an item to the rear of the queue. - `dequeue()` - Removes and returns the front item of the queue. - `peek()` - Returns the front item without removing it. - `is_empty()` - Returns `True` if the queue is empty, otherwise `False`. - `__len__()` - Returns the number of items in the queue. The `CircularQueue` should have a fixed capacity and should wrap around when the end is reached. For example, if the queue\'s capacity is 5 and it is full, the next item should overwrite the frontmost item in the array. **Input/Output**: - The `enqueue` method should raise an exception if trying to add to a full queue. - The `dequeue` method should raise an exception if trying to remove from an empty queue. - The `peek` method should raise an exception if trying to peek at an empty queue. **Constraints**: - The capacity of the queue will be a positive integer (>= 1). **Example**: Consider a `CircularQueue` with a capacity of 3: ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 cq.enqueue(4) print(cq.dequeue()) # Output: 2 cq.enqueue(5) cq.enqueue(6) # This should raise an exception \\"Queue is full\\" ``` Implement the `CircularQueue` class below: ```python class CircularQueue(AbstractQueue): def __init__(self, capacity): super().__init__() self._array = [None] * capacity self._front = 0 self._rear = 0 self._capacity = capacity self._size = 0 def enqueue(self, value): if self._size == self._capacity: raise IndexError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def __iter__(self): probe = self._front count = 0 while count < self._size: yield self._array[probe] probe = (probe + 1) % self._capacity count += 1 ``` Test cases: - Create a `CircularQueue` with capacity 3 and perform enqueue, dequeue, and peek operations. - Handle the edge cases by trying to enqueue into a full queue and dequeue from an empty queue.","solution":"class CircularQueue: def __init__(self, capacity): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self._array = [None] * capacity self._front = 0 self._rear = 0 self._capacity = capacity self._size = 0 def enqueue(self, value): if self._size == self._capacity: raise IndexError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size"},{"question":"# Scenario You\'ve been hired to implement an efficient Customer Service Ticket System. Customers create support tickets which are then processed in the order they arrive. To support this, you\'ve decided to use a queue. # Objective Implement a CustomQueue class that supports the following operations: - `enqueue(ticket_id)`: Adds a new ticket to the queue. - `dequeue()`: Processes and removes the next ticket in the queue. - `peek()`: Returns the ticket id of the next ticket to be processed, without removing it. - `is_empty()`: Returns whether the queue is empty. - `size()`: Returns the number of tickets currently in the queue. # Constraints - The queue should be implemented using linked nodes to handle potentially high numbers of tickets without resizing drawbacks. # Input/Output Format **Methods**: - `enqueue(ticket_id: int) -> None` - `dequeue() -> int` - `peek() -> int` - `is_empty() -> bool` - `size() -> int` # Function Implementation Implement the `CustomQueue` class with described methods. # Example ```python cq = CustomQueue() cq.enqueue(101) cq.enqueue(102) print(cq.peek()) # Output: 101 print(cq.size()) # Output: 2 print(cq.dequeue()) # Output: 101 print(cq.size()) # Output: 1 print(cq.is_empty()) # Output: False cq.dequeue() print(cq.is_empty()) # Output: True ``` # Note 1. Raise an appropriate exception if `dequeue` or `peek` are called on an empty queue. 2. The `enqueue` operation should handle both positive and negative integers as ticket IDs.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class CustomQueue: def __init__(self): self.head = None self.tail = None self._size = 0 def enqueue(self, ticket_id: int) -> None: new_node = Node(ticket_id) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self._size += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\'Dequeue from empty queue\') dequeued_value = self.head.value self.head = self.head.next if not self.head: self.tail = None self._size -= 1 return dequeued_value def peek(self) -> int: if self.is_empty(): raise IndexError(\'Peek from empty queue\') return self.head.value def is_empty(self) -> bool: return self._size == 0 def size(self) -> int: return self._size"},{"question":"# Insertion Sort Analysis and Implementation **Scenario**: You are part of a development team implementing sorting functionalities for a data processing library. One key feature is provided by the Insertion Sort algorithm due to its simplicity and efficiency on small or nearly sorted data sets. To assess your understanding of the Insertion Sort algorithm, you must implement a function that not only sorts an array but also provides options for simulating the sorting process step-by-step. **Task**: Implement the `insertion_sort` function as described below: Function Signature ```python def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input * `arr`: A list of integers to be sorted. * `simulation` (optional): A boolean flag indicating whether to simulate the sorting process step-by-step. Default is `False`. Output * Return a list of integers sorted in non-decreasing order. Detailed Requirements 1. Implement the Insertion Sort algorithm to sort the input list `arr` in-place. 2. If `simulation` parameter is `True`, print the array\'s state at every iteration of the outer loop. Examples ```python # Example 1 print(insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] # Example 2 with simulation print(insertion_sort([4, 3, 2, 10], True)) # Expected Output: # iteration 0 : 4 3 2 10 # iteration 1 : 3 4 2 10 # iteration 2 : 2 3 4 10 # iteration 3 : 2 3 4 10 ``` Constraints * The input list can contain between `0` and `1000` elements. * Each element in the list can be any integer. **Performance Requirements**: * Ensure the function runs efficiently within the provided constraints. * Handle edge cases such as empty arrays or arrays with all equal elements correctly.","solution":"def insertion_sort(arr, simulation=False): Sorts an array in-place using the Insertion Sort algorithm. If simulation is True, prints the state of the array at each outer loop iteration. :param arr: List of integers to sort :param simulation: Boolean flag to output the sorting process :return: Sorted list of integers for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead # of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : \\", \' \'.join(map(str, arr))) return arr"},{"question":"# Context You are tasked to implement a simplistic text editor\'s undo mechanism using a stack. The editor maintains a record of text operations that users can undo. # Requirements 1. Implement a class `TextEditor` which maintains a string and provides operations to modify it and undo those modifications. 2. The class should support five operations: - `insert(text)`: Insert text at the end of the current string. - `delete(count)`: Delete the last `count` characters from the current string. - `replace(old, new)`: Replace the first occurrence of substring `old` with `new`. - `undo()`: Undo the most recent operation. # Input and Output Formats * **Input**: You should provide methods to perform operations directly. You do not need to handle direct input reading. * **Output**: The `undo` method should return a string representing the current state of the text. # Constraints * All strings provided or modified are ASCII characters only. * The maximum length of any text operation is 1000 characters. * No operation will result in a negative text length. # Performance Requirements * Optimize for frequent `undo` calls. `Undo` operation must be O(1) in amortized time. Here is the skeleton code you should start with: ```python class Action: # This class will store the action made (insert, delete, replace) and its respective information to undo. def __init__(self, type, data): self.type = type self.data = data class TextEditor: def __init__(self): self.text = \\"\\" self.action_stack = ArrayStack() def insert(self, new_text): Implement insert method which adds new_text to end of self.text and records this action to stack. pass def delete(self, count): Implement delete method which removes last count characters from self.text and records this action to stack. pass def replace(self, old, new): Implement replace method which replaces first occurrence of old with new in self.text and records this action to stack. pass def undo(self): Implement undo method which reverts the most recent action. pass ``` # Additional Instructions 1. You may use the provided `ArrayStack` code or implement your own stack class. 2. Ensure all edge cases are handled, especially when undoing operations. 3. Write helper methods if necessary, but keep them within the `TextEditor` class.","solution":"class Action: def __init__(self, type, data): self.type = type self.data = data class TextEditor: def __init__(self): self.text = \\"\\" self.action_stack = [] def insert(self, new_text): self.action_stack.append(Action(\'insert\', len(new_text))) self.text += new_text def delete(self, count): deleted_text = self.text[-count:] self.action_stack.append(Action(\'delete\', deleted_text)) self.text = self.text[:-count] def replace(self, old, new): if old in self.text: start_index = self.text.find(old) end_index = start_index + len(old) self.action_stack.append(Action(\'replace\', (old, start_index))) self.text = self.text[:start_index] + new + self.text[end_index:] def undo(self): if not self.action_stack: return self.text last_action = self.action_stack.pop() if last_action.type == \'insert\': self.text = self.text[:-last_action.data] elif last_action.type == \'delete\': self.text += last_action.data elif last_action.type == \'replace\': old, start_index = last_action.data new_len = len(old) end_index = start_index + len(self.text[start_index:start_index + new_len]) self.text = self.text[:start_index] + old + self.text[end_index:] return self.text"},{"question":"# Question You are given an array of integers that may include both positive and negative numbers. Your task is to implement a modified version of the **Counting Sort** algorithm to sort this array. Recall that Counting Sort typically works only with non-negative integers, so you need to handle the negative numbers appropriately. # Function Signature ```python def modified_counting_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: List of integers, where -10^6 <= arr[i] <= 10^6 and 1 <= len(arr) <= 10^6. # Output - A sorted list of integers. # Constraints - Optimize your solution to run in linear time O(n) relative to the number of elements, and additional space O(k), where k is the range of the input values. # Example ```python assert modified_counting_sort([4, -1, 0, -9, 8, 5, 7]) == [-9, -1, 0, 4, 5, 7, 8] assert modified_counting_sort([3, 3, 2, 1, 0, -1, -1, -3]) == [-3, -1, -1, 0, 1, 2, 3, 3] assert modified_counting_sort([]) == [] ``` # Scenario You\'re developing a sorting module for an application that requires efficient sorting of large datasets consisting of integers. The application needs to handle a wide range of values, including negative numbers. Implement the modified counting sort to handle these requirements.","solution":"def modified_counting_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count_arr = [0] * range_of_elements output_arr = [0] * len(arr) for num in arr: count_arr[num - min_val] += 1 for i in range(1, len(count_arr)): count_arr[i] += count_arr[i-1] for num in reversed(arr): output_arr[count_arr[num - min_val] - 1] = num count_arr[num - min_val] -= 1 return output_arr"},{"question":"Scenario You are tasked with ensuring binary communication transmissions are efficient and free of errors. One common issue is checking whether the binary sequence of transmitted numbers has alternating bits. This property is crucial for preventing confusion in certain communication protocols. Task Write a function `has_alternating_bits(n: int) -> bool` which determines if a given positive integer `n` has alternating bits in its binary representation. You should implement both a standard iterative solution and an optimized solution, and then write a unified function which decides which method to use based on certain predefined conditions. Function Signature ```python def has_alternating_bits(n: int) -> bool: pass ``` Input * A positive integer `n`. Output * A boolean value `True` if `n` has alternating bits, `False` otherwise. Constraints 1. (1 leq n leq 2^{31} - 1) Example ```python assert has_alternating_bits(5) == True # binary: 101 assert has_alternating_bits(7) == False # binary: 111 assert has_alternating_bits(11) == False # binary: 1011 assert has_alternating_bits(10) == True # binary: 1010 ``` Requirements 1. Implement an iterative solution similar to `has_alternative_bit`. 2. Implement an optimized solution similar to `has_alternative_bit_fast`. 3. Combine the two methods into `has_alternating_bits`: - Use the iterative method for smaller values. - Use the optimized method for larger values.","solution":"def has_alternating_bits(n: int) -> bool: Determines if a given positive integer has alternating bits in its binary representation. def has_alternating_bits_iterative(n: int) -> bool: Iterative solution to check if a number has alternating bits. current_bit = n & 1 n >>= 1 while n > 0: next_bit = n & 1 if current_bit == next_bit: return False current_bit = next_bit n >>= 1 return True def has_alternating_bits_optimized(n: int) -> bool: Optimized solution to check if a number has alternating bits. xor_n = n ^ (n >> 1) return (xor_n & (xor_n + 1)) == 0 # Define a threshold to choose between the two methods ITERATIVE_THRESHOLD = 2 ** 20 if n < ITERATIVE_THRESHOLD: return has_alternating_bits_iterative(n) else: return has_alternating_bits_optimized(n)"},{"question":"# Context You are working on a data preprocessing module where you need to filter sensor data readings based on given value constraints. The data readings come in the form of a list of integers. Your task is to write a function that takes in the list of readings and optional minimum and maximum threshold values, then returns a filtered list with only the readings that fall within the given range. # Function Specification **Function Name**: `filter_readings` **Inputs**: - `readings` (List of integers): The sensor data readings. - `min_val` (Integer, optional): The minimum value threshold. Default is None. - `max_val` (Integer, optional): The maximum value threshold. Default is None. **Outputs**: - List of integers: A filtered list containing readings that lie between `min_val` and `max_val`, inclusive. # Constraints 1. The input list can be empty, in which case the output should also be an empty list. 2. If `min_val` is not provided, any reading greater than or equal to the smallest reading in the list should be considered. 3. If `max_val` is not provided, any reading less than or equal to the largest reading in the list should be considered. 4. You should not use any additional data structures apart from lists. # Example ```python # Examples # Example 1: readings = [3, 10, 15, 7, 8, 2] min_val = 5 max_val = 10 # Explanation: Filtering the readings that are >= 5 and <= 10, resulting in [10, 7, 8] print(filter_readings(readings, min_val, max_val)) # Output: [10, 7, 8] # Example 2: readings = [3, 10, 15, 7, 8, 2] min_val = None max_val = 8 # Explanation: Filtering the readings that are <= 8, resulting in [3, 7, 8, 2] print(filter_readings(readings, min_val, max_val)) # Output: [3, 7, 8, 2] # Example 3: readings = [] min_val = None max_val = None # Explanation: Empty input should return an empty list print(filter_readings(readings, min_val, max_val)) # Output: [] ``` # Performance Requirements - Ensure the solution runs efficiently with a time complexity of O(n), where n is the number of readings in the input list. # Notes You can assume that the readings and limit values, if provided, are all integers. There is no need to handle non-integer inputs or elements in the array.","solution":"def filter_readings(readings, min_val=None, max_val=None): Filters sensor data readings based on optional minimum and maximum threshold values. Parameters: readings (list of int): The sensor data readings. min_val (int, optional): The minimum value threshold. Default is None. max_val (int, optional): The maximum value threshold. Default is None. Returns: list of int: A filtered list containing readings that lie between min_val and max_val, inclusive. if min_val is None: min_val = min(readings, default=None) if max_val is None: max_val = max(readings, default=None) return [reading for reading in readings if (min_val is None or reading >= min_val) and (max_val is None or reading <= max_val)]"},{"question":"# Insertion Sort Implementation with Search Insert Function **Scenario**: You are working on optimizing the insertion sort algorithm by using a helper function, `search_insert`, which utilizes binary search to determine the position for insertion of the next element. This should theoretically reduce the number of comparisons needed when inserting the element into the sorted section of the list. **Objective**: Write a function named `insertion_sort` that sorts a list of integers in ascending order using the provided `search_insert` function to find the correct index for each insertion. # Function Signature ```python def insertion_sort(array: List[int]) -> List[int]: ``` # Input: * `array`: a list of integers, which may be of any length (including empty). # Output: * A new list of integers where the original list is sorted in ascending order. # Constraints: * The list can include negative integers. * In the simplest case, assume no duplicate elements (although the provided search_insert function is stable). * The solution should efficiently handle edge cases like empty lists. # Performance Requirements: * Since the theoretical improvement with `search_insert` still maintains O(n^2) time complexity, focus on correct implementation and handling edge cases. # Example: ```python assert insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert insertion_sort([-1, 2, -8, -10, 15, 4]) == [-10, -8, -1, 2, 4, 15] assert insertion_sort([]) == [] assert insertion_sort([1]) == [1] assert insertion_sort([5, 3, 7, 1, 4]) == [1, 3, 4, 5, 7] ``` # Notes: * Use the provided `search_insert` function to determine the correct position for each element. * Handle edge cases as appropriate to ensure robust implementation. Good luck, and happy coding!","solution":"from typing import List def search_insert(array: List[int], target: int) -> int: Implements binary search to find the insert position for a target in a sorted array. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid - 1 return left def insertion_sort(array: List[int]) -> List[int]: Sorts an array of integers in ascending order using insertion sort with binary search for insertion. sorted_array = [] for element in array: pos = search_insert(sorted_array, element) sorted_array.insert(pos, element) return sorted_array"},{"question":"**Problem Scenario**: You are tasked with analyzing and improving binary sequences. Given an integer, you need to determine the length of the longest sequence of 1s you could create by flipping exactly one bit from 0 to 1. This task will assess your ability to navigate and manipulate binary representations for optimization purposes. **Function to Implement**: ```python def flip_bit_longest_seq(num: int) -> int: Given an integer `num`, returns the length of the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1. Parameters: num (int): An integer which is the input number. Returns: int: The length of the longest sequence of 1s obtainable by flipping one bit. pass ``` **Input and Output**: * Input: A single integer `num` - Constraints: Assume `num` is a non-negative integer. * Output: An integer representing the maximum length of 1s possible by flipping one bit from 0 to 1. **Performance Requirements**: * The solution should have a time complexity of O(b), where b is the number of bits in the integer binary representation. * The space complexity should be constant, O(1). **Example**: ```python assert flip_bit_longest_seq(1775) == 8 # Explanation: Binary representation is 11011101111. Flipping the 0 after the fifth 1 yields 111111111, which has eight 1s. ``` Ensure to handle edge cases such as: * When the input is 0, the output should be 1. * When the input has all bits as 1s (e.g., 15 -> 1111), the output should be the length of the binary representation plus one.","solution":"def flip_bit_longest_seq(num: int) -> int: Given an integer `num`, returns the length of the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1. Parameters: num (int): An integer which is the input number. Returns: int: The length of the longest sequence of 1s obtainable by flipping one bit. if num == 0: return 1 # flipping the only bit from 0 to 1 gives a sequence of length 1 prev_len = 0 curr_len = 0 max_len = 1 # We can always get at least a sequence of 1 by flipping one bit while num != 0: if num & 1 == 1: curr_len += 1 else: prev_len = 0 if (num & 2) == 0 else curr_len curr_len = 0 max_len = max(max_len, prev_len + curr_len + 1) num >>= 1 return max_len"},{"question":"You are provided with the implementation of the Interpolation Search algorithm. Your task is to extend this algorithm to handle a specific type of edge cases gracefully and demonstrate enhanced understanding by combining multiple competencies. Requirements: 1. **Function Name**: `advanced_interpolation_search` 2. **Parameters**: - `array: List[int]` - The sorted array of integers to be searched. - `search_key: int` - The integer value to be looked for in the array. 3. **Output**: - Returns an integer which is the index of the `search_key` in `array` if found, otherwise -1. 4. **Additional Requirement**: Handle cases where the array elements might include duplicates, and return any one of the possible indexes for the `search_key`. 5. **Constraints**: - The array will contain at most (10^6) elements. - The elements of the array and `search_key` will be within the range (-10^9) to (10^9). Example: ```python >>> advanced_interpolation_search([1, 3, 3, 3, 10, 12], 3) 1 >>> advanced_interpolation_search([1, 3, 3, 3, 10, 12], 10) 4 >>> advanced_interpolation_search([-10, -5, 0, 5, 9], 7) -1 ``` Explanation: 1. The function should correctly identify the index of the search key and if multiple instances exist, return any valid index. 2. Implement efficient handling of edge cases where the array might have duplicates. # Hints: * Consider slight modifications to the position formula or logic to handle duplicates effectively. * Ensure the solution has a focus on maintaining efficient time and space complexity applicable to the problem constraints. ___ Provide your solution by implementing the `advanced_interpolation_search` function in Python.","solution":"def advanced_interpolation_search(array, search_key): Perform an interpolation search on a sorted array to find the index of the search_key. Returns any one index of the search_key if duplicates exist. :param array: List[int] - The sorted array of integers to be searched. :param search_key: int - The integer value to be looked for in the array. :return: int - The index of the search_key in array if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Calculate the position using interpolation formula pos = low + ((high - low) // (array[high] - array[low] + 1) * (search_key - array[low])) # Ensure pos is within the current search bounds pos = min(max(low, pos), high) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question: Walls and Gates Background You are given a 2D grid initialized with the following possible values: - **-1**: A wall or an obstacle. - **0**: A gate. - **INF**: Infinity represents an empty room. We use the value `2^31 - 1 = 2147483647` to represent INF as you may assume that the distance to a gate is less than `2147483647`. Your task is to write a function that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the space should remain filled with `INF`. Input - **rooms**: a list of lists of integers representing the 2D grid (each integer is either `-1`, `0`, or `2147483647`). Output - Modify the input `rooms` grid in place such that each empty room is filled with the distance to its nearest gate. Constraints - The grid is not necessarily square; its dimensions can be `m x n`. - The distances should be calculated using Manhattan distance, i.e., vertical and horizontal movements only (no diagonal moves). - You must perform the operation in place; do not return a new grid. Example ```plaintext Input: [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] Output: [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` Implementation To solve the problem efficiently, you might consider implementing a modified BFS traversal starting from all gates simultaneously. Unlike DFS, BFS ensures the shortest path is found first, making it more suitable for this problem. ```python def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) queue = [] # Enqueue all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from all gates while queue: x, y = queue.pop(0) for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny)) ```","solution":"def walls_and_gates(rooms): Fill each empty room with the distance to its nearest gate in place. If it is impossible to reach a gate, the space remains filled with INF. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) queue = [] # Enqueue all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from all gates while queue: x, y = queue.pop(0) for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"**Question**: Implement a function that solves the \\"Two Sum\\" problem efficiently. Your function should take an array of integers and a target integer. It should return a tuple of indices of two numbers such that they add up to the target. The function should handle edge cases and invalid inputs gracefully. **Function Signature**: ```python def two_sum(array: list, target: int) -> tuple: pass ``` # Input: 1. `array` (list of integers): An array of integers `[a_1, a_2, ..., a_n]` where `n` is the array length (1 ≤ n ≤ 10^7). 2. `target` (integer): The target sum that the function must find using two distinct elements in the array. # Output: - Return a tuple of two indices `(i, j)` where `array[i] + array[j] = target` and `i` is not equal to `j`. # Constraints: - Each input will have exactly one solution. - You may not use the same element twice. - The output tuple should be in the order of their first appearance. # Examples: ```python assert two_sum([2, 7, 11, 15], 9) == (0, 1) assert two_sum([3, 2, 4], 6) == (1, 2) assert two_sum([3, 3], 6) == (0, 1) ``` # Performance Requirements: - The solution should be efficient with a time complexity of O(n). - The solution should use extra space efficiently, preferably O(n). # Instructions: 1. Implement the `two_sum` function considering the above constraints. 2. Ensure your implementation handles edge cases like invalid inputs properly. 3. Assume inputs are always valid as the constraints guarantee one solution.","solution":"def two_sum(array: list, target: int) -> tuple: Returns a tuple of indices of the two numbers in the array that add up to the target. num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index raise ValueError(\\"No two sum solution found\\") # Note: The function assumes that there is exactly one solution, # hence the ValueError should never be raised according to the problem constraints."},{"question":"Context You are designing a file management system that requires consistent and accurate file paths. One of your functions must process various paths provided by users, standardize them, and convert them to absolute paths for internal use. Task Implement a function `absolute_file_path`, which takes a single string argument representing a file path. This function should expand any user directory symbols (`~`) to the corresponding home directory full path and then convert this path to an absolute path. Input - A single string representing the file path. This path may include user directory shorthand (`~`) and can be relative or absolute. Output - A single string representing the absolute path of the given file. Constraints - The input path string is non-empty. - The home directory exists. - Paths will not include any special devices or unusual mount points. Performance Requirements - The function should operate efficiently within typical constraints of file manipulation scripts. - Minimize the number of system calls where possible. Example Scenarios ```python assert absolute_file_path(\\"~\\") == \\"/home/username\\" # Example output assuming standard Unix home directory assert absolute_file_path(\\"~/documents/file.txt\\") == \\"/home/username/documents/file.txt\\" assert absolute_file_path(\\"./file.txt\\") == \\"/current/working/directory/file.txt\\" assert absolute_file_path(\\"/etc/hosts\\") == \\"/etc/hosts\\" ``` Additional Notes - Make sure to handle edge cases such as empty strings or invalid paths gracefully. - The solution should be implemented as platform-independent as possible but assume a Unix-like system for home directory expansion.","solution":"import os def absolute_file_path(path): Converts a given path to its absolute form, expanding user directory symbols if necessary. expanded_path = os.path.expanduser(path) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Minimum Path Cost in a Directed Acyclic Graph You are given a cost matrix where the cost `cost[i][j]` represents the cost of moving directly from station `i` to station `j` (for all `i < j`). Your task is to find the minimum cost to travel from station `0` to station `N-1`. **Function Signature:** ```python def min_cost(cost: List[List[int]]) -> int: ``` **Input:** - `cost`: A 2D list of integers where `cost[i][j]` (0 ≤ i < j < N) represents the cost to travel from station `i` to station `j`. If `i ≥ j`, `cost[i][j]` is irrelevant and may be represented by `-1` or `INF`. The matrix is guaranteed to have no negative cycles. **Output:** - Return an integer representing the minimum cost to travel from station `0` to station `N-1`. # Examples 1. **Example 1:** ```python costs = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] ``` **Input:** - cost matrix as mentioned above **Output:** - 65 (Path: 0 → 1 → 3) 2. **Example 2:** ```python costs = [ [0, 20, 30], [-1, 0, 10], [-1, -1, 0] ] ``` **Input:** - cost matrix as above **Output:** - 30 (Path: 0 → 2) **Constraints:** - 2 ≤ N ≤ 100 - -1 ≤ cost[i][j] ≤ 1000 for all valid `i, j` - The cost to travel from a station to itself is 0 (`cost[i][i] = 0`) **Additional Notes:** - You can assume that there will always be at least one valid path from station 0 to station N-1. - Your algorithm should be efficient in terms of time and space complexity.","solution":"from typing import List def min_cost(cost: List[List[int]]) -> int: N = len(cost) min_costs = [float(\'inf\')] * N min_costs[0] = 0 for i in range(N): for j in range(i + 1, N): if cost[i][j] != -1: if min_costs[j] > min_costs[i] + cost[i][j]: min_costs[j] = min_costs[i] + cost[i][j] return min_costs[N-1]"},{"question":"# Task Description Given a linked list, implement a function to detect the first node of a cycle within the linked list using Floyd\'s Tortoise and Hare algorithm. If there\'s no cycle, return `None`. # Function Signature ```python def first_cyclic_node(head: Node) -> Node: # your code here ``` # Input - `head (Node)`: The head of the linked list. # Output - Returns the node where the cycle begins. If there’s no cycle, return `None`. # Constraints - The linked list can contain any type of data. - Utilize Floyd’s Cycle-Finding algorithm for this task. # Examples ```python # Example 1: # Input: head = 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starts at node with value 2) # Output: Node with value 2 # Example 2: # Input: head = A -> B -> C -> D -> E -> C (cycle starts at node with value C) # Output: Node with value C # Example 3: # Input: head (with no cycle): A -> B -> C -> D -> E # Output: None ``` # Scenario You are involved in developing a tool for validating data structures. One of the crucial checks involves confirming if a sequence of computational tasks forms a loop, which is represented as a linked list forming a cycle. Write a function to detect this anomaly so that you can avoid potential infinite loops during computing. # Notes - Ensure your function works on edge cases such as empty linked lists or lists with single nodes. - You should test the function with various tail lengths and different cycle starting points. - The solution must efficiently handle both small and large linked lists.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def first_cyclic_node(head: Node) -> Node: slow = fast = head # Detect if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are tasked with determining the minimum number of steps required to make two given words the same, where in each step you can delete one character in either of the two strings. # Function Signature ```python def min_distance(word1: str, word2: str) -> int: ``` # Input - `word1`: a string of length up to 1000. - `word2`: a string of length up to 1000. # Output - Return an integer representing the minimum number of steps required. # Constraints 1. The strings can contain ASCII characters. 2. Performance: Minimize time complexity. # Example ```python assert min_distance(\\"sea\\", \\"eat\\") == 2 ``` *Explanation*: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". # Instructions - Implement the `min_distance` function using a dynamic programming approach to ensure efficient processing. - You should avoid using the recursive approach due to its high time complexity. - Your solution should handle edge cases such as empty strings. # Hints - Consider using a 2D table to store results of subproblems. - Optimize space usage if possible by using only two arrays instead of the full 2D table.","solution":"def min_distance(word1: str, word2: str) -> int: Given two words word1 and word2, returns the minimum number of steps required to make the two words the same where in each step you can delete one character in either string. m, n = len(word1), len(word2) # Create a 2D DP array with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, we need to delete all characters of word2 elif j == 0: dp[i][j] = i # If word2 is empty, we need to delete all characters of word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the characters match, no deletions are required else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 # Choose the best option between deleting from word1 or word2 return dp[m][n]"},{"question":"# Binary Search Tree Applications You are working as a software engineer in a company that handles large datasets of numerical data. One of the requirements is to design an efficient system for maintaining and querying such datasets. You are required to implement a Binary Search Tree (BST) with the following functions: 1. **Insert**: Add a new element. 2. **Search**: Check if an element exists. 3. **Size**: Return the count of elements in the BST. 4. **Traversal**: Functions to traverse the tree in Preorder, Inorder, and Postorder. Your task is to implement the following methods in a class `BST`: 1. `insert(self, data: int) -> bool`: Insert a new integer into the BST. Returns `True` if the insertion is successful, or `False` if the integer already exists. 2. `search(self, data: int) -> bool`: Search for an integer in the BST. Returns `True` if the integer exists, or `False` otherwise. 3. `size(self) -> int`: Return the number of elements in the BST. 4. `preorder(self, node: \'Node\') -> List[int]`: Perform a Preorder traversal of the BST and return the list of elements. 5. `inorder(self, node: \'Node\') -> List[int]`: Perform an Inorder traversal of the BST and return the list of elements. 6. `postorder(self, node: \'Node\') -> List[int]`: Perform a Postorder traversal of the BST and return the list of elements. # Implementation Details: - Use the provided `Node` class for tree nodes. - Ensure the operations conform to the specified average and worst-case time complexities. - Optimize and handle the edge cases correctly, including empty trees and skewed conditions. - Provide thorough unit tests demonstrating the correctness of the functions. # Constraints: - The BST should be capable of handling up to ( 10^5 ) nodes efficiently. - Each operation should be optimized to use minimal memory and ensure low computational overhead. # Example: ```python # Example Usage: bst = BST() bst.insert(10) # Returns: True bst.insert(5) # Returns: True bst.insert(15) # Returns: True bst.insert(10) # Returns: False (Duplicate) bst.search(15) # Returns: True bst.search(99) # Returns: False bst.size() # Returns: 3 print(bst.inorder(bst.get_root())) # Returns: [5, 10, 15] ``` Implement the `BST` class based on the provided method signatures and constraints.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def get_root(self): return self.root def insert(self, data: int) -> bool: if self.search(data): return False self.root = self._insert(self.root, data) self.node_count += 1 return True def _insert(self, node, data): if node is None: return Node(data) if data < node.data: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) return node def search(self, data: int) -> bool: return self._search(self.root, data) def _search(self, node, data): if not node: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def size(self) -> int: return self.node_count def preorder(self, node: \'Node\', result=None) -> list: if result is None: result = [] if node: result.append(node.data) self.preorder(node.left, result) self.preorder(node.right, result) return result def inorder(self, node: \'Node\', result=None) -> list: if result is None: result = [] if node: self.inorder(node.left, result) result.append(node.data) self.inorder(node.right, result) return result def postorder(self, node: \'Node\', result=None) -> list: if result is None: result = [] if node: self.postorder(node.left, result) self.postorder(node.right, result) result.append(node.data) return result"},{"question":"# Question: Implement a CircularQueue You are required to implement a `CircularQueue`, which enhances a standard queue by efficiently utilizing the space of a fixed-size list. Unlike a standard queue using a dynamic array or linked list which may need resizing or extra memory for links, a circular queue reuses the available array space. Functionality Requirements 1. **Initialization:** - `__init__(self, capacity)`: Initializes the queue with a fixed capacity and sets up internal pointers. 2. **Enqueue:** - `enqueue(self, value)`: Adds a value to the rear of the queue. - Ensure efficient use of space, wrapping around if necessary. 3. **Dequeue:** - `dequeue(self)`: Removes and returns the front value of the queue. - Utilize circular indexing for efficient space usage. 4. **Peek:** - `peek(self)`: Returns the front value without removing it. 5. **isEmpty:** - `isEmpty(self)`: Checks if the queue is empty. 6. **isFull:** - `isFull(self)`: Checks if the queue is full. Input and Output - The queue operations should use the circular buffer efficiently, ensuring space optimization. - Follow proper error handling by raising appropriate exceptions for invalid operations. Constraints - The queue capacity is a positive integer. - Operations should be performed in constant time, O(1). Code Template ```python class CircularQueue: def __init__(self, capacity): # Initialize the queue with the given capacity def enqueue(self, value): # Add an element to the queue and handle circular indexing def dequeue(self): # Remove and return an element from the queue and handle circular indexing def peek(self): # Return the front element without removing it def isEmpty(self): # Check if the queue is empty def isFull(self): # Check if the queue is full def __len__(self): # Return the number of elements in the queue ``` Example ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) print(cq.dequeue()) # Output: 1 cq.enqueue(3) cq.enqueue(4) print(cq.isFull()) # Output: True print(cq.peek()) # Output: 2 cq.dequeue() print(cq.peek()) # Output: 3 ``` Implement the `CircularQueue` class following the provided constraints and functionality requirements.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = self.rear = self.size = 0 def enqueue(self, value): if self.isFull(): raise Exception(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") return self.queue[self.front] def isEmpty(self): return self.size == 0 def isFull(self): return self.size == self.capacity def __len__(self): return self.size"},{"question":"# Exchange Sort Implementation and Optimization Problem Statement You are tasked with implementing an optimized version of the exchange sort algorithm. The primary goal is to reduce unnecessary comparisons and swaps, especially when the array is already sorted or nearly sorted. Function Signature ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers to be sorted (e.g., [3, 1, 4, 1, 5, 9, 2, 6, 5]). Output - Returns a sorted list of integers in ascending order. Constraints - The function should handle arrays of any reasonable size (up to 10^3 elements). - The function must be optimized to minimize unnecessary comparisons and swaps. Performance Requirements - The function should have a time complexity of O(n^2) in the worst case but strive for better performance in practical scenarios. - Space complexity must remain O(1). Example ```python assert optimized_exchange_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) == [1, 1, 2, 3, 4, 5, 5, 6, 9] assert optimized_exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] # Already sorted array assert optimized_exchange_sort([]) == [] # Empty array assert optimized_exchange_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] # Reverse sorted array ``` Requirements 1. Implement the `optimized_exchange_sort` function. 2. Aim to reduce unnecessary comparisons and swaps. 3. Ensure the array remains unmodified outside the function. Note To achieve an optimized implementation, consider introducing a flag to detect if any swaps were made during an iteration. If no swaps occur, the array is already sorted, and the algorithm can terminate early.","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: Sorts an array using an optimized version of the exchange sort algorithm. n = len(arr) for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"Scenario You are designing a parser for a modern programming language, and a key component is ensuring that the code contains properly matched and nested brackets. To help with this, you need to implement a function that verifies if a sequence of brackets in a given string is valid. # Problem Statement Write a function `is_valid` that determines if a given string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'` is a valid bracket sequence. A string is considered valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. # Input * A single string `s` containing only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. * The length of `s` will be between 0 and 10^4. # Output * Return `True` if the string is valid, otherwise return `False`. # Constraints * The string will consist only of characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. # Example ```python is_valid(\\"()\\") # Returns: True is_valid(\\"()[]{}\\") # Returns: True is_valid(\\"(]\\") # Returns: False is_valid(\\"([)]\\") # Returns: False is_valid(\\"{[]}\\") # Returns: True is_valid(\\"\\") # Returns: True ``` # Additional Notes * Consider edge cases such as an empty string, strings with only one type of bracket, and strings with mismatched brackets. * Aim for an efficient solution with a time complexity of O(n) and space complexity of O(n).","solution":"def is_valid(s): Determines if a given string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a valid bracket sequence. :param s: A string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' :return: True if the string is a valid bracket sequence, otherwise False. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return False else: return False return stack == []"},{"question":"Last Occurrence in a Sorted Array You need to implement a function that finds the last occurrence of a given element in a sorted array. The array is sorted in increasing order. If the element is not present in the array, return `None`. # Function Signature ```python def last_occurrence(array: List[int], query: int) -> Union[int, None]: ``` # Input * `array`: A list of integers sorted in increasing order. (0 <= len(array) <= 10^6) * `query`: An integer to find the last occurrence of. # Output * Return the index of the last occurrence of `query` in the array. If `query` is not found, return `None`. # Constraints * The input array can be empty. * Your solution should have a time complexity of O(log n). # Examples ```python assert last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert last_occurrence([1, 2, 2, 2, 3, 4, 5], 6) == None assert last_occurrence([], 2) == None assert last_occurrence([1, 3, 5, 7, 9], 5) == 2 ``` Implement the function `last_occurrence` that adheres to the given signature and requirements.","solution":"from typing import List, Union def last_occurrence(array: List[int], query: int) -> Union[int, None]: Finds the last occurrence of \'query\' in \'array\'. If \'query\' is not present in \'array\', return None. low, high = 0, len(array) - 1 result = None while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # Continue searching in the right half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Scenario You are tasked with implementing a function to compute the binomial coefficient for given values of ( n ) and ( k ). This coefficient is a fundamental concept in combinatorics and often arises in statistical calculations, algorithm design, and probability theory. # Task Write a Python function `binomial_coefficient` that calculates the binomial coefficient ( C(n, k) ) using dynamic programming to avoid the inefficiencies and limitations of the recursive approach shown. # Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - Two integers `n` (0 ≤ n ≤ 1000) and `k` (0 ≤ k ≤ n). # Output - An integer representing the binomial coefficient ( C(n, k) ). # Constraints - 0 ≤ n ≤ 1000 - 0 ≤ k ≤ n # Performance Requirements Your implementation should handle the maximum input values efficiently (i.e., within reasonable time under typical contest or assessment conditions). # Example ```python >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(8, 2) 28 >>> binomial_coefficient(10, 5) 252 ``` # Hints - Remember the symmetry property ( C(n, k) = C(n, n-k) ). - Think about how you can build up a solution step-by-step using already computed values (dynamic programming).","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculates binomial coefficient C(n, k) using dynamic programming. if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) # because C(n, k) == C(n, n-k) dp = [0] * (k + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): dp[j] += dp[j - 1] return dp[k]"},{"question":"# Question You are tasked with implementing a function that determines if a given string is a \\"friendly pangram sentence.\\" A friendly pangram sentence is defined as follows: 1. It must contain all letters of the English alphabet at least once. 2. It should ignore numbers, punctuation, and other non-alphanumeric characters. 3. It should be case-insensitive. You need to implement the function `check_friendly_pangram(input_string)` that returns `True` if the input string is a friendly pangram sentence and `False` otherwise. Input - `input_string`: A string containing characters, including whitespace, punctuation, and alphanumeric characters. Output - Returns `True` if the input string is a friendly pangram sentence, otherwise returns `False`. Constraints - The input string can have a length up to 10,000 characters. - The input string may contain special characters and spaces. Example ```python check_friendly_pangram(\\"The quick brown fox jumps over the lazy dog!\\") # Should return: True check_friendly_pangram(\\"The quick brown fox jumps over the lazy dog!\\") # Should return: False (missing some alphabet letters) ``` Performance requirements Your solution should aim to complete in linear time relative to the size of the input string, and with constant extra space. Scenario Imagine you\'re working on a language learning app that assesses user\'s inputs to see if they\'ve included all the letters of the alphabet in their creative sentences. It\'s crucial that the app can correctly identify such sentences regardless of various punctuations and symbols while ensuring it\'s efficient even with longer paragraphs. Write the implementation of the function `check_friendly_pangram(input_string)` in Python.","solution":"def check_friendly_pangram(input_string): Returns True if the input string is a friendly pangram sentence, otherwise False. A friendly pangram sentence must contain every letter of the English alphabet at least once, ignoring numbers, punctuation, and case. # Create a set of all lowercase English alphabet letters alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') # Convert the input string to lowercase and create a set of characters from it input_set = set(ch.lower() for ch in input_string if ch.isalpha()) # Check if the input set contains all the letters in the alphabet set return alphabet_set <= input_set"},{"question":"# Matrix Chain Multiplication Optimization The task is to implement a method for finding the most efficient way to multiply a sequence of matrices given their dimensions, thereby minimizing the number of scalar multiplications. # Problem Statement Given an array `arr[]` where the `i-th` element represents dimensions of a matrix such that matrix `A_i` has dimensions `arr[i-1] x arr[i]`, write a function to find the minimum number of scalar multiplications needed to multiply the chain of matrices. # Function Signature ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Find the minimum multiplication cost and the matrix chains resulting. Parameters: array (List[int]): Array of matrix dimensions. Returns: Tuple[List[List[int]], List[List[int]]]: Returns a tuple of two 2D lists; - the first one containing minimum multiplication costs, - the second one containing matrix split points. ``` Additionally, implement a method to print the optimal parenthesization. ```python def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: Prints the optimal parenthesization. Arguments: optimal_solution (List[List[int]]): The matrix split points. i (int): The start matrix index. j (int): The end matrix index. ``` # Constraints * `1 <= len(array) <= 100` * Matrix dimensions should be valid for multiplication. # Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"No. of operations required: \\" + str(matrix[1][len(array)-1])) print_optimal_solution(optimal_solution, 1, len(array)-1) ``` Output: ``` No. of operations required: 15125 ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Notes * Make sure to handle edge cases such as an empty array or an array with only one matrix. * Ensure that your code is optimized for performance to handle the upper constraint limits effectively.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n): # l is the chain length. for i in range(1, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\'\') else: print(\\"(\\", end=\'\') print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\'\')"},{"question":"Given an absolute path for a file (Unix-style), your task is to simplify it and return the canonical path. The canonical path should: 1. Eliminate any intermediate \\".\\" (current directory) elements. 2. Interpret \\"..\\" (move up to parent directory) correctly, ensuring it does not go beyond the root. 3. Remove any redundant slashes. You are to implement the function `simplify_path(path: str) -> str`. Input Format: - `path`: A string representing the Unix-style file path. The path starts with a \'/\' and may contain multiple slashes and dots. Output Format: - The function should return a simplified canonical path as a string. Constraints: - The input path will not be an empty string. - The path will start with a \'/\'. Examples: ```python simplify_path(\\"/home/\\") => \\"/home\\" simplify_path(\\"/a/./b/../../c/\\") => \\"/c\\" simplify_path(\\"/../\\") => \\"/\\" simplify_path(\\"/home//foo/\\") => \\"/home/foo\\" ``` # Additional Context: You are developing a file system browser and need to sanitize the paths provided by users to ensure consistency and security. Properly simplifying paths helps in preventing user errors and potential security vulnerabilities such as directory traversal attacks. # Objective: Implement the function `simplify_path(path)` according to the requirements above, ensuring your solution is efficient and handles all edge cases.","solution":"def simplify_path(path: str) -> str: components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue if component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Problem: Consecutive Power Sum Numbers You are given two integers `low` and `high` which define an inclusive range [low, high]. A number is said to have the consecutive power sum property if the sum of its digits each raised to consecutive powers starting from 1 is equal to the number itself. For example: - 89 has this property because 8^1 + 9^2 = 8 + 81 = 89. - 135 has this property because 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135. Your task is to implement the function `sum_dig_pow` that takes two integers `low` and `high` and returns a list of all numbers in this range that have this consecutive power sum property. Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` Input - `low` (int): Lower bound of the range (1 ≤ low ≤ 10^6). - `high` (int): Upper bound of the range (1 ≤ high ≤ 10^6). Output - List[int]: A list of integers in the range [low, high] that fulfill the consecutive power sum property. Constraints - 1 ≤ low ≤ high ≤ 10^6 - The length of the list should be minimized, ordered increasingly. Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Notes: - Pay attention to the efficiency of your algorithm, it should perform well for large ranges up to 10^6. - Consider edge cases: single-digit numbers, the boundaries of the range, and large numbers close to the upper limit.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def has_consecutive_power_sum_property(n): digits = [int(d) for d in str(n)] power_sum = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return power_sum == n result = [] for num in range(low, high + 1): if has_consecutive_power_sum_property(num): result.append(num) return result"},{"question":"Implement Insertion Sort Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time. In your implementation, use the \'search_insert\' function to determine the correct insertion point of each element. *Implement the following function:* ```python def insertion_sort(array): Function to perform insertion sort on a given list using the binary search helper function. Parameters: array (List[int]): A list of integers to be sorted. Returns: List[int]: Sorted list of integers. pass ``` # Example: ```python array = [5, 2, 9, 1, 5, 6] print(insertion_sort(array)) # Output: [1, 2, 5, 5, 6, 9] ``` # Constraints: * The function should use the binary search helper method \'search_insert\' provided. * You are not allowed to use built-in sort functions. * The function should sort the array in-place with O(1) extra space complexity. * The input array can have up to (10^5) integers (performance must be considered). # Requirements: * Optimize your solution to handle large arrays efficiently. * Consider and handle edge cases such as empty arrays. * Provide a thorough testing section to validate your implementation.","solution":"def search_insert(array, target, start, end): Helper function to find the index where \'target\' should be inserted in the sorted subarray \'array[start:end+1]\'. Parameters: array (List[int]): The list of integers to be sorted. target (int): The target value for which the insertion index is to be found. start (int): The starting index of the sorted subarray. end (int): The ending index of the sorted subarray. Returns: int: The index where \'target\' should be inserted to maintain sorted order. while start <= end: mid = (start + end) // 2 if array[mid] < target: start = mid + 1 else: end = mid - 1 return start def insertion_sort(array): Function to perform insertion sort on a given list using the binary search helper function. Parameters: array (List[int]): A list of integers to be sorted. Returns: List[int]: Sorted list of integers. for i in range(1, len(array)): key = array[i] # Find the position where the key should be inserted j = search_insert(array, key, 0, i-1) # Move all elements to the right to make space for the key while i > j: array[i] = array[i - 1] i -= 1 array[j] = key return array"},{"question":"# Bit Manipulation Challenge Context: You are working on a low-level embedded system where memory usage and execution speed are critical considerations. Your task is to manipulate individual bits of an integer to perform various operations efficiently. Problem: Implement the following four functions for bit manipulation on a 32-bit unsigned integer: 1. **get_bit(num, i)**: This function returns the bit at the ith position in the binary representation of `num` (0-indexed from right). 2. **set_bit(num, i)**: This function sets (turns to 1) the bit at the ith position in the binary representation of `num`. 3. **clear_bit(num, i)**: This function clears (turns to 0) the bit at the ith position in the binary representation of `num`. 4. **update_bit(num, i, bit)**: This function updates the bit at the ith position in the binary representation of `num` to the value `bit` (either 0 or 1). # Input: - `num`: a non-negative integer (0 ≤ `num` < 2^32) - `i`: an integer indicating the bit index (0 ≤ `i` < 32) - `bit`: an integer which is either 0 or 1 (for `update_bit` function) # Output: - `get_bit`: returns 1 if the bit at index `i` is set, otherwise returns 0. - `set_bit`: returns the number after setting the bit at index `i`. - `clear_bit`: returns the number after clearing the bit at index `i`. - `update_bit`: returns the number after updating the bit at index `i` to `bit`. # Constraints: - You must use bitwise operations to complete the tasks. - Avoid using additional data structures or libraries for the core operations. Example: ```python # Example inputs and expected outputs for each function num = 10 # binary representation: 1010 # get_bit(num, 1) # Expected output: 1 (because bit at index 1 is set) assert get_bit(num, 1) == 1 # set_bit(num, 2) # Expected output: 14 (binary 1110) assert set_bit(num, 2) == 14 # clear_bit(num, 1) # Expected output: 8 (binary 1000) assert clear_bit(num, 1) == 8 # update_bit(num, 2, 1) # Expected output: 14 (binary 1110) assert update_bit(num, 2, 1) == 14 # update_bit(num, 3, 0) # Expected output: 2 (binary 0010) assert update_bit(num, 3, 0) == 2 ``` Write implementations for the functions `get_bit(num, i)`, `set_bit(num, i)`, `clear_bit(num, i)`, and `update_bit(num, i, bit)`.","solution":"def get_bit(num, i): Returns the bit at the ith position in the binary representation of num. return (num >> i) & 1 def set_bit(num, i): Sets (turns to 1) the bit at the ith position in the binary representation of num. return num | (1 << i) def clear_bit(num, i): Clears (turns to 0) the bit at the ith position in the binary representation of num. return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at the ith position in the binary representation of num to bit. return (num & ~(1 << i)) | (bit << i)"},{"question":"# Balanced Binary Tree Verification **Scenario**: You\'re developing a database indexing system where the structure of the tree is critical for performance. To ensure the efficiency of the tree structure used for indexing, it\'s essential to verify if a given binary tree is balanced or not. **Task**: Write a function `is_balanced_tree(root)` that determines if a binary tree is height-balanced. A binary tree is considered balanced if for any node in the tree, the difference in the heights of the left and right subtrees is at most 1. **Function Signature**: ```python def is_balanced_tree(root) -> bool: # Your code goes here ``` **Input Format**: * `root` (TreeNode): The root of the binary tree. Each `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` **Output Format**: * Return `True` if the tree is balanced, otherwise `False`. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * Node values are not specifically constrained. **Evaluation Criteria**: 1. Correct handling of edge cases (e.g., empty tree, single node tree). 2. Efficient implementation with a time complexity of O(N). 3. Proper use of recursion or iteration to traverse the tree. **Example**: ```python # Consider the following binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(is_balanced_tree(root)) # Output: True # Another example with an unbalanced tree # 1 # / # 2 # / # 3 root2 = TreeNode(1) root2.left = TreeNode(2) root2.left.left = TreeNode(3) print(is_balanced_tree(root2)) # Output: False ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_tree(root) -> bool: Determines if a binary tree is balanced. A binary tree is balanced if for any node, the difference in height between left and right subtrees is at most 1. def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and (abs(left_height - right_height) <= 1) return current_height, current_balanced _, is_balanced = height_and_balance(root) return is_balanced"},{"question":"# Nearest Neighbor Classification **Objective**: Implement a variant of the nearest neighbor classification algorithm which supports handling of edge cases and performance improvements. **Scenario**: You work for a technology company specializing in autonomous drones. Your team is developing an algorithm to classify various objects based on their sensor data. The drone collects data points representing object features and uses a nearest neighbor approach to classify objects based on the closest match from a set of known objects. # Task Write a function `advanced_nearest_neighbor(x: tuple, tSet: dict) -> any` that takes: 1. **x**: A tuple representing the feature vector of the new object to classify. 2. **tSet**: A dictionary of training examples where keys are tuples representing feature vectors and values are the corresponding labels. The function should return the label of the training example that is nearest (based on Euclidean distance) to the input vector `x`. **Input/Output Specifications**: - **Input**: - A tuple `x` representing the feature vector. - A dictionary `tSet` where keys are tuples of the same length as `x` and values are labels. - **Output**: - The label (from the training set) of the closest feature vector to `x`. **Constraints**: - `x` and keys in `tSet` will always be of the same length. - If `tSet` is empty, return `None`. - Optimize for performance wherever possible with clear trade-offs explained. # Example ```python # Input x = (2, 3) tSet = { (1, 1): \'A\', (4, 4): \'B\', (3, 2): \'C\' } # Output result = advanced_nearest_neighbor(x, tSet) # Expected: \'C\' (since (3, 2) is closest to (2, 3)) ``` **Edge Cases & Considerations**: - Ensure that your function handles the case where `tSet` is empty. - Ensure appropriate error handling for invalid inputs. - Consider performance optimizations using advanced data structures or algorithms like KD-Trees if possible.","solution":"import math def advanced_nearest_neighbor(x, tSet): Returns the label of the nearest neighbor to x based on the Euclidean distance. Parameters: x (tuple): A tuple representing the feature vector of the new object to classify. tSet (dict): A dictionary of training examples where keys are tuples representing feature vectors and values are the corresponding labels. Returns: any: The label of the training example that is nearest to x. if not tSet: return None def euclidean_distance(point1, point2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) nearest_label = None min_distance = float(\'inf\') for point, label in tSet.items(): distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Question Title: Bijective Pattern-Word Mapping # Objective: Given two inputs, a pattern string and a space-separated string of words, write a function to determine if there exists a one-to-one correspondence (bijection) between the characters in the pattern and the words in the string. Your function should return `True` if such a correspondence exists and `False` otherwise. # Input and Output: - **Input**: Two parameters: - `pattern`: a string of lowercase letters. - `s`: a space-separated string of lowercase words. - **Output**: A boolean value (`True` or `False`). # Constraints: - Each word in `s` is separated by a single space. - Pattern string and words in `s` contain only lowercase letters. - No leading or trailing spaces in `s`. # Example: ```python Example 1: Input: pattern = \\"abba\\", s = \\"dog cat cat dog\\" Output: True Example 2: Input: pattern = \\"abba\\", s = \\"dog cat cat fish\\" Output: False Example 3: Input: pattern = \\"aaaa\\", s = \\"dog cat cat dog\\" Output: False Example 4: Input: pattern = \\"abba\\", s = \\"dog dog dog dog\\" Output: False ``` # Function Signature: ```python def word_pattern(pattern: str, s: str) -> bool: pass ``` # Requirements: 1. The function should have linear time complexity, i.e., O(n). 2. The function must account for edge cases, such as when the pattern and string have mismatched lengths of words. 3. Ensure that no single word maps to multiple pattern characters and vice versa.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch in char_to_word: if char_to_word[ch] != word: return False else: char_to_word[ch] = word if word in word_to_char: if word_to_char[word] != ch: return False else: word_to_char[word] = ch return True"},{"question":"Implement a class `ContactList` that uses the Trie data structure to add, search, and get suggestions for contacts based on prefixes. # Task 1. **insert**: Add a new contact name to the contact list. 2. **search**: Check if a full contact name exists in the contact list. 3. **get_suggestions**: Given a prefix, return all contact names that start with the prefix. # Function Signatures ```python class ContactList: def __init__(self): # Initializes the contact list. def insert(self, name: str) -> None: # Inserts a new contact name into the contact list. def search(self, name: str) -> bool: # Returns True if the contact name exists in the list, False otherwise. def get_suggestions(self, prefix: str) -> List[str]: # Returns a list of all contact names that start with the given prefix. ``` # Input * For the `insert` method: - `name` is a string consisting only of lowercase alphabets. * For the `search` method: - `name` is a string consisting only of lowercase alphabets. * For the `get_suggestions` method: - `prefix` is a string consisting only of lowercase alphabets. # Output * For the `insert` method: Nothing. * For the `search` method: - A boolean value indicating the presence or absence of the contact name. * For the `get_suggestions` method: - A list of strings that are contact names starting with the given prefix. # Constraints * All contact names and prefixes to be non-empty strings of lowercase letters. * Expected to handle up to 10000 contact names efficiently. # Example ```python cl = ContactList() cl.insert(\\"alice\\") cl.insert(\\"alex\\") cl.insert(\\"bob\\") print(cl.search(\\"alice\\")) # Output: True print(cl.search(\\"alex\\")) # Output: True print(cl.search(\\"al\\")) # Output: False print(cl.search(\\"bob\\")) # Output: True print(cl.get_suggestions(\\"al\\")) # Output: [\\"alice\\", \\"alex\\"] print(cl.get_suggestions(\\"bo\\")) # Output: [\\"bob\\"] print(cl.get_suggestions(\\"charlie\\")) # Output: [] ``` # Explanation 1. `insert` stores `alice`, `alex`, and `bob` in the trie. 2. `search` checks for exact matches and returns corresponding results. 3. `get_suggestions` returns all names starting with specified prefixes.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class ContactList: def __init__(self): self.root = TrieNode() def insert(self, name: str) -> None: node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, name: str) -> bool: node = self.root for char in name: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def get_suggestions(self, prefix: str) -> list: def dfs(current_node, path, suggestions): if current_node.is_end_of_word: suggestions.append(path) for char, next_node in current_node.children.items(): dfs(next_node, path + char, suggestions) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] suggestions = [] dfs(node, prefix, suggestions) return suggestions"},{"question":"# Zigzag Level Order Traversal You are given a binary tree and you need to return the zigzag level order traversal of its nodes\' values. In a zigzag traversal, the nodes at each level are processed in alternating order. For example, the first level is processed left to right, the second level right to left, the third level left to right, and so on. Input The input will be the root node of the binary tree. Output The output should be a list of lists where each list contains the values of the nodes at that level in the specified zigzag order. Example Given binary tree: ``` 1 / 2 3 / / 4 5 6 7 ``` The zigzag level order traversal should be: ``` [ [1], [3, 2], [4, 5, 6, 7] ] ``` Function Signature ```python def zigzag_level(root: TreeNode) -> List[List[int]]: # your code here ``` Constraints * The number of nodes in the tree will be in the range [0, 2000]. * The value of the nodes will be in the range [-10000, 10000]. * You may assume that the binary tree remains within the given constraints. Notes Approach the problem using a queue-based breadth-first search (BFS) strategy, ensuring you maintain a flag to alternate the order of traversal at each level.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def zigzag_level(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_values = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_values)) left_to_right = not left_to_right return result"},{"question":"# Question: Check Efficiently if a Linked List is Sorted Given a singly linked list, implement a Python function `is_sorted_descending` that checks if the linked list is sorted in descending order. The function should return `True` if the list is sorted in descending order and `False` otherwise. An empty list should be considered sorted in descending order. Function Signature ```python def is_sorted_descending(head: ListNode) -> bool: pass ``` Input Format - `head`: A reference to the first node of a singly linked list where each node has the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output Format - Returns `True` if the linked list is sorted in descending order, otherwise `False`. Constraints - The number of nodes in the linked list is in the range `[0, 10^5]`. - Each node\'s value is an integer in the range `[-10^9, 10^9]`. Examples 1. **Example 1:** ```python # List: 5 -> 4 -> 3 -> 2 -> 1 head = ListNode(5, ListNode(4, ListNode(3, ListNode(2, ListNode(1))))) is_sorted_descending(head) -> True ``` 2. **Example 2:** ```python # List: 5 -> 2 -> 3 -> 1 head = ListNode(5, ListNode(2, ListNode(3, ListNode(1)))) is_sorted_descending(head) -> False ``` 3. **Example 3:** ```python # List: None (empty) head = None is_sorted_descending(head) -> True ``` Additional Notes - The function should be efficient and handle large lists close to the upper constraint limits. - Pay attention to edge cases such as empty lists and lists with only one node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted_descending(head: ListNode) -> bool: Checks if the singly linked list is sorted in descending order. if head is None: return True current = head while current.next is not None: if current.val < current.next.val: return False current = current.next return True"},{"question":"You are given two strings, `str1` and `str2`. Your task is to determine the minimum number of deletions required to make `str1` and `str2` the same. Each deletion operation consists of removing a character from either string. Write a function `min_deletions_to_make_equal(str1: str, str2: str) -> int` that computes and returns this minimum number of deletions. # Input * `str1`: The first string (1 <= len(str1) <= 1000) * `str2`: The second string (1 <= len(str2) <= 1000) # Output * An integer representing the minimum number of deletions required. # Example Example 1 * Input: `str1 = \\"sea\\", str2 = \\"eat\\"` * Output: `2` * Explanation: * One step is needed to change \\"sea\\" to \\"ea\\" (remove \'s\'). * Another step to change \\"eat\\" to \\"ea\\" (remove \'t\'). Example 2 * Input: `str1 = \\"leetcode\\", str2 = \\"etco\\"` * Output: `4` * Explanation: * One possible way is to remove \\"l\\", \\"e\\", \\"o\\", \\"d\\" from `str1`, or \\"e\\", \\"t\\", \\"c\\", \\"o\\" from `str2`. # Constraints * All inputs are guaranteed to be lowercase English letters. * Perform the solution with a time complexity of O(m * n) and a space complexity of O(m * n), where `m` and `n` are the lengths of `str1` and `str2`. # Hints * Compute the length of the longest common subsequence (LCS) for `str1` and `str2`. * The number of deletions required to make `str1` and `str2` equal is given by the formula `len(str1) + len(str2) - 2 * LCS(str1, str2)`.","solution":"def min_deletions_to_make_equal(str1, str2): Returns the minimum number of deletions required to make str1 and str2 equal. # Compute the length of the longest common subsequence (LCS) m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # The minimum number of deletions min_deletions = (m - lcs_length) + (n - lcs_length) return min_deletions"},{"question":"Context You are tasked with building a system that validates transformation rules between strings. Two strings are said to be isomorphic if you can replace the characters of one string to obtain the other string, maintaining the relative order of characters and ensuring no two characters map to the same character. Your task is to implement a function to check if two strings are isomorphic. Problem Statement Given two strings `s` and `t`, write a function `are_isomorphic(s: str, t: str) -> bool` that determines if the strings are isomorphic. Function Signature ```python def are_isomorphic(s: str, t: str) -> bool: pass ``` Input - A string `s` with length `n` (1 ≤ `n` ≤ 10^4). - A string `t` with length `n`. Output - Return `True` if `s` and `t` are isomorphic, otherwise return `False`. Examples ``` Example 1: Input: s = \\"egg\\", t = \\"add\\" Output: True Example 2: Input: s = \\"foo\\", t = \\"bar\\" Output: False Example 3: Input: s = \\"paper\\", t = \\"title\\" Output: True ``` Constraints - Both `s` and `t` consist of lowercase English letters only. - Assume there are no invalid or edge integer inputs apart from different string lengths.","solution":"def are_isomorphic(s: str, t: str) -> bool: Determines if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"# Coding Challenge: Custom Radix Sort Implementation Scenario You are a software engineer tasked with optimizing the sorting process for a large dataset of integers representing customer IDs. The IDs can be assumed to be non-negative integers. Given that the input list can be extremely large, you must ensure that the sorting algorithm used is efficient in both time and space. Task Write a function `custom_radix_sort` that implements the Radix Sort algorithm for sorting a list of non-negative integers. Additionally, handle edge cases such as an empty list, or a list where all numbers are the same. Your implementation must also be able to handle lists with very high numbers efficiently. Function Signature ```python def custom_radix_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of non-negative integers. Output - A list of integers sorted in increasing order. Constraints 1. All numbers in `arr` are non-negative integers. 2. The length of `arr` can be up to 10^6. 3. The maximum value of an integer in `arr` can be up to 10^9. Example ```python input_list = [170, 45, 75, 90, 802, 24, 2, 66] sorted_list = custom_radix_sort(input_list) print(sorted_list) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` Guidelines * You may not use Python\'s built-in `sort` or `sorted` functions. * Ensure that your implementation is efficient in time complexity and handles large inputs within acceptable limits. * Document any assumptions you make, and handle any edge cases you identify.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> None: A function to do counting sort based on the digit represented by exp n = len(arr) output = [0] * n # output array count = [0] * 10 # count array for digits (0 to 9) # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] def custom_radix_sort(arr: List[int]) -> List[int]: Function to implement the Radix Sort algorithm if not arr: return [] # Find the maximum number to know the number of digits max_num = max(arr) # Do counting sort for every digit. Note that instead # of passing digit number, exp is passed. exp is 10^i # where i is current digit number exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"You are given a singly linked list and you need to detect if there is a cycle in it. If a cycle exists, your task is to find the node where the cycle begins. Use Floyd\'s cycle-finding algorithm to accomplish this task. # Implementation Details Define a function `first_cyclic_node(head)` that takes a single argument `head`, which is the starting node of the linked list. The function should return the node where the cycle begins or `None` if there is no cycle. # Input * The `head` of the singly linked list (`head` is of type `Node`). # Output * The node where the cycle begins (of type `Node`), or `None` if no cycle exists. # Constraints * Nodes in the linked list contain integer values and a pointer to the next node (or `None`). * List can have at most 10^4 nodes. * List values will not necessarily be unique. # Example Consider the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 2` (Here, 5 points back to 2, forming a cycle starting from node with value 2). ```python class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): :type head: Node :rtype: Node runner = walker = head while runner and runner.next: runner = runner.next.next walker = walker.next if runner is walker: break if runner is None or runner.next is None: return None walker = head while runner is not walker: runner, walker = runner.next, walker.next return runner ``` # Edge Cases: 1. An empty list (head is `None`). 2. A single node pointing to itself. 3. No cycle in the list. 4. A cycle starting at the head node.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): Detects if there is a cycle in the linked list and returns the node where the cycle begins. If there is no cycle, returns None. :param head: Head of the singly linked list. :type head: Node :return: The node where the cycle begins or None if there is no cycle. :rtype: Node if not head or not head.next: return None runner = walker = head while runner and runner.next: runner = runner.next.next walker = walker.next if runner == walker: break if not runner or not runner.next: return None walker = head while walker != runner: walker = walker.next runner = runner.next return runner"},{"question":"In this problem, you will need to implement functions to convert integers to byte arrays and vice versa, taking endianess into account. The conversions should handle both positive and negative integers and should properly handle edge cases such as empty inputs or zero values. # Functions to Implement 1. **int_to_bytes(num, endianness)**: Given an integer `num` and a string `endianness` which can be \'big\' or \'little\', convert the integer to a byte array accordingly. - **Input**: - `num`: an integer, can be positive or negative. - `endianness`: a string, either \'big\' or \'little\'. - **Output**: A byte array representing the integer in the designated endianness. 2. **bytes_to_int(bytestr, endianness)**: Given a byte array `bytestr` and a string `endianness` which can be \'big\' or \'little\', convert the byte array to an integer accordingly. - **Input**: - `bytestr`: A byte array. - `endianness`: A string, either \'big\' or \'little\'. - **Output**: An integer represented by the byte array in the designated endianness. # Constraints - The integer `num` will be in the range of [-2^63, 2^63 - 1]. - The byte array `bytestr` will be no longer than 8 bytes. - The `endianness` will always be either \'big\' or \'little\'. # Example ```python # Example 1: num = 305419896 endianness = \'big\' print(int_to_bytes(num, endianness)) # Output: b\'x12x34x56x78\' bytestr = b\'x12x34x56x78\' endianness = \'big\' print(bytes_to_int(bytestr, endianness)) # Output: 305419896 # Example 2: num = 305419896 endianness = \'little\' print(int_to_bytes(num, endianness)) # Output: b\'x78x56x34x12\' bytestr = b\'x78x56x34x12\' endianness = \'little\' print(bytes_to_int(bytestr, endianness)) # Output: 305419896 ``` # Notes - The task tests your understanding of byte manipulations and endianess. - Make sure to handle edge cases such as the conversion of zero. - Ensure to use efficient operations to avoid unnecessary overhead.","solution":"def int_to_bytes(num, endianness): Converts an integer to a byte array given the endianness. Args: num (int): The integer to convert. endianness (str): The endianness, either \'big\' or \'little\'. Returns: bytes: The resulting byte array. length = (num.bit_length() + 7) // 8 or 1 # Compute the minimal byte length required to represent the integer return num.to_bytes(length, endianness, signed=True) def bytes_to_int(bytestr, endianness): Converts a byte array to an integer given the endianness. Args: bytestr (bytes): The byte array. endianness (str): The endianness, either \'big\' or \'little\'. Returns: int: The resulting integer. return int.from_bytes(bytestr, endianness, signed=True)"},{"question":"# Question: Efficient Task Scheduler You have been appointed as a software engineer to develop an efficient task scheduling system for a computing server that runs tasks based on their priorities. Tasks with higher priorities should run before those with lower priorities, and among tasks with the same priority, they should execute in the order they were added. Your task is to implement the scheduler using a priority queue. Below are the specific requirements and constraints: 1. Implement a class `EfficientTaskScheduler` with the following methods: - **`__init__(self)`**: Initialize the scheduler. - **`add_task(self, task, priority)`**: Add a new task with the given priority. - **`pop_task(self)`**: Remove and return the task with the highest priority. - **`is_empty(self)`**: Return `True` if there are no tasks, else `False`. - **`size(self)`**: Return the number of tasks currently in the scheduler. 2. Implement methods that efficiently manage and handle the priority queue in the scheduler to ensure optimized task handling with the highest priority tasks popped first. # Constraints: - Tasks can have integer priorities where higher values indicate higher priorities. - The `pop_task` function should remove and return the highest priority task. - There can be multiple tasks with the same priority. In such cases, tasks should be executed in the order they were added (FIFO order for same priority). - You should aim to achieve better average-case performance for insertion compared to the provided linear array-based priority queue. # Example: ```python scheduler = EfficientTaskScheduler() scheduler.add_task(\\"Task1\\", 5) scheduler.add_task(\\"Task2\\", 2) scheduler.add_task(\\"Task3\\", 5) print(scheduler.pop_task()) # Should print \\"Task1\\" (highest priority, first added) print(scheduler.size()) # Should print 2 (remaining tasks) ``` # Note: - This task aims to test your understanding of data structures, specifically priority queues, and how they can be utilized for effective scheduling. - Think about potential improvements over the naive linear array implementation given in the code snippets.","solution":"import heapq class EfficientTaskScheduler: def __init__(self): self._task_counter = 0 self._tasks = [] def add_task(self, task, priority): Add a new task with the given priority. Args: task (str): The task to be added. priority (int): The priority of the task. heapq.heappush(self._tasks, (-priority, self._task_counter, task)) self._task_counter += 1 def pop_task(self): Remove and return the task with the highest priority. Returns: str: The task with the highest priority. if self.is_empty(): return None return heapq.heappop(self._tasks)[2] def is_empty(self): Return True if there are no tasks, else False. Returns: bool: True if there are no tasks, else False. return len(self._tasks) == 0 def size(self): Return the number of tasks currently in the scheduler. Returns: int: The current number of tasks. return len(self._tasks)"},{"question":"# Scenario You are working with machine learning models that involve high-dimensional data. These data vectors are often large but sparse, meaning that they contain a lot of zeros. To efficiently store and compute operations on such vectors, you need to implement a data structure that captures only the non-zero values along with their indices. # Task 1. **Implement a function named `sparse_vector` that converts a given vector (list of floats) into a list of index-value tuples containing only the non-zero elements.** 2. **Implement a function named `sparse_dot_product` that computes the dot product of two sparse vectors represented as lists of index-value tuples.** # Function Signatures ```python def sparse_vector(vector: List[float]) -> List[Tuple[int, float]]: pass def sparse_dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` # Input 1. `sparse_vector(vector)`: * `vector`: A list of floats representing the vector. 2. `sparse_dot_product(iv_list1, iv_list2)`: * `iv_list1`, `iv_list2`: Lists of tuples, where each tuple contains (index, value). # Output 1. `sparse_vector(vector)`: * Returns a list of tuples with non-zero elements, where each tuple is (index, value). 2. `sparse_dot_product(iv_list1, iv_list2)`: * Returns a float value representing the dot product of the two sparse vectors. # Constraints 1. The length of the vector: 0 <= len(vector) <= 10^6 2. Values in the vector: 0.0 <= vector[i] <= 10^9 3. The vectors provided to the `sparse_dot_product` function will be of the same length with realistic sparse vector scenarios. # Example ```python # Conversion to sparse vector vector1 = [0.0, 2.0, 0.0, 3.0, 0.0] vector2 = [0.0, 1.0, 0.0, 2.0, 4.0] # Convert vectors to sparse format iv_list1 = sparse_vector(vector1) iv_list2 = sparse_vector(vector2) print(iv_list1) # [(1, 2.0), (3, 3.0)] print(iv_list2) # [(1, 1.0), (3, 2.0), (4, 4.0)] # Compute dot product of sparse vectors product = sparse_dot_product(iv_list1, iv_list2) print(product) # 2.0 * 1.0 + 3.0 * 2.0 = 2.0 + 6.0 = 8.0 ``` # Note Ensure your implementation handles edge cases, such as vectors containing all zeros, efficiently and correctly.","solution":"from typing import List, Tuple def sparse_vector(vector: List[float]) -> List[Tuple[int, float]]: Converts a given vector into a list of index-value tuples containing only the non-zero elements. :param vector: A list of floats representing the vector. :return: A list of tuples with non-zero elements, where each tuple is (index, value). return [(i, value) if value != 0 else None for i, value in enumerate(vector) if value != 0] def sparse_dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Computes the dot product of two sparse vectors represented as lists of index-value tuples. :param iv_list1: A list of tuples (index, value) representing the first sparse vector. :param iv_list2: A list of tuples (index, value) representing the second sparse vector. :return: A float value representing the dot product of the two sparse vectors. dict1 = dict(iv_list1) dict2 = dict(iv_list2) dot_product = 0.0 for index, value in dict1.items(): if index in dict2: dot_product += value * dict2[index] return dot_product"},{"question":"Given a string `s` and a dictionary of words `wordDict`, write a function `wordBreakCount` that returns the number of different ways the string can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature ```python def wordBreakCount(s: str, wordDict: List[str]) -> int: ``` # Input - `s`: A string consisting of lowercase English letters (1 <= len(s) <= 1000). - `wordDict`: A list of words where each word consists of lowercase English letters (1 <= len(wordDict) <= 1000, 1 <= len(word) <= 20). # Output - Returns an integer representing the number of different ways to segment the string. # Example ```python assert wordBreakCount(\\"appletablet\\", [\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"table\\", \\"t\\"]) == 4 assert wordBreakCount(\\"thing\\", [\\"thing\\"]) == 1 assert wordBreakCount(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) == 2 assert wordBreakCount(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 ``` # Constraints - You can assume all words in the dictionary are unique. - The input consists of lowercase English letters only. # Additional Information Implement this function with memoization to avoid redundant calculations, thereby optimizing its performance.","solution":"from typing import List def wordBreakCount(s: str, wordDict: List[str]) -> int: word_set = set(wordDict) memo = {} def dfs(subs: str) -> int: if subs in memo: return memo[subs] if not subs: return 1 total_ways = 0 for end in range(1, len(subs) + 1): word = subs[:end] if word in word_set: total_ways += dfs(subs[end:]) memo[subs] = total_ways return total_ways return dfs(s)"},{"question":"You are asked to write a function that takes two compatible two-dimensional matrices and returns their product. # Function Signature ```python def matrix_product(multiplicand: list, multiplier: list) -> list: ``` # Input * **multiplicand**: a list of lists where each sub-list represents a row of a 2-dimensional matrix; the matrix has m rows and n columns. * **multiplier**: a list of lists where each sub-list represents a row of a 2-dimensional matrix; the matrix has n rows and p columns. # Output * A list of lists representing the product matrix; the resultant matrix has m rows and p columns. # Constraints * Matrices will always contain integers. * The number of columns in the multiplicand must equal the number of rows in the multiplier. Otherwise, raise an exception with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" # Example ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Output: [[58, 64], [139, 154]] # Example 2 multiplicand = [ [1, 0, 2], [-1, 3, 1] ] multiplier = [ [3, 1], [2, 1], [1, 0] ] # Output: [[5, 1], [4, 2]] ``` Write your solution to implement the matrix multiplication function. Be sure to handle edge cases and raise an exception for incompatible matrices.","solution":"def matrix_product(multiplicand: list, multiplier: list) -> list: Multiplies two compatible 2D matrices and returns the result. :param multiplicand: Matrix A with dimensions m x n :param multiplier: Matrix B with dimensions n x p :return: Matrix C which is the product of A and B with dimensions m x p m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) if len(multiplier) != n: raise ValueError(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize result matrix with zeros. result = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Binary Tree Comparison Given the definition of a binary tree node and two binary trees, write a function to determine if they are identical. Two binary trees are identical if they are structurally the same and the nodes have the same value. Function Signature ```python def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]) -> bool: pass ``` Input - `tree_p`: The root node of the first binary tree (`TreeNode` or `None` if the tree is empty). - `tree_q`: The root node of the second binary tree (`TreeNode` or `None` if the tree is empty). Output - Return `True` if both binary trees are identical, otherwise `False`. Constraints - Each node\'s value is an integer. - The number of nodes in each tree is in the range [0, 10^4]. Performance Requirements - The time complexity should not exceed O(min(N, M)). - Consider the space complexity for deep trees. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree(tree_p, tree_q) == True tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(4)) assert is_same_tree(tree_p, tree_q) == False tree_p = TreeNode(1, TreeNode(2)) tree_q = TreeNode(1, None, TreeNode(2)) assert is_same_tree(tree_p, tree_q) == False ``` Notes - Handle the edge case where both trees are empty. - Ensure the function returns quickly if initial nodes mismatch.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]) -> bool: if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"You are tasked with implementing a modified version of the `OrderedStack` that maintains the elements in descending order, using an auxiliary data structure of your choice for optimization. Specifically, you will enhance the `push` operation to reduce the time complexity for large datasets. **Your task:** Implement a class `OptimizedOrderedStack` to provide the following methods: 1. `__init__(self)`: Initializes an empty stack. 2. `push(self, item)`: Pushes an item onto the stack, maintaining overall order. Optimize this method for large datasets. 3. `pop(self)`: Removes the item from the top of the stack and returns it. 4. `peek(self)`: Returns the item at the top of the stack without removing it. 5. `is_empty(self)`: Returns `True` if the stack is empty, otherwise `False`. **Constraints**: * All items are integers. * Do not use Python\'s built-in sorted structures (like `heapq`, `sorted`, or any variant). **Example**: ```python stack = OptimizedOrderedStack() stack.push(10) stack.push(5) stack.push(20) print(stack.pop()) # Output: 20 print(stack.pop()) # Output: 10 stack.push(15) print(stack.peek()) # Output: 15 print(stack.is_empty()) # Output: False print(stack.size()) # Output: 2 ```","solution":"class OptimizedOrderedStack: def __init__(self): self.stack = [] def push(self, item): # find the correct position to insert the item low, high = 0, len(self.stack) while low < high: mid = (low + high) // 2 if self.stack[mid] < item: high = mid else: low = mid + 1 self.stack.insert(low, item) def pop(self): if self.is_empty(): return None return self.stack.pop(0) def peek(self): if self.is_empty(): return None return self.stack[0] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack)"},{"question":"# Merging Two Sorted Linked Lists Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in forward order and each of their nodes contains a single digit. Merge the two linked lists into one sorted linked list. The result should maintain the order of the linked lists. Implement a function `merge_sorted_linked_lists` that accepts the heads of two linked lists and returns the head of the merged linked list. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_sorted_linked_lists(l1: Node, l2: Node) -> Node: # implement your solution here ``` Input * Two linked lists `l1` and `l2` where: * Each linked list node contains a non-negative integer value. * Inputs are sorted in non-decreasing order. * At least one of the linked lists is non-empty. Output * A single linked list which is the sorted merge of the input linked lists. Constraints * The number of nodes in both linked lists combined will not exceed `10^4`. * The linked lists themselves will not be circular or contain null values for nodes other than the end node. Example ```python # Example 1: # Input: l1 = [1 -> 2 -> 4], l2 = [1 -> 3 -> 4] # Output: [1 -> 1 -> 2 -> 3 -> 4 -> 4] # Example 2: # Input: l1 = [], l2 = [0] # Output: [0] # Example 3: # Input: l1 = [2], l2 = [1] # Output: [1 -> 2] ``` Notes * Your solution should handle edge cases such as one or both linked lists being empty efficiently. * Consider implementing both iterative and recursive solutions, though any of them would suffice to solve the problem.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_sorted_linked_lists(l1: Node, l2: Node) -> Node: # Create a dummy node to act as the head of the merged list dummy = Node(0) current = dummy # Iterate while both linked lists have nodes left while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If either list runs out of elements, append the remaining elements of the other list if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"# Rotated String Verification **Background**: Imagine you are developing a feature for a text editor. One requirement is to check if one string is a rotated version of another, which has applications in text manipulation and pattern recognition. **Problem Statement**: Write a function `is_rotated(s1: str, s2: str) -> bool` that accepts two strings `s1` and `s2` and determines if `s2` is a rotated version of `s1`. For example: - `is_rotated(\\"hello\\", \\"llohe\\")` should return `True` - `is_rotated(\\"hello\\", \\"helol\\")` should return `False` A string is considered a rotated version of another if you can take a substring from the end of the first string and move it to the beginning without changing the relative order of characters. **Function Signature**: ```python def is_rotated(s1: str, s2: str) -> bool: pass ``` **Input**: - `s1`: A string of length `N` where `0 <= N <= 10^3`. - `s2`: A string of length `M` where `0 <= M <= 10^3`. **Output**: - Returns `True` if `s2` is a rotated version of `s1`, `False` otherwise. **Constraints**: - Both strings consist only of printable ASCII characters. # Example ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"abcdefg\\", \\"efgabcd\\") == True assert is_rotated(\\"abcdefg\\", \\"gfedcba\\") == False assert is_rotated(\\"abcdefg\\", \\"abcdefg\\") == True assert is_rotated(\\"\\", \\"\\") == True assert is_rotated(\\"abc\\", \\"\\") == False assert is_rotated(\\"\\", \\"abc\\") == False ``` # Performance Requirements The function should run efficiently with a time complexity of O(N) or better, where `N` is the length of the input strings. **Your Task**: - Implement the `is_rotated` function. - Ensure it handles all edge cases correctly and efficiently. - Add comments to explain the logic and any optimizations you include.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determine if s2 is a rotated version of s1. :param s1: First string :param s2: Second string :return: True if s2 is a rotated version of s1, False otherwise # Both strings must have the same length to be rotations of each other if len(s1) != len(s2): return False # Concatenate s1 with itself s1s1 = s1 + s1 # Check if s2 is a substring of this concatenated string return s2 in s1s1"},{"question":"# Pigeonhole Sort: Function Implementation Challenge Context: You work at a software company that is building tools for data analysis. A common task is to sort datasets efficiently. One of your colleagues suggests using Pigeonhole Sort due to its linear time complexity in certain scenarios. You need to implement this algorithm to sort an array of integers. # Task: Write a function `pigeonhole_sort(arr)` that sorts an array of integers using the pigeonhole sorting algorithm. # Input: - A list of integers, `arr`, where: * 0 ≤ len(arr) ≤ 10^6 * -10^6 ≤ arr[i] ≤ 10^6 for 0 ≤ i < len(arr) # Output: - A sorted list of integers in non-decreasing order. # Constraints: 1. Aim to achieve the best time complexity possible given the nature of the algorithm. 2. Minimize space usage where possible. # Example: ```python input: [8, 3, 2, 7, 4] output: [2, 3, 4, 7, 8] input: [10, -5, 2, 2, 10, -5] output: [-5, -5, 2, 2, 10, 10] ``` # Performance Requirement: - The solution should handle the edge cases efficiently, such as when all elements are the same, and should be able to manage large ranges within the input constraints. # Edge Cases to Consider: 1. All elements are the same. 2. Elements range from a large negative number to a large positive number. 3. The array is empty. 4. The array contains only one element. Implement the function `pigeonhole_sort(arr)` and ensure it passes all edge cases and the provided examples.","solution":"def pigeonhole_sort(arr): Sort the given array using the pigeonhole sort algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Initialize the holes holes = [0] * size # Populate the holes for x in arr: holes[x - min_val] += 1 # Populate the sorted array sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"You are tasked with implementing a function that validates whether a string of parentheses/brackets is well-formed. This means that brackets must close in the correct order and every opening bracket must have a corresponding closing bracket. Function Signature ```python def validate_brackets(s: str) -> bool: ``` # Input * A string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', with a length between 0 and 10^4. # Output * Returns `True` if the input string is valid. Otherwise, returns `False`. # Constraints * The string will contain only these characters: \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. # Examples * `validate_brackets(\\"()\\")` should return `True` * `validate_brackets(\\"()[]{}\\")` should return `True` * `validate_brackets(\\"(]\\")` should return `False` * `validate_brackets(\\"([)]\\")` should return `False` * `validate_brackets(\\"{[]}\\")` should return `True` # Explanation The function should use a stack to check if each closing bracket correctly matches the last unmatched opening bracket. Be cautious of edge cases such as strings with no brackets or improperly nested brackets. # Edge Cases to Consider * An empty string should return `True`. * Strings with unmatched or out-of-order brackets should return `False`. * Ensure `validate_brackets(\\"{[}]\\")` returns `False`. # Performance Requirements * The solution should operate with O(n) time complexity where n is the length of the string. * The space complexity should be efficient, maintaining O(n) in the worst case due to stack usage. # Note The problem assumes that the input consists solely of the mentioned characters, making it strictly about bracket matching without any additional characters or context.","solution":"def validate_brackets(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Coding Challenge: Find Shortest Path in a Maze Given a 2D grid representing a maze, where `1` indicates a cell that can be traversed and `0` indicates a blocked cell, write a function `find_shortest_path` to find the shortest path from the top-left corner to the bottom-right corner. # Function Signature ```python def find_shortest_path(maze: List[List[int]]) -> int: pass ``` # Input Parameters - `maze`: A 2D list of integers where each element is either `0` or `1`. The maze is guaranteed to be non-empty and rectangular. # Constraints - You can only move up, down, left, or right. - You cannot move through cells with the value `0`. - If there is no path from the top-left corner to the bottom-right corner, return `-1`. # Output - Return an integer representing the length of the shortest path from the top-left corner to the bottom-right corner. Do not count the starting cell (top-left corner) in the path length. Return `-1` if no such path exists. # Performance Requirements - Aim to optimize the solution to handle larger mazes efficiently, though a naive DFS solution is acceptable at minimum. # Example ```python # Example 1 maze = [ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1] ] print(find_shortest_path(maze)) # Output: 14 # Example 2 maze = [ [1, 0, 0], [0, 1, 1], [0, 1, 1] ] print(find_shortest_path(maze)) # Output: -1 ``` # Notes - Consider edge cases where the maze might be full of `0`s or blocked right from the start or near the end. - Ensure to handle large mazes efficiently to avoid stack overflow or excessive computation time.","solution":"from collections import deque from typing import List def find_shortest_path(maze: List[List[int]]) -> int: if not maze or not maze[0] or maze[0][0] == 0 or maze[-1][-1] == 0: return -1 rows, cols = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1"},{"question":"Multi-ZigZag Iterator You are required to write a more generalized version of the ZigZag Iterator that can traverse through multiple sequences in a zigzag fashion. Task: Implement a class `MultiZigZagIterator` that takes a list of lists and interleaves them. Your implementation should include the following methods: 1. **`__init__(self, lists: List[List[int]])`**: Constructor to initialize the internal data structure. 2. **`next(self) -> int`**: Returns the next element in zigzag order. 3. **`has_next(self) -> bool`**: Returns `True` if there are remaining elements; otherwise, `False`. Input: * A list of lists `lists` is provided as input at initialization. Output: * `next()` method should return the next integer in the sequence. * `has_next()` should return `True` if there are elements remaining, `False` otherwise. Constraints: * All integers in the lists are within the range `[-1000, 1000]`. * There can be up to `10^4` lists, with each containing up to `10^4` elements. # Example: ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = MultiZigZagIterator(lists) output = [] while it.has_next(): output.append(it.next()) print(output) # Expected: [1, 3, 7, 2, 4, 8, 5, 9, 6] ```","solution":"from collections import deque class MultiZigZagIterator: def __init__(self, lists): self.queue = deque() for i, lst in enumerate(lists): if lst: self.queue.append((i, 0, lst)) def next(self): if not self.has_next(): return None index, elem_index, lst = self.queue.popleft() val = lst[elem_index] if elem_index + 1 < len(lst): self.queue.append((index, elem_index + 1, lst)) return val def has_next(self): return bool(self.queue)"},{"question":"**Decoding Alphanumeric Messages** A message containing letters from A-Z is being encoded into numbers using the mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, determine the total number of ways to decode it. Your task is to write a function `num_decodings` that takes an encoded message as input and returns the total number of ways it can be decoded. # Input - A single string `enc_mes` consisting of digits (\'0\'-\'9\') representing the encoded message. The string length is between `[1, 100]`. # Output - An integer representing the total number of ways to decode the encoded message. # Constraints 1. The encoded message will not contain invalid encodings directly nor empty strings. 2. It will avoid patterns that lead to invalid decodings like strings starting with \'0\' or improper zero-based pairs. # Examples **Example 1:** ```python enc_mes = \\"12\\" print(num_decodings(enc_mes)) # Output: 2 ``` Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). **Example 2:** ```python enc_mes = \\"123\\" print(num_decodings(enc_mes)) # Output: 3 ``` Explanation: \\"123\\" can be decoded as \\"ABC\\" (1 2 3), \\"AW\\" (1 23), or \\"LC\\" (12 3). **Example 3:** ```python enc_mes = \\"226\\" print(num_decodings(enc_mes)) # Output: 3 ``` Explanation: \\"226\\" can be decoded as \\"BBF\\" (2 2 6), \\"VF\\" (22 6), or \\"BZ\\" (2 26). # Assumptions - Ensure your implementation handles edge cases like strings containing zeros appropriately by discarding invalid leading zeros combinations unless part of a valid one like \'10\' or \'20\'. # Note You are provided with the underlying workings of two functions: `num_decodings` using an iterative approach and `num_decodings2` which uses a stack. Optimize the given code to meet the required constraints and pass the provided examples.","solution":"def num_decodings(s): Given a string s, returns the number of ways to decode it according to the given mapping from digits to letters. if not s or s[0] == \'0\': # base cases return 0 n = len(s) dp = [0] * (n + 1) # dp array to store the number of ways to decode dp[0], dp[1] = 1, 1 # initial values for i in range(2, n + 1): single_digit = int(s[i - 1]) double_digit = int(s[i - 2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given an array of integers and a percentage. Your task is to write a function that computes the trimmed mean of the array after excluding a specified percentage of the largest and smallest values. Function Signature ```python def trimmed_mean(array: List[int], percentage: float) -> float: ``` Input * `array: List[int]` - A list of integers, with length n (1 ≤ n ≤ 10^6). * `percentage: float` - A float between 0 and 100 indicating the percentage of elements to trim. The input will guarantee that the fleet is within the valid range. Output * `float` - The trimmed mean of the remaining elements after excluding the specified percentage of the smallest and largest values. Constraints * The percentage must be evenly distributable, meaning that `percentage / 2 * n` must be an integer. For guaranteed validity, assume the array length is such that `percentage` will always properly segment the array. Performance Requirements * Ensure your implementation can handle arrays of up to 10^6 elements efficiently. Example ```python # Example 1 array = [1, 2, 3, 4, 5] percentage = 40 # Explanation: Trim 20% from both ends => [2, 3, 4] # Trimmed mean = (2 + 3 + 4) / 3 = 3.0 print(trimmed_mean(array, percentage)) # Output: 3.0 # Example 2 array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] percentage = 20 # Explanation: Trim 10% from both ends => [20, 30, 40, 50, 60, 70, 80, 90] # Trimmed mean = (20 + 30 + 40 + 50 + 60 + 70 + 80 + 90) / 8 = 55.0 print(trimmed_mean(array, percentage)) # Output: 55.0 ```","solution":"from typing import List def trimmed_mean(array: List[int], percentage: float) -> float: Calculate the trimmed mean of an array, excluding the given percentage of smallest and largest values from the array. :param array: List[int] - The array of integers :param percentage: float - The percentage of values to trim from both ends :return: float - The trimmed mean of the remaining values n = len(array) trim_count = int(n * percentage / 100 / 2) # Sort the array sorted_array = sorted(array) trimmed_array = sorted_array[trim_count:n-trim_count] # Exclude smallest and largest elements trimmed_sum = sum(trimmed_array) trimmed_length = len(trimmed_array) return trimmed_sum / trimmed_length if trimmed_length > 0 else 0.0"},{"question":"# Filtering Array Elements **Objective**: Implement a function that filters an array of integers, retaining only those that fall within a specified range. This should be done without directly using any built-in filtering functions. **Background**: In data analysis and processing, it is common to filter datasets to remove outliers or focus on a specific range of values. For instance, determining which values fall within acceptable operational limits of a machine can be critical for safety and efficiency. # Requirements You are required to implement the function `filter_range(arr, min_val, max_val)` where: - `arr`: list of integers representing the original dataset. - `min_val`: an integer representing the lower bound of the desired range (inclusive). If set to `None`, no lower bound is applied. - `max_val`: an integer representing the upper bound of the desired range (inclusive). If set to `None`, no upper bound is applied. **Expectations**: - The function should return a new list composed only of elements from `arr` that lie between `min_val` and `max_val`, inclusive. - If both `min_val` and `max_val` are set to `None`, return a copy of the original array. - Handle edge cases gracefully such as empty arrays and arrays with values outside the given range. # Constraints - All elements in `arr` are integers. - `min_val` and `max_val` are either integers or `None`. # Example Input and Output Here are some examples to illustrate the expected behavior: ```python # Example 1 arr = [1, 5, 6, 8, 12, 15] min_val = 5 max_val = 10 # Expected output: [5, 6, 8] # Example 2 arr = [1, 5, 6, 8, 12, 15] min_val = None max_val = 10 # Expected output: [1, 5, 6, 8] # Example 3 arr = [1, 5, 6, 8, 12, 15] min_val = 6 max_val = None # Expected output: [6, 8, 12, 15] # Example 4 arr = [] min_val = 2 max_val = 5 # Expected output: [] ``` # Function Signature ```python def filter_range(arr, min_val, max_val): # Your code here ``` # Performance Note Aim for a solution with linear time complexity, O(n).","solution":"def filter_range(arr, min_val, max_val): Filters an array of integers, retaining only those that fall within the specified range. :param arr: List of integers representing the original dataset. :param min_val: An integer representing the lower bound of the desired range (inclusive) or None. :param max_val: An integer representing the upper bound of the desired range (inclusive) or None. :return: A new list composed only of elements that lie between min_val and max_val. filtered_list = [] for num in arr: if (min_val is None or num >= min_val) and (max_val is None or num <= max_val): filtered_list.append(num) return filtered_list"},{"question":"Problem Statement: You are given a partially complete function `pythagoras(opposite, adjacent, hypotenuse)` that calculates the length of an unknown side of a right-angled triangle based on the Pythagorean theorem. Your task is to enhance this function to handle edge cases, validate input, and ensure robust error handling. Requirements: 1. If the side lengths provided can form a right-angled triangle, calculate the length of the unknown side. 2. If inputs are invalid (e.g., non-numeric, negative values, or sides that don\'t logically form a right-angled triangle), raise a ValueError with an appropriate message. 3. Ensure the function only returns positive lengths for sides. Your function should take the following three parameters: - `opposite`: Length of the opposite side or \\"?\\" if it needs to be calculated. - `adjacent`: Length of the adjacent side or \\"?\\" if it needs to be calculated. - `hypotenuse`: Length of the hypotenuse or \\"?\\" if it needs to be calculated. Each parameter can either be a positive number or the string \\"?\\". Only one parameter will be \\"?\\" at a time. # Input and Output Format: - **Input**: - The function `pythagoras` will be called with three arguments which are either positive numbers or \\"?\\". - **Output**: - Return the calculated length as a string \\"Side = x\\" where \\"Side\\" is either \\"Opposite\\", \\"Adjacent\\", or \\"Hypotenuse\\" and \\"x\\" is the calculated length rounded to two decimal places. - Raise a `ValueError` for invalid inputs or configurations. # Constraints: - The inputs are either positive numbers or a \\"?\\". - Only one of the three inputs will be \\"?\\" at a time. - The input values when substituted should logically form a right-angled triangle. # Example: ```python # Example 1: pythagoras(\\"3\\", \\"4\\", \\"?\\") # Output: \\"Hypotenuse = 5.00\\" # Example 2: pythagoras(\\"5\\", \\"12\\", \\"?\\") # Output: \\"Hypotenuse = 13.00\\" # Example 3: pythagoras(\\"8\\", \\"?\\", \\"10\\") # Output: \\"Adjacent = 6.00\\" # Example 4: pythagoras(\\"10\\", \\"?\\", \\"5\\") # Output: ValueError with message \\"Invalid side lengths\\" ``` # Implementation: Enhance the given `pythagoras` function to meet the above requirements. ```python def pythagoras(opposite, adjacent, hypotenuse) -> str: try: # Validate inputs if not (isinstance(opposite, (int, float)) or opposite == \\"?\\"): raise ValueError(\\"Invalid value for opposite\\") if not (isinstance(adjacent, (int, float)) or adjacent == \\"?\\"): raise ValueError(\\"Invalid value for adjacent\\") if not (isinstance(hypotenuse, (int, float)) or hypotenuse == \\"?\\"): raise ValueError(\\"Invalid value for hypotenuse\\") if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse cannot be equal to or less than the other sides\\") opposite = ((hypotenuse**2 - adjacent**2)**0.5) if opposite <= 0: raise ValueError(\\"Calculated opposite length is invalid\\") return f\\"Opposite = {opposite:.2f}\\" if adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse cannot be equal to or less than the other sides\\") adjacent = ((hypotenuse**2 - opposite**2)**0.5) if adjacent <= 0: raise ValueError(\\"Calculated adjacent length is invalid\\") return f\\"Adjacent = {adjacent:.2f}\\" if hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse = ((opposite**2 + adjacent**2)**0.5) if hypotenuse <= 0: raise ValueError(\\"Calculated hypotenuse length is invalid\\") return f\\"Hypotenuse = {hypotenuse:.2f}\\" return \\"You already know the answer!\\" except ValueError as ve: raise ve except: raise ValueError(\\"Invalid argument(s) were given.\\") ```","solution":"def pythagoras(opposite, adjacent, hypotenuse) -> str: try: # Validate inputs if not (isinstance(opposite, (int, float)) or opposite == \\"?\\"): raise ValueError(\\"Invalid value for opposite\\") if not (isinstance(adjacent, (int, float)) or adjacent == \\"?\\"): raise ValueError(\\"Invalid value for adjacent\\") if not (isinstance(hypotenuse, (int, float)) or hypotenuse == \\"?\\"): raise ValueError(\\"Invalid value for hypotenuse\\") # Convert to float if not \\"?\\" if opposite != \\"?\\": opposite = float(opposite) if opposite <= 0: raise ValueError(\\"Side lengths must be positive\\") if adjacent != \\"?\\": adjacent = float(adjacent) if adjacent <= 0: raise ValueError(\\"Side lengths must be positive\\") if hypotenuse != \\"?\\": hypotenuse = float(hypotenuse) if hypotenuse <= 0: raise ValueError(\\"Side lengths must be positive\\") # Calculate the unknown side if opposite == \\"?\\": if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be greater than the other sides\\") opposite = (hypotenuse**2 - adjacent**2)**0.5 return f\\"Opposite = {opposite:.2f}\\" elif adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be greater than the other sides\\") adjacent = (hypotenuse**2 - opposite**2)**0.5 return f\\"Adjacent = {adjacent:.2f}\\" elif hypotenuse == \\"?\\": hypotenuse = (opposite**2 + adjacent**2)**0.5 return f\\"Hypotenuse = {hypotenuse:.2f}\\" # If none of the sides is \\"?\\", return valid message return \\"You already know the answer!\\" except ValueError as ve: raise ve except Exception as e: raise ValueError(\\"Invalid argument(s) were given.\\")"},{"question":"Context You have been hired by a digital archive company to optimize their document management system. They require you to implement an efficient algorithm to organize a list of document IDs in ascending order. Task Implement a function `optimized_insertion_sort` that takes a list of integers `arr` and returns the sorted list in ascending order. Your implementation must utilize the insertion sort algorithm but with a performance optimization that addresses its common bottleneck. # Function Signature ```python def optimized_insertion_sort(arr: list[int]) -> list[int]: pass ``` # Input - A list of integers `arr` with `1 <= len(arr) <= 10^4`. # Output - A list of integers sorted in ascending order. # Constraints - Document IDs are guaranteed to be unique. - Document IDs can be positive or negative integers. # Performance Requirements - The function should maintain a time complexity better than O(n^2) in most common scenarios. # Examples ```python assert optimized_insertion_sort([3, 1, 2]) == [1, 2, 3] assert optimized_insertion_sort([10, -1, 0, 4, 2]) == [-1, 0, 2, 4, 10] assert optimized_insertion_sort([]) == [] assert optimized_insertion_sort([5]) == [5] ``` # Constraints - Ensure to handle edge cases like empty lists or lists with a single element. - Do not use Python\'s built-in sorting methods. Hint Consider implementing a divide and conquer approach within the insertion sort framework to enhance performance.","solution":"def optimized_insertion_sort(arr: list[int]) -> list[int]: Sorts a list of integers using an optimized insertion sort algorithm. Parameters: arr (list[int]): The list of integers to sort. Returns: list[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Moved the elements of arr that are greater than key # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"You are given an array of integers, where every element appears three times except for one element, which appears exactly once. Implement a function `find_single_number(nums)` to identify the single element that does not appear three times. Your solution should have a linear runtime complexity and must be implemented without using extra memory. # Input An array of integers `nums` where: - Each integer `nums[i]` can be any valid integer. - 1 <= len(nums) <= 10^5 - Every element in `nums` appears exactly three times except for one element which appears exactly once. # Output Return the integer that appears exactly once. # Example ```python assert find_single_number([2, 2, 3, 2]) == 3 assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_single_number([1, 1, 1, -1]) == -1 ``` # Constraints - The algorithm must run in linear time, O(n). - The algorithm must use constant extra space, O(1). # Explanation - For the first example, `[2, 2, 3, 2]`: The number `3` appears exactly once, while `2` appears three times. - For the second example, `[0, 1, 0, 1, 0, 1, 99]`: The number `99` appears exactly once, while `0` and `1` appear three times each. - For the third example, `[1, 1, 1, -1]`: The number `-1` appears exactly once, while `1` appears three times. # Coding Implement the function `find_single_number(nums)` to achieve the above requirements. ```python def find_single_number(nums): ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones ```","solution":"def find_single_number(nums): ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# **Question: Implementing and Extending Pigeonhole Sort** Context: You are tasked to implement the pigeonhole sorting algorithm from scratch and extend it to handle different types of numerical data efficiently. This question will test your understanding of the algorithm’s mechanics, edge cases, and optimization strategies. Requirements: 1. Implement the pigeonhole sort algorithm. 2. Extend the implementation to handle an array of integers that can include negative numbers. 3. Handle edge cases such as arrays with one element or arrays with all identical elements. 4. Ensure the algorithm handles large datasets efficiently. Input: - A list of integers `arr` which can include negative numbers. Output: - A sorted list of integers. Constraints: - No usage of in-built sorting functions. - The list `arr` can contain from `0` to `10^6` elements. - The values in `arr` can range from `-10^6` to `10^6`. Function Signature: ```python def extended_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` Example: ```python # Input arr = [-5, -10, 0, 5, 3, -1] # Output [-10, -5, -1, 0, 3, 5] # Input arr = [1, 3, 2, 1, 3, 2, 1, 3] # Output [1, 1, 1, 2, 2, 3, 3, 3] ``` **Note**: Ensure your implementation is efficient and correct, taking into account the specified constraints and handling edge cases effectively.","solution":"def extended_pigeonhole_sort(arr): Sorts a given list of integers using the pigeonhole sorting algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 # Create empty pigeonholes pigeonholes = [[] for _ in range(range_size)] for num in arr: pigeonholes[num - min_val].append(num) sorted_arr = [] for hole in pigeonholes: sorted_arr.extend(hole) return sorted_arr"},{"question":"Stack Pair Switching Objective Write a function that rearranges a given stack such that successive pairs of elements are switched. If there is an odd number of elements, the top element remains unchanged. Context You are given a stack that represents a sequence of tasks. For optimal execution, pairs of tasks need to switch their order while maintaining the relative order of successively executed tasks. Requirements Implement one function, `switch_pairs`, that performs the stack rearrangement using either an auxiliary stack or an auxiliary queue. Function Signature ```python def switch_pairs(stack: list[int]) -> list[int]: pass ``` Input * A list `stack` where the first element represents the bottom of the stack, and the last element represents the top of the stack. * Constraints: Stack size n where (0 leq n leq 10^5), and each element in the stack is an integer in the range ([-10^6, 10^6]). Output * A list with adjusted order, maintaining the stack structure with pairs of elements switched. Example ```python stack = [3, 8, 17, 9, 1, 10] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` Constraints & Performance * Ensure the function runs in linear time, O(n). * Additional space usage must not exceed O(n). Good luck! Your implementation should aim to be clean and efficient. Be mindful of edge cases like empty stacks and odd-sized stacks.","solution":"def switch_pairs(stack: list[int]) -> list[int]: Rearranges a given stack such that successive pairs of elements are switched. n = len(stack) result = [] i = 0 while i < n: if i + 1 < n: # Switch pairs result.append(stack[i + 1]) result.append(stack[i]) i += 2 else: # If there\'s an odd number of elements, append the last element as is result.append(stack[i]) i += 1 return result"},{"question":"# Bucket Sort Implementation Challenge **Context**: You are tasked with enhancing a sorting system for an e-commerce platform. The system uses bucket sort to optimize the ranking of product prices for various categories. Your objective is to implement `bucket_sort` and `next_sort` functions that efficiently sort an array of floating-point numbers ranging from 0 to 100. **Task**: Implement the `bucket_sort` function, a sorting algorithm that distributes elements of an array into a number of buckets. Each bucket then sorts its elements and finally merges all sorted buckets. Use insertion sort (`next_sort`) within each bucket to maintain stable sorting. **Function Signature**: ```python def bucket_sort(arr: List[float]) -> List[float]: ``` **Input**: - `arr`: A list of floating-point numbers (0 ≤ `arr[i]` < 100) **Output**: - Returns a list of sorted floating-point numbers in ascending order. **Constraints**: - The array will contain at least one and at most 10000 elements. - All numbers in the array are non-negative floats less than 100. **Performance Requirements**: - Aim for O(n + k) average time complexity, where `k` is a constant number of buckets (you can assume `k` = 100). **Notes**: - Take into account edge cases like empty arrays or arrays where all numbers are the same. - Ensure the sorting within the buckets is stable. Example: ```python input_array = [42.3, 12.1, 13.5, 99.9, 2.2, 54.4, 22.2] sorted_array = bucket_sort(input_array) print(sorted_array) # Expected: [2.2, 12.1, 13.5, 22.2, 42.3, 54.4, 99.9] ```","solution":"from typing import List def next_sort(arr: List[float]) -> List[float]: Performs insertion sort on the provided list `arr`. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: Sorts the list `arr` using bucket sort algorithm. if len(arr) == 0: return arr # Create buckets num_buckets = 100 buckets = [[] for _ in range(num_buckets)] # Distribute the elements into buckets for num in arr: index = int(num) buckets[index].append(num) # Sort each bucket and concatenate the results sorted_arr = [] for bucket in buckets: sorted_bucket = next_sort(bucket) sorted_arr.extend(sorted_bucket) return sorted_arr"},{"question":"# Matrix Chain Multiplication Problem The matrix chain multiplication problem is an optimization problem that determines the most efficient way to multiply a given sequence of matrices with specific dimensions. The goal is to minimize the total number of scalar multiplications. You are given an array `arr` of length `n+1` where the `i-th` matrix has dimensions `arr[i-1] x arr[i]`. Implement a function `matrix_chain_order(arr)` that calculates the minimum number of scalar multiplications needed to multiply the chain of matrices and returns both the cost matrix and the solution matrix. Additionally, implement `print_optimal_solution(solution, i, j)` to print the optimal order of multiplications. # Function Specifications `matrix_chain_order(arr)` * **Input**: * `arr` (List[int]): Array representing the dimensions of matrices. * **Output**: * `cost` (List[List[int]]): A 2D list where `cost[i][j]` contains the minimum cost of multiplying matrices from `i` to `j`. * `solution` (List[List[int]]): A 2D list where `solution[i][j]` stores the index `k` at which the optimal split occurs. `print_optimal_solution(solution, i, j)` * **Input**: * `solution` (List[List[int]]): A 2D list storing the optimal split points obtained from `matrix_chain_order`. * `i` (int): Starting index of the matrices * `j` (int): Ending index of the matrices. * **Output**: * Prints the optimal order of matrix multiplications. # Example ```python arr = [30, 35, 15, 5, 10, 20, 25] cost, solution = matrix_chain_order(arr) print(\\"Minimum number of multiplications is:\\", cost[1][len(arr)-1]) print(\\"Optimal Parenthesization is:\\", end=\\" \\") print_optimal_solution(solution, 1, len(arr)-1) ``` Expected Output ``` Minimum number of multiplications is: 15125 Optimal Parenthesization is: ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Constraints * 2 < length of arr < 100 * 1 ≤ arr[i] ≤ 100 for all 0 ≤ i < length of arr # Notes - Carefully handle the indices when accessing elements in the `cost` and `solution` matrices. - Feel free to add helper functions for clarity and modularity. - Ensure your solution is efficient and handles the constraints mentioned.","solution":"def matrix_chain_order(arr): Calculates the minimum number of scalar multiplications needed to multiply the chain of matrices with given dimensions. Parameters: arr (list of int): dimensions of the matrices. Returns: tuple: cost matrix and solution matrix n = len(arr) - 1 cost = [[0 for x in range(n + 1)] for y in range(n + 1)] solution = [[0 for x in range(n + 1)] for y in range(n + 1)] for length in range(2, n + 1): for i in range(1, n - length + 2): j = i + length - 1 cost[i][j] = float(\'inf\') for k in range(i, j): q = cost[i][k] + cost[k + 1][j] + arr[i - 1] * arr[k] * arr[j] if q < cost[i][j]: cost[i][j] = q solution[i][j] = k return cost, solution def print_optimal_solution(solution, i, j): Prints the optimal order of matrix multiplications using the solution matrix. Parameters: solution (list of list of int): solution matrix with optimal split indices i (int): starting index of the matrix chain j (int): ending index of the matrix chain if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(solution, i, solution[i][j]) print_optimal_solution(solution, solution[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"Implement advanced stack manipulation based on the provided algorithm. You are required to write a function named `remove_min_advanced(stack)` which takes a list representing a stack as input and removes and returns the smallest element while preserving the order of other elements. Function Signature ```python def remove_min_advanced(stack: list) -> list: ``` # Inputs - `stack`: A list of integers where the end of the list represents the top of the stack. # Outputs - The original `stack` list after the smallest element has been removed. # Constraints - Do not use in-built functions like `min()` to find the minimum element. - The solution should be efficient enough to handle stacks containing up to 1000 elements. # Example ```python stack = [2, 8, 3, -6, 7, 3] result = remove_min_advanced(stack) print(result) # Output: [2, 8, 3, 7, 3] stack = [1, 5, 1, 9] result = remove_min_advanced(stack) print(result) # Output: [5, 1, 9] stack = [7] result = remove_min_advanced(stack) print(result) # Output: [] ``` Additional Notes: - Ensure that the returned stack excludes only the first smallest element found. - Your function should manage edge cases where the stack might be empty or contain identical elements. - Keep the overall complexity in mind to ensure the function performs efficiently for varying stack sizes.","solution":"def remove_min_advanced(stack: list) -> list: if not stack: return stack # Manually finding the minimum element min_element = stack[0] min_index = 0 for index in range(1, len(stack)): if stack[index] < min_element: min_element = stack[index] min_index = index # Remove the first occurrence of the minimum element return stack[:min_index] + stack[min_index + 1:]"},{"question":"**Three Sum Problem** Given an array ( S ) of ( n ) integers, find all unique triplets in the array which give the sum of zero. Your solution must not contain duplicate triplets. **Function Signature**: ```python def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: # Your code here ``` **Input**: * A list of integers, where ( -10^5 leq array[i] leq 10^5 ) * The length of the array will be at most ( 10^4 ). **Output**: * A set of tuples, where each tuple represents a triplet that sums to zero. **Example**: ```python S = [-1, 0, 1, 2, -1, -4] three_sum(S) ``` **Expected Output**: ```python { (-1, 0, 1), (-1, -1, 2) } ``` **Constraints**: * The solution set must not contain duplicate triplets. * Consider edge cases where the input array has fewer than three elements. **Scenario**: You are a software engineer at a financial modeling firm. As part of a trading application, you are tasked to find if there are combinations of asset price changes that together net to zero, to identify if there are possible arbitrage opportunities due to offsetting price variations. **Performance Requirements**: * Your solution should efficiently handle input sizes up to the provided constraints using a time complexity of ( O(n^2) ). **Hint**: Consider sorting the input array first and using a two-pointer technique to find pairs that sum up to the negative of the fixed element.","solution":"from typing import List, Set, Tuple def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: array.sort() result = set() for i in range(len(array) - 2): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, len(array) - 1 while left < right: total = array[i] + array[left] + array[right] if total == 0: result.add((array[i], array[left], array[right])) while left < right and array[left] == array[left + 1]: left += 1 while left < right and array[right] == array[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"# Hailstone Sequence Analysis and Extension Objective: Implement and analyze the hailstone sequence generator and write a function to compute statistics on the sequence. Details: 1. **Function 1**: `hailstone(n)`: Generate the hailstone sequence starting from an integer `n`. * **Input**: A positive integer `n` (1 ≤ n ≤ 10^6). * **Output**: A list representing the hailstone sequence starting from `n` and ending at 1. 2. **Function 2**: `hailstone_extended_statistics(n)`: Compute and return the length of the sequence, the maximum number reached, and the number of steps to reach 1. * **Input**: A positive integer `n` (1 ≤ n ≤ 10^6). * **Output**: A tuple with three integers representing: * Length of the hailstone sequence. * Maximum value within the sequence. * Number of steps to reach 1. Requirements: * Implement `hailstone(n)` function based on the provided snippet. * Implement `hailstone_extended_statistics(n)` that calls `hailstone(n)` and computes the required statistics. * Optimize where possible to handle large sequences efficiently within provided constraints. Constraints: * Handle edge cases for `n` values like 1 and large numbers efficiently. * Ensure the solution works within reasonable time limits for the input range. Examples: ```python # Example 1 sequence = hailstone(7) print(sequence) # Output: [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] # Example 2 stats = hailstone_extended_statistics(7) print(stats) # Output: (17, 52, 16) ```","solution":"def hailstone(n): Generate the hailstone sequence starting from an integer n. Parameters: n (int): A positive integer (1 ≤ n ≤ 10^6). Returns: List[int]: A list representing the hailstone sequence starting from n and ending at 1. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(1) return sequence def hailstone_extended_statistics(n): Compute and return the length of the hailstone sequence, the maximum number reached, and the number of steps to reach 1. Parameters: n (int): A positive integer (1 ≤ n ≤ 10^6). Returns: Tuple[int, int, int]: A tuple containing the length of the hailstone sequence, the maximum value within the sequence, and the number of steps to reach 1. sequence = hailstone(n) length = len(sequence) max_value = max(sequence) steps_to_reach_1 = length - 1 return (length, max_value, steps_to_reach_1)"},{"question":"# Matrix Transformation Functions Given a NxM matrix, write a function to perform the following transformations: 1. Rotation: rotate a given 2D matrix by 90 degrees clockwise or counterclockwise. 2. Top-left diagonal inversion. 3. Bottom-left diagonal inversion. Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input Format - A 2D matrix of integers, where 1 ≤ N, M ≤ 1000. Output Format - Each function should return a new transformed 2D matrix. Constraints - The input matrix can be non-square. - Each function must run in at most O(N x M) time complexity. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] top_left_invert(matrix) == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] bottom_left_invert(matrix) == [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Make sure to handle edge cases appropriately, such as: * Empty matrices. * Matrices with single rows or columns. Your solutions should prioritize clarity and efficiency, considering both time and space complexities.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate a given 2D matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate a given 2D matrix by 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Perform top-left diagonal inversion on a given 2D matrix. N = len(matrix) if N == 0: return matrix M = len(matrix[0]) inverted = [[0] * N for _ in range(M)] for i in range(N): for j in range(M): inverted[j][i] = matrix[i][j] return inverted def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Perform bottom-left diagonal inversion on a given 2D matrix. N = len(matrix) if N == 0: return matrix M = len(matrix[0]) inverted = [[matrix[N-1-i][M-1-j] for i in range(N)] for j in range(M)] return inverted"},{"question":"You are given a task to design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Implement the `encode` and `decode` methods to accomplish this task effectively. # Functions to Implement 1. **encode(self, strs: List[str]) -> str**: - Encodes a list of strings into a single string. - **Input**: - `strs`: List of strings (List[str]) with constraints: 1 <= len(strs[i]) <= 200, 1 <= len(strs) <= 200. - **Output**: - Returns a single encoded string (str). 2. **decode(self, s: str) -> List[str]**: - Decodes a single string back into a list of original strings. - **Input**: - `s`: Encoded string (str). - **Output**: - Returns a list of strings (List[str]). # Constraints - The length of each string in the list will be between 1 and 200. - The total number of strings in the list will be between 1 and 200. - You must preserve the order of strings in the list. # Example ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] ``` # Requirements - Do not use built-in serialization libraries or methods. - Handle edge cases such as empty strings properly. - Ensure that the code is efficient in terms of time and space complexity.","solution":"from typing import List class Codec: def encode(self, strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_string = \'\' for s in strs: length = len(s) encoded_string += f\'{length}:{s}\' return encoded_string def decode(self, s: str) -> List[str]: Decodes a single string back to a list of strings. decoded_list = [] i = 0 while i < len(s): # find the position of the separator \':\' j = s.index(\':\', i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i + length]) i += length return decoded_list"},{"question":"**Flatten Nested Arrays** Given an array that may contain nested arrays, write a function to produce a single, flat resultant array. Function Signature ```python def flatten_array(nested_array: list) -> list: pass ``` Input - `nested_array`: A potentially multi-dimensional list of elements. The list can contain integers, strings, or further nested lists. Output - A single, flat list containing all elements from the `nested_array` in their original order. Constraints 1. The function must use recursion. 2. Avoid using any built-in flattening utilities. 3. Assume the maximum depth of nesting will not exceed 1000 levels to prevent excessive recursion depth issues. 4. While handling nested lists, ensure that strings are not treated as lists even though they are iterable. Example ```python assert flatten_array([1, [2, 3, [4, 5]], 6, [[7], 8], 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_array([1, \'two\', [\'three\', [4, [5, \'six\']]]]) == [1, \'two\', \'three\', 4, 5, \'six\'] assert flatten_array([]) == [] ``` # Performance Requirements - The implementation should run in O(n) time complexity. - Space complexity needs to respect the constraints but optimize for depth using the tail-recursive approach if possible. Additional Context Suppose we are writing an application that processes data files that often have deeply nested structures. Before processing the data, we need a utility to flatten these structures for easy access and manipulation. Write your function and ensure it handles edge cases like single-element nested lists, deeply nested elements near the recursion limit, and various data types (integers, strings, nested lists).","solution":"def flatten_array(nested_array): Recursively flatten a nested list or array. Args: nested_array (list): A list which may contain nested lists. Returns: list: A flattened list with all nested elements in their original order. flattened = [] def recurse(items): for item in items: if isinstance(item, list): recurse(item) else: flattened.append(item) recurse(nested_array) return flattened"},{"question":"**Scenario**: You are a bioinformatician tasked with comparing sequences to find genetic similarities. To achieve this, you need an efficient solution to measure the longest common subsequence between two given DNA segments. **Task**: Write a function `longest_common_subsequence` that takes two strings, `s_1` and `s_2`, containing only lowercase English alphabets and returns the length of their longest common subsequence. **Function Signature**: ```python def longest_common_subsequence(s_1: str, s_2: str) -> int: ``` **Input**: * `s_1` (1 ≤ len(s_1) ≤ 1000): The first string. * `s_2` (1 ≤ len(s_2) ≤ 1000): The second string. **Output**: * An integer representing the length of the longest common subsequence between the two strings. **Constraints**: * The strings will contain only lowercase English alphabets. **Performance Requirements**: * The algorithm should be able to handle strings up to 1000 characters efficiently. * Time complexity should be O(M*N) and space complexity should be O(M*N), where M and N are the lengths of s_1 and s_2, respectively. **Example**: ```python assert longest_common_subsequence(\'abcdgh\', \'aedfhr\') == 3 # Explanation: \'adh\' is the longest common subsequence assert longest_common_subsequence(\'abc\', \'abc\') == 3 # Explanation: \'abc\' is the longest common subsequence assert longest_common_subsequence(\'abc\', \'def\') == 0 # Explanation: There is no common subsequence. ``` **Notes**: * Ensure that your solution handles all edge cases. * You are not required to return the actual subsequence, only its length.","solution":"def longest_common_subsequence(s_1: str, s_2: str) -> int: Returns the length of the longest common subsequence between two strings s_1 and s_2. m, n = len(s_1), len(s_2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Question: Function Implementation for Optimal String Reversal You are tasked with implementing an efficient string reversal function in Python. This function should handle a typical range of input sizes efficiently while maintaining clarity and readability. Your implementation should reflect a clear understanding of algorithmic and data structure principles, avoiding unnecessary complexity. Requirements: 1. **Input Format**: - A single string `s` (1 <= len(s) <= 10^6). 2. **Output Format**: - The reversed string. Constraints: - The function should handle edge cases like empty strings and large strings efficiently. Performance: - Aim for an O(n) time complexity solution with O(1) additional space complexity, where n is the length of the string. # Example ```python Input: \\"hello\\" Output: \\"olleh\\" Input: \\"A man a plan a canal Panama\\" Output: \\"amanaP lanac a nalp a nam A\\" ``` Function Signature: ```python def efficient_reverse(s: str) -> str: pass ``` Context: You are assisting in developing a text processing library where one of the fundamental operations is string reversal. The requirement is to implement this with optimal performance and clear, maintainable code. Task: Implement the function `efficient_reverse(s: str) -> str` to meet these criteria. Evaluation Criteria: - Correctness: Your function should return the correct reversed string. - Efficiency: Your solution should run within the defined time and space constraints. - Code Quality: Your implementation should be clear, maintainable, and reflect good coding practices.","solution":"def efficient_reverse(s: str) -> str: Returns the reversed string of the input string \'s\'. return s[::-1]"},{"question":"# Problem: Bubble Sort with Early Termination Optimization **Context:** You are provided with a basic Bubble Sort algorithm that sorts an array of integers in ascending order. However, the current implementation is inefficient for large datasets. To make this algorithm more efficient, you will optimize it by adding a feature to terminate the algorithm early if the list becomes sorted before completing all possible passes. **Task:** Write a function `optimized_bubble_sort(arr, simulation=False)` that optimizes the traditional Bubble Sort by incorporating an early termination check. **Function Signature:** ```python def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Input:** * `arr`: A list of integers to be sorted (0 ≤ len(arr) ≤ 10^3, -10^3 ≤ arr[i] ≤ 10^3). * `simulation`: A boolean flag that, when set to `True`, prints the internal state of the array at each iteration of the sorting process for visualization. **Output:** * Returns the sorted list of integers. **Constraints:** * If `simulation` is `True`, print the internal state of the array after each iteration, following the format: \\"iteration X: element1 element2 ... elementN\\". * You should ensure that the algorithm terminates early if the list becomes sorted before completing all the passes. **Example:** ```python # Example 1 arr = [3, 2, 1] print(optimized_bubble_sort(arr, True)) # Output: # iteration 0: 3 2 1 # iteration 1: 2 3 1 # iteration 2: 2 1 3 # iteration 3: 1 2 3 # [1, 2, 3] # Example 2 arr = [5, 1, 4, 2, 8] print(optimized_bubble_sort(arr)) # Output: [1, 2, 4, 5, 8] ``` **Note:** Make sure the implementation is efficient and correctly handles edge cases like empty lists, single-element lists, already sorted lists, and lists with all identical elements.","solution":"def optimized_bubble_sort(arr, simulation=False): Optimized Bubble Sort with early termination. Parameters: arr (List[int]): List of integers to be sorted simulation (bool): If True, prints the internal state at each iteration Returns: List[int]: Sorted list of integers n = len(arr) for i in range(n): # Initially assume the array is sorted swapped = False # Traverse the array from 0 to n-i-1 for j in range(0, n-i-1): # Traverse the array and swap if the element found is greater # than the next element if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # Print the internal state of the array if simulation is True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") # If no two elements were swapped by the inner loop, break if not swapped: break return arr"},{"question":"# Minimal Bit Flips Problem Scenario You are tasked with designing a low-level error correction mechanism in a data transmission system. Part of this task involves determining the minimal number of bit changes required between two integers that represent transmitted and received data. Efficient detection of bit differences will allow you to quickly identify and correct errors in the data. Task Implement a function that takes two non-negative integers and returns the number of bit positions that differ between the binary representations of these integers. Constraints * Both integers ( A ) and ( B ) are non-negative. * You must not convert the integers to binary strings directly. * Consider the input integers can be up to 32-bit. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input * Two integers ( A ) and ( B ) (0 <= ( A, B ) <= 2^31 - 1) Output * An integer representing the number of differing bits. Examples 1. For ( A = 29 ) (binary: 11101) and ( B = 15 ) (binary: 01111): * Output: 2 * Explanation: `29 XOR 15` results in binary 10 (binary: 00010), which has 2 bits set to 1. 2. For ( A = 10 ) (binary: 1010) and ( B = 7 ) (binary: 0111): * Output: 3 * Explanation: `10 XOR 7` results in binary 1101 (binary: 1101), which has 3 bits set to 1. Notes * Optimize for time and space complexity.","solution":"def count_flips_to_convert(a: int, b: int) -> int: This function returns the number of differing bit positions between the binary representations of two non-negative integers a and b. # Perform XOR between the two numbers xor_result = a ^ b # Count the number of 1s in the binary representation of the XOR result count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"You have been provided with an implementation of the Interpolation Search algorithm. This algorithm is often preferred over binary search for searching in uniformly distributed arrays as it can provide better performance with average time complexity of O(log log n). However, its worst-case complexity can degenerate to O(n), making it less than ideal for all data distributions. Your task is to implement an optimized variation of the Interpolation Search algorithm that performs better on non-uniformly distributed datasets. Specifically, you need to design a function that dynamically selects between Interpolation Search and Binary Search based on the distribution characteristics of the array. # Requirements 1. **Function Signature**: ```python def hybrid_search(array: List[int], search_key: int) -> int: ``` 2. **Input**: * `array` - A list of integers sorted in increasing order. * `search_key` - An integer key to be searched within the array. 3. **Output**: * The function should return the index of `search_key` in the `array` if it is found. Otherwise, it should return `-1`. 4. **Constraints**: * The array elements are sorted in non-decreasing order. * The function should handle both small and large arrays efficiently. # Performance Expectations 1. The function should perform efficiently for both uniformly and non-uniformly distributed arrays. 2. For uniformly distributed arrays, the function should leverage Interpolation Search. 3. For non-uniformly distributed arrays, it should fallback to Binary Search or another suitable method. # Example ```python >>> hybrid_search([5, 5, 5, 5, 5, 5, 5], 5) 0 >>> hybrid_search([10, 22, 35, 47, 52, 66, 78, 85], 66) 5 >>> hybrid_search([10, 22, 35, 47, 52, 66, 78, 85], 100) -1 >>> hybrid_search([10, 20, 30, 35, 40, 45, 50], 35) 3 >>> hybrid_search([], 5) -1 ``` # Notes * You may define additional helper functions if necessary, but make sure to keep the implementation clear and efficient. * Evaluate the performance using both uniform and non-uniform data distributions, and ensure the algorithm dynamically adapts to provide the best performance.","solution":"from typing import List def hybrid_search(array: List[int], search_key: int) -> int: def interpolation_search(arr, low, high, key): while low <= high and arr[low] <= key <= arr[high]: if low == high: if arr[low] == key: return low return -1 pos = low + ((high - low) // (arr[high] - arr[low]) * (key - arr[low])) if arr[pos] == key: return pos if arr[pos] < key: low = pos + 1 else: high = pos - 1 return -1 def binary_search(arr, low, high, key): while low <= high: mid = (low + high) // 2 if arr[mid] == key: return mid elif arr[mid] < key: low = mid + 1 else: high = mid - 1 return -1 def is_uniform_distribution(arr): if len(arr) < 2: return True step = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != step: return False return True if not array: return -1 if is_uniform_distribution(array): return interpolation_search(array, 0, len(array)-1, search_key) else: return binary_search(array, 0, len(array)-1, search_key)"},{"question":"Given an `m x n` matrix where each row and each column is sorted in non-decreasing order, write a function `find_key_in_sorted_matrix(matrix, key)` that returns a tuple `(row_index, col_index)` indicating the position of `key` in the matrix. If the key is not found, return `None`. # Function Signature ```python def find_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: ``` # Input * `matrix`: A 2D list of integers, where each row and each column is sorted in non-decreasing order. * `key`: An integer that you need to search for in the matrix. # Output * A tuple `(row_index, col_index)` if the key is found, where `row_index` is the index of the row and `col_index` is the index of the column (both 0-indexed). * `None` if the key is not found. # Constraints * `1 <= m, n <= 1000` (1 <= the number of rows, the number of columns <= 1000) * The matrix elements are integers that fit in a 32-bit signed integer. * The matrix is sorted row-wise and column-wise non-decreasingly. # Performance Requirements * The algorithm should run in O(m + n) time complexity. # Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(find_key_in_sorted_matrix(matrix, key)) # Returns (1, 2) because matrix[1][2] = 13 key = 6 print(find_key_in_sorted_matrix(matrix, key)) # Returns None because 6 is not in the matrix ``` # Notes * Start your search from the bottom-left corner of the matrix. * Move up if the current element is larger than the key. * Move right if the current element is smaller than the key.","solution":"from typing import List, Optional, Tuple def find_key_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) # Start from the bottom-left corner of the matrix row = rows - 1 col = 0 while row >= 0 and col < cols: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: row -= 1 else: col += 1 return None"},{"question":"Run-Length Encoding and Decoding # Objective Implement two functions, `encode_rle(input)` and `decode_rle(input)`, following the Run-Length Encoding (RLE) algorithm to compress and decompress data, respectively. # Instructions Function `encode_rle(input)` - **Input**: A string with the data to be encoded. - **Output**: A string with the encoded data. - **Constraints**: - Input string `input` length: 0 <= len(input) <= 10^4 - Characters in input are ASCII characters. Function `decode_rle(input)` - **Input**: A string with the data to be decoded. - **Output**: A string with the decoded data. - **Constraints**: - Input string `input` represents a valid RLE encoded string as produced by `encode_rle`. - The input string is valid, and count digits are correctly placed before characters. # Examples Example 1 ```python input_str = \\"aaabbccccdaa\\" encoded = encode_rle(input_str) print(encoded) # Output: \\"3a2b4c1d2a\\" decoded = decode_rle(encoded) print(decoded) # Output: \\"aaabbccccdaa\\" ``` Example 2 ```python input_str = \\"\\" encoded = encode_rle(input_str) print(encoded) # Output: \\"\\" decoded = decode_rle(encoded) print(decoded) # Output: \\"\\" ``` # Notes - Ensure your solution correctly handles edge cases such as empty strings. - Both functions should handle upper and lower case characters appropriately. - Emphasize efficient string operations to handle the upper limit of constraints effectively.","solution":"def encode_rle(input): Encodes the input string using Run-Length Encoding (RLE). Args: input (str): The input string to be encoded. Returns: str: The RLE encoded string. if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char # Append the last character and its count encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def decode_rle(input): Decodes the RLE encoded string back to its original form. Args: input (str): The RLE encoded string. Returns: str: The decoded string. if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # Handle multi-digit numbers else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"# Bitonic Sort Implementation Challenge You are tasked with implementing the Bitonic Sort algorithm. The main goal is to sort an array of integers and ensure the implementation can handle arrays efficiently. Your solution should include handling edge cases and optimizing performance where feasible. **Function Signature:** ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ... ``` # Input - `arr`: A list of integers of size `n` (where `n` is a power of 2). - `reverse`: A boolean value, which if set to `True`, sorts the array in increasing order, and if set to `False`, sorts it in decreasing order. Default is `False`. # Output - A list of integers sorted in the specified order. # Constraints - The size `n` of the input list is guaranteed to be a power of 2, i.e., `n = 2^k` for some non-negative integer `k`. - The function should handle lists with sizes as small as `1`. # Example Input ```python arr = [3, 7, 4, 8, 6, 2, 1, 5] reverse = True ``` Output ```python [1, 2, 3, 4, 5, 6, 7, 8] ``` # Requirements 1. Implement the Bitonic Sort algorithm. 2. Ensure the function handles edge cases effectively: * At least one test case for an empty array or single element array. 3. Account for potential performance bottlenecks. 4. Achieve the desired sort order based on the value of `reverse`. # Scenario As a part of the software development team working on a high-performance data processing system, you have been assigned the task to implement a highly parallelizable sorting algorithm. Given the nature of the system, the Bitonic Sort is chosen due to its inherent parallelism which fits well with the hardware capabilities. This is a crucial component that needs to be optimized for real-time data sorting.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def compare_and_swap(arr, i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) bitonic_sort_recursive(arr, 0, len(arr), reverse) return arr"},{"question":"Shell sort is an optimized version of insertion sort that allows the exchange of items that are far apart. The basic idea is to arrange the list of elements so sequences of elements that are far apart are sorted. Description Implement the `shell_sort` function which sorts a given list of integers using the Shell Sort algorithm. Your function will receive an input list and should return the sorted list. Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: ``` Input * A list `arr` of integers where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. Output * A list of integers, sorted in non-decreasing order. Constraints * You should implement the Shell Sort algorithm using a gap sequence that halves the gap each iteration, starting from `n/2` and ending at `1`. Example ```python # Example 1 arr = [12, 34, 54, 2, 3] print(shell_sort(arr)) # Output: [2, 3, 12, 34, 54] # Example 2 arr = [4, 3, 2, 1] print(shell_sort(arr)) # Output: [1, 2, 3, 4] ``` # Notes * Focus on an efficient and correct implementation of the Shell Sort algorithm. * Consider potential optimizations and edge cases during implementation. * Ensure your solution adheres to the provided time and space complexity constraints.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"Context You are tasked with enhancing a legacy search system. The system stores search keys in sorted arrays. Your team currently uses a binary search algorithm that performs sub-optimally due to the uniformly distributed nature of most datasets. You decide to implement the Interpolation Search algorithm to increase the search efficiency. Task Write a Python function `enhanced_interpolation_search` that takes a sorted array and a search key as inputs, and returns the index of the search key in the array. If the search key is not found, return `-1`. Input and Output Formats * **Input**: - `array` (List[int]): A sorted list of integers. - `search_key` (int): The integer value to search for in the array. * **Output**: - (int): The index of `search_key` in the array if found; otherwise, `-1`. Constraints * The input array is sorted in non-decreasing order. * Array length is between `0` and `10^6`. * Elements in the array are in the range `-10^9` to `10^9`. Function Signature ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: ``` Performance Requirements * Your solution should aim for O(log log n) time complexity for uniformly distributed data. * Ensure that the function uses O(1) additional space. Edge Cases to Consider * An empty array. * Arrays where all elements are the same. * The search key being the smallest or largest element in the array. * The search key being outside the range of the array elements. Example ```python assert enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert enhanced_interpolation_search([], 5) == -1 assert enhanced_interpolation_search([1, 1, 1, 1, 1], 1) == 0 assert enhanced_interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9 ```","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimate the position of the search_key within the bounds pos = low + int(((float(high - low) / (array[high] - array[low] + 1)) * (search_key - array[low]))) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question: Comprehensive String Reversal Function You are tasked with creating a comprehensive function that reverses a given string. You must implement a function that allows selection between four different reversal techniques: 1. **Recursive**: Using recursion to divide and conquer. 2. **Iterative**: Using a two-pointer technique. 3. **Pythonic**: Utilizing Python\'s `reversed()` functionality. 4. **Ultra Pythonic**: Utilizing Python\'s slicing capabilities. Function Signature ```python def reverse_string(s: str, method: str) -> str: pass ``` Parameters * **s**: A string to be reversed. * **method**: A string indicating the method of reversal. Can be one of [\\"recursive\\", \\"iterative\\", \\"pythonic\\", \\"ultra_pythonic\\"]. Output * Returns the reversed string based on the specified method. Constraints * Do NOT use any external libraries (other than standard Python modules). * Handle edge cases gracefully, particularly the empty string and single-character strings. * Ensure that your function runs efficiently for strings up to 1000 characters in length. Example ```python reverse_string(\\"example\\", \\"recursive\\") # \\"elpmaxe\\" reverse_string(\\"example\\", \\"iterative\\") # \\"elpmaxe\\" reverse_string(\\"example\\", \\"pythonic\\") # \\"elpmaxe\\" reverse_string(\\"example\\", \\"ultra_pythonic\\") # \\"elpmaxe\\" ``` You need to write the function `reverse_string` accordingly and ensure it behaves correctly for all provided methods and edge cases.","solution":"def reverse_string(s: str, method: str) -> str: if method == \\"recursive\\": return recursive_reverse(s) elif method == \\"iterative\\": return iterative_reverse(s) elif method == \\"pythonic\\": return pythonic_reverse(s) elif method == \\"ultra_pythonic\\": return ultra_pythonic_reverse(s) else: raise ValueError(\\"Invalid method specified\\") def recursive_reverse(s: str) -> str: # Helper function for recursion if len(s) <= 1: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: chars = list(s) left, right = 0, len(chars) - 1 while left < right: chars[left], chars[right] = chars[right], chars[left] left += 1 right -= 1 return \'\'.join(chars) def pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: return s[::-1]"},{"question":"Stack Sort Checker You are provided with a stack of integers. Your task is to write a function that verifies if the stack elements are sorted in strictly ascending order from the bottom to the top of the stack. # Function Signature ```python def is_sorted(stack: List[int]) -> bool: ``` # Input * A list of integers representing a stack, where the last element corresponds to the top of the stack. # Output * A boolean value: `True` if the stack is sorted in ascending order from bottom to top, otherwise `False`. # Constraints * The length of the stack will be between 0 and 1000 inclusive. * Each element in the stack will be an integer in the range of -10^6 to 10^6. Examples 1. **Example 1:** * Input: [1, 2, 3, 4, 5, 6] * Output: `True` 2. **Example 2:** * Input: [6, 5, 4, 3, 2, 1] * Output: `False` 3. **Example 3:** * Input: [1, 2, 2, 3] * Output: `True` 4. **Example 4:** * Input: [] * Output: `True` # Scenario Imagine you have a software that uses stacks to manage history states, such as an undo mechanism in a text editor. To ensure consistency, you need to make sure the historical states are stored in ascending order of their timestamps so that the oldest state is at the bottom and the newest state is on top. This function will help in verifying the correctness of the state stack. # Notes Ensure that your implementation retains the original order of the stack elements and operates within the given constraints.","solution":"from typing import List def is_sorted(stack: List[int]) -> bool: Check if the stack is sorted in ascending order from bottom to top. for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"Problem Statement You are provided with an array `nums` consisting of integers where exactly two elements appear only once and all other elements appear exactly twice. Your task is to find these two unique elements. **Function Signature:** ```python def find_two_unique_numbers(nums: List[int]) -> List[int]: pass ``` **Input:** - `nums`: A list of integers where exactly two elements appear only once, and all other elements appear exactly twice. **Output:** - A list of two integers which are the elements that appear only once in `nums`. **Constraints:** - The time complexity of your solution should be O(N), where N is the number of elements in `nums`. - The space complexity of your solution should be O(1). **Example:** ```python nums = [1, 2, 1, 3, 2, 5] find_two_unique_numbers(nums) ``` Output: ```python [3, 5] # or [5, 3] as the order is not important ``` **Scenarios to consider:** - Arrays with minimal size such as `nums = [2, 3]`, expected output: `[2, 3]` - Arrays where all elements except two are repeated exactly twice. Explanation: 1. Use XOR to find the combined effect of the two unique numbers (`A` and `B`). This will result in `A ^ B`. 2. Identify any right-most set bit in the result of `A ^ B`. This bit helps in distinguishing between `A` and `B`. 3. Divide the numbers into two groups based on the identified bit: - One group with the bit set. - Another group with the bit not set. 4. Using XOR within each group will isolate the two unique numbers. Implement `find_two_unique_numbers` function and ensure it meets the constraints provided.","solution":"from typing import List def find_two_unique_numbers(nums: List[int]) -> List[int]: # Step 1: Compute the cumulative XOR of all elements xor = 0 for num in nums: xor ^= num # Step 2: Find the rightmost set bit in the xor result rightmost_set_bit = xor & -xor # Step 3: Use the rightmost set bit to divide the numbers into two groups unique1, unique2 = 0, 0 for num in nums: if (num & rightmost_set_bit) == 0: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Secure Key Exchange using Diffie-Hellman Protocol **Objective**: Implement a secure key exchange using the Diffie-Hellman protocol. # Problem Statement Alice and Bob want to securely share a secret key over an insecure communication channel using the Diffie-Hellman key exchange protocol. The security of the communication relies on the difficulty of the discrete logarithm problem, so they need to select large prime numbers and their corresponding primitive roots. # Tasks 1. **Prime Verification**: Implement a function `is_prime(n: int) -> bool` that determines whether a given number `n` is a prime. 2. **Primitive Root Calculation**: Implement a function `calculate_primitive_root(p: int) -> List[int]` that finds all the primitive roots of prime number `p`. 3. **Diffie-Hellman Key Exchange**: Implement a function `diffie_hellman_key_exchange(a: int, p: int) -> bool` that: - Verifies that `p` is a prime number. - Confirms that `a` is a primitive root of `p`. - Performs the Diffie-Hellman key exchange, generating and sharing keys between Alice and Bob, and ensuring they share the same secret key. # Input and Output - Input: Two integers `a` and `p` where `p` is a prime and `a` is a primitive root of `p`. - Output: A boolean indicating whether the exchange was successful and the shared key generated by both Alice and Bob is the same. # Constraints - `1 <= a < p <= 10^5` # Example ```python def is_prime(n: int) -> bool: # Your code here. def calculate_primitive_root(p: int) -> List[int]: # Your code here. def diffie_hellman_key_exchange(a: int, p: int) -> bool: # Your code here. # Example assert is_prime(23) == True assert calculate_primitive_root(23) == [5, 7, 10, 11, 14, 15, 17, 19, 20, 21] assert diffie_hellman_key_exchange(5, 23) == True ``` # Performance Requirements - Ensure that your implementation is efficient enough to handle the upper constraints within a reasonable time limit.","solution":"from typing import List import random def is_prime(n: int) -> bool: Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def calculate_primitive_root(p: int) -> List[int]: Finds all the primitive roots of a prime number p. if not is_prime(p): return [] def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(root, p): required_set = set(num for num in range(1, p) if gcd(num, p) == 1) result_set = set(pow(root, powers, p) for powers in range(1, p)) return required_set == result_set roots = [g for g in range(1, p) if is_primitive_root(g, p)] return roots def diffie_hellman_key_exchange(a: int, p: int) -> bool: Performs the Diffie-Hellman key exchange and returns True if it is successful. if not is_prime(p): return False if a not in calculate_primitive_root(p): return False # Alice and Bob choose private keys private_key_a = random.randint(1, p - 1) private_key_b = random.randint(1, p - 1) # Compute public keys public_key_A = pow(a, private_key_a, p) public_key_B = pow(a, private_key_b, p) # Compute shared secret keys shared_secret_key_A = pow(public_key_B, private_key_a, p) shared_secret_key_B = pow(public_key_A, private_key_b, p) return shared_secret_key_A == shared_secret_key_B"},{"question":"**Title**: Magic Number Detector with Additional Features Objective: Enhance the given Magic Number detection algorithm to handle additional features and provide more insights. Description: A \\"Magic Number\\" is defined as a number which, when repeatedly summing its digits, can be transformed into the digit 1. Your task is to implement an enhanced version of this algorithm which not only checks if the number is a \\"Magic Number\\" but also provides details on the number of iterations and the intermediate sums. Requirements: 1. Implement the function `enhanced_magic_number(n)` that: - Checks if `n` is a magic number. - Returns a tuple where: - The first element is a Boolean indicating whether `n` is a magic number. - The second element is the number of iterations taken to reach the single digit. - The third element is a list that includes all intermediate sums produced in each iteration. 2. Handle edge cases such as negative numbers and non-integer inputs with appropriate error handling. Function Signature: ```python def enhanced_magic_number(n: int) -> (bool, int, list): pass ``` Input: - `n`: An integer which might be positive, negative, or zero. (*Consider non-integer scenarios for robustness!*) Output: - A tuple `(is_magic: bool, iterations: int, sums: list)` - `is_magic`: A Boolean, True if `n` is a magic number, else False. - `iterations`: An integer, representing the number of digit summation steps. - `sums`: A list of integers, the intermediate sums in each step. Constraints: - Handle values of `n` within the range ([-10^9, 10^9]). Performance Requirement: - Aim to keep the algorithm efficient with minimal number of digit summation iterations. Example: ```python print(enhanced_magic_number(50113)) # Output: (True, 2, [10, 1]) print(enhanced_magic_number(1234)) # Output: (True, 2, [10, 1]) print(enhanced_magic_number(199)) # Output: (True, 3, [19, 10, 1]) print(enhanced_magic_number(111)) # Output: (False, 1, [3]) ``` **Notes**: - For negative numbers or non-digit strings, your function should return `(False, 0, [])`.","solution":"def enhanced_magic_number(n: int): Checks if a number is a magic number and returns details about the process. Parameters: n (int): The number to check. Returns: tuple: (is_magic: bool, iterations: int, sums: list) # Handle cases where n is not an integer or it\'s a negative number if not isinstance(n, int) or n < 0: return (False, 0, []) # Helper function to sum the digits of a number def sum_digits(num): return sum(int(digit) for digit in str(num)) sums = [] iterations = 0 while n >= 10: n = sum_digits(n) sums.append(n) iterations += 1 is_magic = (n == 1) return (is_magic, iterations, sums)"},{"question":"Scenario You are working on a data validation system and need to identify the missing identifier ranges within a given dataset. These identifiers are supposed to be in a sequential range but may have missing values. Create a function to find and report these missing ranges within the given dataset. Function Specification Implement the following function: ```python def find_missing_ranges(arr, lo, hi): This function takes a sorted list of integers arr, and two integers lo and hi. It returns a list of tuples representing the missing ranges between lo and hi inclusive. :param arr: List[int] - A sorted list of unique integers. :param lo: int - The lower boundary of the range. :param hi: int - The upper boundary of the range. :return: List[Tuple[int, int]] - A list of tuples where each tuple represents a missing range. Each tuple is (start, end) representing start and end of a missing range. ``` Input * `arr`: A sorted list of unique integers. * `lo`: An integer representing the lower limit of the range. * `hi`: An integer representing the upper limit of the range. Output * A list of tuples, where each tuple represents a missing range [start, end]. Constraints * The input list `arr` will always be sorted in ascending order. * `lo` <= `hi` is always true. Example ```python # Example 1: # arr = [3, 5] # lo = 1 # hi = 10 # Result: [(1, 2), (4, 4), (6, 10)] print(find_missing_ranges([3, 5], 1, 10)) # Example 2: # arr = [2, 3, 5, 7] # lo = 1 # hi = 9 # Result: [(1, 1), (4, 4), (6, 6), (8, 9)] print(find_missing_ranges([2, 3, 5, 7], 1, 9)) # Example 3: # arr = [] # lo = 1 # hi = 5 # Result: [(1, 5)] print(find_missing_ranges([], 1, 5)) # Example 4: # arr = [1, 2, 3, 4, 5] # lo = 1 # hi = 5 # Result: [] print(find_missing_ranges([1, 2, 3, 4, 5], 1, 5)) ``` Additional Notes: * You may assume arr contains no duplicate values. * Ensure your solution handles edge cases and provides correct results efficiently.","solution":"def find_missing_ranges(arr, lo, hi): This function takes a sorted list of integers arr, and two integers lo and hi. It returns a list of tuples representing the missing ranges between lo and hi inclusive. :param arr: List[int] - A sorted list of unique integers. :param lo: int - The lower boundary of the range. :param hi: int - The upper boundary of the range. :return: List[Tuple[int, int]] - A list of tuples where each tuple represents a missing range. Each tuple is (start, end) representing start and end of a missing range. if not arr: return [(lo, hi)] if lo <= hi else [] missing_ranges = [] previous = lo - 1 # Start just before the lower bound for number in arr: if number > previous + 1: missing_ranges.append((previous + 1, number - 1)) previous = number if previous < hi: missing_ranges.append((previous + 1, hi)) return missing_ranges"},{"question":"# Question: Implement a function to determine if a given number is a probable prime using the Rabin-Miller primality test. You must ensure your solution considers edge cases and optimizes the number of iterations (k) to balance execution time and accuracy. Function Signature: ```python def is_probable_prime(n: int, k: int) -> bool: pass ``` Input: * `n` (int): The number to test for primality. (n geq 1). * `k` (int): The number of iterations the test should run. (k geq 1). Output: * (bool): Returns `True` if `n` is a probable prime, otherwise returns `False`. Constraints: * You must handle edge cases like (n = 1, 2, 3) correctly. * Ensure performance does not degrade excessively for large values of `n`. Example: ```python print(is_probable_prime(17, 5)) # True print(is_probable_prime(18, 5)) # False print(is_probable_prime(101, 4)) # True ``` Notes: Validation for edge cases like (n < 5) is crucial. Enhance efficiency by implementing optimized techniques for modular exponentiation. Ensure the randomness in witness selection is uniform and appropriately bounded.","solution":"import random def is_probable_prime(n: int, k: int) -> bool: Determines if the number n is a probable prime using the Rabin-Miller primality test. Parameters: n (int): The number to test for primality. n >= 1. k (int): The number of iterations the test should run. k >= 1. Returns: bool: Returns True if n is a probable prime, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Find (r, d) such that n-1 = d * 2^r and d is odd r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"**Problem Statement:** Implement a function, `max_depth_and_average_value`, that solves the following: 1. It takes a binary tree and returns: - The maximum depth of that binary tree. - The average value of all nodes at the maximum depth. **Function Signature:** ```python def max_depth_and_average_value(root: TreeNode) -> Tuple[int, float]: :type root: TreeNode :rtype: Tuple[int, float] ``` **Input:** * `root` - A TreeNode representing the root of a binary tree. **Output:** * A tuple containing: * An integer representing the maximum depth of the binary tree. * A float representing the average value of all nodes at the maximum depth. **Constraints:** * The binary tree can have 0 to n nodes where `0 <= n <= 10^4`. * Node values are integers and can be negative. **Example:** ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Binary Tree Construction root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.left.right = TreeNode(100) root.left.right = TreeNode(30) root.right.left = TreeNode(36) # Function call depth, avg_val = max_depth_and_average_value(root) print(f\\"Max Depth: {depth}, Avg Value at Max Depth: {avg_val}\\") # Output should be Max Depth: 4, Avg Value: 100.0 ``` **Explanation:** - The tree has nodes with values 10, 12, 15, 25, 100, 30, and 36. - The maximum depth is 4, with values [100] at this depth. - The average value of nodes at depth 4 is 100.0. **Considerations:** * Pay attention to edge cases like an empty tree or single-node trees. * Aim for optimal run-time performance considering the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from typing import Tuple, List from collections import deque, defaultdict def max_depth_and_average_value(root: TreeNode) -> Tuple[int, float]: if not root: return (0, 0.0) queue = deque([(root, 1)]) # Queue stores tuples of node and its depth depth_values = defaultdict(list) while queue: node, depth = queue.popleft() depth_values[depth].append(node.val) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) max_depth = max(depth_values.keys()) avg_value = sum(depth_values[max_depth]) / len(depth_values[max_depth]) return (max_depth, avg_value)"},{"question":"# Flatten Nested Arrays Given a possibly nested list, implement a function to produce a single resulting flat list. Function Signature ```python def flatten_array(nested_array): # your code here ``` # Input - A list that may contain nested lists with various data types (integers, strings, or other iterables). - Example: `[1, [2, [3, 4], 5], [6, 7]]` # Output - A single flat list containing all elements in the order they appear from left to right in the original nested list. - Example: `[1, 2, 3, 4, 5, 6, 7]` # Constraints 1. Nested arrays can be arbitrarily deep. 2. The input list should not be modified. 3. Avoid exceeding the maximum recursion depth for deeply nested arrays. # Example ```python nested_list = [1, [2, [3, 4], 5], [6, 7]] print(flatten_array(nested_list)) # Output: [1, 2, 3, 4, 5, 6, 7] ``` Requirements - Your function should handle various edge cases, including: - Empty arrays. - Arrays with different data types. - Avoid mutating the original input. - Aim for a solution with a time complexity of O(n), where n is the total number of elements in all nested lists. - Space complexity should be optimized taking into account recursion depth.","solution":"def flatten_array(nested_array): Flatten a nested list into a single flat list. Parameters: nested_array (list): The possibly nested list. Returns: list: A single flat list containing all elements in the order they appear from left to right in the original nested list. result = [] def _flatten(current_array): for element in current_array: if isinstance(element, list): _flatten(element) else: result.append(element) _flatten(nested_array) return result"},{"question":"# Problem: Enhanced Comb Sort You are given an array of integers and need to sort it using an enhanced version of the Comb Sort algorithm. Your task is to modify the given Comb Sort algorithm so that it can handle the following additional requirements: 1. **Pre-check for Small Arrays**: If the array length is less than or equal to 5, perform a different sorting technique (e.g., Insertion Sort) for efficiency. 2. **Handling Duplicates**: Ensure that the algorithm doesn\'t make unnecessary comparisons for elements that are duplicates. 3. **Sorting Stability**: Modify the algorithm to preserve the relative order of equal elements. # Input * An array of integers `arr` with length `n`. # Output * A new array of integers sorted in ascending order. # Constraints * `1 <= n <= 10^4` * `-10^9 <= arr[i] <= 10^9` # Example ```plaintext Input: [23, -3, 4, 68, 34, 23, 93, 0] Output: [-3, 0, 4, 23, 23, 34, 68, 93] Input: [2, 3, 2, 3, 1, 1, 3] Output: [1, 1, 2, 2, 3, 3, 3] ``` # Instructions 1. Implement the function `enhanced_comb_sort(arr)` which sorts the array as described. 2. Avoid using built-in sort functions. 3. Prioritize both stability and efficiency improvements.","solution":"def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def enhanced_comb_sort(arr): n = len(arr) # Pre-check for small arrays if n <= 5: return insertion_sort(arr) # Initialize gap gap = n shrink_factor = 1.3 # Initialize swapped swapped = True while gap > 1 or swapped: # Update gap for next iteration gap = int(gap // shrink_factor) if gap < 1: gap = 1 # Reset swapped swapped = False # Compare elements with current gap for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Nearest Neighbor Algorithm with Constraints You are given a nearest neighbor algorithm that finds the closest vector to a given vector from a training set and returns the result associated with that vector. Your task is to implement this functionality as accurately and efficiently as possible. Problem Description: **Function Signature:** ```python def nearest_neighbor(x: Tuple[float], tSet: Dict[Tuple[float], Any]) -> Any: pass ``` **Input:** - `x`: A tuple representing the given vector. - `tSet`: A dictionary where keys are tuples representing vectors in the training set, and values are the results associated with each vector. **Output:** - The value associated with the closest vector in `tSet`. **Constraints:** - All vectors (including the input vector and the keys in the training set) will have the same dimension. - The training set will contain at least one vector. **Example:** ```python x = (1.0, 2.0) tSet = { (1.1, 2.1): \'A\', (3.0, 4.0): \'B\', (6.0, 7.0): \'C\' } print(nearest_neighbor(x, tSet)) # Output: \'A\' ``` Requirements: 1. **Time Complexity**: Ensure your solution is efficient and adheres to optimal use of time resources. 2. **Edge Case Handling**: Handle scenarios such as very close vectors effectively. 3. **Euclidean Distance Calculation**: Accurately calculate the Euclidean distance between vectors. Additional Notes: - Optimizations using advanced data structures or algorithmic improvements will be evaluated for bonus points.","solution":"from typing import Tuple, Dict, Any import math def euclidean_distance(a: Tuple[float], b: Tuple[float]) -> float: return math.sqrt(sum((x - y) ** 2 for x, y in zip(a, b))) def nearest_neighbor(x: Tuple[float], tSet: Dict[Tuple[float], Any]) -> Any: closest_vector = None min_distance = float(\'inf\') for vector, result in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance closest_vector = vector return tSet[closest_vector]"},{"question":"Permutations Generator You are tasked with implementing a function that generates all possible permutations of a given list of distinct integers. Your implementation should take into consideration the computational and memory efficiencies wherever possible. # Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` # Input * `nums` (a list of distinct integers). # Output * A list of lists, where each list is a permutation of the input list. # Constraints * The input list will have a maximum length of 10. # Performance Requirements Your implementation should be efficient in terms of time and space complexities, especially for the upper bound of the input length. # Example ```python generate_permutations([1, 2, 3]) ``` Output: ``` [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Scenario Consider a situation where you need to test all possible configurations of a three-element list for a puzzle-solving algorithm. The goal is to generate all permutations of the list to pass each to the puzzle solver. Your function needs to efficiently create these permutations.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generates all permutations of the given list of integers. if len(nums) == 0: return [[]] elif len(nums) == 1: return [nums] permutations = [] for i in range(len(nums)): current = nums[i] remaining = nums[:i] + nums[i+1:] for p in generate_permutations(remaining): permutations.append([current] + p) return permutations"},{"question":"# Problem Description Given a nested list of integers, your task is to implement a function called `custom_flatten` that returns a single flat list of all integers in their original order. # Function Signature ```python def custom_flatten(nested_list: List) -> List[int]: ``` # Input * `nested_list` (List): A list which may contain nested lists. The nesting level can be arbitrarily deep. # Output * List[int]: A single list of integers containing all the integers from `nested_list` in their original order. # Constraints * All elements in the list are either integers or lists. * The depth of nesting can be very large. Avoid hitting recursion depth limit in Python. * This flatten function needs to manage large nested structures efficiently. # Example ```python assert custom_flatten([1, [2, [3, 4], [5]], 6]) == [1, 2, 3, 4, 5, 6] assert custom_flatten([1, [2, 3], 4, [5, [6]]]) == [1, 2, 3, 4, 5, 6] assert custom_flatten([[[[]]], [], 1, 2]) == [1, 2] assert custom_flatten([]) == [] ``` # Notes - Do not use the built-in `flatten_iter` or `flatten` functions. Write your own implementation. - Handle cases with highly nested structures without hitting the recursion limit. - Optimize the solution to be as efficient as possible using iterative methods to mitigate recursive depth issues.","solution":"def custom_flatten(nested_list): Recursively flattens a nested list into a single flat list of integers. def flatten_helper(lst, result): for item in lst: if isinstance(item, list): flatten_helper(item, result) else: result.append(item) return result return flatten_helper(nested_list, [])"},{"question":"# Problem Summary: You need to implement a function that finds the shortest path in a weighted graph between two given nodes. Unlike the provided code snippets which handle unweighted graphs, you will need to account for varying path costs. # Detailed Description: Write a function `find_weighted_shortest_path(graph, start, end)` that takes in: - `graph`: A dictionary where keys are node identifiers (e.g., numbers or strings) and values are lists of tuples representing adjacent nodes along with edge weights (e.g., `{\'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': []}`). - `start`: The starting node identifier. - `end`: The target node identifier. Your task is to find and return the shortest path from `start` to `end` as a list of nodes along the path. If no path exists, return `None`. # Input: - `graph`: Dictionary of the graph with weights. - `start`, `end`: Wrting from start node to end node. # Output: - A list of nodes representing the shortest path from the start to the end, or `None` if no such path exists. # Constraints: - Assume all weights are non-negative. - The graph may contain cycles. - The number of nodes (V) and edges (E) is such that V + E <= 10^4. # Function Signature: ```python def find_weighted_shortest_path(graph, start, end) -> list: ``` # Example: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } shortest_path = find_weighted_shortest_path(graph, \'A\', \'D\') print(shortest_path) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` # Notes: - Recollecting that Dijkstra\'s algorithm is ideal for such scenarios might help. - Efficient utilization of priority queues (e.g., heapq) is recommended to achieve optimal performance. - Verify edge cases such as disconnected graphs, cycles, and where no possible path exists for robust function.","solution":"import heapq def find_weighted_shortest_path(graph, start, end): Finds the shortest path in a weighted graph from start to end. If no such path exists, returns None. # Priority Queue to keep track of distances to nodes pq = [(0, start, [start])] # (distance, current_node, path) # Dictionary to keep track of visited nodes and their minimum distance visited = {} while pq: (dist, current, path) = heapq.heappop(pq) if current in visited: continue visited[current] = dist # When we reach the end node, return the path if current == end: return path # Explore the neighbors for neighbor, weight in graph.get(current, []): if neighbor not in visited: heapq.heappush(pq, (dist + weight, neighbor, path + [neighbor])) # If the end node is never reached return None"},{"question":"# Encode and Decode Strings You are tasked with implementing functions to encode and decode a list of strings. The encoding should transform a list of strings into a single string, often used for transmitting over a network or storing compactly. This encoded string must be decoded perfectly back to the original list of strings. The encoded format will use a length prefix for each string followed by a delimiter `\\":\\"`. Specifications: 1. **Function 1: `encode(strs)`** **Input**: A list of strings. ```python def encode(strs: List[str]) -> str: ``` **Output**: A single encoded string which can be decoded back. 2. **Function 2: `decode(s)`** **Input**: A single encoded string. ```python def decode(s: str) -> List[str]: ``` **Output**: The original list of strings. 3. **Constraints**: - Strings may be empty. - Strings may contain any printable ASCII characters, including punctuation such as `\':\'`. 4. **Example**: ```python inp = [\\"Hello\\", \\"world\\", \\":at\\", \\"\\"] encoded = encode(inp) print(encoded) # Output: \\"5:Hello5:world3::at0:\\" decoded = decode(encoded) print(decoded) # Output: [\\"Hello\\", \\"world\\", \\":at\\", \\"\\"] ``` You are required to correctly handle edge cases and ensure that your implementation is robust and efficient.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s: str) -> List[str]: Decodes a single string to a list of strings. res = [] i = 0 while i < len(s): # find the position of the delimiter j = s.find(\':\', i) # get the length of the next string length = int(s[i:j]) # the start index of the actual string start = j + 1 # add the string to the result list res.append(s[start:start+length]) # move the index to the next position after the current string i = start + length return res"},{"question":"You are tasked with implementing an enhanced version of a hash table, which supports dynamic resizing and a more collision-resistant rehashing strategy. Your hash table should support the following operations: - `put(key, value)`: Insert or update a key-value pair. - `get(key)`: Retrieve the value associated with the given key. - `del_(key)`: Delete the associated key-value pair. **Constraints**: - Use open addressing for collision resolution. - Initially, the table should have a size of 11 and dynamically resize when 2/3 of the slots are filled. - Utilize quadratic probing for collision resolution. # Detailed Requirements 1. **Insertion (put)** - Hash the key to find the appropriate index. - If the slot is occupied but with a different key, use quadratic probing to find the next slot. - If the slot is deleted, you can override it. - If the load factor (filled slots / total slots) exceeds 2/3, resize the hash table to twice its current size and rehash all existing entries. 2. **Lookup (get)** - Hash the key and retrieve the value from the computed index. - If the slot contains a different key, use quadratic probing to find the required key. - If the key is not found, return `None`. 3. **Deletion (del_)** - Mark the slot with a deleted sentinel value if the key exists. - If the key is not found, do nothing. 4. **Resizing** - Upon resizing, all entries should be rehashed into the new table with double the current size. # Input - Methods will receive integers for keys and arbitrary Python objects for values. # Output - `put(key, value)`: No output. - `get(key)`: Return the value associated with the given key or `None` if the key does not exist. - `del_(key)`: No output. # Expected Methods ```python class EnhancedHashTable: def __init__(self): # Initialize the hash table with an initial size of 11. pass def put(self, key, value): # Insert or update the key-value pair. pass def get(self, key): # Retrieve the value associated with the key. pass def del_(self, key): # Delete the key-value pair. pass def __resize(self): # Resize the hash table when necessary. pass def hash(self, key): # Hash function to compute the index for a given key. pass def _rehash(self, old_hash, attempt): # Quadratic probing function for collision resolution. pass ``` # Example ```python table = EnhancedHashTable() table.put(1, \\"one\\") table.put(12, \\"twelve\\") print(table.get(1)) # Output: \\"one\\" table.del_(1) print(table.get(1)) # Output: None ``` **Note**: Implement the `EnhancedHashTable` class to fulfill the above requirements.","solution":"class EnhancedHashTable: def __init__(self): self.initial_size = 11 self.size = self.initial_size self.table = [None] * self.size self.count = 0 self.deleted = \\"<deleted>\\" def hash(self, key): return key % self.size def _rehash(self, old_hash, attempt): return (old_hash + attempt**2) % self.size def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item and item != self.deleted: self.put(item[0], item[1]) def put(self, key, value): if self.count / self.size >= 2 / 3: self.__resize() index = self.hash(key) attempt = 0 while self.table[index] is not None and self.table[index] != self.deleted and self.table[index][0] != key: attempt += 1 index = self._rehash(index, attempt) if self.table[index] is None or self.table[index] == self.deleted: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self.hash(key) attempt = 0 while self.table[index] is not None: if self.table[index][0] == key and self.table[index] != self.deleted: return self.table[index][1] attempt += 1 index = self._rehash(index, attempt) return None def del_(self, key): index = self.hash(key) attempt = 0 while self.table[index] is not None: if self.table[index][0] == key and self.table[index] != self.deleted: self.table[index] = self.deleted self.count -= 1 return attempt += 1 index = self._rehash(index, attempt) # Example usage # table = EnhancedHashTable() # table.put(1, \\"one\\") # table.put(12, \\"twelve\\") # print(table.get(1)) # Output: \\"one\\" # table.del_(1) # print(table.get(1)) # Output: None"},{"question":"# Question: Objective: Implement a class `BSTIterator` that sequentially returns the next smallest element in a Binary Search Tree (BST) when the `next` method is called. Requirements: * __Initializer__ (`__init__`): * Input: `root` - the root node of a Binary Search Tree. * Initialize the iterator to the start of an in-order traversal. * __Methods__: 1. `has_next()`: * Output: `True` if there is the next smallest number. Otherwise, return `False`. 2. `next()`: * Output: Return the next smallest number in the BST. Input and Output: * `__init__(root)`: Takes a `TreeNode` as the input. * `has_next()`: Returns a boolean value. * `next()`: Returns an integer representing the next smallest element in the BST. Constraints: * All TreeNode values are unique. * There can be at most 10000 calls to `next` and `has_next` together. * It is guaranteed that `next` will always be called if `has_next` returns `True`. Below is the `TreeNode` definition for your reference: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: ```python # Example: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) iterator.next() # returns 3 iterator.next() # returns 7 iterator.has_next() # returns True iterator.next() # returns 9 iterator.has_next() # returns True iterator.next() # returns 15 iterator.has_next() # returns True iterator.next() # returns 20 iterator.has_next() # returns False ``` Implement the `BSTIterator` class with the above specifications and behavior.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): Initialize the iterator to the start of an in-order traversal. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to push all the leftmost nodes of the tree to the stack while root is not None: self.stack.append(root) root = root.left def next(self): Returns the next smallest number in the BST topmost_node = self.stack.pop() # The topmost element of the stack is the current smallest if topmost_node.right is not None: self._leftmost_inorder(topmost_node.right) # Process the right subtree return topmost_node.val def has_next(self): Return whether there is a next smallest number return len(self.stack) > 0"},{"question":"# Merge Sort Implementation Question You have been assigned a task to implement the Merge Sort algorithm. Merge Sort is a classic divide-and-conquer algorithm that is efficient and guarantees a time complexity of O(n log(n)) for sorting an array of elements. Your task is to implement the `merge_sort` function which takes an array of integers and returns the array sorted in non-decreasing order. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - An array of integers `arr` with 1 <= len(arr) <= 10^6 and -10^9 <= arr[i] <= 10^9. # Output - The array `arr` sorted in non-decreasing order. # Requirements 1. Ensure the function is implemented using the merge sort algorithm. 2. Your implementation should follow the divide-and-conquer strategy. 3. Handle edge cases such as empty arrays, arrays with one element, and arrays with duplicate elements. 4. Optimize for performance and consider space complexity, ensuring that the function can handle the upper constraint efficiently. # Example ```python assert merge_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert merge_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert merge_sort([1]) == [1] assert merge_sort([]) == [] assert merge_sort([2, 3, 2, 3, 1]) == [1, 2, 2, 3, 3] ``` # Constraints - You should use only the Python standard libraries. - Consider both time and space efficiency in your solution. - You cannot use built-in sorting functions like `sorted()`.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. merged_arr = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged_arr.append(left[left_index]) left_index += 1 else: merged_arr.append(right[right_index]) right_index += 1 # Add remaining elements from left or right list if any merged_arr.extend(left[left_index:]) merged_arr.extend(right[right_index:]) return merged_arr"},{"question":"You are given an n-ary tree (a tree where each node can have zero or more children). An n-ary tree can be represented using a dictionary where keys are node values and values are lists of children node values. Write two functions to perform tree traversal: 1. `dfs_traverse_tree(tree, start)` - Perform depth-first search (DFS) traversal on the tree starting from the node with the value `start` and return the order in which nodes are visited. 2. `bfs_traverse_tree(tree, start)` - Perform breadth-first search (BFS) traversal on the tree starting from the node with the value `start` and return the order in which nodes are visited. # Input Format - `tree`: A dictionary representing the n-ary tree. Keys are node values, and values are lists of children node values. - `start`: An integer representing the starting node value for the traversal. # Output Format - Return a list of integers representing the order in which nodes are visited during the traversal for both functions. # Constraints - Assume all node values are unique. - `start` is guaranteed to be in the tree. - The tree will have at least one node and at most 10^4 nodes. - The maximum depth of the tree will not exceed 10^3. # Example ```python tree = { 1: [2, 3, 4], 2: [5, 6], 3: [], 4: [7, 8], 5: [], 6: [], 7: [], 8: [] } start = 1 # DFS Traversal: [1, 4, 8, 7, 3, 2, 6, 5] # BFS Traversal: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Implementation Function 1: `dfs_traverse_tree` Implement depth-first search traversal. Function 2: `bfs_traverse_tree` Implement breadth-first search traversal.","solution":"def dfs_traverse_tree(tree, start): Perform depth-first search (DFS) traversal on the tree starting from the node with the value `start`. Returns the order in which nodes are visited. def dfs(node, visited): visited.append(node) for child in tree.get(node, []): dfs(child, visited) visited = [] dfs(start, visited) return visited def bfs_traverse_tree(tree, start): Perform breadth-first search (BFS) traversal on the tree starting from the node with the value `start`. Returns the order in which nodes are visited. visited = [] queue = [start] while queue: current = queue.pop(0) visited.append(current) for child in tree.get(current, []): queue.append(child) return visited"},{"question":"You are given a one-dimensional array of integers representing daily temperatures. Some days might have higher temperatures and some lower, even negative values. Your task is to write a function `max_temperature_rise(array)` that computes the maximum sum of a contiguous subarray, which signifies the largest rise in temperature over a continuous sequence of days. Function Signature ```python def max_temperature_rise(array: List[int]) -> int: pass ``` Input * `array` (List[int]): A list of integers where `1 <= len(array) <= 10^5` and `-10^4 <= array[i] <= 10^4`. Output * Return an integer representing the maximum sum of a contiguous subarray. Constraints * If all numbers in the array are negative, the function should still return the maximum element. Example ```python array = [1, -2, 3, 5, -1, 2] print(max_temperature_rise(array)) # Output: 9 array = [-3, -2, -5, -1] print(max_temperature_rise(array)) # Output: -1 ``` Explanation * For the first example, the subarray `[3, 5, -1, 2]` yields the maximum sum 9. * For the second example, since all elements are negative, the maximum single element `-1` is the result.","solution":"from typing import List def max_temperature_rise(array: List[int]) -> int: This function finds the maximum sum of a contiguous subarray using Kadane\'s Algorithm. max_current = max_global = array[0] for i in range(1, len(array)): max_current = max(array[i], max_current + array[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"Scenario You are working in a text processing team that deals with string manipulations frequently. One of the common tasks is identifying differences between two versions of strings, especially when an additional character is added to the original string. You are tasked with implementing a function to automate this difference detection. Problem Given two strings `s` and `t` which consist of only lowercase letters. String `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Write a function to find the letter that was added in `t`. # Function Signature ```python def find_the_difference(s: str, t: str) -> str: pass ``` # Input - `s`: A string containing n lowercase letters. - `t`: A string containing n+1 lowercase letters. # Output - A single character which is the extra letter added to string `t`. # Constraints - 0 ≤ len(s) ≤ 10^4 - `t` is generated by random shuffling string `s` and then adding one more letter at a random position. # Performance Requirements - The solution should be time efficient with a complexity of O(n). - The solution should use constant space, O(1). # Example ```python s = \\"abcd\\" t = \\"abecd\\" find_the_difference(s, t) # Should return \'e\' ``` Notes You must consider all character values, and assume the input strings always adhere to the constraints.","solution":"def find_the_difference(s: str, t: str) -> str: Given two strings `s` and `t` which consist of lowercase letters only, and `t` is generated by random shuffling string `s` and then adding one more letter at a random position, return the letter that was added. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"# RSA Encryption and Decryption Implementation (Advanced) You are required to implement the RSA encryption algorithm for a secure communication system. Your task is to provide functions for generating RSA keys, encrypting messages, and decrypting messages, demonstrating a thorough understanding of RSA principles and considerations. Specifications: 1. **Key Generation Function**: - **Function Name**: `generate_key` - **Inputs**: - `k` (integer): The number of bits in `n`. - `seed` (integer, optional): Seed for random prime generation (useful for testing). - **Outputs**: - Tuple `(n, e, d)` where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. 2. **Encryption Function**: - **Function Name**: `encrypt` - **Inputs**: - `data` (integer): Plaintext message to be encrypted. - `e` (integer): Public exponent. - `n` (integer): Modulus. - **Output**: - Encrypted message as an integer. 3. **Decryption Function**: - **Function Name**: `decrypt` - **Inputs**: - `data` (integer): Encrypted message (ciphertext). - `d` (integer): Private exponent. - `n` (integer): Modulus. - **Output**: - Decrypted message as an integer. Constraints: - Ensure that the generated primes (p) and (q) are distinct and not easily factorable. - Handle any possible edge cases such as failed prime generation. - Optimize your solution\'s performance where possible. Performance Requirements: - Aim to keep key generation within reasonable computation time (up to a few seconds for 1024-bit keys). - Ensure efficient and accurate encryption and decryption operations. Example Usage: ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Provide your detailed implementation ensuring clarity and correctness. Comment on any assumptions or decisions made during the development process.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits): while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate def generate_key(k, seed=None): if seed is not None: random.seed(seed) p = generate_prime(k // 2) q = generate_prime(k // 2) while p == q: q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Common value for e d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"Given the task of implementing a function that checks if a given 32-bit integer `num` is a power of two. A number is a power of two if and only if there is exactly one \'1\' bit in its binary representation. Using the bit manipulation operations provided (`get_bit`, `set_bit`, `clear_bit`, `update_bit`), implement the function `is_power_of_two(num)` that determines whether the given integer is a power of two. # Function Signature ```python def is_power_of_two(num: int) -> bool: ``` # Input * `num`: An integer (32-bit signed integer). # Output * Return `True` if `num` is a power of two, otherwise return `False`. # Constraints 1. -2<sup>31</sup> <= `num` < 2<sup>31</sup> (inclusive). 2. Avoid using Python\'s built-in functions to determine the number of set bits directly. # Example ```python assert is_power_of_two(1) == True # 1 (2^0) is a power of two assert is_power_of_two(16) == True # 16 (2^4) is a power of two assert is_power_of_two(218) == False # 218 is not a power of two assert is_power_of_two(0) == False # 0 is not a power of two, by definition assert is_power_of_two(-8) == False # Negative numbers cannot be powers of two ``` # Description The student must leverage the provided bit manipulation functions to implement the solution. The solution must correctly handle negative numbers and edge cases such as zero. # Additional Information This problem assesses understanding of: * Bitwise operations and manipulation. * Logical problem-solving ability. * Algorithm design and edge case handling.","solution":"def is_power_of_two(num: int) -> bool: Determines if the given 32-bit integer is a power of two. # Edge cases for negative numbers and zero if num <= 0: return False # Using bit manipulation to determine if `num` is a power of two. # A number is a power of two if exactly one bit is set in its binary representation. return (num & (num - 1)) == 0"},{"question":"# Coding Challenge: Hamming Weight Calculation Context: In computer science, the Hamming weight of a binary string is the number of symbols that are different from the zero-symbol of the alphabet used. A common problem involves determining the number of 1 bits in the binary representation of an unsigned integer. Task: Write a function that takes an unsigned integer and returns the number of \'1\' bits it has (also known as the Hamming weight). Your solution should be efficient and should not rely on built-in functions that directly compute the population count or Hamming weight. Function Signature: ```python def hamming_weight(n: int) -> int: pass ``` Input: * `n` (0 <= n <= 2^32 - 1): a non-negative integer representing the number to be analyzed. Output: * Return an integer indicating the number of \'1\' bits in the binary representation of `n`. Examples: ```python # Example 1: input: n = 11 output: 3 Explanation: The binary representation of 11 is 00000000000000000000000000001011, which has three \'1\' bits. # Example 2: input: n = 128 output: 1 Explanation: The binary representation of 128 is 00000000000000000000000010000000, which has one \'1\' bit. # Example 3: input: n = 0 output: 0 Explanation: The binary representation of 0 is 00000000000000000000000000000000, which has zero \'1\' bits. ``` Constraints: * You may use either a recursive or iterative approach, but ensure the solution is efficient. * Handle edge cases such as the input being 0. * Aim for a time complexity of O(k), where k is the number of 1 bits in the binary representation of the input integer.","solution":"def hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given unsigned integer `n`. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"# Linked List Intersection Detection Problem Statement You are given two singly linked lists. Write a function that identifies the intersection node, i.e., the node at which the two lists merge. If there is no intersection, return `None`. Function Signature ```python def find_intersection(head1: Node, head2: Node) -> Node: pass ``` Input - `head1` and `head2`: The head nodes of the two singly linked lists. Output - The intersecting node (a `Node` object) or `None` if there is no intersection. Constraints - The number of nodes in each list ranges from 0 to 10^4. - The values in the nodes do not matter for determining the intersection; the intersection is defined by node reference. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None # List 1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # List 2: 2 -> 4 -> 6 node1 = Node(1) node3 = Node(3) node5 = Node(5) node7 = Node(7) node2 = Node(2) node4 = Node(4) node6 = Node(6) node9 = Node(9) node11 = Node(11) node1.next = node3 node3.next = node5 node5.next = node7 node7.next = node9 node9.next = node11 node2.next = node4 node4.next = node6 node6.next = node7 print(find_intersection(node1, node2).val) # Output: 7 ``` # Instructions 1. Traverse both linked lists to determine their lengths. 2. Compute the length difference and adjust starting points. 3. Traverse both lists concurrently to identify the intersection node. 4. Handle edge cases where one or both lists may be empty, or lists do not intersect.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: # Helper function to get the length of a linked list def get_length(head): length = 0 current = head while current is not None: length += 1 current = current.next return length # Get the lengths of both linked lists len1 = get_length(head1) len2 = get_length(head2) # Adjust starting points for both linked lists to be at the same position from the end current1 = head1 current2 = head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next elif len2 > len1: for _ in range(len2 - len1): current2 = current2.next # Traverse both linked lists together to find the intersection while current1 is not None and current2 is not None: if current1 == current2: return current1 current1 = current1.next current2 = current2.next # Return None if no intersection is found return None"},{"question":"# Next Permutation Coding Challenge In this coding challenge, you are required to write a Python function that computes the next higher number permutation for a given input number. The next permutation should use the same set of digits as the original number, and should adhere to the lexicographical order of permutations. # Requirements - **Function Name**: `next_bigger` - **Input**: A single integer `num`, where (0 leq num < 10^{18}). - **Output**: The next higher number consisting of the same digits as the input number. If no such number exists, return `-1`. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Constraints 1. If the input number has only one digit, the output should be `-1` (since there are no possible permutations). 2. If the input number is the largest possible permutation of its digits, the output should be `-1`. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(54321) == -1 assert next_bigger(5) == -1 assert next_bigger(12354) == 12435 ``` # Guidelines 1. Convert the number into a list of its digits. 2. Identify the point where the digits stop increasing from right to left. 3. Find the smallest digit on the right of this point which is larger than the identified digit. 4. Swap these two digits. 5. Reverse the sequence of digits to the right of the first identified point. 6. Convert the list of digits back to an integer and return it. # Edge Cases to Consider - All digits are identical. - The digits are in descending order. - Single digit numbers. Please ensure your code is well-documented and passes the provided test cases to guarantee accuracy and robustness.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) length = len(digits) if length == 1: return -1 # Step 1: Find the largest index \'i\' such that digits[i] < digits[i+1] i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such index exists, return -1 (digits are sorted in descending order) if i == -1: return -1 # Step 2: Find the largest index \'j\' such that digits[i] < digits[j] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the values at indices i and j digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from i+1 to the end of the list digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert back to integer next_perm = int(\\"\\".join(digits)) return next_perm"},{"question":"Context You are a software developer for a custom keyboard manufacturer. Your task is to create a function that checks which words from a list can be typed using letters from only one row of an American keyboard. This feature is to assist with product usability studies. Task Implement the function `find_keyboard_row` that takes a list of words and returns a list of words that can be typed using letters from only one row of the keyboard. # Input - `words`: A list of strings, where each string represents a word (1 ≤ words.length ≤ 100). Words consist of English letters (1 ≤ word.length ≤ 12). # Output - A list containing the words that can be typed using letters from a single row of a keyboard. # Constraints - Words should be case insensitive. - Only consider letters in evaluating whether a word can be typed using a single row. # Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Requirements - Do not use any in-built functions to check row membership directly. - Ensure the function is optimized for performance as it might be used in real-time typing analysis. ```python def find_keyboard_row(words): :type words: List[str] :rtype: List[str] keyboard = [ set(\'qwertyuiop\'), set(\'asdfghjkl\'), set(\'zxcvbnm\'), ] result = [] for word in words: for key in keyboard: if set(word.lower()).issubset(key): result.append(word) return result ```","solution":"def find_keyboard_row(words): Takes a list of words and returns a list of words that can be typed using letters from only one row of an American keyboard. :param words: List[str] :rtype: List[str] # Define each row of the keyboard row1 = set(\'qwertyuiop\') row2 = set(\'asdfghjkl\') row3 = set(\'zxcvbnm\') # Store words that can be typed using one keyboard row result = [] # Iterate through each word in the list for word in words: # Convert word to lowercase for case insensitivity lower_word = set(word.lower()) # Check if the word can be typed with only letters from one row if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"Objective Your task is to implement a function that finds the minimum and maximum values in a Red-Black Tree. You are provided with the Red-Black Tree structure, and you need to add methods to find and return the minimum and maximum elements in the tree. Description Implement two methods `find_minimum` and `find_maximum` in the `RBTree` class which will return the minimum and maximum values stored in the tree, respectively. Requirements 1. `find_minimum` should return the node with the smallest value in the Red-Black Tree. 2. `find_maximum` should return the node with the largest value in the Red-Black Tree. 3. Both methods should handle the tree being empty properly by returning `None`. Expected Function Signatures ```python class RBTree: # existing methods... def find_minimum(self): Returns the node with the smallest value. pass def find_maximum(self): Returns the node with the largest value. pass ``` Constraints * The provided Red-Black Tree may contain any number of nodes (including zero). * Node values are unique integers. Example ```python if __name__ == \\"__main__\\": rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values: rb.insert(RBNode(value, 1)) min_node = rb.find_minimum() max_node = rb.find_maximum() if min_node: print(f\\"The minimum value in the tree is: {min_node.val}\\") else: print(\\"The tree is empty.\\") if max_node: print(f\\"The maximum value in the tree is: {max_node.val}\\") else: print(\\"The tree is empty.\\") ``` Expected Output: ``` The minimum value in the tree is: 1 The maximum value in the tree is: 15 ``` Additional Information * Carefully handle edge cases where the tree is empty. * Ensure the methods run in O(log n) time complexity.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) # TNULL represents the null leaf node self.root = self.TNULL def insert(self, key): node = key node.left = self.TNULL node.right = self.TNULL node.parent = None if self.root == self.TNULL: node.color = 0 self.root = node else: current = self.root while True: if node.val < current.val: if current.left == self.TNULL: current.left = node node.parent = current break current = current.left else: if current.right == self.TNULL: current.right = node node.parent = current break current = current.right node.color = 1 # Red def find_minimum(self): current = self.root if current == self.TNULL: return None while current.left != self.TNULL: current = current.left return current def find_maximum(self): current = self.root if current == self.TNULL: return None while current.right != self.TNULL: current = current.right return current"},{"question":"Problem Description You need to implement a `ZigZagIterator` that iterates through two lists of integers and outputs their elements in a zigzag (alternating) order. Specifically, if given two vectors [1, 2] and [3, 4, 5, 6], it should return [1, 3, 2, 4, 5, 6]. Function Signature ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize the data structure with two lists. pass def next(self) -> int: Return the next element in zigzag order. pass def has_next(self) -> bool: Return True if there is another element in the ZigZag order, False otherwise. pass ``` Input and Output Formats * The class will be initialized with two integer lists `v1` and `v2`. * `next()` method will return an integer, the next element in zigzag order. * `has_next()` method will return `True` if there are more elements to iterate, `False` otherwise. Constraints * Both lists may contain between 0 and 1000 elements. * List elements will be integers from `-1000` to `1000`. * You are not allowed to use any Python built-in iterators such as `itertools`. * Performance should be considered; the solution must efficiently handle lists with up to 1000 elements each. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ```","solution":"class ZigZagIterator: def __init__(self, v1, v2): Initialize the data structure with two lists. self.lists = [v1, v2] self.queue = [(0, 0), (1, 0)] # (list_index, element_index) def next(self): Return the next element in zigzag order. if self.has_next(): list_idx, elem_idx = self.queue.pop(0) result = self.lists[list_idx][elem_idx] if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return result def has_next(self): Return True if there is another element in the ZigZag order, False otherwise. while self.queue and self.queue[0][1] >= len(self.lists[self.queue[0][0]]): self.queue.pop(0) return len(self.queue) > 0"},{"question":"Scenario: In a system where logs are maintained as an array of integers, every integer appears exactly twice except for one integer that appears exactly once. It is essential to identify this single integer for debugging purposes. Task: Implement a function to solve this problem efficiently. Function Signature: ```python def single_number(nums: List[int]) -> int: pass ``` Input: * A list of integers `nums` where: * Each integer appears exactly twice except for one integer. * The list is guaranteed to have at least one element (the single unique integer). Output: * Return the single integer that appears only once. Constraints: * The solution should operate in O(n) time complexity. * The solution should use O(1) additional space. Examples: ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 ``` Notes: * Ensure the function handles arrays with any number of integers meeting the given constraints. * Think about how utilizing the XOR operator can help achieve the requirements effectively and meeting the performance constraints.","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single integer in the list that appears exactly once. All other integers appear exactly twice. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"# Next Lexicographical Permutation **Problem Statement**: You are given a non-negative integer `number`. Your task is to write a function `next_higher_number(number)` that returns the next higher number that can be formed using the exact same set of digits. If no such number exists, return -1. **Function Signature**: ```python def next_higher_number(number: int) -> int: ``` **Input**: * A non-negative integer `number` where `0 <= number <= 10^9`. **Output**: * Return the next higher number made up of the same digits of `number`. If no such number exists, return -1. **Example**: ```python assert next_higher_number(38276) == 38627 assert next_higher_number(12345) == 12354 assert next_higher_number(99999) == -1 assert next_higher_number(54321) == -1 assert next_higher_number(5) == -1 ``` **Constraints**: * The function should have a runtime complexity of O(n), where n is the number of digits in `number`. * You can assume the input number fits within the standard integer range. **Explanation**: * For 38276, the next permutation using the same digits is 38627. * For 12345, the next permutation using the same digits is 12354. * For 99999, there is no such permutation possible, hence return -1. * For 54321, there is no higher permutation, hence return -1. * For single-digit numbers like 5, return -1 as no higher permutation exists. Implement this function considering all possible edge cases and ensuring not to use any external libraries or methods outside standard Python functionality.","solution":"def next_higher_number(number: int) -> int: digits = list(str(number)) n = len(digits) # Step 1: find the first decreasing element from the end i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no decreasing element is found, return -1 if i == -1: return -1 # Step 2: find the smallest element on the right of \'i\' that is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the elements at \'i\' and \'j\' digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the segment after index \'i\' digits = digits[:i+1] + digits[i+1:][::-1] return int(\'\'.join(digits))"},{"question":"**Context**: You are working on data analysis for customer reviews. To understand customer preferences, you need to find out which products are mentioned most frequently in an array of product IDs. However, reviews might have multiple most frequently mentioned products (modes). **Question**: Implement a function `find_modes` that receives an array of integers (product IDs) and returns a list of integers representing the mode(s) of the array. The mode is the value that appears most frequently in the array. If there are multiple values with the same highest frequency, return all such values. # Function Signature ```python def find_modes(arr: list[int]) -> list[int]: ``` # Input * `arr` - A list of integers (0 <= len(arr) <= 10^5, 0 <= arr[i] <= 10^5) # Output * A list of integers representing the mode(s) of the input array. If the array is empty, return an empty list. # Constraints * Your function should run in linear time, O(n). * Your function should use no more than O(n) additional space. # Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 4, 4, 4, 4, 4]) == [4] assert find_modes([]) == [] assert find_modes([7, 7, 8, 8, 9, 10, 10, 10]) == [10] ``` # Notes * Make sure to handle edge cases such as empty arrays or arrays where all elements are unique. * Consider cases where multiple modes exist - the function should include all.","solution":"from collections import Counter def find_modes(arr): Returns the mode(s) of the input array. The mode is the value that appears most frequently in the array. If there are multiple values with the same highest frequency, all such values are returned. if not arr: return [] counter = Counter(arr) max_freq = max(counter.values()) modes = [key for key, value in counter.items() if value == max_freq] return modes"},{"question":"# Prime Factorization Problem **Context**: You are working on enhancing a security feature that requires finding the prime factorization of numbers efficiently. Prime factorization is the process of determining which prime numbers multiply together to create the original number. **Problem**: Given a positive integer ( n ), write a function `prime_factors(n)` that returns a list of its prime factors. # Function Signature ```python def prime_factors(n: int) -> List[int]: ``` # Input * **n (int)**: A positive integer ( n ) where ( 1 leq n leq 10^9 ). # Output * Returns a list of integers representing the prime factors of ( n ). # Constraints * Your solution should efficiently handle large values of ( n ) up to ( 10^9 ). * Consider the edge case where ( n ) is a prime itself. # Example ```python assert prime_factors(28) == [2, 2, 7] assert prime_factors(13) == [13] assert prime_factors(50) == [2, 5, 5] assert prime_factors(1) == [] ``` The result should consist of the prime factors in ascending order, with multiplicity (each prime factor appears as many times as it divides ( n )). # Performance Requirements * Space Complexity: ( O(1) ). * Time Complexity: ( O(sqrt{n}) ). **Hint**: Use the provided prime checking function as a utility to aid your solution and include similar optimizations.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of prime factors of the given number n. factors = [] # Handle the smallest prime number which is 2 while n % 2 == 0: factors.append(2) n //= 2 # Handle all odd factors from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still greater than 2, then it is a prime number if n > 2: factors.append(n) return factors"},{"question":"# Question: You are tasked with implementing a sorting algorithm suitable for parallel execution environments. The algorithm of interest is **Bitonic Sort**, which is efficient for input sizes that are powers of two. The task is to sort a given list in either ascending or descending order using the Bitonic Sort algorithm. # Requirements: 1. Implement the Bitonic Sort algorithm to sort a list of integers. 2. Ensure that the algorithm can sort in both ascending and descending orders based on a parameter. 3. Your implementation should raise a `ValueError` if the size of the input list is not a power of two. # Function Signature: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input: * `arr`: A list of integers to be sorted. The length of this list will always be a power of two. * `reverse`: A boolean indicating the sorting order. `False` means ascending order, and `True` means descending order. Optional and defaults to `False`. # Output: * A list of integers sorted in the specified order. # Constraints: * The list provided will always have a length that is a power of two. * Constraints on the elements of the list: `-10^9 <= arr[i] <= 10^9` # Example: ```python bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5]) -> [1, 2, 3, 4, 5, 6, 7, 8] bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) -> [8, 7, 6, 5, 4, 3, 2, 1] ``` # Implementation Note: In your implementation, create helper functions for `compare` and `bitonic_merge` as detailed in the analysis. Ensure that the solution does not use any parallelism; focus on a single-threaded approach.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: # Check if length of input list is a power of two if not (len(arr) != 0 and ((len(arr) & (len(arr) - 1)) == 0)): raise ValueError(\\"Size of input list must be a power of two.\\") def compare_and_swap(s: List[int], i: int, j: int, direction: bool): if (direction == (s[i] > s[j])): s[i], s[j] = s[j], s[i] def bitonic_merge(s: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(s, i, i + k, direction) bitonic_merge(s, low, k, direction) bitonic_merge(s, low + k, k, direction) def bitonic_sort_rec(s: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_rec(s, low, k, True) # sort in ascending order bitonic_sort_rec(s, low + k, k, False) # sort in descending order bitonic_merge(s, low, cnt, direction) result = arr.copy() bitonic_sort_rec(result, 0, len(result), not reverse) return result"},{"question":"You are tasked with implementing the Bitonic Sort algorithm. This algorithm sorts using a divide-and-conquer approach and is notably efficient when parallelism is leveraged. Although in your implementation, you will not use parallel processing, the core principles of the Bitonic Sort must be retained. The Bitonic Sort should handle sorting numbers in both increasing and decreasing orders, depending on a provided flag. # Input and Output * **Input**: - A list (arr) of integers where the size of (arr) is a power of two. - A boolean (reverse) indicating the order of sorting (True for ascending, False for descending). * **Output**: - A sorted list of integers, sorted based on the (reverse) flag setting. # Constraints * The length of (arr) will always be a power of two. * The length of (arr) will be at least 2 and no greater than (2^{10}). # Examples ```python # Example 1 arr = [3, 7, 2, 8, 1, 5, 4, 6] reverse = False # Expected Output: [8, 7, 6, 5, 4, 3, 2, 1] # Example 2 arr = [4, 3, 2, 1] reverse = True # Expected Output: [1, 2, 3, 4] ``` # Additional Information * Implement the function `bitonic_sort(arr, reverse)`. * Ensure that arrays which are not of the expected length raise a `ValueError`. * Your algorithm should use a divide-and-conquer approach to split and merge the array recursively. ```python def bitonic_sort(arr, reverse=False): # Your code here ``` # Guidance - Consider and handle edge cases such as single-element arrays. - Utilize recursion to breakdown the sorting and merging processes. - Carefully merge the bitonic sequences considering the (reverse) flag.","solution":"def bitonic_compare(arr, start, end, direction): length = end - start mid = length // 2 for i in range(start, start + mid): if (direction and arr[i] > arr[i + mid]) or (not direction and arr[i] < arr[i + mid]): arr[i], arr[i + mid] = arr[i + mid], arr[i] def bitonic_merge(arr, start, end, direction): length = end - start if length > 1: bitonic_compare(arr, start, end, direction) mid = length // 2 bitonic_merge(arr, start, start + mid, direction) bitonic_merge(arr, start + mid, end, direction) def bitonic_sort_recursive(arr, start, end, direction): length = end - start if length > 1: mid = length // 2 bitonic_sort_recursive(arr, start, start + mid, True) # Sort in ascending order bitonic_sort_recursive(arr, start + mid, end, False) # Sort in descending order bitonic_merge(arr, start, end, direction) def bitonic_sort(arr, reverse=False): if len(arr) & (len(arr) - 1) != 0: raise ValueError(\\"The length of the array must be a power of two.\\") bitonic_sort_recursive(arr, 0, len(arr), reverse) return arr"},{"question":"Context: In data validation and string processing, ensuring that a given string reads the same forwards and backwards is a common requirement. This property makes the string a palindrome. Ignoring cases and non-alphanumeric characters is crucial to standardize the checking process. You are asked to implement a function that verifies if a given string is a palindrome based on the aforementioned conditions. Task: You need to design and implement a function called `is_palindrome_optimized` that determines if the provided string is a palindrome. Your function should be efficient in both time and space. # Function Signature ```python def is_palindrome_optimized(s: str) -> bool: pass ``` # Input * A single string `s` (0 <= len(s) <= 10^5). # Output * A boolean value `True` if the given string is a palindrome, `False` otherwise. # Constraints * The string can be empty, and the function should handle it correctly. * Consider only alphanumeric characters and ignore case. # Requirements * **Time Complexity**: The implementation should run in O(n) time. * **Space Complexity**: Try to achieve O(1) additional space complexity (excluding the input string). # Examples 1. `is_palindrome_optimized(\\"A man, a plan, a canal: Panama\\") -> True` 2. `is_palindrome_optimized(\\"race a car\\") -> False` 3. `is_palindrome_optimized(\\"\\") -> True` 4. `is_palindrome_optimized(\\"No lemon, no melon\\") -> True` Use the provided function signature and ensure your solution is well-commented to explain the logic used.","solution":"def is_palindrome_optimized(s: str) -> bool: Determines whether a given string is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"You are given an undirected graph represented by an adjacency list. Your task is to write a function `count_connected_components(graph: Dict[int, List[int]]) -> int` that returns the number of connected components in the graph. # Input Format * `graph`: A dictionary where keys are integer nodes and values are lists of nodes directly connected to the key node. # Output Format * An integer representing the number of connected components in the given graph. # Constraints * 1 ≤ number of nodes ≤ 10^5 * 0 ≤ number of edges ≤ 10^5 # Example ```python graph = { 1: [2], 2: [1, 4, 5], 3: [7], 4: [2, 5, 6], 5: [2, 4], 6: [4], 7: [3] } assert count_connected_components(graph) == 2 # The graph has 2 connected components ``` # Notes * Ensure your solution efficiently handles large graphs. * Consider edge cases, such as an empty graph or a graph with a single node. # Solution Template ```python from typing import List, Dict def count_connected_components(graph: Dict[int, List[int]]) -> int: def dfs(node: int, visited: set): stack = [node] while stack: cur = stack.pop() for neighbor in graph[cur]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in graph: if node not in visited: visited.add(node) dfs(node, visited) components += 1 return components ``` Write a Python function `count_connected_components` using the provided template and ensure it passes the provided example and adheres to the constraints.","solution":"from typing import List, Dict def count_connected_components(graph: Dict[int, List[int]]) -> int: def dfs(node: int, visited: set): stack = [node] while stack: cur = stack.pop() for neighbor in graph[cur]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() components = 0 for node in graph: if node not in visited: visited.add(node) dfs(node, visited) components += 1 return components"},{"question":"You are tasked with implementing a function that takes a list of unsigned integers and returns a list of their respective Hamming weights (the number of \'1\' bits in their binary representation). Function Signature: ```python def hamming_weights(nums: List[int]) -> List[int]: pass ``` Input: * `nums`: A list of non-negative integers (0 ≤ n ≤ 2^31 - 1). Output: * A list of integers where the ith element corresponds to the number of \'1\' bits in the binary representation of `nums[i]`. Example: ```python assert hamming_weights([11, 0, 4, 7]) == [3, 0, 1, 3] ``` *Explanation*: * The binary representation of 11 is `1011`, which has three \'1\' bits. * The binary representation of 0 is `0`, which has zero \'1\' bits. * The binary representation of 4 is `100`, which has one \'1\' bit. * The binary representation of 7 is `111`, which has three \'1\' bits. Constraints: * The solution should aim to use as little additional space as possible. * Try to achieve faster computation by leveraging bitwise operations. * The function must handle input sizes up to 10^5 elements efficiently.","solution":"from typing import List def hamming_weights(nums: List[int]) -> List[int]: Given a list of non-negative integers, returns a list of the number of \'1\' bits in the binary representation of each integer. def count_ones(n): count = 0 while n: n &= (n - 1) # Clear the lowest set bit count += 1 return count return [count_ones(num) for num in nums]"},{"question":"# Problem: Extended Dijkstra\'s Algorithm Context: You have been hired by a logistics company to enhance their navigation system. Currently, they use Dijkstra\'s algorithm to find the shortest paths in their road network graph, but they face performance issues due to the large scale of their network. Task: You need to implement an optimized version of Dijkstra\'s algorithm that efficiently finds the shortest path from a given source node to all other nodes in the graph, using a priority queue (min-heap) to improve performance. Function Signature: ```python def optimized_dijkstra(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: ``` Input: - `vertex_count (int)`: The number of vertices in the graph. - `edges (List[Tuple[int, int, int]])`: A list of tuples where each tuple contains three integers - `(start_vertex, end_vertex, weight)`, representing a directed edge from `start_vertex` to `end_vertex` with edge weight `weight`. - `src (int)`: The source vertex from which to calculate the shortest paths. Output: - `List[int]`: A list where the element at index `i` represents the shortest distance from the source vertex to the vertex `i`. If a vertex is unreachable from the source, the distance should be `float(\\"inf\\")`. Constraints: - 1 ≤ `vertex_count` ≤ 10^5 - 0 ≤ `start_vertex`, `end_vertex` < `vertex_count` - 0 ≤ `weight` ≤ 10^4 - 0 ≤ `src` < `vertex_count` Requirements: - Optimize the algorithm using a priority queue (min-heap) to manage the vertices. - Ensure the implementation handles large graphs efficiently. Example: ```python vertex_count = 5 edges = [ (0, 1, 10), (0, 3, 5), (1, 2, 1), (3, 1, 3), (3, 4, 2), (4, 2, 2), (2, 4, 4) ] src = 0 print(optimized_dijkstra(vertex_count, edges, src)) # Output: [0, 8, 9, 5, 7] ``` Explanation: From the source vertex 0: - The shortest path to vertex 1 is through vertex 3 with a total weight of 8. - The shortest path to vertex 2 is through vertices 3 and 4 with a total weight of 9. - The shortest path to vertex 3 is direct with a weight of 5. - The shortest path to vertex 4 is through vertex 3 with a total weight of 7.","solution":"from typing import List, Tuple import heapq def optimized_dijkstra(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Optimized Dijkstra\'s algorithm to find the shortest paths from src to all vertices in the graph. :param vertex_count: Number of vertices in the graph :param edges: List of edges where each edge is represented as (start_vertex, end_vertex, weight) :param src: The source vertex from which to calculate the shortest paths :return: List of shortest distance from src to each vertex graph = [[] for _ in range(vertex_count)] for u, v, w in edges: graph[u].append((v, w)) distances = [float(\'inf\')] * vertex_count distances[src] = 0 min_heap = [(0, src)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances"},{"question":"Problem Description You are given an array of words and an array of symbols. Your task is to create a function that replaces the substrings in each word with the symbols. If there are multiple possible matches, the function should always choose the longest matching symbol. Function Signature ```python def replace_with_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Input - `words`: A list of strings where each string is a word. - `symbols`: A list of strings where each string is a symbol. Output - A list of strings with each word having been processed to replace the substrings matching the symbols with the symbols enclosed in square brackets `[]`. Constraints - `words` and `symbols` will not be empty. - `words` may contain up to 10,000 words. - `symbols` may contain up to 1,000 symbols. - Each word and symbol can have a length of up to 100 characters. Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(replace_with_symbols(words, symbols)) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Requirements 1. **Efficiency**: Implement the solution with a focus on efficiency, leveraging data structures that can optimize search operations (e.g., Trie). 2. **Correctness**: Ensure that the function correctly handles edge cases and prioritizes the longest matching symbol. 3. **Clarity and Readability**: Write clean and readable code with appropriate comments explaining your approach.","solution":"from typing import List def replace_with_symbols(words: List[str], symbols: List[str]) -> List[str]: Replaces substrings in each word with matching symbols enclosed in brackets. If multiple symbols match, the longest symbol is chosen. def build_trie(symbols): root = {} for symbol in symbols: node = root for char in symbol: if char not in node: node[char] = {} node = node[char] node[\'#\'] = symbol return root def find_longest_symbol(word, trie): max_len = 0 longest_symbol = \\"\\" for i in range(len(word)): node = trie for j in range(i, len(word)): if word[j] not in node: break node = node[word[j]] if \'#\' in node: symbol = node[\'#\'] if len(symbol) > max_len: max_len = len(symbol) longest_symbol = symbol return longest_symbol trie = build_trie(symbols) result = [] for word in words: longest_symbol = find_longest_symbol(word, trie) if longest_symbol: word = word.replace(longest_symbol, f\'[{longest_symbol}]\') result.append(word) return result"},{"question":"You are given an array of integers `nums` in which exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to find the two elements that appear only once. # Function Signature ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Input - `nums`: a list of integers, where 2 elements appear exactly once, and others appear exactly twice. (1 <= len(nums) <= 10^5) # Output - Returns a list containing the two unique elements. # Constraints - The total length of the array is at most 10^5. - You must solve the problem with O(N) time complexity and O(1) space complexity. # Example ```python assert sorted(find_unique_numbers([1, 2, 1, 3, 2, 5])) == [3, 5] assert sorted(find_unique_numbers([4, 1, 2, 1, 2, 3])) == [3, 4] ``` # Scenario Imagine you are developing software for a system monitoring application where you must filter out two error codes that appear only once among a large stream of repeating codes. The constraints on processing speed and memory usage are very strict due to embedded system limitations. Apply the algorithm to efficiently identify these two unique error codes.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: Finds the two unique numbers in a list where all other numbers appear twice. # XOR all numbers to get the XOR of two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Find a bit that is set in xor_all (this bit is different for the two unique numbers) bit_mask = 1 while xor_all & bit_mask == 0: bit_mask <<= 1 # Use bit_mask to divide numbers into two groups and XOR them separately unique1 = unique2 = 0 for num in nums: if num & bit_mask: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Question: Letter Combinations from Digits You are given a string containing digits from \'2\' to \'9\'. Each digit maps to a set of letters, much like the old telephone buttons. Your task is to write a function `letter_combinations(digits)` that returns all possible letter combinations that the input digits could represent. The digit-to-letter mapping is as follows: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Your function should return the result in a list of strings. Input: - A single string `digits` containing only digits \'2\'-\'9\'. Output: - A list of strings representing all possible letter combinations. Constraints: - 1 <= len(digits) <= 4 - The input string `digits` contains only characters between \'2\' and \'9\'. Performance Requirements: - The function should be optimized to handle the maximum input length efficiently. Scenario Context: Imagine you are developing an auto-complete feature for a mobile phone keyboard. When a user types a sequence of digits, the function `letter_combinations` should generate all possible corresponding letter sequences to assist in predicting the intended input. Example: ```python # Given the digit string \\"23\\" # The possible letter combinations are: # [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] print(letter_combinations(\\"23\\")) # Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] print(letter_combinations(\\"\\")) # Output: [] print(letter_combinations(\\"2\\")) # Output: [\\"a\\", \\"b\\", \\"c\\"] ``` Implement the function `letter_combinations(digits)` to achieve the above requirements.","solution":"def letter_combinations(digits): Returns all possible letter combinations that the input digits could represent. if not digits: return [] phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(combination, next_digits): if len(next_digits) == 0: combinations.append(combination) else: for letter in phone_map[next_digits[0]]: backtrack(combination + letter, next_digits[1:]) combinations = [] backtrack(\\"\\", digits) return combinations"},{"question":"# Bubble Sort Assessment Problem Context You are tasked with sorting a list of student grades to assign ranks. The simplest way to understand the process of sorting is via a straightforward sorting algorithm known as Bubble Sort. Implement the Bubble Sort algorithm to sort lists in Python. Task Write a function `bubble_sort(arr)` that takes a list of integer elements and returns the sorted list in ascending order using the bubble sort algorithm. Instructions 1. Implement the bubble sort algorithm. 2. Ensure your function handles the following edge cases: - An empty list. - A list with a single element. - Lists that contain duplicate elements. 3. You may not use Python’s built-in sort functions or any other library functions for sorting. Input Format - A list `arr` of integers where 0 ≤ len(arr) ≤ 10^4. Output Format - Returns a list of integers sorted in ascending order. Constraints - The list can be empty, or it can contain up to 10,000 integers. - Assume all elements are integers within the possible 32-bit integer range. Example ```python print(bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(bubble_sort([])) # Output: [] print(bubble_sort([1, 1, 1])) # Output: [1, 1, 1] print(bubble_sort([5])) # Output: [5] ``` Additional Notes - Ensure the function\'s implementation is efficient to handle the upper constraints comfortably. - Consider performance, particularly how the number of swaps and comparisons impact overall runtime.","solution":"def bubble_sort(arr): Sorts a list of integers in ascending order using the bubble sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # If no two elements were swapped by inner loop, then the list is sorted if not swapped: break return arr"},{"question":"Problem Statement You are given an array of integers. Your task is to implement an optimized version of the Insertion Sort algorithm with improved performance for nearly sorted arrays. Specifically, you need to modify the algorithm so that it detects if the array is already sorted and terminates early if no swaps are necessary. Additionally, to further enhance the efficiency of moving elements, replace the linear search used to find the insertion position with a binary search mechanism. Function Signature ```python def optimized_insertion_sort(arr): Sorts an array of integers using an optimized version of insertion sort. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. pass ``` Input * `arr` : list of integers (0 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) Output * A sorted list of integers in non-decreasing order Constraints * The list may contain negative integers and duplicate elements. * Try to keep the time complexity as close to O(n log n) as possible with the given optimizations. Example ```python # Example 1 input: [4, 3, 2, 10, 12, 1, 5, 6] output: [1, 2, 3, 4, 5, 6, 10, 12] # Example 2 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] # Example 3 input: [] output: [] # Example 4 input: [8, -1, 5, 2, 7] output: [-1, 2, 5, 7, 8] ``` Guidelines * Use binary search to find the appropriate position for insertion to reduce the number of comparisons. * Implement a mechanism to detect if the list is already sorted during the iterations and terminate early if no swaps are made in a complete pass. * Consider edge cases like empty arrays or arrays with identical elements.","solution":"from bisect import bisect_left def optimized_insertion_sort(arr): Sorts an array of integers using an optimized version of insertion sort. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. n = len(arr) if n <= 1: return arr # Already sorted for i in range(1, n): current_value = arr[i] insert_pos = bisect_left(arr, current_value, 0, i) # Move elements to right to make space for the current_value if insert_pos != i: arr = arr[:insert_pos] + [current_value] + arr[insert_pos:i] + arr[i+1:] return arr"},{"question":"# Priority Queue Implementation Assessment Context: You are given a foundational structure of a priority queue implemented using a linear array. The priority queue organizes tasks based on their priority, such that the task with the highest priority can be accessed and removed efficiently. Requirements: Enhance the provided `PriorityQueue` class with the following features. After completing the enhancement, implement a function `process_tasks` that demonstrates the effectiveness of your priority queue with a given set of tasks. # Features to Implement: 1. **get_priority(item)**: a method to fetch the priority of a given item in the priority queue. - Input: `item` - Output: Integer priority of the item, or None if item is not in the queue. 2. **change_priority(item, new_priority)**: a method to change the priority of an existing item in the priority queue. - Input: `item`, `new_priority` - Output: None. Modify the queue in place. 3. **process_tasks(task_list)**: a method that processes a list of tasks defined by tuples (task, priority) and adds them to the priority queue. Each task is represented by a string, and priorities are integers. - Input: List of tuples (task, priority) - Output: List of tasks in the order they are processed by the priority queue (from lowest to highest priority). # Constraints: - Assume all tasks have unique names. - The priority is an integer where a higher number indicates a higher priority. ```python class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): return self.priority_queue_list.pop().data def get_priority(self, item): Implement this method to return the priority of the given item. Return None if the item is not in the queue. def change_priority(self, item, new_priority): Implement this method to change the priority of an existing item. If the item is not in the queue, do nothing. def process_tasks(task_list): Implement this function to process the list of tasks defined by tuples (task, priority) and add them to the priority queue ``` # Example: ```python tasks = [(\\"Task1\\", 10), (\\"Task2\\", 20), (\\"Task3\\", 5)] pq = PriorityQueue() pq.process_tasks(tasks) print(pq) # Should output tasks in the order of highest to lowest priority. print(pq.pop()) # Task3 (lowest priority task) ```","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): return self.priority_queue_list.pop().data def get_priority(self, item): Return the priority of the given item. Return None if the item is not in the queue. for node in self.priority_queue_list: if node.data == item: return node.priority return None def change_priority(self, item, new_priority): Change the priority of an existing item. If the item is not in the queue, do nothing. for node in self.priority_queue_list: if node.data == item: self.priority_queue_list.remove(node) self.push(item, new_priority) break def process_tasks(self, task_list): Process the list of tasks defined by tuples (task, priority) and add them to the priority queue. result = [] for task, priority in task_list: self.push(task, priority) while self.size() > 0: result.append(self.pop()) return result"},{"question":"# Scenario You are tasked with analyzing temperature changes in a city over a week to find the contiguous subarray with the maximum sum of temperature changes, which can inform about the period of maximum temperature improvement or consistency. # Problem Write a function `max_temperature_change` that computes the maximum sum of a contiguous subarray from a given list of temperature changes. # Function Signature ```python def max_temperature_change(temps: List[int]) -> int: pass ``` # Input - `temps`: A list of integers representing daily temperature changes over a period of time. The list is non-empty. # Output - Return an integer representing the maximum sum of any contiguous subarray within `temps`. # Constraints - 1 ≤ len(temps) ≤ 10^5 - -10^4 ≤ temps[i] ≤ 10^4 # Examples ```python assert max_temperature_change([1, 2, -3, 4, 5, -7, 23]) == 25 assert max_temperature_change([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_temperature_change([-1, -2, -3, -4]) == -1 ``` # Performance Requirements The implementation should run efficiently for lists containing up to 100,000 elements. Ensure both time and space complexities are optimal.","solution":"from typing import List def max_temperature_change(temps: List[int]) -> int: Computes the maximum sum of a contiguous subarray from a given list of temperature changes. :param temps: List[int] - A list of integers representing daily temperature changes. :return: int - The maximum sum of any contiguous subarray within the input list. # Implementing Kadane\'s Algorithm max_sum = current_sum = temps[0] for temp in temps[1:]: current_sum = max(temp, current_sum + temp) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"**Exchange Sort Enhancement Challenge** # Problem Statement You are required to enhance the existing Exchange Sort algorithm such that it can handle sorting arrays of floating-point numbers in non-decreasing order. Despite Exchange Sort\'s simplicity and inefficiency for larger datasets, we\'ll focus on a core requirement of algorithm comprehension and implementation optimization for small datasets. # Task Implement a function `enhanced_exchange_sort(arr: List[float]) -> List[float]` that sorts an array of floating-point numbers. Additionally, you need to ensure that the algorithm can recognize and skip already sorted portions of the array to optimize its performance for partially sorted inputs. # Input - A list `arr` of floating-point numbers. # Output - A list of floating-point numbers sorted in non-decreasing order. # Constraints - The input list `arr` will have at most `1000` elements. - The elements of the list will be in the range `-10^6 <= arr[i] <= 10^6`. # Performance Requirements - While the O(n^2) time complexity is expected, handling already sorted arrays or partially sorted arrays efficiently will give extra credit. - You should not use any additional libraries for sorting. # Example ```python arr = [3.4, 2.1, -5.6, 8.0, 1.2] print(enhanced_exchange_sort(arr)) # Output should be [-5.6, 1.2, 2.1, 3.4, 8.0] arr = [1.0, 2.0, 3.0, 4.0] print(enhanced_exchange_sort(arr)) # Output should be [1.0, 2.0, 3.0, 4.0] ``` # Note - You may assume that the input array can have duplicate elements. - Consider ways to optimize the algorithm by early termination if the array becomes sorted during the process. Good luck, and happy coding!","solution":"def enhanced_exchange_sort(arr): Sorts an array of floating-point numbers in non-decreasing order using an optimized Exchange Sort algorithm. n = len(arr) for i in range(n-1): already_sorted = True for j in range(n-1-i): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] already_sorted = False if already_sorted: break return arr"},{"question":"# Problem: Multi-Endian Number to Byte Conversion You are tasked with handling conversions of integers to byte arrays and vice versa in both big-endian and little-endian formats. Your objective is to implement these conversions robustly and efficiently, addressing potential weaknesses in the existing functions. # Task **Implement the following functions** in Python: 1. `improved_int_to_bytes_big_endian(num: int) -> bytes` - **Input**: A non-negative integer `num`. - **Output**: A byte array representing the integer in big-endian format. 2. `improved_int_to_bytes_little_endian(num: int) -> bytes` - **Input**: A non-negative integer `num`. - **Output**: A byte array representing the integer in little-endian format. Constraints: - The input integer `num` will be a non-negative integer lesser than (2^{64}). Requirements: - Optimize for efficiency in both time and space. - Handle edge cases appropriately (e.g., zero, maximum integer values). # Example **Example 1**: - **Input**: `num = 305419896` - **Output for `improved_int_to_bytes_big_endian`**: `b\'x12x34x56x78\'` - **Output for `improved_int_to_bytes_little_endian`**: `b\'x78x56x34x12\'` **Example 2**: - **Input**: `num = 0` - **Output for `improved_int_to_bytes_big_endian`**: `b\'\'` - **Output for `improved_int_to_bytes_little_endian`**: `b\'\'`","solution":"def improved_int_to_bytes_big_endian(num: int) -> bytes: Converts a non-negative integer to a byte array in big-endian format. if num == 0: return b\'x00\' byte_arr = [] while num: byte_arr.append(num & 0xff) num >>= 8 return bytes(byte_arr[::-1]) def improved_int_to_bytes_little_endian(num: int) -> bytes: Converts a non-negative integer to a byte array in little-endian format. if num == 0: return b\'x00\' byte_arr = [] while num: byte_arr.append(num & 0xff) num >>= 8 return bytes(byte_arr)"},{"question":"Context: A balanced binary tree is one in which the height difference between the left and right subtrees of every node is no more than one. Checking whether a tree is balanced ensures that tree operations, such as insertion, deletion, and lookup, can be performed efficiently. Task: Implement a function `check_balanced_tree(tree_root)` that checks if a binary tree is balanced. Use the DFS-based approach for an optimal solution. Input & Output Specifications: * **Input**: * `tree_root`: The root node of the binary tree. The node is a TreeNode object which has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: * Return `True` if the tree is balanced, otherwise `False`. Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are not necessarily unique. * Consider using an efficient solution in terms of both time and space complexity. Performance Requirements: * The implementation should run in O(N) time complexity where N is the number of nodes in the tree. * Space complexity should be optimized and ideally, it should be O(H) where H is the height of the tree. Example: ```python # Example binary tree to function mapping # 3 # / # 9 20 # / # 15 7 tree_root = TreeNode(3) tree_root.left = TreeNode(9) tree_root.right = TreeNode(20) tree_root.right.left = TreeNode(15) tree_root.right.right = TreeNode(7) assert check_balanced_tree(tree_root) == True ``` Function Signature: ```python def check_balanced_tree(tree_root: TreeNode) -> bool: # Your code here ``` You should write the `check_balanced_tree` function, following the above guidelines and requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def check_balanced_tree(tree_root: TreeNode) -> bool: def height_and_balanced(node): if not node: return 0, True left_height, left_balanced = height_and_balanced(node.left) right_height, right_balanced = height_and_balanced(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced return height_and_balanced(tree_root)[1]"},{"question":"# Question: Implement and Compare Stacks As a software engineer, you are tasked with implementing two versions of a stack — one using arrays and another using linked lists. Your goal is to compare their behaviors and performance. Specifically, you need to implement two stack classes, `ArrayStack` and `LinkedListStack`, adhering to the given Stack Abstract Data Type (ADT), and write a function to test their efficiency. Part 1: Stack Implementation 1. Implement the `ArrayStack` class. - `__init__(self, size=10)`: Initializes the stack with an optional size argument. - `push(self, value)`: Adds a value to the stack. - `pop(self)`: Removes and returns the top value of the stack. - `peek(self)`: Returns the top value without removing it. - `is_empty(self)`: Checks if the stack is empty. - `__iter__(self)`: Supports iteration over stack elements. - `_expand(self)`: Expands the capacity of the stack’s underlying array. 2. Implement the `LinkedListStack` class. - `__init__(self)`: Initializes the stack. - `push(self, value)`: Adds a value to the stack. - `pop(self)`: Removes and returns the top value of the stack. - `peek(self)`: Returns the top value without removing it. - `is_empty(self)`: Checks if the stack is empty. - `__iter__(self)`: Supports iteration over stack elements. Part 2: Efficiency Testing Write a function `test_stack_efficiency()` that: 1. Initializes both stacks. 2. Pushes and pops a large number of elements (e.g., 1,000,000) to/from each stack. 3. Measures the time taken for each operation. 4. Prints the results, including: - Time taken for array stack operations. - Time taken for linked list stack operations. - Any observations on performance differences. Constraints * Both stacks should handle at least 1,000,000 elements. * Ensure readability and maintainability of code. * You can import Python\'s `time` module for performance measurement. # Expected Input/Output * No specific input or output; the function will print the performance measurements. # Example ```python def test_stack_efficiency(): pass if __name__ == \\"__main__\\": test_stack_efficiency() ```","solution":"import time class ArrayStack: def __init__(self, size=10): self.array = [None] * size self.top = -1 self.size = size def push(self, value): if self.top == self.size - 1: self._expand() self.top += 1 self.array[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") value = self.array[self.top] self.array[self.top] = None self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.array[self.top] def is_empty(self): return self.top == -1 def _expand(self): new_size = self.size * 2 new_array = [None] * new_size for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.size = new_size def __iter__(self): for i in range(self.top, -1, -1): yield self.array[i] class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None def __iter__(self): current = self.head while current is not None: yield current.value current = current.next def test_stack_efficiency(): iterations = 1000000 array_stack = ArrayStack() linked_list_stack = LinkedListStack() # Array stack performance start_time = time.time() for i in range(iterations): array_stack.push(i) for i in range(iterations): array_stack.pop() end_time = time.time() array_stack_time = end_time - start_time # Linked list stack performance start_time = time.time() for i in range(iterations): linked_list_stack.push(i) for i in range(iterations): linked_list_stack.pop() end_time = time.time() linked_list_stack_time = end_time - start_time print(f\\"ArrayStack operations time: {array_stack_time} seconds\\") print(f\\"LinkedListStack operations time: {linked_list_stack_time} seconds\\") print(\\"Observation: ArrayStack is expected to have more stable access times due to contiguous memory storage, whereas LinkedListStack may have varied access times due to pointer dereferencing for each node.\\") if __name__ == \\"__main__\\": test_stack_efficiency()"},{"question":"# Question: Range Deletion on Singly Linked List Scenario You are working on a music streaming app where playlists are maintained as linked lists. You need to implement a feature that allows users to remove a continuous sub-range of songs. For this, you will implement a function that removes elements from a linked list based on given start and end indices. Function Specification Implement the following function: ```python def remove_range(head, start, end): Given a singly linked list, remove the elements from `start` index to `end` index (inclusive). Args: head (ListNode): The head of the linked list. start (int): The starting index to begin removal (inclusive). end (int): The ending index to stop removal (inclusive). Returns: ListNode: The head of the modified linked list. Constraints: - 0 <= start <= end < length of the linked list - The function should handle the edge case where start is at the head of the list. - The function should handle cases where `head` is `None` appropriately. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example ```python # List: 8 -> 13 -> 17 -> 4 -> 9 -> 12 -> 98 -> 41 -> 7 -> 23 -> 0 -> 92 head = ListNode(8, ListNode(13, ListNode(17, ListNode(4, ListNode(9, ListNode(12, ListNode(98, ListNode(41, ListNode(7, ListNode(23, ListNode(0, ListNode(92)))))))))))) start, end = 3, 8 new_head = remove_range(head, start, end) # Expected updated list: 8 -> 13 -> 17 -> 23 -> 0 -> 92. ``` Performance Requirements Your implementation should run with a linear time complexity, O(n), where n is the length of the entire linked list, ensuring efficient traversal and deletion operations. Notes - Ensure to validate your function against typical edge cases: removing elements that include the head, removing the entire list, and removing nodes with invalid indices.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): Given a singly linked list, remove the elements from `start` index to `end` index (inclusive). Args: head (ListNode): The head of the linked list. start (int): The starting index to begin removal (inclusive). end (int): The ending index to stop removal (inclusive). Returns: ListNode: The head of the modified linked list. if not head: return None dummy = ListNode(0) dummy.next = head prev = dummy # Find the node just before the start position for _ in range(start): prev = prev.next # \'prev\' now is the node just before the range to be removed current = prev.next # Move \'current\' to the end of the range for _ in range(end - start + 1): current = current.next # Relink the list with the remaining part of the list prev.next = current return dummy.next"},{"question":"# Question You are provided with a list containing various elements. Your task is to implement a function that removes any duplicate elements from the list and returns a new list containing only unique elements while maintaining the order of their first occurrence. Function Signature ```python def remove_duplicates(array: list) -> list: # your code here ``` Input - `array` (List): A list containing elements of any data type. Examples include integers, strings, or booleans. The list can also be empty. Output - `List`: A new list containing only the unique elements from the input list, preserving their first occurrence order. Constraints - The input list will have at most 10^5 elements. - The elements can be of various data types (e.g., integers, strings, booleans). Example ```python assert remove_duplicates([1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\', True] assert remove_duplicates([]) == [] assert remove_duplicates([42, 42, \\"answer\\", \\"answer\\", True, True, False, False]) == [42, \\"answer\\", True, False] ``` Performance Requirements - Your implementation should aim to reduce time complexity from O(n^2) to O(n) using efficient data structures such as a set or dictionary for membership checking. Good luck!","solution":"def remove_duplicates(array: list) -> list: Removes duplicates from the list while maintaining order of first occurrence. Parameters: array (list): A list of elements of any data type. Returns: list: A list with duplicates removed, maintaining the order of first occurrence. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Scenario An international linguistics conference is analyzing the typing effort required for various words when using different keyboard layouts. As part of this analysis, they need to identify which words from a list can entirely be typed using letters from a single row of a standard QWERTY keyboard. Task Write a function, `find_keyboard_row(words)`, that takes a list of words and returns a new list of words that can be typed using only one row of the American QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input * `words`: A list of strings, where each string represents a word (`1 <= len(words) <= 100`, `1 <= len(words[i]) <= 100`). Output * A list of strings, containing the words from `words` that can be typed using only one row of the American keyboard. Example ```python input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] output: [\\"Alaska\\", \\"Dad\\"] ``` Constraints and Limitations * The input list is all alphabetical letters and has no punctuation. * The function should be case-insensitive. * Aim for a time complexity of O(n * m) where `n` is the number of words and `m` is the number of characters in the longest word. Performance Requirements * Ensure the function remains efficient and scales well with typical input sizes defined above.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = word.lower() if all(char in row1 for char in lower_word) or all(char in row2 for char in lower_word) or all(char in row3 for char in lower_word): result.append(word) return result"},{"question":"# Question: Implement a Robust Modular Arithmetic Library You have been given the implementations of the Extended GCD algorithm and Modular Inverse algorithm covered in the analysis. Your task is to use these and extend the functionalities to support a modular arithmetic library. Implement a class, `ModularArithmetic`, with the following methods: 1. `__init__(self, modulus: int) -> None`: Initializes the library with a given modulus `m`. 2. `add(self, a: int, b: int) -> int`: Returns the result of `(a + b) % m`. 3. `subtract(self, a: int, b: int) -> int`: Returns the result of `(a - b) % m`. 4. `multiply(self, a: int, b: int) -> int`: Returns the result of `(a * b) % m`. 5. `inverse(self, a: int) -> int`: Returns the modular inverse of `a` under the modulus `m`. Function Signature: ```python class ModularArithmetic: def __init__(self, modulus: int) -> None: pass def add(self, a: int, b: int) -> int: pass def subtract(self, a: int, b: int) -> int: pass def multiply(self, a: int, b: int) -> int: pass def inverse(self, a: int) -> int: pass ``` # Input Format - The constructor receives an integer `m`. - Subsequent method calls receive integers appropriate to their operations. # Output Format - Methods `add`, `subtract`, and `multiply` return computed modular results. - Method `inverse` returns the modular inverse or raises a `ValueError` if `a` and `m` are not coprime. # Constraints - `1 <= modulus <= 10^9` - `0 <= a, b < modulus` # Example ```python mod_arith = ModularArithmetic(7) assert mod_arith.add(4, 5) == 2 # (4 + 5) % 7 = 9 % 7 = 2 assert mod_arith.subtract(4, 5) == 6 # (4 - 5) % 7 = -1 % 7 = 6 assert mod_arith.multiply(4, 5) == 6 # (4 * 5) % 7 = 20 % 7 = 6 assert mod_arith.inverse(5) == 3 # 5 * 3 % 7 = 1 ``` # Performance Requirements - Your implementation should efficiently handle the given constraints, especially considering the operations need to manage large integers.","solution":"class ModularArithmetic: def __init__(self, modulus: int) -> None: self.modulus = modulus def add(self, a: int, b: int) -> int: return (a + b) % self.modulus def subtract(self, a: int, b: int) -> int: return (a - b) % self.modulus def multiply(self, a: int, b: int) -> int: return (a * b) % self.modulus def _extended_gcd(self, a: int, b: int): if a == 0: return b, 0, 1 gcd, x1, y1 = self._extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def inverse(self, a: int) -> int: gcd, x, _ = self._extended_gcd(a, self.modulus) if gcd != 1: raise ValueError(f\\"No modular inverse for {a} under modulus {self.modulus}\\") return x % self.modulus"},{"question":"# ZigZagIterator Generalization for Multiple Input Lists Context The current implementation of the `ZigZagIterator` allows for alternating iteration over two lists only. Generalizing this functionality to an arbitrary number of lists can make the iterator useful in more diverse applications. Think of creating a round-robin access over multiple sequences. Task Write a class `ZigZagIteratorMultiple` that handles an arbitrary number of input lists, allowing you to iterate over them in a round-robin fashion. Function Specifications 1. `__init__(self, *lists)`: * **Input**: An arbitrary number of lists of integers (provided as variable arguments `*lists`). * **Initialization**: Store the lists and set up the structure to iterate over them zigzag fashion. 2. `next(self)`: * **Output**: Return the next integer in zigzag order. * **Constraint**: Ensure that must call `has_next()` before this to ensure there is a next element available. 3. `has_next(self)`: * **Output**: Return a boolean indicating whether there are more elements to iterate over. Example ```python list1 = [1, 2, 3] list2 = [4, 5, 6, 7] list3 = [8, 9] # Initializing it = ZigZagIteratorMultiple(list1, list2, list3) # Outputting elements while it.has_next(): print(it.next()) ``` Expected Output ``` 1 4 8 2 5 9 3 6 7 ``` Constraints * Assume the input lists do not contain any `None` or invalid elements. * The lists can be of varying lengths, including empty. Ensure efficient handling of list operations and provide test cases to validate your implementation.","solution":"from collections import deque class ZigZagIteratorMultiple: def __init__(self, *lists): self.q = deque([(lst, 0) for lst in lists if lst]) # Store lists along with current index def next(self): if not self.has_next(): raise StopIteration(\\"No more elements in iterator\\") lst, idx = self.q.popleft() val = lst[idx] if idx + 1 < len(lst): # If there are more elements in the current list, append it back self.q.append((lst, idx + 1)) return val def has_next(self): return bool(self.q)"},{"question":"# Scenario Imagine you are working on a system that deals with mirrored backups for data. Each backup is represented as a binary tree structure and you need to verify that your backup mirrors are identical to the primary trees in structure and node values. This ensures data integrity across your mirrored systems. # Task You are required to implement a function `is_same_tree(tree_p, tree_q)` that takes two binary trees and determines if they are identical in structure and node values. Formulate your code to handle recursion efficiently and pay attention to edge cases. # Function Signature ```python def is_same_tree(tree_p, tree_q): # Your code here ``` # Input Format - `tree_p`: Root node of the first binary tree. Each node contains an integer and two children (which could be `None`). - `tree_q`: Root node of the second binary tree. Each node contains an integer and two children (which could be `None`). # Output Format - Return a boolean value `True` if the trees are identical, otherwise return `False`. # Constraints 1. The number of nodes in the tree will not exceed 10,000. 2. Node values are integers and can be both positive and negative. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree Creation tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree(tree_p, tree_q) == True tree_p = TreeNode(1, TreeNode(2)) tree_q = TreeNode(1, None, TreeNode(2)) assert is_same_tree(tree_p, tree_q) == False # The assertions should pass without any errors if the function is implemented correctly. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): Determines if two binary trees are identical in structure and node values. if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"You are to implement a `DoublyLinkedList` class with the following methods: 1. `insert_value_at_head(value)`: Inserts a new node with the given value at the head of the list. 2. `insert_value_at_tail(value)`: Inserts a new node with the given value at the tail of the list. 3. `delete_value(value)`: Deletes the first node that contains the given value. 4. `find_value(value)`: Returns `True` if a node with the specified value exists, and `False` otherwise. 5. `traverse_forward()`: Returns a list of all node values in forward order. 6. `traverse_backward()`: Returns a list of all node values in reverse order. # Input: - `insert_value_at_head(value)`, `insert_value_at_tail(value)`, `delete_value(value)` and `find_value(value)` methods will have an integer input value. # Output: - `find_value(value)` returns a boolean. - `traverse_forward()` and `traverse_backward()` return a list of integers. - `insert_value_at_head(value)`, `insert_value_at_tail(value)` and `delete_value(value)` do not return any value. # Constraints: - The list can contain duplicate values. - Values are limited to integer type within the range of 32-bit signed integers. # Example: ```python dll = DoublyLinkedList() dll.insert_value_at_head(10) dll.insert_value_at_head(20) dll.insert_value_at_tail(30) print(dll.traverse_forward()) # Output: [20, 10, 30] print(dll.traverse_backward()) # Output: [30, 10, 20] print(dll.find_value(10)) # Output: True dll.delete_value(10) print(dll.find_value(10)) # Output: False print(dll.traverse_forward()) # Output: [20, 30] ``` # Required Implementation ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_value_at_head(self, value): # Your code here def insert_value_at_tail(self, value): # Your code here def delete_value(self, value): # Your code here def find_value(self, value): # Your code here def traverse_forward(self): # Your code here def traverse_backward(self): # Your code here ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_value_at_head(self, value): new_node = DoublyLinkedListNode(value) new_node.next = self.head if self.head is not None: self.head.prev = new_node else: self.tail = new_node self.head = new_node def insert_value_at_tail(self, value): new_node = DoublyLinkedListNode(value) new_node.prev = self.tail if self.tail is not None: self.tail.next = new_node else: self.head = new_node self.tail = new_node def delete_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def find_value(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def traverse_forward(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def traverse_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"You\'re tasked with implementing a new type of stack based on the abstract class `AbstractStack` provided in the code snippet. This stack should be based on a **circular array** to make efficient use of space. **Requirements**: 1. **Constructor**: Create a constructor that initializes the stack with a fixed size (default to 10 if not specified). 2. **push(value)**: Add an element to the top of the stack. If the stack reaches its capacity, double the size of the circular array. 3. **pop()**: Remove and return the top element of the stack. Raise an `IndexError` if the stack is empty. 4. **peek()**: Return the top element of the stack without removing it. Raise an `IndexError` if the stack is empty. 5. **is_empty()**: Return `True` if the stack is empty, otherwise `False`. **Constraints**: - Do not use Python\'s built-in list methods other than direct element access and assignment. - The stack should behave in a circular manner to utilize the array space effectively until resizing is necessary. - You must implement all methods defined in the `AbstractStack` class. **Input Format**: - The input will be a series of commands and arguments for the stack operations. **Output Format**: - The output should be the result of the `pop()` or `peek()` operations. **Example**: ```python circular_stack = CircularArrayStack(5) circular_stack.push(1) circular_stack.push(2) circular_stack.push(3) circular_stack.peek() # Output: 3 circular_stack.pop() # Output: 3 circular_stack.pop() # Output: 2 circular_stack.is_empty() # Output: False circular_stack.pop() # Output: 1 circular_stack.is_empty() # Output: True ``` **Note**: To handle expansion, the circular nature of the array must be maintained, and elements must be correctly rearranged.","solution":"class AbstractStack: def push(self, value): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class CircularArrayStack(AbstractStack): def __init__(self, size=10): self.array = [None] * size self.top = -1 self.size = size def push(self, value): if self.top + 1 == self.size: self._resize() self.top += 1 self.array[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.array[self.top] self.array[self.top] = None self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.array[self.top] def is_empty(self): return self.top == -1 def _resize(self): new_array = [None] * (self.size * 2) for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.size *= 2"},{"question":"# Task: Pattern Matching with Bijective Mapping You are tasked with implementing a function `pattern_match` that takes a pattern string and a target string and returns a boolean value indicating whether the target string follows the given pattern. Function signature: ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Input: * `pattern`: A string consisting of lowercase alphabetic characters. * `string`: A string consisting of lowercase alphabetic characters. # Output: * A boolean value: - `True` if the target string follows the same pattern where each letter in the pattern can be mapped to a unique non-empty substring of the target string. - `False` otherwise. # Constraints: * Both `pattern` and `string` contain only lowercase letters. * Length of `pattern` and `string` does not exceed 20 characters. # Examples: ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` # Explanation: * In the first example, `pattern = \\"abab\\"` can be mapped as `a -> \\"red\\"`, `b -> \\"blue\\"`. * In the second example, `pattern = \\"aaaa\\"` can be mapped as `a -> \\"asd\\"`. * In the third example, `pattern = \\"aabb\\"` cannot be mapped uniquely to respective substrings in \\"xyzabcxzyabc\\". You must implement the function using a backtracking approach to exhaustively try all potential mappings between pattern characters and substrings of the target string. **Guide**: 1. Recursively attempt to map each character of the pattern to different substrings of the target string. 2. Maintain a dictionary to store these mappings. 3. Ensure that no two characters in the pattern map to the same substring. 4. Backtrack whenever a mapping leads to a dead end and attempt other possible substrings. 5. Return true if a valid mapping is found that exhausts the pattern and matches the entire string, otherwise return false.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, mapping, used): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False pattern_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): sub_str = string[s_idx:end] if pattern_char not in mapping and sub_str not in used: mapping[pattern_char] = sub_str used.add(sub_str) if backtrack(p_idx + 1, end, mapping, used): return True del mapping[pattern_char] used.remove(sub_str) elif pattern_char in mapping and mapping[pattern_char] == sub_str: if backtrack(p_idx + 1, end, mapping, used): return True return False return backtrack(0, 0, {}, set())"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: This is a recursive algorithm to convert a sorted array into a height-balanced Binary Search Tree (BST). * **Complexity**: - **Time Complexity**: O(n) - where n is the number of elements in the array. - **Space Complexity**: O(log n) - due to the recursion stack for a balanced BST. * **Principles**: The core mechanism involves dividing the array into two halves and recursively creating nodes such that the middle element becomes the root, thereby ensuring a height-balanced tree. # Characteristics & Applications * **Properties**: - The resulting BST is height-balanced, meaning the depth of two subtrees of every node never differ by more than one. - The elements are inserted into the tree such that for any node, the left children are less than the node and the right children are greater. * **Common Use Cases**: - Used in applications where balanced tree structures are required for efficient querying, e.g., databases, and search algorithms. - Ideal for scenarios demanding a balanced BST for dynamic ordered data. * **Strengths/Limitations**: - **Strengths**: Guarantees O(log n) height, providing consistent performance for operations like search, insert, and delete. - **Limitations**: Requires the input array to be sorted, adds overhead due to recursion which may not be optimal for very large arrays without tail call optimization or iterative approaches. # Implementation Challenges * **Edge Cases**: - An empty array should return `None`. - Arrays with a single element should correctly produce a tree with one node. * **Performance Bottlenecks**: - The recursion depth can be a limiting factor; deep recursion might lead to stack overflow in languages without proper tail call optimization. * **Error Scenarios**: - Mid calculation and array splits should be handled correctly to avoid infinite loops or incorrect tree structures. * **Optimization Points**: - Consider using iterative approaches for large arrays to avoid recursion depth issues. - Use pre-allocated nodes if memory usage is a concern. <|Analysis End|> <|Question Begin|> # Question: Convert Sorted Array to Height Balanced BST Given an array of integers `nums` sorted in ascending order, write a function to convert it into a height-balanced binary search tree (BST). The function should be implemented with the following signature: ```python def array_to_bst(nums: List[int]) -> TreeNode: ``` # Input - `nums`: A list of integers sorted in ascending order. The length of the list is in the range [0, 10^4]. # Output - Return the root node of the height-balanced BST. # Constraints - The BST should be height-balanced, which means the depth of the two subtrees of every node never differ by more than one. - The values in the nodes must reflect the sorted order of the input array. # Example ```python # Example 1: nums = [-10, -3, 0, 5, 9] root = array_to_bst(nums) # The tree resulting from this example would be: # 0 # / # -10 5 # # -3 9 # Example 2: nums = [1, 3] root = array_to_bst(nums) # The tree resulting from this example would be: # 3 # / # 1 ``` # Explanation: - For the first example, the middle element `0` becomes the root. The left subtree consists of `[-10, -3]` and follows the same logic, the right subtree with `[5, 9]`. - For the second example, the middle element `3` becomes the root, and `1` becomes the left child. # Performance Requirements - The function should have O(n) time complexity and O(log n) space complexity due to recursion stack space. # Guidelines - Focus on creating a genuinely balanced BST. - Ensure to handle edge cases such as empty array input, or arrays with a single element. <||Question End|>","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = array_to_bst(nums[:mid]) root.right = array_to_bst(nums[mid + 1:]) return root"},{"question":"# Scenario You are working as a software engineer tasked with optimizing the performance of a legacy string processing system. Your goal is to identify if certain strings in the system present repetitive patterns which might affect data storage and handling efficiencies. # Question Write a Python function `is_repeated_substring(s: str) -> bool` that determines if a non-empty string `s` can be constructed by repeating one of its substrings multiple times. Input * A single string `s` of length between 1 and 10,000 characters. Output * Return `True` if the string `s` can be constructed by repeating a substring of it, `False` otherwise. Constraints * You should aim for an efficient implementation with a time complexity of O(n) and space complexity of O(n). Examples ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True assert is_repeated_substring(\\"abcd\\") == False ``` # Explanation 1. For the input `\\"abab\\"`, the function returns `True` since \\"abab\\" can be constructed by repeating \\"ab\\" twice. 2. For the input `\\"abcabcabcabc\\"`, it is clear that \\"abc\\" repeated four times produces the string. Your task is to implement the `is_repeated_substring` function accordingly.","solution":"def is_repeated_substring(s: str) -> bool: Determines if the string s can be constructed by repeating one of its substrings multiple times. n = len(s) if n == 1: # Single character strings cannot be constructed by repeating a substring return False # We create a doubled string and cut off the first and last characters. double_s = (s + s)[1:-1] # If s can also be found in the middle of this modified string, it means it can be constructed # by repeating its substring. return s in double_s"},{"question":"Context You are part of a development team working on a navigation system. Efficiently finding the shortest path between points on a map is critical for this system\'s performance. Your team has identified Dijkstra\'s algorithm as suitable for this purpose, given the non-negative weights of the edges representing distances between points. Task Implement a function to find the shortest paths from a specified source vertex to all other vertices in a weighted, directed graph using Dijkstra\'s algorithm. Function Signature ```python def find_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[float]: ``` Input * **vertex_count**: An integer, the number of vertices in the graph (1 ≤ vertex_count ≤ 1000). * **edges**: A list of tuples, where each tuple (u, v, w) represents an edge from vertex `u` to vertex `v` with weight `w` (0 ≤ w ≤ 1000). * **src**: An integer, the source vertex (0 ≤ src < vertex_count). Output * A list of `vertex_count` elements, where the element at index `i` represents the shortest distance from the source vertex `src` to vertex `i`. Constraints * The graph has no negative weight edges. * If a vertex is unreachable from the source, the corresponding distance should be `float(\'inf\')`. Example ```python vertex_count = 5 edges = [ (0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 3, 2), (3, 2, 9), (1, 3, 9) ] src = 0 print(find_shortest_paths(vertex_count, edges, src)) # Output: [0, 8, 9, 7, 5] ``` Special Notes * Consider using a priority queue to optimize your solution. * Thoroughly test your implementation with edge cases such as disconnected graphs and graphs where all nodes are directly connected to the source.","solution":"import heapq from typing import List, Tuple def find_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[float]: Finds shortest paths from the source vertex to all other vertices using Dijkstra\'s algorithm. # Initialize distance to all vertices as infinity, except source distances = [float(\'inf\')] * vertex_count distances[src] = 0 # Adjacency list representation of the graph graph = [[] for _ in range(vertex_count)] for u, v, w in edges: graph[u].append((v, w)) # Priority queue to select the vertex with the smallest distance priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"You are given the task of determining whether two given binary trees are identical in structure and the values at corresponding nodes. # Function Signature ```python def is_same_tree(tree_p, tree_q): # your implementation here ``` # Input - `tree_p`: The root node of the first binary tree. - `tree_q`: The root node of the second binary tree. Each tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Return `True` if the trees are structurally identical and nodes have the same value. - Return `False` otherwise. # Example Input: ```python tree_p: 1 / 2 3 tree_q: 1 / 2 3 ``` Output: ```python True ``` Input: ```python tree_p: 1 / 2 1 tree_q: 1 / 1 2 ``` Output: ```python False ``` # Constraints - Both `tree_p` and `tree_q` can have at most 100 nodes. - Node values are integers that can be both positive and negative, but within a typical integer range. # Performance Requirements - Solutions should consider both time and space complexity. - Aim for time complexity O(min(N, M)) and space complexity O(min(height1, height2)) for optimal efficiency. # Additional Notes - Make sure your solution appropriately handles edge cases such as when both trees are `None`, or when one tree is `None` and the other is not.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): Determine if two binary trees are equivalent. if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Scenario: You are an engineer working on a probability simulation that requires frequent calculations of combinations to determine the possible ways to select items from a set. The algorithm you need should be efficient and handle large inputs without excessive time or space complexity. # Problem: Your task is to implement a combination function to calculate nCr (how many ways to choose r items from n items) using both: - Pure recursion. - Memoized recursion to optimize performance. # Function Signatures: Implement two functions: 1. `combination(n: int, r: int) -> int`: Uses pure recursion. 2. `combination_memo(n: int, r: int) -> int`: Uses recursion with memoization. # Input: - `n`: [0 <= n <= 100] - `r`: [0 <= r <= n] # Output: - Each function should return an integer representing the number of ways to choose `r` items from `n` items. # Example: ```python combination(5, 3) -> 10 combination_memo(5, 3) -> 10 combination(10, 0) -> 1 combination_memo(10, 0) -> 1 combination(1, 1) -> 1 combination_memo(1, 1) -> 1 combination(6, 2) -> 15 combination_memo(6, 2) -> 15 ``` # Constraints: - The solution for `combination_memo` should be optimized to avoid redundant calculations and minimize recursive calls. - Ensure that your implementation manages the memory efficiently to handle the given constraints without running into stack overflow issues.","solution":"def combination(n, r): Uses pure recursion to calculate nCr if r == 0 or r == n: return 1 return combination(n - 1, r - 1) + combination(n - 1, r) def combination_memo(n, r, memo=None): Uses memoized recursion to calculate nCr if memo is None: memo = {} if (n, r) in memo: return memo[(n, r)] if r == 0 or r == n: return 1 result = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) memo[(n, r)] = result return result"},{"question":"# Matrix Chain Multiplication You are working on optimizing the process of multiplying a chain of matrices. Given the dimensions of the matrices, you need to find the most efficient way to multiply them together. Matrix multiplication is associative, so there are many possible ways to multiply these matrices, but you need to determine the way that requires the fewest scalar multiplications. Despite the large search space, dynamic programming provides an efficient way to solve this problem. # Task Write a function `matrix_chain_order` that takes a list of integers (representing the dimensions of matrices) and returns the minimum number of multiplications needed to multiply the chain of matrices together. Additionally, provide a function `print_optimal_solution` that prints the optimal parenthesization of the matrices. Input * `arr`: a list of integers where the ith matrix Ai has dimensions `arr[i-1] x arr[i]`. Output * The minimum number of scalar multiplications needed. Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications required:\\", matrix[1][-1]) print_optimal_solution(optimal_solution, 1, len(array) - 1) ``` Constraints * The length of the array will be at least 2 and can go up to 100. * The dimensions in the array will be positive integers representing valid matrix sizes.","solution":"def matrix_chain_order(arr): Returns the minimum number of scalar multiplications needed to multiply the chain of matrices. n = len(arr) m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n): for i in range(1, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + arr[i-1]*arr[k]*arr[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s, i, j): Prints the optimal parenthesization of matrices. if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Question You are given a stream of data represented by a string which potentially contains recurring characters. Implement a function that compresses this string using Run-Length Encoding (RLE) and another function to decompress the encoded string back to the original. Your implementation should ensure that the given string, whether encoded or decoded, is handled efficiently and correctly. Functions to Implement 1. `encode_rle(input: str) -> str` 2. `decode_rle(input: str) -> str` Specifications: 1. **Encoding Function (encode_rle)** - **Input**: A string `input` (1 ≤ len(input) ≤ 10^5). - **Output**: A string that represents the encoded data. - **Details**: Converts sequences of consecutive characters into the format `(count, character)` where `count` is the number of repetitions and `character` is the character repeated. 2. **Decoding Function (decode_rle)** - **Input**: A string `input` (1 ≤ len(input) ≤ 10^5) that represents an encoded sequence. - **Output**: A string that represents the original uncompressed data. - **Details**: Reconstructs the original string from the encoded format by repeating characters according to the specified counts. Examples: 1. Encoding: ```python encode_rle(\\"aaabbc\\") # returns \\"3a2b1c\\" ``` 2. Decoding: ```python decode_rle(\\"3a2b1c\\") # returns \\"aaabbc\\" ``` Constraints: - The encoding will not include any characters other than digits and letters. - You may assume the encoded string for decoding is always valid. Performance: - Your solution should handle the large inputs efficiently in terms of time and space.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input[-1]}\\") # Append the last set of characters return \'\'.join(encoded_str) def decode_rle(input: str) -> str: decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 # Reset count after using it return \'\'.join(decoded_str)"},{"question":"In computer science, addition and subtraction without using their respective operators can be beneficial in various scenarios, such as processor design, low-level programming, and certain optimization tasks. Using bitwise operations, create a function that performs subtraction of two integers. # Task Write a function `subtract_bitwise_operator(x: int, y: int) -> int` that subtracts the integer `y` from integer `x` without using the subtraction operator (`-`). You should use bitwise operations to perform this task. # Input * `x`: a non-negative integer (0 <= x <= 10^9) * `y`: a non-negative integer (0 <= y <= 10^9) # Output * Return the result of `x - y` as an integer. # Constraints * Assume `x >= y`. * Perform the calculation using only bitwise operations. # Example ```python assert subtract_bitwise_operator(5, 3) == 2 assert subtract_bitwise_operator(10, 4) == 6 assert subtract_bitwise_operator(6, 6) == 0 ``` # Explanation Using the principles of bitwise arithmetic, the solution should iteratively apply operations such as bitwise XOR and bitwise AND to simulate the subtraction process, handling any necessary borrows bit by bit.","solution":"def subtract_bitwise_operator(x, y): Returns the difference between x and y using bitwise operations. while y != 0: # Carry now contains common set bits of x and y carry = (~x) & y # XOR of x and y is the sum without carrying x = x ^ y # Carry is shifted by one to the left to subtract in the next higher bit y = carry << 1 return x"},{"question":"# Question: You are developing a cryptographic library where one of the functions needs to compute the modular exponentiation efficiently. Modular exponentiation is a critical operation, especially in asymmetric key encryption algorithms like RSA. Your task is to write a function that computes ( (base ^ exponent) mod modulus ). # Function Signature: ```python def modular_exponential(base, exponent, mod): Computes (base ^ exponent) % mod. Parameters: base (int): The base number. exponent (int): The exponent number (must be non-negative). mod (int): The modulus (must be positive). Returns: int: The result of (base ^ exponent) % mod. Raises: ValueError: If the exponent is negative or the modulus is non-positive. ``` # Input: - An integer `base`. - A non-negative integer `exponent`. - A positive integer `mod`. # Output: - An integer which is the result of ( (base ^ exponent) mod mod ). # Constraints: - ( 0 leq text{base} leq 10^9 ) - ( 0 leq text{exponent} leq 10^9 ) - ( 1 leq text{mod} leq 10^9 ) # Example: ```python print(modular_exponential(2, 10, 1000)) # Output: 24 print(modular_exponential(5, 3, 13)) # Output: 8 print(modular_exponential(2, 0, 5)) # Output: 1 ``` # Constraints and Requirements: 1. Ensure your function handles large inputs efficiently. 2. Raise `ValueError` if the exponent is negative or the modulus is non-positive. 3. Your function should not use Python\'s built-in power function (`pow`). # Scenario: In a cryptographic system, you need to frequently compute large powers with a modulus to securely encode and decode messages. Implementing this function correctly and efficiently is critical to maintaining the system\'s performance.","solution":"def modular_exponential(base, exponent, mod): Computes (base ^ exponent) % mod using an efficient algorithm. Parameters: base (int): The base number. exponent (int): The exponent number (must be non-negative). mod (int): The modulus (must be positive). Returns: int: The result of (base ^ exponent) % mod. Raises: ValueError: If the exponent is negative or the modulus is non-positive. if exponent < 0: raise ValueError(\\"Exponent must be non-negative\\") if mod <= 0: raise ValueError(\\"Modulus must be positive\\") result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: # If exponent is odd, multiply base with the result result = (result * base) % mod exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"Context A crucial aspect of data analysis is searching for specific elements within datasets. Imagine you are part of a team working on a system that processes arrays of varying lengths. Your task is to ascertain the position of a given element within these arrays using an efficient search algorithm. Task Write an efficient search algorithm that extends the basic linear search to handle and log specific edge cases. While maintaining the same overall logic, your enhanced linear search should be able to: 1. Identify and log when the array is empty. 2. Identify and log duplicates of the query element within the array. 3. Return the index of the first occurrence of the element if found. 4. Return -1 if the element isn\'t found, ensuring that this case is logged as well. Function Signature ```python def enhanced_linear_search(array: List[int], query: int) -> int: Find the index of the given element in the array. Log specific edge cases for debugging and tracing purposes. Args: array: List of integers in which to search for the query. query: Integer element we are searching for. Returns: The index of the first occurrence of the query element, or -1 if the element is not found. In all cases, provide logs of identified edge cases and search progress. pass ``` Input * `array` - List of integers. * `query` - An integer to search for in the array. Output * Return the index of the first occurrence of the query element. * Return -1 if the element is not present in the array. Constraints * The array can have up to `10^5` elements. * Each element in the array can be an integer between `-10^6` and `10^6`. Example ```python assert enhanced_linear_search([], 1) == -1 # Should log: \\"Array is empty.\\" assert enhanced_linear_search([1, 2, 3, 4, 5], 3) == 2 # Should log: \\"Element 3 found at index 2.\\" assert enhanced_linear_search([1, 2, 3, 4, 5], 6) == -1 # Should log: \\"Element 6 not found.\\" assert enhanced_linear_search([1, 2, 2, 2, 3], 2) == 1 # Should log: \\"Element 2 found at index 1.\\" # Should log: \\"Duplicate element 2 found at index 2.\\" # Should log: \\"Duplicate element 2 found at index 3.\\" ``` Requirements Make sure to include detailed comments and clear logs/messages.","solution":"from typing import List def enhanced_linear_search(array: List[int], query: int) -> int: Find the index of the given element in the array. Log specific edge cases for debugging and tracing purposes. Args: array: List of integers in which to search for the query. query: Integer element we are searching for. Returns: The index of the first occurrence of the query element, or -1 if the element is not found. In all cases, provide logs of identified edge cases and search progress. if not array: print(\\"Array is empty.\\") return -1 first_occurrence = -1 for index, elem in enumerate(array): if elem == query: if first_occurrence == -1: first_occurrence = index print(f\\"Element {query} found at index {index}.\\") else: print(f\\"Duplicate element {query} found at index {index}.\\") if first_occurrence == -1: print(f\\"Element {query} not found.\\") return first_occurrence"},{"question":"# Bit Manipulation Operations - Advanced Problem Given the fundamental bit manipulation functions `get_bit`, `set_bit`, `clear_bit`, and `update_bit`, your task is to implement the following function: **Function Name**: `is_power_of_two(num)` **Objective**: Determine if the given integer `num` is a power of two using bitwise operations. # Input Format - The function `is_power_of_two` takes a single integer `num` as its parameter. # Output Format - The function should return `True` if `num` is a power of two and `False` otherwise. # Constraints - Do not use any loops or recursion. - Use the provided bit manipulation functions wherever necessary. - You may assume `num` is a non-zero positive integer. # Examples 1. `is_power_of_two(4)` should return `True` because 4 (0100 in binary) is a power of two. 2. `is_power_of_two(6)` should return `False` because 6 (0110 in binary) is not a power of two. 3. `is_power_of_two(16)` should return `True` because 16 (10000 in binary) is a power of two. # Scenario You are working on a low-level system diagnostic tool that needs to check if certain memory sizes conform to power-of-two sizes for optimized allocation. Implement `is_power_of_two` with bitwise operations to ensure the fastest and most efficient check possible. # Notes - A number `num` is a power of two if and only if there is exactly one bit set in its binary representation (i.e., `num` & (`num` - 1) == 0) and `num` > 0. **Hint**: Use the \'clear_bit\' or other bit manipulation functions to help achieve this.","solution":"def is_power_of_two(num): Determine if the given integer num is a power of two using bitwise operations. if num <= 0: return False return (num & (num - 1)) == 0"},{"question":"# Question: You are given a binary tree. The height of a binary tree is defined as the number of edges in the longest path from the tree\'s root to a leaf. An empty tree has height 0, a tree with one node has height 0, a tree with a root and one or more children has height 1, and so on. # Task: Write a function `maxHeight` that computes the height of a given binary tree. # Function Signature: ```python def maxHeight(root: \'Node\') -> int: # Your implementation here ``` # Input: * `root (Node)`: The root node of the binary tree, or `None` if the tree is empty. # Output: * Returns an integer, the height of the tree. # Example: ```python # Example usage: # Binary tree: # 5 # / # 3 8 # / / # 1 4 7 12 # # 15 # # The height of this tree is 3 # Node class definition class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right root = Node(5) root.left = Node(3) root.right = Node(8) root.left.left = Node(1) root.left.right = Node(4) root.right.left = Node(7) root.right.right = Node(12) root.right.right.right = Node(15) # Test function print(maxHeight(root)) # Output: 3 ``` # Constraints: * You may assume the input tree does not contain any cycles. * The number of nodes in the tree is in the range [0, 10^4]. # Additional Information: * The algorithm should run efficiently on very large trees. * Consider edge cases such as an empty tree or a tree with just one node.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxHeight(root: \'Node\') -> int: if root is None: return 0 left_height = maxHeight(root.left) right_height = maxHeight(root.right) return 1 + max(left_height, right_height)"},{"question":"Ternary Search Implementation and Optimization Objective Implement an efficient search function using the ternary search algorithm. Your implementation should handle edge cases and be optimized for performance. Scenario You work at a tech company that needs an efficient search algorithm for their sorted datasets. Your task is to implement a reliable and optimized ternary search function. Requirements 1. Implement the `ternary_search` function to find the index of a given key in a sorted array. 2. Optimize the function to handle edge cases and improve performance wherever possible. 3. Ensure your algorithm is robust and debug any issues present in the given code snippet. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. If the index is not in the range left..right (ie. left <= index <= right) returns -1. ``` Expected Input and Output - **Input**: - `left` (int): Initial left boundary of the search (0 for full array search). - `right` (int): Initial right boundary of the search (len(arr) - 1 for full array search). - `key` (int): The value to be searched for. - `arr` (List[int]): A list of integers sorted in ascending order. - **Output**: - Returns the index of the key if found. - Returns -1 if the key is not found or if the index is out of the range (left..right). Constraints - The array will contain up to 10⁶ elements. - The elements in the array will be in the range of -10⁹ to 10⁹. - The array will be sorted in ascending order. Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 assert ternary_search(0, len(arr) - 1, key, arr) == 4 key = 11 assert ternary_search(0, len(arr) - 1, key, arr) == -1 ``` Performance Requirements - Your implementation should run in O(log₃(N)) time complexity. - The space complexity should remain O(1). Additional Guidelines - Carefully handle edge cases, including when the array is empty, or the key is not present in the array. - Make sure the function returns correct and expected results in all cases.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. If the index is not in the range left..right (ie. left <= index <= right) returns -1. while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Binary Tree Preorder Traversal You are given a binary tree represented by its root node. The goal is to traverse the tree in preorder (root, left, right) and return an array of the visited node values. Function Signature ```python def binary_tree_preorder(root: Node) -> List[int]: pass ``` Input * `root`: The root node of a binary tree, which is an instance of `Node` or `None` if the tree is empty. Output * A list of integers representing the node values in preorder traversal order. Constraints * The number of nodes in the tree is in the range [0, 10000]. * Node values are unique and are within a range that fits standard integer type. Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: # Input: root = [1, None, 2, 3] # Representation: # 1 # # 2 # / # 3 # Output: [1, 2, 3] root = Node(1, None, Node(2, Node(3))) assert binary_tree_preorder(root) == [1, 2, 3] # Example 2: # Input: root = [1, 2, 3, 4, 5, 6, 7] # Representation: # 1 # / # 2 3 # / / # 4 5 6 7 # Output: [1, 2, 4, 5, 3, 6, 7] root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) assert binary_tree_preorder(root) == [1, 2, 4, 5, 3, 6, 7] ``` **Notes**: * You can choose to implement the solution using either iterative or recursive methods. * Optimal solutions should aim to handle edge cases and be efficient in both time and space complexities.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_preorder(root: Optional[Node]) -> List[int]: Returns the preorder traversal of the binary tree. if root is None: return [] result = [] def preorder_traversal(node): if node: result.append(node.val) # Visit the root preorder_traversal(node.left) # Traverse left subtree preorder_traversal(node.right) # Traverse right subtree preorder_traversal(root) return result"},{"question":"Implement a Custom Stack Objective You are required to implement a custom Stack class using an underlying data structure of your choice (either array or linked list). Your implementation should closely mimic the operations of a classical stack. This exercise is designed to evaluate your understanding of stack operations, their time complexities, error handling, and your ability to implement robust data structures. Requirements Implement a Python class `CustomStack` with the following methods: * `__init__(max_size: int)`: Initialize the stack with a maximum size constraint. * `push(value: int) -> None`: Add a new element `value` to the top of the stack. If the stack is full, ignore the push and do nothing. * `pop() -> int`: Remove the top element of the stack and return it. If the stack is empty, return -1. * `peek() -> int`: Return the top element of the stack without removing it. If the stack is empty, return -1. * `is_empty() -> bool`: Return `True` if the stack is empty, otherwise return `False`. * `is_full() -> bool`: Return `True` if the stack is full, otherwise return `False`. Constraints * The stack will store integer values. * Ensure your implementation is efficient with respect to both time and space. * Handle edge cases such as attempting to pop from an empty stack or pushing into a full stack without crashing. * Your solution should avoid using Python list methods that would provide built-in stack functionality directly (i.e., avoid using methods like append(), pop(), etc. directly on lists). Example ```python stack = CustomStack(3) # Create a stack with a maximum size of 3 stack.push(10) stack.push(20) print(stack.peek()) # Output: 20 stack.push(30) print(stack.is_full()) # Output: True stack.push(40) # Should not add element as stack is full print(stack.pop()) # Output: 30 print(stack.pop()) # Output: 20 print(stack.is_empty())# Output: False print(stack.pop()) # Output: 10 print(stack.peek()) # Output: -1 (stack is empty) print(stack.pop()) # Output: -1 (stack is empty) ``` Good Luck!","solution":"class CustomStack: def __init__(self, max_size: int): self.stack = [] self.max_size = max_size def push(self, value: int) -> None: if len(self.stack) < self.max_size: self.stack.append(value) def pop(self) -> int: if self.is_empty(): return -1 return self.stack.pop() def peek(self) -> int: if self.is_empty(): return -1 return self.stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0 def is_full(self) -> bool: return len(self.stack) == self.max_size"},{"question":"**Problem Statement**: Given an array of integers where every element appears exactly three times except for one element that appears exactly once, write a function to find that single one. You must implement your solution with a linear runtime complexity and without using extra memory. **Function Signature**: ```python def find_unique_element(nums: list[int]) -> int: pass ``` **Input**: * `nums` (List[int]): A list of integers where every element appears exactly three times except for one element which appears exactly once. The size of the list is at least 4 and at most 10^4 elements. **Output**: * Returns the integer that appears exactly once in the list. **Example**: ```python # Example 1: nums = [2, 2, 3, 2] print(find_unique_element(nums)) # Output should be 3 # Example 2: nums = [0, 1, 0, 1, 0, 1, 99] print(find_unique_element(nums)) # Output should be 99 ``` **Constraints**: * The input list `nums` will always have exactly one element that appears once while all other elements appear three times. * The solution should have a linear runtime complexity. * No extra memory should be used (i.e., the space complexity should be constant). **Context**: You work as a software engineer at a tech company, where you\'ve been tasked with handling data streams that conform to the specified pattern. The efficiency of your solution is crucial to ensure system performance under load.","solution":"def find_unique_element(nums: list[int]) -> int: Finds the element in the list that appears exactly once while all other elements appear three times. The solution has a linear runtime complexity and constant space complexity. # Initialize variables to store bits representation. once = 0 twice = 0 for num in nums: # `~once & num`: elements reach this line only if they are not in `once` # `& ~twice`: elements reach this line only if they are not in `twice` once = ~twice & (once ^ num) # `~twice & num`: elements reach this line only if they are not in `twice` # `& ~once`: elements reach this line only if they are not in `once` twice = ~once & (twice ^ num) return once"},{"question":"# Separate Chaining Hash Table with Resizing Design and implement an improved version of a `SeparateChainingHashTable` that automatically resizes itself when a critical load factor is reached. Ensuring that the hash table remains efficient even if the number of items exceeds its initial capacity. Implement the following key functionalities: Requirements: * **Initialization**: Initialize with a default size of 11 buckets and a load factor of 0.75 (resize and rehash when the number of entries exceeds `0.75 * number of buckets`). * **Methods to Implement**: * `put(self, key, value)`: Adds or updates a key-value pair. * `get(self, key)`: Returns the value associated with a key. * `del_(self, key)`: Deletes the key-value pair by key. * `resize_and_rehash(self)`: Doubles the number of buckets and rehashes all items when load factor is exceeded. Constraints: * **Input**: Assume keys will be strings and values will be integers. * **Output**: Follow the specified functionalities and their expected behaviors. * **Performance**: Ensure average-case constant time complexity for `put`, `get`, and `del_`. Example Usage: ```python >>> table = ResizableSeparateChainingHashTable() # Create a new, empty map. >>> table.put(\'a\', 1) # Add a new key-value pair. >>> table.put(\'b\', 2) >>> table.put(\'c\', 3) >>> table.get(\'b\') # Get value by key. 2 >>> len(table) # Return the number of key-value pairs stored in the map. 3 >>> table.del_(\'b\') # Delete key-value pair. >>> table.get(\'b\') is None # Return `None` if a key doesn\'t exist. True >>> len(table) # Check size after deletion. 2 ```","solution":"class ResizableSeparateChainingHashTable: def __init__(self, initial_capacity=11, load_factor=0.75): self.capacity = initial_capacity self.load_factor = load_factor self.size = 0 self.buckets = [[] for _ in range(self.capacity)] def put(self, key, value): if self.size / self.capacity >= self.load_factor: self.resize_and_rehash() index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def resize_and_rehash(self): old_buckets = self.buckets self.capacity *= 2 self.buckets = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value) def _hash(self, key): return hash(key) % self.capacity def __len__(self): return self.size"},{"question":"You are given a list that may contain duplicates. Your task is to implement a function that returns a new list with all duplicates removed, preserving the order of their first occurrence. # Function Signature ```python def remove_duplicates_efficient(array: List[Any]) -> List[Any]: ``` # Input Format - `array`: A list of elements that can be integers, strings, booleans, or any other hashable types. The length of the list can be up to 10^5 elements. # Output Format - A list with duplicates removed from the input list, with the order of the first occurrence preserved. # Constraints 1. The elements in the list are hashable and can be compared using equality. 2. The length of the list is within the range [0, 10^5]. # Performance Requirements - Your solution must be more efficient than O(n^2) in terms of time complexity. # Example ```python Input: [1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \\"hey\\", \\"hello\\", True] ``` # Explanation In the given example, the function will remove duplicates while maintaining the order of their first appearance. # Guidelines - Utilize a data structure that supports efficient membership checking and update operations to improve the performance of your solution. # Note Make sure to handle edge cases such as an empty list, lists with all unique elements, and lists with only duplicates.","solution":"def remove_duplicates_efficient(array): Takes a list \'array\' and returns a new list with duplicates removed, preserving the order of their first occurrence. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Question: Stutter Stack Manipulation You are given a stack with N integer values. Your task is to write a Python function `custom_stutter(stack, use_queue)` that takes a stack and a boolean flag `use_queue` as input and replaces every value in the stack with two occurrences of that value. Specifically: * If `use_queue` is `True`, utilize a queue to help you manipulate the stack. * If `use_queue` is `False`, use another stack to help you manipulate the stack. **Input**: - A list `stack` of integers: This represents the stack where the last element is the top of the stack. - A boolean `use_queue`: Determines whether to use a queue or a stack for auxiliary storage. **Output**: - A list that represents the modified stack where every integer has two occurrences, preserving original order. **Constraints**: - The stack can have at most (10^4) elements. - The stack elements are all integers. **Example**: ```python stack = [3, 7, 1, 14, 9] use_queue = True custom_stutter(stack, use_queue) # Expected Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [3, 7, 1, 14, 9] use_queue = False custom_stutter(stack, use_queue) # Expected Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` **Function Signature**: ```python def custom_stutter(stack: List[int], use_queue: bool) -> List[int]: pass ``` Write a solution that efficiently performs the required stack manipulation given the constraints.","solution":"from collections import deque from typing import List def custom_stutter(stack: List[int], use_queue: bool) -> List[int]: if use_queue: aux = deque() else: aux = [] while stack: value = stack.pop() if use_queue: aux.appendleft(value) aux.appendleft(value) else: aux.append(value) aux.append(value) if use_queue: while aux: stack.append(aux.popleft()) else: while aux: stack.append(aux.pop()) return stack"},{"question":"You are required to implement additional functionalities for the `BinaryHeap` class to support more advanced operations. Specifically, you need to implement a method that merges another binary heap into the current heap while maintaining the heap property. # Function Signature: ```python def merge(self, other_heap: \\"BinaryHeap\\") -> None: ... ``` # Input: - `other_heap`: Another instance of `BinaryHeap`. # Output: - The method should modify the current heap in-place by merging elements of `other_heap`. # Constraints: - Both heaps do not contain duplicate elements. - The heaps must maintain the Min Heap property after merging. - The size of the combined heaps will not exceed 10^5. # Example: ```python bh1 = BinaryHeap() bh1.insert(5) bh1.insert(7) bh1.insert(10) bh2 = BinaryHeap() bh2.insert(3) bh2.insert(6) bh2.insert(9) bh1.merge(bh2) # After the merge, bh1 should contain all elements: [3, 5, 6, 7, 9, 10] # and it should maintain the heap property. ``` # Requirements: 1. Thoroughly test edge cases, such as: - Merging with an empty heap. - Merging into an empty heap. - A few elements versus many elements in either heap. 2. Ensure the solution efficiently handles merging within the constraints provided. # Explanation: To achieve the merge functionality, consider adding each element from the `other_heap` into `self.heap` using the `insert` method. Alternatively, you could concatenate the arrays representing the heaps and then build the Min Heap from scratch to optimize the heap construction.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, item): heapq.heappush(self.heap, item) def merge(self, other_heap): Merges another binary heap into the current heap while maintaining the heap property. for item in other_heap.heap: heapq.heappush(self.heap, item)"},{"question":"# BST Iterator Implementation You are given the implementation of a BST Iterator that iterates over the nodes of a binary search tree (BST) in sorted order. Your task is to extend this implementation by adding functionality to get the k-th smallest element in the BST. Ensure your solution takes into consideration the efficiency and robustness against edge cases. Class `BSTIterator` ```python class BSTIterator: def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self): return bool(self.stack) def next(self): node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val ``` Function Signature ```python def get_kth_smallest(self, k: int) -> int: Given a BST iterator, implement the method `get_kth_smallest` which returns the k-th smallest element in the BST, where k is a positive integer. Assume the `BSTIterator` object has been initialized successfully with a valid BST root. :param self: The instance of BSTIterator :param k: The k-th index (1-based) of the element to retrieve :return: The k-th smallest element in the BST # Example # A sample usage of the BSTIterator might be: # bst = BSTIterator(root) # kth_smallest_element = bst.get_kth_smallest(3) # assuming root is the root of the following BST: # 3 # / # 1 4 # # 2 # The call bst.get_kth_smallest(3) would return 3 as the third smallest element. ``` Constraints * The value of `k` will be in the range `[1, n]` where `n` is the number of elements in the BST. * Ensure your solution handles edge cases like an empty BST or k being out of the bounds properly.","solution":"class BSTIterator: def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self): return bool(self.stack) def next(self): node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val def get_kth_smallest(self, k: int) -> int: count = 0 while self.has_next(): val = self.next() count += 1 if count == k: return val raise ValueError(\\"k is out of the bounds of the BST\\")"},{"question":"# Question You are tasked with adding a new feature to the existing Min Heap data structure. Implement a method that merges two min heaps into one. The new min heap should maintain the properties of a binary min heap. Class Definitions and Definitions: You are provided with the `BinaryHeap` class implementation as described below. Extend this class to implement the additional feature. ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] # Existing methods ... def perc_up(self, i): ... def insert(self, val): ... def min_child(self, i): ... def perc_down(self, i): ... def remove_min(self): ... ``` # Implementation Implement the following method inside the `BinaryHeap` class: ```python def merge(self, other_heap): Merges the current heap with another min heap and maintains the heap property. Args: other_heap (BinaryHeap): another instance of BinaryHeap to be merged with. Returns: None pass ``` # Constraints 1. Both heaps (`self` and `other_heap`) use zero-indexed lists with `0` as a dummy element (i.e., [0, ...]) for easier calculations. 2. The method should maintain valid min heap properties after merging. 3. You should not modify the `other_heap` object. # Example ```python heap1 = BinaryHeap() heap2 = BinaryHeap() # Inserting elements to heap1: 4, 50, 7, 55, 90, 87 for i in [4, 50, 7, 55, 90, 87]: heap1.insert(i) # Inserting elements to heap2: 2, 3, 1 for i in [2, 3, 1]: heap2.insert(i) # Merging heap2 into heap1 heap1.merge(heap2) # After merging, heap1 should be a valid min heap print(heap1.heap) ``` # Expected Output ```plain [0, 1, 3, 2, 50, 7, 87, 55, 90, 4] ``` # Additional Information - You may refer to existing methods in the class to facilitate your implementation. - Pay attention to edge cases where one or both heaps are empty.","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): retval = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return retval def merge(self, other_heap): for val in other_heap.heap[1:]: self.insert(val)"},{"question":"You are provided with a binary tree, and your task is to convert it into a doubly linked list (DLL). The nodes in the list should follow the in-order sequence of the binary tree. Once converted, you need to implement a function that prints out the values of the DLL in order. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: pass def print_tree(root: TreeNode) -> None: pass ``` # Input - `root` (TreeNode): The root of the binary tree. This value can be `None` which represents an empty tree. # Output - The function `bin_tree_to_list` should convert the given binary tree to a doubly linked list and return the head of the list. - The function `print_tree` should print each value in the doubly linked list from head to tail. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes (-10000 <= node.val <= 10000) are unique. - Aim for O(n) time complexity where n is the number of nodes in the tree. # Example ```python # Example Binary Tree # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) head = bin_tree_to_list(root) print_tree(head) # Expected Output: 1 2 3 4 5 ``` # Explanation - The binary tree is converted into a doubly linked list maintaining the in-order traversal order. - The `print_tree` function prints out the values of this doubly linked list from leftmost to rightmost. Ensure edge cases are handled, such as an empty tree or a tree with a single node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None # Helper function to perform in-order traversal and connect nodes def inorder_traversal(node): nonlocal head, prev if not node: return # Traverse left subtree inorder_traversal(node.left) # No previous node implies this is the head of the DLL if prev is None: head = node else: # Link the previous node with the current node prev.right = node node.left = prev # Update the previous node to current node prev = node # Traverse right subtree inorder_traversal(node.right) head = None prev = None inorder_traversal(root) return head def print_tree(root: TreeNode) -> None: current = root while current: print(current.val, end=\\" \\") current = current.right print()"},{"question":"# Gnome Sort Enhancement and Analysis Gnome Sort is a simple sorting algorithm, characterized by repeatedly comparing each element with its predecessor and swapping them if they are out of order. The algorithm continues from the beginning if needed, resembling a \\"drunken baboon\\" that sorts items in its path. Despite its simplicity, Gnome Sort exhibits poor performance for larger datasets due to its quadratic time complexity in the worst case. Your task is to improve the implementation of Gnome Sort and analyze its performance. Here are the steps to complete this task: 1. **Function Enhancement**: Write a function `enhanced_gnome_sort(arr)`, which includes: * Optimization to efficiently handle large datasets by incorporating a mechanism to avoid unnecessary comparisons. * Thorough error and edge case handling. 2. **Edge Case Consideration**: * You should consider and handle arrays that are: - Already sorted. - Reverse sorted. - Containing duplicate elements. - All elements are the same. 3. **Performance Analysis**: * Following your implementation, analyze both the optimized time and space complexity of your function. * Compare the complexity against the provided `gnome_sort` version. # Constraints * Array elements are integers. * `0 <= len(arr) <= 10^5` * `arr[i]` can be any integer within the range of standard integer values. # Input * A single list `arr` of integers. # Output * A sorted list of integers. # Example **Input**: ```python arr = [34, 2, 25, -4, 17] ``` **Output**: ```python [-4, 2, 17, 25, 34] ``` # Additional Notes * Consider adding comments to explain the steps and improvements made in your enhanced implementation of the Gnome Sort algorithm. * Write unit tests to validate the correctness of your `enhanced_gnome_sort` function using different test cases including edge cases.","solution":"def enhanced_gnome_sort(arr): An enhanced Gnome Sort function to sort elements in increasing order. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Cycle Detection in a Directed Graph Using DFS You are given a directed graph represented as an adjacency list. Your task is to write a function `contains_cycle(graph)` that determines whether the graph contains a cycle. Function Signature ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` Input - `graph`: A dictionary where the keys are vertex identifiers (strings) and the values are lists of adjacent vertices (strings). Output - Returns `True` if the graph contains a cycle, `False` otherwise. Constraints - The number of vertices, V, will be in the range [1, 10^3]. - The number of edges, E, will be in the range [0, 10^4]. - The graph will be directed and may contain isolated vertices. Example # Input: ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} ``` # Output: ```python True ``` **Explanation**: The cycle in the graph is B -> D -> E -> B. # Additional Context You may use the following helper enumeration and function: ```python from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): # Implemented as described in the assessment ``` Write a function `contains_cycle(graph)` that utilizes the `is_in_cycle` helper function to determine if the provided directed graph contains a cycle.","solution":"from enum import Enum from typing import List, Dict class TraversalState(Enum): WHITE = 0 # Vertex has not been visited yet GRAY = 1 # Vertex is being visited (in the current path) BLACK = 2 # Vertex and all its descendants have been completely visited def is_in_cycle(graph, traversal_states, vertex): # Mark the current node as being visited traversal_states[vertex] = TraversalState.GRAY # Traverse all the adjacent vertices for neighbor in graph.get(vertex, []): if traversal_states[neighbor] == TraversalState.GRAY: # Found a cycle return True if traversal_states[neighbor] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, neighbor): return True # Mark the current node as completely visited traversal_states[vertex] = TraversalState.BLACK return False def contains_cycle(graph: Dict[str, List[str]]) -> bool: # Initialize all vertices as not visited traversal_states = {vertex: TraversalState.WHITE for vertex in graph} # Perform DFS for each vertex to detect a cycle for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"In this coding assessment, you are required to implement an enhanced version of Dijkstra\'s Algorithm using a priority queue (min-heap) for improved efficiency. The provided implementation of Dijkstra\'s Algorithm uses nested loops which result in a time complexity of (O(V^2)). By using a priority queue, we can reduce this to (O(E log V)), where (E) is the number of edges and (V) is the number of vertices. # Task You need to write a function `dijkstra_priority_queue(graph, src)` that performs Dijkstra\'s Algorithm using a priority queue to find the shortest path from a given source node to all other nodes. # Input - `graph`: A dictionary where keys are node identifiers and values are lists of tuples `(neighbor, weight)` representing the neighbors of a node and the weights of the corresponding edges. - `src`: An integer representing the source node. # Output - Return a dictionary where the keys are the nodes and the values are the shortest path distances from the source node to each respective node. # Example ```python def dijkstra_priority_queue(graph, src): import heapq # Initialize distances to infinity and priority queue dist = {node: float(\'inf\') for node in graph} dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist # Example usage graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } src = 0 print(dijkstra_priority_queue(graph, src)) # Expected output: {0: 0, 1: 3, 2: 1, 3: 4} ``` # Constraints * Each edge weight is a non-negative integer. * The graph is connected, i.e., there is a path from the source node to every other node. * It is guaranteed that the input graph will have fewer than 10,000 nodes.","solution":"def dijkstra_priority_queue(graph, src): import heapq # Initialize distances to infinity and priority queue dist = {node: float(\'inf\') for node in graph} dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"# Union-Find Application: Social Network Connectivity In a social network, people are represented as nodes and their connections (friendships) as edges. We want to evaluate the connectivity in the network as new friendships are formed. Specifically, you are to write a function that determines the number of connected components in the network after each new friendship is added. Implement the following function: ```python def social_network_connections(people, friendships): Given the number of people and a list of friendships, return the number of connected components after each friendship is added. Args: - people (int): the number of people in the network, labeled from 0 to people-1. - friendships (List[Tuple[int, int]]): a list of tuples where each tuple represents a new friendship. Returns: - List[int]: a list of integers where the i-th integer represents the number of connected components after the i-th friendship is added. pass ``` Input and Output Formats: * **Input**: * `people`: an integer representing the number of people, labeled from `0` to `people-1`. * `friendships`: a list of tuples, where each tuple `(a, b)` indicates a friendship between persons `a` and `b`. * **Output**: * A list of integers, where each integer represents the number of connected components after the corresponding friendship is added. Constraints: * `0 <= people <= 10^5` * `0 <= len(friendships) <= 10^5` * Multiple friendships between the same pair of people should be ignored. * Ensure optimal performance and consider edge cases like already connected components. Sample Scenario: Consider a scenario with 5 people and these friendships: ```python people = 5 friendships = [(0, 1), (1, 2), (3, 4), (2, 3)] ``` Initial state (everyone is isolated): Components: 5 After `(0, 1)`: Components: 4 After `(1, 2)`: Components: 3 After `(3, 4)`: Components: 2 After `(2, 3)`: Components: 1 Expected Output: `[4, 3, 2, 1]` Implement the function `social_network_connections` to solve this problem.","solution":"def social_network_connections(people, friendships): Given the number of people and a list of friendships, return the number of connected components after each friendship is added. Args: - people (int): the number of people in the network, labeled from 0 to people-1. - friendships (List[Tuple[int, int]]): a list of tuples where each tuple represents a new friendship. Returns: - List[int]: a list of integers where the i-th integer represents the number of connected components after the i-th friendship is added. parent = list(range(people)) rank = [0] * people num_components = people components = [] def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): nonlocal num_components root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 num_components -= 1 for a, b in friendships: union(a, b) components.append(num_components) return components"},{"question":"# Question **URL/File Path Combining Function Implementation** You are implementing a file system command-line utility that constructs absolute paths from given base paths and suffixes. Write a function `combine_path(base: str, suffix: str) -> str` that merges the base path and a suffix to form a valid path. This path must ensure there is exactly one slash between the base and suffix. # Requirements - **Input**: - `base`: A string representing the base path. This could be a URL or a directory path. - `suffix`: A string representing the part to be appended to the base path. This can also be a partial URL or directory path. - **Output**: - `result`: A string representing the combined path with exactly one slash between `base` and `suffix`. # Constraints - The strings `base` and `suffix` should be non-null. - The resulting path should not contain multiple slashes in a row (e.g., \\"///\\"). - Whitespace trailing in `suffix` should be ignored. - Assume no other special characters need to be handled. # Example - **Input**: `combine_path(\\"http://algorithms.com\\", \\"part\\")` - **Output**: `\\"http://algorithms.com/part\\"` - **Input**: `combine_path(\\"path/to/dir/\\", \\"file\\")` - **Output**: `\\"path/to/dir/file\\"` # Performance Requirements - The implementation should be efficient in both time and space, keeping complexity as low as possible. # Detailed Steps 1. Remove any trailing slashes from the `base`. 2. Remove any leading slashes and trailing whitespace from the `suffix`. 3. Concatenate `base` and `suffix` with a single slash. Implement the `combine_path` function in Python. ```python def combine_path(base: str, suffix: str) -> str: # Your implementation here ```","solution":"def combine_path(base: str, suffix: str) -> str: Combines base URL/path with suffix ensuring exactly one slash between them. base = base.rstrip(\'/\') suffix = suffix.lstrip().lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"# Subsets Generation (Combinatorial Algorithm) Problem Statement You are given a list of distinct integers `nums`. Write a function that returns all possible subsets (the power set) of `nums`. The solution set must not contain duplicate subsets. The subsets can be returned in any order. Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input - A list of distinct integers `nums` with `0 <= len(nums) <= 10`. Output - A list of lists, where each list is a possible subset of `nums`. Constraints - The total number of subsets for a list of length `n` is (2^n), which is feasible within the given constraints (`n <= 10`). - The input integers can be negative or positive. Example ```python assert generate_subsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert generate_subsets([]) == [[]] assert generate_subsets([4]) == [[], [4]] ``` Performance Requirements Your implementation should efficiently generate all subsets within the constraints and avoid duplicate computations. Additional Notes Consider handling edge cases such as empty list or list with a single element. Ensure the solution does not produce duplicate subsets and all subsets are accounted for.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets (the power set) of a list of distinct integers nums. result = [] def backtrack(start, path): # Add the current subset (path) to the result result.append(path.copy()) # Iterate over the possible next elements to include in the subset for i in range(start, len(nums)): # Include nums[i] in the subset path.append(nums[i]) # Recurse with updated current subset and starting index backtrack(i + 1, path) # Exclude nums[i] from the subset (backtrack) path.pop() # Start backtracking with an empty path backtrack(0, []) return result"},{"question":"You are given an array of integers where every element appears exactly three times except for one, which appears exactly once. Your task is to implement a function to find that single element. Your solution must have a linear runtime complexity, and you must not use any additional data structures or memory. # Function Signature ```python def find_unique_element(nums: List[int]) -> int: # Your code here ``` # Input - `nums`: A list of integers where every integer appears exactly three times except for one integer that appears exactly once. * Constraints: - (1 leq text{len}(nums) leq 3 times 10^4) - (-2^{31} leq text{nums[i]} leq 2^{31}-1) # Output - Returns an integer representing the unique element that appears exactly once. # Example ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_element([-2, -2, 1, -2]) == 1 ``` # Explanation - In Example 1, the element `3` appears only once while all other elements `2` appear three times. - In Example 2, the element `99` appears only once while all other elements `0` and `1` appear three times. - In Example 3, the element `1` appears only once while the element `-2` appears three times. Your goal is to fully implement the function while considering edge cases and ensuring efficient performance.","solution":"def find_unique_element(nums): Find the element that appears exactly once in a list where all other elements appear exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Question: Compute Large Power Modulus **Scenario**: You are tasked with implementing a modular exponentiation function. This is often used in cryptographic applications where numbers can be exceedingly large. The modulus operation helps in keeping numbers manageable. **Function Description**: Implement the `modular_exponential` function to compute ((text{base} ^ text{exponent}) % text{mod}). Your function should handle very large exponents efficiently using the technique called \\"Exponentiation by Squaring\\". **Input**: - `base` (integer): The base number for exponentiation. - `exponent` (integer): The exponent to which the base is raised (must be a non-negative integer). - `mod` (integer): The modulus used to keep numbers manageable (must be greater than 0). **Output**: - A single integer, which is the result of ((text{base} ^ text{exponent}) % text{mod}). **Constraints**: - (0 leq text{base} leq 10^9) - (0 leq text{exponent} leq 10^9) - (1 leq text{mod} leq 10^9) **Example**: ``` modular_exponential(2, 10, 1000) => 24 Explanation: 2^10 = 1024, and 1024 % 1000 = 24 modular_exponential(3, 7, 13) => 3 Explanation: 3^7 = 2187, and 2187 % 13 = 3 modular_exponential(5, 0, 7) => 1 Explanation: Any number to the power of 0 is 1, and 1 % 7 = 1 ``` **Edge Cases**: - Consider the base of 0 with a non-zero exponent. - Consider both the base and exponent of 0. **Notes**: - Ensure that the function has efficient performance, ideally O(log n), where n is the exponent. - Handle corner cases such as large numbers gracefully without overflow errors.","solution":"def modular_exponential(base, exponent, mod): Computes (base ^ exponent) % mod using exponentiation by squaring. Parameters: base (int): The base number for exponentiation. exponent (int): The exponent to which the base is raised (non-negative integer). mod (int): The modulus used to keep numbers manageable (greater than 0). Returns: int: The result of (base ^ exponent) % mod. if mod == 1: return 0 result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Scenario You are tasked with securing a government art gallery that has several exhibition rooms. Each room has a distinct amount of artwork. You need to implement an efficient security algorithm to determine the maximum value of artwork that can be secured without alarming the security systems. The constraint is that you cannot secure two consecutive rooms on the same day. # Task Implement a function `secure_art_gallery(art_values: List[int]) -> int` that returns the maximum value of artwork you can secure without setting off any alarms. # Input: * A list of non-negative integers `art_values` where each integer represents the value of the artwork in each room. # Output: * An integer representing the maximum value of artwork that can be secured. # Constraints: * `0 <= len(art_values) <= 10^4` * `0 <= art_values[i] <= 10^4` # Example: ```python assert secure_art_gallery([2, 7, 9, 3, 1]) == 12 assert secure_art_gallery([5, 3, 4, 11, 2]) == 16 assert secure_art_gallery([3, 2, 5, 10, 7]) == 15 assert secure_art_gallery([]) == 0 assert secure_art_gallery([1]) == 1 ``` # Notes: 1. The function should have O(n) time complexity and O(1) space complexity. 2. Make sure to handle edge cases like an empty list or a list with a single element appropriately.","solution":"from typing import List def secure_art_gallery(art_values: List[int]) -> int: Returns the maximum value of artwork that can be secured without alarming the security systems. if not art_values: return 0 if len(art_values) == 1: return art_values[0] prev2 = 0 prev1 = 0 for value in art_values: current = max(prev1, prev2 + value) prev2 = prev1 prev1 = current return prev1"},{"question":"# Context In scenarios where built-in libraries for large integer computations are restricted, implementing arithmetic operations manually can be particularly useful. This exercise helps to solidify understanding of underlying principles by coding a solution from scratch. # Question Implement a function `multiply(num1: str, num2: str) -> str` that performs multiplication on two non-negative integers provided as strings without converting them to integers directly. Your implementation should follow these guidelines: - **Input**: * `num1` and `num2` as non-negative integer strings with lengths up to 109. * Both `num1` and `num2` contain only digits (`0-9`). * Both `num1` and `num2` do not contain any leading zero (except when the number itself is `0`). - **Output**: * A string representing the product of `num1` and `num2`. # Constraints - Do not use any built-in `BigInteger` library or convert the inputs to integers directly. - Ensure that your solution is efficient and handles up to 109-digit long strings within a reasonable time frame. # Example ```python assert multiply(\\"1\\", \\"23\\") == \\"23\\" assert multiply(\\"23\\", \\"23\\") == \\"529\\" assert multiply(\\"100\\", \\"23\\") == \\"2300\\" assert multiply(\\"100\\", \\"10000\\") == \\"1000000\\" ``` # Requirement * Ensure that your function efficiently handles different sized inputs and edge cases like multiplication with zero. # Hint * Think about how you would handle manual multiplication as done on paper and simulate this in your code.","solution":"def multiply(num1, num2): # Edge case: if either num1 or num2 is zero, return \'0\' if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result as a list of zeros result = [0] * (len(num1) + len(num2)) # Reverse both strings to facilitate multiplication from right to left num1 = num1[::-1] num2 = num2[::-1] # Perform the multiplication for i in range(len(num1)): for j in range(len(num2)): mult = int(num1[i]) * int(num2[j]) result[i + j] += mult # Carry over the excess to the next place result[i + j + 1] += result[i + j] // 10 result[i + j] = result[i + j] % 10 # Remove leading zeros and convert to string while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"# Summary of Continuous Ranges in a Sorted List You are given a sorted list of integers `arr`, which does not contain duplicates. Your task is to implement a function `summarize_ranges(arr)` that returns a list summarizing all the continuous intervals in the input list. **Function Signature**: ```python def summarize_ranges(arr: List[int]) -> List[str]: ``` **Input**: - `arr`: A list of sorted integers without duplicates. **Output**: - A list of strings where each string represents a summarized range. - If the range contains only one number, represent it as `\\"x\\"`. - If the range contains more than one number, represent it as `\\"x-y\\"`. **Constraints**: - The length of `arr` will be between 0 and 10^4. - The integers provided in `arr` could be any valid integer values within the range of `[-10^5, 10^5]`. **Examples**: ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([1, 3, 5, 6, 7, 9]) == [\\"1\\", \\"3\\", \\"5-7\\", \\"9\\"] assert summarize_ranges([]) == [] assert summarize_ranges([10]) == [\\"10\\"] assert summarize_ranges([0, 2, 4, 6, 8]) == [\\"0\\", \\"2\\", \\"4\\", \\"6\\", \\"8\\"] ```","solution":"from typing import List def summarize_ranges(arr: List[int]) -> List[str]: Summarizes all the continuous intervals in a sorted list of integers. if not arr: return [] ranges = [] start = arr[0] end = arr[0] for i in range(1, len(arr)): if arr[i] == end + 1: end = arr[i] else: if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") start = arr[i] end = arr[i] if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Encoding and Decoding of Strings Scenario You are working on a data transmission project where you need to send lists of strings over a network. To simplify the transmission process, you decide to encode the list of strings into a single string before transmission and decode this string back into the original list on the receiving end. Task Write two functions `encode` and `decode`: 1. **encode**: Encodes a list of strings to a single string. 2. **decode**: Decodes a single string back to a list of strings. Function Specifications - **encode(strs: List[str]) -> str**: Takes a list of strings and encodes it into a single string. - **decode(string: str) -> List[str]**: Takes an encoded string and decodes it back to a list of strings. Input/Output Formats # `encode()` - **Input**: A list of strings `strs` where each string is any sequence of characters. - Example: `[\\"hello\\", \\"world\\"]` - **Output**: A single encoded string. - Example: `\\"5:hello5:world\\"` # `decode()` - **Input**: A single encoded string `s`. - Example: `\\"5:hello5:world\\"` - **Output**: A list of strings. - Example: `[\\"hello\\", \\"world\\"]` Constraints - Avoid delimiter conflicts by thinking about potential edge cases. - All input strings are valid ASCII strings. You are required to handle edge cases effectively and think about the performance implications of your functions. Here is the template you should use for your implementation: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your code here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your code here ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_strings = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 decoded_strings.append(s[i:i + length]) i += length return decoded_strings"},{"question":"You are tasked with implementing a function to compute the factorial of a non-negative integer `n`. Additionally, you have the option to compute this value modulo another integer `mod` if provided. Factorial computation can be an intensive operation, so consider efficiency in your implementation. You need to choose between an iterative or a recursive approach based on their characteristics. # Function Definition ```python def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of a non-negative integer n, optionally modulo \'mod\'. Parameters: n (int): a non-negative integer representing the number to compute the factorial of. mod (int, optional): a positive integer to compute the factorial modulo this value. Returns: int: the factorial of n modulo mod if mod is provided, otherwise just the factorial of n. Raises: ValueError: if \'n\' is negative or not an integer, or if \'mod\' is non-positive or not an integer. ``` # Example: ```python print(compute_factorial(5)) # Output: 120 print(compute_factorial(5, 3)) # Output: 0 (120 % 3 is 0) print(compute_factorial(0)) # Output: 1 ``` # Constraints * `0 <= n <= 10^6` * `1 <= mod <= 10^9` (if provided) # Notes * Consider both iterative and recursive methods and choose accordingly. * Pay attention to edge cases and validation of inputs.","solution":"def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of a non-negative integer n, optionally modulo \'mod\'. Parameters: n (int): a non-negative integer representing the number to compute the factorial of. mod (int, optional): a positive integer to compute the factorial modulo this value. Returns: int: the factorial of n modulo mod if mod is provided, otherwise just the factorial of n. Raises: ValueError: if \'n\' is negative or not an integer, or if \'mod\' is non-positive or not an integer. # Input validation if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") factorial = 1 if mod is None: for i in range(2, n + 1): factorial *= i else: for i in range(2, n + 1): factorial = (factorial * i) % mod return factorial"},{"question":"Implement Nearest Neighbor Classifier Context You are working on a simple classification system that uses a nearest neighbor algorithm to classify data points. Your task is to create a function that finds the nearest neighbor of a given input vector `x` from a training set `tSet`. Task Implement the `nearest_neighbor(x, tSet)` function provided in the code snippet. This function should take a vector `x` and a training set `tSet`, and return the value associated with the nearest vector in `tSet` to `x`. Input * `x` (tuple): An input vector to be classified. * `tSet` (dict): A training set where keys are tuples representing vectors, and values represent the associated classification label of the vectors. Output * The classification label from `tSet` of the vector nearest to `x`. Constraints * All vectors (including `x` and keys in `tSet`) have the same length. * `tSet` will contain at least one vector. * Elements of vectors are numeric (integers or floats). Example ```python x = (2, 3) tSet = { (1, 2): \\"A\\", (3, 4): \\"B\\", (5, 6): \\"C\\" } nearest_neighbor(x, tSet) # should return \\"A\\" ``` Requirements 1. Implement the `distance` function to calculate Euclidean distance between two vectors. 2. Implement the `nearest_neighbor` function to find the nearest neighbor and return its classification label.","solution":"import math def euclidean_distance(v1, v2): Calculates the Euclidean distance between two vectors v1 and v2. sum_squared_diff = sum((a - b) ** 2 for a, b in zip(v1, v2)) return math.sqrt(sum_squared_diff) def nearest_neighbor(x, tSet): Finds the nearest neighbor of vector x from the training set tSet. Returns the classification label of the nearest vector. nearest = None min_dist = float(\'inf\') for vec in tSet: dist = euclidean_distance(x, vec) if dist < min_dist: min_dist = dist nearest = vec return tSet[nearest]"},{"question":"# Problem: General Base Conversion and Validation You are tasked to implement two functions for converting integers to strings in arbitrary bases and vice-versa. To ensure robustness, include additional checks for validity and handle different edge cases. Function 1: `int_to_base_with_check(num: int, base: int) -> str` **Input**: * `num` - An integer which can be negative. * `base` - An integer representing the base (between 2 and 36). **Output**: * A string representing `num` in the specified `base`. **Constraints**: * `num` can be any integer. * `base` will be in the range [2, 36]. **Function 2: `base_to_int_with_check(num_str: str, base: int) -> int` **Input**: * `num_str` - A string representing the number in the specified `base`. * `base` - An integer representing the base (between 2 and 36). **Output**: * An integer representing the string `num_str` converted from the specified `base`. **Constraints**: * `num_str` will be a valid string representation in the given `base`. * `base` will be in the range [2, 36]. Requirements: 1. **Validation**: * Ensure base is within the [2, 36] range. * Ensure number strings do not contain invalid characters for the given base. 2. **Handling Negative Numbers**: * Support and correctly process negative integers. Example: ```python # Example usage assert int_to_base_with_check(5, 2) == \'101\' assert int_to_base_with_check(-5, 2) == \'-101\' assert base_to_int_with_check(\'101\', 2) == 5 assert base_to_int_with_check(\'-101\', 2) == -5 assert base_to_int_with_check(\'F\', 16) == 15 ``` Write robust implementations and handle edge cases as outlined above.","solution":"def int_to_base_with_check(num, base): Converts an integer to a string representation in the specified base. if not (2 <= base <= 36): raise ValueError(\\"Base must be in the range [2, 36]\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int_with_check(num_str, base): Converts a string representation of a number in an arbitrary base to an integer. if not (2 <= base <= 36): raise ValueError(\\"Base must be in the range [2, 36]\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {digit: index for index, digit in enumerate(digits[:base])} num_str = num_str.upper() negative = num_str[0] == \'-\' if negative: num_str = num_str[1:] num = 0 for char in num_str: if char not in value_map: raise ValueError(f\\"Character {char} is not valid for base {base}\\") num = num * base + value_map[char] return -num if negative else num"},{"question":"# Word Dictionary with Trie Structure Objective: Implement a `WordDictionary` class with efficient methods to add words and search for words using prefix matching and wildcard characters. Requirements: 1. **Function Implementations**: * `add_word(self, word: str) -> None`: Inserts a word into the dictionary. * `search(self, word: str) -> bool`: Returns `True` if the word (with optional wildcard `.`) is in the dictionary, otherwise returns `False`. Constraints: * Input string `word` will only contain lowercase alphabetical letters or the wildcard character `.` and can be of length up to 1000. * The total number of words added to the dictionary will not exceed `10^5`. Example: ```python # Initializing the dictionary word_dict = WordDictionary() # Adding words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Searching words print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True print(word_dict.search(\\"d..e\\")) # Output: False print(word_dict.search(\\"....\\")) # Output: False ``` Additional Context: * The method `add_word` should efficiently handle multiple insertions without significant delay for large datasets. * The method `search` should be able to handle and perform prefix matching with the `.` wildcard which can represent any letter. Performance Requirements: * The solution should aim for efficient space and time complexity, given the constraints on the number of words and length of each word. Implement the `WordDictionary` class below: ```python class WordDictionary: def __init__(self): # Initialize the root of the Trie pass def add_word(self, word: str) -> None: # Implementation for adding a word pass def search(self, word: str) -> bool: # Implementation for searching a word with or without wildcards pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.end_of_word return search_in_node(word, self.root)"},{"question":"You are given a linked list, which may contain a cycle. Your task is to write a function `find_cycle_start` that detects if a cycle exists and returns the node at which the cycle begins. If there is no cycle, the function should return `None`. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: pass ``` # Input * `head`: the head node of a linked list. # Output * The node where the cycle begins, or `None` if there is no cycle. # Constraints * The linked list may be empty (head is None). * The linked list\'s length can be arbitrary but will fit in memory. # Performance Requirements * The algorithm should run in O(n) time complexity. * The algorithm should use O(1) additional space. # Example Cases Example 1 Input: ``` 1 -> 2 -> 3 -> 4 -> 5 ^ v 8 <- 7 <- 6 ``` Output: Node with value `3` Example 2 Input: ``` A -> B -> C -> D -> E ^ v G <- F ``` Output: Node with value `C` Example 3 Input: ``` 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` Output: `None` (no cycle) # Explanation 1. Create a slow pointer (walker) and a fast pointer (runner). 2. Move the slow pointer one step at a time and the fast pointer two steps at a time. 3. If they both meet, a cycle exists. 4. To find the start of the cycle, reset one pointer to the head and move both pointers one step at a time until they meet again. Write the function `find_cycle_start(head: Node) -> Node` to implement this algorithm.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: if not head: return None slow, fast = head, head # Detect if a cycle exists using the Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: return None # No cycle # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are to implement a Priority Queue ADT from scratch, using a max-heap as the underlying data structure. A priority queue ensures that the element with the highest priority is dequeued first. # Class Definitions & Methods Implement a class `MaxHeapPriorityQueue` with the following methods: * `__init__(self)`: Initializes an empty priority queue. * `enqueue(self, item)`: Adds an item to the priority queue. * `dequeue(self)`: Removes and returns the item with the highest priority. * `peek(self)`: Returns the item with the highest priority without removing it. * `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. * `size(self)`: Returns the number of items in the queue. * `__iter__(self)`: An iterator returning elements in the priority queue order. # Requirements 1. Use a list to represent the heap and maintain the heap property. 2. Ensure that all operations (insertion, deletion) uphold the max-heap property. # Inputs and Outputs * `enqueue(item)`: Adds `item` to the queue. * `dequeue()`: Returns and removes the item with the highest priority. * `peek()`: Returns the item with the highest priority without removing it. * `is_empty()`: Returns a boolean indicating whether the queue is empty. * `size()`: Returns the count of items. # Constraints * The queue must support up to 10^4 operations efficiently. * Each item in the priority queue can be represented as a tuple `(priority, value)` where `priority` is an integer. # Example ```python # Define a priority queue pq = MaxHeapPriorityQueue() # Enqueue elements pq.enqueue((2, \'task2\')) pq.enqueue((1, \'task1\')) pq.enqueue((5, \'task5\')) # Peek at the highest priority item print(pq.peek()) # Outputs: (5, \'task5\') # Dequeue the highest priority item print(pq.dequeue()) # Outputs: (5, \'task5\') # Check size print(pq.size()) # Outputs: 2 # Check if empty print(pq.is_empty()) # Outputs: False ``` **Performance Requirements**: The insertion and deletion operations should have an average-case time complexity of O(log n).","solution":"class MaxHeapPriorityQueue: def __init__(self): self.heap = [] def _heapify_up(self): idx = len(self.heap) - 1 while idx > 0: parent_idx = (idx - 1) // 2 if self.heap[parent_idx] >= self.heap[idx]: break self.heap[parent_idx], self.heap[idx] = self.heap[idx], self.heap[parent_idx] idx = parent_idx def _heapify_down(self): idx = 0 length = len(self.heap) while 2 * idx + 1 < length: larger_child_idx = 2 * idx + 1 if 2 * idx + 2 < length and self.heap[2 * idx + 2] > self.heap[larger_child_idx]: larger_child_idx = 2 * idx + 2 if self.heap[idx] >= self.heap[larger_child_idx]: break self.heap[idx], self.heap[larger_child_idx] = self.heap[larger_child_idx], self.heap[idx] idx = larger_child_idx def enqueue(self, item): self.heap.append(item) self._heapify_up() def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") if len(self.heap) == 1: return self.heap.pop() highest_priority_item = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down() return highest_priority_item def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap) def __iter__(self): return iter(sorted(self.heap, reverse=True))"},{"question":"Context You are part of a development team building a gaming application. One of the features requires a special data structure allowing fast insertions, deletions, and random selection of game items. Your task is to implement this data structure named `RandomizedSet`. Objective Implement the `RandomizedSet` class with the following operations: * `insert(val)`: Inserts an item `val` to the set if not already present. * `remove(val)`: Removes an item `val` from the set if present. * `get_random()`: Returns a random element from current set of elements. Each element must have the same probability of being returned. Function Signatures ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def get_random(self) -> int: pass ``` Requirements 1. **Insert** Operation: * Parameters: An integer `val`. * Returns `True` if the item was not present in the set and has been inserted, otherwise `False`. 2. **Remove** Operation: * Parameters: An integer `val`. * Returns `True` if the item was present in the set and has been removed, otherwise `False`. 3. **Get Random** Operation: * Returns a random element from the set. * Each element in the set must have an equal chance of being returned. Constraints * All inputs to the `insert` and `remove` functions will be integers. * The random element returned by `get_random` must be uniform across all present elements, meaning no element should be favored over another. Example ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.remove(2)) # True print(rs.get_random()) # Could be 1 or 3, each with an equal chance print(rs.insert(2)) # True print(rs.remove(3)) # True print(rs.get_random()) # Could be 1 or 2, each with an equal chance ``` Your task is to implement the `RandomizedSet` class to meet these specifications.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: if val not in self.dict: return False last_element = self.list[-1] idx = self.dict[val] self.list[idx] = last_element self.dict[last_element] = idx self.list.pop() del self.dict[val] return True def get_random(self) -> int: return random.choice(self.list)"},{"question":"# Question: Implement Accelerated Pattern Matching in a Text Given a large text and a pattern string, write a function using the Knuth-Morris-Pratt (KMP) algorithm that efficiently finds all starting positions of the pattern in the text. Function Signature ```python def find_pattern_positions(text: str, pattern: str) -> List[int]: pass ``` Input 1. `text` (str): A string where pattern matching is to be performed. The text can be of length up to 10^6. 2. `pattern` (str): A string pattern to search in the text. The pattern can be of length up to 10^5. Output - Return a list of integers representing the starting indices/positions where the pattern is found in the text. Constraints - Pattern and text are non-empty. - The pattern length will not exceed the length of the text. Examples ```python assert find_pattern_positions(\\"abcabcabc\\", \\"abc\\") == [0, 3, 6] assert find_pattern_positions(\\"ababcabcab\\", \\"abcab\\") == [2] assert find_pattern_positions(\\"abracadabra\\", \\"abra\\") == [0, 7] ``` Notes - Your implementation should be able to handle large input sizes efficiently. - Consider edge cases such as when the pattern is the same as the text, or when the text contains repeated sub-pattern sequences.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Helper function to compute the longest proper prefix which is also suffix table (lps array) for the given pattern using KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_pattern_positions(text: str, pattern: str) -> List[int]: Function to find all starting positions of the pattern in the given text. if not pattern or not text or len(pattern) > len(text): return [] # Compute the lps array lps = compute_lps(pattern) i = 0 # index for text j = 0 # index for pattern positions = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): positions.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return positions"},{"question":"# One Edit Distance Check Context In a version management system, it is necessary to determine if a change in the content can be a minor typo correction or an intentional edit. The system you are building needs an efficient way to check if two given strings can be converted into one another with a single modification (insert a character, delete a character, or replace a character). Problem Statement Write a function `one_edit_away(s, t)` that takes two input strings `s` and `t`, and returns `True` if they are exactly one edit distance apart, else returns `False`. Function Signature ```python def one_edit_away(s: str, t: str) -> bool: ``` Input * `s` and `t`: Two non-null strings (0 <= len(s), len(t) <= 10^4). Output * A boolean value indicating whether the two strings are one edit distance apart. Constraints 1. The difference in lengths of `s` and `t` should not be more than 1. 2. The function should run in linear time O(n). Example ```python assert one_edit_away(\\"abc\\", \\"ab\\") == True assert one_edit_away(\\"abc\\", \\"abcd\\") == True assert one_edit_away(\\"abc\\", \\"xbc\\") == True assert one_edit_away(\\"abc\\", \\"abcde\\") == False assert one_edit_away(\\"abc\\", \\"abc\\") == False ``` Requirements - Ensure that your function handles the various edge cases effectively. - Your solution should be efficient in terms of both time and space complexity.","solution":"def one_edit_away(s: str, t: str) -> bool: # Check length difference, if more than 1, return False if abs(len(s) - len(t)) > 1: return False m, n = len(s), len(t) # Ensure that s is the shorter string if m > n: s, t = t, s m, n = n, m edit_found = False i, j = 0, 0 while i < m and j < n: if s[i] != t[j]: if edit_found: return False edit_found = True if m == n: # If lengths are same, move both pointers i += 1 # If lengths are different, move pointer of longer string else: i += 1 j += 1 return True if edit_found or m != n else False"},{"question":"You are tasked with developing a highly reliable spell-checking feature for a text editor. The core of this feature relies on computing the edit distance (Levenshtein distance) between two words. # Objective Write a function `compute_edit_distance` that calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another. # Function Signature ```python def compute_edit_distance(word_a: str, word_b: str) -> int: ``` # Input - `word_a`: A string (0 ≤ len(word_a) ≤ 1000) - `word_b`: A string (0 ≤ len(word_b) ≤ 1000) # Output - An integer representing the edit distance between `word_a` and `word_b`. # Constraints - Only lowercase English letters (a-z) will appear in the input strings. - The size of each string will not exceed 1000 characters. # Performance Requirements - Your implementation should run within a reasonable time limit for the given constraints (O(length_a * length_b)). # Example ```python assert compute_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert compute_edit_distance(\\"food\\", \\"money\\") == 4 assert compute_edit_distance(\\"\\", \\"banana\\") == 6 assert compute_edit_distance(\\"apple\\", \\"apple\\") == 0 ``` # Hint Think of using dynamic programming to fill up a 2D array where each cell represents the edit distance for substrings of the two words. Optimize the space complexity if possible to handle larger strings efficiently.","solution":"def compute_edit_distance(word_a: str, word_b: str) -> int: Computes the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into another (Levenshtein distance). len_a, len_b = len(word_a), len(word_b) # If one of the strings is empty, return the length of the other string if len_a == 0: return len_b if len_b == 0: return len_a # Create a 2D array to store the edit distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the base cases for i in range(len_a + 1): dp[i][0] = i for j in range(len_b + 1): dp[0][j] = j # Fill the dp array for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1)# Substitution return dp[len_a][len_b]"},{"question":"# Binary Tree Level Order Traversal Problem Description: You are given a binary tree. Your task is to write a function to return the level order traversal of the nodes\' values as a list of lists. Each sub-list in your result should contain the values of nodes at the same level, from left to right. Input: * A binary tree represented by its root node, which may be `None` if the tree is empty. Output: * A list of lists, where each list contains integers representing node values at a particular level. Example: Consider the binary tree represented as `[3, 9, 20, None, None, 15, 7]`: ``` 3 / 9 20 / 15 7 ``` The expected level order traversal output would be: ``` [ [3], [9, 20], [15, 7] ] ``` Constraints: * The number of nodes in the tree is between 0 and 10^4. * Node values are integers between -10^5 and 10^5. Function Signature: ```python def level_order(root): # Your code here ``` Performance Requirements: * The function should run with a time complexity of O(N). * The function should utilize additional memory proportional to the number of nodes at the widest level of the tree (i.e., O(N)).","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Perform a level-order traversal on a binary tree and return a list where each element is a list of node values at each level. :param root: TreeNode, the root of the binary tree :return: List[List[int]], values of the nodes at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"**Scenario**: You are developing a microservice for a software system that processes large volumes of numerical data. The service needs to efficiently compute the GCD and LCM of integer pairs, including the ability to handle large values and edge cases robustly. As such, you are tasked with implementing these calculations using both traditional and advanced methods to ensure the service performs optimally. **Task**: Implement two functions: `calculate_gcd(a: int, b: int) -> int` and `calculate_lcm(a: int, b: int) -> int`. 1. **Function 1: `calculate_gcd`**: - **Input**: Two integers `a` and `b`, which can be positive or negative, but neither should be zero. - **Output**: The greatest common divisor (GCD) of `a` and `b`. - **Constraints**: - Negative values should be handled by converting them to positive. - Ensure robust error handling for non-integer inputs. - **Performance Requirement**: Must run in O(log(min(a, b))). 2. **Function 2: `calculate_lcm`**: - **Input**: Two integers `a` and `b`, none of which should be zero. - **Output**: The least common multiple (LCM) of `a` and `b`. - **Constraints**: - It should leverage the `calculate_gcd` function for efficient computation. - Return the result as an integer. - Ensure robust error handling for non-integer inputs. **Example**: ```python calculate_gcd(48, 18) -> 6 calculate_lcm(48, 18) -> 144 calculate_gcd(-48, 18) -> 6 calculate_lcm(48, 0) -> Error: Both input values must be non-zero. ``` **Hints**: - Consider using helper functions where necessary. - Your solution should efficiently handle edge cases such as very large integers. **Notes**: - You may assume that the input values will be sufficiently large for typical use-cases but within the bounds of practical computation for modern systems. - Ensure you test the functions with various edge cases to validate correctness and performance.","solution":"def calculate_gcd(a: int, b: int) -> int: Calculate the Greatest Common Divisor (GCD) of two non-zero integers. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both inputs must be integers.\\") if a == 0 or b == 0: raise ValueError(\\"Both input values must be non-zero.\\") a, b = abs(a), abs(b) while b: a, b = b, a % b return a def calculate_lcm(a: int, b: int) -> int: Calculate the Least Common Multiple (LCM) of two non-zero integers. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both inputs must be integers.\\") if a == 0 or b == 0: raise ValueError(\\"Both input values must be non-zero.\\") return abs(a * b) // calculate_gcd(a, b)"},{"question":"# Caesar Cipher Function Implementation You are tasked with implementing the Caesar cipher, which is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down or up the alphabet. # Function Specification **Function Name**: `caesar_cipher` **Input**: - `s` (str): The input string containing alphabetic characters. - `k` (int): The shift factor. A non-negative integer representing the number of positions each character in the string is shifted. **Output**: - `str`: The encoded string after applying the Caesar cipher. # Constraints - 1 <= |s| <= 1000 (where |s| is the length of the input string) - 0 <= k <= 1000 # Examples 1. `caesar_cipher(\\"abc\\", 2)` should return `\\"cde\\"` 2. `caesar_cipher(\\"xyz\\", 3)` should return `\\"abc\\"` 3. `caesar_cipher(\\"Hello, World!\\", 5)` should return `\\"Mjqqt, Btwqi!\\"` # Performance Requirements - Implement the function efficiently to handle the upper limits of the input size constraints. - Ensure the function preserves the case of each letter and ignores non-alphabet characters. # Additional Notes - Consider edge cases like wrapping around the alphabet, handling upper and lower case letters, and ignoring characters that are not part of the alphabet. - Think about how you can optimize the function to avoid redundant computations, especially considering wraparounds for both uppercase and lowercase letters.","solution":"def caesar_cipher(s, k): Shifts each letter in the string `s` by `k` positions in the alphabet. Wraps around within the alphabet and maintains case. Non-alphabetical characters are not changed. :param s: str - the input string :param k: int - the shift factor :return: str - the encoded string after applying Caesar cipher result = [] k = k % 26 # Because shifting by 26 or more loops back to the original character for char in s: if \'a\' <= char <= \'z\': # Handle lowercase letters shifted = (ord(char) - ord(\'a\') + k) % 26 + ord(\'a\') result.append(chr(shifted)) elif \'A\' <= char <= \'Z\': # Handle uppercase letters shifted = (ord(char) - ord(\'A\') + k) % 26 + ord(\'A\') result.append(chr(shifted)) else: # Non-alphabetical characters remain unchanged result.append(char) return \'\'.join(result)"},{"question":"You are provided with a linked list where each node contains an additional random pointer that could point to any node in the list or be null. Your task is to write a function `copy_random_pointer_optimized`, which returns a deep copy of the linked list using an optimized approach that avoids using extra space for a dictionary. The function should exhibit O(n) time complexity and O(1) space complexity, excluding the space used by the output. # Function Signature ```python def copy_random_pointer_optimized(head: \'Optional[RandomListNode]\') -> \'Optional[RandomListNode]\': pass ``` # Input * A `head` of the linked list of type `RandomListNode` or `None`. # Output * The `head` of the copied linked list of type `RandomListNode`. # Constraints * The number of nodes in the linked list is in the range `[0, 1000]`. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) (excluding the space used by the new list nodes) # Example ```python # Example Usage: node1 = RandomListNode(1) node2 = RandomListNode(2) node3 = RandomListNode(3) node1.next = node2 node2.next = node3 node1.random = node3 node2.random = node1 node3.random = node2 new_head = copy_random_pointer_optimized(node1) # The new_head should point to a deep copy of the original list, maintaining the same next and random pointers structure. ``` # Hints * Consider interleaving the copied nodes directly with the original nodes and then separating them in two passes.","solution":"class RandomListNode: def __init__(self, val: int, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.val = val self.next = next self.random = random def copy_random_pointer_optimized(head: \'RandomListNode\') -> \'RandomListNode\': if not head: return None # First pass: Create a copy of each node and insert it directly after the original node. current = head while current: new_node = RandomListNode(current.val, current.next, None) current.next = new_node current = new_node.next # Second pass: Assign the random pointers for the copied nodes. current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Third pass: Separate the original and copied nodes. current = head copy_head = head.next copy_current = copy_head while current: current.next = current.next.next if copy_current.next: copy_current.next = copy_current.next.next current = current.next copy_current = copy_current.next return copy_head"},{"question":"# Radix Sort Implementation **Scenario**: You are tasked with implementing a sorting module that sorts large lists of non-negative integers efficiently. Your module will use Radix Sort, a highly efficient sorting algorithm for such data. The sorting needs to be stable, ensuring that the relative order of numbers with the same digits is preserved. **Problem Statement**: Implement a function `radix_sort(arr)` that sorts a list of non-negative integers. The function should follow the radix sort algorithm as illustrated in the given code snippet. **Function Signature**: ```python def radix_sort(arr: list[int]) -> list[int]: ``` **Input**: - `arr`: A list of non-negative integers `arr` where `1 <= len(arr) <= 10^6` and `0 <= arr[i] <= 10^9` for each `i`. **Output**: - Returns a list of integers sorted in ascending order. **Constraints**: - Your implementation should complete in a reasonable time frame for large inputs (up to 1 million elements). - Do not use any built-in sorting functions (`sort`, `sorted`, etc.). **Performance Requirements**: - Expected time complexity: O(nk + n), where n is the length of the list and k is the number of digits in the largest number. - Expected space complexity: O(n). **Edge Cases**: - An empty list should return an empty list. - A single element list should return the single element. **Example**: ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([3, 3, 3]) == [3, 3, 3] assert radix_sort([]) == [] assert radix_sort([123]) == [123] ``` Your goal is to write the `radix_sort` function as per the requirements.","solution":"def counting_sort_for_radix(arr, exp): n = len(arr) output = [0] * n # output array that will have sorted arr count = [0] * 10 # count array to store occurrences of digits # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that it contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array using count and the original array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] def radix_sort(arr): Performs radix sort on a list of non-negative integers if len(arr) == 0: return arr # Find the maximum number to know number of digits max_val = max(arr) # Do counting sort for every digit. Note that instead of passing digit number, # exp (10^i) is passed. exp is 10^0, 10^1, 10^2, ... exp = 1 while max_val // exp > 0: counting_sort_for_radix(arr, exp) exp *= 10 return arr"},{"question":"You are developing a software module that processes numerical data and presents various statistics. One of the requirements is to determine the number of digits in an integer quickly. You are to implement a function that receives an integer and returns the number of its digits. Function Signature ```python def num_digits(n: int) -> int: ``` Input - An integer `n` where `-10^18 <= n <= 10^18`. Output - An integer representing the number of digits in the absolute value of `n`. Constraints - The function should operate in constant time O(1). Example - `num_digits(12345)` should return `5`. - `num_digits(-987)` should return `3`. - `num_digits(0)` should return `1`. # Scenario In the provided software module, there is a need to efficiently determine how many digits an integer has. This piece of information is particularly useful for setting dynamic formatting lengths in reporting functions, verifying user inputs for fixed-length fields, and other numerical analysis tasks. Implement the `num_digits` function to meet these requirements.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the absolute value of the given integer `n`. return len(str(abs(n)))"},{"question":"# Problem Description: You are tasked with implementing a pair of functions for encoding and decoding strings using Run-Length Encoding (RLE). Your implementation should compress strings by converting sequences of repeated characters into a succinct form and decompress strings back to their original form. This problem tests your understanding and ability to handle edge cases and ensure correct functionality. # Function Signature: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Input: - `encode_rle`: A string `input` consisting of alphanumeric characters. - `decode_rle`: An encoded string `input` which is the result of the RLE algorithm (composed of digit characters denoting counts followed by the character being repeated). # Output: - `encode_rle`: A string that represents the RLE compressed form. - `decode_rle`: A string that reconstructs the original sequence from its RLE form. # Constraints: - The input strings for encoding/decoding will not exceed 10^4 characters. - The encoded string will be a valid RLE format. # Examples: Example 1: ```python assert encode_rle(\\"aaaabbbccdaa\\") == \\"4a3b2c1d2a\\" assert decode_rle(\\"4a3b2c1d2a\\") == \\"aaaabbbccdaa\\" ``` Example 2: ```python assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" ``` Example 3: ```python assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" ``` # Notes: - Your implementation should correctly handle edge cases like empty strings, single character strings, and strings with no repeating characters. - Assume input for decoding is always valid and well-formed according to the RLE format.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_output = [] current_char = input[0] count = 1 for char in input[1:]: if char == current_char: count += 1 else: encoded_output.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_output.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_output) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_output = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_output.append(char * count) count = 0 return \'\'.join(decoded_output)"},{"question":"Problem Statement: You are tasked with developing a transportation route optimization system for a city\'s bus network. The city\'s bus stops and routes are modeled as a directed graph, where vertices represent bus stops and edges represent routes between them with a given travel time. Your Task: Implement the `BusRoutes` class with the following methods: - `__init__(self, vertex_count)`: Initializes a graph with `vertex_count` bus stops. - `add_route(self, u, v, w)`: Adds a directed route from bus stop `u` to bus stop `v` with travel time `w`. - `shortest_travel_time(self, src)`: Returns an array of the shortest travel times from the source bus stop `src` to all other bus stops using Dijkstra\'s algorithm. Input: - The number of bus stops `vertex_count` (2 ≤ vertex_count ≤ 100) - A list of tuples representing routes `(u, v, w)` where `u` is the starting stop, `v` is the ending stop, and `w` is the travel time (0 < w < 100). Output: - An array of integers where the `i-th` element represents the shortest travel time from the source bus stop to the `i-th` bus stop. Example: ```python # Initialize the bus routes graph with 5 bus stops graph = BusRoutes(5) # Add routes between bus stops graph.add_route(0, 1, 10) graph.add_route(0, 4, 5) graph.add_route(1, 2, 1) graph.add_route(4, 1, 3) graph.add_route(4, 2, 9) graph.add_route(4, 3, 2) graph.add_route(3, 2, 4) # Get the shortest travel time from bus stop 0 print(graph.shortest_travel_time(0)) # Output: [0, 8, 9, 7, 5] ``` Constraints: - Assume all bus stops are uniquely indexed from `0` to `vertex_count - 1`. - There will always be at least one route within the provided graph. Notes: - Ensure your solution handles edge cases such as multiple routes between the same stops with different travel times. - Consider using efficient data structures to improve the performance where applicable.","solution":"import heapq class BusRoutes: def __init__(self, vertex_count): self.vertex_count = vertex_count self.edges = {i: [] for i in range(vertex_count)} def add_route(self, u, v, w): self.edges[u].append((v, w)) def shortest_travel_time(self, src): dist = [float(\'inf\')] * self.vertex_count dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in self.edges[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"Binary Search Scenario Suppose you are developing a search utility for a contacts application where users have a list of contacts sorted alphabetically by their names. You need to implement a search function that efficiently locates a contact by their name. Task Write a function `binary_search_name` that searches for a target name in a sorted list of contact names using the binary search technique. If the target name exists in the list, the function should return its index. If the target name does not exist, the function should return -1. Function Signature ```python def binary_search_name(names: List[str], target: str) -> int: pass ``` Input - `names` (List[str]): A list of strings representing contact names sorted in ascending order. The list contains no duplicate names. - `target` (str): A string representing the name to be searched. Output - `int`: Index of the target name if found, otherwise -1. Constraints - The length of the list `names` is between 0 and 10^6. - The length of each contact name is between 1 and 100 characters. Example ```python assert binary_search_name([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Charlie\\") == 2 assert binary_search_name([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Eve\\") == -1 assert binary_search_name([], \\"Alice\\") == -1 ``` Performance Requirements Your implementation should have a time complexity of O(log n) and space complexity of O(1). Hints - Consider edge cases like an empty list or the target name being the first/last element in the list. - Ensure you\'re not causing integer overflow when computing the middle index; use Python’s integer division appropriately.","solution":"def binary_search_name(names, target): Performs binary search on a sorted list of names to find the index of the target name. Parameters: names (List[str]): A list of sorted contact names. target (str): The name to be searched. Returns: int: Index of the target name if found, else -1. left, right = 0, len(names) - 1 while left <= right: mid = (left + right) // 2 if names[mid] == target: return mid elif names[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Two Sum Problem with Three Solutions You are given an array of integers sorted in ascending order and a target value. Your task is to implement three functions to find the indices of the two numbers such that they add up to the target value. Specifications 1. **Binary Search Method**: - Function name: `two_sum` - Input: List of integers `numbers` (sorted in ascending order), an integer `target` - Output: List with two integers `[index1, index2]` (1-based indices) 2. **Hash Table Method**: - Function name: `two_sum1` - Input: List of integers `numbers`, an integer `target` - Output: List with two integers `[index1, index2]` (1-based indices) 3. **Two Pointers Method**: - Function name: `two_sum2` - Input: List of integers `numbers` (sorted in ascending order), an integer `target` - Output: List with two integers `[index1, index2]` (1-based indices) Example Given: ```python numbers = [2, 7, 11, 15], target = 9 ``` * `two_sum(numbers, target)` should return `[1, 2]` * `two_sum1(numbers, target)` should return `[1, 2]` * `two_sum2(numbers, target)` should return `[1, 2]` Constraints * The input array is guaranteed to be sorted. * Each input would have exactly one solution. * Indices returned must be 1-based. * You may not use the same element twice. Performance Requirements * Binary Search method should run in (O(n log n)) time. * Hash Table method should run in (O(n)) time with (O(n)) space. * Two Pointers method should run in (O(n)) time with (O(1)) space. Implement each of these functions to return the correct 1-based indices of the two numbers such that they add up to the target.","solution":"def two_sum(numbers, target): Binary Search Method to find the indices of the two numbers that add up to the target. def binary_search(numbers, left, right, target): while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: return mid elif numbers[mid] < target: left = mid + 1 else: right = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] def two_sum1(numbers, target): Hash Table Method to find the indices of the two numbers that add up to the target. lookup = {} for i, num in enumerate(numbers): if target - num in lookup: return [lookup[target - num] + 1, i + 1] lookup[num] = i def two_sum2(numbers, target): Two Pointers Method to find the indices of the two numbers that add up to the target. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"# Sudoku Solver Implementation Context You are tasked with implementing a Sudoku solver. Sudoku is a number puzzle game played on a 9x9 grid, divided into 3x3 subgrids. The objective is to fill the grid with numbers from 1 to 9 such that each row, each column, and each 3x3 subgrid contains all the numbers from 1 to 9 exactly once. Problem Statement Using the depth-first search (DFS) with backtracking strategy, complete the implementation of a Sudoku solver. Your solution should handle possible constraints and efficiently backtrack to find a valid Sudoku configuration. Function Signature ```python def sudoku_solver(board: List[List[str]]) -> bool: Solves the Sudoku puzzle. Parameters: board : List[List[str]] - A 9x9 list of lists containing digits \'1\'-\'9\' and \'.\' for empty spaces. Returns: bool - True if the board is solved, False otherwise. pass ``` Input - `board`: A 2D list representing a Sudoku board. Array elements contain numbers \'1\' to \'9\' or \'.\' (indicating empty cells). Output - Return `True` if the Sudoku board is solved, otherwise `False`. Constraints - The board is always a 9x9 grid. - Input board may represent a valid or invalid Sudoku configuration without any guarantees of solvability. - A filled Sudoku grid must follow these rules: - Each of the digits 1-9 must appear exactly once in each row. - Each of the digits 1-9 must appear exactly once in each column. - Each of the digits 1-9 must appear exactly once in each of the 9 3x3 subgrids. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] sudoku_solver(board) # Expected output: True (and board is modified to be solved) ``` Notes - Your function should modify the input board list to reflect the solved state. - Ensure your function efficiently handles possible constraints to avoid excessive runtime. Implementation Guide 1. Initialize possible values for each cell. 2. Recursively attempt to place numbers using DFS and backtracking. 3. Respect the constraints of rows, columns, and subgrids. 4. Implement robust handling of invalid or unsolvable states.","solution":"from typing import List def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: # Check if num is not in the current row/column/subgrid # Check row for i in range(9): if board[row][i] == num: return False # Check column for i in range(9): if board[i][col] == num: return False # Check subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def find_empty(board: List[List[str]]): # Find an empty cell (represented by \'.\') for i in range(9): for j in range(9): if board[i][j] == \'.\': return i, j return None def sudoku_solver(board: List[List[str]]) -> bool: empty = find_empty(board) if not empty: return True # Solved row, col = empty for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if sudoku_solver(board): return True board[row][col] = \'.\' return False"},{"question":"# Distance to Nearest Gate Problem Context You are given a `m x n` 2D grid initialized with the following values: * `-1`: A wall or an obstacle. * `0`: A gate. * `INF`: Infinity means an empty room, represented by the value `2^31 - 1 = 2147483647`. Your task is to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the value as `INF`. Example For the grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` The result should be: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: Modifies the grid in-place with distances to the nearest gate. Parameters: rooms (List[List[int]]): The 2D grid of rooms, gates, and obstacles. Returns: None: This function should mutate the input grid. ``` Constraints * `-2^31 <= rooms[i][j] <= 2^31 - 1` * `1 <= rooms.length <= 200` * `1 <= rooms[i].length <= 200` Requirements * Modify the given 2D grid `rooms` in place. * Utilize BFS instead of DFS to ensure optimal performance and avoid stack overflow issues. Performance * **Time Complexity**: O(m * n), where `m` is the number of rows and `n` is the number of columns in the grid. * **Space Complexity**: O(m * n) due to queue usage in BFS.","solution":"from typing import List from collections import deque def walls_and_gates(rooms: List[List[int]]) -> None: m, n = len(rooms), len(rooms[0]) INF = 2147483647 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Enqueue all gates\' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from gate positions while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"Optimizing Set Cover Problem Objective The task is to implement a more efficient algorithm to solve an approximation of the minimum cost set-cover problem using a different heuristic approach than the simple greedy algorithm provided. Problem Statement Given a universe of elements and a collection of subsets with associated costs, find a near-optimal subcollection of subsets that covers all elements in the universe with a minimized cost. Your implementation should strive for better performance or improved approximation over the basic greedy algorithm. Consider the coverage gain of a subset in relation to the elements it adds, weighted more heavily by elements that are rarer in remaining uncovered elements. Input * `universe` : A list of unique elements representing the universe. * `subsets` : A dictionary where the keys are subset identifiers and the values are sets of elements contained within those subsets. * `costs` : A dictionary where the keys are subset identifiers and the values are the cost associated with each subset. Output * Return the identifiers of selected subsets that form the near-optimal cover and the minimized total cost. Constraints - All elements in the universe must be covered. - Each subset must only be counted once. - Subsets can have overlapping elements. Example ```python universe = [1, 2, 3, 4, 5] subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} output = custom_approx_set_cover(universe, subsets, costs) print(output) # Example output could be: # ([\'S3\', \'S2\'], 13) - illustrating the selected subset identifiers with their minimized total cost. ``` Performance Requirements The algorithm should run efficiently on inputs where the number of subsets and elements can be large (up to 1000 subsets and elements). Your implementation should produce a good approximation of the minimum cost for large datasets. Implementation Hints - Consider enhancements to the basic greedy algorithm, such as weighted gain (prioritizing rare elements not covered). - Think about ways to prune or avoid redundant calculations.","solution":"def custom_approx_set_cover(universe, subsets, costs): Approximate the minimum cost set-cover problem using a heuristic improvement over the simple greedy algorithm. uncovered = set(universe) selected_subsets = [] total_cost = 0 while uncovered: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_id, subset_elements in subsets.items(): uncovered_elements = uncovered & subset_elements if uncovered_elements: # Calculate the cost-effectiveness: cost per uncovered element current_cost_effectiveness = costs[subset_id] / len(uncovered_elements) # Prioritize rare elements (appearing in fewer subsets) by multiplying effectiveness rarity_factor = sum(1 for e in uncovered_elements if sum(e in s for s in subsets.values()) == 1) current_cost_effectiveness /= (rarity_factor + 1) if current_cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = current_cost_effectiveness best_subset = subset_id if best_subset is not None: selected_subsets.append(best_subset) total_cost += costs[best_subset] uncovered -= subsets[best_subset] return selected_subsets, total_cost"},{"question":"# Scenario You are working as part of a team developing a high-performance data processing system. One of your tasks involves sorting datasets that consist of integer values. To optimize performance for specific datasets with predictable ranges of values, you have decided to implement a specialized sorting algorithm. # Task Write a Python function `optimized_counting_sort(arr)` that sorts an array of integers using the Counting Sort method. Your function should: 1. Accept an array `arr` of integers as input. 2. Handle negative values within the array. 3. Sort the array in ascending order using Counting Sort. 4. Return the sorted array. # Input and Output Formats - **Input**: A list of integers `arr`, with `1 <= len(arr) <= 10^6` and `-10^6 <= arr[i] <= 10^6`. - **Output**: A list of integers sorted in non-decreasing order. # Constraints - The array may contain both negative and positive integers. - The function should handle large datasets efficiently in terms of time and space. # Example Input ```python arr = [4, 2, -3, 1, 2, -5, 0] ``` Output ```python [-5, -3, 0, 1, 2, 2, 4] ``` # Notes - Consider the edge cases such as an empty array, arrays with negative numbers, duplicate elements, and arrays where all elements are the same. - Focus on ensuring the stability of the sort (elements with the same value should appear in the original order).","solution":"def optimized_counting_sort(arr): Sorts an array of integers using the Counting Sort method. if not arr: return arr min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize the count array count_arr = [0] * range_of_elements # Store the count of each element for num in arr: count_arr[num - min_val] += 1 # Reconstruct the sorted array sorted_index = 0 for i in range(range_of_elements): while count_arr[i] > 0: arr[sorted_index] = i + min_val sorted_index += 1 count_arr[i] -= 1 return arr"},{"question":"# Prime Numbers with Sieve of Eratosthenes You are tasked with implementing a function to generate a list of all prime numbers less than a given number using the Sieve of Eratosthenes. Your implementation should optimize the sieve by excluding even numbers beyond 2 from consideration, thus halving the size of the array used for the sieve. Function Signature ```python def get_primes(n: int) -> List[int]: Return list of all primes less than n using a modified Sieve of Eratosthenes. Parameters: n (int): The upper limit (exclusive) up to which primes are to be generated. Returns: List[int]: List of all primes less than \'n\'. pass ``` Input * `n`: Integer (1 ≤ n ≤ 10^6) representing the exclusive upper limit for prime generation. Output * A list of integers containing all prime numbers less than `n`. Constraints * Your implementation should handle the edge cases where `n` is very small. * Aim to minimize both the time and space complexity of your solution. * The solution should manage to avoid processing extraneous even numbers beyond 2. # Scenario Imagine you are developing a feature for a math tutoring app that helps students learn about prime numbers. Your task is to create a function that can quickly provide a list of prime numbers less than a given number `n`. This feature needs to be highly efficient to handle numerous queries in real-time from the students. # Examples ```python assert get_primes(10) == [2, 3, 5, 7] assert get_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert get_primes(2) == [] assert get_primes(1) == [] assert get_primes(18) == [2, 3, 5, 7, 11, 13, 17] ``` # Guidelines * Validate the input to ensure `n` is a positive integer and raise a `ValueError` if not. * Your sieve should handle the optimization by checking only odd numbers and including 2 in the list of primes by default. * Ensure efficient marking of non-primes to maintain optimal performance.","solution":"from typing import List def get_primes(n: int) -> List[int]: Return list of all primes less than n using a modified Sieve of Eratosthenes. Parameters: n (int): The upper limit (exclusive) up to which primes are to be generated. Returns: List[int]: List of all primes less than \'n\'. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers # Only check for odd numbers and include 2 initially for start in range(3, int(n**0.5) + 1, 2): if sieve[start]: sieve[start*start:n:start*2] = [False] * len(range(start*start, n, start*2)) return [2] + [num for num in range(3, n, 2) if sieve[num]]"},{"question":"Crout Matrix Decomposition You are required to implement the Crout matrix decomposition algorithm. This algorithm decomposes a given square matrix A into a lower triangular matrix L and an upper triangular matrix U such that A = L * U. L has non-zero elements only on and below its diagonal, while U has non-zero elements only on and above its diagonal. Given a square matrix A, write a function: ```python def crout_matrix_decomposition(A): # Your code here ``` # Input: - `A (list of list of floats)`: A 2D list representing an n x n matrix. # Output: - Returns a tuple of two 2D lists (L, U): - `L (list of list of floats)`: The lower triangular matrix. - `U (list of list of floats)`: The upper triangular matrix. # Constraints: - 1 ≤ n ≤ 1000: The input matrix is square and can be as large as 1000x1000. - The matrix elements can be any real number. - The matrix should be non-singular (i.e., it has a full rank). # Example: ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U = crout_matrix_decomposition(A) print(\\"L:\\") for row in L: print(row) print(\\"U:\\") for row in U: print(row) ``` **Expected Output:** ``` L: [1.0, 0.0, 0.0] [3.0, -2.0, 0.0] [6.0, -5.0, 0.0] U: [1.0, 2.0, 3.0] [0.0, 1.0, 2.0] [0.0, 0.0, 1.0] ``` # Edge Cases to Consider: 1. Matrices with zero elements on the diagonal. 2. Precision issues in floating-point calculations. 3. Large matrices approaching the upper bound of constraints. 4. Avoiding division by zero by ensuring some minimal adjustment (e.g., a small epsilon value if the diagonal element of L is zero). **Note**: You may assume the input matrix is well-formed and meets the constraints unless stated otherwise.","solution":"def crout_matrix_decomposition(A): Performs Crout matrix decomposition on a given square matrix A. Args: A (list of list of floats): A 2D list representing an n x n matrix. Returns: tuple: A tuple with two 2D lists, L (lower triangular matrix) and U (upper triangular matrix). n = len(A) # Initialize L and U matrices L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): # Construct the U matrix U[j][j] = 1.0 for i in range(j, n): L[i][j] = A[i][j] - sum(L[i][k] * U[k][j] for k in range(j)) for i in range(j + 1, n): if L[j][j] == 0: raise ValueError(\\"Matrix is singular.\\") U[j][i] = (A[j][i] - sum(L[j][k] * U[k][i] for k in range(j))) / L[j][j] return L, U"},{"question":"**Context**: You have recently learned about generating all possible subsets of a given set of distinct integers and have encountered both recursive and iterative approaches in the study material. To test your understanding and implementation skills, you\'re asked to solve a variant of this problem with additional constraints. **Problem Statement**: Write a function `unique_subsets(nums)` that takes a list of integers `nums` and returns all unique subsets where: 1. Each subset is sorted in non-decreasing order. 2. The list of subsets itself should be sorted, with subsets compared lexicographically. **Function Signature**: ```python def unique_subsets(nums: List[int]) -> List[List[int]]: pass ``` **Input**: * `nums` (List[int]) - A list of distinct integers (1 <= len(nums) <= 12, -10 <= nums[i] <= 10). **Output**: * Returns a list of lists, each inner list representing a subset of `nums`, sorted as per the constraints above. **Example**: ```python assert unique_subsets([3, 1, 2]) == [ [], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3] ] assert unique_subsets([-1, 1]) == [ [], [-1], [-1, 1], [1] ] assert unique_subsets([4]) == [ [], [4] ] ``` **Constraints**: - `nums` consists of distinct integers only. - Implement both recursive and iterative approaches within the function using appropriate helper functions if necessary. - Ensure your solution handles the edge cases, such as an empty input list or single-element list. **Performance Requirements**: - Ensure the solution runs efficiently within the given constraints, particularly noting the time complexity implications.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generates all unique subsets of the given list of integers such that each subset is sorted in non-decreasing order and the entire list of subsets is sorted lexicographically. nums.sort() subsets = [] def backtrack(start, path): subsets.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return subsets"},{"question":"You are given a stream of integers and a window size \'n\', and you need to calculate the moving average of the last \'n\' numbers. Implement a class `MovingAverage` that supports the following operations: Initialization: ```python def __init__(self, size: int): Initializes the MovingAverage with a specific window size. :param size: int - the size of the sliding window ``` Function: ```python def next(self, val: int) -> float: Adds a new value to the sliding window and returns the moving average of the window\'s numbers. :param val: int - the new integer value to add :return: float - the current moving average ``` # Constraints 1. The window size (n) is a positive integer (1 ≤ n ≤ 1000). 2. The integer values in the stream can be from -10^4 to 10^4. 3. `next` function will be called a large number of times, hence efficiency is crucial. 4. Return the moving average with a precision of up to two decimal places. # Example ```python m = MovingAverage(3) assert m.next(1) == 1.00 assert m.next(10) == 5.50 assert m.next(3) == 4.67 assert m.next(5) == 6.00 ``` # Performance Requirement - For this problem, the `next` function should have a time complexity of approximately O(1) leveraging an optimized approach to maintain a running sum of the window. # Additional Notes - Ensure you handle edge cases, such as the first few calls to `next` before the window reaches its full size. - Consider memory usage and ensure the implementation is efficient for the maximum window size.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initializes the MovingAverage with a specific window size. :param size: int - the size of the sliding window self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: Adds a new value to the sliding window and returns the moving average of the window\'s numbers. :param val: int - the new integer value to add :return: float - the current moving average if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return round(self.current_sum / len(self.queue), 2)"},{"question":"# Flatten Multi-Dimensional Arrays **Background**: You are given an array that may contain nested arrays of varying depths. Your task is to \\"flatten\\" this array such that all elements are contained within a single, one-dimensional array. # Task: Implement the function `flatten` to flatten nested arrays. Avoid using any external libraries. # Function Signature: ```python def flatten(input_arr): Flattens a multi-dimensional array into a single-dimensional array. Args: input_arr (list): A list that may contain nested lists. Returns: list: A single-dimensional list containing all elements from the input list. ``` # Input: * `input_arr`: A list containing elements, where an element can be a basic data type (e.g., integer, string) or another list. # Output: * Returns a single-dimensional list containing all the elements from the input list. # Example: ```python flatten([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] ``` # Constraints: * The elements in the list can be of any data type. * You should not use any built-in flatten functions or libraries. * Ensure the solution is efficient for considerably large and deeply nested arrays. # Guidelines: 1. Recursively traverse the input array. 2. For each element, check if it is an array. * If it is not an array, add it directly to the result. * If it is an array, recursively flatten it and add its elements to the result. 3. Handle edge cases such as empty arrays and strings properly. # Performance Requirements: * The solution should handle deep nesting efficiently. * Minimize the number of recursive calls to avoid stack overflow issues.","solution":"def flatten(input_arr): Flattens a multi-dimensional array into a single-dimensional array. Args: input_arr (list): A list that may contain nested lists. Returns: list: A single-dimensional list containing all elements from the input list. result = [] for element in input_arr: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result"},{"question":"# Problem: You are given the task of generating and verifying properties of the Hailstone sequence (Collatz sequence) which is generated starting from a positive integer `n` by following these rules: * n == 1 -> Sequence terminates. * n is even -> The next n = n / 2. * n is odd -> The next n = 3 * n + 1. # Task: Write a Python function named `hailstone_properties` which takes one argument: * an integer `n` where `n > 0`. The function should compute the Hailstone sequence starting from `n` and return two things: 1. The Hailstone sequence as a list. 2. The length of this sequence. # Input: * A single integer `n` (1 <= n <= 10^6) # Output: * A tuple containing: * A list representing the Hailstone sequence starting from `n`. * An integer representing the length of the sequence. # Constraints: * You should ensure your implementation is efficient and runs within a reasonable time for large values of `n`. * Consider edge cases where `n` is already 1. # Example: Input: `n = 7` Output: ``` ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 17) ``` # Notes: * The provided sequence in the example starts with 7 and ends with 1. * The length of sequence in the example is 17.","solution":"def hailstone_properties(n): Generates the Hailstone sequence starting from n and returns the sequence as a list and its length. Parameters: n (int): The starting integer for the Hailstone sequence (n > 0) Returns: tuple: A tuple where the first element is the Hailstone sequence list and the second element is the length of the sequence. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence, len(sequence)"},{"question":"# Question: Enhanced Sorting Algorithm Implementation Given the provided code snippet for the Cocktail Shaker Sort, your task is to implement an enhanced sorting algorithm with the following specifications: 1. **Hybrid Approach**: Combine the Cocktail Shaker Sort with a more efficient algorithm (of your choice) to handle large datasets. For the purpose of this exercise, you can switch to the efficient algorithm when the number of elements is larger than a certain threshold (e.g., 20). 2. **Error Handling**: Ensure the provided input is validated (e.g., check for non-integer values) and handle any errors properly by returning a clear error message. 3. **Edge Case Optimization**: Implement additional conditions to handle the edge cases particularly efficiently (e.g., arrays already sorted, arrays with identical elements, very small or large arrays). # Constraints: * The array `arr` will only contain integers. * The size of the array will be less than or equal to 10^5. * Performance should be optimized for arrays larger than 20 elements by integrating a more efficient sort algorithm. # Function Signature ```python def enhanced_sort(arr): Enhanced sorting function combining cocktail shaker sort with a more efficient algorithm. Args: arr (list): A list of integers to be sorted. Returns: list: The sorted list. ``` # Input Format * A list of integers, `arr`. # Output Format * A sorted list of integers. # Example ```python >>> enhanced_sort([3, 2, 5, 4, 1]) [1, 2, 3, 4, 5] >>> enhanced_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> enhanced_sort([3, 3, 3, 3, 3]) [3, 3, 3, 3, 3] >>> enhanced_sort([10, -1, 2, -10, 3, 7]) [-10, -1, 2, 3, 7, 10] ``` # Notes * Consider integrating an efficient sort like Python\'s built-in Timsort for larger datasets. * Clearly document your code, explaining the choice of the hybrid approach and any assumptions made.","solution":"def cocktail_shaker_sort(arr): n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr def enhanced_sort(arr): Enhanced sorting function combining cocktail shaker sort with a more efficient algorithm. Args: arr (list): A list of integers to be sorted. Returns: list: The sorted list. # Check if input is a list if not isinstance(arr, list): return \\"Input must be a list\\" # Check for non-integer elements for element in arr: if not isinstance(element, int): return \\"All elements must be integers\\" # If array has 20 or fewer elements, use Cocktail Shaker Sort if len(arr) <= 20: return cocktail_shaker_sort(arr) # If array has more than 20 elements, use Python\'s built-in Timsort return sorted(arr)"},{"question":"**Problem Statement:** **Cycle Sort Implementation** You are given an array of distinct integers. Implement the Cycle Sort algorithm to sort this array in-place. Cycle Sort is efficient in terms of space utilization but can have a quadratic time complexity. Your task is to ensure the algorithm is implemented correctly and handles all necessary edge conditions. **Function Signature:** ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input:** * `arr`: An array of distinct integers with a length of `1 <= len(arr) <= 1000`. **Output:** * Return the sorted array `arr`. **Constraints:** * The input array will contain unique integers only. * The algorithm must be performed in-place, modifying the input array directly. * You are required to handle possible edge cases and ensure the correct output for all valid inputs. **Example:** ```python assert cycle_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert cycle_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert cycle_sort([10, 20, 1, 0]) == [0, 1, 10, 20] ``` **Special Conditions:** - The algorithm should run efficiently in O(N^2) time complexity, consistent with Cycle Sort\'s expected performance. - If the input array is already sorted, your function should recognize this early and minimize operations. **Context:** You are tasked with applying an in-place sorting algorithm (Cycle Sort) which showcases your understanding of manipulating arrays with minimal auxiliary space and your ability to handle typical edge cases associated with in-place algorithms. This question assesses your capability to implement algorithmic logic and your understanding of sorting mechanisms.","solution":"def cycle_sort(arr): writes = 0 for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] pos = cycleStart # Find where to put the item. for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 if pos == cycleStart: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Enhanced Insertion Sort Given an array of integers, you are to implement an enhanced version of the Insertion Sort algorithm that includes the following features: 1. **Duplicate Removal**: Your sort should ensure that all duplicate numbers are removed and only unique elements remain in the sorted array. 2. **Early Termination**: If the array is detected to be already sorted at any point, the algorithm should terminate early and return the sorted result immediately. # Function Signature ```python def enhanced_insertion_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers (`1 <= len(arr) <= 10^5`), where each integer value in the range (-10^6 to 10^6). # Output * Returns a sorted list of unique integers. # Constraints * Focus on minimizing time complexity and space usage where applicable while ensuring the sort is carried out correctly. * The function should be able to handle edge cases like empty arrays gracefully. # Performance Requirements * The solution should optimize for early termination for already sorted segments. * Time complexity should remain close to O(n^2) in the worst case and improve when possible. # Examples ```python assert enhanced_insertion_sort([8, 4, 7, 4, 9, 1, 8, 2]) == [1, 2, 4, 7, 8, 9] assert enhanced_insertion_sort([1, 2, 2, 2, 3, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_insertion_sort([]) == [] assert enhanced_insertion_sort([5]) == [5] assert enhanced_insertion_sort([2, 3, 1]) == [1, 2, 3] assert enhanced_insertion_sort([2, 2, 2]) == [2] ``` # Additional Methods You are allowed to implement additional helper methods as needed to achieve the solution.","solution":"from typing import List def enhanced_insertion_sort(arr: List[int]) -> List[int]: if not arr: return [] # An optimised insertion sort that also removes duplicates n = len(arr) sorted_list = [] for i in range(n): # Skip inserting duplicates if arr[i] in sorted_list: continue inserted = False for j in range(len(sorted_list)): if arr[i] < sorted_list[j]: sorted_list.insert(j, arr[i]) inserted = True break if not inserted: sorted_list.append(arr[i]) return sorted_list"},{"question":"You are given a large body of text and a set of phrases. Your task is to implement a function that identifies all the starting positions of each phrase within the given text using the Knuth-Morris-Pratt (KMP) algorithm for pattern matching. # Function Signature ```python def find_phrases_in_text(text: str, phrases: List[str]) -> List[List[int]]: Given a text and a list of phrases, return a list of lists where each inner list contains the starting indices of the corresponding phrase found within the text. Args: text: A string representing the large body of text. phrases: A list of strings where each string is a phrase to be searched within the text. Returns: A list of lists where the i-th list contains the starting indices of the i-th phrase found within the text. Example: >>> find_phrases_in_text(\'hello there hero! hello hero!\', [\'hello\', \'hero\']) [[0, 18], [12, 24]] ``` # Constraints * Phrasess can be empty, in which case return an empty list or lists should reflect handling of empty input properly. * Text length N can be up to 10^6 characters. * Phrases length M can be up to 10^4 characters. # Requirements 1. **Input/Output Specification**: - The function should take a string `text` and a list of phrases `phrases`. - The function returns a list of lists as described above. 2. **Performance**: - The solution should be efficient, with an expected time complexity around O(N + M) per phrase. 3. **Implementation Details**: - Use the Knuth-Morris-Pratt (KMP) algorithm. - Handle cases where phrases may be empty or not found in the text. 4. **Edge Cases**: - Include conditions to handle scenarios like empty text, phrases longer than text, or highly repetitive characters efficiently.","solution":"from typing import List def kmp_search(pattern: str, text: str) -> List[int]: Perform KMP search of the pattern in the text and returns a list of starting indices where the pattern is found in the text. def compute_lps(pattern: str) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i, j = 0, 0 result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result def find_phrases_in_text(text: str, phrases: List[str]) -> List[List[int]]: result = [] for phrase in phrases: if not phrase: result.append([]) else: indices = kmp_search(phrase, text) result.append(indices) return result"},{"question":"# Scenario You are developing a machine learning system that requires efficient computation of similarity between high-dimensional data points. Implement a function to compute cosine similarity between two vectors, a common metric in text mining and recommendation systems. Your function should be efficient and handle edge cases effectively. # Problem Statement Write a Python function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two equal-length vectors. Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: pass ``` # Input * `vec1` and `vec2`: Two lists of integers or floats, representing high-dimensional vectors. Both lists must have the same length, denoted as `N` (1 ≤ N ≤ 10^6). # Output * A float representing the cosine similarity between the two vectors. The output should be accurate up to 6 decimal places. # Constraints 1. The input lists will contain only numerical values. 2. If the input lists are not of the same length, raise a `ValueError` with a descriptive message. # Examples ```python assert abs(cosine_similarity([1, 1, 1], [1, 2, -1]) - 0.471404) < 1e-6 assert abs(cosine_similarity([1, 0, 0], [0, 1, 0]) - 0.0) < 1e-6 assert abs(cosine_similarity([1, 2, 3], [4, 5, 6]) - 0.974631846) < 1e-6 assert abs(cosine_similarity([0, 0, 0], [0, 0, 1]) - 0.0) < 1e-6 ``` # Notes 1. Make sure to handle the case where one or both vectors are zero-vectors, as this should return a similarity of 0 to avoid division errors. 2. Ensure your implementation can handle up to 1 million elements efficiently.","solution":"import math def cosine_similarity(vec1: list, vec2: list) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Two Sum Problem with Additional Constraints **Problem Statement**: You are given an array of integers and a target sum. Write a function `two_sum_with_indices` that returns the indices of the two numbers such that they add up to the target. Each input array will have exactly one solution, and you may not use the same element twice. Additionally, you must ensure your implementation adheres to the following constraints: * **Time Complexity**: O(n), where n is the number of elements in the input array. * **Space Complexity**: O(n), only the dictionary may be used for auxiliary storage. **Examples**: 1. **Input**: nums = [2, 7, 11, 15], target = 9 **Output**: (0, 1) * Because nums[0] + nums[1] = 2 + 7 = 9. 2. **Input**: nums = [3, 2, 4], target = 6 **Output**: (1, 2) * Because nums[1] + nums[2] = 2 + 4 = 6. 3. **Input**: nums = [3, 3], target = 6 **Output**: (0, 1) * Because nums[0] + nums[1] = 3 + 3 = 6. **Function Signature**: ```python def two_sum_with_indices(array: List[int], target: int) -> Tuple[int, int]: pass ``` **Constraints**: 1. The input list `array` will contain at least two elements. 2. The target will always have exactly one solution in the given input. 3. The same element in the array may not be used twice. **Additional Details**: 1. You should leverage a dictionary for efficient lookup and ensure your solution is optimized for both timing and space requirements. 2. Consider all edge cases, including the smallest arrays and edge values.","solution":"from typing import List, Tuple def two_sum_with_indices(array: List[int], target: int) -> Tuple[int, int]: Given an array of integers and a target sum, this function returns the indices of the two numbers such that they add up to the target. Each input array has exactly one solution. # Dictionary to store the number and its index num_to_index = {} # Loop through the list for i, num in enumerate(array): # Calculate the needed value to reach the target complement = target - num # Check if the complement exists in the dictionary if complement in num_to_index: return (num_to_index[complement], i) # Store the index of the current number in the dictionary num_to_index[num] = i"},{"question":"# Pancake Sort Implementation Challenge You are provided with a sorting algorithm called Pancake Sort. This algorithm sorts an array by repeatedly flipping sections of the array. Your task is to modify the given algorithm to improve its efficiency and ensure robust handling of edge cases. Problem Statement Write a function `optimized_pancake_sort(arr)` that sorts an array of integers using an optimized version of the Pancake Sort algorithm. Your function should aim to reduce the number of flips required and handle all edge cases efficiently. Function Signature ```python def optimized_pancake_sort(arr: list) -> list: pass ``` Input * A list `arr` of integers with 0 ≤ len(arr) ≤ 10^5. * The list contains integers where -10^9 ≤ arr[i] ≤ 10^9. Output * A list of integers sorted in non-decreasing order. Constraints * The function must operate within the time complexity of O(N^2) or better. * You may not use any extra space for sorting (in-place sorting). Example ```python input: [3, 2, 4, 1] output: [1, 2, 3, 4] input: [1, 2, 3] output: [1, 2, 3] input: [] output: [] ``` Context The Pancake Sort algorithm simulates the process of sorting pancakes in a stack by flipping them with a spatula. Although not suited for production environments, understanding and optimizing this algorithm can enhance your comprehension of sorting techniques and algorithm design. **Requirements**: 1. Implement the flipping (prefix reversal) operation. 2. Optimize the algorithm to reduce unnecessary flips and checks. 3. Ensure robust handling of edge cases such as empty arrays or arrays with a single element.","solution":"def flip(arr, k): Reverse the order of the first k elements of arr. return arr[:k][::-1] + arr[k:] def optimized_pancake_sort(arr): Sorts the array using an optimized pancake sort method. n = len(arr) for i in range(n, 1, -1): # Find the index of the largest element not yet sorted max_idx = max(range(i), key=arr.__getitem__) # If the largest element is not already in its final position, flip it to the front and then to its final position if max_idx + 1 != i: if max_idx != 0: # Flip the largest element to the front arr = flip(arr, max_idx + 1) # Flip the largest element to its final position arr = flip(arr, i) return arr"},{"question":"You are working on a text segmentation tool that determines if a given string can be segmented into a sequence of valid words from a dictionary. Implement a function `can_segment_string` that takes two parameters: `s` (a non-empty string) and `word_dict` (a list of non-empty words), and returns a boolean indicating if `s` can be fully segmented using the words in `word_dict`. Function Signature: ```python def can_segment_string(s: str, word_dict: List[str]) -> bool: pass ``` # Input * `s`: A non-empty string `1 <= len(s) <= 300`. * `word_dict`: A list of non-empty words. The dictionary does not contain duplicate words. # Output * Returns `True` if string `s` can be segmented into valid dictionary words, `False` otherwise. # Constraints * Elements of `word_dict` contain only lowercase English letters. * The string `s` is also composed only of lowercase English letters. # Example ```python assert can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True assert can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False ``` # Scenario Imagine you are part of a team developing an autocomplete feature for a search engine. The feature works by checking if a user\'s query can be split into valid search terms found in a pre-compiled dictionary of frequently searched terms. Your task is to implement the function `can_segment_string` to aid in assessing valid search terms and improving the search results accuracy. # Performance Requirement Ensure that your solution can handle up to the maximum string length efficiently, given the constraints.","solution":"from typing import List def can_segment_string(s: str, word_dict: List[str]) -> bool: word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"You have been tasked to implement an efficient algorithm for calculating combinations (nCr). This function is essential in many fields such as statistics, computer science, and game theory. Given the large possible values for n and r, a highly efficient solution is needed. Write a function `combination_optimized` that calculates the number of ways to choose r items from n items using dynamic programming. Your solution should be optimized for both time and space complexity. Function Signature ```python def combination_optimized(n: int, r: int) -> int: pass ``` Input * `n` (0 ≤ n ≤ 10^5): The total number of items. * `r` (0 ≤ r ≤ n): The number of items to choose. Output * Returns an integer representing the number of ways to choose r items from n items. Constraints * The function should handle large values of n and r efficiently. * Time complexity should be close to O(n*r) or better. * Space complexity should be optimized to an acceptable level. Examples * `combination_optimized(5, 2)` should return 10 * `combination_optimized(10, 3)` should return 120 * `combination_optimized(0, 0)` should return 1 # Requirements 1. Implement the function in a way that avoids redundant calculations. 2. Make use of dynamic programming or other optimization techniques to improve the efficiency. 3. Handle edge cases appropriately, such as when n < r or invalid inputs. Notes * You may use Python’s built-in libraries for additional optimizations if necessary. * Aim to provide a solution that is both clear and concise, and demonstrates your understanding of efficient algorithms and data structures. Submit your `combination_optimized` function in a single Python file.","solution":"def combination_optimized(n, r): Returns the number of ways to choose r items from n items using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 # Ensure r is the smaller of the two values for efficiency r = min(r, n - r) # Use a dynamic programming approach with a single row (1D array) C = [0] * (r + 1) C[0] = 1 # nC0 is 1 for i in range(1, n + 1): # Compute next row of pascal triangle using the previous row for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"You are required to implement a function `optimized_interpolation_search`, which improves on the standard interpolation search by handling edge cases and optimizing performance. Your function should find the index of a given `search_key` within a sorted array. # Function Signature ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` # Input * `array`: A list of integers in increasing order (sorted). * `search_key`: An integer to be searched in the array. # Output * An integer representing the index of `search_key` if found in the array; otherwise, return `-1`. # Constraints * Do not use any built-in search functions. * The function should handle edge cases gracefully: - Empty array or array with one element. - Arrays with non-uniform distributions. - Avoid division by zero. * Optimize for uniformly distributed data. * Consider the worst-case performance efficiency. # Example ```python print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 12)) # Output: 2 print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 15)) # Output: -1 print(optimized_interpolation_search([], 4)) # Output: -1 print(optimized_interpolation_search([10], 10)) # Output: 0 print(optimized_interpolation_search([5, 7, 9, 20, 20, 30], 20)) # Output: 3 or 4 ``` # Notes * Ensure the function operates within the expected time and space complexity. * Test for uniform and non-uniform data distributions. * The function should ensure valid array accesses to avoid errors.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: if not array: return -1 low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 if array[low] == array[high]: if array[low] == search_key: return low else: return -1 pos = low + ((high - low) * (search_key - array[low]) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Scenario You\'re a software engineer tasked with designing a custom priority queue system. Given the familiarity and performance traits of heaps, you decide to implement sorting mechanisms that rely on both max-heaps and min-heaps. Your task is to adapt these sorting methods to accommodate a dynamic, adjustable sorting direction specified at runtime. # Question Implement a function that takes an array and a sorting direction (`\'ascend\'` for ascending order or `\'descend\'` for descending order) to sort the array using heap sort accordingly. # Function Signature ```python def adjustable_heap_sort(arr: list, direction: str) -> list: Sorts an array in either ascending or descending order using heap sort. :param arr: List of integers to be sorted. :param direction: Sorting order, \'ascend\' for ascending and \'descend\' for descending. Any other value should raise ValueError. :return: The sorted list. :raises ValueError: If the direction is not recognized. pass ``` # Input - `arr` (list): A list of integers to be sorted. (0 <= len(arr) <= 10^5) - `direction` (str): Indicates sorting order, either `\'ascend\'` or `\'descend\'`. # Output - A list of integers sorted according to the specified direction. # Constraints - You must use max heap for descending order and min heap for ascending order. - Handle invalid directions with appropriate error handling. - Aim for optimal performance with O(n log(n)) complexity. # Example ```python assert adjustable_heap_sort([3, 9, 2, 1, 4], \'ascend\') == [1, 2, 3, 4, 9] assert adjustable_heap_sort([3, 9, 2, 1, 4], \'descend\') == [9, 4, 3, 2, 1] assert adjustable_heap_sort([], \'ascend\') == [] assert adjustable_heap_sort([7], \'descend\') == [7] try: adjustable_heap_sort([2, 3, 5], \'upwards\') except ValueError as e: assert str(e) == \'Invalid sorting direction\' ``` # Additional Information You may reuse the `max_heap_sort` and `min_heap_sort` functions and their helpers (`max_heapify` and `min_heapify`) from the provided code snippets. The critical part is to integrate them seamlessly to achieve the adaptive sorting based on the specified direction.","solution":"def adjustable_heap_sort(arr: list, direction: str) -> list: Sorts an array in either ascending or descending order using heap sort. :param arr: List of integers to be sorted. :param direction: Sorting order, \'ascend\' for ascending and \'descend\' for descending. Any other value should raise ValueError. :return: The sorted list. :raises ValueError: If the direction is not recognized. def heapify(arr, n, i, comparator): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and comparator(arr[left], arr[largest]): largest = left if right < n and comparator(arr[right], arr[largest]): largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, comparator) def heap_sort(arr, comparator): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, comparator) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, comparator) if direction == \'ascend\': comparator = lambda x, y: x > y elif direction == \'descend\': comparator = lambda x, y: x < y else: raise ValueError(\\"Invalid sorting direction\\") heap_sort(arr, comparator) return arr"},{"question":"# Scenario: Fibonacci Sequence Generator Given the mathematical background and different implementations of the Fibonacci sequence, you are tasked with designing a performance-efficient Fibonacci number generator. # Problem Statement: Write a function `fib_optimized` that computes the n-th Fibonacci number. This function should be both time and space-efficient. Consider the constraints and requirements below for your full implementation. # Function Signature: ```python def fib_optimized(n: int) -> int: ``` # Input: * An integer `n` (0 ≤ n ≤ 10^6). # Output: * The n-th Fibonacci number. # Requirements: 1. **Performance**: The solution should run in O(n) time complexity and O(1) space complexity. 2. **Correctness**: Handle edge cases where n=0 and n=1 appropriately. 3. **Stability**: Ensure that your function can handle very large inputs without performance issues or memory overflow. # Constraints: * The input integer `n` will be in the range from 0 to 1,000,000. * Fibonacci numbers can grow very large; consider the maximum value that might be needed for very high n values. # Example: - Example 1: - Input: `n = 0` - Output: `0` - Example 2: - Input: `n = 10` - Output: `55` - Example 3: - Input: `n = 1000000` - Output: Should compute efficiently. # Additional Information: When computing very large Fibonacci numbers, consider Python\'s ability to handle large integers. The time complexity of your function should always remain linear relative to the size of the input, and the space complexity should be constant. # Hint: Consider leveraging iterative approaches and optimizing constant space usage to achieve the required specifications.","solution":"def fib_optimized(n: int) -> int: Computes the n-th Fibonacci number in an optimized manner using O(n) time complexity and O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Interpolation Search Implementation and Analysis Problem Statement Implement the Interpolation Search algorithm in Python, ensuring your function can handle edge cases efficiently. Additionally, analyze the efficiency of your implementation on different types of datasets: sorted with uniform distribution, sorted with non-uniform distribution, and unsorted datasets. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: pass ``` Input * `array`: A sorted list of integers where the search will be performed (0 <= len(array) <= 10^6). * `search_key`: An integer to be searched within the array. Output Return the index of `search_key` if found; otherwise, return `-1`. Constraints * The input array can be empty. * Input array is sorted in non-decreasing order. * No duplicates in the array. Examples ```python # Example 1 assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 # Example 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 # Example 3 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 # Edge Case Example assert interpolation_search([], 10) == -1 assert interpolation_search([10], 10) == 0 assert interpolation_search([10], 5) == -1 assert interpolation_search([1, 1, 1, 1, 1], 1) == 0 ``` Additional Analysis Task Perform an analysis of your implementation by running it on the following dataset types: 1. Large sorted array with uniform distribution. 2. Large sorted array with non-uniform distribution. 3. Unsorted array (to observe impact). Document your findings on time performance and any optimizations you suggest.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Implements the interpolation search algorithm to find the search_key in a sorted array. Parameters: array (List[int]): A list of sorted integers. search_key (int): The integer value to search for. Returns: int: The index of search_key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero and search within bounds. if array[low] == array[high]: if array[low] == search_key: return low return -1 # Calculate the position using interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if pos < 0 or pos >= len(array): return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are a data analyst tasked with analyzing the distribution of numerical data. Your goal is to summarize a given list of numbers by counting the frequency of each unique number. Create a function that takes a list of integers and returns a dictionary representing the histogram of the list. # Function Signature ```python def get_histogram(input_list: list) -> dict: ``` # Input - `input_list`: A list of integers. The list may contain repeated numbers and can be arbitrarily large. # Output - A dictionary where the keys are the unique integers from the input list, and the values are the counts of those integers. # Constraints 1. The input list can contain integers in any order. 2. The input list can be empty, in which case the function should return an empty dictionary. # Performance Requirements - The implementation should be optimized for linear time complexity (O(n)). - The solution should also handle the case where the input list is very large, but the total number of unique integers should fit into memory. # Example ```python # Example 1 input_list = [3, 3, 2, 1] # Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` # Special Note - Ensure that your function handles edge cases correctly, such as an empty input list or lists with negative numbers.","solution":"def get_histogram(input_list): Takes a list of integers and returns a dictionary representing the histogram of the list. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary where keys are unique integers from the input list and the values are their counts. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"Find nth Digit in Sequence **Objective**: Write a function that finds the nth digit in the sequence of concatenated positive integers (e.g., 123456789101112...). **Function Signature**: ```python def find_nth_digit(n: int) -> int: Given an integer n, returns the nth digit of the infinite integer sequence. :param n: Non-negative integer representing the digit position in the sequence. :return: The nth digit of the sequence. ``` **Input**: * `n`: an integer (1 ≤ n ≤ 2^31 - 1). **Output**: * Returns an integer, which is the nth digit of the infinite sequence of concatenated positive integers. **Example**: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` **Constraints**: * You must ensure your solution works within a reasonable time frame for large values of `n`. **Scenario/Context**: Imagine a giant digital billboard that continually displays all positive integers in sequence, one after another. Your task is to determine which digit is displayed at a particular position, based on the given index `n`. This method could be used in optimizing advert timings or detecting patterns in such massive displays. Provide a detailed implementation of your solution taking into consideration edge cases, efficiency, and correctness.","solution":"def find_nth_digit(n: int) -> int: Given an integer n, returns the nth digit of the infinite integer sequence. :param n: Non-negative integer representing the digit position in the sequence. :return: The nth digit of the sequence. if n < 1: raise ValueError(\\"n must be a positive integer\\") length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Coding Assessment Question # Context A binary heap is a complete binary tree which maintains the heap property — each parent node in the heap is less than or equal to its children. This data structure is widely used in implementing priority queues due to its efficient support for insert and remove operations. # Problem Statement Implement a `BinaryHeapPython` class that can support the following operations: 1. **Insert**: Insert an integer into the heap. 2. **Remove Min**: Remove and return the minimum element from the heap. 3. **Heapify**: Given a list of integers, convert it into a binary heap. # Specific Requirements 1. **Insert** - Input: An integer `val` - Output: None - Operation: Insert `val` into the heap while maintaining the heap property. 2. **Remove Min** - Input: None - Output: The minimum element in the heap. - Operation: Remove and return the minimum element, then restructure the heap to maintain the heap property. 3. **Heapify** - Input: A list of integers `lst` - Output: None - Operation: Convert the given list into a binary heap in place. # Constraints - You may assume that all integers are unique. - The heap operations should be consistent with the min-heap property. # Example ```python heap = BinaryHeapPython() heap.insert(3) heap.insert(1) heap.insert(6) heap.insert(5) heap.insert(2) heap.insert(4) print(heap.remove_min()) # Output: 1 print(heap.remove_min()) # Output: 2 heapify_list = [9, 6, 8, 2, 1, 4] heap.heapify(heapify_list) print(heap.remove_min()) # Output: 1 ``` # Implementation Details You need to implement the following methods: ```python class BinaryHeapPython: def __init__(self): # Initialize the binary heap pass def insert(self, val): # Insert val into the heap pass def remove_min(self): # Remove and return the minimum element from the heap pass def heapify(self, lst): # Convert the list into a binary heap pass ``` # Notes Ensure that your implementation handles edge cases such as inserting into an empty heap and removing from a single-element heap. Pay special attention to maintaining the heap\'s structural and ordering properties during each operation.","solution":"class BinaryHeapPython: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._bubble_up(len(self.heap) - 1) def remove_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_val def heapify(self, lst): self.heap = lst[:] for i in range(len(self.heap) // 2, -1, -1): self._bubble_down(i) def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest)"},{"question":"# Question: Implementing Optimized Binary Search **Context**: You\'re tasked with searching for an integer value in a sorted array of integers. Since the dataset can be very large, the efficiency of your search algorithm is critical. The array is guaranteed to be sorted in ascending order. **Objective**: Implement both iterative and recursive versions of the optimized binary search algorithm. **Function Signatures**: * Implement `def binary_search(array: List[int], target: int) -> int:` * Implement `def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int:` **Input**: - `array`: A list of integers sorted in ascending order. - `target`: The integer value to search for in the array. - For the recursive version, also include: - `low`: The starting index of the array segment to search. - `high`: The ending index of the array segment to search. **Output**: - Returns the index of the `target` value within the array if found, otherwise `-1`. **Constraints**: - The length of the array will be at most (10^6). - The array is sorted in ascending order. - The values in the array and the target will be between (-10^9) and (10^9). **Performance Requirements**: - The solution must run in logarithmic time O(log n) for both versions. **Examples**: 1. `binary_search([10, 20, 30, 40, 50], 30)` should return `2`. 2. `binary_search_recursive([10, 20, 30, 40, 50], 0, 4, 25)` should return `-1`. **Additional Instructions**: - Ensure to handle edge cases such as an empty array, array with one element, and duplicates of target value. **Notes**: - Consider using an optimized midpoint calculation to avoid potential overflow.","solution":"from typing import List def binary_search(array: List[int], target: int) -> int: Iterative binary search. low, high = 0, len(array) - 1 while low <= high: mid = low + (high - low) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: Recursive binary search. if low > high: return -1 mid = low + (high - low) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"Context: You are implementing a task scheduler for a real-time system where tasks are queued based on their priority. The most critical task is processed first. Objective: Write a Python class `AdvancedPriorityQueue` that extends the given `PriorityQueue` class. Your task is to implement an `update_priority` method that updates the priority of an existing item in the queue. If the item does not exist in the queue, it should be added with the given priority. Function Signature: ```python class AdvancedPriorityQueue(PriorityQueue): def update_priority(self, item: Any, new_priority: int) -> None: pass ``` Implementations Details: - The method should ensure that the item is present in the correct position after the priority update. - If the item is not present, add it with the given priority. - You may assume `PriorityQueueNode` and `PriorityQueue` classes are defined as in the provided code snippet. Constraints: - The priority of tasks is an integer. - Tasks are unique. Example: ```python a_queue = AdvancedPriorityQueue() a_queue.push(\'task1\', priority=1) a_queue.push(\'task2\', priority=3) a_queue.update_priority(\'task2\', 2) a_queue.update_priority(\'task3\', 5) assert a_queue.pop() == \'task1\' # task with priority 1 assert a_queue.pop() == \'task2\' # task with updated priority 2 assert a_queue.pop() == \'task3\' # newly added task with priority 5 ``` Performance Requirement: Ensure the update operation has a worst-case time complexity of O(n).","solution":"import heapq class PriorityQueueNode: def __init__(self, priority, item): self.priority = priority self.item = item def __lt__(self, other): return self.priority < other.priority class PriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): heapq.heappush(self.heap, PriorityQueueNode(priority, item)) def pop(self): if self.heap: return heapq.heappop(self.heap).item return None def is_empty(self): return len(self.heap) == 0 class AdvancedPriorityQueue(PriorityQueue): def update_priority(self, item, new_priority): # Check if item is in the queue found = False for node in self.heap: if node.item == item: # Update the priority node.priority = new_priority found = True break if found: # Rebuild the heap since a priority was updated heapq.heapify(self.heap) else: # Item not found, add it with new_priority self.push(item, new_priority)"},{"question":"# Question: Anagram Checker for Diverse Character Sets Context In this assessment, you\'ll need to implement an optimized version of the anagram checker to handle a broader range of characters beyond just lowercase alphabetic letters. Specifically, you should account for uppercase letters, digits, and punctuation marks. Problem Statement Given two strings, determine if they are anagrams of each other. Two strings are considered anagrams if they can be rearranged to form the same string. Your implementation should handle all ASCII characters (i.e., characters with ASCII values from 0 to 127). Write a function `is_anagram` with the following signature: ```python def is_anagram(s1: str, s2: str) -> bool: ``` Input - `s1` (string): The first string to be compared. - `s2` (string): The second string to be compared. Output - Returns `True` if `s1` and `s2` are anagrams, otherwise returns `False`. Examples ```python is_anagram(\\"apple\\", \\"pleap\\") -> True is_anagram(\\"apple\\", \\"apple!\\") -> False is_anagram(\\"123\\", \\"321\\") -> True is_anagram(\\"hello\\", \\"jello\\") -> False is_anagram(\\"A gentleman\\", \\"Elegant man\\") -> False # Case sensitivity and spaces make it False ``` Constraints - The function should handle strings with up to 100,000 characters efficiently. - Consider all ASCII characters (0 to 127) - Performance should be kept within O(n) time complexity and O(c) space complexity where c is a constant representing the number of possible characters (128 for ASCII). Implementation Notes - Use a counter mechanism to count character occurrences in both strings. - Ensure proper handling of edge cases like strings of different lengths or empty strings. Additional Information Edge cases, input constraints, and specific performance requirements are detailed above. Your implementation should carefully consider these factors to ensure correctness and efficiency.","solution":"def is_anagram(s1: str, s2: str) -> bool: from collections import Counter # If the lengths are not equal, they can\'t be anagrams if len(s1) != len(s2): return False # Count character frequencies in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Compare the two counters return counter1 == counter2"},{"question":"# Problem: Implement a Doubly Linked List with Key Operations You are tasked to implement a Doubly Linked List that supports several key operations. Define a class `DoublyLinkedList` which includes the following methods: 1. **`insert_at_end(self, value)`**: Inserts a new node with the specified value at the end of the linked list. 2. **`delete(self, value)`**: Deletes the first node with the specified value from the list. If the value is not found, no action should be taken. 3. **`find(self, value)` -> bool**: Searches the list for a node with the specified value and returns `True` if found, otherwise returns `False`. 4. **`display(self)`**: Prints out all the values in the doubly linked list from beginning to end. Example ```python dll = DoublyLinkedList() dll.insert_at_end(5) dll.insert_at_end(3) dll.insert_at_end(7) dll.display() # Output: 5 3 7 dll.delete(3) dll.display() # Output: 5 7 print(dll.find(5)) # Output: True print(dll.find(3)) # Output: False ``` Constraints 1. The linked list starts empty. 2. Assume all node values are unique integers. Submission Requirements * Ensure your code handles edge cases such as deleting from an empty list and deleting nodes that do not exist. * Your `display` method should print node values in a single line separated by spaces. * Aim to minimize the time complexity of the insert and delete operations.","solution":"class Node: def __init__(self, value): Initializes a node with the specified value and references to the next and previous nodes. self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): Initializes an empty doubly linked list. self.head = None self.tail = None def insert_at_end(self, value): Inserts a new node with the specified value at the end of the linked list. new_node = Node(value) if self.tail is None: # List is empty self.head = self.tail = new_node else: # Append to the end new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete(self, value): Deletes the first node with the specified value from the list. If the value is not found, no action is taken. current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def find(self, value): Searches the list for a node with the specified value and returns True if found, otherwise returns False. current = self.head while current: if current.value == value: return True current = current.next return False def display(self): Prints out all the values in the doubly linked list from beginning to end. current = self.head values = [] while current: values.append(current.value) current = current.next print(\\" \\".join(map(str, values)))"},{"question":"# Wiggle Sort Challenge You are given an unsorted integer array `nums`. Your task is to reorder the array such that `nums[0] < nums[1] > nums[2] < nums[3]`. This kind of ordering is known as a \\"wiggle sort.\\" # Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Reorder the list nums in place to meet the wiggle pattern. ``` # Input Parameters - `nums`: A list of integers, where 1 <= len(nums) <= 10^5 and -10^6 <= nums[i] <= 10^6. # Task Write a function that modifies the array in place to achieve the required wiggle sorting. # Example ```python array = [3, 5, 2, 1, 6, 4] wiggle_sort(array) print(array) # Possible output: [3, 5, 1, 6, 2, 4] ``` # Constraints 1. The solution should aim for a time complexity of O(n). 2. Extra space usage should be minimized; ideally, only constant space should be used. # Notes - The input list may contain duplicate elements. - There are multiple valid wiggle sorted configurations for any given input; any valid configuration will be accepted. # Scenario Imagine you are designing a wave-like sequence for a dance choreography where heights (elements) of dancers need to follow an alternating pattern to create a visual effect. Implementing the wiggle sort will help you achieve the desired order. # Edge Cases to Consider 1. An array with a single element (should remain unchanged). 2. Arrays that are already wiggle sorted. 3. Arrays either strictly increasing or decreasing.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Reorder the list nums in place to meet the wiggle pattern. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"Coding Assessment Question # Matrix Inversion Function Implementation **Objective**: Implement a function to invert an invertible (n times n) matrix, adhering to the principles of matrix operations, including the use of minors, cofactors, adjugation, and determinant calculations. # Problem Statement: You are required to implement a function `invert_matrix(matrix: List[List[float]]) -> List[List[float]]` that takes as input a square (n times n) matrix of floats and returns its inverted matrix. # Input: - `matrix`: A list of lists representing a square (n times n) matrix (`n` ≥ 2). Each element within the nested lists is a float. # Output: - A list of lists representing the inverted matrix if the input matrix is invertible. # Constraints: - You can assume that `n` is reasonably small (e.g., ( n leq 15)) to maintain feasibility given the cubic time complexity of matrix inversion. - The matrix will be correctly formatted and will not be empty. # Performance Requirements: - The function must efficiently handle the inversion process for matrices up to the size of ( 15 times 15 ). # Example: ```python matrix = [ [1, 2], [3, 4] ] invert_matrix(matrix) # Output: [[-2.0, 1.0], [1.5, -0.5]] ``` # Additional Notes: - Ensure to handle the non-invertible matrices (determinant = 0) by raising an appropriate exception. - Implement helper functions as necessary to modularize the tasks (e.g., determinant calculation, minors, adjugation).","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): submatrix = [row[:c] + row[c+1:] for row in matrix[1:]] sign = (-1) ** c det += sign * matrix[0][c] * determinant(submatrix) return det def minor(matrix: List[List[float]], row: int, col: int) -> List[List[float]]: Calculate the minor of a matrix element at a specified row and column. return [r[:col] + r[col+1:] for r in (matrix[:row] + matrix[row+1:])] def cofactor(matrix: List[List[float]]) -> List[List[float]]: Calculate the cofactor matrix of a given square matrix. n = len(matrix) cofactors = [] for r in range(n): cofactor_row = [] for c in range(n): minor_matrix = minor(matrix, r, c) sign = (-1) ** ((r + 1) + (c + 1)) cofactor_val = sign * determinant(minor_matrix) cofactor_row.append(cofactor_val) cofactors.append(cofactor_row) return cofactors def transpose(matrix: List[List[float]]) -> List[List[float]]: Transpose a matrix. return list(map(list, zip(*matrix))) def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Invert a given square matrix. n = len(matrix) det = determinant(matrix) if det == 0: raise ValueError(\\"Matrix is not invertible\\") cofactors = cofactor(matrix) adjugate = transpose(cofactors) inverse = [[adjugate[r][c] / det for c in range(n)] for r in range(n)] return inverse"},{"question":"Context Segment trees are highly efficient data structures that are used for performing queries and updates on ranges of an array quickly. This question will test your ability to implement a segment tree and efficiently apply it to solve a problem that requires frequent range queries. Task You are asked to implement a function `range_query` that builds a segment tree and uses it to answer multiple range queries. Input Your function will receive three parameters: 1. **arr** (List[int]): A list of integers representing the initial array. 2. **queries** (List[Tuple[str, int, int]]): A list of queries. Each query is a tuple containing three elements: * A string indicating the type of query - either \\"sum\\" or \\"max\\". * An integer representing the start index (inclusive) of the query range. * An integer representing the end index (inclusive) of the query range. 3. **function_map** (Dict[str, Callable[[int, int], int]]): A dictionary that maps the query type \\"sum\\" or \\"max\\" to their respective functions. Output Return a list of integers where each integer is the result of a corresponding query in the `queries` list. Example ```python def range_query(arr: List[int], queries: List[Tuple[str, int, int]], function_map: Dict[str, Callable[[int, int], int]]) -> List[int]: pass # Example usage: arr = [2,4,5,3,4] queries = [(\\"max\\", 2, 4), (\\"sum\\", 0, 3)] function_map = { \\"sum\\": lambda x, y: x + y, \\"max\\": lambda x, y: max(x, y) } Output: [5, 14] # Explanation: # \\"max\\" query from index 2 to 4 yields the maximum value 5. # \\"sum\\" query from index 0 to 3 yields the sum 14. ``` Constraints - 1 <= len(arr) <= 10^5 - 0 <= l <= r < len(arr) - Functions in function_map will always be associative and commutative. Write the function `range_query` in Python to implement the described functionality.","solution":"from typing import List, Tuple, Dict, Callable class SegmentTree: def __init__(self, data: List[int], function: Callable[[int, int], int], default: int): self.n = len(data) self.function = function self.default = default self.tree = [default] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[i + self.n] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, l: int, r: int) -> int: result = self.default l += self.n r += self.n + 1 while l < r: if l % 2 == 1: result = self.function(result, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 result = self.function(result, self.tree[r]) l //= 2 r //= 2 return result def range_query(arr: List[int], queries: List[Tuple[str, int, int]], function_map: Dict[str, Callable[[int, int], int]]) -> List[int]: results = [] sum_segment_tree = SegmentTree(arr, function_map[\'sum\'], 0) max_segment_tree = SegmentTree(arr, function_map[\'max\'], float(\'-inf\')) for query in queries: q_type, start, end = query if q_type == \'sum\': results.append(sum_segment_tree.query(start, end)) elif q_type == \'max\': results.append(max_segment_tree.query(start, end)) return results # Example usage: arr = [2,4,5,3,4] queries = [(\\"max\\", 2, 4), (\\"sum\\", 0, 3)] function_map = { \\"sum\\": lambda x, y: x + y, \\"max\\": lambda x, y: max(x, y) } print(range_query(arr, queries, function_map)) # Output: [5, 14]"},{"question":"You are given a list of non-negative integers. Your task is to implement the Radix Sort algorithm to sort this list. # Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input - `arr`: A list of non-negative integers. - `simulation`: A boolean flag. If set to `True`, print the intermediate steps of the algorithm for educational purposes. Default is `False`. # Output - Returns the sorted list of integers. # Constraints 1. The length of `arr` will not exceed 10^5. 2. Each integer in `arr` can be as large as 10^9. # Requirements You must: 1. Implement the Radix Sort algorithm. 2. Handle edge cases such as an empty list and a list containing a single element. 3. Ensure the implementation is efficient both in terms of time and space. # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] # With simulation # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 170 90 802 2 24 45 75 66 # iteration 2 : 802 2 24 45 66 75 170 90 assert radix_sort([3, 1, 2, 3, 1], True) == [1, 1, 2, 3, 3] ``` # Additional Notes 1. Ensure your function handles lists efficiently to match the constraints. 2. The `simulation` flag is to visually demonstrate the internal progression of the algorithm and aid learning.","solution":"from typing import List def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {exp} : {\' \'.join(map(str, arr))}\\") max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Context You are tasked with cleaning up inventory data for a large retail store. The inventory list contains various SKU prices, and the retail management system only processes items priced between a specific range defined by the management team. You are required to implement a function that filters out the SKU prices that do not fall within the management-defined range. # Task Implement a function `limit_prices` that: * Takes an array of integers representing SKU prices. * Takes two optional integer parameters `min_price` and `max_price` representing the minimum and maximum price limits respectively. * Returns a new array containing only the SKU prices that fall within the inclusive range `[min_price, max_price]`. If `min_price` is not provided, it should use the smallest value in the array. If `max_price` is not provided, it should use the largest value in the array. # Function Signature ```python def limit_prices(prices: List[int], min_price: Optional[int] = None, max_price: Optional[int] = None) -> List[int]: ``` # Input * `prices` (List[int]): A list of integers where each integer represents an SKU price. * `min_price` (Optional[int]): Minimum price limit. Default is None. * `max_price` (Optional[int]): Maximum price limit. Default is None. # Output * List[int]: A new list of integers with SKU prices within the specified range. # Constraints * The input list `prices` will have at most 10^6 elements. * Each price will be a non-negative integer not greater than 10^6. * No explicit constraints on time or space, but aim to adhere to linear complexity. # Example 1. `limit_prices([12, 99, 25, 34, 57, 100], 20, 50)` should return `[25, 34]`. 2. `limit_prices([12, 99, 25, 34, 57, 100], None, 30)` should return `[12, 25]`. 3. `limit_prices([12, 99, 25, 34, 57, 100])` should return `[12, 99, 25, 34, 57, 100]`. # Note When both `min_price` and `max_price` are None, the function should return the entire array as no filtering is required.","solution":"from typing import List, Optional def limit_prices(prices: List[int], min_price: Optional[int] = None, max_price: Optional[int] = None) -> List[int]: if not prices: return [] if min_price is None: min_price = min(prices) if max_price is None: max_price = max(prices) return [price for price in prices if min_price <= price <= max_price]"},{"question":"**Objective**: Verify if two given strings are anagrams. **Scenario**: In an encryption system, an encrypted message is considered valid if it is an anagram of a given string. Your task is to write a function that determines whether a given target string is an anagram of the original string. This will help the encryption system to validate the encrypted message. **Function Specification**: * `def are_anagrams(s: str, t: str) -> bool:` **Input**: 1. `s` (str): The original string. Contains only lowercase alphabets. 2. `t` (str): The target string to be checked. Contains only lowercase alphabets. **Output**: * Return `True` if `t` is an anagram of `s`, otherwise return `False`. **Constraints**: * Both `s` and `t` will consist of `lowercase English letters` only. **Performance Requirement**: * The solution should run in linear time, O(n). **Examples**: ```python assert are_anagrams(\\"anagram\\", \\"nagaram\\") == True assert are_anagrams(\\"rat\\", \\"car\\") == False ``` **Edge Cases Example**: ```python assert are_anagrams(\\"\\", \\"\\") == True # Empty strings case assert are_anagrams(\\"a\\", \\"a\\") == True # Single character case assert are_anagrams(\\"ab\\", \\"ba\\") == True # Two characters, different strings assert are_anagrams(\\"a\\", \\"b\\") == False # Different characters ``` **Explanation**: Your implementation should consider efficiency and correctness by optimizing how you count and compare the characters of the two strings. You should handle different possible edge cases and invalid inputs based on the constraints provided.","solution":"def are_anagrams(s: str, t: str) -> bool: from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Challenge: Implement Enhanced Pancake Sort with Optimization You work at a software company developing sorting utilities, and you have been tasked to enhance an existing sorting method known as Pancake Sort. While the base algorithm works correctly, it is not optimized for performance due to its high time complexity. You need to retain the properties of Pancake Sort but optimize as best as you can. Requirements: 1. **Function Signature**: Implement the function `pancake_sort_optimized` which takes a single list `arr` as its parameter and returns the sorted list. 2. **Input**: - An array of integers `arr` with size n (1 <= n <= 1000 and –10^5 <= arr[i] <= 10^5 for i in range(n)). 3. **Output**: - Return a new list that contains the sorted order of input list `arr`. 4. **Constraints**: - The implementation should be in-place and maintain O(1) space complexity. - Time complexity should aim to be better or as close to O(N log N) as feasible while adhering to the Pancake Sort principles. Performance Requirements: - Aim to optimize the number of flips by minimizing unnecessary operations. - Ensure the solution handles common edge cases robustly. Example: ```python def pancake_sort_optimized(arr): # your optimized solution here # Example Usage print(pancake_sort_optimized([3, 1, 4, 1, 5, 9])) # Output should be [1, 1, 3, 4, 5, 9] ``` Your task is to design an efficiency-focused version of Pancake Sort while adhering to the given constraints and properties. Optimize wherever possible and ensure your solution passes large input sizes within acceptable time limits.","solution":"def pancake_sort_optimized(arr): def flip(sublist, k): start = 0 while start < k: sublist[start], sublist[k] = sublist[k], sublist[start] start += 1 k -= 1 for size in range(len(arr), 1, -1): # Find the index of the maximum element in the unsorted part of the array max_index = arr.index(max(arr[:size])) # Move the maximum element to the end of the unsorted part via two flips if max_index != size - 1: # Flip the maximum number to the first position if max_index != 0: flip(arr, max_index) # Flip it to its correct position in the sorted part flip(arr, size - 1) return arr"},{"question":"# Context Imagine you are working on a navigation system for a robot that can only move right or down on a grid. You need to determine how many unique paths the robot can take to go from the top-left corner to the bottom-right corner of the grid. # Problem Statement Write a function `count_unique_paths(rows: int, cols: int) -> int` that takes in two integers `rows` and `cols`, representing the number of rows and columns in the grid respectively. The function should return the number of unique paths from the top-left corner to the bottom-right corner. # Function Signature ```python def count_unique_paths(rows: int, cols: int) -> int: ``` # Input * An integer `rows` (1 ≤ rows ≤ 100) * An integer `cols` (1 ≤ cols ≤ 100) # Output * An integer representing the number of unique paths from the start (top-left) to the end (bottom-right). # Constraints * The robot can only move either right or down. * The grid is represented as a matrix of `rows` x `cols`. # Performance * The function should have a time complexity of O(rows * cols). * The function should have a space complexity of O(rows * cols). # Examples ```python # Example 1 print(count_unique_paths(3, 3)) # Output: 6 # Example 2 print(count_unique_paths(4, 4)) # Output: 20 # Example 3 print(count_unique_paths(1, 5)) # Output: 1 ``` # Notes The value of `rows` and `cols` will be within the specified constraints. Ensure to handle edge cases where the dimensions may lead to minimalistic grids, such as `1xN` or `Mx1`.","solution":"def count_unique_paths(rows: int, cols: int) -> int: Returns the number of unique paths from the top-left to the bottom-right of a grid. Parameters: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. Returns: int: Number of unique paths. # Create a 2D list initialized to 0 dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the first row and first column to 1 for i in range(rows): dp[i][0] = 1 for j in range(cols): dp[0][j] = 1 # Fill the dp array with the number of unique paths to each cell for i in range(1, rows): for j in range(1, cols): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"**Title**: Efficient Combination Calculation Using Dynamic Programming **Problem Statement**: You are provided with a task to calculate the number of ways to choose `r` items from `n` items without regard to the order of selection (a combination calculation). Given `n` and `r`, write a function that efficiently computes the combination using dynamic programming to avoid redundant computations. # Function Signature ```python def combination_dp(n: int, r: int) -> int: ``` # Input * `n` (1 <= n <= 1000): Total number of items. * `r` (0 <= r <= n): Number of items to be chosen. # Output * Return an integer representing the number of ways to choose `r` items out of `n`. # Performance Requirements * The implementation should utilize dynamic programming concepts to ensure the solution is efficient even for larger values of `n` up to 1000. # Constraints * In Python, consider the limitations of recursion depth and large integer calculations. # Example ```python assert combination_dp(5, 2) == 10 assert combination_dp(10, 5) == 252 assert combination_dp(100, 50) == 100891344545564193334812497256 ``` # Additional Requirements * Handle edge cases such as when r equals 0 or n. * Avoid using the built-in `math.comb` function to ensure understanding of the algorithm. * Implement the solution using an iterative dynamic programming approach rather than recursion to handle larger inputs efficiently. # Scenario: Imagine you are a software engineer working on a probability calculation module for a sophisticated statistics application. Efficiently calculating combinations is critical for handling large datasets and producing results in a timely manner. Your task is to implement a combination calculator that meets these performance requirements.","solution":"def combination_dp(n: int, r: int) -> int: Computes the combination nCr using dynamic programming. :param n: Total number of items :param r: Number of items to be chosen :return: Number of ways to choose r items from n if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): # Base cases if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"# Scenario You have been tasked with creating a small part of a library for handling small arrays of numerical data. One of the functions you need to implement is an efficient sorting function for small datasets where the dataset may often be nearly sorted. # Problem Statement Implement a function named `optimized_insertion_sort` in Python, which sorts an array of integers using the insertion sort algorithm. Your implementation should aim to optimize the sorting process in situations where the array is nearly sorted. # Function Signature ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input * An array `arr` of integers where `1 ≤ len(arr) ≤ 10^3` and `-10^6 ≤ arr[i] ≤ 10^6`. # Output * Return a new sorted array in ascending order. # Constraints * Optimize the function to handle nearly sorted arrays efficiently. * Ensure that your implementation maintains the stability of the sorting process. * The algorithm should run in-place with O(1) additional space. # Example ```python arr = [8, 2, 4, 9, 3] print(optimized_insertion_sort(arr)) # Output: [2, 3, 4, 8, 9] arr = [1, 2, 3, 4, 5] print(optimized_insertion_sort(arr)) # Output: [1, 2, 3, 4, 5] arr = [] print(optimized_insertion_sort(arr)) # Output: [] arr = [5] print(optimized_insertion_sort(arr)) # Output: [5] ``` Notes * Your implementation must not use Python\'s built-in sorting functions (e.g., `sorted()`, `list.sort()`). * Test cases include: - Nearly sorted arrays. - Arrays with duplicated elements. - Large arrays (up to 1000 elements).","solution":"from typing import List def optimized_insertion_sort(arr: List[int]) -> List[int]: Sort an array of integers using an optimized insertion sort. This implementation is efficient for nearly sorted arrays. # Traverse through 1 to len(arr) for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"You are tasked with formatting a list of words into a paragraph of text that is justified within a specified width. Each line in the paragraph should have exactly `maxWidth` characters and be fully justified. Your goal is to ensure that the extra spaces are distributed as evenly as possible between words, with the leftmost spaces being distributed first. For the last line of text, it should be left-justified and should not have extra spaces distributed between the words. # Function Signature ```python def text_justification(words: List[str], max_width: int) -> List[str]: ``` # Input - `words`: A list of words (strings). Each word has at least one non-space character. - `max_width`: An integer representing the maximum width of each line. # Output - Returns a list of lines of text (strings) where each string has exact length `max_width` and the text is fully justified as described. # Constraints 1. Each word\'s length is guaranteed to be greater than 0 and not exceed `max_width`. 2. The input list `words` contains at least one word. # Example ```python Input 1: words = [\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"], max_width = 16 Output 1: [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] Input 2: words = [\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], max_width = 16 Output 2: [ \\"This is an\\", \\"example of text\\", \\"justification. \\" ] ``` # Explanation 1. In **Output 1**: - The first line contains words \\"What\\", \\"must\\", \\"be\\" with spaces distributed as \\"What must be\\". - The second line contains the single word \\"acknowledgment\\" followed by adequate spaces for justification. - The third line contains words \\"shall\\", \\"be\\" with left-justified formatting. 2. In **Output 2**: - The first line should read \\"This is an\\", with 4 spaces distributed evenly after \\"This\\" and \\"is\\". - The second line should read \\"example of text\\", with 2 spaces after \\"example\\". - The third line should read \\"justification.\\" followed by spaces. # Notes - Ensure that your code is efficient and handles edge cases such as single-word lines and words that exactly fit the maxWidth.","solution":"def text_justification(words, max_width): def justify(words, max_width, is_last_line): if len(words) == 1 or is_last_line: # Left-justify return \' \'.join(words).ljust(max_width) total_length = sum(len(word) for word in words) total_spaces = max_width - total_length number_of_gaps = len(words) - 1 even_spaces = total_spaces // number_of_gaps extra_spaces = total_spaces % number_of_gaps # Build line with even spaces and extras added from left to right justified_line = \\"\\" for i in range(number_of_gaps): justified_line += words[i] + \' \' * (even_spaces + (1 if i < extra_spaces else 0)) # Add the last word without trailing spaces justified_line += words[-1] return justified_line result = [] current_words = [] current_length = 0 for word in words: if current_length + len(word) + len(current_words) > max_width: result.append(justify(current_words, max_width, False)) current_words = [] current_length = 0 current_words.append(word) current_length += len(word) if current_words: result.append(justify(current_words, max_width, True)) return result"},{"question":"# Problem Description: You are given the implementation of a BST iterator in Python. Your task is to enhance the iterator to support two additional operations: 1. **prev()**: This function should return the previous smallest number in the BST. You can assume that the `prev()` function will never be called if there is no previous element. 2. **has_prev()**: This function should return `True` if there is a previous smaller number available, and `False` otherwise. # Function Signature: ```python class BSTIterator: def __init__(self, root): Initialize an iterator object over a binary search tree (BST). The root of the BST is given. pass def has_next(self): Return True if there is a next largest number in the BST iterator. pass def next(self): Return the next largest number in the BST. pass def has_prev(self): Return True if there is a previous smallest number in the BST iterator. pass def prev(self): Return the previous smallest number in the BST iterator. pass ``` # Example: Given a binary search tree [7, 3, 15, null, null, 9, 20]: 7 / 3 15 / 9 20 Your BSTIterator class should be able to perform the following operations: ```python i = BSTIterator(root) print(i.next()) # returns 3 print(i.next()) # returns 7 print(i.has_prev()) # returns True print(i.prev()) # returns 3 print(i.has_next()) # returns True print(i.next()) # returns 7 print(i.next()) # returns 9 print(i.has_prev()) # returns True print(i.prev()) # returns 7 print(i.next()) # returns 9 print(i.has_next()) # returns True print(i.next()) # returns 15 print(i.has_next()) # returns True print(i.next()) # returns 20 print(i.has_prev()) # returns True print(i.prev()) # returns 15 print(i.prev()) # returns 9 print(i.prev()) # returns 7 print(i.prev()) # returns 3 print(i.has_prev()) # returns False ``` # Constraints: * The number of nodes in the tree is in the range `[1, 10^5]`. * The values of the nodes are in the range `[-10^4, 10^4]`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTIterator: def __init__(self, root): self.nodes = [] self.index = -1 self.inorder_traversal(root) def inorder_traversal(self, root): stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() self.nodes.append(current.val) current = current.right def has_next(self): return self.index + 1 < len(self.nodes) def next(self): self.index += 1 return self.nodes[self.index] def has_prev(self): return self.index > 0 def prev(self): self.index -= 1 return self.nodes[self.index]"},{"question":"# Radix Sort Implementation Challenge **Scenario**: You are provided with a list of non-negative integers that need to be sorted efficiently. One of the algorithms that excel in this scenario is Radix Sort. **Task**: Implement a function that takes a list of non-negative integers and returns a sorted list using the radix sort algorithm. For the sake of this task, assume all numbers are non-negative. **Function Signature**: ```python def radix_sort(arr: list, simulation: bool = False) -> list: ``` **Input**: - `arr`: A list of non-negative integers (0 ≤ arr[i] ≤ 10^9, 1 ≤ len(arr) ≤ 10^5). - `simulation` (optional): A Boolean flag; if set to `True`, print the list after every sorting iteration (default is `False`). **Output**: - Return a sorted list of integers. **Constraints**: - The function should be capable of handling large input sizes efficiently. - You are not allowed to use in-built sorting functions. **Example**: ```python radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) ``` Output: ```[2, 24, 45, 66, 75, 90, 170, 802]``` **Performance Requirements**: - The algorithm should run in O(nk + n) time complexity. - The space complexity should be kept as minimal as possible. **Note**: Consider edge cases such as: - Single element list. - Lists with repetitive elements. - Verify the behavior for the maximum digit length numbers within provided constraints.","solution":"def counting_sort(arr, exp, simulation=False): n = len(arr) output = [0] * n count = [0] * 10 # Count occurrences of digits for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Convert count to position array for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 # Copy the output array to arr for i in range(n): arr[i] = output[i] if simulation: print(arr) def radix_sort(arr, simulation=False): Function to perform radix sort on a list of non-negative integers. Parameters: arr (list of int): List of non-negative integers to sort. simulation (bool): If True, print the list after every sorting iteration. Returns: list of int: Sorted list of integers. if not arr: return arr max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"Given a positive integer `n`, write a Python function `find_nth_digit(n)` that returns the nth digit in the concatenated sequence of natural numbers starting from 1. # Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` # Input Description - A single integer `n` (1 <= n <= 2^31 - 1), representing the digit\'s position in the infinite concatenated number sequence. # Output Description - Return a single integer, which is the nth digit in the concatenated sequence of natural numbers. # Examples 1. Input: `n = 3` Output: `3` 2. Input: `n = 11` Output: `0` 3. Input: `n = 190` Output: `1` # Constraints - You must ensure the solution handles large values of `n` efficiently. - The function should not rely on constructing large sequences explicitly but should use mathematical calculations to derive the result. - Consider edge cases, such as the transition from single-digit to double-digit numbers or boundary checks between number lengths. # Performance Requirements - Your solution must have a time complexity of O(log n) and a space complexity of O(1). - Ensure there are no floating-point inaccuracies by strictly using integer arithmetic. # Scenario Imagine writing code for a performance-critical application where generating long sequences is impractical due to time or memory constraints. This problem mirrors this requirement by needing an efficient method to determine specific digits in a theoretical infinite sequence. # Implementation Note Be cautious of using integer division, modulo operations, and string manipulations to maintain precision.","solution":"def find_nth_digit(n: int) -> int: length = 1 # length of the digits (1 for 1-9, 2 for 10-99, ...) count = 9 # initial count of numbers with that many digits (9 for 1-9, 90 for 10-99, ...) start = 1 # starting number in the current range (1 for 1-9, 10 for 10-99, ...) # Determine the range in which the nth digit lies. while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit. start += (n - 1) // length # offset to the correct number # Determine the specific digit in the number. digit_in_number = (n - 1) % length return int(str(start)[digit_in_number])"},{"question":"# Combination Calculation Using Memoization As a data scientist, you often need to calculate combinations for various analyses, such as creating voting models, feature selection, and more. The combinations formula is given by ( C(n, r) = frac{n!}{r!(n-r)!} ), representing how many ways you can choose r items from n items. The naive recursive implementation can be highly inefficient due to overlapping subproblems. Your task is to implement an efficient solution using memoization to optimize the calculation of combinations. Function Signature ```python def combination_optimized(n: int, r: int) -> int: pass ``` # Input - `n` (0 ≤ n ≤ 1000): Total number of items. - `r` (0 ≤ r ≤ n): Number of items to choose. # Output - An integer representing the number of ways to choose r items from n items. # Constraints - Use memoization to optimize the recursive combination calculation. - Handle base cases efficiently to avoid unnecessary calculations. # Example ```python assert combination_optimized(5, 2) == 10 assert combination_optimized(10, 0) == 1 assert combination_optimized(10, 10) == 1 assert combination_optimized(30, 15) == 155117520 ``` # Notes - Your solution should efficiently handle larger inputs by leveraging memoization. - Consider edge cases such as the smallest and largest values of n and r. - Ensure that your implementation is sufficiently optimized to handle the given constraints efficiently.","solution":"def combination_optimized(n: int, r: int) -> int: memo = {} def comb(n, r): # Base cases if r == 0 or r == n: return 1 if r == 1: return n # Check if value is already computed if (n, r) in memo: return memo[(n, r)] # Recursive computation with memoization result = comb(n - 1, r - 1) + comb(n - 1, r) memo[(n, r)] = result return result return comb(n, r)"},{"question":"# Problem: Custom Insertion Sort with Enhanced Scenarios Your task is to implement an enhanced version of the **Insertion Sort** algorithm that can handle additional constraints and provide specific output information. **Requirements**: 1. Implement a function `custom_insertion_sort` that sorts an input list of integers in ascending order. 2. The function should additionally accept an optional parameter `descending` which defaults to `False`. When set to `True`, the function should sort the list in descending order. 3. If the list is already sorted, either in ascending or descending order, the function should print a message: \\"List is already sorted in {order} order.\\" and return the list as-is. 4. Return both the sorted list and the total number of swaps performed during the sort. **Function Signature**: ```python def custom_insertion_sort(arr: List[int], descending: bool = False) -> Tuple[List[int], int]: pass ``` **Input**: * `arr`: A list of integers `List[int]` (1 <= len(arr) <= 10^3). * `descending`: A boolean `bool` (optional). **Output**: * A tuple containing: * The sorted list `List[int]`. * The total number of swaps `int` performed during the sorting process. **Constraints**: * The list will contain integers in the range [-10^6, 10^6]. * You should appropriately handle edge cases such as empty lists. **Example**: ```python # Example 1 arr = [4, 3, 2, 1] sorted_arr, swaps = custom_insertion_sort(arr) print(sorted_arr) # Output: [1, 2, 3, 4] print(\\"Total swaps:\\", swaps) # Output: Total swaps: 6 # Example 2 arr = [1, 2, 3, 4] sorted_arr, swaps = custom_insertion_sort(arr, descending=True) print(sorted_arr) # Output: [4, 3, 2, 1] print(\\"Total swaps:\\", swaps) # Output: Total swaps: 6 # Example 3 arr = [1, 2, 3, 4] sorted_arr, swaps = custom_insertion_sort(arr) # Output: List is already sorted in ascending order. print(sorted_arr) # Output: [1, 2, 3, 4] print(\\"Total swaps:\\", swaps) # Output: Total swaps: 0 ```","solution":"from typing import List, Tuple def custom_insertion_sort(arr: List[int], descending: bool = False) -> Tuple[List[int], int]: n = len(arr) if n <= 1: return arr, 0 already_sorted = True if descending: for i in range(1, n): if arr[i-1] < arr[i]: already_sorted = False break if already_sorted: print(\\"List is already sorted in descending order.\\") return arr, 0 else: for i in range(1, n): if arr[i-1] > arr[i]: already_sorted = False break if already_sorted: print(\\"List is already sorted in ascending order.\\") return arr, 0 swaps = 0 for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and ((arr[j] < key if descending else arr[j] > key)): arr[j + 1] = arr[j] j -= 1 swaps += 1 arr[j + 1] = key return arr, swaps"},{"question":"# Question: Optimized nCr Calculation with Bottom-Up Dynamic Programming You are tasked with implementing a function to compute the number of combinations, `C(n, r)`, which represents the number of ways to choose `r` items from `n` items without considering the order of selection. Your implementation should use an iterative, bottom-up dynamic programming approach that optimizes both time and space complexity. Function Signature ```python def combination_iter(n: int, r: int) -> int: pass ``` Input * `n` (0 <= n <= 1000): The total number of items. * `r` (0 <= r <= n): The number of items to choose. Output * Returns an integer representing `C(n, r)`. Constraints * The calculation should be efficient even for large `n`. * Your solution should handle edge cases such as `n = 0, r = 0`, and should return `0` for invalid inputs where `r > n`. Example ```python # Example 1: n = 5 r = 2 # Calculation of C(5, 2) # Expected Output: 10 # Example 2: n = 6 r = 0 # Edge case, C(6, 0) should be 1 by definition # Expected Output: 1 # Example 3: n = 5 r = 5 # C(5, 5) should be 1 by definition # Expected Output: 1 print(combination_iter(5, 2)) # Output: 10 print(combination_iter(6, 0)) # Output: 1 print(combination_iter(5, 5)) # Output: 1 print(combination_iter(10, 3)) # Output: 120 ```","solution":"def combination_iter(n: int, r: int) -> int: Calculate C(n, r) using bottom-up dynamic programming approach. if r > n: return 0 if r == 0 or r == n: return 1 # We only need min(r, n-r) columns r = min(r, n - r) # take advantage of symmetry dp = [0] * (r + 1) dp[0] = 1 # there\'s one way to choose 0 elements for i in range(1, n + 1): # Update the array from back to front for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"# Finding the Single Number in an Array You are provided with an array of integers where every element appears twice, except for one element which appears only once. Your task is to implement a function that finds and returns this unique element. **Function Signature:** ```python def single_number(nums: List[int]) -> int: pass ``` **Input:** - `nums`: A list of integers, `1 <= len(nums) <= 10^6`, where all elements except one appear exactly twice. **Output:** - Return the single integer that appears only once in the array. If the array is empty, return `0`. **Constraints:** - Your solution must have a linear runtime complexity O(n). - You must not use extra memory (i.e., no additional data structures that grow with input size). **Examples:** ```python assert single_number([2, 2, 3, 4, 4]) == 3 assert single_number([1, 1, 2, 2, 3, 4, 4]) == 3 assert single_number([0, 1, 0]) == 1 assert single_number([]) == 0 assert single_number([1]) == 1 ``` **Scenario:** Imagine you are working with a large dataset where duplicate entries are common except for one anomaly. This scenario can occur in various fields, such as data analytics, network packet analysis, or inventory management systems, where identifying the unique item quickly is crucial for maintaining data integrity. Write the `single_number` function to help efficiently find the unique element.","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number in a list of integers where every element appears twice except for one element which appears only once. if not nums: return 0 unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Scenario In a cyber-security firm, analysts are investigating sets of traces from various cybersecurity threat logs. Each trace is represented as an integer. Analysts know that for each set, every trace appears exactly twice except one which could indicate an anomaly worth deeper investigation. They need an efficient way to find this unique trace without using additional memory. # Task Implement a function `find_unique_trace` that identifies the unique trace in the given list where every other trace appears exactly twice. # Function Signature ```python def find_unique_trace(traces: List[int]) -> int: Given a list of traces where each trace appears exactly twice except for one, finds the unique trace. :param traces: List of integers representing traces, where all but one element appears twice. :return: The integer value of the unique trace. pass ``` # Input - A list `traces` of integers, where `1 <= len(traces) <= 10^5`. - Each integer in the list appears exactly twice, except for one unique integer. # Output - Return the integer value of the unique trace. # Constraints - Linear time complexity required. - Constant space complexity required. # Example ```python >>> find_unique_trace([4, 1, 2, 1, 2]) 4 >>> find_unique_trace([2, 2, 3]) 3 >>> find_unique_trace([1]) 1 ```","solution":"from typing import List def find_unique_trace(traces: List[int]) -> int: Given a list of traces where each trace appears exactly twice except for one, finds the unique trace. :param traces: List of integers representing traces, where all but one element appears twice. :return: The integer value of the unique trace. unique_trace = 0 for trace in traces: unique_trace ^= trace return unique_trace"},{"question":"# Scenario: You have been tasked to implement a notification system for an online platform where user notifications are stored in a priority queue. Notifications of higher priority should be shown to the user first. Due to system constraints, it is critical to have efficient handling of insertion and extraction of notifications. # Task: Implement the `PriorityQueue` class using a binary heap for efficient insertion and extraction. You are given an initial implementation using a linear array, but you need to rewrite it to use a binary heap instead. # Function to Implement: ```python class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize the priority queue. # Your code here def size(self): Return the size of the priority queue. # Your code here def push(self, item, priority=None): Push the item into the priority queue with the given priority. # Your code here def pop(self): Remove and return the item with the highest priority. # Your code here ``` # Requirements: 1. Implement all the methods of the `PriorityQueue` class. 2. Use a binary heap to achieve efficient push and pop operations. 3. Ensure that pushing and popping operations adhere to the complexity of O(log n). 4. Handle edge cases like popping from an empty priority queue effectively. # Input/Output Formats: * **push(item, priority)**: Adds an item with the given priority to the queue. * **pop()**: Removes and returns the item with the highest priority. # Constraints: * The priority can be any integer (positive, negative, zero). * The items can be any comparable type. * The priority queue can have up to 10^6 elements. # Example: ```python pq = PriorityQueue() pq.push(\'task1\', 3) pq.push(\'task2\', 1) pq.push(\'task3\', 2) print(pq.pop()) # Output: task1 print(pq.pop()) # Output: task3 print(pq.pop()) # Output: task2 ```","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize the priority queue. self._heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): Return the size of the priority queue. return len(self._heap) def push(self, item, priority): Push the item into the priority queue with the given priority. # Use negative priority because heapq is a min-heap by default heapq.heappush(self._heap, (-priority, item)) def pop(self): Remove and return the item with the highest priority. if not self._heap: raise IndexError(\\"pop from an empty priority queue\\") priority, item = heapq.heappop(self._heap) # Return only the item (priority is not needed here) return item"},{"question":"# Scenario You are tasked with building a communication network for a new company campus. The goal is to connect all office buildings using the shortest possible length of cable. You are given a list of potential cables with their lengths and the buildings they connect. # Problem Statement Write a function `minimum_spanning_tree` that determines the minimum total length of cable required to connect all buildings on the campus. # Function Signature ```python def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: ``` # Input * An integer `vertex_count` representing the number of buildings (`1 <= vertex_count <= 1000`). * A list of tuples `edges`, where each tuple contains three integers: * `u` and `v` (1-indexed building numbers) and `weight` representing the length of cable between buildings `u` and `v` (`1 <= u, v <= vertex_count`, `1 <= weight <= 10^5`). # Output * An integer representing the minimum total length of cable required to connect all buildings. # Constraints * All buildings are connected by at least some combination of the given cables. # Example ```python vertex_count = 5 edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] assert minimum_spanning_tree(vertex_count, edges) == 14 vertex_count = 3 edges = [(2, 1, 20), (3, 1, 20), (2, 3, 100)] assert minimum_spanning_tree(vertex_count, edges) == 40 ``` # Requirements * Your solution should use Kruskal\'s algorithm to find the Minimum Spanning Tree (MST). * Implement the Disjoint Set (Union-Find) data structure with path compression and union-by-size optimizations. * Handle edge cases and input constraints carefully. # Notes * Ensure that your implementation efficiently handles the sorting and union-find operations to meet the constraints. * Consider 1-indexed building numbers in the input edges and convert them to 0-indexed if needed for internal processing.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: edges.sort(key=lambda x: x[2]) dsu = DisjointSet(vertex_count) mst_weight = 0 for u, v, weight in edges: u -= 1 v -= 1 if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += weight return mst_weight"},{"question":"# Question: Enhanced Separate Chaining Hash Table Scenario You have been provided with an implementation of a separate chaining hash table. While it works, it lacks some important features, such as dynamic resizing and more robust error handling. Task Enhance the provided `SeparateChainingHashTable` class by implementing the following functionalities: 1. **Dynamic Resizing**: Implement dynamic resizing of the hash table when the load factor exceeds a certain threshold. Choose a load factor threshold of 0.75. When resizing, the new table size should be the next prime number greater than twice the current size. 2. **Contains Method**: Add a method `contains(key)` which returns `True` if the key exists in the hash table, otherwise returns `False`. 3. **Rehashing**: Implement the internal rehashing function used during resizing. Function Signature ```python class SeparateChainingHashTable: def resize(self): pass def contains(self, key): pass ``` Constraints 1. Use the `hash` method provided for generating bucket indices. 2. Ensure that the dynamic resizing maintains the mapping of existing keys. Input/Output * **Input**: The `SeparateChainingHashTable` class will be used to store and retrieve key-value pairs. * **Output**: Your methods should correctly resize the table and handle contains checks. Example ```python table = SeparateChainingHashTable() table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) print(table.contains(\'a\')) # Should return True print(table.contains(\'z\')) # Should return False # Add more elements to trigger resize for i in range(20): table.put(str(i), i) print(len(table)) # Should correctly reflect the number of elements in the hash table after resizing ``` Ensure that your implementation maintains efficient performance, even as the hash table grows.","solution":"import itertools def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): Return the next prime number greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate class SeparateChainingHashTable: def __init__(self, initial_capacity=7): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(self.capacity)] self.load_factor_threshold = 0.75 def hash(self, key): return hash(key) % self.capacity def put(self, key, value): index = self.hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 if self.size / self.capacity > self.load_factor_threshold: self.resize() def get(self, key): index = self.hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def remove(self, key): index = self.hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def contains(self, key): index = self.hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return True return False def resize(self): new_capacity = next_prime(2 * self.capacity) new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for key, value in bucket: index = hash(key) % new_capacity new_buckets[index].append((key, value)) self.capacity = new_capacity self.buckets = new_buckets def __len__(self): return self.size"},{"question":"You are tasked with implementing a variation of the Selection Sort algorithm, specifically optimized for scenarios where the array is mostly sorted. Your function should detect such scenarios and switch to an Insertion Sort algorithm to potentially reduce the time complexity in such cases. # Function Signature: ```python def hybrid_sort(arr: List[int]) -> List[int]: This function applies Selection Sort, but will automatically switch to Insertion Sort if it detects that the array is mostly sorted. :param arr: List[int] - The list of integers to be sorted. :return: List[int] - The sorted list of integers. ``` # Constraints: * The array may contain up to 10^4 elements. * Each element of the array will be an integer within the range [-10^6, 10^6]. * You need to maintain the overall function\'s time complexity to be as optimal as possible in scenarios with mostly sorted arrays. # Input: * A list of integers `arr`. # Output: * A sorted list of integers. # Considerations: * Ensure that your hybrid sort efficiently detects if the array is mostly sorted. * For the purpose of this task, you may assume an array is \\"mostly sorted\\" if it requires fewer than 10% of the elements to be moved to achieve a fully sorted state. * Validate the edge cases such as an empty array, arrays with one element, arrays with all identical elements, and already sorted arrays. # Example: ```python # Example 1: arr = [3, 1, 2] print(hybrid_sort(arr)) # Output: [1, 2, 3] # Example 2: arr = [] print(hybrid_sort(arr)) # Output: [] # Example 3: arr = [4, 2, 2, 8, 3, 3, 1] print(hybrid_sort(arr)) # Output: [1, 2, 2, 3, 3, 4, 8] ```","solution":"from typing import List def hybrid_sort(arr: List[int]) -> List[int]: def is_mostly_sorted(arr: List[int]) -> bool: change_count = 0 threshold = len(arr) // 10 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: change_count += 1 if change_count > threshold: return False return True def insertion_sort(arr: List[int]) -> None: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def selection_sort(arr: List[int]) -> None: for i in range(len(arr)): min_idx = i for j in range(i + 1, len(arr)): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if is_mostly_sorted(arr): insertion_sort(arr) else: selection_sort(arr) return arr"},{"question":"You are given a list of mixed data types containing integers, booleans, strings, etc. You need to write a function that moves all the zeros (int type only) to the end of the list while preserving the order of all other non-zero elements and non-zero type elements. # Function Signature ```python def move_zeros(arr: List[Union[int, bool, str]]) -> List[Union[int, bool, str]]: ``` # Input * A list `arr` containing diverse elements (e.g., integers, boolean, strings). # Output * A list with all the zero integers moved to the end, preserving the original order of other elements. # Example ```python print(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"])) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` # Constraints * Assume the length of the list will not exceed 10000 elements. # Performance Requirement * The solution should run in linear time, O(n), where n is the length of the list. * Extra space utilization should be minimized if possible. **Note**: Ensure the zeros you identify to move are typecast to `int` not `bool` to preserve logical entities correctly (avoid treating `False` as zero). # Edge Cases * An empty list should return an empty list. * A list with no zeros should return the same list. * A list with all zeros should move all zeros to the end without affecting non-zero elements.","solution":"from typing import List, Union def move_zeros(arr: List[Union[int, bool, str]]) -> List[Union[int, bool, str]]: Moves all integer zeros to the end of the list while preserving the order of all other non-zero elements and non-zero type elements. non_zeros = [] zeros = 0 for item in arr: if item == 0 and type(item) is int: zeros += 1 else: non_zeros.append(item) return non_zeros + [0] * zeros"},{"question":"# Question: Joining File Paths and URLs Given the task of joining file paths and URLs in a consistent manner, write a function `join_paths` that joins a `base` path or URL with a `suffix` and ensures there is exactly one \'/\' between them. # Function Signature ```python def join_paths(base: str, suffix: str) -> str: ``` # Input * `base` (str): The base path or URL. It may or may not end with a \'/\'. * `suffix` (str): The suffix to add to the base path or URL. It may or may not start with a \'/\'. # Output * (str): The joined path or URL with exactly one \'/\' between the base and suffix parts. # Constraints * Both `base` and `suffix` are non-empty strings. * The combined length of `base` and `suffix` will not exceed 10^4 characters. # Examples ```python assert join_paths(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_paths(\\"http://algorithms.com\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_paths(\\"http://algorithms.com\\", \\"/part\\") == \\"http://algorithms.com/part\\" ``` # Considerations * Handle various trailing and leading slashes correctly. * Ensure the function doesn\'t introduce redundant slashes.","solution":"def join_paths(base: str, suffix: str) -> str: Joins a base path or URL with a suffix ensuring there is exactly one \'/\' between them. if base.endswith(\'/\') and suffix.startswith(\'/\'): return base.rstrip(\'/\') + \'/\' + suffix.lstrip(\'/\') if not base.endswith(\'/\') and not suffix.startswith(\'/\'): return base + \'/\' + suffix return base + suffix"},{"question":"# Stack Simulation and Expression Evaluation Given the `ArrayStack` or `LinkedListStack` implementation of a stack, you are required to write a function `evaluate_postfix(expression: str) -> int` that evaluates a postfix (Reverse Polish Notation) mathematical expression. Input and Output - **Input**: - `expression` (str): A string containing the postfix expression where operands and operators are separated by spaces. Operands are non-negative integers, and operators are \'+\', \'-\', \'*\', or \'/\'. - **Output**: - Returns an integer result of the evaluated postfix expression. Constraints - The expression is a valid postfix expression. - The expression contains at least one operand. - Division is integer division, rounding towards zero. - Operands and operators are separated by single spaces. Example - **Input**: `expression = \\"2 3 1 * + 9 -\\"` - **Output**: `-4` *Explanation*: The postfix expression evaluates to 2 + (3 * 1) - 9 = -4. # Task Implement the function `evaluate_postfix` as specified above using either `ArrayStack` or `LinkedListStack` for stack operations. Ensure to handle the edge cases where the stack might be empty when trying to pop or peek. ```python def evaluate_postfix(expression: str) -> int: # Your implementation here pass # Example usage print(evaluate_postfix(\\"2 3 1 * + 9 -\\")) # Output should be -4 ``` # Note - You must use the provided `ArrayStack` or `LinkedListStack` classes for the stack implementation part of your solution. - Account for empty stack scenarios by raising appropriate exceptions. - Ensure that the time complexity of the solution remains O(n), where n is the length of the expression.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def evaluate_postfix(expression: str) -> int: stack = ArrayStack() tokens = expression.split() for token in tokens: if token.isdigit(): stack.push(int(token)) else: operand2 = stack.pop() operand1 = stack.pop() if token == \'+\': result = operand1 + operand2 elif token == \'-\': result = operand1 - operand2 elif token == \'*\': result = operand1 * operand2 elif token == \'/\': result = int(operand1 / operand2) # Ensure integer division stack.push(result) return stack.pop()"},{"question":"# Scenario You are working on implementing a secure communication system where two parties need to establish a shared secret key over an insecure network. Your task is to implement the core phases of the Diffie-Hellman key exchange protocol. # Objective Write functions to carry out key steps in the Diffie-Hellman protocol as described below: # Requirements 1. **Prime Check Function**: `prime_check(num)` - **Input**: `num` (an integer) - **Output**: `True` if the number is prime, `False` otherwise 2. **Euler\'s Totient Function**: `euler_totient(n)` - **Input**: `n` (an integer) - **Output**: Returns the totient of `n` 3. **Find Primitive Root Function**: `find_primitive_root(n)` - **Input**: `n` (an integer) - **Output**: List of primitive roots of `n` 4. **Private Key Generation and Public Key Calculation for Alice and Bob**: - **Alice\'s Private Key**: `alice_private_key(p)` - **Alice\'s Public Key**: `alice_public_key(a_pr_k, a, p)` - **Bob\'s Private Key**: `bob_private_key(p)` - **Bob\'s Public Key**: `bob_public_key(b_pr_k, a, p)` 5. **Shared Key Calculation**: - **Alice\'s Shared Key**: `alice_shared_key(b_pu_k, a_pr_k, p)` - **Bob\'s Shared Key**: `bob_shared_key(a_pu_k, b_pr_k, p)` 6. **Main Function**: `diffie_hellman_key_exchange(a, p)` - Performs the overall protocol and validates the shared key # Constraints - `p` must be a large prime number (e.g., >= 10^6). - `a` must be a primitive root of `p`. # Input/Output ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform Diffie-Hellman key exchange. - a: integer, a primitive root of p - p: integer, a large prime number Returns True if the shared keys match, False otherwise. # Example usage: diffie_hellman_key_exchange(a=3, p=97) # Expected output: # Should return True if the shared keys calculated by Alice and Bob match. ``` # Notes - Handle edge cases such as `p` not being prime or `a` not being a primitive root of `p`. - Print relevant information to debug the process, such as private and public keys. - Ensure that the shared keys computed by both Alice and Bob match.","solution":"import math import random def prime_check(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n): Returns the Euler\'s totient function value of n. if n == 0: return 0 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(p): Given a prime number p, find its primitive roots. if not prime_check(p): return [] phi_p = euler_totient(p) factors = set() n = phi_p i = 2 while i * i <= n: if n % i == 0: factors.add(i) while n % i == 0: n //= i i += 1 if n > 1: factors.add(n) primitive_roots = [] for r in range(2, p): flag = False for factor in factors: if pow(r, phi_p // factor, p) == 1: flag = True break if not flag: primitive_roots.append(r) return primitive_roots def alice_private_key(p): return random.randint(2, p-2) def alice_public_key(a_pr_k, a, p): return pow(a, a_pr_k, p) def bob_private_key(p): return random.randint(2, p-2) def bob_public_key(b_pr_k, a, p): return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a, p): Perform Diffie-Hellman key exchange. if not prime_check(p): raise ValueError(\\"p must be a prime number.\\") if a not in find_primitive_root(p): raise ValueError(\\"a must be a primitive root of p.\\") a_pr_k = alice_private_key(p) b_pr_k = bob_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pu_k = bob_public_key(b_pr_k, a, p) shared_key_alice = alice_shared_key(b_pu_k, a_pr_k, p) shared_key_bob = bob_shared_key(a_pu_k, b_pr_k, p) return shared_key_alice == shared_key_bob"},{"question":"# Maximum Non-Adjacent Sum Scenario: You are a securitization consultant for a wealthy neighborhood where houses are prone to burglary. Each house has a certain amount of wealth and is connected to a sophisticated security system that triggers alarms if two adjacent houses are broken into on the same night. Your task is to determine the maximum amount of wealth that can be stolen without triggering the alarm system. Problem: Write a function `max_non_adjacent_sum(arr)` that takes a list of integers `arr` representing the amount of money in each house and returns the maximum amount of money that can be stolen without triggering the alarm. Input: - A list `arr` of `n` non-negative integers (0 <= arr[i] <= 10^4) representing the money in each house, where `1 <= n <= 10^5`. Output: - An integer representing the maximum amount of money that can be stolen. Constraints: - You cannot steal from two adjacent houses. - Elements in the list may be zero. - Optimize for both time complexity and space complexity. Examples: ```python max_non_adjacent_sum([2, 7, 9, 3, 1]) # Output: 12 max_non_adjacent_sum([2, 1, 1, 2]) # Output: 4 max_non_adjacent_sum([]) # Output: 0 max_non_adjacent_sum([8]) # Output: 8 ``` Hint: Think of a dynamic programming approach where you keep track of: - The maximum money that can be stolen up to the previous house. - The money that can be stolen up to the current house without stealing from the previous adjacent house.","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the list. if not arr: return 0 n = len(arr) if n == 1: return arr[0] # Initialize the previous maximum sums prev_prev_max = 0 prev_max = arr[0] for i in range(1, n): current = max(prev_max, prev_prev_max + arr[i]) prev_prev_max = prev_max prev_max = current return prev_max"},{"question":"Given the implementation of inorder traversal of a binary tree in both iterative and recursive styles, your task is to write a function that performs \\"K-th smallest element in a Binary Search Tree\\". # Problem Statement You are provided with a binary search tree (BST) and an integer `k`. Write a function `kth_smallest(root: Node, k: int) -> int` that returns the k-th smallest element in the BST. Input Format - `Node` (Class defined as in the initial code snippet): - `val`: Integer value of the node. - `left`: Pointer to the left child node. - `right`: Pointer to the right child node. - Integer `k` where 1 <= k <= number of nodes in the BST. Output Format - Return the value of the k-th smallest element in the given BST. Constraints - All node values are unique. - Assume `k` is always valid (1 <= k <= number of nodes). # Performance Requirements - The solution should efficiently handle large BSTs. # Example ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert kth_smallest(n1, 3) == 75 assert kth_smallest(n1, 1) == 25 ``` # Hints - Use the properties of the inorder traversal to count visited nodes. - Consider both iterative and recursive approaches to solve the problem.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(node, result): if node: inorder_traversal(node.left, result) result.append(node.val) inorder_traversal(node.right, result) def kth_smallest(root: Node, k: int) -> int: result = [] inorder_traversal(root, result) return result[k-1]"},{"question":"# Question: Implement the Cocktail Shaker Sort with Early Termination Given an array of integers, implement the Cocktail Shaker Sort algorithm with an optimization to terminate early if no swaps are made in both forward and backward passes. This ensures the algorithm takes advantage of any existing order in the array to improve performance. Input - An array of integers `arr` where 1 <= len(arr) <= 10^5. Output - A sorted array in ascending order. Example ```python Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] Input: [3, 2, 1] Output: [1, 2, 3] Input: [] Output: [] ``` Constraints - You must implement the sort in-place. - You should handle the array with up to 100,000 elements efficiently. - Optimize the code to terminate early if no swaps are necessary in both directions. You should consider edge cases such as: - Empty arrays. - Arrays with only one element. - Arrays with all elements being the same. - Arrays that are already sorted.","solution":"def cocktail_shaker_sort(arr): In-place Cocktail Shaker Sort algorithm with early termination. n = len(arr) if n < 2: return arr start = 0 end = n - 1 while True: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Backward pass swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break start += 1 return arr"},{"question":"# Filtering Student Scores You are given the task of analyzing student scores to identify those who fall within a specific range. You need to implement a function that filters a list of student scores based on a minimum and maximum threshold. Your function should handle various edge cases and ensure that the resulting list maintains the original order of scores. Write a function `filter_scores(scores, min_score=None, max_score=None)` that receives: * `scores` (list of integers): A list containing student scores. * `min_score` (integer, optional): The minimum score threshold. If `None`, consider the lowest score in the list as the minimum threshold. * `max_score` (integer, optional): The maximum score threshold. If `None`, consider the highest score in the list as the maximum threshold. **Constraints**: 1. The number of scores in the list `n` can range from 0 to (10^5). 2. Each score is an integer ranging from 0 to 100. 3. If `min_score` is provided, it will be a non-negative integer. 4. If `max_score` is provided, it will be an integer less than or equal to 100. **Output**: * Return a list containing the scores within the specified range (`min_score` to `max_score`), inclusive. **Example**: ```python # Example 1 scores = [35, 87, 55, 66, 91, 42] min_score = 50 max_score = 90 # Expected output: [55, 66, 87] # Example 2 scores = [10, 20, 30, 40, 50] max_score = 25 # Expected output: [10, 20] # Example 3 scores = [5, 8, 12, 20] min_score = 10 # Expected output: [12, 20] # Example 4 scores = [] # Expected output: [] ``` Note any edge cases such as an empty list, where both `min_score` and `max_score` are `None`, and lists with scores all being the same value. Write clear, clean, and efficient code to handle these scenarios.","solution":"def filter_scores(scores, min_score=None, max_score=None): Filters a list of student scores based on a minimum and maximum threshold. Parameters: scores (list of int): A list containing student scores. min_score (int, optional): The minimum score threshold. Default is None. max_score (int, optional): The maximum score threshold. Default is None. Returns: list of int: A list containing the scores within the specified range, inclusive. if not scores: return [] if min_score is None: min_score = min(scores) if max_score is None: max_score = max(scores) filtered_scores = [score for score in scores if min_score <= score <= max_score] return filtered_scores"},{"question":"# Scenario You are working as a software engineer at a company that manages a complex system involving multiple interdependent processes. To ensure resource allocation safety and avoid deadlocks, you need to detect if there are any cycles within the directed graph representing process dependencies. # Problem Statement Write a Python function `has_cycle(graph: dict) -> bool` that determines if a directed graph contains a cycle. The graph is provided as an adjacency list represented by a dictionary, where the keys are vertex identifiers and the values are lists of adjacent vertices. # Input - `graph: dict` - A dictionary representing a directed graph. Each key is a vertex, and its associated value is a list of vertices it has directed edges to. # Output - Return `True` if the graph contains a cycle, otherwise `False`. # Constraints - The graph can contain up to 10^3 vertices and 10^4 edges. - Vertex identifiers will be strings and are case-sensitive. - There will be no duplicate edges. - The graph can be disconnected. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(has_cycle(graph)) # Output: True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(has_cycle(graph)) # Output: False ``` # Notes - Ensure your solution handles all the mentioned edge cases effectively. - Consider the performance implications of your implementation, particularly with respect to the given constraints.","solution":"def has_cycle(graph: dict) -> bool: Determines if a directed graph contains a cycle. Args: - graph (dict): A dictionary representing a directed graph. Returns: - bool: True if the graph contains a cycle, otherwise False. def dfs(vertex, visited, rec_stack): visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False visited = set() for node in graph: if node not in visited: if dfs(node, visited, set()): return True return False"},{"question":"You are provided with a binary tree structure along with functions to serialize and deserialize this tree. Your task is to enhance the functionality by implementing a new feature that allows serialization and deserialization of binary search trees (BSTs) only, ensuring that the tree maintains its BST properties after deserialization. # Core Functionality 1. **serialize_bst(root: TreeNode) -> str**: - **Input**: A root node of a binary search tree. - **Output**: A string representing the serialized form of the BST. 2. **deserialize_bst(data: str) -> TreeNode**: - **Input**: A string representing the serialized form of a BST. - **Output**: The root node of the re-constructed BST with all BST properties intact. # Constraints 1. Assume that the values of the BST nodes are unique integers. 2. Your solution should maintain O(n) complexity in both serialization and deserialization processes. 3. Ensure that edge cases such as empty trees and single-child trees are handled. # Performance Requirements 1. **Time Complexity**: O(n) for both functions. 2. **Space Complexity**: O(n) for both functions. # Implementation Details Use the provided base code for reference, and you should modify or extend it to correctly manage BST-specific serialization and deserialization. ```python # Base Code for Reference class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): def build_string(node): if node: vals.append(str(node.val)) build_string(node.left) build_string(node.right) else: vals.append(\\"#\\") vals = [] build_string(root) return \\" \\".join(vals) def deserialize(data): def build_tree(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree() # Your task is to create the following functions: def serialize_bst(root: TreeNode) -> str: # Implement this function pass def deserialize_bst(data: str) -> TreeNode: # Implement this function pass ``` # Example ```python # Example Usage # Constructing a Binary Search Tree # 5 # / # 3 7 # / / # 2 4 6 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) # Serialize the BST serialized = serialize_bst(root) print(serialized) # \\"5 3 2 # # 4 # # 7 6 # # #\\" # Deserialize the BST deserialized_root = deserialize_bst(serialized) assert deserialized_root.val == 5 assert deserialized_root.left.val == 3 assert deserialized_root.right.val == 7 assert deserialized_root.left.left.val == 2 assert deserialized_root.left.right.val == 4 assert deserialized_root.right.left.val == 6 ```","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize_bst(root: TreeNode) -> str: Serialize a BST to a string. def serialize_helper(node): if node is None: return [] return [str(node.val)] + serialize_helper(node.left) + serialize_helper(node.right) return \' \'.join(serialize_helper(root)) def deserialize_bst(data: str) -> TreeNode: Deserialize a string back to a BST. if not data: return None def deserialize_helper(bounds): if not data_array or not (bounds[0] < data_array[0] < bounds[1]): return None val = data_array.pop(0) root = TreeNode(val) root.left = deserialize_helper((bounds[0], val)) root.right = deserialize_helper((val, bounds[1])) return root data_array = list(map(int, data.split())) return deserialize_helper((-float(\'inf\'), float(\'inf\')))"},{"question":"# Coding Challenge: Binary Tree Path Finding Problem Statement: Given the root of a binary tree, write a function `binary_tree_paths` that returns all paths from the root to the leaf nodes. Each path should be in the form of a string showcasing the nodes visited from the root to the leaf, separated by \'->\'. You must implement a recursive depth-first search (DFS) approach to find and return these paths. Function Signature: ```python def binary_tree_paths(root): # Your code here ``` Input: * `root` (TreeNode): The root of the binary tree, where TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: * `List[str]`: A list of strings, each representing a path from root to leaf. Constraints: 1. The number of nodes in the tree is in the range `[0, 100]`. 2. Every node\'s value is guaranteed to be a unique integer in the range `[-1000, 1000]`. 3. The tree may be unbalanced, and certain nodes may have only one child. Example: # Input: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) # The tree looks like this: # 1 # / # 2 3 # # 5 ``` # Output: ```python [\\"1->2->5\\", \\"1->3\\"] ``` Notes: 1. Use a helper function `dfs` to assist with recursive traversal. 2. Paths must be constructed in the \\"root->left->right\\" format, as shown in the example. 3. Consider edge cases such as when the tree is empty or has only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all paths from the root to the leaf nodes as strings separated by \'->\'. if not root: return [] def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: paths.append(path) # It\'s a leaf else: path += \'->\' dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"# Problem: Red-Black Tree With Find and Count Operations The provided code implements a Red-Black Tree which ensures that the tree is balanced after each insertion and deletion. The Red-Black Tree is a self-balancing binary search tree. Task: You are required to extend the `RBTree` class by implementing two additional methods: 1. `find`: This method should search for a given value in the Red-Black Tree and return `True` if the value exists, and `False` otherwise. 2. `count`: This method should return the total number of nodes present in the Red-Black Tree. Implementation Details: 1. You need to implement the `find` function in the `RBTree` class to search for a value. 2. You need to implement the `count` function in the `RBTree` class to count the nodes. Method Signature: `find(self, val: int) -> bool` - **Input**: An integer value `val` to be searched within the Red-Black Tree. - **Output**: Returns `True` if `val` is found in the tree, `False` otherwise. `count(self) -> int` - **Output**: Returns the total number of nodes in the Red-Black Tree. Example: ```python rb = RBTree() # Inserting nodes for val in [11, 2, 14, 1, 7, 15, 5, 8, 4]: node = RBNode(val, 1) rb.insert(node) # Searching print(rb.find(7)) # Output: True print(rb.find(3)) # Output: False # Counting print(rb.count()) # Output: 9 ``` Constraints: - You can assume that the values inserted are integers. - The initial state of the Red-Black Tree can be either empty or have some pre-inserted values. - Perform efficient searching and counting while leveraging the properties of the Red-Black Tree. Implement the `find` method to complete the above task: ```python class RBTree: ... def find(self, val): Search for a value in the Red-Black Tree. :param val: Integer value to find in the tree. :return: Boolean indicating if value exists. node = self.root while node is not None: if node.val == val: return True elif node.val < val: node = node.right else: node = node.left return False def count(self): Count the number of nodes in the Red-Black Tree. :return: Integer representing the number of nodes. return self._count_nodes(self.root) def _count_nodes(self, node): if node is None: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right) ```","solution":"class RBNode: def __init__(self, val, color): self.val = val self.color = color # 1 for Red, 0 for Black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NULL = RBNode(0, 0) self.root = self.NULL def insert(self, node: RBNode): # This is a simplified version and does not handle balancing, # you should write actual Red-Black Tree insertion logic here. if self.root == self.NULL: self.root = node node.color = 0 node.left = self.NULL node.right = self.NULL node.parent = None else: current = self.root while current != self.NULL: parent = current if node.val < current.val: current = current.left else: current = current.right node.parent = parent if node.val < parent.val: parent.left = node else: parent.right = node node.left = self.NULL node.right = self.NULL node.color = 1 self.fix_insert(node) def fix_insert(self, node): # This method must handle the balancing and recoloring of the tree. # This is a placeholder. Implement actual Red-Black Tree balancing logic here. pass def find(self, val: int) -> bool: Search for a value in the Red-Black Tree. :param val: Integer value to find in the tree. :return: Boolean indicating if value exists. node = self.root while node != self.NULL: if node.val == val: return True elif node.val < val: node = node.right else: node = node.left return False def count(self) -> int: Count the number of nodes in the Red-Black Tree. :return: Integer representing the number of nodes. return self._count_nodes(self.root) def _count_nodes(self, node: RBNode) -> int: if node == self.NULL: return 0 return 1 + self._count_nodes(node.left) + self._count_nodes(node.right)"},{"question":"# Matrix Transformation Programming Question Context You are given a matrix represented by a 2D list (list of lists) in Python. Your task is to implement a function that performs a specific matrix transformation. The available transformations are: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix across the top-left to bottom-right diagonal. 4. Invert the matrix across the bottom-left to top-right diagonal. Function Signature ```python def transform_matrix(matrix, operation): Transforms the given matrix based on the specified operation. Parameters: - matrix (list of list of ints): The 2d matrix to transform. - operation (str): The type of transformation to perform. It can be one of \'clockwise\', \'counterclockwise\', \'top_left_invert\', or \'bottom_left_invert\'. Returns: - new_matrix (list of list of ints): The transformed matrix. pass ``` Input - `matrix`: A list containing `m` sublists, each with `n` integers. - Example: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - `operation`: A string representing the transformation operation. - Example: `\'clockwise\'`, `\'counterclockwise\'`, `\'top_left_invert\'`, `\'bottom_left_invert\'` Output - `new_matrix`: A list containing the transformed matrix. Constraints - The matrix will have at least 1 row and 1 column. - All elements in the matrix are integers between -1000 and 1000. - The operation will be one of the given valid string types. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotate 90 degrees clockwise transform_matrix(matrix, \'clockwise\') # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Rotate 90 degrees counterclockwise transform_matrix(matrix, \'counterclockwise\') # Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] # Invert across top-left to bottom-right diagonal transform_matrix(matrix, \'top_left_invert\') # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Invert across bottom-left to top-right diagonal transform_matrix(matrix, \'bottom_left_invert\') # Output: [[9, 6, 3], [8, 5, 2], [7, 4, 1]] ``` Notes - Think about the edge cases such as empty matrices or single-element matrices. - Ensure to handle different matrix sizes gracefully. - Try to write efficient code to optimize both time and space complexity.","solution":"def transform_matrix(matrix, operation): Transforms the given matrix based on the specified operation. Parameters: - matrix (list of list of ints): The 2d matrix to transform. - operation (str): The type of transformation to perform. It can be one of \'clockwise\', \'counterclockwise\', \'top_left_invert\', or \'bottom_left_invert\'. Returns: - new_matrix (list of list of ints): The transformed matrix. if operation == \'clockwise\': return [list(row) for row in zip(*matrix[::-1])] elif operation == \'counterclockwise\': return [list(row) for row in reversed(list(zip(*matrix)))] elif operation == \'top_left_invert\': return [list(row) for row in zip(*matrix)] elif operation == \'bottom_left_invert\': return [list(row) for row in zip(*matrix[::-1])][::-1] else: raise ValueError(\\"Invalid operation specified\\")"},{"question":"**Objective**: Write a function `custom_insertion_sort(arr, k)` to perform a custom insertion sort on a given array. The sorting will only process the first `k` elements of the array. The function should return the partially sorted array where the first `k` elements are sorted, and the rest of the array remains unchanged. # Requirements: * The input array will always be of length `n` with `n >= k`. * You must modify the array in place. * The function should handle edge cases like empty arrays or arrays with less than `k` elements gracefully. # Function Signature: ```python def custom_insertion_sort(arr: list[int], k: int) -> list[int]: pass ``` # Input: * `arr`: a list of integers, representing the array to be sorted. * `k`: an integer, representing the number of elements to sort from the beginning of the array. # Output: * The function should return the modified list where the first `k` elements are sorted in ascending order. # Constraints: 1. The input array will contain integers ranging from `-10^5` to `10^5`. 2. The value of `0 <= k <= len(arr)`. # Example: ```python assert custom_insertion_sort([3, 1, 5, 7, 2, 4], 4) == [1, 3, 5, 7, 2, 4] assert custom_insertion_sort([5, 4, 3, 2, 1], 3) == [3, 4, 5, 2, 1] assert custom_insertion_sort([10, 20, 30, 40, 50], 0) == [10, 20, 30, 40, 50] ``` # Explanation: 1. In the first example, the first 4 elements are sorted in ascending order while the remaining two elements are untouched. 2. In the second example, the first 3 elements are sorted. 3. In the last example, `k` is 0, hence the array remains unchanged.","solution":"def custom_insertion_sort(arr, k): Performs a custom insertion sort on the first k elements of the array. Parameters: arr (list): The array to partially sort. k (int): The number of elements to sort from the beginning of the array. Returns: list: The partially sorted array. for i in range(1, k): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question: Optimizing and Extending Exchange Sort Context: You are tasked to enhance the usability of the provided `exchange_sort` function. Your goal is to improve its efficiency, extend its functionality to handle a broader range of edge cases, and make it more configurable. Task: 1. **Enhancements**: - Optimize the function to reduce unnecessary passes when the array is already sorted. (Hint: Track if any swaps are made in the inner loop and break early if none are made). 2. **Extensions**: - Add support for specifying the order of sorting (ascending or descending). Function Description: Implement a function `exchange_sort_optimized(arr, ascending=True)`. # Expected Input: * `arr` - A list of integers that needs to be sorted. * `ascending` - A boolean flag to determine the order of sorting. Default is `True` for ascending order. If `False`, sort in descending order. # Expected Output: * A list of integers sorted based on the specified order. # Constraints: * You must not use any built-in sorting functions. * The function should be optimized to minimize the number of comparisons when the array is already sorted. Example: ```python exchange_sort_optimized([3, 1, 4, 1, 5, 9, 2, 6, 5], ascending=True) # Output: [1, 1, 2, 3, 4, 5, 5, 6, 9] exchange_sort_optimized([3, 1, 4, 1, 5, 9, 2, 6, 5], ascending=False) # Output: [9, 6, 5, 5, 4, 3, 2, 1, 1] exchange_sort_optimized([], ascending=True) # Output: [] ``` Notes: * Consider optimizing the inner loop to break early if no swaps were made during a pass, which indicates the array is already sorted. * Ensure the function handles arrays with negative numbers and identical elements correctly.","solution":"def exchange_sort_optimized(arr, ascending=True): Sorts the array in ascending or descending order using an optimized exchange sort algorithm. Parameters: arr (list): List of integers to be sorted. ascending (bool): If True, sort in ascending order. If False, sort in descending order. Returns: list: Sorted list of integers. n = len(arr) for i in range(n - 1): swapped = False for j in range(n - 1 - i): if (ascending and arr[j] > arr[j + 1]) or (not ascending and arr[j] < arr[j + 1]): arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Minimum Spanning Tree with Kruskal’s Algorithm As a software developer at a network design company, you have been tasked with designing an efficient algorithm to construct the minimum cost network that connects all the cities. You have been provided with the following function skeleton and are asked to implement the Kruskal’s algorithm to find the Minimum Spanning Tree (MST) of the given cities and their connecting roads with weights. Function Signature ```python def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Args: n (int): The number of vertices (cities). edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing an edge between vertex u and vertex v with weight w. Returns: int: The weight sum of the MST. ``` Input * **n**: an integer representing the number of vertices (1 ≤ n ≤ 1000). * **edges**: a list of tuples ( (u, v, w) ) representing the edges of the graph, where 1 ≤ u, v ≤ n and 1 ≤ w ≤ 10^5. Each edge tuple consists of three integers representing two vertices connected by an edge and the respective edge weight. Output * Return an integer which is the sum of the weights of the MST. Example ```python assert minimum_spanning_tree(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)]) == 14 assert minimum_spanning_tree(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)]) == 40 ``` Constraints * The graph is guaranteed to be connected. * There could be multiple edges between two vertices, but you should consider only the one with the lowest weight. * Your solution should run within appropriate time and space complexity bounds (~ O(E log E + E log V)). Notes * Implement efficient data structures that can handle union-find operations for detecting cycles in the graph. * Ensure that the graph is constructed and processed correctly to produce the MST. Implement the function `minimum_spanning_tree` to solve the problem of finding the minimum spanning tree using Kruskal\'s algorithm, ensuring it handles various edge cases and large inputs effectively.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Args: n (int): The number of vertices (cities). edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing an edge between vertex u and vertex v with weight w. Returns: int: The weight sum of the MST. # Sort edges based on weight edges.sort(key=lambda edge: edge[2]) uf = UnionFind(n) mst_weight = 0 for u, v, weight in edges: if uf.find(u-1) != uf.find(v-1): uf.union(u-1, v-1) mst_weight += weight return mst_weight"},{"question":"# AVL Tree Implementation and Traversal Objective You are tasked with implementing a function that inserts elements into an AVL Tree and performs an in-order traversal. This tree will ensure that the tree remains balanced after each insertion. Problem Statement Create an AVL tree that supports insertion and performs an in-order traversal to return a sorted list of elements. Function Signatures ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key): Insert a new key into the AVL Tree. :param key: The key to be inserted. pass def in_order_traverse(self): Perform in-order traversal and return keys as a list. :return: Sorted list of elements. pass ``` Constraints - The keys to be inserted will be integers. - The number of operations will be in the range of 1 to 10^4. - TreeNode is assumed to be a part of the `tree.tree` module. Example ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) print(avl.in_order_traverse()) # Output: [10, 20, 25, 30, 40, 50] ``` Detailed Requirements 1. Implement the insert method using AVL tree insertion logic, which includes: - Insertion like a regular BST. - Balancing the tree by checking balance factors. - Performing rotations (left, right, left-right, right-left) if the tree becomes unbalanced. 2. Implement the `in_order_traverse` method to return the elements of the tree in a sorted order.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if node: self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res)"},{"question":"# Segment Tree Implementation and Usage Context A Segment Tree is a data structure that allows efficient range queries and updates on an array. Given a commutative function, you can build a tree that allows for querying over a range in `O(log n)` time and updating an element in `O(log n)` time. Task Implement your own version of the Segment Tree for range sum queries and updates. Function Definitions 1. **build_tree(arr: List[Union[int, float]]) -> None:** * Builds a segment tree from the given array using sum as the commutative function. 2. **update(p: int, value: Union[int, float]) -> None:** * Updates the value at index `p` to `value` in the segment tree. 3. **query(left: int, right: int) -> Union[int, float]:** * Returns the sum of elements from index `left` to `right` (inclusive). ```python class SegmentTree: def __init__(self, arr: List[Union[int, float]]) -> None: Initialize the Segment Tree with the given array. self.tree = [0] * 2 * len(arr) self.size = len(arr) for i in range(self.size): self.tree[self.size + i] = arr[i] self.build_tree() def build_tree(self) -> None: Build the Segment Tree using the sum function. for i in range(self.size - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, p: int, value: Union[int, float]) -> None: Update the value at index `p` to `value`. p += self.size self.tree[p] = value while p > 1: p //= 2 self.tree[p] = self.tree[2 * p] + self.tree[2 * p + 1] def query(self, left: int, right: int) -> Union[int, float]: Return the sum of elements from index `left` to `right` (inclusive). left += self.size right += self.size sum = 0 while left <= right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 0: sum += self.tree[right] right -= 1 left //= 2 right //= 2 return sum # Example Usage: arr = [2, 4, 5, 3, 4] st = SegmentTree(arr) print(st.query(1, 3)) # Output should be 12 (4 + 5 + 3) st.update(3, 6) print(st.query(1, 3)) # Output should be 15 (4 + 5 + 6) ``` Constraints * 1 ≤ `len(arr)` ≤ 10^5 * 0 ≤ `arr[i]` ≤ 10^5 * Multiple `update` and `query` operations should be tested. * Both `update` and `query` operations should abide by `O(log n)` time complexity. Evaluation Criteria * Correct implementation of the Segment Tree. * Efficient handling of range updates and queries. * Edge cases handled appropriately.","solution":"from typing import List, Union class SegmentTree: def __init__(self, arr: List[Union[int, float]]) -> None: Initialize the Segment Tree with the given array. self.tree = [0] * 2 * len(arr) self.size = len(arr) for i in range(self.size): self.tree[self.size + i] = arr[i] self.build_tree() def build_tree(self) -> None: Build the Segment Tree using the sum function. for i in range(self.size - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, p: int, value: Union[int, float]) -> None: Update the value at index `p` to `value`. p += self.size self.tree[p] = value while p > 1: p //= 2 self.tree[p] = self.tree[2 * p] + self.tree[2 * p + 1] def query(self, left: int, right: int) -> Union[int, float]: Return the sum of elements from index `left` to `right` (inclusive). left += self.size right += self.size sum = 0 while left <= right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 0: sum += self.tree[right] right -= 1 left //= 2 right //= 2 return sum # Example Usage: arr = [2, 4, 5, 3, 4] st = SegmentTree(arr) print(st.query(1, 3)) # Output should be 12 (4 + 5 + 3) st.update(3, 6) print(st.query(1, 3)) # Output should be 15 (4 + 5 + 6)"},{"question":"# Question: Minimum Depth of a Binary Tree Context: Understanding the structure and traversal of binary trees is fundamental in computer science. This problem will test your ability to implement a function to determine the minimum depth of a binary tree, which is the shortest path from the root node to any leaf node. Task: You are required to implement a function, `min_depth`, that computes the minimum depth of a given binary tree. Additionally, you must provide an iterative solution using BFS (Breadth-First Search). Requirements: 1. **Function Signature**: - **Python**: `def min_depth_recursive(root: TreeNode) -> int:` - **Python**: `def min_depth_iterative(root: TreeNode) -> int:` 2. **Input**: - A binary tree represented by its root node. - The tree is defined using a class `TreeNode`: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. **Output**: - The minimum depth of the binary tree as an integer. 4. **Constraints**: - The number of nodes in the tree is in the range `[0, 10^4]`. - Tree node values are integers in the range `[-10^4, 10^4]`. 5. **Performance Requirements**: - Your solution should be efficient in terms of both time and space. Example: Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` - For this tree, `min_depth_recursive` and `min_depth_iterative` should both return `2`, since the shortest path from root to leaf is through node `9`. Notes: - Ensure your function handles edge cases such as an empty tree or a tree with only one node. Solution Template: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_recursive(root: TreeNode) -> int: # Your implementation here pass def min_depth_iterative(root: TreeNode) -> int: # Your implementation here pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_recursive(root: TreeNode) -> int: if not root: return 0 if not root.left and not root.right: return 1 left_depth = float(\'inf\') right_depth = float(\'inf\') if root.left: left_depth = min_depth_recursive(root.left) if root.right: right_depth = min_depth_recursive(root.right) return 1 + min(left_depth, right_depth) from collections import deque def min_depth_iterative(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Unique Pair Finder **Problem Statement:** You are given an array of integers `nums` where exactly two elements appear only once, and all the others appear exactly twice. Write a function to find the two elements that appear only once. Your solution must achieve a time complexity of O(N) and a space complexity of O(1). **Function Signature:** ```python def find_unique_pair(nums: List[int]) -> List[int]: pass ``` **Input:** * `nums` (List[int]): A list of integers where exactly two elements appear only once and all others appear exactly twice. Length of the list is at least 2 and it will always contain at least two unique numbers that appear only once. **Output:** * Returns a list of two integers that appear only once in any order. **Constraints:** * The function should run in O(N) time complexity. * The function should use O(1) space complexity. **Example:** * `nums = [1, 2, 1, 3, 2, 5]` should return `[3, 5]` or `[5, 3]`. **Notes:** * The order of the result is not important. **Explanation:** * The example input `[1, 2, 1, 3, 2, 5]` has the numbers `3` and `5` appearing only once. The rest of the numbers appear twice. Make sure to correctly handle the isolation of the right-most differing bit and use this property to divide the numbers into two groups, ensuring that each group can be XORed to isolate one of the unique numbers.","solution":"from typing import List def find_unique_pair(nums: List[int]) -> List[int]: # XOR all the numbers to get a combined result of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Find the rightmost differing bit differing_bit = xor_all & -xor_all # Divide numbers into two groups based on the differing bit num1, num2 = 0, 0 for num in nums: if num & differing_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"You are tasked with writing a function to process an input string by removing any reoccurring characters while preserving the order of their first occurrences. Characters are considered on a case-sensitive basis (i.e., \'a\' and \'A\' are different). # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: pass ``` # Input & Output Format * **Input**: A single string `string` with a maximum length of 10^5 characters. The string can contain any printable ASCII characters. * **Output**: A string with all reoccurring characters removed, preserving the order of their first appearance. # Constraints 1. The function should operate within O(n) time complexity. 2. Consider case sensitivity (\'a\' and \'A\' are different). # Example Example 1 * Input: `\\"Google\\"` * Output: `\\"Gogle\\"` Example 2 * Input: `\\"Programming\\"` * Output: `\\"Progamin\\"` # Edge Cases to Handle * Empty input string returns an empty string. * Strings with no repeating characters return the original string. # Scenario Imagine you are tasked with pre-processing a large dataset of user-generated content to remove duplicate characters in each piece of text. This could be part of a larger text normalization process before further natural language processing. Good luck!","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a string with all reoccurring characters removed, preserving the order of their first appearance. Parameters: string (str): The input string. Returns: str: The processed string with reoccurring characters removed. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario You are tasked to implement a balanced bracket checker using a stack. The aim is to ensure that every opening bracket has a corresponding closing bracket in the correct order. The input will be a string consisting of various types of brackets: `()`, `{}`, `[]`. # Question **Problem**: Write a function `is_balanced(expression: str) -> bool` that takes a string `expression` as input and returns `True` if the brackets are balanced and `False` otherwise. # Function Signature ```python def is_balanced(expression: str) -> bool: pass ``` # Input/Output Format * **Input**: A string `expression` containing brackets. Length of the expression is between 1 and 10^4. * **Output**: A boolean `True` if the string is balanced, otherwise `False`. # Constraints * Only the bracket characters `()`, `{}`, `[]` are considered valid and need to be checked. * You must implement your function using one of the stack implementations provided: `ArrayStack` or `LinkedListStack`. # Example ```python assert is_balanced(\\"(){}[]\\") == True assert is_balanced(\\"({[]})\\") == True assert is_balanced(\\"({[})\\") == False assert is_balanced(\\"(((())))\\") == True assert is_balanced(\\"({[\\") == False ``` # Explanation 1. An empty stack will be used to keep track of the opening brackets. 2. As you iterate through each character in the string: * If it is an opening bracket (`(`, `{`, `[`), push it onto the stack. * If it is a closing bracket (`)`, `}`, `]`), check if the stack is not empty and if the top of the stack matches the corresponding opening bracket. If not, return `False`. If it matches, pop the stack. 3. After processing all characters, if the stack is empty, return `True`. Otherwise, return `False`.","solution":"def is_balanced(expression: str) -> bool: This function checks if the given expression has balanced brackets. bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} open_set = set(bracket_map.values()) stack = [] for char in expression: if char in open_set: stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"**Scenario**: You are a software engineer working on a security system for an innovative home protection agency. The system includes a smart contract feature that helps homeowners determine the maximum amount of money that can be safely robbed from a sequence of houses without tripping off the interconnected alarm systems of adjacent homes. **Question**: Implement a function `house_robber(houses)` that takes a list of non-negative integers, where each element represents the amount of money stashed in a house, and returns the maximum amount of money that can be robbed given the constraint that no two adjacent houses can be robbed on the same night. **Function Signature**: ```python def house_robber(houses: List[int]) -> int: ``` **Input**: * `houses`: List of non-negative integers (1 <= len(houses) <= 10^4, 0 <= houses[i] <= 10^4) **Output**: * Return a single integer representing the maximum amount of money that can be robbed without alerting the police. **Constraints**: * No two adjacent houses can be robbed on the same night. **Examples**: 1. `house_robber([2, 3, 2])` should return `4` 2. `house_robber([1, 2, 3, 1])` should return `4` 3. `house_robber([2, 7, 9, 3, 1])` should return `12` **Notes**: * Focus on ensuring the algorithm efficiently handles the constraints provided. * Consider edge cases where the house list is empty or has only one house.","solution":"from typing import List def house_robber(houses: List[int]) -> int: n = len(houses) if n == 0: return 0 elif n == 1: return houses[0] # Helper function to handle the simple linear robber problem def rob_linear(houses: List[int]) -> int: prev2, prev1 = 0, 0 for house in houses: current = max(prev1, prev2 + house) prev2 = prev1 prev1 = current return prev1 return rob_linear(houses)"},{"question":"# Number Decomposition and Combination Count You are tasked with developing a function to compute the number of ways a positive integer can be decomposed into a sum of smaller non-negative integers. A decomposition includes listing forms of combinations that add up to the integer, potentially using repeated elements. Your goal is to implement the function `int_divide` that uses dynamic programming to solve this problem efficiently. Function Signature ```python def int_divide(decompose: int) -> int: Find number of decompositions from `decompose` Parameters: decompose (int): The positive integer to be decomposed. Returns: int: The number of ways `decompose` can be decomposed into sums of smaller non-negative integers. ``` Input - A single positive integer `decompose`. (1 ≤ decompose ≤ 1000) Output - An integer representing the total number of ways to decompose the given `decompose`. Constraints - Consider using a dynamic programming approach to handle the problem within a reasonable time and space complexity. - Ensure your implementation handles edge cases efficiently. Example ```python print(int_divide(4)) # Expected Output: 5 print(int_divide(7)) # Expected Output: 15 print(int_divide(1)) # Expected Output: 1 ``` Explanation - For `int_divide(4)`, the decompositions are: ``` 4 3+1 2+2 2+1+1 1+1+1+1 ``` - For `int_divide(7)`, the decompositions are numerous, resulting in 15 possible combinations. Evaluation Your solution will be assessed based on: 1. **Correctness**: Does the function return the correct number of decompositions? 2. **Efficiency**: Is the function efficient and runs within expected time and space limits? 3. **Edge Case Handling**: Does the function handle all specified edge cases?","solution":"def int_divide(n: int) -> int: Find the number of ways to decompose a positive integer `n` into sums of smaller non-negative integers. Parameters: n (int): The positive integer to be decomposed. Returns: int: The number of ways `n` can be decomposed into sums of smaller non-negative integers. dp = [1] + [0] * n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Knapsack Problem with Fractional Items Scenario You are tasked to optimize the storage in a warehouse where you can store fractions of items, unlike the traditional 0/1 knapsack problem. Given a set of items, each defined by its value and weight, and a maximum capacity, the goal is to maximize the value of the items stored in the warehouse. Task Implement a function `get_maximum_fractional_value(items, capacity)` that returns the maximum value that can be fit into the warehouse capacity using the fractional knapsack approach. Input * `items`: A list of tuples where each tuple contains two integers, value and weight of the item (items[i] = (value_i, weight_i)). * `capacity`: An integer representing the maximum capacity of the warehouse. Output * Return a floating-point number representing the maximum value that can be fit into the warehouse capacity. Constraints * 1 ≤ number of items ≤ 1000 * 1 ≤ value, weight, capacity ≤ 10^5 Example ```python items = [(60, 10), (100, 20), (120, 30)] capacity = 50 get_maximum_fractional_value(items, capacity) # Expected Output: 240.0 ``` Explanation: You can take the whole item with value 100, and then take half of the item with value 120. The total value would be 100 + (120 * (10/30)) = 100 + 40 = 140. Ensure your solution is efficient and handles fraction properly to maximize the value under given constraints.","solution":"def get_maximum_fractional_value(items, capacity): Calculate the maximum value that can be carried in the knapsack with given capacity using fractional items. Parameters: items (list of tuples): Each tuple contains (value, weight) capacity (int): Maximum capacity of knapsack Returns: float: The maximum value that can be carried in the knapsack # Calculate value per weight ratio for each item and sort them items = sorted(items, key=lambda x: x[0] / x[1], reverse=True) total_value = 0.0 for value, weight in items: if capacity == 0: break if weight <= capacity: capacity -= weight total_value += value else: total_value += (value / weight) * capacity capacity = 0 return total_value"},{"question":"# Task: Implement a Hybrid Heap Sort Algorithm Objective Using the principles of both Max Heap Sort and Min Heap Sort, develop a hybrid heap sort algorithm that can dynamically switch between Max Heap and Min Heap based on certain conditions, optimizing the overall sorting process. Problem Statement Write a function `hybrid_heap_sort(arr)` that takes an array of integers `arr` and sorts it in ascending order. Your function should dynamically switch between using a Max Heap and a Min Heap to optimize the sorting process. Specifically: 1. Use Max Heap Sort to handle the first half of the array. 2. Use Min Heap Sort to handle the second half of the array. 3. Merge the two halves to produce the final sorted array. Requirements * **Input**: * An unsorted array of integers, `arr`. * Constraints: `1 <= len(arr) <= 10^5`, each element in `arr` lies in the range `[-10^9, 10^9]`. * **Output**: A new array containing the sorted elements in ascending order. Constraints 1. You may not use built-in sort functions. 2. You must implement the heap sort mechanisms provided in the code snippets above. 3. Your solution should have a time complexity of **O(n log n)**. 4. Try to maintain an in-place approach as much as possible to preserve memory efficiency. Guidelines * Implement helper methods for Max Heap Sort (`max_heap_sort`) and Min Heap Sort (`min_heap_sort`). * Use these helper methods within the `hybrid_heap_sort` to achieve the task. * Ensure to handle edge cases such as arrays with single elements, already sorted arrays, and arrays with duplicate elements. Example # Input ```python arr = [4, 10, 3, 5, 1, 7, 9, 6] ``` # Output ```python [1, 3, 4, 5, 6, 7, 9, 10] ```","solution":"def max_heapify(arr, n, i): Helper function to maintain the max heap property for the given subtree. largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): Helper function to maintain the min heap property for the given subtree. smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def max_heap_sort(arr): Function to perform max heap sort on an array. n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) def min_heap_sort(arr): Function to perform min heap sort on an array. n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) def hybrid_heap_sort(arr): Function to perform hybrid heap sort on an array. n = len(arr) if n <= 1: return arr mid = n // 2 # Max heap sort on the first half first_half = arr[:mid] max_heap_sort(first_half) # Min heap sort on the second half second_half = arr[mid:] min_heap_sort(second_half) result = first_half + second_half result.sort() return result"},{"question":"# Shell Sort Implementation Problem Description You are tasked with implementing the Shell Sort algorithm and optimizing it to handle common edge cases effectively. Ensure that your implementation takes into consideration performance bottlenecks and potential error scenarios. Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr`, where `1 <= len(arr) <= 10^5`. * The integers in the list can be in any order, including all being the same value. Output * A list of integers, sorted in non-decreasing order. Constraints * You should aim to optimize the time complexity by carefully choosing the gap sequence. * The algorithm should handle arrays with up to 100,000 elements efficiently. Requirements * Ensure your function handles the following edge cases: - Empty array - Array with a single element - Array with repeated elements * Optimize gap sequence to improve performance for larger arrays. Example ```python # Example Inputs and Outputs assert optimized_shell_sort([45, 23, 53, 12, 43, 13, 26, 51, 18]) == [12, 13, 18, 23, 26, 43, 45, 51, 53] assert optimized_shell_sort([5, -1, 3, 7, 3, -1, 5]) == [-1, -1, 3, 3, 5, 5, 7] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([42]) == [42] assert optimized_shell_sort([42, 42, 42]) == [42, 42, 42] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Perform an optimized Shell Sort on the input list arr. n = len(arr) gaps = [] h = 1 while h < n: gaps.append(h) h = 3 * h + 1 gaps.reverse() for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Scenario You are working for a technology company that needs to ensure the proper allocation and management of user IDs. Each ID should be within a particular range, but due to various reasons (e.g., user deletions or skipped allocations), some IDs may be missing from the allocation list. Given a sorted list of allocated IDs and a specified ID range, you are to write a function that determines which ID ranges are missing. Task Implement the `find_missing_id_ranges` function that identifies the missing ID ranges within the specified lower and upper bound, `lo` and `hi`, using the provided algorithm principles. Function Signature ```python def find_missing_id_ranges(allocated_ids: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` Input - `allocated_ids` (List[int]): A sorted list of integer IDs that have been allocated. The list may be empty. - `lo` (int): The lower bound of the ID range. - `hi` (int): The upper bound of the ID range. Output - Returns a list of tuples where each tuple represents a range of missing IDs. Each tuple contains two integers, representing the start and end of the missing range. Constraints - `1 <= len(allocated_ids) <= 10^5` - `1 <= lo <= hi <= 10^9` - Each ID within `allocated_ids` is between `lo` and `hi`. Examples 1. Input: `allocated_ids = [2, 4, 7, 8], lo = 1, hi = 10` Output: `[(1, 1), (3, 3), (5, 6), (9, 10)]` 2. Input: `allocated_ids = [], lo = 1, hi = 5` Output: `[(1, 5)]` 3. Input: `allocated_ids = [1, 2, 3], lo = 1, hi = 3` Output: `[]` # Additional Information Consider edge cases such as: - An empty list of allocated IDs. - The allocated IDs completely covering the range from `lo` to `hi`. - Allocated IDs exactly at the boundaries (`lo` and `hi`). You are expected to handle these cases efficiently and ensure your function runs within the given constraints.","solution":"from typing import List, Tuple def find_missing_id_ranges(allocated_ids: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: missing_ranges = [] prev = lo - 1 for current in allocated_ids: if current - prev > 1: missing_ranges.append((prev + 1, current - 1)) prev = current if hi - prev > 0: missing_ranges.append((prev + 1, hi)) return missing_ranges"},{"question":"As a software developer, you are tasked with creating a system that manages a network of tasks with dependencies. This network is represented as a directed acyclic graph (DAG) where nodes represent tasks and directed edges represent dependencies (an edge from Task A to Task B means Task A must be completed before Task B). **Your task** is to implement a function `topological_sort(graph: DirectedGraph) -> List[str]` that performs a topological sort on the given directed graph. The function should return a list of task names in an order that respects dependency constraints. # Function Signature ```python def topological_sort(graph: DirectedGraph) -> List[str]: ``` # Input * `graph`: An instance of the `DirectedGraph` class. # Output * Returns a list of task names in topologically sorted order. # Constraints * The graph is guaranteed to be a Directed Acyclic Graph (DAG). * The nodes in the graph are uniquely named. * The graph object is constructed using the `DirectedGraph` class provided in the snippets. # Example ```python # Create a graph using adjacency list dictionary representation # Task D depends on Task C, Task C depends on Task B, Task B depends on Task A graph_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } # Initialize graph graph = DirectedGraph(graph_dict) # Perform topological sort sorted_tasks = topological_sort(graph) # sorted_tasks may be [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] ``` # Hint - You may use algorithms such as Kahn\'s algorithm or Depth-First Search (DFS) for performing topological sorting. **Performance Requirement**: Ensure that your solution has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph.","solution":"from typing import List, Dict, Set class DirectedGraph: def __init__(self, adjacency_list: Dict[str, List[str]]): self.adjacency_list = adjacency_list def topological_sort(graph: DirectedGraph) -> List[str]: def dfs(node): if node in visited: return visited.add(node) for neighbor in graph.adjacency_list[node]: dfs(neighbor) result.append(node) visited = set() result = [] # Call DFS for each vertex to cover disconnected parts of the graph for node in graph.adjacency_list: if node not in visited: dfs(node) # Since we are appending to result after exploring neighbors, we reverse it at the end return result[::-1]"},{"question":"# Climbing Stairs Challenge Background You are climbing a staircase. It takes `steps` number of steps to reach the top. Each time, you can either climb 1 or 2 steps. You need to determine the number of distinct ways you can reach the top of the staircase. Assume `steps` will always be a positive integer. Requirements 1. Implement a function `calculate_ways(steps: int) -> int` that returns the number of distinct ways to reach the top of the staircase. 2. Optimize your solution to have O(1) space complexity. Input - `steps`: An integer representing the number of steps to reach the top. (1 ≤ steps ≤ 10^5) Output - An integer representing the number of distinct ways to reach the top of the staircase. Example 1. Input: `steps = 2` Output: `2` (Explanation: There are two ways to reach the top: (1 step + 1 step) or (2 steps in one go)) 2. Input: `steps = 3` Output: `3` (Explanation: There are three ways to reach the top: (1+1+1), (1+2), (2+1)) 3. Input: `steps = 5` Output: `8` (Explanation: The sequence follows the pattern of Fibonacci, i.e., F(n) = F(n-1) + F(n-2), thus the answer is 8) Constraints - You should strive for both optimal time and space complexity. - Only consider valid positive integer inputs for `steps`.","solution":"def calculate_ways(steps): Calculate the number of distinct ways to reach the top of the staircase. if steps == 1: return 1 elif steps == 2: return 2 prev2, prev1 = 1, 2 for _ in range(3, steps+1): current = prev1 + prev2 prev2, prev1 = prev1, current return prev1"},{"question":"You are given a list of integers. Your task is to implement a function that finds the most frequent integer(s) (mode) in the list. Return these integers in a list. Note that there might be multiple integers with the same highest frequency. Your implementation should be efficient in terms of time complexity and should handle edge cases effectively. Function Signature: ```python def find_mode(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers. The length of the list, `n`, where 0 <= n <= 10^6. # Output: - A list of integers that are the most frequent in the input list, in any order. # Constraints: - The input list may be empty. - The integers in the list can be negative, zero, or positive. - Performance requirements are that the function must run in O(n) time complexity. # Example Cases: Input ```python find_mode([1, 1, 2, 2, 3, 4]) ``` Output ```python [1, 2] ``` Input ```python find_mode([5, 5, 5, 2, 2, 2, 3, 1]) ``` Output ```python [5, 2] ``` Input ```python find_mode([]) ``` Output ```python [] ``` Input ```python find_mode([7]) ``` Output ```python [7] ``` # Notes: - Ensure your function handles edge cases such as an empty list appropriately. - If there are multiple numbers with the same highest frequency, the order of their appearance in the output list does not matter.","solution":"from typing import List from collections import Counter def find_mode(arr: List[int]) -> List[int]: Finds the most frequent integer(s) (mode) in the list. Returns these integers in a list. if not arr: return [] # Count the frequency of each number in the list counts = Counter(arr) # Find the maximum frequency max_count = max(counts.values()) # Collect all numbers with the maximum frequency mode = [num for num, count in counts.items() if count == max_count] return mode"},{"question":"You are required to write a function called `improved_insertion_sort` that sorts a list of integers using the insertion sort algorithm. The algorithm provided should be optimized to detect whether the list becomes sorted during the sorting process and terminate early if no swaps are made in a pass. # Function Signature ```python def improved_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers to be sorted. # Output * (List[int]): The sorted list of integers in non-decreasing order. # Constraints * The input list can have up to 10^4 elements. * Each element of the list can be an integer between -10^6 and 10^6. # Example ```python >>> improved_insertion_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> improved_insertion_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> improved_insertion_sort([]) [] ``` # Notes * Optimize the insertion sort algorithm to terminate early if the list becomes sorted before completing all iterations. * Handle edge cases such as an empty list and a list with one element. # Explanation The improved insertion sort should detect if the list is already sorted or becomes sorted during execution, leading to early termination if no swaps are necessary. This enhancement preserves the algorithm\'s stability and in-place properties while improving its efficiency for certain input cases.","solution":"from typing import List def improved_insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers using an optimized insertion sort algorithm. The optimization involves early termination if no swaps are necessary. n = len(arr) if n <= 1: return arr for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Check if the list is already sorted sorted_check = all(arr[k] <= arr[k + 1] for k in range(n - 1)) if sorted_check: break return arr"},{"question":"# Coding Task: Extend the BTree Implementation Using the provided BTree and Node class implementation, extend the functionality of the BTree with the following features: 1. **Range Query**: - Implement a method called `range_query` that takes two arguments, `low` and `high`, returning a list of all keys within this range `[low, high]` inclusive. - The method should efficiently traverse the BTree to locate the starting point within the range and then collect all the keys within the range. 2. **Sum of Range**: - Implement a method called `sum_of_range` that takes two arguments, `low` and `high`, returning the sum of all keys within the range `[low, high]` inclusive. - Utilize your `range_query` method to collect the relevant keys and compute the sum. # Constraints * The keys stored in the BTree are integer values. * The `low` and `high` parameters for the range query will always be valid integers such that `low <= high`. # Expected Input and Output Format: For the `range_query` method: * **Input**: * `low`: An integer representing the lower bound of the range. * `high`: An integer representing the upper bound of the range. * **Output**: A list of integers representing the keys within the range `[low, high]` inclusive. For the `sum_of_range` method: * **Input**: * `low`: An integer representing the lower bound of the range. * `high`: An integer representing the upper bound of the range. * **Output**: An integer representing the sum of keys within the range `[low, high]` inclusive. # Example ```python # Assuming BTree initialized and keys inserted as follows b_tree = BTree(t_val=3) keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: b_tree.insert_key(key) # Example usage: print(b_tree.range_query(6, 17)) # Output: [6, 7, 10, 12, 17] print(b_tree.sum_of_range(6, 17)) # Output: 52 ``` # Implementation Notes - Ensure both methods leverage the BTree\'s structure and properties for efficient traversal and data collection. - Handle edge cases like when no keys fall within the specified range. - Be mindful of the efficiency and ensure that the methods operate within the constraint of the BTree\'s properties.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.keys = [] self.children = [] self.leaf = leaf class BTree: def __init__(self, t): self.root = Node(t, True) self.t = t def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = Node(self.t) self.root = temp temp.children.append(root) self._split_child(temp, 0) self._insert_non_full(temp, k) else: self._insert_non_full(root, k) def _split_child(self, parent, i): t = self.t node = parent.children[i] newNode = Node(t, node.leaf) parent.children.insert(i + 1, newNode) parent.keys.insert(i, node.keys[t - 1]) newNode.keys = node.keys[t:(2 * t - 1)] node.keys = node.keys[0:(t - 1)] if not node.leaf: newNode.children = node.children[t:(2 * t)] node.children = node.children[0:(t)] def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def range_query(self, low, high): def _range_query(node, low, high): result = [] i = 0 while i < len(node.keys) and node.keys[i] < low: i += 1 while i < len(node.keys) and node.keys[i] <= high: if not node.leaf: result.extend(_range_query(node.children[i], low, high)) result.append(node.keys[i]) i += 1 if not node.leaf: result.extend(_range_query(node.children[i], low, high)) return result return _range_query(self.root, low, high) def sum_of_range(self, low, high): return sum(self.range_query(low, high))"},{"question":"**Scenario**: You are working on a compression utility for efficiently storing repetitive character sequences in strings. To achieve this, you need to use Run-Length Encoding (RLE) and provide the corresponding decoding functionality for data retrieval. **Task**: Implement the encoding and decoding functions for RLE as specified. **Function Implementations**: 1. **encode_rle(input)**: * Input: A string `input` of printable characters. * Output: Returns a string where each run of characters is encoded as the character followed by the number of repetitions. 2. **decode_rle(input)**: * Input: A string `input` that represents an RLE encoded string. * Output: Returns the original decoded string. **Constraints**: - All characters in `input` are valid printable characters. - The encoded string will not contain numbers as original data, only as part of the encoding format. **Performance Requirements**: - Both functions should run in O(n) time where n is the length of the string. # Example: For `encode_rle(input)`: ```python assert encode_rle(\\"aaaabbbcca\\") == \\"4a3b2c1a\\" assert encode_rle(\\"abc\\") == \\"1a1b1c\\" ``` For `decode_rle(input)`: ```python assert decode_rle(\\"4a3b2c1a\\") == \\"aaaabbbcca\\" assert decode_rle(\\"1a1b1c\\") == \\"abc\\" ``` Implement these function definitions in Python, ensuring they handle the constraints and edge cases as described above.","solution":"def encode_rle(input): Encodes the given string using Run-Length Encoding (RLE). :param input: The input string to be encoded. :return: The RLE encoded string. if not input: return \\"\\" encoded = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{count}{current_char}\\") current_char = char count = 1 # Append the last group encoded.append(f\\"{count}{current_char}\\") return \\"\\".join(encoded) def decode_rle(input): Decodes the given RLE encoded string back to its original form. :param input: The RLE encoded string to be decoded. :return: The original decoded string. if not input: return \\"\\" decoded = [] num = \\"\\" for char in input: if char.isdigit(): num += char else: decoded.append(char * int(num)) num = \\"\\" return \\"\\".join(decoded)"},{"question":"You are tasked with implementing a power function using binary exponentiation (iterative approach), which computes `a^n (mod m)` efficiently. **Function Signature:** ```python def custom_power(a: int, n: int, m: int) -> int: pass ``` # Input: * `a` (int): The base of the exponentiation ( |a| <= 10^9 ) * `n` (int): The exponent ( 0 <= n <= 10^9 ) * `m` (int): The modulus (2 <= m <= 10^9) # Output: * `int`: The result of `(a^n) % m`. # Requirements and Constraints: 1. You should use an iterative method for the implementation (avoid recursion). 2. Consider all edge cases, including `n = 0`, which should return `1` regardless of `a`. 3. Ensure your solution handles large values of `a` and `n` efficiently. 4. Avoid using built-in power functions or any libraries directly solving this problem. 5. Maintain optimal time complexity of `O(log(n))` and space complexity of `O(1)`. # Examples: Example 1: ```plaintext Input: a = 2, n = 10, m = 1000 Output: 24 Explanation: 2^10 = 1024, 1024 % 1000 = 24 ``` Example 2: ```plaintext Input: a = 3, n = 5, m = 7 Output: 5 Explanation: 3^5 = 243, 243 % 7 = 5 ``` Example 3: ```plaintext Input: a = 2, n = 0, m = 1000 Output: 1 Explanation: Any number to the power of 0 is 1. ```","solution":"def custom_power(a: int, n: int, m: int) -> int: Implements a^n (mod m) using the binary exponentiation method. result = 1 a = a % m while n > 0: if n % 2: # If n is odd, multiply a with result result = (result * a) % m a = (a * a) % m # Square the base n //= 2 # Divide the exponent by 2 return result"},{"question":"# Context: You are a software engineer working on a task scheduling system. Tasks are assigned different priorities, and you need to manage these tasks efficiently by always executing the highest priority task available. # Task: Implement a `TaskScheduler` class that uses a priority queue to manage tasks. The priority queue should allow efficient insertion of tasks and retrieval of the highest priority task. The priority of tasks is determined by an integer, where a lower value indicates higher priority. # Requirements: 1. Implement the `TaskScheduler` class with the following methods: - `add_task(task_name, priority)`: Adds a task with the specified priority. - `get_next_task()`: Retrieves and removes the highest priority task. If the queue is empty, return `\\"No tasks available\\"`. 2. The class should use the provided priority queue as a base for its operations. # Input and Output Formats: 1. **add_task**: - **Input**: `task_name` (str) - The name of the task. `priority` (int) - The priority of the task. 2. **get_next_task**: - **Output**: The name of the highest priority task (str). If no tasks are available, return `\\"No tasks available\\"`. # Constraints: - `task_name` should be a non-empty string with a maximum length of 100 characters. - `priority` should be an integer between 1 and 100 (inclusive). # Performance: - The implemented solution should handle up to 10,000 tasks efficiently. # Example: ```python scheduler = TaskScheduler() scheduler.add_task(\\"task1\\", 3) scheduler.add_task(\\"task2\\", 1) scheduler.add_task(\\"task3\\", 2) assert scheduler.get_next_task() == \\"task2\\" assert scheduler.get_next_task() == \\"task3\\" assert scheduler.get_next_task() == \\"task1\\" assert scheduler.get_next_task() == \\"No tasks available\\" ``` Implement the `TaskScheduler` class below:","solution":"import heapq class TaskScheduler: def __init__(self): self.priority_queue = [] def add_task(self, task_name, priority): if not isinstance(task_name, str) or len(task_name) == 0 or len(task_name) > 100: raise ValueError(\\"task_name must be a non-empty string with a maximum length of 100 characters\\") if not isinstance(priority, int) or priority < 1 or priority > 100: raise ValueError(\\"priority must be an integer between 1 and 100 (inclusive)\\") heapq.heappush(self.priority_queue, (priority, task_name)) def get_next_task(self): if not self.priority_queue: return \\"No tasks available\\" priority, task_name = heapq.heappop(self.priority_queue) return task_name"},{"question":"# Question: Advanced Palindrome Checker Scenario: You are developing a feature for a text validation system that needs to check whether entries are palindromes. Your system should be robust, handling a variety of inputs including sentences, punctuation, and ignoring case sensitivity. # Task: Implement a function `advanced_palindrome_checker` in Python that: - Receives a string `s`. - First removes any non-alphanumeric characters and converts everything to lowercase. - Then checks if the cleaned string is a palindrome, using the most space-efficient approach possible. Input: - A string `s` which may contain characters including spaces and punctuation (0 <= len(s) <= 10^6). Output: - Returns `True` if the cleaned string is a palindrome, `False` otherwise. Constraints: - Your solution should be optimal in time complexity and use space wisely. - Handle edge cases such as empty strings and strings comprising only non-alphanumeric characters appropriately. # Function Signature: ```python def advanced_palindrome_checker(s: str) -> bool: pass ``` # Example: ```python assert advanced_palindrome_checker(\\"A man, a plan, a canal: Panama\\") == True assert advanced_palindrome_checker(\\"race a car\\") == False assert advanced_palindrome_checker(\\"\\") == True assert advanced_palindrome_checker(\\".,\\") == True ``` Evaluation: Your implementation will be evaluated on: 1. Correctness. 2. Time and space efficiency. 3. Handling edge cases effectively.","solution":"def advanced_palindrome_checker(s: str) -> bool: Checks if the input string s is a palindrome, ignoring non-alphanumeric characters and case. :param s: Input string which may contain a variety of characters including spaces and punctuation. :return: True if the cleaned string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase cleaned_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is a palindrome return cleaned_s == cleaned_s[::-1]"},{"question":"# Binary Search for First Occurrence **Context**: You are given the task to find the first occurrence of a specific element within a sorted list of integers. The list is sorted in non-decreasing (increasing) order. Your task is to efficiently locate the first occurrence of this element using a search mechanism. **Function Signature**: ```python def find_first_occurrence(array: List[int], query: int) -> int: :param array: List[int] - The list of integers sorted in increasing order. :param query: int - The integer value to search for. :return: int - The index of the first occurrence of the query element in array or -1 if not found ``` **Constraints**: - The length of the array will not exceed (10^6). - Each element in the array will be an integer within the range (-10^6) to (10^6). - Duplicates may exist in the array. **Input**: - `array`: A list of integers sorted in increasing order. - `query`: An integer you need to search for in the array. **Output**: - An integer representing the index of the first occurrence of `query` in the array. - Return `-1` if the `query` is not found in the array. **Example**: ```python # Example 1: array = [1, 2, 2, 2, 4, 5, 6] query = 2 # Output: 1 # Explanation: The first occurrence of 2 is at index 1. # Example 2: array = [1, 3, 5, 7] query = 4 # Output: -1 # Explanation: 4 is not present in the array. ``` **Note**: - Make sure to optimize the function to run in O(log n) time complexity. - Consider edge cases such as an empty array or the `query` not being present.","solution":"from typing import List def find_first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of the query in the sorted array. If query is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # look for earlier occurrences elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Problem Description You are required to implement a class that extends the Stack Abstract Data Type (ADT) using a different approach: a Circular Array Stack. The main goal of this circular array-based stack is to wrap around when it reaches the end of the array, thus reusing empty slots that may have been formed at the beginning due to consecutive pop operations. # Your Task Implement a CircularArrayStack class that supports the following functions: - `push(item)`: Adds a new item to the top of the stack. - `pop()`: Removes and returns the top item from the stack. - `peek()`: Returns the top item from the stack without removing it. - `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. # Class Signature ```python class CircularArrayStack(AbstractStack): def __init__(self, size=10): # Constructor to initialize stack with given size def __iter__(self): # Iterator implementation to iterate through the stack elements def push(self, item): # Adds a new item to the top of the stack def pop(self): # Removes and returns the top item from the stack def peek(self): # Returns the top item from the stack without removing it def is_empty(self): # Checks if the stack is empty ``` # Constraints - Do not use Python’s inbuilt list methods push, pop, and append. - The stack should have a fixed size, which is set when the stack is created. - Handle edge cases where the stack might be full or empty appropriately. # Performance Requirements - All operations should run in O(1) time complexity except the situations where resizing is needed. - The usage of space for the stack should not exceed twice its initial size. # Example ```python stack = CircularArrayStack(5) stack.push(1) stack.push(2) stack.push(3) print(stack.pop()) # Output: 3 stack.push(4) print(stack.peek()) # Output: 4 print(stack.is_empty()) # Output: False ```","solution":"class CircularArrayStack: def __init__(self, size=10): self.size = size self.data = [None] * size self.top = -1 self.start = 0 self.count = 0 def push(self, item): if self.count == self.size: raise OverflowError(\\"Stack is full\\") self.top = (self.top + 1) % self.size self.data[self.top] = item self.count += 1 def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") item = self.data[self.top] self.data[self.top] = None # Clear the reference self.top = (self.top - 1 + self.size) % self.size self.count -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.data[self.top] def is_empty(self): return self.count == 0"},{"question":"# Question: Check Prime Intervals You have been tasked with developing a function that checks the number of prime numbers in a given range ([a, b]) inclusively. Task: Write a Python function `count_primes(a: int, b: int) -> int` that returns the count of prime numbers between two given integers (a) and (b) (inclusive). Input: - Two integers (a) and (b) where (-10^6 leq a leq b leq 10^6). Output: - An integer representing the number of prime numbers between (a) and (b) (inclusive). Constraints: - You should aim for an efficient solution due to the wide range of input values. - Ensure your solution is robust to handle both negative and positive ranges. Example: ```python assert count_primes(1, 10) == 4 # Primes are 2, 3, 5, 7 assert count_primes(10, 20) == 4 # Primes are 11, 13, 17, 19 assert count_primes(-10, 10) == 4 # Primes are 2, 3, 5, 7 assert count_primes(30, 40) == 2 # Primes are 31, 37 ``` Additional Notes: - Consider re-using the `prime_check(n)` function provided. You may optimize or modify it as needed for checking primes within a range efficiently. - Your implementation should handle edge cases such as negative inputs and zeros properly.","solution":"import math def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes(a, b): Count the number of prime numbers in the range [a, b] (inclusive). count = 0 for num in range(a, b + 1): if is_prime(num): count += 1 return count"},{"question":"# Scenario You are tasked with sorting a list of earthquake magnitudes recorded over a period of time. These magnitudes are given as integer values ranging from -5 to 10. Due to the nature of the data, it\'s imperative to sort these magnitudes rapidly to analyze aftershocks and major quakes. # Problem Statement Implement the **counting sort** algorithm to sort the given list of earthquake magnitudes. Ensure that the algorithm handles negative values efficiently. # Function Signature ```python def earthquake_counting_sort(magnitudes: List[int]) -> List[int]: pass ``` # Input * `magnitudes` (List[int]): A list of integers ranging from -5 to 10, representing recorded earthquake magnitudes. # Output * Returns a list of integers sorted in non-decreasing order. # Constraints * The length of the list is between 0 and 10^6. * The integers in the list are in the inclusive range [-5, 10]. # Example ```python print(earthquake_counting_sort([3, -2, -5, 0, 10, 7, -3, 1, 5])) # Output: [-5, -3, -2, 0, 1, 3, 5, 7, 10] print(earthquake_counting_sort([])) # Output: [] print(earthquake_counting_sort([0, 0, 0, 0])) # Output: [0, 0, 0, 0] ``` # Guidelines * Handle edge cases carefully, especially the presence of negative numbers. * Ensure the algorithm works efficiently for the upper limit of the input size. * You should not use in-built sorting functions. Instead, implement the counting sort algorithm as described.","solution":"def earthquake_counting_sort(magnitudes): Sorts a list of earthquake magnitudes using the counting sort algorithm. This handles magnitudes ranging from -5 to 10. if not magnitudes: return [] # Range of magnitudes known from -5 to 10 min_value = -5 max_value = 10 range_of_values = max_value - min_value + 1 # Create a count array to store the count of each unique value counts = [0] * range_of_values # Populate the counts array for magnitude in magnitudes: counts[magnitude - min_value] += 1 # Build the sorted list based on counts sorted_magnitudes = [] for i in range(range_of_values): sorted_magnitudes.extend([i + min_value] * counts[i]) return sorted_magnitudes"},{"question":"Write a function `find_next_square` that identifies the next perfect square greater than a given input `sq`. If the input is not a perfect square, return -1. # Function Signature ```python def find_next_square(sq: int) -> int: ``` # Input and Output Format: * The input `sq` is a non-negative integer. * The output should be the next perfect square if `sq` is a perfect square, otherwise -1. # Constraints: * `0 <= sq <= 10^12` # Examples: * `find_next_square(121)` returns `144` * `find_next_square(625)` returns `676` * `find_next_square(114)` returns `-1` * `find_next_square(0)` returns `1` * `find_next_square(-4)` returns `-1` # Scenario: Imagine you are working with a tool that tries to assess the next power of a number for a variety of applications, including games and UI animations. This method provides a mathematical way to determine the next stepping point in such cases when working with perfect squares. # Requirements: The function must: 1. Correctly identify whether the input is a perfect square. 2. Calculate and return the next perfect square if the input is valid. 3. Handle edge cases such as zero and non-perfect squares gracefully. # Additional Notes: * The function should avoid using built-in mathematical functions other than basic arithmetic operations to ensure comprehension of the fundamental concepts.","solution":"def find_next_square(sq: int) -> int: Finds the next perfect square greater than a given input \'sq\'. If \'sq\' is not a perfect square, returns -1. Args: sq (int): A non-negative integer. Returns: int: The next perfect square if \'sq\' is a perfect square, otherwise -1. if sq < 0: return -1 root = int(sq**0.5) if root * root == sq: next_square = (root + 1) * (root + 1) return next_square else: return -1"},{"question":"# Rabin-Karp Algorithm Enhancement You are given a text and a pattern, and you need to determine if the pattern exists within the text using the Rabin-Karp string matching algorithm. Typically, the Rabin-Karp algorithm employs a rolling hash technique for efficient substring comparison. However, to minimize collisions and handle larger string sizes securely, implement the algorithm using modular arithmetic with a prime modulus. Function Signature ```python def rabin_karp_mod(word: str, text: str) -> int: pass ``` Input * `word` - a non-empty string pattern that you are trying to search in the text (1 ≤ len(word) ≤ 10^6). * `text` - a non-empty string within which you are searching for the pattern (1 ≤ len(text) ≤ 10^6). Output * Return the starting index (0-based) of the first occurrence of the pattern `word` in the `text`. If the pattern does not exist in the `text`, return -1. Constraints * Use a prime modulus `MOD = 10^9 + 7`. * Use a base `BASE = 31` to calculate the hash values. * Ensure the time complexity in typical cases is O(n + m). Example ```python >>> rabin_karp_mod(\\"abcd\\", \\"baccabcd\\") 4 >>> rabin_karp_mod(\\"aaaa\\", \\"aa\\") -1 >>> rabin_karp_mod(\\"test\\", \\"this is a test text\\") 10 ``` # Description 1. Compute hash values using a prime modulus and base. 2. Utilize rolling hashing while adjusting constants for modular arithmetic. 3. Compare hashes and substrings only when hash values match. 4. Optimize using properties of moduli and bases to ensure scalability and collision resistance. Implement the Rabin-Karp algorithm as described, ensuring to handle collision reduction via modular arithmetic. Validate your implementation with various test cases to confirm correctness and efficiency.","solution":"def rabin_karp_mod(word: str, text: str) -> int: MOD = 10**9 + 7 BASE = 31 m = len(word) n = len(text) if m > n: return -1 # Function to calculate hash of a string def calculate_hash(s: str) -> int: h = 0 for char in s: h = (h * BASE + ord(char)) % MOD return h # Calculate hash value for the pattern word word_hash = calculate_hash(word) # Calculate hash value for the first window of text text_hash = calculate_hash(text[:m]) # Precompute powers of BASE modulo MOD base_powers = [1] * (m + 1) for i in range(1, m + 1): base_powers[i] = (base_powers[i - 1] * BASE) % MOD # Rolling hash and comparison for i in range(n - m + 1): if text_hash == word_hash: if text[i:i + m] == word: return i if i < n - m: text_hash = (text_hash - ord(text[i]) * base_powers[m - 1]) % MOD text_hash = (text_hash * BASE + ord(text[i + m])) % MOD text_hash = (text_hash + MOD) % MOD # Adjust if negative return -1"},{"question":"You are provided with an implementation of Bogo Sort, an intentionally inefficient sorting algorithm used primarily for educational purposes. Your task is to implement a function `find_bogo_sort_stats` that takes an array of integers as input and returns two key statistics about the Bogo Sort process: 1. The number of iterations it took to sort the array. 2. The final sorted array. # Function Signature ```python def find_bogo_sort_stats(arr: List[int], simulation: bool = False) -> Tuple[int, List[int]]: pass ``` # Input - `arr`: A list of integers that needs to be sorted using Bogo Sort. - `simulation`: A boolean flag (default is `False`). If set to `True`, print the array at each iteration. # Output - A tuple consisting of: - An integer representing the number of iterations it took for the array to get sorted. - A list representing the final sorted array. # Constraints - Assume the array will have at most 7 elements due to the inefficiency of the Bogo Sort algorithm. # Example ```python # Test Case arr = [3, 2, 1] result = find_bogo_sort_stats(arr) # Expected: (Some positive integer, [1, 2, 3]) arr = [1, 2, 3] result = find_bogo_sort_stats(arr, simulation=True) # Expected: (0, [1, 2, 3]) ``` # Notes - The number of iterations can vary due to the random nature of the shuffling process. - Ensure your solution randomizes and checks for sorted order at each iteration.","solution":"import random from typing import List, Tuple def find_bogo_sort_stats(arr: List[int], simulation: bool = False) -> Tuple[int, List[int]]: def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) iterations = 0 while not is_sorted(arr): if simulation: print(f\\"Iteration {iterations}: {arr}\\") random.shuffle(arr) iterations += 1 return iterations, arr"},{"question":"# **Range Summarization** Given a sorted list of unique integers, write a function to summarize the list into its continuous ranges. A range is defined as a sequence of consecutive numbers. Single numbers not part of any range should be listed as themselves. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input - `array`: A sorted list of unique integers. (0 ≤ len(array) ≤ 10^4) Output - A list of strings representing continuous ranges. For a single number `x`, it should be \\"x\\". For a range from `a` to `b`, it should be \\"a-b\\". Example ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([0, 2, 3, 4, 8, 9]) # Output: [\\"0\\", \\"2-4\\", \\"8-9\\"] summarize_ranges([1, 3, 5, 7]) # Output: [\\"1\\", \\"3\\", \\"5\\", \\"7\\"] ``` Constraints - You must handle edge cases where the input list is empty. - Your solution should be efficient, ideally with a time complexity of O(n). Scenario This function could be applied in scenarios like summarizing intervals in time series data, grouping continuous runs in numerical datasets, and simplifying output in reporting tools.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Given a sorted list of unique integers, summarize the list into its continuous ranges. if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Scenario You are working on a problem that requires identifying numbers within a specific range where each digit raised to the power of its position and summed equals the number itself. These numbers are often referred to as digit power sum numbers or \\"Eureka\\" numbers. # Problem Write a function `find_eureka_numbers()` that takes two integers: `start` and `end`, which represent an inclusive range of numbers. The function should return a list of integers within this range that satisfy the Eureka number property. # Input: * `start` - an integer representing the starting number of the range (inclusive) * `end` - an integer representing the ending number of the range (inclusive) # Output: * A list of integers within the range `[start, end]` that satisfy the Eureka number property. # Constraints: * The range will include positive integers. (1 ≤ start ≤ end ≤ 1,000,000) * The output list might be empty if no such numbers are found within the range. # Examples: Example 1: ```python find_eureka_numbers(1, 10) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Example 2: ```python find_eureka_numbers(1, 100) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Implementation Guidelines: * Your implementation should efficiently handle the range provided with attention to performance. * Ensure you handle any edge cases. * Consider optimizations for large ranges. # Helper Example: Here\'s an example of how the number 89 satisfies the property: * Digits in 89: [8, 9] * Calculation: ( 8^1 + 9^2 = 8 + 81 = 89 ) * Hence, 89 is included in the output.","solution":"def find_eureka_numbers(start, end): Returns a list of \\"Eureka\\" numbers within the range [start, end] inclusive. A Eureka number is a number that can be represented as the sum of its digits raised to their respective positions. eureka_numbers = [] for num in range(start, end + 1): if is_eureka_number(num): eureka_numbers.append(num) return eureka_numbers def is_eureka_number(num): Helper function to check if a number is a Eureka number. digits = [int(d) for d in str(num)] sum_digits = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return sum_digits == num"},{"question":"Implement Dijkstra\'s Algorithm with Priority Queue Optimization Scenario You are tasked with implementing an optimized version of Dijkstra\'s algorithm using a priority queue to find the shortest paths from a given source vertex to all other vertices in a weighted graph. This will help you handle larger graphs more efficiently. Task Write a function `dijkstra_optimized()` that takes an adjacency list representation of a graph and a source vertex. The function should return a list containing the shortest distance from the source vertex to every other vertex. Function Signature ```python def dijkstra_optimized(graph: List[List[Tuple[int, int]]], src: int) -> List[int]: ``` Input - `graph`: A list of lists where `graph[u]` contains tuples `(v, w)` representing an edge from vertex `u` to vertex `v` with weight `w`. - `src`: An integer representing the source vertex. Output - A list of integers where the element at index `i` represents the shortest distance from the source vertex to vertex `i`. Constraints - All edge weights are non-negative. - The number of vertices `V` is between 1 and 1000. - The number of edges `E` is between 1 and 10000. Example ```python graph = [ [(1, 2), (2, 4)], # Node 0: connected to node 1 (weight 2) and node 2 (weight 4) [(2, 1)], # Node 1: connected to node 2 (weight 1) [(3, 3)], # Node 2: connected to node 3 (weight 3) [] # Node 3: no outgoing edges ] src = 0 print(dijkstra_optimized(graph, src)) # Output: [0, 2, 3, 6] ``` # Notes - Use a priority queue to optimize the vertex selection process. - Handle graphs with different structures and verify that the algorithm correctly computes the shortest paths.","solution":"import heapq from typing import List, Tuple def dijkstra_optimized(graph: List[List[Tuple[int, int]]], src: int) -> List[int]: V = len(graph) distances = [float(\'inf\')] * V distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Graph Pathfinding Challenge Given the functions used to find paths in a graph, your task is to implement a function that not only finds paths, but also ensures the paths found are minimal in some cost metric. You need to design a function using the following signature: ```python def find_min_cost_path(graph, costs, start, end): Finds the path between start and end nodes of a graph such that the cost is minimized. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. costs (dict): A dictionary where keys are tuples representing edges and values are cost associated with each edge. start (str): The starting node of the path. end (str): The target node of the path. Returns: list: A list representing the path from start to end with minimal cost. If no path exists, returns None. ``` Input and Output Formats: * **Input**: - `graph`: A dictionary where the keys are node names and the values are lists of adjacent nodes. - `costs`: A dictionary where each key is a tuple representing an edge (start, end) and the value is the cost associated with that edge. - `start`: A string representing the starting node. - `end`: A string representing the target node. * **Output**: - A list representing the path from the start to end nodes with the minimal cost, or `None` if there is no such path. Constraints: * Nodes and edge costs are non-negative. * The graph can contain cycles. * The costs dictionary is guaranteed to have a cost entry for every edge in the graph. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } costs = { (\'A\', \'B\'): 1, (\'A\', \'C\'): 4, (\'B\', \'C\'): 2, (\'B\', \'D\'): 5, (\'C\', \'D\'): 1 } # The most cost-effective path from A to D is A -> B -> C -> D with a cost of 1 + 2 + 1 = 4 find_min_cost_path(graph, costs, \'A\', \'D\') # should return [\'A\', \'B\', \'C\', \'D\'] ``` Note that it is essential to efficiently handle edge cases like non-existent nodes and cyclic paths. **Evaluation Criteria**: * Correctness: The solution needs to find the minimal cost path correctly. * Efficiency: It should handle large graphs within reasonable time and space limits. * Edge Case Handling: Proper handling of scenarios like isolated nodes, cycles, and non-reachable target nodes.","solution":"import heapq def find_min_cost_path(graph, costs, start, end): Finds the path between start and end nodes of a graph such that the cost is minimized. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. costs (dict): A dictionary where keys are tuples representing edges and values are cost associated with each edge. start (str): The starting node of the path. end (str): The target node of the path. Returns: list: A list representing the path from start to end with minimal cost. If no path exists, returns None. # Priority queue to hold the paths, prioritized by their current path cost pq = [(0, start, [start])] visited = set() while pq: current_cost, current_node, path = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) if current_node == end: return path for neighbor in graph.get(current_node, []): if neighbor not in visited: new_cost = current_cost + costs.get((current_node, neighbor), float(\'inf\')) heapq.heappush(pq, (new_cost, neighbor, path + [neighbor])) return None"},{"question":"Question: Cycle Detection in a Directed Graph # Objective Write a function to determine whether a given directed graph contains a cycle. # Input - A dictionary representing the directed graph. Each key-value pair represents a vertex and its list of adjacent vertices (the outgoing edges). # Output - A boolean value: `True` if the graph contains a cycle, `False` otherwise. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], # Cycle here: E -> B -> D -> E \'F\': [] } print(contains_cycle(graph)) # Output: True ``` # Constraints - The graph is a directed graph. - The graph may have zero or more vertices. - Vertices are represented as strings. - The graph may contain vertices with no outgoing edges. - There will be no parallel edges between two vertices. # Tips 1. Utilize a depth-first search approach. 2. Track the state of each vertex using a state dictionary (e.g., WHITE, GRAY, BLACK) to determine cycle presence. 3. Pay attention to edge cases such as self-loops and disconnected components. Implement the function `contains_cycle(graph)`: ```python from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if traversal_states[neighbor] != TraversalState.BLACK: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False def contains_cycle(graph): traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False ``` Write the function and test it with the example provided and additional test cases to ensure accuracy.","solution":"from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if traversal_states[neighbor] != TraversalState.BLACK: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False def contains_cycle(graph): traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"You are given a list of integers that you need to sort using Shell Sort. Implement the function `shell_sort_custom_gap` that takes an array of integers and a custom list of gap values (integers) as its parameters. The function should sort the array based on the provided gap sequence. If the provided gap sequence is invalid or does not end with \'1\', return an empty array. # Function Signature ```python def shell_sort_custom_gap(arr, gaps): pass ``` # Input 1. `arr`: A list of integers to be sorted (0 ≤ len(arr) ≤ 1000) 2. `gaps`: A sorted list of integers (`[g1, g2, ..., 1]`, `g1 > g2 > ... > 1`) indicating the gap sequence # Output A sorted list of integers if the gap sequence is valid. An empty list if the gap sequence is invalid (i.e., if the sequence does not end with \'1\' or the sequence is not in strictly decreasing order). # Constraints - Elements in the list `arr` are in the range `-10^4` to `10^4`. - The gap sequence must end with a \'1\'. # Example ```python # Example 1 arr = [23, 12, 1, 8, 34, 56, 72, 19, 5] gaps = [5, 3, 1] print(shell_sort_custom_gap(arr, gaps)) # Output: [1, 5, 8, 12, 19, 23, 34, 56, 72] # Example 2 arr = [23, 12, 1, 8, 34, 56, 72, 19, 5] gaps = [4, 2, 1] print(shell_sort_custom_gap(arr, gaps)) # Output: [1, 5, 8, 12, 19, 23, 34, 56, 72] # Example 3 arr = [23, 12, 1, 8, 34, 56, 72, 19, 5] gaps = [4, 2] print(shell_sort_custom_gap(arr, gaps)) # Output: [] ``` # Notes - The function must not modify the input array `arr`. - The provided gap sequence must be validated before performing the sort. - Use the shell sort algorithm as a basis but adapt it to use the provided gap sequence.","solution":"def shell_sort_custom_gap(arr, gaps): Sort the given array using Shell Sort with a custom gaps sequence. If the gaps sequence is invalid (not strictly decreasing ending with 1), return an empty array. # Validate the gaps sequence if not gaps or gaps[-1] != 1 or any(gaps[i] <= gaps[i+1] for i in range(len(gaps)-1)): return [] n = len(arr) arr = arr.copy() # Start with the largest gap and go down to 1 (gap = 1 implies using insertion sort) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Coding Assessment: Pythagorean Problem As an aspiring computer scientist, you are tasked with implementing a function based on the Pythagorean theorem to compute the length of the unknown side of a right-angled triangle given the lengths of the other two sides. Function Signature ```python def find_unknown_side(opposite: str, adjacent: str, hypotenuse: str) -> str: ``` Input and Output * **Inputs:** - `opposite` (str): Length of the opposite side or \\"?\\" if unknown. - `adjacent` (str): Length of the adjacent side or \\"?\\" if unknown. - `hypotenuse` (str): Length of the hypotenuse or \\"?\\" if unknown. * **Output:** - (str): A well-formatted string indicating the length of the unknown side or a message if all sides are known. Constraints * Only one of the inputs will be \\"?\\". * The provided lengths will be non-negative real numbers. * Ensure to handle invalid inputs gracefully with an informative error message. Example Scenario Given the lengths: * `opposite = \\"?\\"` * `adjacent = \\"3\\"` * `hypotenuse = \\"5\\"` The function should return: * `Opposite = 4.0` Consider edge cases such as perfect square results and invalid inputs that might not form a right-angled triangle. Performance Requirements * Optimize the function to run in constant time, O(1). * Minimize memory usage. Implement the `find_unknown_side` function adhering to the requirements and ensuring robust error handling for invalid inputs.","solution":"import math def find_unknown_side(opposite: str, adjacent: str, hypotenuse: str) -> str: Computes the length of the unknown side of a right-angled triangle using the Pythagorean theorem. Exactly one of the inputs will be \\"?\\". Args: - opposite (str): Length of the opposite side or \\"?\\" if unknown. - adjacent (str): Length of the adjacent side or \\"?\\" if unknown. - hypotenuse (str): Length of the hypotenuse or \\"?\\" if unknown. Returns: - str: A well-formatted string indicating the length of the unknown side or a message if all sides are known. try: if opposite == \\"?\\": a = float(adjacent) c = float(hypotenuse) if c <= a: return \\"Invalid input: hypotenuse must be greater than the adjacent side.\\" b = math.sqrt(c**2 - a**2) return f\\"Opposite = {b:.1f}\\" elif adjacent == \\"?\\": b = float(opposite) c = float(hypotenuse) if c <= b: return \\"Invalid input: hypotenuse must be greater than the opposite side.\\" a = math.sqrt(c**2 - b**2) return f\\"Adjacent = {a:.1f}\\" elif hypotenuse == \\"?\\": a = float(adjacent) b = float(opposite) c = math.sqrt(a**2 + b**2) return f\\"Hypotenuse = {c:.1f}\\" else: return \\"All sides are known.\\" except ValueError as ve: return f\\"Invalid input: {ve}\\""},{"question":"# Question: Unique Character String You are given a string `s` consisting of lowercase and/or uppercase alphabets. Your task is to write a function `remove_duplicates(s: str) -> str` that removes all recurring characters from the input string and returns a new string that contains only the first occurrences of each character in the order of their first appearance. Input - A single parameter `s` which is a string (1 <= len(s) <= 1000). Output - A string with all recurring characters removed. # Constraints - The function should maintain the order of first occurrences of the characters. - The function should be optimized for both time and space. Example **Example 1:** ```python Input: \\"hello\\" Output: \\"helo\\" ``` **Example 2:** ```python Input: \\"programming\\" Output: \\"proaming\\" ``` **Example 3:** ```python Input: \\"Python\\" Output: \\"Python\\" ``` **Additional Notes:** - On encountering an empty string input return an empty string. - Handle case-insensitive unique preservation. # Testing Ensure your function passes the following test cases: 1. `remove_duplicates(\\"banana\\")` should return `\\"ban\\"`. 2. `remove_duplicates(\\"abracadabra\\")` should return `\\"abrcd\\"`. 3. `remove_duplicates(\\"a\\")` should return `\\"a\\"`. 4. `remove_duplicates(\\"aAaAa\\")` should return `\\"aA\\"`. Implement `remove_duplicates(s: str) -> str` function to solve the problem.","solution":"def remove_duplicates(s: str) -> str: Removes duplicates from a given string s. Preserves the order of first occurrences of the characters. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given four functions related to converting integers to byte arrays and vice versa, both in big-endian and little-endian formats. Your task is to extend these functionalities to include the conversion of floating-point numbers (of double precision) to byte arrays and back. Write the following four functions: 1. `float_to_bytes_big_endian(num)` 2. `float_to_bytes_little_endian(num)` 3. `bytes_big_endian_to_float(bytestr)` 4. `bytes_little_endian_to_float(bytestr)` # Input/Output Specifications 1. **float_to_bytes_big_endian(num)** * Input: A float `num`. * Output: A byte array representing the float in big-endian format. 2. **float_to_bytes_little_endian(num)** * Input: A float `num`. * Output: A byte array representing the float in little-endian format. 3. **bytes_big_endian_to_float(bytestr)** * Input: A byte array `bytestr` in big-endian format. * Output: A float represented by the byte array. 4. **bytes_little_endian_to_float(bytestr)** * Input: A byte array `bytestr` in little-endian format. * Output: A float represented by the byte array. # Constraints * For this task, you can assume the floating-point numbers are represented using IEEE 754 double precision (64 bits). * The length of the byte array should always be 8. * Valid floats and byte arrays are provided as input (`bytestr` for float-to-byte functions and `float` for byte-to-float functions). # Example ```python # Big-endian conversions >>> float_to_bytes_big_endian(123.456) b\'@^xdd/lMxc7xff\' >>> bytes_big_endian_to_float(b\'@^xdd/lMxc7xff\') 123.456 # Little-endian conversions >>> float_to_bytes_little_endian(123.456) b\'xffxc7Mlfxde@\' >>> bytes_little_endian_to_float(b\'xffxc7Mlfxde@\') 123.456 ``` > Note: Use the `struct` module in Python for packing and unpacking the floats to bytes and vice versa. This can help you handle the complexities of floating-point representation. # Implementation Details To achieve this, you may find Python\'s `struct` module helpful, particularly `struct.pack` and `struct.unpack`. Here\'s a brief hint on how to use it: ```python import struct # Packing float to bytes (big endian) packed_bytes = struct.pack(\'>d\', 123.456) # Unpacking bytes to float (big endian) unpacked_float = struct.unpack(\'>d\', packed_bytes)[0] # Similarly, you can use \'<d\' for little endian conversions ``` Implement the functions respecting the endianness indicated and ensure that you handle the conversion both ways accurately.","solution":"import struct def float_to_bytes_big_endian(num): Convert a float to a byte array in big-endian format. return struct.pack(\'>d\', num) def float_to_bytes_little_endian(num): Convert a float to a byte array in little-endian format. return struct.pack(\'<d\', num) def bytes_big_endian_to_float(bytestr): Convert a byte array in big-endian format to a float. return struct.unpack(\'>d\', bytestr)[0] def bytes_little_endian_to_float(bytestr): Convert a byte array in little-endian format to a float. return struct.unpack(\'<d\', bytestr)[0]"},{"question":"You are given an array of integers. Your task is to write a function that sorts this array using the Stooge Sort algorithm. Although Stooge Sort is not practical for large datasets, this exercise will help you understand recursive problem-solving techniques. # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> List[int]: ``` # Input - `arr` (List[int]): An array of integers that you need to sort. - `l` (int): The starting index of the array or subarray to sort. - `h` (int): The ending index of the array or subarray to sort. # Output - Returns the sorted array. # Constraints - 0 <= l <= h < len(arr) - The input array `arr` can contain both negative and positive integers. # Example ```python arr = [5, 4, 3, 2, 1] sorted_arr = stoogesort(arr, 0, len(arr)-1) print(sorted_arr) # Output: [1, 2, 3, 4, 5] ``` # Notes - The main purpose is to recursively sort the array. - You must not use any built-in sorting functions or libraries. - Focus on recursive implementation and ensure the base and recursive cases are correctly handled. # Testing Ensure your code handles: - Arrays with a single element. - Arrays with multiple elements in descending order. - Arrays with multiple elements in random order. - Arrays containing duplicate elements. - Arrays containing both positive and negative values.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> List[int]: if l >= h: return arr # If first element is smaller than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the subarray if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the initial 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the final 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the initial 2/3 of the array again stoogesort(arr, l, h - t) return arr"},{"question":"# Finding the Single Number Objective Given an array of integers where every element appears twice except for one, write a function to find the unique single number that doesn\'t appear twice. Function Signature ```python def single_number(nums: List[int]) -> int: ``` Input * A list of integers `nums` where each integer appears twice except for one. Output * Return the single integer that appears only once. If the array is empty or does not follow the constraint, return 0. Constraints * Your algorithm should have a linear runtime complexity. * You should not use extra memory structures like lists or sets. Example ```python # Example 1 single_number([2, 2, 1]) # Output: 1 # Example 2 single_number([4, 1, 2, 1, 2]) # Output: 4 # Example 3 single_number([1]) # Output: 1 # Example 4 single_number([]) # Output: 0 ``` Additional Notes Ensure the function handles special cases such as an empty list efficiently. Use bitwise operations to achieve the desired linear time complexity and constant space complexity.","solution":"def single_number(nums): Returns the single number in the list where every element appears twice except for one. if not nums: return 0 unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Question: Implement and Analyze an Efficient Sorting Algorithm Scenario Given the drawbacks of Bogo Sort you\'ve analyzed, it is clear that another more efficient algorithm is needed for practical sorting. # Task Implement the Quick Sort algorithm to sort an array of integers. Quick Sort is a divide-and-conquer algorithm that efficiently sorts arrays by partitioning them into smaller subarrays. The key step in Quick Sort is choosing a pivot and rearranging the elements such that elements less than the pivot come before it and elements greater than the pivot come after it, and then recursively applying the same logic to the subarrays. 1. **Function Signature**: ```python def quick_sort(arr): # your code here ``` 2. **Input Format**: * An array `arr` of integers, where 1 <= len(arr) <= 10^5. 3. **Output Format**: * Return a new array that is sorted in ascending order. 4. **Constraints**: * The implementation should aim for average time complexity of O(n log n) and a worst-case time complexity of O(n^2). * Ensure you handle edge cases such as already sorted arrays and arrays with duplicate values. 5. **Performance Requirements**: * The algorithm should be efficient to handle inputs where len(arr) can go up to 100,000. # Example ```python assert quick_sort([3,6,8,10,1,2,1]) == [1,1,2,3,6,8,10] assert quick_sort([1,2,3,4,5,6,7]) == [1,2,3,4,5,6,7] # In case of an already sorted array assert quick_sort([]) == [] # edge case: empty array assert quick_sort([5,5,5,5]) == [5, 5, 5, 5] # case with duplicate elements ```","solution":"def quick_sort(arr): Sorts an array of integers using the Quick Sort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] less = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] return quick_sort(less) + equal + quick_sort(greater)"},{"question":"# Question: Find the nth Digit in a Sequence of Natural Numbers You are tasked with finding the nth digit in the sequence formed by concatenating all natural numbers sequentially (i.e., \\"123456789101112...\\"). **Function Signature**: ```python def find_nth_digit(n: int) -> int: ``` **Input**: - An integer `n` (1 <= n <= 2^31 - 1). **Output**: - An integer representing the nth digit in the concatenated sequence. **Example**: ```python find_nth_digit(11) # returns 0 because the sequence is \\"12345678910\\" and the 11th digit is \'0\' find_nth_digit(15) # returns 2 because the sequence is \\"123456789101112\\" and the 15th digit is \'2\' ``` **Constraints**: - You must solve this problem in O(log n) time complexity. - Pay attention to integer arithmetic and ensure there are no off-by-one errors. **Performance Requirements**: - Your solution should efficiently handle large values of `n` up to the maximum constraint. # Scenario: Imagine you are creating a game where each level, represented by a natural number, is identified by a specific digit. This function helps the game determine which digit to display for any given level, ensuring a unique and accurate experience for players as they progress. **Edge Cases to Consider**: - What if `n` is small (like 1 or 2)? - What if `n` is exactly at a transition point (like moving from single to double digits: 9 to 10)? - What if `n` is very large and involves several digit-length transitions? Given these details, write the implementation for `find_nth_digit` function ensuring it meets the expected performance and accurately identifies the digit.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in the infinite sequence of natural numbers concatenated together. :param n: The position of the digit to find :return: The nth digit as an integer # Initial variables for number length, counts & start of the length range length = 1 count = 9 start = 1 # Determine the range where the nth digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number where the nth digit is located start += (n - 1) // length # Find the digit in the final located number digit_index = (n - 1) % length return int(str(start)[digit_index])"},{"question":"# Cocktail Shaker Sort Implementation and Improvement You are tasked with writing a function to sort a given list of integers using the Cocktail Shaker Sort algorithm. Additionally, you should modify the algorithm to keep track of the last swap position to potentially reduce the number of comparisons in subsequent passes. Function Signature: ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input: * `arr` (List[int]): A list of integers to be sorted. Output: * List[int]: A sorted list of integers. Constraints: * The length of the list `n` will be in the range [0, 10^5]. * Integers in the list will be in the range [-10^9, 10^9]. Requirements: 1. Implement the Cocktail Shaker Sort algorithm as described above with the optimization of tracking the last swap position. 2. Ensure the algorithm is stable and in-place. 3. Your implementation should efficiently handle edge cases and minimize unnecessary comparisons. Example: ```python assert optimized_cocktail_shaker_sort([3, 1, 2, 4]) == [1, 2, 3, 4] assert optimized_cocktail_shaker_sort([]) == [] assert optimized_cocktail_shaker_sort([5, -1, 4, 2, -3, 0]) == [-3, -1, 0, 2, 4, 5] ``` Note: Make sure to handle edge cases, such as empty arrays and arrays that are already sorted.","solution":"def optimized_cocktail_shaker_sort(arr): Sorts the given list of integers using the optimized Cocktail Shaker Sort algorithm. Args: arr (list of int): A list of integers to sort. Returns: list of int: The sorted list. if not arr: return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: # Reset the swapped flag on entering the loop, because it might be true from a previous iteration. swapped = False # Traverse the list from left to right similar to Bubble Sort last_swap_position = start for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True last_swap_position = i # If nothing moved, then the list is sorted. if not swapped: break # Otherwise, reset the swap flag so that it could be used in the next stage swapped = False # Move the end point back to the last position where a swap occurred end = last_swap_position # Traverse the list from right to left doing the same comparison as in the previous stage for i in range(end, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True last_swap_position = i # Increment the starting point after the completion of a pass start = last_swap_position + 1 return arr"},{"question":"# Context In a grid of size R x C filled with water represented by 0s, we can turn water into land (represented by 1) by placing land cells in specific positions. The task is to count the number of separate islands after each placement of land. # Task Write a function `count_islands(R: int, C: int, positions: List[Tuple[int, int]]) -> List[int]` that takes the number of rows `R`, the number of columns `C` of the grid, and a list of positions (`positions`) to turn water into land in the grid. The function should return a list with the count of islands after each addition of land. # Constraints * `1 <= R, C <= 10^3` * `1 <= len(positions) <= 10^4` * Positions are unique and within the bounds of the grid. # Input * `R`: an integer representing the number of rows of the grid. * `C`: an integer representing the number of columns in the grid. * `positions`: a list of tuples, where each tuple contains two integers indicating the row and column index where land is to be added. # Output * A list of integers, where each integer represents the number of islands in the grid after each addition of land. # Example ```python def count_islands(R: int, C: int, positions: List[Tuple[int, int]]) -> List[int]: # Your implementation here # Example usage R = 3 C = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(count_islands(R, C, positions)) ``` Expected Output ``` [1, 1, 2, 3] ``` # Explanation Initial grid: ``` 0 0 0 0 0 0 0 0 0 ``` - After `addLand(0, 0)`: ``` 1 0 0 0 0 0 Number of islands = 1 0 0 0 ``` - After `addLand(0, 1)`: ``` 1 1 0 0 0 0 Number of islands = 1 0 0 0 ``` - After `addLand(1, 2)`: ``` 1 1 0 0 0 1 Number of islands = 2 0 0 0 ``` - After `addLand(2, 1)`: ``` 1 1 0 0 0 1 Number of islands = 3 0 1 0 ``` # Requirements * Ensure your function is optimized for large grids and large lists of positions. * Handle edge cases such as land placement on an already filled position gracefully.","solution":"from typing import List, Tuple def count_islands(R: int, C: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x, parent): if parent[x] != x: parent[x] = find(parent[x], parent) return parent[x] def union(x, y, parent, rank): rootX = find(x, parent) rootY = find(y, parent) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 parent = {} rank = {} directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] grid = [[0] * C for _ in range(R)] island_count = 0 result = [] for r, c in positions: if grid[r][c] == 1: result.append(island_count) continue grid[r][c] = 1 index = r * C + c parent[index] = index rank[index] = 0 island_count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == 1: neighbor = nr * C + nc if find(index, parent) != find(neighbor, parent): union(index, neighbor, parent, rank) island_count -= 1 result.append(island_count) return result"},{"question":"Given a linked list, write a function `first_cyclic_node` to find the first node of a cycle in the linked list, if such a cycle exists. If there\'s no cycle, the function should return `None`. # Function Signature ```python def first_cyclic_node(head: \'Node\') -> \'Node\': pass ``` # Input and Output * **Input**: * `head`: The head node of the singly linked list. * **Output**: * Returns the starting node of the cycle if one exists, otherwise returns `None`. # Constraints * The linked list can have zero or more nodes. * The nodes contain integer values only. * You need to implement the function without using extra space proportional to the input size (O(1) space complexity). # Example ```python class Node: def __init__(self, val): self.val = val self.next = None def first_cyclic_node(head: Node) -> Node: # Implement the function here # Example Usage # List: A -> B -> C -> D -> E -> C (Cycle starts at C) head = Node(\'A\') head.next = Node(\'B\') cyclic_node = Node(\'C\') head.next.next = cyclic_node cyclic_node.next = Node(\'D\') cyclic_node.next.next = Node(\'E\') cyclic_node.next.next.next = cyclic_node assert first_cyclic_node(head).val == \'C\' ``` # Unit Test Write a unittest to verify the implementation of your function: ```python import unittest class TestFirstCyclicNode(unittest.TestCase): def test_first_cyclic_node(self): # create linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node self.assertEqual(\'C\', first_cyclic_node(head).val) def test_no_cycle(self): # create linked list => 1 -> 2 -> 3 head = Node(1) head.next = Node(2) head.next.next = Node(3) self.assertIsNone(first_cyclic_node(head)) def test_single_node_no_cycle(self): # create linked list => 1 head = Node(1) self.assertIsNone(first_cyclic_node(head)) def test_single_node_with_cycle(self): # create linked list => 1 -> 1 (self-loop) head = Node(1) head.next = head self.assertEqual(1, first_cyclic_node(head).val) if __name__ == \'__main__\': unittest.main() ``` # Notes * Consider edge cases like empty lists, single-element lists, and long lists with cycles. * Ensure the implementation has an O(n) time complexity and O(1) space complexity. * Comment your code properly to explain the logic used for detecting cycles and identifying the starting node of the cycle.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def first_cyclic_node(head: Node) -> Node: Detects the first node in a cycle in the linked list. Uses Floyd\'s Tortoise and Hare algorithm to detect the cycle. Parameters: head (Node): The head of the singly linked list. Returns: Node: The starting node of the cycle if a cycle exists, otherwise None. if not head or not head.next: return None slow = head fast = head # Detect the cycle using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find cycle start slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Maximum Sum Subarray Context Suppose you are working on analyzing stock price changes over a series of days. You are given a list of daily changes in stock value. You need to determine the maximum profit that can be achieved by buying and selling on the best two days such that the buy comes before the sell. Task Write a function `max_profit` which takes a list of integers as input and returns the maximum sum of a contiguous subarray (maximum profit). Function Signature ```python def max_profit(price_changes: List[int]) -> int: ``` Input * `price_changes` : A list of integers representing daily changes in stock value. The list can be of any length, including 0. Output * Returns an integer representing the maximum profit. If there are no profitable days, return `0`. Constraints * Consider all provided edge cases including: * An empty list should return `0`. * Lists with negative and positive numbers. * Ensure your solution runs in linear time and constant space. Example ```python # Example 1 print(max_profit([-2, 3, 8, -1, 4])) # Output: 14 # Example 2 print(max_profit([-1, 1, 0])) # Output: 1 # Example 3 print(max_profit([-1, -3, -4])) # Output: 0 # Example 4 print(max_profit([-2, 3, 8, -12, 8, 4])) # Output: 12 # Example 5 print(max_profit([5, -3, 5, -3, 5])) # Output: 9 ``` Notes * Your function should leverage Kadane\'s Algorithm principles to ensure an optimal linear time solution. * Comprehensive handling of all edge cases is critical to pass all test cases and ensure the robustness of your solution.","solution":"def max_profit(price_changes): Returns the maximum profit that can be achieved from the given list of daily changes in stock price. This is equivalent to finding the maximum sum of a contiguous subarray in the list. if not price_changes: return 0 max_current = max_global = price_changes[0] for value in price_changes[1:]: max_current = max(value, max_current + value) if max_current > max_global: max_global = max_current return max(max_global, 0)"},{"question":"You are given a string, and your task is to find the length of the longest substring without repeating characters. Additionally, you need to return the substring itself. This problem tests your understanding of string manipulation, the sliding window technique, hash maps, and efficient algorithms with optimal space-time complexity. # Input and Output Formats - **Input**: A single string `s` (1 <= len(s) <= 10^5) consisting of English letters, digits, symbols, and spaces. - **Output**: A tuple `(length, substring)` where `length` is an integer representing the length of the longest substring without repeating characters, and `substring` is the longest substring itself. # Constraints - The string may contain any printable ASCII characters. - The longest substring should be the first one encountered in the case of multiple substrings with the same maximum length. # Example - Input: `\\"abcabcbb\\"` - Output: `(3, \\"abc\\")` - Input: `\\"bbbbb\\"` - Output: `(1, \\"b\\")` - Input: `\\"pwwkew\\"` - Output: `(3, \\"wke\\")` # Instructions 1. Write a function `find_longest_unique_substring(s)` that: - Takes a string `s` as input. - Returns a tuple containing the length of the longest substring without repeating characters and the substring itself. 2. Ensure your code handles edge cases appropriately, such as empty strings or strings with all unique characters. 3. Optimize for both time and space complexity to handle large input sizes efficiently. # Function Signature ```python def find_longest_unique_substring(s: str) -> (int, str): # Implementation here pass ``` # Implementation Tips - Use a sliding window approach with two pointers to maintain the current window of unique characters. - Utilize a hash map to track the last index of each character encountered. - Adjust the start pointer to ensure the window always contains unique characters. - Keep track of the maximum length observed and update the result accordingly.","solution":"def find_longest_unique_substring(s: str) -> (int, str): Finds the length of the longest substring without repeating characters and the substring itself. Parameters: s (str): The input string Returns: Tuple: A tuple containing the length of the longest substring and the substring itself if not s: return (0, \\"\\") char_map = {} start = 0 max_length = 0 longest_substr = \\"\\" for end in range(len(s)): if s[end] in char_map: # Update start to max of the current start or the next index to the previous occurrence # to ensure the substring remains unique. start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_substr = s[start:end+1] return (max_length, longest_substr)"},{"question":"Reverse a String Using Multiple Approaches Given a string `s`, implement the following functions to reverse the string: 1. **recursive_reverse(s)**: Reverses the string using a recursive approach. 2. **iterative_reverse(s)**: Reverses the string using an iterative two-pointer technique. 3. **pythonic_reverse(s)**: Reverses the string using Python\'s `reversed` function. 4. **ultra_pythonic_reverse(s)**: Reverses the string using Python\'s slice notation. Your implementations should handle the following constraints: * The input string `s` can have a length of up to (10^6). * You can assume the input will always be a string, and no need to handle non-string inputs. * Consider edge cases where the string is empty or contains a single character. # Function Signatures ```python def recursive_reverse(s: str) -> str: # Your code here def iterative_reverse(s: str) -> str: # Your code here def pythonic_reverse(s: str) -> str: # Your code here def ultra_pythonic_reverse(s: str) -> str: # Your code here ``` # Input Format * A single string `s`. # Output Format * A string which is the reversed version of the input string. # Examples ```python assert recursive_reverse(\\"hello\\") == \\"olleh\\" assert iterative_reverse(\\"world\\") == \\"dlrow\\" assert pythonic_reverse(\\"openai\\") == \\"ianepo\\" assert ultra_pythonic_reverse(\\"gpt-3\\") == \\"3-tpg\\" ``` # Explanation 1. **recursive_reverse(\\"hello\\")**: Recursively divides the string and concatenates reversed halves. 2. **iterative_reverse(\\"world\\")**: Uses two pointer technique to swap characters until the middle of the string. 3. **pythonic_reverse(\\"openai\\")**: Uses Python\'s built-in `reversed` function to reverse the string. 4. **ultra_pythonic_reverse(\\"gpt-3\\")**: Uses Python\'s slice notation to reverse the string in a single line.","solution":"def recursive_reverse(s: str) -> str: Reverses the string using a recursive approach. if len(s) <= 1: return s return recursive_reverse(s[1:]) + s[0] def iterative_reverse(s: str) -> str: Reverses the string using an iterative two-pointer technique. s_list = list(s) left, right = 0, len(s) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left, right = left + 1, right - 1 return \'\'.join(s_list) def pythonic_reverse(s: str) -> str: Reverses the string using Python\'s reversed function. return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: Reverses the string using Python\'s slice notation. return s[::-1]"},{"question":"# Anagram Check in Custom Alphabet Set Scenario: You are tasked with writing a function to determine if two strings are anagrams. However, this time, the strings can contain any characters from a given custom alphabet set. You need to extend the previous approach to handle a dynamic set of characters and ensure the solution remains efficient. Challenge: Write a function `custom_anagram(s1, s2, alphabet)` that: 1. Takes two strings `s1` and `s2`. 2. Takes a string `alphabet` representing the custom set of allowed characters. 3. Returns `True` if `s1` is an anagram of `s2` based on the given alphabet set. Input: - `s1, s2`: Strings (can contain any characters within the given `alphabet`) - `alphabet`: String representing the allowed characters. Output: - Boolean: `True` if `s1` is an anagram of `s2`, `False` otherwise. Constraints: - The length of `s1` and `s2` allows up to 10^5 characters. - The `alphabet` can have up to 256 unique characters. - Consider character comparison to be case-sensitive. Example: ```python custom_anagram(\\"apple\\", \\"pleap\\", \\"abcdefghijklmnopqrstuvwxyz\\") -> True custom_anagram(\\"apple\\", \\"cherry\\", \\"abcdefghijklmnopqrstuvwxyz\\") -> False custom_anagram(\\"a1b2\\", \\"1a2b\\", \\"0123456789abcdefghijklmnopqrstuvwxyz\\") -> True ``` Function Signature: ```python def custom_anagram(s1: str, s2: str, alphabet: str) -> bool: ``` **Note**: Your solution should efficiently handle large strings and various character sets in the provided alphabet.","solution":"def custom_anagram(s1, s2, alphabet): Determines if two strings are anagrams based on the given custom alphabet. Args: s1 (str): The first string. s2 (str): The second string. alphabet (str): A string representing the custom set of allowed characters. Returns: bool: True if s1 is an anagram of s2 based on the given alphabet, False otherwise. if len(s1) != len(s2): return False # Initialize frequency counts for characters in the given alphabet char_frequency_s1 = {char: 0 for char in alphabet} char_frequency_s2 = {char: 0 for char in alphabet} # Count the frequency of each character in s1 and s2 for char in s1: if char in alphabet: char_frequency_s1[char] += 1 for char in s2: if char in alphabet: char_frequency_s2[char] += 1 # Compare both frequency dictionaries return char_frequency_s1 == char_frequency_s2"},{"question":"# Graph Traversal Challenge Background A group of friends are navigating through a network of cities. Each city is connected to other cities with roadways. They decide to create a system to explore all the cities starting from a specific city. They are interested in two strategies for exploration: Depth-First Search (DFS) and Breadth-First Search (BFS). You are tasked with implementing both strategies for them to demonstrate how they can traverse their network. Task Write two functions: 1. `dfs_traverse(graph, start)` 2. `bfs_traverse(graph, start)` Each function should take: * `graph`: A dictionary where keys are city names (strings) and values are lists of connected cities. * `start`: The city name (string) from which to start the traversal. Each function should return a set of all cities that can be visited starting from `start`. Specifications 1. **dfs_traverse(graph, start)** - Implements Depth-First Search using an iterative approach. - Returns a set of cities (nodes) visited. 2. **bfs_traverse(graph, start)** - Implements Breadth-First Search. - Returns a set of cities (nodes) visited. Constraints * The graph is guaranteed to be non-empty. * All city names are unique and valid strings. * The start city is guaranteed to be a key in the graph. Examples ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Expected Output print(dfs_traverse(graph, \'A\')) # {\'A\', \'B\', \'D\', \'E\', \'C\', \'F\'} print(bfs_traverse(graph, \'A\')) # {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` Additional Notes * Consider edge cases such as small graphs (single node) or graphs forming cycles. * Aim for efficient use of memory and ensure functions complete in a reasonable time for large graphs.","solution":"def dfs_traverse(graph, start): Implements the Depth-First Search (DFS) algorithm iteratively. Returns a set of all cities that can be visited starting from `start`. visited = set() stack = [start] while stack: city = stack.pop() if city not in visited: visited.add(city) # Add connected cities in the stack stack.extend(graph[city]) return visited def bfs_traverse(graph, start): Implements the Breadth-First Search (BFS) algorithm. Returns a set of all cities that can be visited starting from `start`. visited = set() queue = [start] while queue: city = queue.pop(0) if city not in visited: visited.add(city) # Add connected cities to the queue queue.extend(graph[city]) return visited"},{"question":"# Fenwick Tree - Cumulative Frequency Updates and Queries **Objective**: Implement a Fenwick Tree to efficiently handle frequency updates and prefix sum queries on a dataset. # Problem Statement: You are given an array `freq` where `freq[i]` denotes the frequency of the element at index `i`. Your task is to implement a Fenwick Tree that supports the following operations: 1. **Update**: Increase the frequency of a specific element. 2. **Prefix Sum Query**: Compute the sum of frequencies from the start of the array up to a given index. # Function Signatures: ```python class Fenwick_Tree: def __init__(self, freq: List[int]): # Initialize the Fenwick tree with the given frequency array pass def update(self, i: int, delta: int): # Increase the frequency of the element at index i by delta pass def query(self, i: int) -> int: # Get the prefix sum of frequencies up to index i pass ``` # Input - The initial frequency array `freq` containing integers. # Output - For `update` operation: No return value (in-place update). - For `query` operation: An integer, the prefix sum of frequencies up to index `i`. # Constraints: - 1 <= len(freq) <= 10^5 - -10^4 <= freq[i] <= 10^4 (initial frequencies and updates) # Example ```python # Initialize the frequency array freq = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] ft = Fenwick_Tree(freq) # Query the prefix sum up to index 5 print(ft.query(5)) # Output: 19 (3+2-1+6+5+4) # Update the frequency at index 3 ft.update(3, 4) # Query again the prefix sum up to index 5 print(ft.query(5)) # Output: 23 (3+2-1+10+5+4) ``` In the above example: - The `query(i)` function should return the sum of the array from the start index up to `i`. - The `update(i, delta)` function modifies the frequency at index `i` by adding `delta`. **Note**: Ensure your solution handles large arrays efficiently within the provided constraints.","solution":"class Fenwick_Tree: def __init__(self, freq): Initialize the Fenwick tree with the given frequency array self.n = len(freq) self.tree = [0] * (self.n + 1) for i, val in enumerate(freq): self.update(i, val) def update(self, i, delta): Increase the frequency of the element at index i by delta i += 1 # Fenwick Tree is 1-indexed while i <= self.n: self.tree[i] += delta i += i & -i def query(self, i): Get the prefix sum of frequencies up to index i i += 1 # Fenwick Tree is 1-indexed sum = 0 while i > 0: sum += self.tree[i] i -= i & -i return sum"},{"question":"Objective You are tasked with improving the given function `first_unique_char` by making it more efficient. The function should return the index of the first non-repeating character in the given string. If there is no such character, return -1. Detailed Specification **Function Signature:** ```python def first_unique_char(s: str) -> int: :param s: a string :return: The index of the first non-repeating character or -1 if no such character exists ``` **Example Usage:** ```python assert first_unique_char(\\"leetcode\\") == 0 assert first_unique_char(\\"loveleetcode\\") == 2 assert first_unique_char(\\"aabbcc\\") == -1 assert first_unique_char(\\"\\") == -1 ``` **Constraints:** * The string can contain only lowercase English letters. * The length of the string (len(s)) is between 0 and 10^5. Performance Requirements The solution should have a time complexity of O(n) and a space complexity of O(1) besides the input string size. Solution Approach You should use a two-pass algorithm: 1. First pass: Use a hash map to count the frequency of each character. 2. Second pass: Iterate through the string to find the first character with a frequency of 1. Scenario Imagine you\'re processing logs to find the first instance of a unique event identifier. Your algorithm must efficiently pinpoint the position of this unique identifier in a long sequence of events. **Edge Cases to Consider:** * When the string is empty. * When all characters in the string repeat. * When the unique character is at the start or end of the string.","solution":"def first_unique_char(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no non-repeating character exists, returns -1. from collections import Counter # Step 1: Count the frequency of each character in the string char_count = Counter(s) # Step 2: Find the first character with a count of 1 for i, char in enumerate(s): if char_count[char] == 1: return i # If no non-repeating character was found, return -1 return -1"},{"question":"# Function Implementation Question **Context**: You are tasked with writing a new feature for a banking software that verifies account numbers. An account number must adhere to specific length constraints to ensure proper format and avoid errors during transactions. **Problem Statement**: Write a function `validate_account_number(account_number: str) -> bool` that checks whether a given account number string meets the following criteria: - It should consist of only digits. - The total number of digits should fall within a specified range `[min_length, max_length]` inclusive. **Function Signature**: ```python def validate_account_number(account_number: str, min_length: int, max_length: int) -> bool: ``` **Inputs**: - `account_number` (str): The account number to validate, given as a string. - `min_length` (int): The minimum valid length for the account number. - `max_length` (int): The maximum valid length for the account number. **Output**: - Returns `True` if the `account_number` meets all validation criteria, otherwise `False`. **Constraints**: - The `account_number` string may contain leading zeros, which should be counted in the length. - `1 ≤ min_length ≤ max_length ≤ 100`. **Examples**: ```python assert validate_account_number(\\"12345678\\", 5, 10) == True assert validate_account_number(\\"1234567A\\", 5, 10) == False assert validate_account_number(\\"1234\\", 5, 10) == False assert validate_account_number(\\"12345678901234567890\\", 10, 20) == True ``` Ensure that your solution handles various edge cases, including inputs with leading zeros and bounds of the valid length range.","solution":"def validate_account_number(account_number: str, min_length: int, max_length: int) -> bool: Validates the account number based on the given length constraints. Args: account_number (str): The account number to validate. min_length (int): The minimum valid length for the account number. max_length (int): The maximum valid length for the account number. Returns: bool: True if the account number is valid, False otherwise. # Check if the account number contains only digits if not account_number.isdigit(): return False # Check if the length of the account number is within the specified range length = len(account_number) if length < min_length or length > max_length: return False return True"},{"question":"Objective: Your task is to implement a function `repeat_substring(s)` that determines if the given string `s` can be constructed by repeating a substring of itself multiple times. Input: - A non-empty string `s` (1 ≤ len(s) ≤ 10^4), where `s` consists of lowercase English letters. Output: - A boolean value: - `True` if the input string `s` can be constructed by repeating a substring of itself. - `False` otherwise. Constraints: - The solution must run efficiently with a time complexity of O(n) and space complexity of O(n). Performance Requirements: - The function should handle cases with large input sizes up to 10,000 characters within a reasonable time (ideally within one second). Example Scenarios: 1. **Example 1**: - **Input**: `\\"abab\\"` - **Output**: `True` - **Explanation**: The string is \\"ab\\" repeated twice. 2. **Example 2**: - **Input**: `\\"aba\\"` - **Output**: `False` - **Explanation**: The string cannot be constructed by repeating any substring. 3. **Example 3**: - **Input**: `\\"abcabcabcabc\\"` - **Output**: `True` - **Explanation**: The string is \\"abc\\" repeated four times. Requirements: 1. Properly handle edge cases, such as single-character strings and strings with no repetition. 2. Ensure optimal performance for the specified input size limits. Implement the function as follows: ```python def repeat_substring(s): :type s: str :rtype: bool str = (s + s)[1:-1] return s in str ``` Note: - Use appropriate string operations and slicing to achieve the desired result efficiently. - Carefully test your function with various edge cases to ensure correctness.","solution":"def repeat_substring(s): Determine if the string can be constructed by repeating a substring of itself. :param s: A non-empty string consisting of lowercase English letters. :return: A boolean value, True if the string can be constructed by repeating a substring, otherwise False. # Create a new string by concatenating s with itself and removing the first and last characters combined_string = (s + s)[1:-1] # Check if the original string s is in the new combined string return s in combined_string"},{"question":"**Objective**: To assess students\' understanding of bitwise operations and binary representation manipulation through an algorithmic problem. Description: Given a positive integer N, write a function `find_longest_binary_gap(N)` that finds and returns the longest distance between two consecutive 1\'s in the binary representation of N. If there are not two consecutive 1\'s, the function should return 0. Input: * A single integer N (1 ≤ N ≤ 10^9) Output: * An integer representing the longest distance between consecutive 1\'s in the binary representation of N. Constraints: * The maximum value for N is 10^9, ensuring the binary representation will fit within 30 bits. Function Signature: ```python def find_longest_binary_gap(N: int) -> int: pass ``` # Example: **Example 1:** ```python Input: 22 Output: 2 Explanation: 22 in binary is 10110. In the binary representation of 22, there are three ones with the following respective distances: - The first consecutive pair of 1\'s have a distance of 2. - The second consecutive pair of 1\'s have a distance of 1. The answer is the largest of these distances, which is 2. ``` **Example 2:** ```python Input: 5 Output: 2 Explanation: 5 in binary is 101. The only pair of consecutive 1\'s has a distance of 2. ``` **Example 3:** ```python Input: 8 Output: 0 Explanation: 8 in binary is 1000. There are no consecutive 1\'s. ``` Notes: The function should accurately handle: * Cases with no consecutive 1\'s. * Very small inputs, such as 1. * Large integers up to 1 billion (10^9). Performance Requirements: * The implementation should achieve a time complexity of O(log N) and a space complexity of O(1).","solution":"def find_longest_binary_gap(N: int) -> int: binary_representation = bin(N)[2:] # convert to binary and strip the \'0b\' prefix max_gap = 0 current_gap = 0 for bit in binary_representation: if bit == \'1\': if current_gap > max_gap: max_gap = current_gap current_gap = 1 # reset current gap counter and include this \'1\' in the count elif bit == \'0\' and current_gap > 0: current_gap += 1 # count the gap return max_gap"},{"question":"Objective Write a function that implements matrix multiplication. The function should take two matrices as input and return their product, adhering to the properties and constraints outlined below. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` Input - `multiplicand`: A list of lists representing a 2D matrix of integers. - `multiplier`: A list of lists representing another 2D matrix of integers. Output A list of lists representing the result of multiplying the two matrices. If the matrices are not compatible for multiplication, the function should raise an exception with a clear error message. Constraints - The input matrices should contain only integers. - Assume the matrices are well-formed, i.e., no jagged arrays. - The dimensions of the matrices will be such that the number of columns in `multiplicand` matches the number of rows in `multiplier`. Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] # Expected output: # [ # [4, 4], # [10, 8] # ] print(matrix_multiply(multiplicand, multiplier)) ``` Performance Requirements - Ensure the solution is capable of handling matrices of size up to 100x100 within a reasonable time frame. Implementation Notes - Handle potential errors gracefully by raising exceptions with clear messages. - Avoid using third-party libraries; the function needs to be implemented using basic structures and loops.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the resulting matrix. Parameters: multiplicand (list of lists): The first matrix to be multiplied. multiplier (list of lists): The second matrix to be multiplied. Returns: list of lists: The resulting matrix from multiplying the two input matrices. # Get the number of rows and columns for both matrices rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check if the matrices can be multiplied if cols_multiplicand != rows_multiplier: raise ValueError(\\"Number of columns of the first matrix must equal number of rows of the second matrix.\\") # Initialize the result matrix with zeros result = [[0]*cols_multiplier for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Coding Challenge: Detecting and Locating the First Node of a Cycle in a Linked List Context Imagine you are implementing a traffic monitoring system, where a cycle represents a potential traffic jam. Each road segment (node) leads to another, and your goal is to identify the start of any loop to assist in traffic management. Task Write a function `first_cyclic_node` that detects the first node of a cycle in a singly linked list. If no cycle exists, return `None`. Function Signature ```python def first_cyclic_node(head: Node) -> Node: :param head: the head node of a linked list :return: the first node where the cycle begins, or None if no cycle. ``` Input - `head`: The starting node of the linked list. Each node contains an attribute `val` for its value, and `next` pointing to the next node. Output - Return the first node where the cycle begins. If no cycle exists, return `None`. Example 1. Given the linked list `1 -> 2 -> 3 -> 4 -> 5 -> 2` (cycle starts at `2`), the output should be the node with value `2`. 2. If the linked list is `A -> B -> C -> D -> E -> C` (cycle starts at `C`), the output should be the node `C`. Constraints - Try to achieve O(n) time complexity and O(1) space complexity. Implementation Implement the function `first_cyclic_node` using Floyd\'s Tortoise and Hare Algorithm to detect and locate the first node of a cycle.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def first_cyclic_node(head: Node) -> Node: Detect the first node of the cycle in a linked list. If no cycle, return None. :param head: the head node of a linked list :return: the first node where the cycle begins, or None if no cycle. if not head or not head.next: return None slow = head fast = head # First phase - find the intersection point if a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle was detected if not fast or not fast.next: return None # Second phase - find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Problem You are tasked with implementing a Segment Tree that supports both construction and query operations. The Segment Tree allows the user to specify the function used to merge the segments, providing flexibility for different kinds of queries (e.g., sum, minimum, maximum). # Requirements: **Implementation** 1. **Class**: Implement a `SegmentTree` class. 2. **Constructor**: - **Parameters**: - `arr`: List of integers. - `function`: A binary function (e.g., `sum`, `max`, `min`) that determines how the segments will be merged. - **Operation**: Constructs the segment tree from the input array `arr`. 3. **Method**: `query(L, R)` - **Parameters**: - `L`: Starting index of the query range. - `R`: Ending index of the query range. - **Operation**: Returns the result of the specified query from index `L` to `R` using the merging function provided. # Input/Output Formats: **Input:** - The segment tree construction should accept: - An array `arr` of integers. - A binary function like `sum`, `max`, or `min`. - The `query` method should accept two integers `L` and `R` representing the range. **Output:** - The `query` method should return: - An integer representing the result of the function applied over the range `[L, R]`. # Constraints: - The input array length can be between 1 and 10^5. - The elements of the array can range from -10^9 to 10^9. - The function will be a valid Python callable like `sum` or a custom lambda function. # Example Usage ```python # Create a segment tree with max function seg_tree = SegmentTree([2, 4, 5, 3, 4], max) # Perform a query on range 2 to 4 print(seg_tree.query(2, 4)) # Output: 5 (since max of [5, 3, 4] is 5) # Create a segment tree with sum function seg_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) # Perform a query on range 1 to 5 print(seg_tree.query(1, 5)) # Output: 57 (since sum of [5, 2, 3, 4, 43] is 57) ``` Your task is to complete the implementation of the `SegmentTree` class as described above.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, L, R): L += self.n R += self.n + 1 res = None while L < R: if (L & 1): res = self.tree[L] if res is None else self.function(res, self.tree[L]) L += 1 if (R & 1): R -= 1 res = self.tree[R] if res is None else self.function(res, self.tree[R]) L >>= 1 R >>= 1 return res"},{"question":"Given a digit string, write a function `letter_combinations(digits: str) -> List[str]` that returns all possible letter combinations that the number could represent. The function should map digits to their corresponding letters based on a standard telephone button layout. # Input and Output Formats - **Input**: - A single string `digits` consisting of digits `2` through `9` (inclusive) with length `0 <= len(digits) <= 10`. - **Output**: - A list of all possible letter combinations in lexicographical order. # Constraints - The function should handle the input efficiently for the given constraints. - It should handle edge cases like an empty input string gracefully. # Example ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"9\\") == [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] ``` # Additional Scenario Consider integrating this function into a text input system where users input digit sequences to receive suggested words, similar to predictive text on old mobile phones.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the digit string could represent. if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return for letter in phone_map[digits[index]]: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Question: Advanced GCD Calculation with Constraints In this question, you are tasked to implement a function that computes the greatest common divisor (GCD) of a list of integers. Your implementation should consider both positive and negative integers and leverage bitwise operations for optimization. Additionally, handle zero values properly within the list. **Function Signature:** ```python def optimized_gcd(nums: List[int]) -> int: Computes the greatest common divisor of a list of integers using bitwise operations. Parameters: nums (List[int]): a list of non-zero integers Returns: int: the greatest common divisor of the list ``` # Input - `nums` (List[int]): A list of non-zero integers. - Size constraints: 1 ≤ len(nums) ≤ 10^5 - Value constraints: -10^6 ≤ num ≤ 10^6 # Output - Returns an integer which is the greatest common divisor of the input list. # Constraints - The list will always contain at least one integer. - All integers in the list are guaranteed to be non-zero. # Performance Requirements - Solution should operate within O(n log(min(abs(nums)))) time complexity. # Example Example 1 ```python Input: [54, 24, 36] Output: 6 ``` Example 2 ```python Input: [48, -180, 640] Output: 4 ``` # Additional Clarification - Consider the effect of both positive and negative integers on your GCD calculation. - Leverage bitwise operations for the GCD calculation to ensure optimal performance. - Assume the input list size and values to be within manageable bounds for typical integer operations in Python.","solution":"from typing import List def gcd(a: int, b: int) -> int: Computes the greatest common divisor using the bitwise Stein\'s algorithm. if a == 0: return b if b == 0: return a # both a and b are nonzero if a < 0: a = -a if b < 0: b = -b # find common factors of 2 shift = 0 while (a | b) & 1 == 0: a >>= 1 b >>= 1 shift += 1 while a & 1 == 0: a >>= 1 while b != 0: while b & 1 == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def optimized_gcd(nums: List[int]) -> int: Computes the greatest common divisor of a list of integers using bitwise operations. result = nums[0] for num in nums[1:]: result = gcd(result, num) if result == 1: break return result"},{"question":"# Sorting Large Data with Optimized Bubble Sort Scenario: You are working as a software engineer in a company that processes large datasets. You are assigned to optimize the sorting of lists of numerical data using the bubble sort algorithm. Given the analysis of the bubble sort\'s properties and limitations, you realize that an optimized approach is necessary for practical use with larger datasets. Task: Implement an optimized version of the bubble sort algorithm that: 1. Efficiently handles cases where the input list is already partially sorted or fully sorted. 2. Processes large datasets as efficiently as possible within the constraints of bubble sort. # Requirements: 1. Write a function `optimized_bubble_sort` that takes a list of integers as input and returns a sorted list of integers. 2. Optimize the implementation to minimize unnecessary passes through the list. 3. Ensure that your solution maintains a time complexity of O(N^2) in the worst case and O(N) in the best case. # Input: - A list of integers `arr` (0 ≤ |arr| ≤ 10^5, where |arr| is the length of the list) # Output: - A sorted list of integers. # Constraints: - Do not use any built-in sorting functions. - Your implementation should work efficiently with the upper limit of the input size. # Example: ```python input: [64, 25, 12, 22, 11] output: [11, 12, 22, 25, 64] input: [5, 1, 4, 2, 8] output: [1, 2, 4, 5, 8] ``` Develop the `optimized_bubble_sort` function to handle the task as described.","solution":"def optimized_bubble_sort(arr): Sorts a list of integers using an optimized bubble sort approach. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Problem: Bit Flipping Challenge **Context**: In digital communications and data storage, it\'s common to encounter the need to assess and correct bit differences between two data words. Your task is to determine the minimal number of bit flips required to convert one integer into another. **Objective**: Write a function `count_flips_to_convert(a: int, b: int) -> int` that determines the number of bits that need to be flipped to convert the integer `A` to integer `B`. **Function Signature**: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` **Input**: * `a` (integer): The first integer. * `b` (integer): The second integer. **Output**: * Returns an integer. The minimal number of bit flips required to turn `A` into `B`. **Constraints**: * 0 ≤ a, b ≤ 10^9 **Example**: ```python assert count_flips_to_convert(29, 15) == 2 # Binary: 11101 to 01111 assert count_flips_to_convert(0, 15) == 4 # Binary: 00000 to 01111 assert count_flips_to_convert(7, 7) == 0 # Binary: 00111 to 00111 ``` # Requirements: * Implement the function efficiently with regard to time and space. * Ensure the solution handles edge cases such as minimum and maximum values within the specified constraints. Happy coding!","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the number of bit flips required to convert integer \'a\' to integer \'b\'. :param a: The first integer. :param b: The second integer. :return: The minimal number of bit flips required to convert \'a\' to \'b\'. # XOR the two numbers to find differing bits xor_result = a ^ b # Count the number of 1s in the binary representation of the result return bin(xor_result).count(\'1\')"},{"question":"# Question: Implement Enhanced Bucket Sort You have been provided with the bucket sort algorithm, a technique suitable for sorting an array of numbers by dividing them into several buckets, sorting each bucket, and then combining the sorted buckets. However, the provided implementation uses insertion sort for sorting each bucket, which can be inefficient for larger datasets. # Task: Your task is to implement an enhanced version of the `bucket_sort` function where each bucket is sorted using a more efficient sorting algorithm like quicksort. # Function Signature: ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Expected Input and Output: * Input: A list of integers `arr` where `0 <= len(arr) <= 10^5` and `0 <= arr[i] <= 10^6` for all valid `i`. * Output: A list of integers sorted in non-descending order. # Constraints: 1. Optimize the sorting algorithm inside the bucket_sort function to handle larger datasets efficiently. 2. You may use any Python library functions if needed. 3. The function should handle edge cases such as empty lists or lists with identical elements efficiently. # Example: ```python assert bucket_sort([29, 25, 3, 49, 37, 21, 43, 31, 33]) == [3, 21, 25, 29, 31, 33, 37, 43, 49] assert bucket_sort([]) == [] assert bucket_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert bucket_sort([3, 3, 3, 1, 1, 1, 2, 2, 2]) == [1, 1, 1, 2, 2, 2, 3, 3, 3] ``` # Note: Ensure that your solution is both efficient and handles edge cases appropriately.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Determine the number of buckets to use num_buckets = len(arr) max_value = max(arr) min_value = min(arr) bucket_size = (max_value - min_value) // num_buckets + 1 # Create and distribute elements into buckets buckets = [[] for _ in range(num_buckets)] for num in arr: index = (num - min_value) // bucket_size buckets[index].append(num) # Sort individual buckets and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(quicksort(bucket)) return sorted_arr"},{"question":"# Unique Element in a Repeating Array Context: Imagine you\'re working on an array where every integer appears exactly three times except for one integer in the array, which appears only once. Your task is to find this unique integer efficiently both in terms of time and space. Problem Statement: Write a function `find_unique_number(nums: List[int]) -> int` that takes a list of integers `nums` and returns the integer that appears exactly once. Your algorithm should have a linear runtime complexity and should not use extra memory (i.e., constant space complexity). Constraints: - The array will have at least one element (the unique one). - The elements of the array are integers. - Every element in the array, except one, appears exactly three times. - You must not use extra memory beyond a fixed amount (O(1) space complexity). Input/Output Format: - **Input**: A list of integers `nums` with length `n`. ```python def find_unique_number(nums: List[int]) -> int: # Your implementation here # Example usage print(find_unique_number([2, 2, 3, 2])) # Should output 3 print(find_unique_number([0, 1, 0, 1, 0, 1, 99])) # Should output 99 ``` Performance Requirements: - Time Complexity: O(n) - Space Complexity: O(1) Given this scenario, implement the function while adhering to the constraints and requirements provided. Your solution should demonstrate efficient use of bitwise operations.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: This function finds the unique number in a list where every integer appears three times except for one. ones = 0 twos = 0 for num in nums: # when num comes, it first alters `ones` (first appearance) # if it appears again, it updates `twos`. If it appears the third time, both `ones` and `twos` will be zero for that number ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Combination Sum Problem Problem Statement Given an integer array `nums` consisting of all positive numbers and no duplicates, write a function to find the number of possible combinations that add up to a positive integer `target`. Different sequences of the same set of numbers count as different combinations. Note: If negative numbers are allowed in the array, the nature of the problem changes significantly. Hence, handle only the case with all positive numbers and no duplicates. Input - `nums` (List[int]): A list of positive integers without duplicates. - `target` (int): A positive integer for which we want to find the number of combinations in `nums` summing up to `target`. Output - Return (int): The number of possible combinations that add up to the `target`. Constraints - All elements in `nums` are positive integers without duplicates. - The `target` is a positive integer. Function Signature ```python def combination_sum(nums: List[int], target: int) -> int: ``` # Requirements - Implement the function `combination_sum(nums, target)`. - Use an iterative dynamic programming (bottom-up) approach, utilizing a DP array to incrementally build solutions for all sub-targets up to the given `target`. Example ```python nums = [1, 2, 3] target = 4 # The possible combination ways are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) # Hence, the output will be 7. print(combination_sum(nums, target)) # Output: 7 ```","solution":"def combination_sum(nums, target): Given an integer array `nums` consisting of all positive numbers and no duplicates, this function finds the number of possible combinations that add up to a positive integer `target`. # Initialize the dp array where dp[i] will be storing the number of solutions for # target `i`. We need target + 1 space. dp = [0] * (target + 1) # Base case: There is exactly one way to get sum 0, by using no element at all dp[0] = 1 # Fill the dp array by considering solutions for every sum upto the target. for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"Problem Statement You are given a string `s` and a set of words `wordDict`. Your task is to write a function `count_sentences(s, wordDict)` that returns the number of possible sentence decompositions of `s` such that each word in the decomposition is contained in the `wordDict`. Each word in the dictionary can be reused multiple times if necessary. # Input - `s`: A non-empty string containing lowercase letters (1 ≤ len(s) ≤ 200). - `wordDict`: A set of unique strings containing lowercase letters (1 ≤ len(wordDict) ≤ 50, 1 ≤ len(word) ≤ 50 for each word in wordDict). # Output - An integer representing the number of potential sentences that can be formed from `s` using `wordDict`. # Constraints 1. Use of global variables is not allowed. 2. The function should be optimized to handle upper constraint limits efficiently. 3. Repeated substrings should be computed using a caching mechanism (Memoization). # Example ```python s = \\"appletablet\\" wordDict = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"} assert count_sentences(s, wordDict) == 3 s = \\"thing\\" wordDict = {\\"thing\\"} assert count_sentences(s, wordDict) == 1 ``` # Hint Use recursion with memoization to avoid recalculating subproblems. ```python def count_sentences(s, wordDict): # Your code goes here pass ```","solution":"def count_sentences(s, wordDict): Returns the number of possible sentence decompositions of s such that each word in the decomposition is contained in the wordDict. def dfs(s, memo): # If string is empty, we\'ve successfully decomposed it if not s: return 1 if s in memo: return memo[s] count = 0 for word in wordDict: if s.startswith(word): count += dfs(s[len(word):], memo) memo[s] = count return count # Dictionary to store results of subproblems memo = {} return dfs(s, memo)"},{"question":"**Context:** You are developing a plagiarism detection tool that needs to efficiently search for a given pattern (word) within a larger body of text. The Rabin-Karp algorithm is an ideal choice due to its efficient average case performance for string searching. Your task is to implement the `rabin_karp` function that uses the Rolling Hash technique to search for a pattern in a given text and returns the starting index of the first occurrence of the pattern. **Requirements:** 1. Implement the `Rabin-Karp` string searching algorithm. 2. Use the polynomial hash-based rolling hash technique provided in the `RollingHash` class. 3. Ensure that edge cases such as empty input strings and pattern lengths greater than the text length are handled appropriately. **Function Signature:** ```python def rabin_karp(word: str, text: str) -> int: ``` # Input - `word (str)`: The pattern to search for in the text. It may contain only lowercase alphabetic characters. - `text (str)`: The text in which to search for the pattern. It may contain only lowercase alphabetic characters. # Output - `int`: The starting index of the first occurrence of the pattern in the text if found, else return `None`. # Constraints - `0 <= len(word) <= 10^5` - `0 <= len(text) <= 10^6` # Examples ```python assert rabin_karp(\\"test\\", \\"this is a test text\\") == 10 assert rabin_karp(\\"a\\", \\"banana\\") == 1 assert rabin_karp(\\"abc\\", \\"aabcac\\") == 1 assert rabin_karp(\\"abc\\", \\"defgr\\") == None ``` # Notes - You are provided with the `RollingHash` class that handles the hash computation and window shifting. - Assume that the character set is restricted to lowercase English letters for both input strings. - Handle large inputs efficiently, focusing on average case performance.","solution":"class RollingHash: def __init__(self, base=256, modulus=2**61-1): self.base = base self.modulus = modulus self.base_inv = pow(base, -1, modulus) def hash(self, s): h = 0 for char in s: h = (h * self.base + ord(char)) % self.modulus return h def roll(self, prev_hash, dropped, added, k): new_hash = prev_hash - ord(dropped) * pow(self.base, k-1, self.modulus) new_hash = (new_hash * self.base + ord(added)) % self.modulus return new_hash def rabin_karp(word: str, text: str) -> int: if not word or not text or len(word) > len(text): return None m, n = len(word), len(text) rh = RollingHash() word_hash = rh.hash(word) current_hash = rh.hash(text[:m]) if current_hash == word_hash and text[:m] == word: return 0 for i in range(1, n - m + 1): current_hash = rh.roll(current_hash, text[i-1], text[i + m - 1], m) if current_hash == word_hash and text[i:i + m] == word: return i return None"},{"question":"# Question: Integer Decomposition Count Given a positive integer `n`, write a function `count_partitions(n)` that returns the number of ways to partition `n` into sums of positive integers. In a partition of `n`, the order of terms does not matter, and partitions that differ only in the order of their summands are considered the same. Your function should use a dynamic programming approach to efficiently compute the result. Input: - A single integer `n` (1 ≤ n ≤ 100). Output: - Return a single integer representing the number of ways to partition `n`. Example: ```python count_partitions(4) ``` Expected Output: ``` 5 ``` Explanation: There are five ways to partition 4: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Constraints: - You can assume `n` will always be a positive integer. - Optimize for both time and space as much as possible within the given constraints. Note: Use a 2D list to store intermediate results for partitions, where `dp[i][j]` represents the number of ways to partition the integer `i` using integers up to `j`.","solution":"def count_partitions(n): Returns the number of ways to partition the integer n. # Create a 2D list to store results of subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # base case: there\'s one way to partition 0, that is using 0 dp[0][0] = 1 # Fill the dp table for i in range(1, n + 1): for j in range(n + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[n][n]"},{"question":"**Insertion Sort with Shift Count** A sequence of numbers typically represents various data points in computational tasks. Sorting such sequences in a systematic, deterministic manner is a common requirement. You are tasked with writing a function called `insertion_sort_with_shifts` that will sort an array using the Insertion Sort algorithm and also return the number of shifts (or swaps) required to sort the array. A shift is counted every time an element in the array is moved to an earlier position. # Input Format - A list of integers `arr` where ( 1 leq len(arr) leq 10^3 ) and elements are within the range of integer values. The array may contain duplicate values. # Output Format - The sorted list of integers. - An integer indicating the total number of shifts required to sort the array. # Constraints - Your solution should have a time complexity of O(n^2) in the worst case. - Aim to minimize the auxiliary space usage to O(1). # Function Signature ```python def insertion_sort_with_shifts(arr: list[int]) -> tuple[list[int], int]: pass ``` # Example **Example 1:** ```plaintext Input: [4, 3, 2, 1] Output: ([1, 2, 3, 4], 6) ``` Explanation: Each element required multiple shifts: - 4 to 1 shift - 3 shifts twice - 2 shifts twice - 1 shift once **Example 2:** ```plaintext Input: [1, 2, 3, 4] Output: ([1, 2, 3, 4], 0) ``` Explanation: The array is already sorted; hence, no shifts are needed. Write a `insertion_sort_with_shifts` function to implement this. The function must sort the array while keeping track of the number of shifts. # Notes Additionally, document edge cases that you consider (e.g., empty list, single-element list, etc.).","solution":"def insertion_sort_with_shifts(arr: list[int]) -> tuple[list[int], int]: Sorts the input array using the Insertion Sort algorithm and returns the sorted array along with the number of shifts (or swaps) required to sort the array. Args: arr (list[int]): The array of integers to be sorted. Returns: tuple[list[int], int]: A tuple containing the sorted array and the total number of shifts. shifts = 0 for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] shifts += 1 j -= 1 arr[j + 1] = key return arr, shifts"},{"question":"# Flatten Nested Arrays You are given multidimensional arrays which may contain nested arrays of arbitrary depth. Write a function `flatten_array(input_arr)` which takes in a single list argument `input_arr` that may contain nested lists, and returns a flattened list containing all the elements in depth-first order. Function Signature ```python def flatten_array(input_arr: List[Any]) -> List[Any]: ``` # Input - `input_arr`: A list which may contain nested lists. - Example: `[1, [2, [3, 4]], [5]]` # Output - Returns a single list where all elements are flattened. - Example: `[1, 2, 3, 4, 5]` # Constraints - Nested lists may be of arbitrary depth. - Elements of the list can be integers, strings, or lists. # Examples 1. Input: `[1, [2, [3, 4]], [5]]` - Output: `[1, 2, 3, 4, 5]` 2. Input: `[\'a\', [\'b\', [\'c\', \'d\']], [\'e\']]` - Output: `[\'a\', \'b\', \'c\', \'d\', \'e\']` 3. Input: `[1, [2, [3, [4, NULL]]]]` - Output: `[1, 2, 3, 4, NULL]` 4. Input: `[[], [[], []], []]` - Output: `[]` # Performance Requirements - Your implementation should handle deeply nested structures effectively. - Avoid lengthy call stacks by considering both recursive and non-recursive strategies if needed.","solution":"from typing import List, Any def flatten_array(input_arr: List[Any]) -> List[Any]: Flattens a nested list into a single list of elements. flattened = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flattened.append(element) flatten(input_arr) return flattened"},{"question":"# Intersection Detection in Singly Linked Lists Description You are given two singly linked lists that may merge at some point. Your task is to write a function that returns the node where the two lists intersect. If the lists do not intersect, return `None`. Function Signature ```python def intersection(h1: Node, h2: Node) -> Node: pass ``` Input - `h1`: The head node of the first linked list. - `h2`: The head node of the second linked list. Each `Node` is defined as: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` Output - Return the node where the two linked lists intersect. Return `None` if there is no intersection. Constraints - The node itself (based on reference, not value) is the unique identifier for comparison. - Lists can be of different lengths. - Both lists do not contain cycles. Examples # Example 1 ```python # Input: # List 1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # List 2: 2 -> 4 -> 6 # Output: # Node with value 7 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2).val == 7 ``` # Example 2 ```python # Input: # List 1: 1 -> 9 # List 2: 2 -> 4 # Output: None a1 = Node(1) b1 = Node(9) a2 = Node(2) b2 = Node(4) a1.next = b1 a2.next = b2 assert intersection(a1, a2) is None ``` Requirements - **Time Complexity**: The solution should have a linear time complexity. - **Space Complexity**: The solution should use constant extra space. Write the function `intersection` that meets the requirements and successfully determines the point of intersection in two singly linked lists.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: if not h1 or not h2: return None # Get the lengths of both lists def get_length(head): length = 0 while head: head = head.next length += 1 return length length1 = get_length(h1) length2 = get_length(h2) # Determine the longer and shorter list longer, shorter = (h1, h2) if length1 >= length2 else (h2, h1) diff = abs(length1 - length2) # Advance the pointer for the longer list by the length difference for _ in range(diff): longer = longer.next # Now both pointers are equally far from the intersection point (if any) while longer and shorter: if longer == shorter: return longer longer = longer.next shorter = shorter.next return None"},{"question":"# Exchange Sort Enhancement As a junior software developer, you’ve been tasked with optimizing and ensuring the robustness of the Exchange Sort algorithm. Your goal is to improve its efficiency and address any potential edge cases. Specifically, implement a flag mechanism to detect if a swap has occurred in the current pass. If no swaps are made, the algorithm should terminate early. This optimization can reduce unnecessary comparisons and potentially improve performance. Write a function `optimized_exchange_sort` that sorts a list of integers. The function should implement the traditional Exchange Sort principles with the enhancements described. Function Signature ```python def optimized_exchange_sort(arr: list[int]) -> list[int]: pass ``` Input * `arr`: A list of integers (0 <= len(arr) <= 10^5) Output * Returns the sorted list of integers in ascending order. Constraints * You may not use any in-built sorting functions. * The algorithm should operate in-place to ensure O(1) space complexity. * Address edge cases such as empty list, singleton list, and lists with duplicate elements. Example 1. Input: `[4, 3, 2, 1]` Output: `[1, 2, 3, 4]` 2. Input: `[1, 2, 3, 4]` Output: `[1, 2, 3, 4]` 3. Input: `[4, 1, 3, 2]` Output: `[1, 2, 3, 4]` 4. Input: `[]` Output: `[]` Make sure your solution is optimized and runs efficiently within the given constraints.","solution":"def optimized_exchange_sort(arr: list[int]) -> list[int]: Sorts a list using an optimized version of the Exchange Sort algorithm. This version terminates early if no swaps are made in a pass. Args: arr (list of int): The list to be sorted. Returns: list of int: The sorted list. n = len(arr) for i in range(n-1): swapped = False for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"Serialize and Deserialize Binary Search Tree You are required to implement a function to serialize and deserialize a Binary Search Tree (BST). Firstly, the BST needs to be converted to a string representation (serialize) and then the string should be parsed back to the same BST structure (deserialize). **Function Signatures**: ```python def bst_serialize(root: TreeNode) -> str: pass def bst_deserialize(data: str) -> TreeNode: pass ``` # Input and Output Formats * **bst_serialize**: - **Input**: The root of the BST. - **Output**: A string representation of the BST. * **bst_deserialize**: - **Input**: A string representation of the BST. - **Output**: The root of the reconstructed BST. # Constraints - The number of nodes in the tree is between 0 and 10^4. - Each node\'s value is a unique integer. # Example ```python # Define the TreeNode class before the example class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None # Example root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) serialized = bst_serialize(root) print(serialized) # Output format for serialization (example): \\"2 1 # # 3 # #\\" deserialized_root = bst_deserialize(serialized) print(deserialized_root.val) # Output should match the structure and values of the original tree print(deserialized_root.left.val) print(deserialized_root.right.val) ``` # Requirements * Ensure your functions handle edge cases such as an empty BST (root is None). * Optimize to handle trees with large number of nodes efficiently. * Consider iterative approaches to manage tree depth and recursive call stack limitations.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bst_serialize(root: TreeNode) -> str: Encodes a tree to a single string. def preorder_traversal(node): if not node: return [\'#\'] return [str(node.val)] + preorder_traversal(node.left) + preorder_traversal(node.right) return \' \'.join(preorder_traversal(root)) def bst_deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def build_tree(): val = next(vals) if val == \'#\': return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree()"},{"question":"# ZigZag Iterator for N Lists **Scenario**: You\'re given multiple lists, each containing a number of integers. You need to iterate through these lists in a \\"zigzag\\" fashion, meaning you take one element from the first list, then the next element from the second list, and so on. When you reach the end of a list, you skip it and continue with the next available list, until all lists are exhausted. **Task**: Design a class `ZigZagIteratorN` that takes an arbitrary number of lists and allows iteration in a zigzag order. **Requirements**: 1. **Initialization**: - `__init__(self, lists: List[List[int]])` - Initializes the iterator with a list of lists. 2. **Next Element**: - `next(self) -> int` - Returns the next element in the zigzag order. 3. **Check for Remaining Elements**: - `has_next(self) -> bool` - Returns `True` if there are more elements to iterate through, otherwise returns `False`. **Constraints**: - The total number of elements across all lists will not exceed 10^5. - Lists may contain integers in any order. - Lists may be of different lengths and may be empty. **Example**: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] zz = ZigZagIteratorN(lists) result = [] while zz.has_next(): result.append(zz.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` **Implementation Tips**: - Use a queue to manage the lists and their current indices. - Ensure that you handle varying list lengths correctly. - Efficiently handle edge cases where some lists may be empty.","solution":"from collections import deque from typing import List class ZigZagIteratorN: def __init__(self, lists: List[List[int]]): self.queue = deque((i, 0) for i in range(len(lists)) if lists[i]) self.lists = lists def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") i, idx = self.queue.popleft() value = self.lists[i][idx] if idx + 1 < len(self.lists[i]): self.queue.append((i, idx + 1)) return value def has_next(self) -> bool: return bool(self.queue)"},{"question":"# Prim\'s Algorithm for Minimum Spanning Tree Problem Statement: You have been provided code that implements Prim’s algorithm to find the weight of the minimum spanning tree (MST) for a connected graph represented as a dictionary. Your task is to modify and extend the implementation to: 1. Handle general node labeling (not restricted to numeric labels). 2. Return the actual set of edges in the MST along with the minimum cost. 3. Ensure robustness against invalid input data structures, including disconnected graphs if detected. # Function Signature ```python def enhanced_prims_minimum_spanning(graph: Dict[str, List[Tuple[int, str]]]) -> Tuple[int, List[Tuple[str, str, int]]]: pass ``` # Input * **graph**: A dictionary where keys are node labels and values are lists of tuples. Each tuple contains an edge weight (int) and the label of an adjacent node (string). # Output * A tuple containing: * **int**: Total weight of the minimal spanning tree. * **List of Tuples**: Edges in the MST represented as tuples (node1, node2, weight). # Constraints * Ensure the graph is connected, otherwise, return an error or empty MST. * Node labels can be any string. # Example ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } # Expected Output: # (14, [(\'a\', \'b\', 3), (\'b\', \'d\', 5), (\'d\', \'c\', 2), (\'c\', \'e\', 4)]) ``` # Performance Requirements: * The solution should efficiently handle graphs with up to 1000 nodes and roughly 10,000 edges. # Notes: * Validate the input graph structure to ensure nodes are adequately represented across edge lists. * Return a meaningful message if it detects the graph is disconnected.","solution":"import heapq from typing import Dict, List, Tuple def enhanced_prims_minimum_spanning(graph: Dict[str, List[Tuple[int, str]]]) -> Tuple[int, List[Tuple[str, str, int]]]: if not graph: return 0, [] # Initialize start_node = next(iter(graph)) min_heap = [(0, start_node, None)] # (cost, to_node, from_node) total_cost = 0 mst_edges = [] visited = set() while min_heap: cost, to_node, from_node = heapq.heappop(min_heap) if to_node in visited: continue visited.add(to_node) if from_node: mst_edges.append((from_node, to_node, cost)) total_cost += cost for edge_cost, neighbor in graph[to_node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_cost, neighbor, to_node)) # Check if all nodes are connected if len(visited) != len(graph): return \\"The graph is disconnected\\", [] return total_cost, mst_edges"},{"question":"# Question You have been provided with an implementation of Bogo Sort, a highly inefficient sorting algorithm. Your task is to implement a new sorting function to simulate and visualize each step of the sorting process. However, given the impracticality of Bogo Sort for real-world scenarios, your solution should ensure that it avoids shuffling arrays excessively. Implement a function `visual_bogo_sort` that takes in a list of integers and performs Bogo Sort on it. The function should output each intermediate step when the array is shuffled and when it finds the array to be sorted. Given the inefficiencies of Bogo Sort, the function should include a mechanism to abort after a large number of iterations to avoid infinite loops. # Requirements: 1. Implement the function `visual_bogo_sort(arr, max_iterations)`: - **Input**: The function accepts two arguments: - `arr` (list of integers): The array to be sorted. - `max_iterations` (int): The maximum iterations allowed to attempt sorting before aborting. - **Output**: Print the array at each iteration and a final message. - Print the array for each shuffle and check. - Print \\"Sorted after X iterations\\" if the array gets sorted. - Print \\"Aborted after Y iterations\\" if the maximum iterations limit is reached without sorting. 2. The function should handle edge cases gracefully: - Empty array. - Array with one element. - Arrays that are already sorted. # Example: ```python arr = [3, 2, 5, 1, 4] max_iterations = 1000 visual_bogo_sort(arr, max_iterations) ``` **Note**: This function is mostly for educational purposes to illustrate the inefficiencies of certain algorithms. # Constraints: - The length of the array `arr` will be at most 10 elements. - The maximum number of iterations (`max_iterations`) will be a positive integer no greater than 10,000.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def visual_bogo_sort(arr, max_iterations): Performs a Bogo Sort on the array while visualizing each iteration. Args: arr (list of int): The array to be sorted. max_iterations (int): Maximum number of iterations allowed. Returns: None: Prints the array at each iteration and final result. iterations = 0 while not is_sorted(arr): if iterations >= max_iterations: print(f\\"Aborted after {iterations} iterations.\\") return print(f\\"Iteration {iterations}: {arr}\\") random.shuffle(arr) iterations += 1 print(f\\"Iteration {iterations}: {arr}\\") print(f\\"Sorted after {iterations} iterations.\\")"},{"question":"# Radix Sort Implementation with Error Handling You are tasked with implementing an extended version of the radix sort algorithm to handle various edge cases and provide helpful error messages in case of invalid inputs. The algorithm must sort a list of non-negative integers in ascending order. # Function Signature ```python def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Expected Input and Output Formats: - **Input**: A list of non-negative integers `arr` with a length `n`. - The list can be empty, contain duplicates, or have a single element. - Example: `arr = [170, 45, 75, 90, 802, 24, 2, 66]` - **Output**: A sorted list of integers. - Example: `[2, 24, 45, 66, 75, 90, 170, 802]` # Constraints: - `0 <= len(arr) <= 10^5` - `0 <= arr[i] <= 10^9` for each element in `arr`. # Requirements: 1. Improve and implement the radix sort algorithm provided in the snippet. 2. Implement error handling and input validation: - Raise appropriate errors or return specific messages if the input list contains invalid types (e.g., negative numbers, non-integer values). - Ensure an empty list returns immediately without unnecessary processing. 3. Optionally simulate the sorting process at each iteration if the `simulation` flag is set to `True`. - Print the state of the array at each significant step. 4. Maintain O(nk) time complexity and handle the upper limit of the constraints efficiently. # Edge Cases: - Empty list: `[]` - List with one element: `[5]` - All elements are the same: `[7, 7, 7, 7]` - Large numbers: `[999999999, 1, 123456789]` - Mix of sorted and unsorted elements: `[3, 1, 2, 1000, 999]` Implement the `enhanced_radix_sort` function based on the criteria above.","solution":"from typing import List def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if not all(isinstance(x, int) and x >= 0 for x in arr): raise ValueError(\\"All elements must be non-negative integers.\\") if len(arr) == 0: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"After sorting on exp={exp}, array: {arr}\\") exp *= 10 return arr"},{"question":"**Scenario**: You are working on a signal processing project and need to compute the frequency domain representation of various input signals. Given the constraints of computational efficiency and correctness, you choose to implement the Cooley-Tukey FFT algorithm. Your implementation must handle arrays whose lengths are powers of two and return the discrete Fourier transform of the input. **Task**: Implement a function `fft` that computes the FFT of an input array of complex numbers. ```python def fft(x): Computes the discrete Fourier transform of the input array using the Cooley-Tukey FFT algorithm. Parameters: x (list of complex): An array of complex numbers whose length is a power of 2. Returns: list of complex: The discrete Fourier transform of the input array. pass ``` # Input: - `x`: A list of complex numbers. The length of the list `N` is guaranteed to be a power of 2. # Output: - A list of complex numbers representing the FFT of the input array. # Example: ```python input_array = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output = fft(input_array) print(output) # Should print: [(8+8j), 2j, (2-2j), (-2+0j)] ``` # Constraints: 1. The length of the input array will be a power of 2. 2. The maximum length of the input array is 2^10 (~1024 elements). # Performance Requirements: - The algorithm should have a time complexity of O(N log N) and space complexity of O(N). Your implementation should efficiently handle the computational needs and provide accurate results for the FFT transformation.","solution":"import cmath def fft(x): Computes the discrete Fourier transform of the input array using the Cooley-Tukey FFT algorithm. Parameters: x (list of complex): An array of complex numbers whose length is a power of 2. Returns: list of complex: The discrete Fourier transform of the input array. N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"# Queue Implementation Challenge You are required to implement a `CircularArrayQueue` class inheriting from `AbstractQueue`, which manages the queue elements using a circular array to avoid excessive memory allocation while handling the front and rear pointers efficiently. Requirements: * Implement the `enqueue`, `dequeue`, and `peek` methods following FIFO (First In, First Out) principle. * Ensure the implementation dynamically resizes the internal array when full, similar to the expansion done in `ArrayQueue`. However, utilize the properties of a circular array to enhance performance. * Override the `__iter__` method to iterate over the queue\'s elements in FIFO order. * The queue should handle edge cases like enqueueing and dequeueing on an empty or full queue accurately. Function Signatures ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): Initialize the circular array with a fixed capacity or given input. pass def enqueue(self, value): Adds an element to the end of the queue. If the queue is full, expand the array. pass def dequeue(self): Removes and returns the front element of the queue. pass def peek(self): Returns the front element of the queue without removing it. pass def __iter__(self): Iterates over the queue elements in FIFO order. pass ``` Input and Output * **Input Format**: Input consists of multiple operations to enqueue and dequeue elements, the initial array capacity, and specific elements. * **Output Format**: For each dequeue operation, output the element removed and for the peek operation, output the front element. Constraints * The queue must efficiently handle large number of enqueue and dequeue operations without degrading the performance. * Properly handle any invalid operation attempts such as dequeue or peek from an empty queue. Example ```python # Creating a CircularArrayQueue instance with a capacity of 5 queue = CircularArrayQueue(5) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) print(queue.dequeue()) # Output: 1 queue.enqueue(6) print(queue.peek()) # Output: 2 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: 3 queue.enqueue(7) print(queue.peek()) # Output: 4 ``` Note * Make sure to consider the wrap-around condition while implementing the circular array. * Ensure the solution efficiently handles edge cases and provides optimal performance.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: self._expand_capacity() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def _expand_capacity(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.size self.capacity = new_capacity def dequeue(self): if self.size == 0: raise IndexError(\\"Dequeue from empty queue\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Peek from empty queue\\") return self.queue[self.front] def __iter__(self): for i in range(self.size): yield self.queue[(self.front + i) % self.capacity]"},{"question":"# Newton\'s Method Square Root Calculation with Edge Cases Handling Problem Description You are required to implement a function that calculates the square root of a positive integer `N` using Newton\'s method. Additionally, handle edge cases, such as when `N` is zero or a negative number. Your function should return an approximate square root of `N` with an absolute error not exceeding `epsilon`. Function Signature ```python def newtons_sqrt(n: float, epsilon: float = 0.001) -> float: pass ``` Input - `n` : A positive floating-point number representing the number for which the square root is to be calculated. (0 <= N <= 10^9) - `epsilon`: A positive floating-point number that specifies the precision of the result (default value is 0.001). Output - Returns a floating-point number `x` such that ( |x^2 - n| < epsilon ). Constraints - Your implementation must handle the scenario where `n` is `0` gracefully by returning `0` immediately. - For negative values of `n`, return `None` to indicate an invalid input. - Keep the computational time within acceptable limits for large values of `n`. Examples ```python assert newtons_sqrt(5, 0.001) # Expected output: approximately 2.236 assert newtons_sqrt(10) # Expected output: approximately 3.162 assert newtons_sqrt(0) # Expected output: 0 assert newtons_sqrt(-1) # Expected output: None (invalid input) ``` Additional Information - You can assume that the user will always provide either 0 or a positive `epsilon`. - Ensure that your solution minimizes the number of iterations while maintaining the requested precision.","solution":"def newtons_sqrt(n: float, epsilon: float = 0.001) -> float: Calculate the square root of a positive integer `n` using Newton\'s method. Handle edge cases where n is zero or a negative number. Parameters: n (float): A positive floating-point number representing the number for which the square root is calculated. epsilon (float): Precision of the result. Default value is 0.001. Returns: float: Approximated square root of `n` with absolute error not exceeding `epsilon`, or None for invalid input. if n < 0: return None if n == 0: return 0.0 guess = n / 2.0 while abs(guess**2 - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"# Question: Given an unsorted array of integers, write a function `compressed_longest_increasing_subsequence` to find the length of the longest increasing subsequence (LIS) using an optimized approach involving Compressed Segment Tree to handle cases where elements might be extremely large. If any two elements in the sequence are equal, consider only their first occurrence. # Function Signature: ```python def compressed_longest_increasing_subsequence(sequence: list[int]) -> int: ``` # Input: - `sequence`: A list of integers representing the sequence. # Output: - An integer representing the length of the longest increasing subsequence. # Constraints: - The length of the sequence ( n) can be up to ( 10^5 ). - The sequence elements can be very large, up to ( 10^9). # Examples: 1. Input: `[10, 9, 2, 5, 3, 7, 101, 18]` Output: `4` Explanation: The longest increasing subsequence is `[2, 3, 7, 101]`, and its length is 4. 2. Input: `[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]` Output: `6` Explanation: The longest increasing subsequence is `[0, 2, 6, 9, 11, 15]`, and its length is 6. # Notes: - Ensure your solution is efficient and correctly handles large inputs. - You are advised to use a Compressed Segment Tree for optimal performance.","solution":"from bisect import bisect_left def compressed_longest_increasing_subsequence(sequence): Finds the length of the longest increasing subsequence in the given sequence. if not sequence: return 0 # The dp array will store the smallest possible tail value for all increasing subsequences # with a certain length. dp = [] for number in sequence: # Find the position to replace or extend in the dp array. pos = bisect_left(dp, number) if pos == len(dp): dp.append(number) else: dp[pos] = number return len(dp)"},{"question":"You have been assigned to develop a system that validates properties of numbers for a high-speed trading engine. One critical requirement is to efficiently determine if given numbers are powers of two. Your task is to implement this validation function. Function Signature ```python def is_power_of_two(n: int) -> bool: ``` Input * **n** (int): The input integer to check. Output * **bool**: Returns `True` if the number is a power of two, otherwise `False`. Constraints * The input number can be any integer, both positive and negative. # Scenario The system must ensure optimal performance due to the high volume of numbers being checked concurrently. Given the sensitivity, handle any unexpected input types gracefully. # Example ```python >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(16) True >>> is_power_of_two(0) False >>> is_power_of_two(-2) False ``` Notes * Powers of two include numbers like 1, 2, 4, 8, 16, etc. * Ensure the function handles edge cases like zero and negative numbers correctly. * Implement the solution in a way that guarantees minimal execution time, leveraging bitwise operations where applicable.","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer n is a power of two. Parameters: n (int): The integer to check. Returns: bool: True if n is a power of two, False otherwise. if n <= 0: return False # A number n is a power of two if and only if n & (n - 1) == 0 return (n & (n - 1)) == 0"},{"question":"# File Path Resolution **Problem Statement:** Write a Python function `full_path(file)` that takes a single string representing a file path as input and returns the full absolute path to the file, resolving any user directory shortcuts (like `~`) and relative paths. **Function Signature:** ```python def full_path(file: str) -> str: pass ``` **Input:** - `file`: A string representing the file path, which may include relative paths, user directory shortcuts (`~`), or both. **Output:** - Returns a string representing the absolute path of the file. **Constraints:** - The input path will always be a string. - The input path may be an empty string, a relative path, an absolute path, or contain user directory shortcuts. **Examples:** ```python # Example 1 print(full_path(\\"~/documents/project\\")) # Suppose the user home directory is \\"/home/user\\", the output should be \\"/home/user/documents/project\\" # Example 2 print(full_path(\\"./test/file.txt\\")) # If the current working directory is \\"/home/user\\", the output should be \\"/home/user/test/file.txt\\" # Example 3 print(full_path(\\"/etc/config.yaml\\")) # The output should be \\"/etc/config.yaml\\" ``` **Additional Notes:** - Your implementation should handle the edge cases, such as empty strings and paths that resolve to non-existent directories (though it does not need to check if the path actually exists). - You can assume the environment in which this function is running allows standard library usage.","solution":"import os def full_path(file: str) -> str: Returns the absolute path of a given file path, resolving any user directory shortcuts (~) and relative paths. return os.path.abspath(os.path.expanduser(file))"},{"question":"Context You are implementing a real-time monitoring system for a distributed application where consistency of data between nodes is crucial. Occasionally, due to network issues or system errors, a single additional character might get introduced in one of the dataset nodes. As part of the debugging toolkit, one of the essential utilities is to pinpoint this additional character to help resolve inconsistencies rapidly. Task Write a function `find_extra_character(s: str, t: str) -> str` that identifies the extra character added to string `t`. String `t` is formed by shuffling string `s` and adding one additional character. Function Signature ```python def find_extra_character(s: str, t: str) -> str: ... ``` Input * `s`: A string consisting solely of lowercase letters (1 ≤ len(s) ≤ 10^5). * `t`: A string consisting solely of lowercase letters (len(t) = len(s) + 1). Output * A single character which is the additional character added to `t`. Constraints * The input strings only consist of lowercase English letters. * The function should execute efficiently with regard to time and space complexity. Examples ```python print(find_extra_character(\\"abcd\\", \\"abecd\\")) # Output: \'e\' print(find_extra_character(\\"abc\\", \\"abcd\\")) # Output: \'d\' ``` Notes * You need to ensure that your function handles large strings effectively, keeping in mind the constraints and performance requirements. * Use the properties of XOR as demonstrated in the initial snippet to implement your solution.","solution":"def find_extra_character(s: str, t: str) -> str: Identifies the extra character added to string t, which is formed by shuffling string s and adding one additional character. Uses XOR operation to efficiently find the extra character. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"Scenario: You are developing a new feature in a software application that requires searching for a specific entry in a sorted dataset of user records. To maximize efficiency, given that user records are generally uniformly distributed, you are tasked with implementing the Interpolation Search algorithm. Problem Statement: Write a function `custom_interpolation_search` that takes a sorted list of integers `data` and an integer `target` as input and returns the index of the `target` in the `data` list using the Interpolation Search algorithm. If the `target` is not found in the list, return `-1`. Function Signature: ```python def custom_interpolation_search(data: List[int], target: int) -> int: pass ``` Input: * `data`: A list of integers, sorted in increasing order, representing the dataset to search within. * `target`: An integer, the value to search for within the `data`. Output: * Return the index of `target` if it is found in the `data`, otherwise return `-1`. Constraints: 1. The length of `data` will be in the range [0, 10^6]. 2. All integers in `data` will be in the range `[-10^6, 10^6]`. 3. The algorithm should handle edge cases smoothly. Example: ```python assert custom_interpolation_search([10, 20, 30, 40, 50], 30) == 2 assert custom_interpolation_search([10, 20, 30, 40, 50], 25) == -1 assert custom_interpolation_search([], 10) == -1 assert custom_interpolation_search([5], 5) == 0 assert custom_interpolation_search([1, 2, 3, 4, 5], 5) == 4 ``` Performance Requirements: The function should aim to have a time complexity of O(log(log n)) for the best case scenario and should use a constant amount of extra space, O(1). Notes: * Validate and handle special cases such as an empty list or uniform values within the list. * Ensure the function is efficient and handles the given constraints appropriately.","solution":"from typing import List def custom_interpolation_search(data: List[int], target: int) -> int: Performs an interpolation search on a sorted list of integers. Args: data (List[int]): A list of sorted integers. target (int): The target value to search for. Returns: int: The index of the target within the data list, or -1 if not found. if not data: return -1 low = 0 high = len(data) - 1 while low <= high and target >= data[low] and target <= data[high]: if low == high: if data[low] == target: return low return -1 pos = low + ((high - low) // (data[high] - data[low]) * (target - data[low])) if pos >= len(data) or pos < 0: return -1 if data[pos] == target: return pos if data[pos] < target: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question: You are tasked with implementing a priority queue using a binary heap. A priority queue is an advanced form of a queue where each element is associated with a priority, and the element with the highest priority is dequeued before other elements. Requirements: 1. Implement a class `PriorityQueue` with the following methods: - `__init__(self)`: Initializes an empty priority queue. - `enqueue(self, value, priority)`: Adds a value with a given priority to the priority queue. - `dequeue(self)`: Removes and returns the element with the highest priority. - `peek(self)`: Returns the element with the highest priority without removing it. - `is_empty(self)`: Returns `True` if the priority queue is empty, `False` otherwise. - `size(self)`: Returns the number of elements in the priority queue. 2. Utilize a binary heap for internal storage to ensure the operations are efficient. 3. Provide edge cases handling for trying to dequeue or peek from an empty priority queue. Example: ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 2) pq.enqueue(\\"task3\\", 3) print(pq.dequeue()) # Output: \\"task3\\" print(pq.peek()) # Output: \\"task2\\" print(pq.size()) # Output: 2 pq.dequeue() pq.dequeue() print(pq.is_empty()) # Output: True ``` Constraints: - Enqueued values can be any comparable data type. - Priorities are integers, with higher integers representing higher priority. - The `enqueue`, `dequeue`, and `peek` operations should run in O(log n) time complexity. Implement your solution in Python.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] def enqueue(self, value, priority): heapq.heappush(self._heap, (-priority, value)) def dequeue(self): if self.is_empty(): raise IndexError(\\"Priority Queue is empty\\") return heapq.heappop(self._heap)[1] def peek(self): if self.is_empty(): raise IndexError(\\"Priority Queue is empty\\") return self._heap[0][1] def is_empty(self): return len(self._heap) == 0 def size(self): return len(self._heap)"},{"question":"Objective Implement a function to find the maximum sum of a contiguous subarray using Kadane\'s Algorithm. Your function should be efficient and handle various edge cases. Context You are given a list of integers representing stock prices over several days. You want to determine the maximum profit you could have achieved if you were allowed to buy and sell once during the period. Since you can only trade once, you\'re trying to maximize the difference between buying low and selling high on a single contiguous sub-period. Implementation Requirements * Implement a function **max_contiguous_subsequence_sum(arr: List[int]) -> int**. * **Input**: - **arr** (List[int]): A list of integers representing stock prices. * **Output**: - **int**: The maximum sum of a contiguous subsequence which represents the maximum possible profit. Constraints * The array can contain both positive and negative integers. * The array can be empty. * The array can contain duplicates. Example Scenarios 1. **Example 1**: * **Input**: `[-2, 3, 8, -1, 4]` * **Output**: `14` - Explanation: The subarray `[3, 8, -1, 4]` gives the maximum sum of 14. 2. **Example 2**: * **Input**: `[-1, 1, 0]` * **Output**: `1` - Explanation: The subarray `[1]` gives the maximum sum of 1. 3. **Example 3**: * **Input**: `[-1, -3, -4]` * **Output**: `-1` - Explanation: The subarray `[-1]` gives the maximum sum of -1. 4. **Example 4**: * **Input**: `[-2, 3, 8, -12, 8, 4]` * **Output**: `12` - Explanation: The subarray `[8, 4]` gives the maximum sum of 12.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Uses Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. if not arr: return 0 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Scenario You are given a large dataset that needs to be compactly represented to save storage space. This dataset contains numerous repetitive sequences of characters, making it a suitable candidate for the Run-Length Encoding (RLE) compression algorithm. Your task is to implement these encoding and decoding techniques to handle the data efficiently. # Problem Statement Implement a Run-Length Encoder and Decoder. # Function Signature ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Requirements * **Function 1: encode_rle** - **Input**: A string `input` (0 <= len(input) <= 10^5) consisting of alphanumeric characters. - **Output**: A compressed string using Run-Length Encoding. * **Function 2: decode_rle** - **Input**: A string `input` (encoded by RLE rules). - **Output**: The original uncompressed string. # Constraints 1. The encoding should not use any external libraries. 2. If the input string to `encode_rle` has no repeated characters, it should return the input prefixed by \'1\' for each character. 3. Ensure correctness for both upper and lower case characters. # Example 1. **Encoding Example**: - Input: `\\"aaabb\\"` - Output: `\\"3a2b\\"` 2. **Decoding Example**: - Input: `\\"3a2b\\"` - Output: `\\"aaabb\\"` # Edge Case Examples 1. **Encoding Edge Case**: - Input: `\\"\\"` (empty string) - Output: `\\"\\"` 2. **Decoding Edge Case**: - Input: `\\"\\"` - Output: `\\"\\"` 3. **Encoding No Repeating Characters**: - Input: `\\"abc\\"` - Output: `\\"1a1b1c\\"` 4. **Decoding No Repeating Characters**: - Input: `\\"1a1b1c\\"` - Output: `\\"abc\\"` Implement the functions to handle these requirements and provide reliable and efficient data compression and decompression.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] i = 0 while i < len(input): run_length = 1 while i + 1 < len(input) and input[i] == input[i + 1]: run_length += 1 i += 1 encoded_str.append(f\\"{run_length}{input[i]}\\") i += 1 return \\"\\".join(encoded_str) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = [] i = 0 while i < len(input): run_length = 0 while i < len(input) and input[i].isdigit(): run_length = run_length * 10 + int(input[i]) i += 1 if i < len(input): decoded_str.append(input[i] * run_length) i += 1 return \\"\\".join(decoded_str)"},{"question":"Zigzag Order Traversal of a Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in zigzag order. In zigzag order, elements are visited in a \'zigzag\' pattern: the first row is traversed from left to right, the second row from right to left, the third row from left to right, and so on. Input - A 2D list `matrix` containing `m` rows and `n` columns of integers. Output - A list containing all elements of the matrix in zigzag order. Constraints - 0 <= m, n <= 100 (the dimensions of the matrix are non-negative and each dimension is at most 100). Example # Input ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` # Output ```python [1, 2, 3, 6, 5, 4, 7, 8, 9] ``` Scenario Consider you have a large LED display (represented as a matrix) where the goal is to light up the LEDs in a zigzag order. Your task is to figure out the sequence of lighting up the LEDs. Function Signature ```python def zigzag_traversal(matrix: List[List[int]]) -> List[int]: pass ```","solution":"from typing import List def zigzag_traversal(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in zigzag order. if not matrix: return [] result = [] for i, row in enumerate(matrix): if i % 2 == 0: # Even row: left to right result.extend(row) else: # Odd row: right to left result.extend(row[::-1]) return result"},{"question":"# Graph Reachability Assessment Objective: You are tasked with implementing a function to compute the transitive closure of a directed graph. Given the number of vertices and a list of directed edges, you need to determine the reachability matrix such that `matrix[i][j] = 1` if there is a path from vertex `i` to vertex `j`, otherwise `matrix[i][j] = 0`. Input: - An integer `n` representing the number of vertices `0 to n-1`. - A list of tuples `edges` where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Output: - A 2D list `closure` where `closure[i][j]` is `1` if there is a path from vertex `i` to vertex `j`, otherwise `0`. Constraints: - `1 <= n <= 1000` - Number of edges, `0 <= |edges| <= 10000` Requirements: - The solution must run within the provided constraints. - Optimize for both time and space without sacrificing clarity. Example: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3)] # Expected Output: # [[1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1]] def compute_transitive_closure(n, edges): # Your code here pass print(compute_transitive_closure(n, edges)) ``` Explanation: 1. From vertex `0`, you can reach 1, 2, and 3 through a series of directed edges. 2. From vertex `1`, you can reach 2 and 3. 3. From vertex `2`, you can reach 3. 4. From vertex `3`, you cannot reach any other vertex except itself.","solution":"def compute_transitive_closure(n, edges): Computes the transitive closure of a directed graph with n vertices and given edges. The output is a 2D list where cell (i, j) is 1 if there\'s a path from i to j, and 0 otherwise. # Initialize closure matrix with 0s and set diagonal to 1 (each node can reach itself) closure = [[0] * n for _ in range(n)] for i in range(n): closure[i][i] = 1 # Set the edges in the closure for u, v in edges: closure[u][v] = 1 # Floyd-Warshall algorithm to compute reachability matrix for k in range(n): for i in range(n): for j in range(n): if closure[i][k] and closure[k][j]: closure[i][j] = 1 return closure"},{"question":"# Question: Design a Circular Queue using a Static Array Objective Design and implement a circular queue using a static array with a fixed capacity. Ensure that the operations `enqueue`, `dequeue`, and `peek` adhere to O(1) time complexity. This problem helps assess understanding of data structure implementation, handling edge cases, and ensuring efficient operations. Detailed Description A circular queue (also known as a ring buffer) is a linear data structure that treats the array as circular. It allows efficient usage of space by reusing emptied slots. Tasks: 1. Implement the `CircularQueue` class. 2. Methods to be implemented: - `__init__(self, capacity)`: Initializes the queue with the specified capacity. - `enqueue(self, value)`: Adds a new value to the rear of the queue. Raises an error if the queue is full. - `dequeue(self)`: Removes and returns the front value from the queue. Raises an error if the queue is empty. - `peek(self)`: Returns the front value without removing it. Raises an error if the queue is empty. - `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. - `is_full(self)`: Returns `True` if the queue is full, otherwise `False`. - `__len__(self)`: Returns the number of items in the queue. Example Usage: ```python cq = CircularQueue(5) cq.enqueue(10) cq.enqueue(20) print(cq.dequeue()) # Output: 10 print(cq.peek()) # Output: 20 print(cq.is_empty()) # Output: False cq.enqueue(30) cq.enqueue(40) cq.enqueue(50) cq.enqueue(60) # Raises an error because the queue is full ``` Constraints: - Do not use Python\'s built-in queue libraries. - Handle edge cases such as circular wrap-around of indices. Bonus: As a bonus, implement a method `resize(new_capacity)` that dynamically changes the capacity of the queue while preserving the items.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity def __len__(self): return self.size def resize(self, new_capacity): if new_capacity < self.size: raise ValueError(\\"New capacity must be greater than the current number of elements\\") new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.size"},{"question":"# Insertion Sort Enhancement As a software developer at an e-commerce company, you\'ve been tasked to optimize the sorting algorithm for various data-intensive reporting features. The current implementation of the Insertion Sort works fine; however, it struggles with large datasets. The data you\'ll work with is primarily sales records, which are often somewhat sorted by date or sales volume but can become unsorted due to concurrent updates. This means the sorting problem often partially sorted arrays. Your task is to enhance the current Insertion Sort implementation with the following specifications: - Create an improved insertion sort algorithm that: - Retains the stability of the sort (relative order of equal elements). - Optimizes for partially sorted datasets. - Applies a threshold to switch to a more efficient sorting algorithm for large datasets. Implement the function `optimized_insertion_sort(arr, threshold)`, which accepts an array `arr` and a threshold `threshold`. If the array size is greater than the threshold, switch to an efficient sorting algorithm (like quicksort). Otherwise, use an optimized insertion sort to sort the array. Function Signature ```python def optimized_insertion_sort(arr: List[int], threshold: int) -> List[int]: pass ``` Input - `arr`: A list of integers representing the sales data. - `threshold`: An integer specifying the array size threshold for when to switch sorting algorithms. Output - A list of integers sorted in non-decreasing order. Constraints - The length of the array `arr` will be in the range `[0, 10^5]`. - The values of the array elements will be within `[-10^9, 10^9]`. Performance Requirements - The solution should perform efficiently on both small (few elements) and large datasets (up to 100,000 elements). Example ```python # Example 1 arr = [5, 2, 9, 1, 5, 6] threshold = 10 # Small array example, uses optimized insertion sort print(optimized_insertion_sort(arr, threshold)) # Output: [1, 2, 5, 5, 6, 9] # Example 2 arr = [50, 23, 93, 17, 77, 31, 44, 55, 20, 27] threshold = 5 # Large array example, switches to quicksort print(optimized_insertion_sort(arr, threshold)) # Output: [17, 20, 23, 27, 31, 44, 50, 55, 77, 93] ``` Notes - Think about handling arrays that are nearly-sorted to optimize the insertion sort process further. - Take care of edge cases such as empty arrays or completely sorted arrays.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: Simple insertion sort algorithm for reasonably small arrays. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def quicksort(arr: List[int]) -> List[int]: Quicksort algorithm for larger arrays. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def optimized_insertion_sort(arr: List[int], threshold: int) -> List[int]: Optimized sorting function that uses insertion sort for small arrays or quicksort for larger arrays based on a given threshold. if len(arr) <= threshold: return insertion_sort(arr) else: return quicksort(arr)"},{"question":"You are provided with the definition of the recursive binomial coefficient algorithm. Your task is to optimize this algorithm to handle larger values of n and k more efficiently. Specifically, you should write an iterative version of the binomial coefficient calculation that addresses the limitations of the recursive approach in terms of recursion depth and execution speed. # Function Signature: ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input: - **n** (int): A non-negative integer representing the total number of items. - **k** (int): A non-negative integer representing the number of items to choose. 0 <= k <= n. # Output: - **int**: The binomial coefficient C(n, k). # Constraints: - n and k are non-negative integers, and n >= k. - Your solution should handle large values efficiently, e.g., n, k up to 1000. # Performance Requirements: - Your solution should have a time complexity of O(min(k, n-k)) and a space complexity of O(1). # Examples: 1. iterative_binomial_coefficient(5, 0) -> 1 2. iterative_binomial_coefficient(8, 2) -> 28 3. iterative_binomial_coefficient(500, 300) -> 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 # Notes: - Your implementation should avoid using recursion to prevent stack overflow issues. - Aim for an efficient iterative solution that minimizes computation and memory usage.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using an iterative approach. Args: n (int): Total number of items. k (int): Number of items to choose. Returns: int: The binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 # C(n, k) = C(n, n-k) (Taking advantage of symmetry) k = min(k, n - k) coeff = 1 for i in range(k): coeff *= (n - i) coeff //= (i + 1) return coeff"},{"question":"# Context In the field of data science and machine learning, it\'s often necessary to measure the similarity between two data points. One popular method for vector comparison is the cosine similarity metric, which measures the cosine of the angle between two vectors. This is particularly useful in high-dimensional spaces such as text document vectors, where the actual magnitudes of the vectors are of less importance than their direction. # Task You are required to implement a function to calculate the cosine similarity between two given vectors. Vectors are represented as lists of floats of the same length. Your function should handle potential edge cases and ensure correctness. # Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: ``` # Input - `vec1`: A list of floats representing the first vector. - `vec2`: A list of floats representing the second vector. # Output - Returns a float that represents the cosine similarity between the two input vectors. # Constraints & Requirements - The two input vectors must be of the same length; otherwise, raise a `ValueError`. - If either vector is all zeros, a `ValueError` should be raised since cosine similarity is undefined in such cases. - The vectors are guaranteed to have at least one element. # Example ```python # Example 1 vec1 = [1, 1, 1] vec2 = [1, 2, -1] assert abs(cosine_similarity(vec1, vec2) - 0.47140452079103173) < 1e-9 # Example 2 vec1 = [0] vec2 = [1] assert abs(cosine_similarity(vec1, vec2) - 0.0) < 1e-9 # Example 3 vec1 = [1, 2, 3] vec2 = [4, 5, 6] assert abs(cosine_similarity(vec1, vec2) - 0.9746318461970762) < 1e-9 ``` # Notes - Do not use any external libraries for the vector calculations; you must implement the necessary computations directly. - Ensure your implementation is efficient with an O(n) time complexity, where n is the number of elements in the vectors.","solution":"import math def cosine_similarity(vec1: list, vec2: list) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Cosine similarity is undefined for vectors with zero magnitude\\") cosine_sim = dot_product / (magnitude_vec1 * magnitude_vec2) return cosine_sim"},{"question":"Problem Statement You are given a sorted array of integers and a target value. Your task is to implement the `ternary_search` function to determine if the target value exists within the array. The function should return the index of the target value if found. If the target value is not present in the array, return -1. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` Input and Output Format - **Input**: - `left` (int): The starting index of the search interval, initially set to 0. - `right` (int): The ending index of the search interval, initially set to length of array - 1. - `key` (int): The target value to search in the array. - `arr` (List[int]): A sorted list of integers. - **Output**: - (int): Index of `key` in `arr` if present, otherwise -1. Constraints - The array `arr` will contain at most 10^5 integers. - The integers in `arr` will lie in the range of -10^9 to 10^9. - The target value `key` will be within the same range. Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 assert ternary_search(0, len(arr) - 1, key, arr) == 4 # Example 2 arr = [2, 4, 6, 8, 10, 12, 14] key = 7 assert ternary_search(0, len(arr) - 1, key, arr) == -1 # Example 3 arr = [1, 3, 5, 7, 9] key = 1 assert ternary_search(0, len(arr) - 1, key, arr) == 0 ``` Notes 1. Ensure that your implementation avoids common pitfalls such as off-by-one errors in index calculation. 2. Test your solution with both edge cases and typical cases to ensure accuracy. 3. Analyze the time and space complexity of your solution and justify any design decisions made to optimize performance.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on a sorted array to find the index of a given key. Args: left (int): Starting index of the search interval. right (int): Ending index of the search interval. key (int): The target value to search in the array. arr (List[int]): A sorted list of integers. Returns: int: Index of key in arr if present, otherwise -1. while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are working on a classic cryptography project and need to implement an encoding scheme known as the Atbash cipher. This cipher is a simple substitution cipher where each letter of the alphabet is mapped to its counterpart from the opposite end of the alphabet. For instance, \'A\' becomes \'Z\', \'B\' becomes \'Y\', and so on. Given an input string, implement the Atbash cipher encoding. Non-alphabet characters should be left unchanged, and the case of the letters should be preserved. # Function Signature ```python def atbash_cipher(text: str) -> str: ``` # Input * `text`: A string containing the text to be encoded. The string can contain letters (both uppercase and lowercase), digits, spaces, and punctuation marks. # Output * The function should return a new string where each alphabetical character has been encrypted using the Atbash cipher, while non-alphabet characters remain unchanged. # Example ```python # Example 1: input_text = \\"Attack at dawn\\" output_text = atbash_cipher(input_text) print(output_text) # Output should be \\"Zggzxp zg wzdm\\" # Example 2: input_text = \\"Hello, World!\\" output_text = atbash_cipher(input_text) print(output_text) # Output should be \\"Svool, Dliow!\\" ``` # Constraints * The input string will have at most length 10^5. **Note:** The encoding and decoding process is the same for the Atbash cipher. # Additional Information * Ensure that your solution adheres to the O(n) time complexity.","solution":"def atbash_cipher(text: str) -> str: def atbash_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) # 219 = \'a\' + \'z\' elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) # 155 = \'A\' + \'Z\' return c return \'\'.join(atbash_char(c) for c in text)"},{"question":"# Prime Checker with Optimizations **Scenario**: You are developing a feature for a cryptography library that requires determining the primality of large numbers efficiently. Implement a function called `is_prime_optimized`, an optimized version of the prime checking algorithm, that not only checks for primality but also incorporates optimizations from prime-based checking for higher divisors. **Function signature**: ```python def is_prime_optimized(n: int) -> bool: pass ``` **Input**: - `n`: A positive integer ((1 leq n leq 10^9)). **Output**: - Returns `True` if `n` is a prime number, otherwise returns `False`. **Constraints**: - Consider edge cases for small values of ( n ) and large prime checks. - Aim for a solution with a time complexity of ( O(sqrt{n}) ) or better. **Example**: ```python assert is_prime_optimized(1) == False assert is_prime_optimized(2) == True assert is_prime_optimized(4) == False assert is_prime_optimized(17) == True assert is_prime_optimized(25) == False assert is_prime_optimized(29) == True ``` **Notes**: - Ensure your implementation is optimized to handle the upper constraint efficiently. - Provide detailed docstrings with your code to explain your logic.","solution":"def is_prime_optimized(n: int) -> bool: Checks if a given number n is a prime number or not using an optimized algorithm. Args: n (int): A positive integer to check for primality. Returns: bool: True if n is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n > 1 else False if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are given a binary tree where each node contains a unique integer value. The binary tree is represented by the `Node` class shown below: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function `inorder` that performs an in-order traversal on the given binary tree. Implement both an iterative and a recursive version of the in-order traversal algorithm. The iterative version should use an explicit stack, while the recursive version should use the system call stack. # Function Signature ```python def inorder(root: Node) -> List[int]: pass def inorder_rec(root: Node, res: List[int] = None) -> List[int]: pass ``` # Input - `root`: The root node of the binary tree. If the tree is empty, `root` will be `None`. # Output - For both functions, return a list of integers representing the in-order traversal of the tree. # Constraints - The binary tree will have at most `1000` nodes. # Example ```python # Create a tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Notes - Ensure to address performance requirements primarily through the iterative version as it is more commonly used for large trees where system call stack might overflow. - Handle the edge cases of empty trees and single-node trees effectively. - Demonstrate both depth of understanding (through the recursive approach) and efficiency (through the iterative approach).","solution":"from typing import List, Optional # Definition for a binary tree node. class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def inorder(root: Optional[Node]) -> List[int]: Iterative in-order traversal. stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root: Optional[Node], res: List[int] = None) -> List[int]: Recursive in-order traversal. if res is None: res = [] if root: inorder_rec(root.left, res) res.append(root.val) inorder_rec(root.right, res) return res"},{"question":"You are given an (n times n) grid representing the edge weights of a graph. Each cell ((i, j)) in the grid represents the weight of the edge from node (i) to node (j). If there is no direct edge between node (i) and node (j), the weight will be a large value (you can consider it as a representation of infinity). Your task is to implement an algorithm that computes the shortest path between every pair of nodes. # Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: pass ``` # Input * An integer (n) representing the number of nodes. * A list of lists (adjacency_matrix) where each inner list has (n) floats. The (j)-th float in the (i)-th list represents the edge weight from node (i) to node (j). # Output * Return a list of lists where the (j)-th float in the (i)-th list represents the shortest distance from node (i) to node (j). # Constraints 1. (1 leq n leq 100) 2. The edge weights are non-negative floats, and the value representing no direct edge can be assumed to be (float(\'inf\')). # Example Input: ```python adjacency_matrix = [ [0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0], ] ``` Output: ```python [ [0, 0.1, 0.101, 0.142, 0.277], [0.436, 0, 0.191, 0.192, 0.343], [0.245, 0.345, 0, 0.333, 0.484], [0.706, 0.27, 0.461, 0, 0.151], [0.555, 0.119, 0.31, 0.311, 0], ] ``` # Notes - Ensure that you handle self-loops properly, i.e., the distance from a node to itself should always be zero. - Consider edge cases such as disconnected nodes, represented by `float(\'inf\')`. - Optimize your solution keeping in mind the (O(n^3)) time complexity of the Floyd–Warshall algorithm.","solution":"from typing import List def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Uses the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes. n = len(adjacency_matrix) # Initialize distance matrix with the given adjacency matrix dist = [row[:] for row in adjacency_matrix] # Applying Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] + dist[k][j] < dist[i][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"# Problem: Enhanced Kruskal\'s Algorithm to calculate number of connected components Implement a function that not only computes the Minimum Spanning Tree (MST) of an undirected graph using Kruskal’s algorithm but also returns the number of connected components in the graph. # Function Signature ```python def kruskal_with_components(vertex_count: int, edges: List[Edge]) -> Tuple[int, int]: Args: - vertex_count (int): Number of vertices in the graph - edges (List[Edge]): List of Edge objects representing the graph Returns: - Tuple[int, int]: A tuple containing two integers: 1) sum of weights of the minimum spanning tree, 2) number of connected components in the graph pass ``` # Input Format You need to read the input in the following format: 1. An integer `vertex_count V` representing the number of vertices. 2. An integer `edge_count E` representing the number of edges. 3. Next `E` lines, each containing three integers `u, v, w` representing an edge with vertices `u` and `v` and weight `w`. # Output Format Return a tuple of two integers: 1. The sum of weights of the edges in the minimum spanning tree. 2. The number of connected components in the graph. # Constraints * 1 <= V <= 1000 * 0 <= E <= (V * (V - 1)) / 2 * 1 <= w <= 1000 # Example ```python # Input vertex_count = 5 edges = [ Edge(0, 1, 3), Edge(0, 2, 8), Edge(1, 3, 5), Edge(2, 3, 2), Edge(2, 4, 4), Edge(3, 4, 6), ] # Expected Output result = (14, 1) # MST weight sum is 14, and graph is fully connected (1 component) # Input vertex_count = 5 edges = [ Edge(0, 1, 10), ] # Expected Output result = (0, 4) # No MST (0 weight), 4 disconnected components ``` # Explanation: 1. The example shows a fully connected graph forming a single MST with weight sum 14. 2. Another example shows a sparsely connected graph resulting in multiple disconnected components. Use the provided helper classes (`Edge` and `DisjointSet`) for your implementation. You should ensure thorough error handling and edge case considerations in your solution.","solution":"from typing import List, Tuple class Edge: def __init__(self, u: int, v: int, weight: int): self.u = u self.v = v self.weight = weight def find(subsets, node): if subsets[node] != node: subsets[node] = find(subsets, subsets[node]) return subsets[node] def union(subsets, ranks, u, v): root_u = find(subsets, u) root_v = find(subsets, v) if ranks[root_u] < ranks[root_v]: subsets[root_u] = root_v elif ranks[root_u] > ranks[root_v]: subsets[root_v] = root_u else: subsets[root_v] = root_u ranks[root_u] += 1 def kruskal_with_components(vertex_count: int, edges: List[Edge]) -> Tuple[int, int]: result = 0 # Initialize result (sum of weights of the MST) subsets = [i for i in range(vertex_count)] ranks = [0] * vertex_count edges = sorted(edges, key=lambda edge: edge.weight) connected_components_count = vertex_count for edge in edges: u, v, w = edge.u, edge.v, edge.weight if find(subsets, u) != find(subsets, v): result += w union(subsets, ranks, u, v) connected_components_count -= 1 return result, connected_components_count"},{"question":"# Coding Challenge: Find the nth Digit in an Infinite Sequence You\'ve been hired to build a digital system that requires the extraction of specific digits from an extremely large sequence of integers (1, 2, 3, ...). Your task is to write a function `find_nth_digit` that accurately returns the nth digit in this infinite sequence of integers. Function Signature: ```python def find_nth_digit(n: int) -> int: ``` Input: * An integer `n` where 1 <= n <= 2*10^9, representing the position of the digit in the infinite sequence. Output: * An integer representing the digit located at the nth position in the sequence. Constraints: * Performance should handle large values of `n` efficiently, adhering to O(log n) time complexity. * Space utilization should remain constant, O(1). Example: ```plaintext find_nth_digit(3) Output: 3 Explanation: The sequence starts at \'123...\', the 3rd digit is \'3\'. find_nth_digit(11) Output: 0 Explanation: The sequence starts at \'123456789101112...\', the 11th digit is \'0\' from \'10\'. ``` Edge Cases: * When `n` maps to single digits (e.g., 1-9). * Larger values of `n` requiring traversal across multi-digit numbers. * Verify the handling and positioning when transitioning from one digit-length range to another. Test Your Solution: Ensure your implementation passes the provided examples and handles edge cases efficiently.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Find the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where nth digit is located start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# FizzBuzz Assessment Question Objective Demonstrate your ability to implement an iteration-based algorithm with specific conditional logic by solving a variant of the FizzBuzz problem. Problem Statement Write a function `fizzbuzz_custom` that takes two parameters, `n` and `replacements`. The function should return a list of numbers from 1 to `n` with specific substitutions based on the `replacements` dictionary. Each key in the `replacements` dictionary will be an integer, and the value will be the string to replace any multiple of that integer. Function Signature ```python def fizzbuzz_custom(n: int, replacements: dict) -> list: pass ``` Input - `n` (int): An integer (n >= 1). - `replacements` (dict): A dictionary where keys are integers and values are their respective replacement strings. Output - (list): A list of integers and/or strings according to the specified rules. Constraints - `replacements` dictionary will have unique positive integer keys. - `n` will never be less than 1. Task Implement the function following these steps: 1. Iterate from 1 to `n`. 2. For each number, check if it is a multiple of any key in the `replacements` dictionary. 3. If multiple keys match, concatenate their corresponding values. 4. If no keys match, use the number itself. Example ```python # Example Input n = 15 replacements = {3: \'Fizz\', 5: \'Buzz\'} # Example Output [ 1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\' ] # Another Example Input n = 10 replacements = {2: \'Two\', 3: \'Three\'} # Example Output [ 1, \'Two\', \'Three\', \'Two\', 5, \'TwoThree\', 7, \'Two\', \'Three\', \'Two\' ] ```","solution":"def fizzbuzz_custom(n: int, replacements: dict) -> list: Returns a list of numbers from 1 to n with specific substitutions based on the replacements dictionary. result = [] for i in range(1, n + 1): substitution = \'\' for key in replacements: if i % key == 0: substitution += replacements[key] if substitution: result.append(substitution) else: result.append(i) return result"},{"question":"# Question: First Occurrence in a Sorted Array Scenario You are working on a data retrieval system where you frequently need to locate elements in large, sorted datasets. To efficiently retrieve the first occurrence of a specified element, you decide to implement a binary search algorithm. Problem Write a function named `first_occurrence` that takes two arguments: `array` (a list of integers sorted in increasing order) and `query` (an integer to search for). The function should return the index of the first occurrence of the `query` in the `array`. If the `query` is not found, the function should return `-1`. Input - `array`: a list of integers sorted in increasing order. The length of `array` will not exceed (10^6). - `query`: an integer to find in the `array`. Output - An integer representing the index of the first occurrence of `query` in `array` or `-1` if `query` is not present. Constraints - The `array` is sorted in increasing order. - The function should have a time complexity of O(log n). Performance Requirements - The solution should be optimized to handle the upper constraint of (10^6) elements efficiently. Example ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 # The first occurrence of 2 is at index 1. print(first_occurrence(array, query)) # Output: 1 array = [5, 7, 7, 8, 8, 10] query = 6 # 6 is not in the array. print(first_occurrence(array, query)) # Output: -1 ``` Implementation Based on your understanding of binary search and the constraints given, write a function `first_occurrence` to solve the problem efficiently.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of `query` in `array`. If `query` is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Move left to find the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question You are tasked to implement a Trie (prefix tree) to optimize auto-completion suggestions for a search engine. A Trie is a tree-like data structure that stores a dynamic dataset of strings, providing efficient operations for insertion, deletion, and prefix-based search. **Objective:** Implement the following methods of the Trie structure: 1. **`insert(word: str) -> None`:** Inserts `word` into the trie. 2. **`search(word: str) -> bool`:** Returns `True` if the exact `word` is in the trie, `False` otherwise. 3. **`starts_with(prefix: str) -> bool`:** Returns `True` if there exists any word in the trie that starts with the given `prefix`, `False` otherwise. **Example:** ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # Returns True assert trie.search(\\"app\\") == False # Returns False assert trie.starts_with(\\"app\\") == True # Returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # Returns True ``` **Constraints:** - All words are comprised of lowercase English letters (`a-z`). - The input word length will not exceed 100 characters. - The number of `insert`, `search`, and `starts_with` operations will not exceed 10^4. **Instructions:** 1. Implement the provided class structure with the required methods. 2. Ensure your code handles all edge cases like empty strings and searches for both present and missing words. 3. Optimize for performance considering both time and space constraints. 4. Provide clear and concise code with appropriate comments. ```python # Your solution import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: # Implement this method pass def search(self, word: str) -> bool: # Implement this method pass def starts_with(self, prefix: str) -> bool: # Implement this method pass ```","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Scenario You are a software engineer tasked with developing a function to store an entire binary tree structure and later reconstruct it accurately. This functionality will be used in a system that regularly backs up and restores tree data structures. # Problem Statement Implement the functions `serialize(root: TreeNode) -> str` and `deserialize(data: str) -> TreeNode` which perform the following operations: * **serialize**: Given the root of a binary tree, serialize the tree into a string. * **deserialize**: Given the serialized string, deserialize it back into the binary tree. The TreeNode class is defined as follows: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ``` # Input and Output Formats serialize(root) * **Input**: `root` is the root node of a binary tree. * **Output**: A single string representing the serialized binary tree. deserialize(data) * **Input**: `data` is a string representing the serialized binary tree. * **Output**: The root node of the deserialized binary tree. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * Node values are in the range [-1000, 1000]. # Example ```python # Example Input root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialize data = serialize(root) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize new_root = deserialize(data) # new_root is a reconstructed tree with the same structure and values as the original. ``` Your task is to complete the implementation of the `serialize` and `deserialize` functions to fulfill the above requirements.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def helper(node): if not node: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def helper(values): value = next(values) if value == \\"#\\": return None node = TreeNode(int(value)) node.left = helper(values) node.right = helper(values) return node value_iterator = iter(data.split()) return helper(value_iterator)"},{"question":"In this coding task, you are required to implement the bitonic sort algorithm as per the given constraints and further enhance it to handle a broader range of input scenarios. # Task: 1. **Implement Bitonic Sort**: Modify the existing `bitonic_sort` function to sort an array of integers in both increasing and decreasing orders. The input array size will always be a power of 2. 2. **Generalize Array Size**: Extend the function to handle arrays of any size by: - Padding the array with a large maximum value (e.g., `float(\'inf\')`) to make its size a power of 2. - Removing the padding elements after sorting while ensuring the rest of the array is correctly sorted. # Function Signature: ```python def generalized_bitonic_sort(arr: list, reverse: bool = False) -> list: pass ``` # Expected Input and Output: **Input**: - An array of integers `arr`, where the size of the array is any non-negative integer. - A boolean `reverse` indicating the sorting order (default is `False` for ascending order). **Output**: - A sorted array in the specified order. If `reverse` is `True`, the array must be sorted in descending order. Otherwise, it should be sorted in ascending order. # Constraints: - The input array can have size ranging from (0) to (10^5). - The integer elements of the array will be in the range ([-10^9, 10^9]). # Example: ```python assert generalized_bitonic_sort([3, 7, 2, 5], reverse=False) == [2, 3, 5, 7] assert generalized_bitonic_sort([3, 7, 2, 5], reverse=True) == [7, 5, 3, 2] assert generalized_bitonic_sort([1], reverse=False) == [1] assert generalized_bitonic_sort([], reverse=False) == [] ``` # Special Consideration - Ensure the function raises a ValueError for any input that doesn\'t adhere to the expected input format or constraints. - Carefully handle edge cases, such as arrays of size 0, 1, or sizes that aren\'t powers of 2.","solution":"import math from typing import List def bitonic_sort(arr: List[int], low: int, cnt: int, order: bool): Helper function to perform bitonic sort on a subarray if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) # First half in ascending order bitonic_sort(arr, low + k, k, False) # Second half in descending order bitonic_merge(arr, low, cnt, order) def bitonic_merge(arr: List[int], low: int, cnt: int, order: bool): Helper function to merge bitonically sorted subarrays if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (order and arr[i] > arr[i + k]) or (not order and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, order) bitonic_merge(arr, low + k, k, order) def generalized_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Generalized bitonic sort to handle arrays of any size if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements must be integers\\") n = len(arr) if n == 0 or n == 1: return arr # Find the next power of 2 greater than or equal to n next_power_of_2 = 1 << (n - 1).bit_length() # Pad the array with float(\'inf\') to make its length a power of 2 padded_arr = arr + [float(\'inf\')] * (next_power_of_2 - n) # Perform bitonic sort bitonic_sort(padded_arr, 0, next_power_of_2, not reverse) # Remove the padding elements and return the sorted list result = [x for x in padded_arr if x != float(\'inf\')] return result"},{"question":"# Scenario You are working on a project involving data encryption and you need to frequently convert integers to different base representations and back. You have decided to implement these functionalities yourself to get a deeper understanding of how they work and to ensure flexibility in adjusting for specific requirements. # Task Implement two functions: `int_to_base()` and `base_to_int()`, to handle conversions between an integer and its string representation in another base (between 2 and 36). # Function Specification 1. `int_to_base(num, base) -> str` - **Input**: - `num`: an integer to convert (negative numbers allowed) - `base`: the base to convert to (integer between 2 and 36) - **Output**: A string representing the number in the specified base - **Constraints**: - Handle bases between 2 and 36 inclusively. - Include a \'-\' sign for negative numbers. - **Performance Requirements**: - The solution should run efficiently for large integers up to typical system limits. 2. `base_to_int(str_to_convert, base) -> int` - **Input**: - `str_to_convert`: the string representation of the number in the given base - `base`: the base the string is in (integer between 2 and 36) - **Output**: An integer converted from the base string - **Constraints**: - Handle bases between 2 and 36 inclusively. - The input string should be correctly formatted to represent a number in the given base. - **Performance Requirements**: - The conversion algorithm should handle strings of length up to 1000 characters efficiently. # Examples ```python print(int_to_base(5, 2)) # Output: \'101\' print(int_to_base(-255, 16)) # Output: \'-FF\' print(base_to_int(\'101\', 2)) # Output: 5 print(base_to_int(\'-FF\', 16)) # Output: -255 ``` # Implementation Notes - Ensure robust error handling for invalid base values and conversion errors. - Optimize for both time and space performance. - Avoid using Python\'s built-in conversion functions for educational purposes, though these might be discussed in post-assessment reviews.","solution":"def int_to_base(num, base): Converts an integer to a string representation in a given base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] negative = num < 0 num = abs(num) while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Converts a string representation of a number in a given base back to an integer. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36\\") if not str_to_convert: raise ValueError(\\"Input string cannot be empty\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {ch: idx for idx, ch in enumerate(digits)} negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] result = 0 for ch in str_to_convert: result = result * base + value_map[ch] return -result if negative else result"},{"question":"Inorder Successor in a Binary Search Tree Given a Binary Search Tree (BST) and a node `p` in it, write a function to find the inorder successor of that node in the BST. The inorder successor of a node `p` is the node with the smallest key greater than `p.val`. # Function Signature ```python def inorder_successor(root: Node, p: Node) -> Node: pass ``` # Input - `root`: The root node of the BST. - `p`: A node in the BST for which you need to find the inorder successor. # Output - Return the inorder successor of node `p`. If the node has no inorder successor, return `None`. # Constraints - All nodes have unique values. - The function must have an average time complexity of O(h) where h is the height of the tree. - You may assume that `root` is not `None` and `p` is a valid node in the tree. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right if __name__ == \'__main__\': n1 = Node(20) n2 = Node(10) n3 = Node(30) n4 = Node(5) n5 = Node(15) n6 = Node(25) n7 = Node(35) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_successor(n1, n2).val == 15 # 10\'s successsor is 15 assert inorder_successor(n1, n5).val == 20 # 15\'s successor is 20 assert inorder_successor(n1, n6).val == 30 # 25\'s successor is 30 assert inorder_successor(n1, n7) is None # 35 has no successor ``` # Scenario You are working on a feature that involves navigating through products stored in a binary search tree according to their SKU numbers (which are unique). This feature will allow the current product to move to the next one based on increasing SKU numbers.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_successor(root: Node, p: Node) -> Node: successor = None # Iterate through the tree while root: if p.val < root.val: successor = root root = root.left else: root = root.right return successor"},{"question":"Context You\'ve recently learned about various sorting algorithms and their efficiency. One of the most inefficient sorts is the Bogo Sort, which relies on random shuffling until the array is sorted. Despite its inefficiency, Bogo Sort can be a valuable educational tool for understanding the importance of algorithm efficiency. Problem Statement Write a function that utilizes the Bogo Sort algorithm to sort an array of integers. Your function should repeatedly shuffle the array and check if it is sorted. It should return a sorted array once a sorted permutation is found. Requirements * Your function should generate and display each step if the `simulation` parameter is set to `True`. * You need to address the edge cases (e.g., empty array, single-element array) appropriately. * Thoroughly test the function to ensure it handles various types of input correctly. Function Signature ```python def bogo_sort(arr: list, simulation: bool = False) -> list: ``` Input * `arr`: A list of integers to be sorted. * `simulation`: A boolean parameter that, if set to `True`, prints each shuffle step. Output * A sorted list of integers. Constraints * For the purpose of this task, assume the input list will contain no more than 5 elements. Example ```python # Example 1 input_array = [3, 1, 2] print(bogo_sort(input_array, simulation=True)) # Example 2 input_array = [5, 3, 4, 1, 2] print(bogo_sort(input_array)) # Example 3 input_array = [1] print(bogo_sort(input_array)) ```","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort(arr: list, simulation: bool = False) -> list: Sorts the array using the Bogo Sort algorithm. if len(arr) <= 1: return arr attempts = 0 while not is_sorted(arr): attempts += 1 if simulation: print(f\\"Shuffle {attempts}: {arr}\\") random.shuffle(arr) if simulation: print(f\\"Sorted array after {attempts} shuffles: {arr}\\") return arr"},{"question":"# Scenario You are working as a software engineer at a logistics company that is optimizing its network of delivery routes. They need to ensure that they can handle maximum traffic flow through their delivery network efficiently. The delivery routes can be represented as a directed graph where nodes represent warehouse locations, and edges represent routes with capacities indicating the maximum number of deliveries per hour the route can handle. To help the logistics company determine the maximum flow of deliveries between two main warehouses (source and sink), you need to implement a program using the appropriate algorithms learned in class. One scenario you need to address is a critical delivery route that represents the main service path between warehouses. # Task Your task is to write a function that, given a capacity matrix, source, and sink, calculates the maximum flow from the source to the sink warehouse using the efficient **Dinic\'s algorithm**. # Function Signature ```python def calculate_max_delivery_flow(capacity: List[List[int]], source: int, sink: int) -> int: ``` # Input - `capacity`: List of lists of integers representing the capacity matrix. `capacity[i][j]` denotes the capacity of the route from warehouse `i` to warehouse `j`. - `source`: Integer representing the index of the source warehouse. - `sink`: Integer representing the index of the sink warehouse. **Constraints**: - The number of vertices (warehouses) `V` will be at most 100. - The capacities will be non-negative integers less than (10^5). # Output - Return an integer representing the maximum flow from the source warehouse to the sink warehouse. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert calculate_max_delivery_flow(capacity, source, sink) == 23 ``` # Notes - Ensure proper usage of helper functions for BFS and DFS as described in the Dinic\'s algorithm. - Consider edge cases such as when there is no possible path between source and sink.","solution":"from typing import List from collections import deque def bfs_level_graph(capacity: List[List[int]], source: int, sink: int, level: List[int]) -> bool: Uses BFS to build level graph and store level of each node in level[] array. Returns True if there is a path from source to sink, else False. for i in range(len(level)): level[i] = -1 level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dfs_flow(u: int, flow: int, capacity: List[List[int]], sink: int, level: List[int], start: List[int]) -> int: Uses DFS to send flow from source to sink. if u == sink: return flow while start[u] < len(capacity): v = start[u] if capacity[u][v] > 0 and level[v] == level[u] + 1: curr_flow = min(flow, capacity[u][v]) temp_flow = dfs_flow(v, curr_flow, capacity, sink, level, start) if temp_flow > 0: capacity[u][v] -= temp_flow capacity[v][u] += temp_flow return temp_flow start[u] += 1 return 0 def calculate_max_delivery_flow(capacity: List[List[int]], source: int, sink: int) -> int: Returns the maximum flow from source to sink in the given capacity graph using Dinic\'s Algorithm. n = len(capacity) level = [-1] * n max_flow = 0 while bfs_level_graph(capacity, source, sink, level): start = [0] * n while True: flow = dfs_flow(source, float(\'Inf\'), capacity, sink, level, start) if flow == 0: break max_flow += flow return max_flow"},{"question":"Implement B-Tree Traversal and Verification You have been provided with a B-tree implementation in Python which supports insertion, deletion, and searching. Your task is to extend this implementation to include two new functionalities: In-order traversal and structure verification. Part 1: In-order Traversal Implement a method `in_order_traverse()` that performs an in-order traversal of the B-tree and returns a list of keys in non-decreasing order. ```python def in_order_traverse(self): # Your implementation here ``` Part 2: Structure Verification Implement a method `verify_structure()` that verifies if the B-tree maintains its properties: 1. All nodes must have at least ⌈t/2⌉ - 1 keys and at most t - 1 keys. 2. All leaf nodes must be at the same level. 3. The tree must be balanced. ```python def verify_structure(self): # Your implementation here ``` Input and Output 1. `in_order_traverse()` - **Output**: List of integers sorted in non-decreasing order. 2. `verify_structure()` - **Output**: Boolean value `True` if the B-tree is correctly structured, otherwise `False`. Constraints * Assume the degree `t` of the B-tree is at least 2. * The tree will contain no more than 10^4 nodes. Example Usage ```python btree = BTree(3) # B-tree of degree 3 btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # In-order Traversal print(btree.in_order_traverse()) # Output: [5, 6, 7, 10, 12, 17, 20, 30] # Structure Verification print(btree.verify_structure()) # Output: True ``` Your task is to implement the `in_order_traverse` and `verify_structure` functions within the `BTree` class.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, false otherwise self.keys = [] # List of keys in the node self.children = [] # List of children nodes class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert_key(self, k): root = self.root if len(root.keys) == 2 * self.t - 1: temp = BTreeNode(self.t, False) temp.children.append(self.root) self.split_child(temp, 0) self._insert_non_full(temp, k) self.root = temp else: self._insert_non_full(root, k) def split_child(self, parent, i): t = self.t node = parent.children[i] new_node = BTreeNode(t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t: t * 2 - 1] node.keys = node.keys[:t - 1] if not node.leaf: new_node.children = node.children[t:t * 2] node.children = node.children[:t] def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self.split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def in_order_traverse(self): result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if node: for i in range(len(node.keys)): if not node.leaf: self._in_order_helper(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self._in_order_helper(node.children[len(node.keys)], result) def verify_structure(self): if not self._verify_minimum_degree(self.root): return False levels = [] self._verify_leaf_levels(self.root, 0, levels) if len(set(levels)) > 1: return False return True def _verify_minimum_degree(self, node): if len(node.keys) > 2 * self.t - 1 or (node != self.root and len(node.keys) < self.t - 1): return False if node.leaf: return True for child in node.children: if not self._verify_minimum_degree(child): return False return True def _verify_leaf_levels(self, node, level, levels): if node.leaf: levels.append(level) for child in node.children: self._verify_leaf_levels(child, level + 1, levels)"},{"question":"# Palindrome Check for Singly Linked List **Context**: You are working at a data processing company where you frequently need to check if sequences (represented as singly linked lists) are palindromic. Your job is to ensure data remains consistent, and one of the checks involves verifying if the sequence reads the same forwards as backwards. **Task**: Implement a function to determine if a singly linked list is a palindrome. **Function Signature**: ```python def is_palindrome_optimized(head: ListNode) -> bool: pass ``` **Input**: - `head` (ListNode): Head of the singly linked list. Each `ListNode` object has an integer `val` and a `next` pointer to the next node. **Output**: - `bool`: Returns `True` if the list is a palindrome, and `False` otherwise. **Constraints**: - The length of the list is in the range [0, 10^5]. - The values in the nodes are integers. **Performance Requirements**: - The function should run in O(n) time complexity. - Aim to achieve O(1) space complexity (excluding input space). **Example**: ```python Input: head = [1, 2, 2, 1] Output: True Input: head = [1, 2] Output: False ``` **Instructions**: 1. First, find the midpoint of the list using the slow and fast pointer technique. 2. Reverse the second half of the list. 3. Compare the elements of the first half and the reversed second half. 4. Restore the list to its original form (if modified during reversal). 5. Return `True` if both halves match, otherwise return `False`. Hint: - Pay careful attention to the handling of edge cases (e.g., lists with zero or one node). - Ensure no additional space is used for large-scale data. **Edge Cases to Consider**: - An empty list should return `True`. - A list with one element should return `True`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_optimized(head: ListNode) -> bool: if not head or not head.next: return True # Find the end of the first half and reverse the second half. def end_of_first_half(node): slow = node fast = node while fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow def reverse_list(node): prev = None curr = node while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev first_half_end = end_of_first_half(head) second_half_start = reverse_list(first_half_end.next) # Check whether or not there is a palindrome. result = True first_position = head second_position = second_half_start while result and second_position: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Restore the list and return the result. first_half_end.next = reverse_list(second_half_start) return result"},{"question":"# Coding Challenge: Detect and Locate the Cycle Start in a Linked List You are given a linked list in which some nodes form a cycle. You need to determine if there is a cycle in the linked list and if a cycle exists, return the first node of the cycle. Use Floyd\'s Cycle-Finding Algorithm to solve this problem efficiently. Function Signature: ```python def first_cyclic_node(head: Optional[ListNode]) -> Optional[ListNode]: # your code here ``` Input: * `head` - reference to the head of the list (`ListNode`), where `ListNode` is a class: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output: * Return the node where the cycle begins. If there is no cycle, return `None`. Constraints: * The number of nodes in the list is between 0 and 10^4. * The nodes are not necessarily unique, but two nodes with the same value are not considered the same object. Example Scenario: 1. Given a linked list: ``` 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle back to 2) ``` Your function should return the node with the value `2`. 2. Given a linked list with no cycle: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` Your function should return `None`. 3. Given an empty linked list: ``` [] ``` Your function should return `None`. Notes: * You must not modify the linked list. * Make sure to handle edge cases like an empty list or a list with one node. Here’s an example test case setup to verify your solution: ```python import unittest class TestCycleDetection(unittest.TestCase): def create_linked_list(self, values, pos): head = ListNode(values[0]) current = head cycle_entry = None if pos == 0: cycle_entry = head for i in range(1, len(values)): current.next = ListNode(values[i]) current = current.next if i == pos: cycle_entry = current current.next = cycle_entry return head def test_cycle_detection(self): # Example 1: 1 -> 2 -> 3 -> 4 -> 2 (cycle back to 2) values = [1, 2, 3, 4] head = self.create_linked_list(values, 1) self.assertEqual(first_cyclic_node(head).val, 2) # Example 2: no cycle values = [1, 2, 3, 4, 5] head = self.create_linked_list(values, -1) self.assertEqual(first_cyclic_node(head), None) # Example 3: empty linked list self.assertEqual(first_cyclic_node(None), None) # Example 4: 1 node without cycle head = ListNode(1) self.assertEqual(first_cyclic_node(head), None) if __name__ == \'__main__\': unittest.main() ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def first_cyclic_node(head): Returns the first node where the cycle begins in the linked list. If there is no cycle, return None. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Cycle-Finding Algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question: Palindrome Check with LinkedList Given a singly linked list, your task is to determine if it is a palindrome. To simplify this task, consider a singly linked list of character nodes. A singly linked list is a palindrome if the sequence of characters reads the same forward and backward. Write a function `is_linked_list_palindrome(head)` to solve the following problem: Input - `head`: A reference to the head node of a singly linked list where each node contains an alphabetic character (\'a\'-\'z\'). Output - Return `True` if the linked list is a palindrome; otherwise, return `False`. Constraints - The length of the linked list is in the range `[0, 10^5]`. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_linked_list_palindrome(head: ListNode) -> bool: # Your solution should go here. # Example use case: # Input: 1 -> 2 -> 2 -> 1 # Output: True # Input: \'a\' -> \'b\' -> \'b\' -> \'a\' # Output: True # Input: \'a\' -> \'b\' -> \'c\' # Output: False ``` Notes 1. Consider edge cases like empty lists and single-character lists. 2. You may use any of the approaches analyzed earlier (splitting and reversing, stack comparison, or dictionary approach). Implementation Tips - Ensure your solution handles all potential edge cases. - Aim for an efficient algorithm with a time complexity of O(n) and space complexity of O(1) or O(n) as discussed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_linked_list_palindrome(head: ListNode) -> bool: if head is None: return True slow, fast = head, head stack = [] # Use runner technique to find the midpoint of the list and push the first half onto stack while fast and fast.next: stack.append(slow.val) slow = slow.next fast = fast.next.next # If the list has odd number of elements, skip the middle element if fast: slow = slow.next # Compare the second half of the list with the values in stack while slow: if slow.val != stack.pop(): return False slow = slow.next return True"},{"question":"# Decoding Message Problem You are given an encoded message containing digits from \'0\' to \'9\'. Each letter is encoded as a number from \'1\' to \'26\' (e.g., \'A\' -> \'1\', \'B\' -> \'2\', ..., \'Z\' -> \'26\'). Write a function that determines the total number of ways to decode the message. Function Signature: ```python def num_decodings(message: str) -> int: ``` Input: * `message`: A non-empty string containing only digits (\'0\'-\'9\'). Output: * An integer representing the total number of valid ways to decode the message. Constraints: * The encoded message will not be empty and will only contain valid digits (\'0\'-\'9\'). * All tests will have at least one valid decoding. Examples: ```python assert num_decodings(\\"12\\") == 2 # \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6) or \\"BBF\\" (2 2 6) assert num_decodings(\\"0\\") == 0 # \\"0\\" has no valid decodings assert num_decodings(\\"10\\") == 1 # \\"10\\" can be decoded as \\"J\\" assert num_decodings(\\"11106\\") == 2 # \\"11106\\" can be decoded as \\"AAAAJF\\", or \\"KJF\\" ``` Detailed Requirements 1. Your implementation should efficiently handle the length of the message up to 1000 characters. 2. If there is no valid decoding, return 0. 3. Do not use any additional libraries. Explanation The problem requires a solution utilizing dynamic programming principles to keep track of valid decoding ways up to the current digit, making use of: - **Single digit**: Valid if it falls between \'1\' and \'9\'. - **Double digit**: Valid if it falls between \'10\' and \'26\'. Use a loop to incrementally build up the number of ways to decode the message, similar to how the Fibonacci sequence is generated with state transitions being from the last valid single digit and last valid double digit positions.","solution":"def num_decodings(message: str) -> int: if not message or message[0] == \'0\': return 0 n = len(message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): single_digit = int(message[i-1:i]) double_digit = int(message[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Context You are part of a team developing a new game where each player\'s progress from one level to the next is determined by numerical challenges. A critical feature of the game is checking if a score is a perfect square and deciding the next level threshold based on this. Problem Statement Write a function `find_next_perfect_square(n: int) -> int` that takes a single integer `n` as input. The function should return: - The next perfect square greater than the given number, if the given number itself is a perfect square. - `-1` if the given number is not a perfect square. # Function Signature ```python def find_next_perfect_square(n: int) -> int: pass ``` # Input - An integer `n` where `0 <= n <= 10^10`. # Output - An integer representing the next perfect square if `n` is a perfect square. - `-1` if `n` is not a perfect square. # Constraints - The input will be a non-negative integer. - Consider edge cases such as `0`, `1`, and maximum input values carefully. # Examples ```python assert find_next_perfect_square(121) == 144 assert find_next_perfect_square(625) == 676 assert find_next_perfect_square(114) == -1 assert find_next_perfect_square(0) == 1 assert find_next_perfect_square(1) == 4 ``` # Performance Requirements - The function must execute efficiently with a time complexity of O(1) and a space complexity of O(1). Use this information to write and test your function accordingly.","solution":"import math def find_next_perfect_square(n: int) -> int: Returns the next perfect square greater than the given number if it is a perfect square. Returns -1 if the given number is not a perfect square. if n < 0: return -1 sqrt_n = int(math.isqrt(n)) if sqrt_n * sqrt_n == n: next_perfect_square = (sqrt_n + 1) * (sqrt_n + 1) return next_perfect_square else: return -1"},{"question":"Design and implement a `BinarySearchTree` class based on the `TreeNode` class provided. Your BST should support the following operations: 1. **Insert a value** into the BST. 2. **Delete a value** from the BST. 3. **Search for a value** in the BST. Ensure the class adheres to the properties and behaviors of a binary search tree. Specifically, the tree should allow rebalancing to maintain reasonably efficient operation if required. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): Insert a value into the BST. :param val: Integer value to be inserted. :return: None pass def delete(self, val): Delete a value from the BST. :param val: Integer value to be deleted. :return: None pass def search(self, val): Search for a value in the BST. :param val: Integer value to be searched. :return: Boolean indicating presence of the value in the tree. pass ``` # Input and Output 1. **Insert** - **Input**: Single integer value. - **Output**: None (modifies the tree in-place). 2. **Delete** - **Input**: Single integer value. - **Output**: None (modifies the tree in-place). 3. **Search** - **Input**: Single integer value. - **Output**: Boolean (`True` if the value is present in the tree, `False` otherwise). # Constraints - Values will be integers within the range ( -10^6 ) to ( 10^6 ). - Operations should be optimized to handle a large number of elements efficiently. # Example Usage ```python bst = BinarySearchTree() bst.insert(10) assert bst.search(10) == True bst.insert(5) assert bst.search(5) == True bst.insert(15) assert bst.search(15) == True bst.delete(10) assert bst.search(10) == False ``` You are required to implement the missing methods in the `BinarySearchTree` class. Make sure to handle edge cases, such as deleting non-existent values, inserting duplicates, and searching in an empty tree.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): Insert a value into the BST. :param val: Integer value to be inserted. :return: None if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def delete(self, val): Delete a value from the BST. :param val: Integer value to be deleted. :return: None self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): while node.left is not None: node = node.left return node def search(self, val): Search for a value in the BST. :param val: Integer value to be searched. :return: Boolean indicating presence of the value in the tree. return self._search(self.root, val) def _search(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val)"},{"question":"# Decoding Nested Encoded Strings Context You are tasked with developing a functionality for a communication protocol that requires decoding of nested encoded strings. Each encoded segment follows the pattern `k[encoded_string]`, signifying that the `encoded_string` should be repeated `k` times. Given a valid encoded string, your function should return its decoded version. Task Write a Python function `decode_string(s)` that takes a single argument: * **s (str)**: A valid encoded string. The function should return: * **decoded_string (str)**: The fully decoded string. Input & Output Examples ```python # Example 1 # Input: \\"3[a]2[bc]\\" # Output: \\"aaabcbc\\" assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" # Example 2 # Input: \\"3[a2[c]]\\" # Output: \\"accaccacc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" # Example 3 # Input: \\"2[abc]3[cd]ef\\" # Output: \\"abcabccdcdcdef\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` Constraints - The input string is guaranteed to be valid; no extra white spaces, and square brackets are well-formed. - The input won\'t contain digits outside the repetition counts. - The length of the input string is at most 30,000 characters. Notes - Handle nested encoded patterns correctly. - Ensure your implementation is efficient and adheres to the performance requirements.","solution":"def decode_string(s: str) -> str: def decode_helper(index): decoded = \\"\\" num = 0 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char == \'[\': index, temp = decode_helper(index + 1) decoded += temp * num num = 0 elif char == \']\': return index, decoded else: decoded += char index += 1 return index, decoded return decode_helper(0)[1]"},{"question":"# Flatten Nested Arrays You are given a multi-dimensional array (which may contain nested arrays). Write a function to flatten this multi-dimensional array into a single-level array. # Requirements: 1. Implement the function `flatten_array` which takes a list of potentially nested lists and returns a single flattened list. 2. Implement the function `flatten_array_generator` which takes a list of potentially nested lists and returns an iterator that yields each element from the flattened array, in order. Input Format: - `flatten_array`: - A list `arr` which may contain nested lists. - `flatten_array_generator`: - A list `iterable` which may contain nested lists. Output Format: - The function `flatten_array` returns a list. - The function `flatten_array_generator` returns an iterator (`yield` elements one by one). Constraints: 1. The input lists may contain integers and/or other lists. 2. Strings should be treated as atomic elements (i.e., they should not be further flattened). Example: ```python # Example Input input_arr = [1, [2, [3, [4]], 5], 6] # Example output for `flatten_array` output_arr = [1, 2, 3, 4, 5, 6] # Example usage of `flatten_array_generator` for element in flatten_array_generator(input_arr): print(element) # Expected printed output 1 2 3 4 5 6 ``` # Functions Signature ```python def flatten_array(arr): # Your implementation here def flatten_array_generator(iterable): # Your implementation here ```","solution":"def flatten_array(arr): Flatten a multi-dimensional array into a single-level array. :param arr: List of potentially nested lists. :return: List of single-level elements. result = [] stack = [arr] while stack: current = stack.pop() if isinstance(current, list): stack.extend(reversed(current)) else: result.append(current) return result def flatten_array_generator(iterable): Flatten a multi-dimensional array into a single-level array via a generator. :param iterable: List of potentially nested lists. :yield: Single-level elements one by one. stack = [iterable] while stack: current = stack.pop() if isinstance(current, list): stack.extend(reversed(current)) else: yield current"},{"question":"# Merge Sort Challenge Merge Sort is a highly efficient sorting algorithm based on the divide-and-conquer principle. Students will need to implement a merge sort function given an unsorted list of integers. They must handle edge cases appropriately. # Task * **Function Signature**: `def merge_sort(arr: List[int]) -> List[int]:` * **Expected Input**: A list of integers. * **Expected Output**: Sorted list of integers. # Constraints 1. The function must implement the merge sort algorithm. 2. The merge operation should be in-place. 3. Do not use any built-in sort functions. 4. Maximum array length: 10^5. 5. Each integer in the array can range between -10^6 and 10^6. # Example Usage: ```python assert merge_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert merge_sort([7, 5, 3, 1]) == [1, 3, 5, 7] assert merge_sort([10, -3, 2, 5, 0]) == [-3, 0, 2, 5, 10] assert merge_sort([]) == [] assert merge_sort([1]) == [1] ``` # Edge Cases 1. Empty list should return an empty list. 2. Single-element list should return the same single-element list. 3. Lists with duplicates should maintain the stability of elements. # Evaluation Criteria 1. **Correctness**: The function should return the correctly sorted list for all test cases. 2. **Efficiency**: The function should handle the maximum constraints efficiently (O(n log(n)) time complexity). 3. **Edge Case Handling**: The function must handle edge cases correctly. 4. **In-Place Merge**: The function should merge in-place rather than creating additional arrays. 5. **Readability and Maintainability**: Code should be clean, well-commented, and maintainable.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Performs the merge sort algorithm on the input list. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # If any elements are left in either left or right list, add them to merged list merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Priority Queue Problem You are given an implementation of a priority queue using a linear array. The priority queue allows for inserting elements with associated priorities and extracting the element with the highest priority. Your task is to enhance and extend this implementation. # Objectives: 1. **Enhance** the `PriorityQueue` class by adding a method to change the priority of an existing item. 2. **Extend** the `PriorityQueue` class to include a method that checks if an item exists within the queue. 3. **Implement** all new methods in a way that maintains the existing functionality of the priority queue. # Requirements: 1. The `change_priority` method should: - Change the priority of an existing item in the priority queue. - Reinsert the item at its correct position based on the new priority. - Raise an appropriate exception if the item does not exist in the queue. 2. The `contains` method should: - Return `True` if the item exists in the priority queue, `False` otherwise. 3. Maintain the time complexity for `push` and `pop` methods as O(n) and O(1), respectively. # Expected Input and Output Formats: - **`change_priority(item, new_priority)`**: - **Input**: `item` (the item to update), `new_priority` (the new priority to set). - **Output**: None. It modifies the priority within the queue. - **`contains(item)`**: - **Input**: `item` (the item to check). - **Output**: `True` (if item exists in the priority queue), `False` (otherwise). # Example: ```python pq = PriorityQueue() pq.push(\'task1\', priority=2) pq.push(\'task2\', priority=1) pq.push(\'task3\', priority=3) print(pq.contains(\'task1\')) # Output: True print(pq.contains(\'task4\')) # Output: False pq.change_priority(\'task1\', new_priority=4) print(pq.pop()) # Output: \'task1\' since it now has the highest priority print(pq.pop()) # Output: \'task3\' print(pq.pop()) # Output: \'task2\' ``` # Constraints: - You may assume that the priority values are integers. - All items in the priority queue are unique. # Implementation: ```python class PriorityQueue: # ... (existing methods) ... def change_priority(self, item, new_priority): # Your code here pass def contains(self, item): # Your code here pass ``` Ensure your implementation handles all the edge cases and follows the given constraints.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority): Insert an item with the given priority. self.queue.append((priority, item)) self.queue.sort(reverse=True) # Highest priority first def pop(self): Remove and return the item with the highest priority. if not self.queue: raise IndexError(\\"pop from an empty priority queue\\") return self.queue.pop(0)[1] def change_priority(self, item, new_priority): Change the priority of an existing item. found = False for i, (priority, current_item) in enumerate(self.queue): if current_item == item: self.queue.pop(i) self.push(item, new_priority) found = True break if not found: raise ValueError(\\"item not found in the priority queue\\") def contains(self, item): Check if an item exists in the priority queue. return any(current_item == item for _, current_item in self.queue)"},{"question":"# Graph Transitive Closure Calculation You are given a directed graph representation in an adjacency list format. Your task is to write a function to compute the transitive closure of the graph. **Function Signature**: ```python def compute_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` **Input**: - `vertices`: An integer, the number of vertices in the graph. - `edges`: A list of tuples, where each tuple represents a directed edge from the source vertex to the target vertex. **Output**: - A `List[List[int]]`, representing the transitive closure matrix. The element `matrix[i][j]` should be 1 if there is a path from vertex `i` to vertex `j`, otherwise 0. **Constraints**: - `1 <= vertices <= 100` - Each edge is represented by a tuple `(a, b)`, where `0 <= a, b < vertices`. **Examples**: ```python assert compute_transitive_closure(4, [(0, 1), (1, 2), (2, 3)]) == [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] assert compute_transitive_closure(3, [(0, 1), (1, 2)]) == [ [1, 1, 1], [0, 1, 1], [0, 0, 1] ] ``` **Explanation**: - In the first example, there is a direct or indirect path from every vertex to every other vertex due to chain-like connections. - In the second example, `(0, 1)` and `(1, 2)` imply paths `0->1->2`.","solution":"from typing import List, Tuple def compute_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the transitive closure matrix closure = [[0] * vertices for _ in range(vertices)] # Adding self loops for i in range(vertices): closure[i][i] = 1 # Add the edges to the matrix for (u, v) in edges: closure[u][v] = 1 # Apply the Floyd-Warshall algorithm to compute the transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"You are implementing a system that requires modular arithmetic for handling large prime numbers. Given two numbers `a` and `m`, you need to find the modular inverse of `a` modulo `m`. # Task Implement a function `find_modular_inverse(a: int, m: int) -> int` that returns the modular inverse of `a` modulo `m`. If the modular inverse does not exist, raise a `ValueError`. # Input * `a`: a positive integer (1 leq a leq 10^9). * `m`: a positive integer (1 leq m leq 10^9). # Output * Return the modular inverse of `a` modulo `m`, such that ((a * x) % m = 1). # Constraint * `a` and `m` must be coprime. # Example ```python find_modular_inverse(3, 11) # returns 4 because (3 * 4) % 11 = 1 ``` # Note You should use the Extended Euclidean algorithm to implement your solution. Make sure your implementation handles edge cases where `a` and `m` are not coprime by raising a `ValueError`. # Testing Your implementation should be efficient enough to handle the upper constraint within permissible time limits. ```python def find_modular_inverse(a: int, m: int) -> int: # Your code here ```","solution":"def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def find_modular_inverse(a: int, m: int) -> int: gcd, x, y = extended_gcd(a, m) if gcd != 1: raise ValueError(\\"Modular inverse doesn\'t exist because a and m are not coprime\\") return x % m"},{"question":"# Scenario You are working as a data scientist for a tech company. Your task is to develop a custom implementation of a nearest neighbor search algorithm, which will be used to classify new data points based on their proximity to existing labeled data points. This is crucial for building a customer recommendation system based on user behavior and preferences. # Task Write a function `custom_nearest_neighbor(x, tSet)` that takes: - `x`: A tuple representing the new data point. - `tSet`: A dictionary where keys are tuples representing training data points, and values are their corresponding labels. # Requirements - Use Euclidean distance for the nearest neighbor search. - Validate input dimensions. - Efficiently identify and return the label of the closest training data point to `x`. # Input Format - A tuple `x` of length `m` representing the new data point. - A dictionary `tSet` where each key is a tuple of length `m` and each value is a label (could be any data type). # Output Format - The function should return the label corresponding to the nearest neighbor in `tSet`. # Constraints - `1 <= m <= 10^4` - `0 <= len(tSet) <= 10^4` - Ensure the function handles large input sizes efficiently. # Examples ```python # Example 1 x = (1, 2) tSet = {(0, 0): \'A\', (3, 4): \'B\', (1, 1): \'C\'} print(custom_nearest_neighbor(x, tSet)) # Output: \'C\' # Example 2 x = (5, 5) tSet = {(1, 2): \'A\', (4, 4): \'B\', (8, 8): \'C\'} print(custom_nearest_neighbor(x, tSet)) # Output: \'B\' ``` # Note 1. You should consider edge cases such as empty training sets and vector length mismatches. 2. Implement optimally to handle potential performance bottlenecks for large datasets.","solution":"import math def custom_nearest_neighbor(x, tSet): Given a data point x and a training set tSet, returns the label of the nearest neighbor in tSet using Euclidean distance. Parameters: - x (tuple): The new data point. - tSet (dict): The training set of points and their labels. Returns: - The label of the closest training data point. if not tSet: # If the training set is empty raise ValueError(\\"Training set is empty\\") # Dimensionality check x_len = len(x) for point in tSet: if len(point) != x_len: raise ValueError(\\"Dimensionality of training data points must match the new data point\\") min_distance = float(\'inf\') nearest_label = None for point, label in tSet.items(): # Calculate Euclidean distance distance = math.sqrt(sum((xi - pi) ** 2 for xi, pi in zip(x, point))) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"Given a directed, weighted graph represented as an adjacency matrix, implement a function `find_shortest_paths(graph, source)` that uses Dijkstra’s algorithm to compute the shortest paths from the given source vertex to all other vertices. # Function Signature: ```python def find_shortest_paths(graph: List[List[int]], source: int) -> List[int]: pass ``` # Input: * `graph`: A two-dimensional list of integers where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If there is no edge, the weight is represented as 0. * `source`: An integer representing the starting vertex. # Output: * A list of integers where the `i-th` element represents the shortest distance from the source vertex to the `i-th` vertex. If a vertex is unreachable, its shortest distance should be represented as infinity (`float(\\"inf\\")`). # Constraints: * The number of vertices (`n`) will be between `1` and `100`. * All edge weights will be non-negative integers. * It is guaranteed that the graph does not contain negative weight edges. # Example: ```python graph = [ [0, 10, 20, 0, 0], [10, 0, 0, 50, 10], [20, 0, 0, 20, 33], [0, 50, 20, 0, 2], [0, 10, 33, 2, 0] ] source = 0 print(find_shortest_paths(graph, source)) # Output: [0, 10, 20, 40, 20] ``` # Explanation: For the given graph, the shortest paths from vertex 0 are: - Vertex 0 to Vertex 0: 0 - Vertex 0 to Vertex 1: 10 - Vertex 0 to Vertex 2: 20 - Vertex 0 to Vertex 3: 40 (0 -> 2 -> 3) - Vertex 0 to Vertex 4: 20 (0 -> 2 -> 3 -> 4) # Additional Notes: - Carefully handle edge cases such as graphs with no edges or disconnected nodes. - Use efficient data structures to ensure that your solution runs within acceptable time limits for the given constraints. - Your algorithm should be robust enough to handle varied input sizes and configurations.","solution":"import heapq from typing import List def find_shortest_paths(graph: List[List[int]], source: int) -> List[int]: Computes the shortest paths from the source vertex to all other vertices using Dijkstra\'s algorithm. n = len(graph) dist = [float(\\"inf\\")] * n dist[source] = 0 visited = [False] * n priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if visited[current_vertex]: continue visited[current_vertex] = True for neighbor, weight in enumerate(graph[current_vertex]): if weight > 0 and not visited[neighbor]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"You are given two integers, n and k representing the total number of items and the number of items to choose, respectively. Your task is to implement a function to calculate the binomial coefficient C(n, k), which is the number of ways to choose k items from n items without regards to order. Write a function `binomial_coefficient(n, k)` that: - Accepts two integer inputs, n and k (0 ≤ k ≤ n). - Returns an integer which is the calculated binomial coefficient C(n, k). Given the potential depth of the recursion, optimize your approach to avoid maximum recursion limit exceeded errors and handle large inputs efficiently. You may use an iterative, dynamic programming, or memoized recursive approach. # Constraints: - 0 ≤ k ≤ n ≤ 10^3 # Input: - Two integers n and k. # Output: - An integer representing the binomial coefficient C(n, k). # Example: ```python def binomial_coefficient(n, k): # Your implementation here # Test cases print(binomial_coefficient(5, 0)) # Output: 1 print(binomial_coefficient(8, 2)) # Output: 28 print(binomial_coefficient(10, 5)) # Output: 252 print(binomial_coefficient(1000, 500)) # (Large value) ``` # Additional Notes: - Be aware of edge cases such as when k = 0 or k = n. - Consider both time and space efficiency.","solution":"def binomial_coefficient(n, k): Calculates the binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) # Take advantage of symmetry dp = [0] * (k + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[k]"},{"question":"# Question: Bit Manipulation for Custom Permission System You are tasked with developing a simple but efficient permission system using bit manipulation. Each user in your system will have an integer representing their permissions. Each bit in this integer corresponds to a specific permission: - Bit 0: Read (1 if allowed, 0 if not) - Bit 1: Write (1 if allowed, 0 if not) - Bit 2: Execute (1 if allowed, 0 if not) - Bit 3: Delete (1 if allowed, 0 if not) - Bits 4-31: Reserved for future use. Implement the following functions for the permission system: 1. `has_permission(permissions, position)` - Check if a specific permission (given by position) is set. 2. `grant_permission(permissions, position)` - Grant a specific permission (set the bit at the given position). 3. `revoke_permission(permissions, position)` - Revoke a specific permission (clear the bit at the given position). 4. `set_permission(permissions, position, value)` - Set or clear a specific permission based on `value` (0 or 1). **Function Interface**: ```python def has_permission(permissions: int, position: int) -> bool: pass def grant_permission(permissions: int, position: int) -> int: pass def revoke_permission(permissions: int, position: int) -> int: pass def set_permission(permissions: int, position: int, value: int) -> int: pass ``` **Input**: - `permissions`: An integer where each bit represents a specific permission. - `position`: The bit position (0-31) to check, set, or clear. - `value`: An integer (0 or 1) representing the desired state in the `set_permission` function. **Output**: - `has_permission`: Returns a boolean indicating whether the permission is set. - `grant_permission`, `revoke_permission`, `set_permission`: Return the modified permissions integer. **Constraints**: - Position will be between 0 and 31 inclusive. - Value will be either 0 or 1. - Assume that only valid inputs are provided for simplicity. **Example**: ```python permissions = 0b0001 # Only Read permission is set assert has_permission(permissions, 0) == True # Read permission assert has_permission(permissions, 1) == False # Write permission permissions = grant_permission(permissions, 1) # Grant Write permission assert has_permission(permissions, 1) == True # Now Write permission is granted permissions = revoke_permission(permissions, 0) # Revoke Read permission assert has_permission(permissions, 0) == False # Now Read permission is revoked permissions = set_permission(permissions, 2, 1) # Grant Execute permission explicitly assert has_permission(permissions, 2) == True # Execute permission is now granted permissions = set_permission(permissions, 1, 0) # Explicitly revoke Write permission assert has_permission(permissions, 1) == False # Now Write permission is revoked ``` **Task**: Write the implementations of `has_permission`, `grant_permission`, `revoke_permission`, and `set_permission` functions that fulfill the described functionality.","solution":"def has_permission(permissions: int, position: int) -> bool: Check if a specific permission (given by position) is set in the permissions. return (permissions & (1 << position)) != 0 def grant_permission(permissions: int, position: int) -> int: Grant a specific permission (set the bit at the given position) in the permissions. return permissions | (1 << position) def revoke_permission(permissions: int, position: int) -> int: Revoke a specific permission (clear the bit at the given position) in the permissions. return permissions & ~(1 << position) def set_permission(permissions: int, position: int, value: int) -> int: Set or clear a specific permission based on value (0 or 1) in the permissions. if value: return grant_permission(permissions, position) else: return revoke_permission(permissions, position)"},{"question":"# Coding Assessment: As a tree traversal algorithm, the **Level Order Traversal** is essential for understanding how trees can be explored breadth-wise. The task below will test your ability to implement this traversal correctly and efficiently. Task: Implement a function named `level_order_traversal` that takes the root of a binary tree and returns its level order traversal as a list of node values grouped by level. Function Signature: ```python def level_order_traversal(root: TreeNode) -> List[List[int]]: pass ``` Input Format: * `root`: The root node of a binary tree. A node is defined as a class with attributes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output Format: * Return a list of lists, where each inner list contains node values of one level, from top to bottom. Constraints: * The number of nodes in the tree is in the range [0, 1000]. * Node values are integers. Example 1: **Input:** ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) level_order_traversal(root) ``` **Output:** ```python [ [3], [9, 20], [15, 7] ] ``` Example 2: **Input:** ```python root = None level_order_traversal(root) ``` **Output:** ```python [] ``` Ensure your implementation efficiently handles edge cases and large inputs, and consider using appropriate data structures to manage memory and execution time effectively.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level = [] level_size = len(queue) for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Question: You have been provided with a code snippet that implements Kruskal’s algorithm to find the Minimum Spanning Tree (MST) for an undirected, connected weighted graph. Using the principles from the code provided, extend the functionality to handle the following additional tasks: Task: 1. **Add Edge Weights**: Modify the function `kruskal` to return not just the sum of weights but also the individual edges included in the MST. 2. **Handling Disconnected Graphs**: Enhance the implementation to check whether the input graph is a connected graph. If not, return an indication that an MST cannot be formed. 3. **Optimizing for Sparse and Dense Graphs**: Add logic to switch between Kruskal\'s algorithm and Prim\'s algorithm based on the density of the graph (ratio of edges to vertices). Implement Prim’s algorithm within the same code and choose the appropriate one to run based on the graph density. 4. **Function Signature**: Your main function should be `def find_min_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int, int]]]:`. - `vertex_count`: Number of vertices in the graph. - `edges`: List of tuples, where each tuple represents an edge in the format (source, target, weight). - Returns a tuple. The first element should be the sum of the MST weights, and the second element should be a list of edges included in the MST (each edge represented as a tuple (source, target, weight)). Input: * An integer `vertex_count` representing the number of vertices (1 ≤ vertex_count ≤ 10^5). * A list of tuples `edges`, each containing three integers `(u, v, w)` representing an edge between vertex `u` and vertex `v` with weight `w` (1 ≤ u, v ≤ vertex_count; 1 ≤ w ≤ 10^6). Output: * A tuple containing two elements: 1. The sum of the weights of the edges in the MST. 2. A list of tuples representing the edges in the MST. * If the graph is disconnected, return `(None, [])`. Performance Requirements: * Aim for an optimized solution that can handle large inputs efficiently within reasonable time limits. Scenario: Consider you are working for a company that builds networking infrastructures. Your goal is to establish the most efficient network cabling that connects all devices with the minimum total cabling cost. However, not all configurations are guaranteed to be fully connected (devices might be in separate rooms without cables between some of them yet). In such cases, you should detect if it\'s impossible to connect all devices and alert the system accordingly. Good Luck!","solution":"def find_min_spanning_tree(vertex_count: int, edges: list[tuple[int, int, int]]) -> tuple[int, list[tuple[int, int, int]]]: Finds the MST using either Kruskal\'s or Prim\'s algorithm based on the density of the graph. Returns a tuple containing the sum of the weights of the edges in the MST and a list of edges in the MST. If the graph is disconnected, returns (None, []). # Union-Find data structure for Kruskal\'s algorithm class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True return False def kruskal(): edges_sorted = sorted(edges, key=lambda x: x[2]) uf = UnionFind(vertex_count) mst_weight = 0 mst_edges = [] for u, v, weight in edges_sorted: if uf.union(u, v): mst_weight += weight mst_edges.append((u, v, weight)) if len(mst_edges) == vertex_count - 1: return (mst_weight, mst_edges) if len(mst_edges) != vertex_count - 1: return (None, []) return (mst_weight, mst_edges) def prim(): import heapq import itertools adj = [[] for _ in range(vertex_count)] for u, v, w in edges: adj[u].append((w, v)) adj[v].append((w, u)) MST_weight = 0 MST_edges = [] min_heap = [(0, 0, None)] visited = [False] * vertex_count while min_heap: weight, u, p = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True if p is not None: MST_weight += weight MST_edges.append((p, u, weight)) for next_weight, v in adj[u]: if not visited[v]: heapq.heappush(min_heap, (next_weight, v, u)) if len(MST_edges) != vertex_count - 1: return (None, []) return (MST_weight, MST_edges) edge_count = len(edges) density = edge_count / vertex_count if density > 10: return prim() else: return kruskal()"},{"question":"# Subset Generation Challenge **Objective**: Write a Python function to generate all possible subsets of a given set of distinct integers. **Function Signature**: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` **Input**: * A list of distinct integers `nums`, where `0 <= len(nums) <= 20` and `-10^6 <= nums[i] <= 10^6` for all valid `i`. **Output**: * A set of tuples, where each tuple is a unique subset of the given integers in `nums`. **Constraints**: * The solution set must not contain duplicate subsets. * The subsets can be in any order. **Performance Requirements**: * Given the constraints, your algorithm should efficiently handle input of size up to 20. **Example**: ```python assert generate_subsets([1, 2, 3]) == { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,) } assert generate_subsets([]) == { () } assert generate_subsets([9]) == { (), (9,) } ``` Provide a well-crafted and optimized solution demonstrating your understanding of this algorithm.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of a given set of distinct integers nums. Args: nums (List[int]): List of distinct integers. Returns: Set[Tuple[int]]: Set of tuples, where each tuple is a unique subset of the given integers in nums. def backtrack(start: int, path: List[int]): # Add the current combination to the subsets subsets.add(tuple(path)) for i in range(start, len(nums)): # Include nums[i] in the current combination path.append(nums[i]) # Continue recursively backtrack(i + 1, path) # Backtrack and remove nums[i] path.pop() subsets = set() backtrack(0, []) return subsets"},{"question":"**Problem Statement: Longest Substring Without Repeating Characters** Given a string, write a function `find_longest_unique_substr(s: str) -> (int, str)` to determine the length of the longest substring without repeating characters and return both the length and the substring itself. # Input: - A single string `s` (0 ≤ len(s) ≤ 10^5) containing only printable ASCII characters. # Output: - A tuple `(int, str)`, where the first element is the length of the longest substring without repeating characters, and the second element is the substring itself. # Constraints: - You must implement the function using a sliding window technique. - The function should handle edge cases, such as an empty string. - The solution should have a time complexity of O(n). # Examples: Example 1: ```plaintext Input: \\"abcabcbb\\" Output: (3, \\"abc\\") ``` Example 2: ```plaintext Input: \\"bbbbb\\" Output: (1, \\"b\\") ``` Example 3: ```plaintext Input: \\"pwwkew\\" Output: (3, \\"wke\\") ``` Example 4: ```plaintext Input: \\" \\" Output: (1, \\" \\") ``` Example 5: ```plaintext Input: \\"\\" Output: (0, \\"\\") ``` # Note: - Each input string `s` will contain only printable ASCII characters. - In case of multiple answers, you can return any valid substring. **Function Signature:** ```python def find_longest_unique_substr(s: str) -> (int, str): pass ``` # Guidelines: - Implement the sliding window approach to solve this problem. - Use auxiliary data structures like sets or dictionaries to keep track of seen characters and their positions efficiently. - Thoroughly test your function with edge cases and large inputs to ensure it meets the time complexity requirements.","solution":"def find_longest_unique_substr(s: str) -> (int, str): n = len(s) if n == 0: return (0, \\"\\") longest_length = 0 longest_substr = \\"\\" start = 0 seen = {} for end in range(n): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end current_length = end - start + 1 if current_length > longest_length: longest_length = current_length longest_substr = s[start:end+1] return (longest_length, longest_substr)"},{"question":"# Question: Implement a Frequency Distribution Histogram with Edge Handling Context You are a data scientist working on preprocessing data for a machine learning project. A histogram that captures the frequency distribution of elements in a dataset is essential for understanding data distribution. Your task is to implement a function that takes a list of numerical elements and returns a dictionary representing the histogram. However, you also need to handle edge cases effectively. Problem Statement Write a function `get_histogram_with_edge_handling` that takes a list of numerical elements and returns a dictionary representing the histogram. Ensure that your implementation handles various edge cases, such as empty lists and non-hashable elements. Function Signature ```python def get_histogram_with_edge_handling(input_list: list) -> dict: pass ``` Input - `input_list`: A list of numerical elements (e.g., integers, floats). Output - A dictionary where the keys are the unique elements from the input list, and the values are their corresponding frequencies. Constraints - Your function should handle an empty input list by returning an empty dictionary. - You should raise a `ValueError` if any of the elements in the list are not hashable or not valid numerical data types. - Ensure that your function performs efficiently even with reasonably large lists. Example ```python assert get_histogram_with_edge_handling([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert get_histogram_with_edge_handling([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert get_histogram_with_edge_handling([]) == {} assert get_histogram_with_edge_handling([1, \'a\', 1]) # Should raise ValueError assert get_histogram_with_edge_handling([1, frozenset([1])]) # Should raise ValueError ```","solution":"def get_histogram_with_edge_handling(input_list: list) -> dict: Takes a list of numerical elements and returns a dictionary representing the histogram. Ensures to handle edge cases such as empty lists and non-hashable elements. Parameters: input_list (list): A list of numerical elements (e.g., integers, floats). Returns: dict: A dictionary where the keys are the unique elements from the input list, and the values are their corresponding frequencies. # Handle the case of an empty input list if not input_list: return {} # Initialize an empty dictionary to store the histogram histogram = {} for element in input_list: # Check if element is not a valid numerical value if not isinstance(element, (int, float)): raise ValueError(\\"All elements in the list must be integers or floats.\\") # Add the element to the histogram if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"You are given a large text and a smaller pattern string. Your task is to implement an efficient algorithm to find all the starting indices of occurrences of the pattern in the text using the Rabin-Karp algorithm. # Function Signature: ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: pass ``` # Input: - `text` (str): The larger text where the pattern is to be searched. (1 ≤ len(text) ≤ 10^6) - `pattern` (str): The pattern string to search within the text. (1 ≤ len(pattern) ≤ 10^5) # Output: - Returns a list of all starting indices where the pattern is found in the text. If the pattern is not found, return an empty list. # Constraints: - The text and pattern will consist of lowercase alphabetical letters only. - The function should handle cases where the pattern is longer than the text gracefully. # Example: ```python text = \\"abcabcdabc\\" pattern = \\"abc\\" find_pattern_occurrences(text, pattern) # Output: [0, 3, 7] text = \\"aaaaa\\" pattern = \\"aa\\" find_pattern_occurrences(text, pattern) # Output: [0, 1, 2, 3] text = \\"abcdefgh\\" pattern = \\"xyz\\" find_pattern_occurrences(text, pattern) # Output: [] ``` # Notes: - You should make efficient use of the rolling hash mechanism to ensure that your solution works in expected linear time for most inputs. - Pay attention to the management of hash values to minimize collisions and ensure correctness.","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: if len(pattern) > len(text): return [] base = 256 mod = 101 # A prime number to mod out hash values to reduce collisions len_text = len(text) len_pat = len(pattern) hash_text = 0 hash_pat = 0 h = 1 # Initial value of h: base^(len_pat-1) % mod for _ in range(len_pat - 1): h = (h * base) % mod # Calculate initial hash values for the pattern and the first window of the text for i in range(len_pat): hash_pat = (base * hash_pat + ord(pattern[i])) % mod hash_text = (base * hash_text + ord(text[i])) % mod result = [] # Sliding the window to check each substring in the text for i in range(len_text - len_pat + 1): if hash_text == hash_pat: # If hash values match, then only check characters one by one if text[i:i + len_pat] == pattern: result.append(i) # Calculate hash value for the next window of text, if there is any if i < len_text - len_pat: hash_text = (base * (hash_text - ord(text[i]) * h) + ord(text[i + len_pat])) % mod # We might get negative value of hash, converting it to positive if hash_text < 0: hash_text += mod return result"},{"question":"**Context**: Stooge Sort is a recursive sorting algorithm with poor efficiency, primarily used for academic purposes to study less efficient algorithms. While its time complexity is very high, it demonstrates the concept of recursive sorting. **Question**: Write a function `stooge_sort(arr)` that takes a list of integers and sorts it in non-decreasing order using the Stooge Sort algorithm. Your implementation should follow the core operational steps of Stooge Sort. # Function Definition ```python def stooge_sort(arr: List[int]) -> None: pass ``` # Input * `arr`: A list of integers where 1 ≤ len(arr) ≤ 10^2. # Output * The function should modify the list `arr` in-place to sort the elements in non-decreasing order. # Constraints * The function must use the Stooge Sort algorithm. * Do not use built-in sorting functions or libraries. # Example ```python arr = [2, 4, 5, 3, 1] stooge_sort(arr) print(arr) # Output: [1, 2, 3, 4, 5] ``` # Notes Consider any potential edge cases and ensure your function handles arrays of different sizes appropriately. Since this is a demonstration of understanding Stooge Sort, focus on implementing the algorithm correctly rather than optimizing for performance.","solution":"def stooge_sort(arr, l=0, h=None): if h is None: h = len(arr) - 1 if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array, recursively sort parts of the array if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t)"},{"question":"# Scenario You are working on a data transmission system where binary trees need to be sent over a network. To efficiently transmit these structures, you need to convert them into a string format and revert them back into the original tree structure upon reception. # Task Implement functions `serialize` and `deserialize` for converting a binary tree into a string and back into the binary tree structure, respectively. # Detailed Requirements 1. **Function `serialize`**: * **Input**: A `TreeNode` object representing the root of the binary tree. * **Output**: A single string that represents the serialized form of the tree. * The string should use pre-order traversal and use \\"#\\" to represent null nodes. 2. **Function `deserialize`**: * **Input**: A string representation of a binary tree as produced by the `serialize` function. * **Output**: The `TreeNode` object that is the root of the deserialized binary tree. # Input Format - For `serialize(root: TreeNode) -> str`: The input is the root node of a binary tree. - For `deserialize(data: str) -> TreeNode`: The input is a string representing a serialized binary tree. # Output Format - For `serialize`: A string representing the serialized form of the binary tree. - For `deserialize`: A `TreeNode` object representing the root of the deserialized binary tree. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The serialized string length will not exceed 50000 characters. # Example ```python # Example usage: # Construct the tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialize the binary tree serialized = serialize(root) print(serialized) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize the string back to the binary tree deserialized_root = deserialize(serialized) # Verify the structure by serializing it again print(serialize(deserialized_root)) # Output should be the same: \\"1 2 # # 3 4 # # 5 # #\\" ``` # Hints - Carefully handle the representation and reversals of `None` nodes. - Make sure to thoroughly test with edge cases like empty trees and trees with varied structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def dfs(node): if node is None: return \\"#\\" return f\\"{node.val} {dfs(node.left)} {dfs(node.right)}\\" return dfs(root).strip() def deserialize(data): Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node node_iter = iter(data.split()) return helper(node_iter)"},{"question":"Efficient Sorting Function Scenario You have been provided with a legacy sorting function in a project, called Stooge Sort, which is seen to be highly inefficient for practical use due to its very high time complexity. Your task is to implement a more efficient sorting algorithm to replace Stooge Sort while maintaining a similar interface. Requirements * You need to implement the `quick_sort` function which has better time complexity, specifically average-case O(n log n). * Ensure that your solution handles edge cases and provides better performance, especially for large datasets. Function Signature ```python def quick_sort(arr: list, left: int, right: int) -> None: Sorts the array in-place from index \'left\' to index \'right\' using Quick Sort algorithm. Parameters: arr: list - list of elements to be sorted. left: int - starting index of the segment of the list to be sorted. right: int - ending index of the segment of the list to be sorted. ``` # Input * `arr` (list): A list of integers that need to be sorted. * `left` (int): The starting index of the segment to be sorted. * `right` (int): The ending index of the segment to be sorted. # Output * The function sorts the list in-place; hence it does not return anything. # Constraints * You may assume that `left` and `right` will always be valid indices within the array. * Elements of the array can be any integer (positive, negative or zero). * Aim for a solution with average-case time complexity of O(n log n). # Example ```python arr = [1, 3, 64, 5, 7, 8] quick_sort(arr, 0, len(arr) - 1) print(arr) # This should output the sorted array: [1, 3, 5, 7, 8, 64] ``` # Notes * Consider edge cases such as arrays of length 0, 1, and arrays that are already sorted. * Also account for arrays with duplicate values, and verify the algorithm\'s performance on various sizes of input arrays.","solution":"def quick_sort(arr, left, right): Sorts the array in-place from index \'left\' to index \'right\' using Quick Sort algorithm. Parameters: arr: list - list of elements to be sorted. left: int - starting index of the segment of the list to be sorted. right: int - ending index of the segment of the list to be sorted. if left < right: pivot_index = partition(arr, left, right) quick_sort(arr, left, pivot_index - 1) quick_sort(arr, pivot_index + 1, right) def partition(arr, left, right): Partitions the array around the pivot element and returns the pivot index. Parameters: arr: list - list of elements to be partitioned. left: int - starting index of the segment of the list to be partitioned. right: int - ending index of the segment of the list to be partitioned. Returns: int - index of the pivot element after partitioning. pivot = arr[right] i = left - 1 for j in range(left, right): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[right] = arr[right], arr[i + 1] return i + 1"},{"question":"Word Pattern Validator Given a pattern and a string `s`, determine if `s` follows the same pattern. Here, \\"follows the same pattern\\" means there exists a bijection between each character in the pattern and a non-empty word in the string such that the pattern\'s characters map uniquely to the words in the string. Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: pass ``` # Input * `pattern` (string): A string of lowercase letters. * `s` (string): A string of lowercase words separated by single spaces. # Output * `bool`: Returns `True` if the string follows the pattern, otherwise returns `False`. # Constraints * The pattern contains only lowercase letters. * The string `s` contains only lowercase words separated by a single space. # Examples 1. **Example 1:** ```python pattern = \\"abba\\" s = \\"dog cat cat dog\\" Output: True ``` 2. **Example 2:** ```python pattern = \\"abba\\" s = \\"dog cat cat fish\\" Output: False ``` 3. **Example 3:** ```python pattern = \\"aaaa\\" s = \\"dog cat cat dog\\" Output: False ``` 4. **Example 4:** ```python pattern = \\"abba\\" s = \\"dog dog dog dog\\" Output: False ``` # Additional Notes - If the number of words in the string does not match the number of characters in the pattern, the function should return `False`. - Ensure that mappings are unique and bijective. - Handle edge cases where the string or pattern is empty. # Implementation Implement the `word_pattern` function to solve the problem as per the provided signature.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: if word_to_char[word] != char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"Implement Efficient Hash Table Handling Load Factor Changes Scenario: You are working for a tech company that uses a Resizable Hash Table to handle large amounts of dynamic data efficiently. However, there\'s a need for further optimization by implementing a more sophisticated probing method and addressing the need for customized load factor thresholds. Requirements: 1. **Quadratic Probing**: Enhance the Resizable Hash Table to use quadratic probing for handling collisions. 2. **Customizable Load Factor**: Implement the ability to dynamically adjust the resizing threshold beyond the current 2/3 default. Specifications: - **Input**: - **key**: Integer (key to be inserted or searched) - **value**: Any (value associated with the key) - **load_factor**: Float (custom load factor to trigger resizing, if not provided, defaults to 2/3) - **Output**: - For `put` operation, return `None`. - For `get` operation, return the associated value or `None` if key does not exist. - For `delete` operation, return `None`. Constraints: - Keys will be unique integers. - Customize the `put`, `get`, and `delete` methods to handle the new probing strategy efficiently. - Ensure that resizing maintains all existing entries correctly and adheres to new load factor thresholds. Performance: - Expected average time complexity for standard operations should remain O(1). - Minimize the number of resizing operations and rehashing time. # Sample Method Definitions: ```python class EnhancedHashTable(HashTable): def __init__(self, size=11, load_factor=2/3): # Initialize with given size and load factor pass def put(self, key, value): # Implement quadratic probing for collision handling and dynamic resizing based on load factor pass def get(self, key): # Implement value retrieval pass def delete(self, key): # Implement key deletion pass ``` # Sample Usage: ```python ht = EnhancedHashTable(size=11, load_factor=0.75) ht.put(10, \\"Value1\\") ht.put(21, \\"Value2\\") print(ht.get(10)) # Output: \\"Value1\\" ht.delete(21) print(ht.get(21)) # Output: None ht.put(32, \\"Value3\\") ht.put(43, \\"Value4\\") # Triggers resize print(len(ht)) # Output: 3 ``` Implement the **EnhancedHashTable** class using the methods and optimizations described.","solution":"class EnhancedHashTable: def __init__(self, size=11, load_factor=2/3): self.size = size self.table = [None] * size self.load_factor = load_factor self.count = 0 def _hash(self, key, i): return (key + i * i) % self.size def put(self, key, value): i = 0 while i < self.size: index = self._hash(key, i) if self.table[index] is None or self.table[index] == \'deleted\': if self.table[index] is None: self.count += 1 self.table[index] = (key, value) if (self.count / self.size) > self.load_factor: self._resize() return elif self.table[index][0] == key: self.table[index] = (key, value) return i += 1 def get(self, key): i = 0 while i < self.size: index = self._hash(key, i) if self.table[index] is None: return None if self.table[index] != \'deleted\' and self.table[index][0] == key: return self.table[index][1] i += 1 return None def delete(self, key): i = 0 while i < self.size: index = self._hash(key, i) if self.table[index] is None: return if self.table[index] != \'deleted\' and self.table[index][0] == key: self.table[index] = \'deleted\' self.count -= 1 return i += 1 def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item and item != \'deleted\': self.put(item[0], item[1])"},{"question":"You are required to extend the functionality of a Binary Search Tree (BST) to include multiple methods related to tree properties. 1. `height(root)`: Write a function `height` that computes the height of the BST. 2. `is_balanced(root)`: Write a function `is_balanced` that checks if the tree is balanced. A tree is defined as balanced if the heights of the two subtrees of any node never differ by more than 1. # Input/Output Formats * **Input**: * The root node of the BST. * **Output**: * For `height`: an integer representing the height of the tree. * For `is_balanced`: a boolean indicating if the tree is balanced (`True` for balanced, `False` otherwise). # Constraints * The number of nodes (n) in the tree will be between 0 and 10^4. * The tree contains unique element values (no duplicates). # Example ```python # Given this tree: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 height(root) -> 4 is_balanced(root) -> True # If we insert 19 under 18, resulting in: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 # # 19 is_balanced(root) -> False ``` # Note: We provide you with the basic structure of the Binary Search Tree implementation. You need to complete the `height` and `is_balanced` methods. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def height(root): # Your implementation here def is_balanced(root): # Your implementation here ``` # Additional Instructions: Please include unit tests to verify the correctness of the `height` and `is_balanced` methods.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def height(root): if root is None: return 0 return 1 + max(height(root.left), height(root.right)) def is_balanced(root): def check_height_and_balance(node): if node is None: return 0, True left_height, left_balanced = check_height_and_balance(node.left) right_height, right_balanced = check_height_and_balance(node.right) current_balanced = (abs(left_height - right_height) <= 1) current_height = 1 + max(left_height, right_height) return current_height, current_balanced and left_balanced and right_balanced _, balanced = check_height_and_balance(root) return balanced"},{"question":"You are given a set of distinct integers, `nums`. Your task is to write a function `generate_subsets(nums)` which returns all possible subsets of the given set. # Implementation Details - **Function Signature**: `def generate_subsets(nums: List[int]) -> Set[Tuple[int]]` - **Input**: - `nums` - a list of distinct integers, 0 <= len(nums) <= 20, each integer -10^7 <= nums[i] <= 10^7. - **Output**: - A set of tuples, where each tuple represents a subset of the input list. # Constraints - The input set will not contain duplicate numbers. - You must handle the edge case where the input list is empty. - The solution set must not contain duplicate subsets. # Example Scenarios 1. **Example 1**: - **Input**: nums = [1,2,3] - **Output**: {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} 2. **Example 2**: - **Input**: nums = [] - **Output**: {()} # Performance Requirements - The function should have a time complexity of O(n * 2^n). - The space complexity should be O(2^n). # Additional Context Imagine you are designing software to test all possible configurations of a given set of components. Each component can either be included or excluded from a configuration. Your task is to write an algorithm that can efficiently generate all possible configurations.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets of the given list of distinct integers. :param nums: List of distinct integers :return: A set of tuples, each representing a subset of the input list. def backtrack(start: int, curr: List[int]): result.add(tuple(curr)) for i in range(start, len(nums)): # Include nums[i] in the subset curr.append(nums[i]) # Move to the next element backtrack(i + 1, curr) # Backtrack, remove nums[i] from current subset curr.pop() result = set() backtrack(0, []) return result"},{"question":"# Scenario Sort-X Corporation specializes in algorithm optimization and has recently acquired a legacy system that uses Cocktail Shaker Sort for sorting data. You, as a new engineer, have been asked to write an optimized and robust implementation of this sorting algorithm to handle varied data efficiently. # Objective Implement an optimized Cocktail Shaker Sort function for a list of integers. # Requirements 1. Your function should be named `optimized_cocktail_shaker_sort`. 2. The function should take a list of integers as input and return the sorted list. 3. The algorithm should stop early if the list becomes sorted during any pass, avoiding unnecessary iterations. 4. The function should handle edge cases such as empty lists or lists with duplicate elements. 5. You may not use any additional data structures; sorting must be done in-place. # Input Format - A list of integers, `arr`, with length `n` (0 ≤ n ≤ 10^5). # Output Format - A list of integers sorted in ascending order. # Example ```python input: [5, 3, 8, 4, 2] output: [2, 3, 4, 5, 8] input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] input: [] output: [] ``` # Constraints - You should minimize the number of swaps if the list is already almost sorted. - The function should maintain a space complexity of O(1). # Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Note Harness the bi-directional approach optimally to minimize the number of passes and ensure early termination wherever possible. Remember to handle all edge cases effectively.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Reset the swapped flag so it can be used in the next stage swapped = False # Move the end point back by one end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the start point, because the last stage would have moved the next smallest number to its correct position start += 1 return arr"},{"question":"# Question: Find Minimum Depth of a Binary Tree with Correct Recursive Implementation **Background**: You are given a binary tree that is represented using node objects. Each node can have a left child, a right child, both, or neither. The minimum depth of a binary tree is the number of nodes along the shortest path from the root node down to the nearest leaf node. **Problem**: Implement a function that correctly computes the minimum depth of a binary tree using a recursive approach. **Function Signature**: ```python def min_depth(root): :type root: TreeNode :rtype: int ``` **Input**: * `root`: The root node of the binary tree. A node is represented by the `TreeNode` class. **Output**: * Return the integer value which is the minimum depth of the binary tree. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * The tree nodes\' values are in the range [1, 10^5]. **Examples**: ```python # Example 1: # Tree Structure: # 3 # / # 9 20 # / # 15 7 # The minimum depth of the above tree is 2. tree1 = TreeNode(3) tree1.left = TreeNode(9) tree1.right = TreeNode(20) tree1.right.left = TreeNode(15) tree1.right.right = TreeNode(7) print(min_depth(tree1)) # Output: 2 # Example 2: # Tree structure: # 1 # # 2 # The minimum depth of the above tree is 2. tree2 = TreeNode(1) tree2.right = TreeNode(2) print(min_depth(tree2)) # Output: 2 ``` **Notes**: 1. Use the correct recursive logic to compute the minimum depth. 2. Pay attention to edge cases where the provided tree might be empty or consist of only one node. 3. Ensure optimal performance both in terms of time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root): Calculated the minimum depth of a binary tree. :type root: TreeNode :rtype: int if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1"},{"question":"You are given an undirected graph represented as an adjacency list and a starting node. Your task is to count the number of connected components in the graph using both Depth-First Search (DFS) and Breadth-First Search (BFS). # Input Format - A dictionary `graph` representing the adjacency list of the graph. Each key is a node, and its value is a list of connected nodes. - An integer `start` representing the starting node for the traversal. # Output Format - An integer representing the number of connected components in the graph. # Constraints - The graph is undirected. - The graph may have disconnected components. - Multiple nodes may have no outgoing edges. # Example Input ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } start = 1 ``` Output ``` 2 ``` # Detailed Explanation Given the graph, there are two connected components `[1, 2, 3, 4]` and `[5, 6]`. Hence, the output is `2`. # Requirements Write the following two functions: 1. `count_connected_components_dfs(graph: Dict[int, List[int]], start: int) -> int` which uses depth-first search. 2. `count_connected_components_bfs(graph: Dict[int, List[int]], start: int) -> int` which uses breadth-first search. # Performance - Ensure that your solution runs efficiently for large graphs. - Keep the space complexity in mind, especially for DFS\'s recursion stack.","solution":"def count_connected_components_dfs(graph): Count the number of connected components in the graph using DFS. visited = set() component_count = 0 def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: stack.append(neighbor) for node in graph: if node not in visited: dfs(node) component_count += 1 return component_count def count_connected_components_bfs(graph): Count the number of connected components in the graph using BFS. visited = set() component_count = 0 def bfs(start_node): queue = [start_node] while queue: current = queue.pop(0) if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: queue.append(neighbor) for node in graph: if node not in visited: bfs(node) component_count += 1 return component_count"},{"question":"**Objective**: Write a function that takes a string and returns it with the words in reversed order without changing the order of characters within each word. **Context**: You are developing a text editing software that includes a feature to instantly reverse the order of words in a given sentence. This feature allows users to modify text for certain stylistic or analytical purposes. Function Signature: ```python def reverse_sentence(sentence: str) -> str: ``` Input: - A single input string `sentence` which may contain leading, trailing, or multiple spaces between words. Output: - The function should return a string with the words in reversed order, ensuring that any leading, trailing, or between-word spaces are preserved accurately. Constraints: - The input string can contain any ASCII characters. - Assume the sentence can fit in memory. Examples: ```python assert reverse_sentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_sentence(\\" Hello world \\") == \\" world Hello \\" assert reverse_sentence(\\"\\") == \\"\\" assert reverse_sentence(\\"single\\") == \\"single\\" ``` Important Points: - Do not use any built-in reverse functions or utilities that provide the functionality to directly reverse collections. - Ensure to handle edge cases such as empty strings and strings with varying spaces properly. - Implement efficient time complexity while preserving input constraints.","solution":"def reverse_sentence(sentence: str) -> str: Returns a sentence with the words in reversed order, keeping the internal order of characters within each word unchanged. # Split the sentence by whitespace while keeping the spaces words_with_spaces = [] current_word = \'\' in_space = False for char in sentence: if char == \' \': if not in_space: if current_word: words_with_spaces.append(current_word) current_word = \'\' in_space = True current_word += char else: if in_space: if current_word: words_with_spaces.append(current_word) current_word = \'\' in_space = False current_word += char if current_word: words_with_spaces.append(current_word) # Reverse the collected list of words and spaces words_with_spaces.reverse() # Join the reversed list back into a single string return \'\'.join(words_with_spaces)"},{"question":"As a matrix analyst, you are tasked with developing a more efficient function to calculate the sum of all possible sub-squares of a given size within a square matrix. The existing function is functional but may become inefficient for large matrices and sub-squares. Your objective is to optimize the given algorithm using prefix sums. This technique should allow you to compute each sub-square sum in constant time after preprocessing. Write a function `sum_sub_squares_optimized(matrix, k)` that achieves this. Input * `matrix`: A 2D list of integers representing an ( n times n ) square matrix. * `k`: An integer representing the size of the sub-squares. Output * Returns a 2D list of integers where each entry represents the sum of the corresponding ( k times k ) sub-square in the input matrix. Constraints * ( 1 leq n leq 500 ) * ( 1 leq k leq n ) Performance Requirements * The function should preprocess the matrix and compute the prefix sums in ( O(n^2) ) time. * Each sub-square\'s sum should be computed in ( O(1) ) time. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 assert sum_sub_squares_optimized(matrix, k) == [ [12, 16], [24, 28] ] ``` Tips * Consider building a prefix sum matrix where each entry at (i, j) in this matrix represents the sum of all elements in the rectangular sub-matrix from (0, 0) to (i, j). * Use this prefix sum matrix to efficiently compute any sub-square sum with minimal additional computation.","solution":"def sum_sub_squares_optimized(matrix, k): n = len(matrix) # Create prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = (matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) result = [] for i in range(n - k + 1): row = [] for j in range(n - k + 1): total = (prefix_sum[i + k][j + k] - prefix_sum[i][j + k] - prefix_sum[i + k][j] + prefix_sum[i][j]) row.append(total) result.append(row) return result"},{"question":"# Context You are building a data cleaning and normalization pipeline for a text processing application. One of the tasks is to remove duplicate characters from input strings while maintaining the original order of characters as they first appear in the string. # Problem Statement Write a function `remove_duplicates` that takes an input string and returns a new string with all reoccurring characters removed. The function should preserve the order of first appearance of characters. # Function Signature ```python def remove_duplicates(string: str) -> str: ``` # Input * A string `string` with a length of up to 10^5 characters. The string can contain any printable ASCII characters. # Output * A string with all reoccurring characters removed, preserving the order of the first occurrence. # Examples ```python assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"abcabc\\") == \\"abc\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"aAaAaA\\") == \\"aA\\" ``` # Constraints * For case-sensitive handling: * `remove_duplicates(\\"aAaA\\")` should return `\\"aA\\"`. # Performance Requirements * The solution should run in O(n) time complexity, where n is the length of the input string. * The solution should have O(n) auxiliary space complexity. # Notes * Consider edge cases as part of your implementation. * Pay attention to the performance and corner cases given the maximum input size.","solution":"def remove_duplicates(string: str) -> str: Remove duplicate characters from the string while preserving the order of their first occurrence. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Cycle Detection in Directed Graphs Context You are developing a system to manage resource allocation among multiple processes. Each process can request resources held by other processes, leading to dependencies. To ensure that your system does not encounter deadlocks (where processes wait indefinitely for each other to release resources), you need to detect if there are any circular dependencies (cycles) in the graph representing process-resource links. Task Write a function `contains_cycle(graph: Dict[Any, List[Any]]) -> bool` in Python that determines if a given directed graph contains any cycles. Input - `graph`: A dictionary where keys are nodes (vertices) and values are lists of adjacent nodes (edges). Example: ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} ``` Output - Returns `True` if there is at least one cycle in the graph. - Returns `False` if there are no cycles. Constraints 1. Vertices are unique and can be any hashable type. 2. The graph may have no vertices or edges. 3. Optimize the function to handle large graphs efficiently. Example 1. Given the graph: ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} ``` Calling `contains_cycle(graph)` should return `True`, since there is a cycle involving nodes B, D, and E. 2. Given the graph: ```python graph = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': []} ``` Calling `contains_cycle(graph)` should return `False`, as there are no cycles. Additional Notes - Pay attention to edge cases such as graphs with a single node and graphs where nodes have self-loops. - Ensure your solution handles large inputs efficiently.","solution":"def contains_cycle(graph): Determines if the directed graph contains any cycles. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph: if dfs(node): return True return False"},{"question":"# Problem Description Imagine you are building a system that frequently processes dynamic datasets using binary search trees (BST). One common operation in your system is to find the k-th smallest element in a BST, which means traversing the tree in a sorted manner. Given a BST, your task is to implement a module to find this k-th smallest element effectively. # Function Specifications You are required to implement the following function: ```python def kth_smallest(root: Node, k: int) -> int: Find the k-th smallest element in a binary search tree. :param root: Node, the root of the BST :param k: int, the order (1-indexed) of the smallest element to find :return: int, the k-th smallest element in the BST ``` # Input - `root`: The root node of a binary search tree. - `k`: An integer indicating the order of the smallest element to find (1-indexed). # Output - An integer representing the k-th smallest element. # Constraints - The BST will have at most 10^4 nodes. - The value of k will always be valid, i.e., 1 <= k <= number of elements in the BST. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Construct the following BST # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(kth_smallest(n1, 2)) # Output: 50 ``` # Notes - You may choose to implement an iterative or recursive solution based on your preference. - Consider edge cases where the BST is minimal (e.g., a single node) or very unbalanced. - Write your function to handle large inputs efficiently.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in a binary search tree. :param root: Node, the root of the BST :param k: int, the order (1-indexed) of the smallest element to find :return: int, the k-th smallest element in the BST # In-order traversal of BST def in_order_traverse(node): if node is None: return [] # Traverse the left subtree left = in_order_traverse(node.left) # Traverse the current node cur = [node.val] # Traverse the right subtree right = in_order_traverse(node.right) return left + cur + right # Get all elements in sorted order sorted_elements = in_order_traverse(root) # Return the k-th smallest element return sorted_elements[k - 1]"},{"question":"# Question: You are provided with an array of integers. Write a function `find_max_subarray_sum(array: List[int]) -> Tuple[int, Tuple[int, int]]` that implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray. Additionally, the function should return the starting and ending indices of this subarray. Input - A list of integers `array` with length `n` (1 <= n <= 10^5), where the values of elements can range from -10^4 to 10^4. Output - A tuple where the first element is an integer representing the maximum sum. - The second element is a tuple of two integers representing the starting and ending indices (0-based) of the subarray that produces this maximum sum. Constraints - If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. - Do not use any external libraries for the implementation. Example ```python assert find_max_subarray_sum([1, 2, -3, 4, 5, -7, 23]) == (25, (3, 6)) assert find_max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == (7, (2, 6)) assert find_max_subarray_sum([2, 3, 1, -1, 3]) == (8, (0, 4)) ``` Ensure your solution is optimal in terms of time complexity and handle edge cases effectively. Implement the function in Python.","solution":"from typing import List, Tuple def find_max_subarray_sum(array: List[int]) -> Tuple[int, Tuple[int, int]]: Implements Kadane\'s Algorithm to find the maximum sum of a contiguous subarray, and returns the sum along with the starting and ending indices of the subarray. max_sum = float(\'-inf\') current_sum = 0 start_idx = 0 temp_start_idx = 0 end_idx = 0 for i, num in enumerate(array): if current_sum <= 0: temp_start_idx = i current_sum = num else: current_sum += num if current_sum > max_sum: max_sum = current_sum start_idx = temp_start_idx end_idx = i return (max_sum, (start_idx, end_idx))"},{"question":"**Context**: You are given two strings `s` and `t` where `t` is generated by shuffling `s` and then adding exactly one more letter at a random position. Your task is to identify the additional letter in `t`. **Objective**: Implement a function `find_difference` that returns the extra character added to `t`. **Function Signature**: ```python def find_difference(s: str, t: str) -> str: # Your code here ``` **Input**: * `s` (str): A string containing lowercase letters. * `t` (str): A string containing a permutation of `s` with one additional character. **Output**: * (str): The additional character in `t`. **Constraints**: * Both strings `s` and `t` will only contain lowercase letters (\'a\' to \'z\'). * The length of `t` will be exactly one more than the length of `s`. **Performance Requirements**: * The solution should run in linear time, (O(n)), where (n) is the length of the input strings. * The solution should use constant additional space, (O(1)). # Example ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"apple\\", \\"ppale\\") == \'a\' assert find_difference(\\"xyz\\", \\"yxzx\\") == \'x\' ```","solution":"def find_difference(s: str, t: str) -> str: char_code_difference = 0 # Sum all char codes in string `t` for char in t: char_code_difference += ord(char) # Subtract all char codes in string `s` for char in s: char_code_difference -= ord(char) # The result will be the additional character\'s char code return chr(char_code_difference)"},{"question":"# Coding Challenge: Validate Sorted Linked List Context You are working on a data processing system that frequently needs to validate if a series of records (represented as a linked list) are sorted in non-decreasing order. To ensure efficiency in subsequent operations, you need a function to verify the order of the records. Objective Write a function `is_sorted(head)` that takes the head of a singly linked list and returns `True` if the list is sorted in non-decreasing order, and `False` otherwise. An empty list is considered to be sorted. Function Signature ```python def is_sorted(head: Optional[ListNode]) -> bool: ``` Input - `head` (Optional[ListNode]): The head of a singly linked list where each node contains an integer value and a reference to the next node. Output - `True` if the linked list is sorted in non-decreasing order. - `False` otherwise. Constraints - The linked list can have between 0 and 10^5 nodes. - Node values can be any integer within the range of -10^9 to 10^9. Example Given the linked list: 1 -> 2 -> 3 -> 4 is_sorted(head) should return `True`. Given the linked list: 1 -> 2 -> -1 -> 3 is_sorted(head) should return `False`. Notes - You can assume that the ListNode class is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` - Consider carefully handling edge cases such as empty lists or lists with only one element.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Returns True if the linked list is sorted in non-decreasing order, False otherwise. if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# **Converting Integers with Specific Endianness Byte Representation** You are working on a data serialization scheme that ensures cross-hardware compatibility when exchanging integer data. In this context, you need to handle integers and convert them to byte arrays and back to integers while maintaining a specific byte order (endianness). Write a Python function for each of the following tasks: 1. Convert an integer to a big-endian byte array. 2. Convert an integer to a little-endian byte array. 3. Convert a big-endian byte array back to an integer. 4. Convert a little-endian byte array back to an integer. # **Function Signatures** ```python def int_to_bytes_big_endian(num: int) -> bytes: pass def int_to_bytes_little_endian(num: int) -> bytes: pass def bytes_big_endian_to_int(bytestr: bytes) -> int: pass def bytes_little_endian_to_int(bytestr: bytes) -> int: pass ``` # **Input and Output Formats** - **int_to_bytes_big_endian(num)**: - **Input**: An integer `num` (0 ≤ num ≤ 2^64 - 1). - **Output**: A `bytes` object representing the number in big-endian order. - **int_to_bytes_little_endian(num)**: - **Input**: An integer `num` (0 ≤ num ≤ 2^64 - 1). - **Output**: A `bytes` object representing the number in little-endian order. - **bytes_big_endian_to_int(bytestr)**: - **Input**: A `bytes` object `bytestr` representing a number in big-endian order. - **Output**: An integer converted from the bytes. - **bytes_little_endian_to_int(bytestr)**: - **Input**: A `bytes` object `bytestr` representing a number in little-endian order. - **Output**: An integer converted from the bytes. # **Constraints and Requirements** 1. Your implementation should handle `0` and `positive integers` up to `2^64 - 1`. 2. Consider empty byte arrays as valid input for `bytes_to_int` functions which should return `0`. 3. Performance efficiency should be considered: The solution should handle conversions in linear time relative to the number of bytes. 4. Ensure to handle any edge cases like maximum integer boundary and validate input types inside your function. # **Example** ```python # Example of big-endian conversion print(int_to_bytes_big_endian(305419896)) # Output: b\'x12x34x56x78\' print(bytes_big_endian_to_int(b\'x12x34x56x78\')) # Output: 305419896 # Example of little-endian conversion print(int_to_bytes_little_endian(305419896)) # Output: b\'xV4x12\' print(bytes_little_endian_to_int(b\'xV4x12\')) # Output: 305419896 ``` Implement the above functions in the cell below. Ensure your code is readable, efficient, and handles all specified edge cases.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Convert an integer to a big-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'big\') or b\'x00\' def int_to_bytes_little_endian(num: int) -> bytes: Convert an integer to a little-endian byte array. return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'little\') or b\'x00\' def bytes_big_endian_to_int(bytestr: bytes) -> int: Convert a big-endian byte array back to an integer. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Convert a little-endian byte array back to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Problem Description You are given a binary tree. Your task is to write a function `find_deepest_left_leaf(root) -> int` that finds and returns the value of the deepest left leaf node in the tree. If there are multiple nodes at the same depth, return any one of them. If the tree is empty or there is no left leaf node, return `None`. # Function Signature ```python def find_deepest_left_leaf(root: TreeNode) -> int: # Your code here ``` # Input - `root` (TreeNode): The root node of the binary tree. # Output - (int): The value of the deepest left leaf node. If no such node exists, return `None`. # Constraints - The number of nodes in the tree will be between 0 and 10^4. - Each node in the tree will have a unique integer value. # Example Example 1 ``` Input: 1 / 2 3 / 4 5 6 7 Output: 4 ``` Example 2 ``` Input: 1 2 Output: None ``` # Detailed Requirements 1. Traverse the tree using depth-first search (DFS). 2. Keep track of the depth of each node. 3. Only consider nodes that are left children. 4. Update the deepest left node found so far during traversal. 5. Return the value of the deepest left node. You are required to use a helper class to keep track of depth during the traversal. ```python class Result: def __init__(self): self.depth = 0 self.node_val = None ``` **Note**: Remember to handle edge cases where the tree is empty or where there are no left leaf nodes.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class Result: def __init__(self): self.depth = 0 self.node_val = None def find_deepest_left_leaf(root): if root is None: return None def dfs(node, depth, is_left, result): if node is None: return if is_left and node.left is None and node.right is None: if depth > result.depth: result.depth = depth result.node_val = node.value dfs(node.left, depth + 1, True, result) dfs(node.right, depth + 1, False, result) result = Result() dfs(root, 0, False, result) return result.node_val"},{"question":"# Matrix Transformation Challenge **Objective**: Implement a function to perform various matrix transformations. # Background: Given a 2D matrix, transformations such as rotations and inversions can be applied. You are required to implement the matrix transformation functions with an emphasis on performance and handling edge cases. # Transformations to Implement: 1. **rotate_clockwise(matrix)**: Rotates the matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Mirrors the elements of the matrix from the top-left to the bottom-right. 4. **bottom_left_invert(matrix)**: Mirrors the elements of the matrix from the bottom-left to the top-right. # Function Signatures: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` # Input: - A list of lists of integers representing the matrix. - The matrix may be non-square, and it can contain anything from 0 to 1000 elements in total. # Output: - A new list of lists of integers representing the transformed matrix. # Constraints: - The matrix can be empty (i.e., `matrix == []` or `matrix == [[]]`). - The matrix and its elements are immutable; the original matrix must remain unchanged. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(top_left_invert(matrix)) # Output: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` # Performance Requirements: - The time complexity should be O(n*m). - The space complexity should be O(n*m). # Notes: - A matrix containing one row or one column should be handled gracefully. - An empty matrix should return an empty matrix.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] return [list(reversed(col)) for col in zip(*matrix)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] return [list(col) for col in reversed(list(zip(*matrix)))] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] return [row.copy() for row in matrix] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] return [list(reversed(row)) for row in matrix[::-1]]"},{"question":"# Challenge: Stack Stuttering You are tasked with implementing a function `stutter` that will replace each element of a given stack with two occurrences of that element. You will provide two solutions for this implementation: one using another stack for auxiliary storage and the other using a queue. # Function Signatures ```python def first_stutter(stack): pass def second_stutter(stack): pass ``` # Input and Output Formats * **Input**: A stack represented as a list of integers. The bottom of the stack is the first element of the list, and the top is the last. * **Output**: The modified stack where each element is replaced by two of the same element. * The function modifies the stack in-place but also returns it for convenience. # Constraints and Performance Requirements * You may assume the stack has at most 10^4 elements. * Your solution should efficiently handle the described operations, both in terms of time and space. # Example Given a stack `[3, 7, 1, 14, 9]`, after applying `first_stutter` or `second_stutter`, it should be `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. # Considerations * Handle empty stacks appropriately. * Ensure the functions do not unnecessarily use additional memory or have redundant operations. # Sample Input ```python stack = [3, 7, 1, 14, 9] ``` # Sample Output ```python [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Implement both versions of the `stutter` function following the structure and guidelines provided above.","solution":"def first_stutter(stack): Stutter the elements of the stack using another stack for auxiliary storage. :param stack: List[int] - input stack to be stuttered :return: List[int] - stuttered stack aux_stack = [] # Push each element twice in the auxiliary stack while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Populate the original stack with elements from the auxiliary stack preserving order while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack): Stutter the elements of the stack using a queue for auxiliary storage. :param stack: List[int] - input stack to be stuttered :return: List[int] - stuttered stack from collections import deque queue = deque() # Enqueue each element twice while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) # Populate the original stack with elements from the queue preserving order while queue: stack.append(queue.popleft()) return stack"},{"question":"**Question**: Implement an AVL Tree with the following functionalities: 1. **insert(key)**: Insert a new key into the AVL tree while maintaining its balanced property. 2. **delete(key)**: Delete a key from the AVL tree while maintaining its balanced property. 3. **in_order_traversal()**: Return a list of keys in the AVL tree in sorted order. 4. **is_balanced()**: Return a boolean indicating whether the tree is maintaining the AVL property of being balanced. This would typically involve checking if every node meets the balance factor property. # Input/Output Format: - **insert(key)**: - **Input**: A key (integer) to insert. - **Output**: None. - **delete(key)**: - **Input**: A key (integer) to delete. - **Output**: None. - **in_order_traversal()**: - **Input**: None. - **Output**: A list of integers in sorted order. - **is_balanced()**: - **Input**: None. - **Output**: Boolean value indicating balance status (True if balanced, False if not). # Constraints: - All keys inserted will be integers. - The tree should not contain duplicate keys. - The height of the tree should remain bounded by O(log n). # Performance Requirements: Ensure that the insert and delete operations run in O(log n) time complexity, thanks to the balancing operations. # Example: ```python avl = AvlTree() avl.insert(20) avl.insert(15) avl.insert(25) avl.insert(10) avl.delete(15) print(avl.in_order_traversal()) # Output: [10, 20, 25] print(avl.is_balanced()) # Output: True ``` Implement the above functionalities in Python.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp_node = self._get_min_value_node(node.right) node.key = temp_node.key node.right = self._delete(node.right, temp_node.key) if node is None: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) # Left Right if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Right if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) # Right Left if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) def is_balanced(self): def check_balance(node): if not node: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) current_balance = left_balanced and right_balanced and abs(left_height - right_height) <= 1 current_height = 1 + max(left_height, right_height) return current_balance, current_height balanced, _ = check_balance(self.root) return balanced def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"**Context**: You are required to work with a dataset that supports frequent modifications and queries for cumulative sums. Implement the Fenwick Tree data structure to handle multiple operations efficiently. **Function Implementation Requirements**: 1. **Function Name**: `fenwick_tree(arr, operations)` 2. **Input**: - `arr`: List of integers representing the initial array. - `operations`: List of tuples representing operations where each tuple can be: * `(\'query\', end_index)`: to return the sum of elements from index 0 to `end_index`. * `(\'update\', index, value)`: to update the element at `index` to `value`. 3. **Output**: - List of results for `query` operations in the order they appear in the `operations` list. 4. **Constraints**: - All indices are 0-based. - The array length will be up to 10^5. - The number of operations can be up to 10^5. **Examples**: ```python arr = [1, 2, 3, 4, 5] operations = [(\'query\', 2), (\'update\', 1, 6), (\'query\', 3)] # The initial array sums up to [1, 3 (1+2), 6 (1+2+3),...] # After updating index 1 from 2 to 6, the array becomes [1, 6, 3, 4, 5] # The new sums are [1, 7 (1+6), 10 (1+6+3),...] # Expected Output: [6, 14] ``` **Note**: - Ensure efficiency to handle large datasets. - Use Fenwick Tree for sum and update operations.","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i in range(self.n): self._update_tree(i, arr[i]) def _update_tree(self, index, delta): index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def update(self, index, value): delta = value - self.arr[index] self.arr[index] = value self._update_tree(index, delta) def query(self, index): index += 1 result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def fenwick_tree(arr, operations): fenwick = FenwickTree(arr) results = [] for operation in operations: if operation[0] == \'query\': end_index = operation[1] results.append(fenwick.query(end_index)) elif operation[0] == \'update\': index, value = operation[1], operation[2] fenwick.update(index, value) return results"},{"question":"# Question Scenario You are given the task to implement a specialized stack which automatically sorts its elements in descending order upon insertion. This feature is particularly useful in scenarios where accessing the maximum element repeatedly is needed, such as in priority scheduling systems or for maintaining sorted history records. Task Implement the `OrderedStack` class, which should contain the following methods: * `push(item)` - Insert `item` into the stack, preserving the descending order. * `pop()` - Remove and return the top element (highest value) of the stack. * `peek()` - Returns the top element without removing it. * `is_empty()` - Returns `True` if the stack is empty, else `False`. * `size()` - Returns the number of elements in the stack. Input and Output Format - `push(item)` does not return any value. `item` can be any integer. - `pop()` returns an integer which is the top element of the stack. - `peek()` returns an integer which is the top element of the stack. - `is_empty()` returns a boolean. - `size()` returns an integer representing the stack size. Constraints - Assume the stack can hold a very large number of elements, such as 10^5. Performance - Time complexity for `push` should not exceed O(n). - `pop`, `peek`, `is_empty`, and `size` should operate in O(1) time. Example ``` stack = OrderedStack() stack.push(5) stack.push(3) stack.push(7) print(stack.pop()) # Output: 7 print(stack.peek()) # Output: 5 print(stack.size()) # Output: 2 print(stack.is_empty()) # Output: False ``` Implementation Write your implementation of the `OrderedStack` class below.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item: int) -> None: Insert item into the stack, maintaining descending order. # Perform a binary search to find the correct insertion index low, high = 0, len(self.stack) while low < high: mid = (low + high) // 2 if self.stack[mid] < item: high = mid else: low = mid + 1 self.stack.insert(low, item) def pop(self) -> int: Remove and return the top element (highest value) of the stack. if self.stack: return self.stack.pop(0) raise IndexError(\\"pop from an empty stack\\") def peek(self) -> int: Returns the top element without removing it. if self.stack: return self.stack[0] raise IndexError(\\"peek from an empty stack\\") def is_empty(self) -> bool: Returns True if the stack is empty, else False. return len(self.stack) == 0 def size(self) -> int: Returns the number of elements in the stack. return len(self.stack)"},{"question":"# Question: Find the Range of a Target Value Given an array of integers `nums` sorted in ascending order, you are to find the starting and ending positions of a given target value. Your task is to improve the provided `search_range` function to handle all necessary edge cases efficiently. # Input: * `nums`: List of integers sorted in ascending order. * `target`: An integer representing the target value. # Output: A list of two integers indicating the start and end indices of the target value in the array. Return `[-1, -1]` if the target is not found. # Constraints: * `1 <= len(nums) <= 10^5` * `-10^9 <= nums[i], target <= 10^9` # Example: ```plaintext Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3, 5] Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] ``` # Performance Requirements: * Your solution should aim for `O(log n)` time complexity combined for start and end positions and `O(1)` space complexity. # Instructions: Implement the function `search_range(nums, target)` in Python which returns a list of two integers.","solution":"def search_range(nums, target): Return the start and end indices of target in nums. If target is not found, return [-1, -1]. def find_start(): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 else: high = mid - 1 return low def find_end(): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] > target: high = mid - 1 else: low = mid + 1 return high start = find_start() end = find_end() if start <= end and start < len(nums) and end >= 0 and nums[start] == target and nums[end] == target: return [start, end] else: return [-1, -1]"},{"question":"# **Context** You are designing a protocol for a messaging system where multiple short strings need to be sent as a single message over the network. To ensure that the original list of strings can be accurately reconstructed upon receipt, you must encode the list into a single string and then decode it back to its original form. # **Task** Write two functions: `encode` and `decode`. - **Function 1: `encode`** - **Description**: Encodes a list of strings to a single string. - **Input**: A list of strings `strs`. - **Output**: A single encoded string. - **Function 2: `decode`** - **Description**: Decodes the single string back to the original list of strings. - **Input**: A single string `s`. - **Output**: A list of strings. # **Constraints** - The list of strings input to `encode` is guaranteed to contain only valid strings. - Strings may include spaces but will not contain the delimiter character `\\":\\"`. # **Performance Requirements** - Both functions should have a time complexity of O(n), where n is the length of the input data. # **Example** ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs # Example Usage: encoded_string = encode([\\"hello\\", \\"world\\"]) print(encoded_string) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` # **Scenarios to Test** - Input: `[\\"a\\", \\"bc\\", \\"def\\"]` -> Expected output after encoding: `\\"1:a2:bc3:def\\"` -> Decoded output: `[\\"a\\", \\"bc\\", \\"def\\"]`. - Input: `[\\"\\"]` -> Expected output: `\\"0:\\"` -> Decoded output: `[\\"\\"]`. - Input: `[\\"longtext\\", \\"anotherlongtext\\"]` -> Expected output: length-prefixed encoded string -> Decoded output: original list. Ensure your implementation handles these cases effectively.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index + 1: index + 1 + size]) i = index + 1 + size return strs"},{"question":"# Questions: Implement Advanced Counting Sort Context & Objective You have been hired by a company that handles large datasets of stock transactions. One core task is to quickly sort these transactions by transaction amounts. Here, the range of transaction amounts is broad but the number of unique transaction amounts is relatively small compared to the full range. Implement an optimized version of the Counting Sort that minimizes memory usage for sparse data. Task Implement a function `counting_sort_optimized(arr: List[int]) -> List[int]` that sorts an input list efficiently, given that the list may contain negative numbers and a large range of values. Input * A list of integers `arr` where the values may range significantly but the number of unique transaction amounts is small compared to this range. Output * A sorted list of integers. Constraints * The values in `arr` can range from -10^6 to 10^6. * The length of `arr` is between 0 and 10^6. Performance Requirements Your solution should: * Optimize for memory usage given the sparsity of values. * Handle edge cases such as negative numbers and empty list efficiently. * Maintain the time complexity as close as possible to O(n). Example ```python from typing import List def counting_sort_optimized(arr: List[int]) -> List[int]: # Your implementation here # Example usage arr = [4, 2, 2, 8, 3, 3, 1, -3, -3, -1000000, 1000000] sorted_arr = counting_sort_optimized(arr) print(sorted_arr) # Output: [-1000000, -3, -3, 1, 2, 2, 3, 3, 4, 8, 1000000] ```","solution":"from typing import List from collections import defaultdict def counting_sort_optimized(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) # Use defaultdict for sparse counting count_dict = defaultdict(int) for num in arr: count_dict[num] += 1 sorted_arr = [] for num in range(min_val, max_val + 1): sorted_arr.extend([num] * count_dict[num]) return sorted_arr"},{"question":"You have been hired as a software engineer for a tech company that maintains large sorted datasets. One of your tasks is to optimize the insertion of new data points into these sorted datasets efficiently. You are given a sorted list of integers and a target integer. Your goal is to find the index at which the target should be inserted into the list to maintain the sorted order. Implement a function `search_insert(array, val)` that: - Takes a sorted list of integers `array` and an integer `val` as inputs. - Returns the index at which `val` should be inserted to keep the list sorted. # Input - `array`: A list of sorted integers (can be empty). - `val`: An integer `val` that needs to be inserted. # Output - An integer representing the index where `val` should be inserted. # Constraints - The length of `array` is in the range [0, 10^5]. - Each element of `array` and `val` is an integer where -10^4 <= `array[i]`, `val` <= 10^4. - The input list `array` is sorted in ascending order. # Performance Requirements - The solution should run in O(log n) time complexity. # Example ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 ``` # Edge Cases - The target value is smaller than all elements in the array. - The target value is larger than all elements in the array. - The target value is equal to one of the elements in the array. - The input array is empty. Good luck, and be sure to think through your solution efficiently!","solution":"def search_insert(array, val): Returns the index at which val should be inserted to keep the array sorted. Assumes array is sorted in ascending order. low, high = 0, len(array) while low < high: mid = (low + high) // 2 if array[mid] < val: low = mid + 1 else: high = mid return low"},{"question":"# Context You are tasked with implementing a function to compress and decompress a sequence of strings using the Run-Length Encoding (RLE) algorithm. This is a simple form of data compression where sequences of the same data value are stored as a single data value and count. # Task Implement two functions, `custom_encode_rle()` and `custom_decode_rle()`, that perform Run-Length Encoding and Decoding respectively. # Encode Function This function will take a list of strings and return a list of their Run-Length Encoded versions. Input: - A list of strings. Each string can be empty or contain only characters. Output: - A list of encoded strings, where each string is encoded using RLE. Constraints: - The length of the input list will be at most 1000. - Each string in the input list will have a length of at most 2000. - Characters can be any visible ASCII characters. # Decode Function This function will take a list of encoded strings and return a list of their decoded (original) versions. Input: - A list of strings, where each string is encoded using RLE. Output: - A list of decoded strings. Constraints: - The length of the input list will be at most 1000. - Each string in the input list will have a length of at most 4000. - Encoded strings will use valid Run-Length Encoding format with counts followed by characters. # Example ```python input_strings = [\\"aaabccc\\", \\"eeeeffff\\", \\"gg\\"] encoded_strings = custom_encode_rle(input_strings) # Expected Output: [\\"3a1b3c\\", \\"4e4f\\", \\"2g\\"] decoded_strings = custom_decode_rle(encoded_strings) # Expected Output: [\\"aaabccc\\", \\"eeeeffff\\", \\"gg\\"] ``` # Requirements: 1. Implement `custom_encode_rle(input_list: List[str]) -> List[str]` 2. Implement `custom_decode_rle(input_list: List[str]) -> List[str]` 3. Ensure the encoded and decoded lists maintain the same order as the input.","solution":"def custom_encode_rle(input_list): Encode a list of strings using Run-Length Encoding (RLE). Args: input_list (List[str]): List of strings to be encoded. Returns: List[str]: List of RLE encoded strings. encoded_list = [] for s in input_list: if not s: encoded_list.append(\\"\\") continue encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{s[i-1]}\\") count = 1 encoded_str.append(f\\"{count}{s[-1]}\\") encoded_list.append(\\"\\".join(encoded_str)) return encoded_list def custom_decode_rle(input_list): Decode a list of strings that were encoded using Run-Length Encoding (RLE). Args: input_list (List[str]): List of RLE encoded strings. Returns: List[str]: List of decoded strings. decoded_list = [] for s in input_list: if not s: decoded_list.append(\\"\\") continue decoded_str = [] count = 0 for char in s: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 decoded_list.append(\\"\\".join(decoded_str)) return decoded_list"},{"question":"Minimum Repeated Substring Match Problem Statement You are given two non-empty strings `A` and `B`. Your task is to determine the minimum number of times the string `A` must be repeated such that `B` becomes a substring of the resultant repeated string. If it is not possible for `B` to be a substring regardless of the number of repetitions, return `-1`. Input * A single string `A` of length n (1 <= n <= 10,000). * A single string `B` of length m (1 <= m <= 10,000). Output * A single integer which is the minimum number of times `A` must be repeated. If `B` cannot be a substring of any repeated version of `A`, return `-1`. Constraints * The sum of lengths of all input strings in one test case do not exceed 20,000. Example ```python A = \\"abcd\\" B = \\"cdabcdab\\" # The output should be 3 because repeating \\"abcd\\" three times (\\"abcdabcdabcd\\") will contain \\"cdabcdab\\" as a substring. ``` Note * Consider handling edge cases such as: - `A` or `B` containing distinct characters that are not part of each other. - Strings that are already overlapping partly. Function Signature ```python def repeat_string(A: str, B: str) -> int: pass ``` Craft your solution to ensure optimal performance and handle edge cases effectively.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times A must be repeated such that B becomes a substring of the repeated A. # Calculate the minimal number of repetitions needed. times = -(-len(B) // len(A)) # This is ceiling of len(B) / len(A) # Check for the minimum number of times A needs to be repeated. repeated_A = A * times # If B is already in the repeated_A return times if B in repeated_A: return times # Try one more repeat to cover scenarios where B might start at the end of one repeat and end at the start of next. repeated_A += A if B in repeated_A: return times + 1 return -1"},{"question":"You are tasked with designing a function to generate all possible permutations of a given list of distinct integers. This exercise is designed to test your understanding of backtracking algorithms and handling recursion efficiently. Function Signature ```python def generate_permutations(elements: List[int]) -> List[List[int]]: pass ``` # Input - A list of distinct integers where `0 <= len(elements) <= 10`. # Output - A list of lists, where each sublist represents a unique permutation of the input list. # Constraints - The length of the input list will not exceed 10 due to factorial time complexity. - You must utilize the backtracking approach to generate permutations. # Performance Requirements - The solution should handle the generation of up to 10! permutations efficiently. - Utilize memory efficiently, especially when dealing with recursion. # Example ```python # Example 1 input_list = [1, 2, 3] output = generate_permutations(input_list) # Expected Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] # Example 2 input_list = [] output = generate_permutations(input_list) # Expected Output: # [] ``` # Notes - You must handle edge cases like an empty list or a list with a single element. - Ensure that your function can handle inputs at the upper limit efficiently. # Hints - Consider using a helper function for the recursive logic. - Think about how to build permutations iteratively and recursively. Good luck, and happy coding!","solution":"from typing import List def generate_permutations(elements: List[int]) -> List[List[int]]: def backtrack(start=0): # if we reached the end of the list, we found a permutation if start == len(elements): permutations.append(elements[:]) for i in range(start, len(elements)): # swapping elements[start], elements[i] = elements[i], elements[start] # recurse backtrack(start + 1) # backtrack (swap back) elements[start], elements[i] = elements[i], elements[start] permutations = [] if elements: backtrack() return permutations"},{"question":"# Topological Sort Implementation **Context**: Given a directed graph representing tasks and their dependencies, where each task is represented as a node and a directed edge from node `u` to node `v` implies that task `u` must be completed before task `v`, you need to find a valid order to finish all tasks. If tasks cannot be ordered due to a cycle, your implementation should handle this error gracefully. **Task**: Write a function `topological_sort` that takes a dictionary representing a directed graph and returns a list of nodes in topologically sorted order. If the graph contains a cycle, raise a `ValueError` with the message \\"cycle\\". **Function Signature**: ```python def topological_sort(graph: dict) -> list: Parameters: graph (dict): A dictionary representing the directed graph where key is a node and value is a list of nodes it points to. Returns: list: A topologically sorted list of nodes. Raises: ValueError: If the graph contains a cycle. pass ``` **Input**: 1. `graph` (dict): A dictionary where key is a node (int/str) and value is a list of nodes it points to. **Output**: 1. A list of nodes in topological order, if the graph contains no cycles. **Constraints**: * Nodes are represented as integers or strings. * The graph can have between 0 and 10^4 vertices. **Example**: ```python graph = { 5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 0: [], 1: [] } assert topological_sort(graph) == [4, 5, 2, 3, 1, 0] ``` **Notes**: 1. If there are multiple valid topological orders, any of them is accepted. 2. Handle edge cases like graphs with no nodes, no edges, or disconnected components appropriately.","solution":"def topological_sort(graph): Parameters: graph (dict): A dictionary representing the directed graph where key is a node and value is a list of nodes it points to. Returns: list: A topologically sorted list of nodes. Raises: ValueError: If the graph contains a cycle. def dfs(node): if visited[node] == 1: # Node is being processed, means a cycle raise ValueError(\\"cycle\\") if visited[node] == 2: # Node is already processed return visited[node] = 1 # Mark node as being processed for neighbor in graph.get(node, []): dfs(neighbor) visited[node] = 2 # Mark node as fully processed topological_order.append(node) visited = {node: 0 for node in graph} # 0 = unvisited, 1 = visiting, 2 = visited topological_order = [] for node in graph: if visited[node] == 0: # if node is not visited dfs(node) return topological_order[::-1]"},{"question":"# Question **Graph Path Finder** You are provided with a class `Graph` that represents a directed graph. Implement the `dfsutil` method to accurately determine if there is a path from a source node to a target node using Depth First Search (DFS). Additionally, fix any errors in the method to ensure it works correctly. Class Definition: ```python class Graph: def __init__(self, vertex_count): Initializes the directed graph with a given number of vertices. :param vertex_count: Number of vertices in the graph. self.vertex_count = vertex_count self.graph = defaultdict(list) self.has_path = False def add_edge(self, source, target): Adds a directed edge from source to target. :param source: Start vertex of the edge. :param target: End vertex of the edge. self.graph[source].append(target) def dfs(self, source, target): Initiates a DFS traversal from the source to determine if there is a path to the target. :param source: The starting vertex. :param target: The target vertex to reach. visited = [False] * self.vertex_count self.dfsutil(visited, source, target) def dfsutil(self, visited, source, target): Recursive helper function for DFS traversal. :param visited: List to keep track of visited vertices. :param source: Current vertex in DFS traversal. :param target: Target vertex to reach. # Your task is to implement this method correctly def is_reachable(self, source, target): Determines if there is a path from source to target. :param source: The starting vertex. :param target: The target vertex to reach. :return: True if there is a path, False otherwise. self.has_path = False self.dfs(source, target) return self.has_path ``` Requirements: 1. Implement the `dfsutil` method such that it correctly uses DFS to determine if there\'s a path from `source` to `target`. 2. Make sure to set `self.has_path` to `True` as soon as the target is found to optimize the search. 3. The input parameters to `dfsutil` include: - `visited`: A list of booleans to keep track of visited vertices. - `source`: The current node in the DFS traversal. - `target`: The target node for which we need to determine the reachability. Input Format: - `vertex_count`: An integer representing the number of vertices. - `edges`: A list of tuples where each tuple contains two integers representing a directed edge from source to target. - `source`: The starting vertex. - `target`: The target vertex. Output Format: - Return `True` if there is a path from `source` to `target`. - Return `False` otherwise. Constraints: - All vertices are 0-indexed. - 2 ≤ vertex_count ≤ 10^3. - 0 ≤ edges count ≤ 10^4. - 0 ≤ source, target < vertex_count. Example: ```python # Create a graph with 4 vertices g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) print(g.is_reachable(0, 3)) # Output: True print(g.is_reachable(3, 0)) # Output: False ```","solution":"from collections import defaultdict class Graph: def __init__(self, vertex_count): Initializes the directed graph with a given number of vertices. :param vertex_count: Number of vertices in the graph. self.vertex_count = vertex_count self.graph = defaultdict(list) self.has_path = False def add_edge(self, source, target): Adds a directed edge from source to target. :param source: Start vertex of the edge. :param target: End vertex of the edge. self.graph[source].append(target) def dfs(self, source, target): Initiates a DFS traversal from the source to determine if there is a path to the target. :param source: The starting vertex. :param target: The target vertex to reach. visited = [False] * self.vertex_count self.dfsutil(visited, source, target) def dfsutil(self, visited, source, target): Recursive helper function for DFS traversal. :param visited: List to keep track of visited vertices. :param source: Current vertex in DFS traversal. :param target: Target vertex to reach. if source == target: self.has_path = True return visited[source] = True for neighbor in self.graph[source]: if not visited[neighbor]: self.dfsutil(visited, neighbor, target) if self.has_path: # Early exit if path is found return def is_reachable(self, source, target): Determines if there is a path from source to target. :param source: The starting vertex. :param target: The target vertex to reach. :return: True if there is a path, False otherwise. self.has_path = False self.dfs(source, target) return self.has_path"},{"question":"Given a singly linked list, implement a function `kth_to_last_safe(head, k)` that returns the k-th to last element in the list in an optimal and secure manner. Your function should handle edge cases and constraints efficiently. # Input - `head`: The head node of the linked list (an instance of `Node`). - `k`: An integer representing the k-th to last position. # Output - Return the value of the k-th to last node. If `k` is invalid or beyond the list range, return `None`. ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last_safe(head, k): # Your implementation here pass ``` # Constraints - Do not use unsafe libraries or evaluation methods such as `eval`. - Consider the edge cases: - Empty linked list. - `k` larger than the length of the list. - Negative or zero value of `k`. # Example ```python # Helper function to create linked list from list of values def create_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head # Example values = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] head = create_linked_list(values) k = 2 result = kth_to_last_safe(head, k) # Should return \\"D\\" print(result) # Output: \\"D\\" ``` # Performance Requirements - Your solution should be optimized for both time and space complexities. - Function should operate within O(n) time and O(1) space complexities. # Notes - Use the `Node` class as defined. - Ensure your implementation is robust and can handle various edge cases as described.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last_safe(head, k): if head is None or k <= 0: return None p1 = head p2 = head for i in range(k): if p2 is None: # If k is larger than the length of the list return None p2 = p2.next while p2 is not None: p1 = p1.next p2 = p2.next return p1.val"},{"question":"Context Comb Sort is a comparison-based sorting algorithm that improves on the bubble sort. It uses a gap sequence to compare elements that are far apart to eliminate the turtles (small elements at the beginning). This makes it more efficient on average than bubble sort due to fewer swaps required for widely spaced elements. Task Implement the comb sort algorithm for sorting a list of integers provided as input. Ensure your implementation handles potential edge cases effectively and performs efficiently for moderate-sized lists. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: # your implementation here ``` Input * A list of integers `arr` where (1 leq text{len(arr)} leq 10^5) * The integers in the list may range from (-10^6) to (10^6). Output * A list of integers sorted in non-decreasing order. Constraints * The algorithm must be implemented as prescribed with a gap reduction factor. Example Input: ```python arr = [33, 10, -5, 3, 7] ``` Output: ```python [-5, 3, 7, 10, 33] ``` Notes 1. Ensure to handle the edge case where the list might be already sorted or contains only one element. 2. Aim to provide an efficient solution that performs well on average for larger input sizes within given constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Perform comb sort on the input list arr. Returns the sorted list in non-decreasing order. def get_next_gap(gap): # Shrink gap by shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Context You work for a software company that requires calculating various combinatorial values to analyze data sets efficiently. Your task is to implement a function that leverages the concept of dynamic programming to compute the combinations in an optimized manner. Problem Statement Implement a function `optimized_combination(n, r)` that calculates the number of ways to choose r items from n items (nCr) in an optimized manner using dynamic programming. Ensure that your implementation is efficient both in terms of time and space complexity. Requirements - **Function Signature**: `def optimized_combination(n: int, r: int) -> int:` - **Input**: - `n` (integer): The total number of items. - `r` (integer): The number of items to choose. - **Output**: - Return an integer representing the number of ways to choose r items from n items. Constraints - (0 leq r leq n leq 1000) Performance Requirements - Your solution should have a time complexity of (O(n*r)). - Your solution should have a space complexity of (O(r)). Example ```python assert optimized_combination(5, 2) == 10 assert optimized_combination(6, 3) == 20 assert optimized_combination(0, 0) == 1 assert optimized_combination(10, 0) == 1 assert optimized_combination(10, 10) == 1 assert optimized_combination(10, 5) == 252 ``` Notes - Ensure that your function handles edge cases, such as when (r = 0) or (r = n), correctly. - Aim for a solution that avoids deep recursion to prevent stack overflow issues.","solution":"def optimized_combination(n: int, r: int) -> int: Computes the number of ways to choose r items from n items (nCr) using dynamic programming. # Base cases if r > n: return 0 if r == 0 or r == n: return 1 # Optimization: C(n, r) == C(n, n-r) if r > n - r: r = n - r # Initialize the dp array with 0s dp = [0] * (r + 1) dp[0] = 1 # C(n, 0) is always 1 # Fill the dp array for i in range(1, n + 1): for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"You are working on a system that requires frequent rotations of arrays and you need to implement an efficient solution for this task. Problem Statement: Write a function called `rotate_array` that efficiently rotates an array of `n` elements to the right by `k` steps. The function should modify the array in-place and handle various constraints properly. Function Signature: ```python def rotate_array(array: List[int], k: int) -> None: pass ``` Input: - `array` - A list of integers containing `n` elements. - `k` - An integer specifying the number of steps to rotate to the right. Output: The function should return `None` but modify the `array` in place to achieve the rotation. Constraints: - `1 <= n <= 10^5` - `0 <= k <= 10^5` - Elements in the array will be integers. Examples: 1. `rotate_array([1, 2, 3, 4, 5, 6, 7], 3)` would modify the array to `[5, 6, 7, 1, 2, 3, 4]`. 2. `rotate_array([1, 2, 3, 4], 1)` would modify the array to `[4, 1, 2, 3]`. 3. `rotate_array([1, 2, 3, 4], 4)` would modify the array to `[1, 2, 3, 4]` (since rotating the array length times results in the same array). Special Considerations: - Handle edge cases where `k` is greater than the length of `array`. - Optimize for both time and space complexity to handle large arrays efficiently. - Do not return any value; ensure the array is modified in place. Hints: 1. Consider the most efficient way to achieve the rotation without using extra space significantly. 2. Use helper functions if necessary for operations like reversing parts of the array.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps in place. n = len(array) k = k % n # Handle cases where k > n # Helper function to reverse elements in the array from start to end index. def reverse(arr: List[int], start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(array, 0, n-1) # Step 2: Reverse the first k elements reverse(array, 0, k-1) # Step 3: Reverse the remaining n-k elements reverse(array, k, n-1)"},{"question":"# Text Justification Coding Task Context You are developing a text editing tool that formats given text into lines of a specified width. Your tool needs to ensure that each line is fully justified, meaning the text aligns on both the left and right sides, by appropriately distributing spaces between words. For the last line, however, it should be left-justified without inserting extra spaces between words. Task Implement the function `text_justification(words, max_width)` to justify the given list of words into lines of `max_width` length. Input - `words`: A list of strings where each string is a word (length of each word is guaranteed to be greater than 0 and not exceed `max_width`). - `max_width`: An integer representing the maximum width of each line. Output - A list of strings where each string is a line of justified text. Constraints - Each word\'s length is guaranteed to be greater than 0 and not exceed `max_width`. - The input array `words` contains at least one word. Performance Requirements - The solution must process the input list in a time-efficient manner, emphasizing a linear time complexity O(n). Example Input: ```python words = [\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"] max_width = 16 ``` Output: ```python [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] ``` You must implement the following function: ```python def text_justification(words, max_width): \'\'\' :type words: list :type max_width: int :rtype: list \'\'\' pass ```","solution":"def text_justification(words, max_width): def justify_line(line, max_width, is_last_line): if is_last_line or len(line) == 1: return \\" \\".join(line).ljust(max_width) total_spaces = max_width - sum(len(word) for word in line) gaps = len(line) - 1 equal_space, extra_space = divmod(total_spaces, gaps) for i in range(extra_space): line[i] += \\" \\" return (\\" \\" * equal_space).join(line) result = [] current_line = [] current_line_length = 0 for word in words: if current_line_length + len(current_line) + len(word) > max_width: result.append(justify_line(current_line, max_width, False)) current_line = [] current_line_length = 0 current_line.append(word) current_line_length += len(word) result.append(justify_line(current_line, max_width, True)) return result"},{"question":"# Question: Given two sparse matrices ( A ) and ( B ), implement a function `multiply(A, B)` that returns the result of ( AB ). You can assume that ( A )\'s column number is equal to ( B )\'s row number. **Function Signature**: ```python def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: ``` # Input: - ( A ): A list of lists of integers where each inner list represents a row in the matrix ( A ). - ( B ): A list of lists of integers where each inner list represents a row in the matrix ( B ). # Output: - Return the resultant matrix ( AB ), which is also a list of lists of integers. # Constraints: - The number of columns in ( A ) equals the number of rows in ( B ). - All elements in matrices ( A ) and ( B ) are 32-bit integers. # Example: ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] # Expected Output # [ # [7, 0, 0], # [-7, 0, 3] # ] print(multiply(A, B)) # Output: [[7, 0, 0], [-7, 0, 3]] ``` # Additional Information: - Consider only non-zero elements in the matrices to optimize multiplication. - Handle edge cases including, but not limited to, completely empty matrices and unmatched dimensions (throw an appropriate exception).","solution":"from typing import List def multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or len(A[0]) != len(B): raise ValueError(\\"Invalid input matrices dimensions\\") m, n, p = len(A), len(A[0]), len(B[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] for i in range(m): for k in range(n): if A[i][k] != 0: for j in range(p): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Polynomial Arithmetic System You are tasked with developing a component of a symbolic mathematics system that handles polynomial arithmetic. The system will provide operations for polynomial addition, subtraction, multiplication, and evaluation of polynomial expressions. Problem Statement Using the class `Polynomial`, implement the following functionalities: 1. **Addition**: Implement an efficient method to add two polynomials. 2. **Subtraction**: Implement an efficient method to subtract one polynomial from another. 3. **Multiplication**: Implement an efficient method to multiply two polynomials. 4. **Evaluation**: Implement a method that substitutes values for the variables in a polynomial and calculates the resulting value. Requirements - **Functionality 1** (`add_polynomials`): - **Input**: Two polynomials represented as instances of the `Polynomial` class. - **Output**: A new instance of the `Polynomial` class representing the sum. - **Functionality 2** (`subtract_polynomials`): - **Input**: Two polynomials represented as instances of the `Polynomial` class. - **Output**: A new instance of the `Polynomial` class representing the difference. - **Functionality 3** (`multiply_polynomials`): - **Input**: Two polynomials represented as instances of the `Polynomial` class. - **Output**: A new instance of the `Polynomial` class representing the product. - **Functionality 4** (`evaluate_polynomial`): - **Input**: - A polynomial represented as an instance of the `Polynomial` class. - A dictionary assigning values to the variables of the polynomial. - **Output**: The evaluated result (integer, float, or Fraction). Constraints - Implement each function efficiently considering the potential size of polynomials. - Assume that variable indices are positive integers and non-negative exponents. Example ```python # Define Monomial and Polynomial monomial1 = Monomial({1: 2}, 3) # Represents 3*a_1^2 monomial2 = Monomial({2: 1}, 4) # Represents 4*a_2 monomial3 = Monomial({1: 1}, 5) # Represents 5*a_1 monomial4 = Monomial({2: 0}, 2) # Represents 2 # Create Polynomials polynomial1 = Polynomial([monomial1, monomial2]) # Represents 3*a_1^2 + 4*a_2 polynomial2 = Polynomial([monomial3, monomial4]) # Represents 5*a_1 + 2 # Define the required functions def add_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: # Implement addition of two polynomials return poly1 + poly2 def subtract_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: # Implement subtraction of two polynomials return poly1 - poly2 def multiply_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: # Implement multiplication of two polynomials return poly1 * poly2 def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: # Implement evaluation of a polynomial given variable assignments return poly.subs(values) # Usage result_add = add_polynomials(polynomial1, polynomial2) # Expected: 3*a_1^2 + 4*a_2 + 5*a_1 + 2 result_sub = subtract_polynomials(polynomial1, polynomial2) # Expected: 3*a_1^2 + 4*a_2 - 5*a_1 - 2 result_mul = multiply_polynomials(polynomial1, polynomial2) # Expected: 15*a_1^3 + 6*a_1^2 + 20*a_1*a_2 + 8*a_2 result_eval = evaluate_polynomial(result_add, {1: 1, 2: 1}) # Substitute a_1 and a_2 with 1, Expected: 3 + 4 + 5 + 2 = 14 ``` Implement the above functionalities in the respective functions.","solution":"from typing import List, Dict, Union from fractions import Fraction class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Union[int, float, Fraction]): self.variables = variables # {variable_index: exponent} self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): # Hash for using Monomials in a dictionary return hash((frozenset(self.variables.items()), self.coefficient)) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def __add__(self, other): result_monomials = list(self.monomials) for monomial in other.monomials: found = False for res_monomial in result_monomials: if res_monomial.variables == monomial.variables: res_monomial.coefficient += monomial.coefficient found = True break if not found: result_monomials.append(monomial) return Polynomial(result_monomials) def __sub__(self, other): negative_monomials = [Monomial(monomial.variables, -monomial.coefficient) for monomial in other.monomials] return self.__add__(Polynomial(negative_monomials)) def __mul__(self, other): result_monomials_dict = {} for monomial1 in self.monomials: for monomial2 in other.monomials: new_vars = monomial1.variables.copy() for var, exp in monomial2.variables.items(): if var in new_vars: new_vars[var] += exp else: new_vars[var] = exp new_monomial = Monomial(new_vars, monomial1.coefficient * monomial2.coefficient) if new_monomial in result_monomials_dict: result_monomials_dict[new_monomial] += new_monomial.coefficient else: result_monomials_dict[new_monomial] = new_monomial.coefficient result_monomials = [Monomial(monomial.variables, coefficient) for monomial, coefficient in result_monomials_dict.items()] return Polynomial(result_monomials) def subs(self, values: Dict[int, Union[int, float, Fraction]]): total = 0 for monomial in self.monomials: product = monomial.coefficient for var, exp in monomial.variables.items(): product *= values.get(var, 0) ** exp total += product return total def add_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: return poly1 + poly2 def subtract_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: return poly1 - poly2 def multiply_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: return poly1 * poly2 def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: return poly.subs(values)"},{"question":"# Sorting Assessment Question **Context**: In this problem, you have to sort a list of integers using the Gnome Sort algorithm. The Gnome Sort algorithm is a comparison-based sorting algorithm, much like the insertion sort, but with a slight variation in the way the elements are moved around to get sorted. **Task**: Implement the `gnome_sort` function that sorts a list of integers in non-decreasing order. Your function should follow the gnome sort principles accurately. **Function Signature**: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr` (List[int]): a list of integers to be sorted. **Output**: - `List[int]`: a new list containing the sorted integers in non-decreasing order. **Constraints**: - The length of the list `arr` will not exceed 10^4. - The integer elements of `arr` will be between -10^9 and 10^9 inclusive. **Requirements**: - Your function should have a time complexity of O(n^2) in the worst case. - Do not use Python’s built-in sort functions (`sort()` or `sorted()`). **Examples**: Example 1: ```python input: [34, 2, 10, -9] output: [-9, 2, 10, 34] ``` Example 2: ```python input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ``` **Notes**: - Consider edge cases such as already sorted arrays, arrays with duplicate values, and arrays with negative values. - Think about potential performance improvements or additional optimizations.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts the array using the Gnome Sort algorithm. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Generate All Possible Abbreviations for a Word Background You are developing a text-processing tool that generates abbreviations for words. Each abbreviation can replace any set of consecutive characters with their count. The provided backtracking algorithm generates all such possible abbreviations of a word. Task Your task is to implement a function `generate_abbreviations(word)` that takes a string `word` and returns a list of all possible abbreviations of the word. Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` Input * `word`: A string consisting of lowercase alphabetic characters, with a maximum length of 20. Output * A list of strings representing all possible abbreviations. Example 1. Input: `word = \'word\'` Output: `[\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\']` 2. Input: `word = \'a\'` Output: `[\'a\', \'1\']` 3. Input: `word = \'\'` Output: `[\'\']` Constraints * The length of the word will not exceed 20 characters. Performance Requirements * Your solution should have a time complexity of (O(2^n)) where (n) is the length of the word. Implementation Details * Use the backtracking algorithm to explore all possible abbreviations. * Ensure to handle edge cases such as an empty string. * Collect all possible abbreviations in a list and return it.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == n: res.append(cur + str(count) if count > 0 else cur) return # Skip this character and increase the count backtrack(pos + 1, cur, count + 1) # Include this character in the abbreviation backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) n = len(word) res = [] backtrack(0, \'\', 0) return res"},{"question":"You are given a class `Interval` with methods to manage intervals of real numbers. The class can determine if a number is included within an interval, merge overlapping intervals, and more. Your task is to enhance this class to include additional functionalities that handle more sophisticated interval operations. # Requirements: 1. **Functionality** * Implement a method `fuse_intervals` that takes a list of `Interval` objects and returns a new list where overlapping intervals are merged. * Implement a method `find_gaps` that finds the gaps between given intervals and returns a list representing the intervals of those gaps. 2. **Input/Output Formats** - Input: A list of `Interval` objects to the `fuse_intervals` method. - Output: A list of merged `Interval` objects. - Input: A list of `Interval` objects to the `find_gaps` method. - Output: A list of `Interval` objects representing the gaps between given intervals. 3. **Constraints** - Intervals can be defined with `start` and `end` being any integer. - Intervals may overlap or be disjoint. - Consider negative ranges as well (`start` can be less than zero). 4. **Edge Cases** - Handling an empty list of intervals. - Handling intervals that just touch each other without overlapping. # Example: ```python intervals = [Interval(1, 5), Interval(10, 14), Interval(2, 6), Interval(8, 12)] # Expected output for fuse_intervals # [Interval(1, 6), Interval(8, 14)] # Expected output for find_gaps # [Interval(6, 8)] ``` # Additional Information - Implementation must be efficient with minimum time complexity. - Assume valid input intervals are passed (i.e., `start` <= `end`). - Utilize the provided `Interval` class structure and methods for defining and managing intervals. ```python def fuse_intervals(intervals): # Your code here pass def find_gaps(intervals): # Your code here pass ```","solution":"class Interval: def __init__(self, start, end): self.start = start self.end = end def __repr__(self): return f\\"Interval({self.start}, {self.end})\\" def __eq__(self, other): return self.start == other.start and self.end == other.end def fuse_intervals(intervals): if not intervals: return [] intervals.sort(key=lambda x: x.start) merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current.start <= last.end: # Overlapping intervals last.end = max(last.end, current.end) else: merged_intervals.append(current) return merged_intervals def find_gaps(intervals): if not intervals: return [] intervals = fuse_intervals(intervals) gaps = [] for i in range(len(intervals) - 1): if intervals[i].end < intervals[i + 1].start: gaps.append(Interval(intervals[i].end, intervals[i + 1].start)) return gaps"},{"question":"# Matrix Transformation Funhouse You are given a square matrix and need to perform various transformations on it. Implement the following functions to manipulate the matrix: 1. **rotate_clockwise(matrix)**: Rotates the input square matrix by 90 degrees in the clockwise direction. 2. **rotate_counterclockwise(matrix)**: Rotates the input square matrix by 90 degrees in the counterclockwise direction. 3. **top_left_invert(matrix)**: Performs a top-left to bottom-right inversion on the matrix. 4. **bottom_left_invert(matrix)**: Performs a bottom-left to top-right inversion on the matrix. Input - `matrix` (List[List[int]]): A 2D list representing the square matrix. The matrix will always be non-empty. Output - The output of each function should be a new 2D list representing the transformed matrix. Constraints - The matrix contains integers from -1000 to 1000. - The dimensions of the matrix are limited to 1 ≤ n ≤ 1000. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print_matrix(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print_matrix(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print_matrix(top_left_invert(matrix)) # Output: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] print_matrix(bottom_left_invert(matrix)) # Output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` Notes 1. Pay special attention to the handling of matrix boundaries and ensure not to exceed them. 2. Consider and handle edge cases, such as matrices with single elements, appropriately.","solution":"def rotate_clockwise(matrix): Rotates the input square matrix by 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Rotates the input square matrix by 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): Performs a top-left to bottom-right inversion on the matrix. return [row[:] for row in matrix] def bottom_left_invert(matrix): Performs a bottom-left to top-right inversion on the matrix. return [row[::-1] for row in matrix[::-1]]"},{"question":"# Question Implement a `Red-Black Tree` with additional functionality for finding the kth smallest element. The tree should support insertions and deletions while maintaining its balance according to Red-Black tree properties. **Function Signature**: ```python def kth_smallest(tree: RBTree, k: int) -> int: pass ``` # Input * `tree` (RBTree): An instance of RBTree which has been populated with several integers. * `k` (int): An integer representing the k-th smallest element to be retrieved. Assume 1 ≤ k ≤ number of nodes in the tree. # Output * Returns the value of the k-th smallest element in the given Red-Black Tree. # Constraints * The tree should be balanced after each insertion and deletion. * `k` is always valid (1 ≤ k ≤ number of nodes in the tree). # Example ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) assert kth_smallest(rb, 1) == 1 assert kth_smallest(rb, 5) == 7 ``` Write code to implement the function `kth_smallest` that utilizes the properties of a Red-Black Tree to efficiently find the k-th smallest element. Your implementation should be optimal and align with the principles of Red-Black Trees.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color self.left = left self.right = right self.parent = parent self.size = 1 # Additional field to keep track of the size of the subtree class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.TNULL.size = 0 self.root = self.TNULL def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y y.size = x.size x.size = x.left.size + x.right.size + 1 def right_rotate(self, y): x = y.left y.left = x.right if x.right != self.TNULL: x.right.parent = y x.parent = y.parent if y.parent is None: self.root = x elif y == y.parent.right: y.parent.right = x else: y.parent.left = x x.right = y y.parent = x x.size = y.size y.size = y.left.size + y.right.size + 1 def insert(self, key): node = RBNode(key, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None y = None x = self.root while x != self.TNULL: y = x x.size += 1 # Increment size for every node in the path if node.key < x.key: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.key < y.key: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self._fix_insert(node) def _fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def get_kth_smallest(self, node, k): if node == self.TNULL: return None left_size = node.left.size if node.left != self.TNULL else 0 if k == left_size + 1: return node.key elif k <= left_size: return self.get_kth_smallest(node.left, k) else: return self.get_kth_smallest(node.right, k - left_size - 1) def kth_smallest(tree: RBTree, k: int) -> int: return tree.get_kth_smallest(tree.root, k)"},{"question":"# FizzBuzz Duplicate Detection **Context**: You have been assigned the task of enhancing the basic FizzBuzz function by detecting duplicate outputs in the list. The FizzBuzz output should remain the same, but you will additionally create a dictionary to count occurrences of each unique output. **Objective**: Write a function named `enhanced_fizzbuzz` that returns a tuple containing: 1. The FizzBuzz list from 1 to N. 2. A dictionary that maps each unique output to the number of times it appears in the list. **Function Signature**: ```python def enhanced_fizzbuzz(n: int) -> tuple: :param n: int - The upper limit of the sequence. :return: tuple - A tuple containing the FizzBuzz list and a dictionary of occurrences. ``` **Input**: - An integer N (N ≥ 1). **Output**: - A tuple with: 1. A list of integers and strings according to the FizzBuzz rules. 2. A dictionary with each unique output as a key and its occurrence count as the value. **Performance Requirements**: - Time Complexity: O(n) - Space Complexity: O(n) **Example**: ```python enhanced_fizzbuzz(5) # Output: ([1, 2, \'Fizz\', 4, \'Buzz\'], {1: 1, 2: 1, \'Fizz\': 1, 4: 1, \'Buzz\': 1}) enhanced_fizzbuzz(15) # Output: ([1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'], # {1: 1, 2: 1, \'Fizz\': 4, 4: 1, \'Buzz\': 2, 7: 1, 8: 1, 11: 1, 13: 1, 14: 1, \'FizzBuzz\': 1}) ``` **Constraints**: - The function should handle large values of N efficiently. - Ensure that the input N is always a positive integer. **Implementation Guidelines**: 1. Validate the input to ensure N is a positive integer. 2. Generate the FizzBuzz list as specified. 3. Create a dictionary to count occurrences of each unique output. 4. Return the FizzBuzz list along with the dictionary of counts as a tuple.","solution":"def enhanced_fizzbuzz(n: int) -> tuple: Generate a FizzBuzz sequence from 1 to N and count the occurrences of each unique output. :param n: int - The upper limit of the sequence. :return: tuple - A tuple containing the FizzBuzz list and a dictionary of occurrences. fizzbuzz_list = [] counts = {} for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: value = \\"FizzBuzz\\" elif i % 3 == 0: value = \\"Fizz\\" elif i % 5 == 0: value = \\"Buzz\\" else: value = i fizzbuzz_list.append(value) if value in counts: counts[value] += 1 else: counts[value] = 1 return (fizzbuzz_list, counts)"},{"question":"# ZigZag Iterator Modification Scenario You are given two lists of integers. Your task is to write a function that initializes a ZigZag Iterator for these two lists and iterates over them in alternating (zigzag) order, but with a twist: instead of two lists, you need to support k (k ≥ 2) lists. Problem Statement: Design and implement a class `KZigZagIterator` that takes k lists of integers and enables zigzag iteration over all k lists. Write methods to initialize the data structure, retrieve the next element, and check if there are remaining elements. Function Signatures: ```python class KZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize your data structure here. :type vecs: List[List[int]] def next(self) -> int: :rtype: int def has_next(self) -> bool: :rtype: bool ``` Input - An initialization function that takes a list of `k` lists (where `k ≥ 2`) of integers. - Lists can be of differing lengths and may be empty. Output - The `next` function returns the next integer in the zigzag sequence. - The `has_next` function returns a boolean value indicating if there are remaining elements. Constraints - You should minimize additional space usage. - Aim to maintain O(1) operations for `next` and `has_next`. Example Usage: ```python l1 = [1, 2, 3] l2 = [4, 5] l3 = [6, 7, 8, 9] it = KZigZagIterator([l1, l2, l3]) result = [] while it.has_next(): result.append(it.next()) # expected result = [1, 4, 6, 2, 5, 7, 3, 8, 9] ```","solution":"from typing import List from collections import deque class KZigZagIterator: def __init__(self, vecs: List[List[int]]): Initialize your data structure here. :type vecs: List[List[int]] self.queue = deque((i, 0) for i in range(len(vecs)) if vecs[i]) self.vecs = vecs def next(self) -> int: :rtype: int if self.has_next(): i, j = self.queue.popleft() result = self.vecs[i][j] if j + 1 < len(self.vecs[i]): self.queue.append((i, j + 1)) return result raise Exception(\\"No more elements\\") def has_next(self) -> bool: :rtype: bool return bool(self.queue)"},{"question":"Problem Statement You have been tasked with implementing an enhanced version of the Cocktail Shaker Sort algorithm. This variation should track the last position where a swap occurred during the forward and backward pass to minimize the range of subsequent passes. Additionally, ensure the function handles various edge cases effectively. Function Signature ```python def enhanced_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers that need to be sorted. The list can be empty or contain up to `10^5` elements. Output - Returns a sorted list of integers in non-decreasing order. Constraints - The elements in `arr` can range from `-10^6` to `10^6`. - Your implementation should aim to improve performance by minimizing unnecessary comparisons. Example ```python assert enhanced_cocktail_shaker_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert enhanced_cocktail_shaker_sort([]) == [] assert enhanced_cocktail_shaker_sort([3]) == [3] assert enhanced_cocktail_shaker_sort([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10] assert enhanced_cocktail_shaker_sort([-1, -50, 0, 50, 2]) == [-50, -1, 0, 2, 50] ``` # Additional Notes - Implement the function `enhanced_cocktail_shaker_sort` without using any external sorting library functions. - Focus on reducing the range of comparisons based on the last swapped index during both passes. - Consider various edge cases like empty lists, sorted lists, and lists with repetitive elements.","solution":"from typing import List def enhanced_cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the enhanced cocktail shaker sort algorithm. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 sorted = False while not sorted: sorted = True new_end = 0 # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] sorted = False new_end = i if sorted: break end = new_end sorted = True new_start = n # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] sorted = False new_start = i if sorted: break start = new_start return arr"},{"question":"# Instructions: You are provided with an array of words and an array of symbols. Your task is to implement a function that returns a list of words where each word has any matching symbols replaced by the symbol enclosed in square brackets. If a word matches more than one symbol, the function should replace the part of the word that matches the longest symbol. # Input: * `words`: A list of strings representing words (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ 100, words only contain lowercase or uppercase English letters). * `symbols`: A list of strings representing the symbols (1 ≤ len(symbols) ≤ 100, 1 ≤ len(symbol) ≤ 100, symbols only contain lowercase or uppercase English letters). # Output: * The function should return a list of strings where each word with matched symbol is modified as per the constraints. # Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Function Signature: ```python def match_word_with_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Constraints: * The solution should be performant with time complexity in the order of O(w * n) where `w` is the number of words and `n` is the average length of the words. * Handle edge cases like no matches, multiple matches (choosing the longest), and overlapping symbols efficiently. * Clearly comment and document your code for readability.","solution":"from typing import List def match_word_with_symbols(words: List[str], symbols: List[str]) -> List[str]: This function replaces parts of each word in the list \'words\' with any matching symbols from the list \'symbols\'. The matched symbol in the word is replaced by the symbol enclosed in square brackets. If a word matches more than one symbol, the function replaces the part of the word that matches the longest symbol. :param words: List of words to be processed. :param symbols: List of symbols to match and replace in the words. :return: List of words with symbols replaced by the longest match found. def find_longest_symbol_match(word: str) -> str: Finds and returns the longest matching symbol in a word. :param word: The word in which to find the longest matching symbol. :return: The longest matching symbol or an empty string if no match is found. longest_match = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_match): longest_match = symbol return longest_match result = [] for word in words: longest_match = find_longest_symbol_match(word) if longest_match: word = word.replace(longest_match, f\\"[{longest_match}]\\") result.append(word) return result"},{"question":"# AVL Tree Implementation and Analysis You are required to implement an AVL Tree to understand how self-balancing binary search trees work. Your task involves: 1. Completing the AVL Tree implementation by adding the `delete` method, which removes a node while maintaining the tree\'s balance. 2. Writing test cases to ensure the AVL Tree operations( `insert`, `delete`, `in_order_traverse`) work correctly. Task **Function:** ```python class AvlTree(object): def delete(self, key: int): # Your Code Here pass # Rest of the class implementation as provided above ``` **Input:** - An integer `key` to be deleted from the AVL Tree. **Output:** - The AVL Tree should no longer contain the specified key. Perform any necessary rotations to maintain balance. **Constraints:** - `key` is an integer and will be within the range [-10^6, 10^6]. - Duplicate inserts will not be performed; every key is unique. - The initial tree can be assumed non-empty for delete operations. **Performance Requirements:** - Ensure the delete operation completes in O(log n) time complexity. Example Scenario Given a sequence of operations: 1. Insert: 10, 20, 30, 40, 50, 25 2. Delete: 50, 25 **Expected Result:** - After the inserts, the AVL Tree should balance to maintain the height difference property. - After deleting 50 and 25, the tree should re-balance. **Functionality Validation:** * Implement suitable test cases that can test the `delete` operation accurately. * Validate that all AVL Tree properties are maintained through the operations. Edge Cases to Consider: * Deleting a node with two children - ensure the in-order predecessor or successor is correctly placed and the tree is rebalanced. * Deleting a node from the tree that results in an imbalance that requires double rotation. * Deleting the root node.","solution":"class Node: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree(object): def get_height(self, root): return root.height if root else 0 def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, root, key): if not root: return Node(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.rotate_right(root) # Right Right Case if balance < -1 and key > root.right.key: return self.rotate_left(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.rotate_left(root.left) return self.rotate_right(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def min_value_node(self, node): current = node while current.left: current = current.left return current def delete(self, root, key): if not root: return root elif key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Balance the tree # Left Left Case if balance > 1 and self.get_balance(root.left) >= 0: return self.rotate_right(root) # Left Right Case if balance > 1 and self.get_balance(root.left) < 0: root.left = self.rotate_left(root.left) return self.rotate_right(root) # Right Right Case if balance < -1 and self.get_balance(root.right) <= 0: return self.rotate_left(root) # Right Left Case if balance < -1 and self.get_balance(root.right) > 0: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def in_order_traverse(self, root, result=None): if result is None: result = [] if root: self.in_order_traverse(root.left, result) result.append(root.key) self.in_order_traverse(root.right, result) return result"},{"question":"Optimized Combination Calculation Scenario You\'re a software developer working on a program that involves combinatorial mathematics. You need to efficiently calculate the number of ways to choose `r` items from `n` items (nCr). Given the potentially large values of `n` and `r`, implementing a computationally efficient solution is crucial. Task Write a function `combination_iterative(n, r)` that calculates nCr using an iterative dynamic programming approach. Requirements * **Function Name**: `combination_iterative` * **Input**: Two integers `n` and `r` (`0 <= r <= n`) * **Output**: The value of `nCr` (an integer) * **Constraints**: The function should handle large values up to n, r ≤ 1000 efficiently, avoiding excessive recursion and unnecessary calculations. Performance Expectations * Time Complexity should be O(n*r). * Space Complexity should be O(r). Example ```python def combination_iterative(n, r): # Your implementation here # Provided Examples print(combination_iterative(5, 2)) # Output: 10 print(combination_iterative(6, 3)) # Output: 20 print(combination_iterative(10, 5)) # Output: 252 ``` Considerations * Make sure to handle edge cases such as `n = r` and `r = 0`. * Avoid recursive solutions to prevent stack overflow. * Optimize for both time and space efficiency. Good luck, and happy coding!","solution":"def combination_iterative(n, r): Calculate nCr using an iterative dynamic programming approach. :param n: Total number of items :param r: Number of items to choose :return: The number of combinations (nCr) if r > n: return 0 if r == 0 or r == n: return 1 if r > n - r: r = n - r dp = [0] * (r + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(r, i), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"**Scenario**: Imagine you\'re a software engineer who is optimizing the search feature in a list of customer orders. Each order is represented by a unique order ID. Your task is to enhance the functionality by finding not just the first occurrence index of the order ID, but also ensuring that the array is validated against certain conditions to avoid common mistakes. **Problem Statement**: Write a function `enhanced_linear_search` that accepts two parameters: an array of integers (`orders`) representing order IDs and an integer (`order_id`) representing the target order ID to search for. Perform the following tasks: 1. Validate that `orders` is a non-empty list of integers. If the list is empty or contains non-integer values, return `\'Error: Invalid input\'`. 2. Perform a linear search to find the index of the first occurrence of `order_id` in `orders`. 3. If `order_id` is found, return the index. 4. If `order_id` is not found, return -1. **Input Format**: - `orders`: A list of integers representing order IDs. (1 ≤ len(orders) ≤ 10^5) - `order_id`: An integer representing the order ID to search for. **Output Format**: - An integer representing the index of the first occurrence of `order_id` in the list, or -1 if it is not found. Alternatively, a string `\'Error: Invalid input\'` if the input list is empty or contains non-integer values. **Constraints**: - Your solution should handle up to 100,000 elements efficiently. - The `orders` array can be very large, so the solution should be optimized for performance. **Function Signature**: ```python def enhanced_linear_search(orders: list, order_id: int) -> int: pass ``` **Example**: ```python # Example 1: orders = [102, 205, 312, 102, 456] order_id = 102 # Expected Output: 0 # Example 2: orders = [101, 203, 305, 150] order_id = 500 # Expected Output: -1 # Example 3: orders = [] order_id = 123 # Expected Output: \'Error: Invalid input\' # Example 4: orders = [101, \'203\', 305, 150] order_id = 305 # Expected Output: \'Error: Invalid input\' # Example Call: print(enhanced_linear_search([102, 205, 312, 102, 456], 102)) # Output: 0 print(enhanced_linear_search([101, 203, 305, 150], 500)) # Output: -1 print(enhanced_linear_search([], 123)) # Output: \'Error: Invalid input\' print(enhanced_linear_search([101, \'203\', 305, 150], 305)) # Output: \'Error: Invalid input\' ```","solution":"def enhanced_linear_search(orders: list, order_id: int) -> int: Performs a linear search to find the index of the first occurrence of order_id in orders list. Validates that orders is a non-empty list of integers. if not orders or not all(isinstance(item, int) for item in orders): return \'Error: Invalid input\' for index, current_id in enumerate(orders): if current_id == order_id: return index return -1"},{"question":"# Euler\'s Totient Function and GCD Sum Calculation Problem Statement Euler\'s Totient function, denoted as ϕ(n), counts the number of positive integers up to `n` that are coprime with `n`. Implement the function `euler_totient()` that calculates ϕ(n) as follows: ```python def euler_totient(n: int) -> int: Args: n (int): A positive integer. Returns: int: The count of integers between 1 and n inclusive that are coprime to n. ``` Using this function, you will then compute the sum of ϕ(i) for all integers from 1 to a given `N` (inclusive). Implement the `gcd_sum()` function which uses `euler_totient(n)` to calculate this sum: ```python def gcd_sum(N: int) -> int: Args: N (int): A positive integer. Returns: int: The sum of ϕ(i) for all integers from 1 to N inclusive. ``` # Input and Output * The expected input is a single integer `N` (1 ≤ N ≤ 10^6). * The output should be a single integer representing the sum of the Euler\'s Totient function values from 1 to `N`. # Constraints * You must ensure your function runs efficiently for larger values of `N` within given constraints. # Example ```python # Example: print(gcd_sum(5)) # Output: 9 # Explanation: ϕ(1) = 1, ϕ(2) = 1, ϕ(3) = 2, ϕ(4) = 2, ϕ(5) = 4 # Sum = 1 + 1 + 2 + 2 + 4 = 10 ``` # Notes Make sure your solution handles edge cases, such as: * Lower-bound cases where `N = 1`. * Performance on upper-bound cases where `N` approaches 10^6. * Correctness on prime and composite numbers.","solution":"def gcd(a, b): while b: a, b = b, a % b return a def euler_totient(n: int) -> int: count = 0 for i in range(1, n + 1): if gcd(n, i) == 1: count += 1 return count def gcd_sum(N: int) -> int: total = 0 for i in range(1, N + 1): total += euler_totient(i) return total"},{"question":"**Context**: An organization needs to format device identifiers according to a new standard in which the characters must be grouped in a specific manner. They need your help to write a function to reformat the device keys accordingly. **Task**: Write a function `reformat_license_key(key: str, k: int) -> str` that takes a license key string `key`, consisting of alphanumeric characters and hyphens, and an integer `k`. The function outputs a string formatted so that: * All alphanumeric characters are grouped into groups of size `k`. * Groups are separated by single hyphens (`-`). * The first group could be shorter than `k`. * All lowercase letters in the output should be converted to uppercase. **Input**: - `key` (string): A string of length `1 <= len(key) <= 10^4` containing alphanumeric characters and hyphens. - `k` (integer): An integer size for grouping the characters where `1 <= k <= len(key)`. **Output**: - A string formatted according to the described rules. **Example**: ```python assert reformat_license_key(\\"2-4A0r7-4k\\", 4) == \\"24A0-R74K\\" assert reformat_license_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" ```","solution":"def reformat_license_key(key: str, k: int) -> str: Reformats the given license key into groups of size k, separated by hyphens, with all letters in uppercase. # Remove hyphens and convert to uppercase cleaned_key = key.replace(\\"-\\", \\"\\").upper() # Calculate the size of the first group first_group_size = len(cleaned_key) % k or k # Initialize the result with the first group result = [cleaned_key[:first_group_size]] # Process subsequent groups for i in range(first_group_size, len(cleaned_key), k): result.append(cleaned_key[i:i + k]) # Join groups with hyphens return \\"-\\".join(result)"},{"question":"# Question You have been hired by an organization to help with the analysis of relationships in organizational hierarchies. They represent their hierarchy using a binary tree, where each node represents an employee, and edges represent the reporting line between employees. One common task is to find the lowest common manager (i.e., lowest common ancestor, LCA) for two employees. For example, in the following hierarchy: _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 The lowest common manager of employees 5 and 1 is 3. Another example is the lowest common manager of employees 5 and 4 is 5 since an employee can be a manager of themselves. Task Write a function `find_lowest_common_manager(root, employee1, employee2)` that takes in the root of the binary tree representing the organizational structure and two employees, and returns their lowest common manager. Input * `root`: The root node of the binary tree (type: `TreeNode`). * `employee1`: One node in the tree (type: `TreeNode`). * `employee2`: Another node in the tree (type: `TreeNode`). Output * The lowest common manager node (type: `TreeNode`). Constraints * All employee node values are unique. * The binary tree contains at most `10^4` nodes. * Each node has at most two children. Example 1. Input: ```python # Constructing the tree root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) # Nodes employee1 = root.left # Node with value 5 employee2 = root.right # Node with value 1 # Output output = find_lowest_common_manager(root, employee1, employee2) assert output.val == 3 ``` 2. Input: ```python # Constructing the tree root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) # Nodes employee1 = root.left # Node with value 5 employee2 = root.left.right.right # Node with value 4 # Output output = find_lowest_common_manager(root, employee1, employee2) assert output.val == 5 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lowest_common_manager(root, employee1, employee2): # Base case if root is None or root == employee1 or root == employee2: return root # Recursively find LCA in the left and right subtrees left = find_lowest_common_manager(root.left, employee1, employee2) right = find_lowest_common_manager(root.right, employee1, employee2) # If both left and right are not None, root must be the LCA if left and right: return root # Otherwise, return non-null value return left if left else right"},{"question":"# Scenario You are tasked with writing an implementation of the Comb Sort algorithm for a new system that processes student scores. The performance team has highlighted that the current bubble sort implementation is too slow, especially with large data sets. Your goal is to replace this with a more efficient Comb Sort. # Problem Statement Implement a `comb_sort` function in Python that sorts a list of integers. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, where `1 <= len(arr) <= 10^5`, and `0 <= arr[i] <= 10^9` for each integer in the list. # Output * Return a list of integers sorted in ascending order. # Constraints * You should aim for better average performance than O(N^2). * The function should modify the array in place but also return it. # Example ```python assert comb_sort([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert comb_sort([]) == [] assert comb_sort([10, 3, 15, 7, 8, 23, 74, 18]) == [3, 7, 8, 10, 15, 18, 23, 74] ``` # Guidelines * Avoid using built-in sorting functions. Implement the logic yourself. * Handle edge cases such as single element array, and arrays with repeated values. * Optimize for performance and ensure proper handling of large lists within given constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) sorted = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"Advanced Word Search with Wildcards You are tasked with implementing a data structure that supports adding words and searching for exact words or patterns that may include the wildcard character `\'.\'`, which can represent any letter. Specification # Data Structure 1: Trie-Based Word Dictionary Implement a class `WordDictionary` that supports the following methods: 1. **`add_word(word: str) -> None`**: Adds a word to the dictionary. 2. **`search(word: str) -> bool`**: Returns `True` if the word is in the dictionary, potentially containing wildcard `\'.\'`. # Data Structure 2: Dictionary-Based Word Dictionary Implement a class `WordDictionary2` that supports the following methods: 1. **`add_word(word: str) -> None`**: Adds a word to the dictionary. 2. **`search(word: str) -> bool`**: Returns `True` if the word is in the dictionary, potentially containing wildcard `\'.\'`. Example ```python # Example usage of the classes wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True wd2 = WordDictionary2() wd2.add_word(\\"bad\\") wd2.add_word(\\"dad\\") wd2.add_word(\\"mad\\") print(wd2.search(\\"pad\\")) # Output: False print(wd2.search(\\"bad\\")) # Output: True print(wd2.search(\\".ad\\")) # Output: True print(wd2.search(\\"b..\\")) # Output: True ``` Constraints * All words added or searched are non-empty and consist of lowercase alphabets. * Performance will be evaluated based on both time and space efficiency. Additional Requirements * Ensure your implementations are robust against edge cases and optimized for performance. * Provide appropriate error handling and input validation where necessary.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_word return search_in_node(word, self.root) class WordDictionary2: def __init__(self): self.words = {} def add_word(self, word: str) -> None: if len(word) not in self.words: self.words[len(word)] = [] self.words[len(word)].append(word) def search(self, word: str) -> bool: if len(word) not in self.words: return False for candidate in self.words[len(word)]: if all(word[i] == candidate[i] or word[i] == \'.\' for i in range(len(word))): return True return False"},{"question":"**Scenario**: As a software engineer, you are working on a version control system that requires getting the minimum number of steps needed to make two file versions identical by only deleting characters. This is crucial for efficiently merging different versions of files and tracking the changes made by different users. # Task Write a function `min_delete_steps` that calculates the minimum number of deletion steps required to make two given strings identical. You need to implement this using a dynamic programming approach for efficiency. # Function Signature ```python def min_delete_steps(word1: str, word2: str) -> int: pass ``` # Input * `word1` (a string, 1 ≤ len(word1) ≤ 500) * `word2` (a string, 1 ≤ len(word2) ≤ 500) # Output * An integer, representing the minimum number of steps required to make both strings identical. # Constraints * The given strings consist of lowercase English letters only. # Example ```python assert min_delete_steps(\\"sea\\", \\"eat\\") == 2 assert min_delete_steps(\\"leetcode\\", \\"etco\\") == 4 ``` # Explanation 1. In the first example, \\"sea\\" can be transformed to \\"ea\\" by deleting \'s\' and \\"eat\\" can be transformed to \\"ea\\" by deleting \'t\'. Thus, the total deletions required are 2. 2. In the second example, the minimum steps needed are 4 deletions to make the two strings the same. # Notes * Implement the dynamic programming version to ensure efficiency. * Thoroughly test your function, considering both normal cases and edge cases (e.g., empty strings, no common characters).","solution":"def min_delete_steps(word1: str, word2: str) -> int: Calculate the minimum number of deletion steps required to make two given strings identical. # Get the lengths of the words m, n = len(word1), len(word2) # Create a DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(m): for j in range(n): if word1[i] == word2[j]: dp[i+1][j+1] = dp[i][j] + 1 else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]) # The length of the longest common subsequence lcs_length = dp[m][n] # The minimum deletes required return (m + n) - 2 * lcs_length # Example assertions for correctness verification assert min_delete_steps(\\"sea\\", \\"eat\\") == 2 assert min_delete_steps(\\"leetcode\\", \\"etco\\") == 4"},{"question":"# AVL Tree Re-balancing Function Implementation You are provided with a partial implementation of an AVL Tree - a self-balancing binary search tree. Your task is to complete the implementation for node deletion, ensuring the tree remains balanced after deletions. **Function to Implement**: ```python def delete(self, key): Deletes the key from the AVL Tree and re-balances it. Args: key: The key to delete. ``` Requirements: * **Input Format**: * An integer `key` that needs to be deleted from the tree. Assume that the key exists in the tree. * **Output Format**: * None. The function modifies the tree in place. * **Constraints**: * The tree is not empty. Your function should handle replacing nodes correctly, updating height and balance, and performing necessary rotations to maintain AVL properties. Example: ```python tree = AvlTree() tree.insert(10) tree.insert(20) tree.insert(5) tree.insert(6) tree.delete(10) # In-order traversal of the tree after deletion print(tree.in_order_traverse()) # Expected Output: [5, 6, 20] ``` Performance Requirements: The implementation should maintain O(log N) time complexity for deletions. Use the provided AVL tree code, and ensure it is compatible with the insertion, rotation, and traversal logic given.","solution":"class Node: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: temp = node.right node = None return temp elif not node.right: temp = node.left node = None return temp temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._rebalance(node) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _rebalance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if node: self._in_order_helper(node.left, result) result.append(node.key) self._in_order_helper(node.right, result)"},{"question":"# Binary Heap Implementation and Element Tracking # Context You are given a class `BinaryHeap` that implements a min-heap using an array. The heap allows two primary operations: `insert` to add elements and `remove_min` to extract the smallest element. # Challenge Extend the `BinaryHeap` class to include a new method `find_element(val)` that searches for an element in the heap and returns its index (or -1 if the element is not found). Additionally, optimize the `remove_min` method to maintain an auxiliary structure that keeps track of all elements, allowing for O(1) access to any element by its value. # Requirements 1. **find_element(val)**: - Input: An integer `val`. - Output: The index of `val` in the heap if it exists, otherwise -1. - Performance: Ensure the method operates efficiently with respect to the binary heap properties. 2. **remove_min**: - Maintain an additional data structure that allows direct access to elements by value. - Update this structure on each `insert` and `remove_min`. # Implementation Details - Modify the `BinaryHeap` class provided in snippets. - Add a dictionary `element_indices` for efficient element lookup and maintenance. # Example Usage ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) heap.insert(2) print(heap.find_element(7)) # Should return the index of 7 in the heap print(heap.remove_min()) # Should remove and return the min element (2) print(heap.find_element(2)) # Should return -1 as 2 has been removed ``` # Constraints - All values inserted in the heap are unique. - The heap initially will not contain any elements. Extend the existing `BinaryHeap` class provided, ensuring it adheres to the specified requirements and ensure accuracy and performance using test cases.","solution":"class BinaryHeap: def __init__(self): self.heap = [] self.element_indices = {} def insert(self, val): self.heap.append(val) self._bubble_up(len(self.heap) - 1) self.element_indices[val] = self.heap.index(val) def remove_min(self): if len(self.heap) < 1: return None if len(self.heap) == 1: min_val = self.heap.pop() del self.element_indices[min_val] return min_val min_val = self.heap[0] self.heap[0] = self.heap.pop() del self.element_indices[min_val] self._bubble_down(0) self.element_indices[self.heap[0]] = 0 return min_val def find_element(self, val): return self.element_indices.get(val, -1) def _bubble_up(self, index): while index > 0: parent_index = (index - 1) // 2 if self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self.element_indices[self.heap[index]] = index self.element_indices[self.heap[parent_index]] = parent_index index = parent_index else: break def _bubble_down(self, index): length = len(self.heap) left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < length and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < length and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self.element_indices[self.heap[index]] = index self.element_indices[self.heap[smallest]] = smallest self._bubble_down(smallest)"},{"question":"# Coding Task: Implementing Advanced Markov Chain Features Given the basic implementation of the Markov Chain provided above, extend the functionality to include advanced features for more practical applications. Requirements 1. **Validate Chain**: Implement a function to validate that the given markov chain dictionary\'s transition probabilities sum to 1.0 for each state. If not, raise an appropriate error. 2. **Transition Count**: Modify the `iterating_markov_chain` function to keep track of the number of transitions made from each state, and return this count after a given number of interactions. 3. **State Transition Probability Update**: Implement a function to update the transition probabilities dynamically during the Markov chain iterations based on the frequencies of transitions observed. Function Signatures: ```python def validate_markov_chain(chain: dict) -> bool: Ensures that each state\'s transition probabilities sum to 1.0. pass def iterating_markov_chain_with_counts(chain: dict, state: str, iterations: int) -> dict: Yields a sequence of states and returns the number of transitions made from each state after the given iterations. pass def update_transition_probabilities(chain: dict, transition_frequencies: dict) -> dict: Updates the transition probabilities based on the observed frequencies. pass ``` Input and Output: - **validate_markov_chain**: - Input: A dictionary representing the Markov chain. - Output: Boolean indicating whether the chain is valid. - **iterating_markov_chain_with_counts**: - Input: A dictionary representing the Markov chain, initial state (`str`), and the number of iterations (`int`). - Output: Dictionary with states as keys and the count of transitions from each state as values. - **update_transition_probabilities**: - Input: A dictionary representing the Markov chain, and a dictionary representing the frequency of transitions. - Output: Updated dictionary representing the new Markov chain. Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Validate chain assert validate_markov_chain(chain) == True # Iterate and count transitions initial_state = \'A\' iterations = 1000 transition_counts = iterating_markov_chain_with_counts(chain, initial_state, iterations) print(transition_counts) # Expected: Dictionary with count of transitions from \'A\' and \'E\' # Update probabilities updated_chain = update_transition_probabilities(chain, transition_counts) print(updated_chain) # Expected: Updated chain with new transition probabilities based on observed frequencies ```","solution":"import random def validate_markov_chain(chain: dict) -> bool: Ensures that each state\'s transition probabilities sum to 1.0. for state, transitions in chain.items(): if not (abs(sum(transitions.values()) - 1.0) < 1e-9): raise ValueError(f\\"Transition probabilities for state {state} do not sum to 1.0\\") return True def iterating_markov_chain_with_counts(chain: dict, state: str, iterations: int) -> dict: Yields a sequence of states and returns the number of transitions made from each state after the given iterations. transition_counts = {s: 0 for s in chain} current_state = state for _ in range(iterations): transition_counts[current_state] += 1 next_state = random.choices(list(chain[current_state].keys()), list(chain[current_state].values()))[0] current_state = next_state return transition_counts def update_transition_probabilities(chain: dict, transition_frequencies: dict) -> dict: Updates the transition probabilities based on the observed frequencies. updated_chain = {} for state, freq in transition_frequencies.items(): total_transitions = sum(freq.values()) updated_chain[state] = {next_state: count / total_transitions for next_state, count in freq.items()} return updated_chain # Example usage: # chain = { # \'A\': {\'A\': 0.6, \'E\': 0.4}, # \'E\': {\'A\': 0.7, \'E\': 0.3} # } # validate_markov_chain(chain) # initial_state = \'A\' # iterations = 1000 # transition_counts = iterating_markov_chain_with_counts(chain, initial_state, iterations) # updated_chain = update_transition_probabilities(chain, transition_counts)"},{"question":"You are tasked with writing a function to efficiently insert elements into a sorted array using binary search to determine the correct insertion index. This is often crucial in sorting algorithms and search optimizations. # Function Signature ```python def insert_and_sort(array, values): Inserts multiple values into a sorted array preserving the order. Parameters: array (List[int]): A sorted list of integers values (List[int]): A list of integers to be inserted. Returns: List[int]: A new sorted list with the values inserted. pass ``` # Input * `array`: A list of sorted integers. (1 <= len(array) <= 10^4) * `values`: A list of integers to be inserted into the sorted array. (1 <= len(values) <= 10^3) # Output * A new list with `values` inserted in `array`, maintaining sorted order. # Constraints * The input array is guaranteed to be already sorted. * Values to be inserted may include duplicate values already in the array or in the values list. # Performance Requirements * The solution efficiency must maximize the benefits of binary search, with a focus on minimizing the number of comparisons and overall computation time. # Example ```python array = [1, 3, 5, 6] values = [2, 5, 7] insert_and_sort(array, values) ``` **Note**: The expected return should be `[1, 2, 3, 5, 5, 6, 7]`. # Explanation 1. Insert `2`: `[1, 2, 3, 5, 6]` 2. Insert `5`: `[1, 2, 3, 5, 5, 6]` 3. Insert `7`: `[1, 2, 3, 5, 5, 6, 7]` Good luck!","solution":"from bisect import bisect_left def insert_and_sort(array, values): Inserts multiple values into a sorted array preserving the order. Parameters: array (List[int]): A sorted list of integers values (List[int]): A list of integers to be inserted. Returns: List[int]: A new sorted list with the values inserted. result = array[:] for value in values: insert_index = bisect_left(result, value) result.insert(insert_index, value) return result"},{"question":"# Question: Implement BST Operations Context: You are tasked with implementing basic operations for a Binary Search Tree (BST). This data structure needs to efficiently handle dynamic insertions, deletions, and lookups while maintaining order. Problem Statement: Implement the following functions for the Binary Search Tree (BST): 1. `insert(self, root: TreeNode, key: int) -> TreeNode`: Inserts a new key into the BST. If the tree is empty, the new key becomes the root. 2. `delete(self, root: TreeNode, key: int) -> TreeNode`: Deletes the specified key from the BST and returns the modified tree. 3. `search(self, root: TreeNode, key: int) -> bool`: Searches for the specified key in the BST. Returns `True` if found, else `False`. Function Signatures: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def insert(self, root: TreeNode, key: int) -> TreeNode: pass def delete(self, root: TreeNode, key: int) -> TreeNode: pass def search(self, root: TreeNode, key: int) -> bool: pass ``` Input and Output Formats: 1. `insert` - Input: A `TreeNode` representing the root, and an integer `key` to be inserted. - Output: The root `TreeNode` of the modified BST. 2. `delete` - Input: A `TreeNode` representing the root, and an integer `key` to be deleted. - Output: The root `TreeNode` of the modified BST. 3. `search` - Input: A `TreeNode` representing the root, and an integer `key` to be searched. - Output: A boolean `True` if the key is found, `False` otherwise. Constraints: - The keys are unique. - The BST should maintain its properties after each operation. - `insert`, `delete`, and `search` operations should follow O(log n) average time complexity. - You may assume that the initial root is always a valid `TreeNode`. Example: ```python # Initialize the BST and a root node bst = BinarySearchTree() root = TreeNode(10) # Insert elements root = bst.insert(root, 5) root = bst.insert(root, 15) root = bst.insert(root, 2) root = bst.insert(root, 6) # Search element found = bst.search(root, 6) # Should return True missing = bst.search(root, 20) # Should return False # Delete element root = bst.delete(root, 5) ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def insert(self, root: TreeNode, key: int) -> TreeNode: if root is None: return TreeNode(key) elif key < root.val: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) return root def delete(self, root: TreeNode, key: int) -> TreeNode: if root is None: return root if key < root.val: root.left = self.delete(root.left, key) elif key > root.val: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = self._get_min_value_node(root.right) root.val = min_larger_node.val root.right = self.delete(root.right, min_larger_node.val) return root def _get_min_value_node(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def search(self, root: TreeNode, key: int) -> bool: if root is None: return False if key == root.val: return True elif key < root.val: return self.search(root.left, key) else: return self.search(root.right, key)"},{"question":"Optimal Matrix Chain Multiplication Context: Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices together. The problem is not to actually perform the multiplications but to decide the optimal sequence to minimize the number of scalar multiplications. Function Requirements: **Function Signature:** ```python def optimal_matrix_chain_multiplication(matrix_dims: List[int]) -> Tuple[int, List[List[int]]]: pass ``` **Input:** * `matrix_dims`: A list of integers where the `i-th` matrix Ai has dimensions `matrix_dims[i-1] x matrix_dims[i]`. **Output:** * The minimum number of scalar multiplications required to multiply the sequence of matrices. * The matrix containing the optimal splits. Additional Challenge: Implement a function to print the optimal order of matrix multiplication. **Function Signature:** ```python def print_optimal_order(optimal_solution: List[List[int]], i: int, j: int) -> None: pass ``` **Input:** * `optimal_solution`: The matrix containing the indexes of the optimal splits, obtained from `optimal_matrix_chain_multiplication`. * `i`: Starting index for the range of matrices. * `j`: Ending index for the range of matrices. **Output:** * Prints the optimal order of multiplications. # Example: ```python def main(): matrix_dims = [30, 35, 15, 5, 10, 20, 25] # Size of matrices: 30x35, 35x15, 15x5, 5x10, 10x20, 20x25 min_mults, optimal_splits = optimal_matrix_chain_multiplication(matrix_dims) print(f\\"Minimum number of multiplications needed: {min_mults}\\") print(\\"Optimal order of multiplications:\\") print_optimal_order(optimal_splits, 1, len(matrix_dims)-1) if __name__ == \\"__main__\\": main() ``` This question tests the student\'s understanding of dynamic programming, matrix manipulation, and efficient algorithm implementation.","solution":"from typing import List, Tuple def optimal_matrix_chain_multiplication(matrix_dims: List[int]) -> Tuple[int, List[List[int]]]: n = len(matrix_dims) - 1 m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length. for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + matrix_dims[i - 1] * matrix_dims[k] * matrix_dims[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s def print_optimal_order(optimal_solution: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_order(optimal_solution, i, optimal_solution[i][j]) print_optimal_order(optimal_solution, optimal_solution[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"You are given an array of integers and your task is to sort the array using the Stooge Sort algorithm. Stooge Sort is a recursive algorithm that sorts the array by recursively sorting the first two-thirds, last two-thirds, and the first two-thirds again if necessary. # Function Specification **Function Name**: `stoogesort` **Parameters**: * `arr` (list of int): The list of integers to be sorted. * `l` (int): Starting index of the portion of the list to be sorted. * `h` (int): Ending index of the portion of the list to be sorted. **Returns**: None (The function sorts the array `arr` in place). # Input - A list `arr` of integers where 1 <= len(arr) <= 1000. - Indices `l` and `h` representing the starting and ending indices for sorting. # Output - The function should modify the list `arr` in place such that it becomes sorted in non-decreasing order. # Constraints 1. All elements of the array are integers. 2. Sorting must be done using Stooge Sort. 3. Recursive approach must be used as specified by the algorithm. # Example ```python arr = [2, 4, 5, 3, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5] ``` # Performance Requirements Your implementation should not cause excessive use of memory or cause a stack overflow for input arrays within the given constraints.","solution":"def stoogesort(arr, l, h): Sorts the array using the Stooge Sort algorithm. Args: arr (list of int): The list of integers to be sorted. l (int): Starting index of the portion of the list to be sorted. h (int): Ending index of the portion of the list to be sorted. Returns: None: The function sorts the array in place. if l >= h: return # swap if needed if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2 / 3 stoogesort(arr, l, h - t) # Recursively sort last 2 / 3 stoogesort(arr, l + t, h) # Recursively sort first 2 / 3 again to confirm stoogesort(arr, l, h - t)"},{"question":"# Caesar Cipher Decoder You are given a message that has been encrypted using a Caesar Cipher with an unknown shift key. Your task is to write a function that accepts the encrypted message and the shift key, and returns the original (decrypted) message. The decoding process is the reverse of the encoding process: you will shift each letter backward by the specified number of positions in the alphabet. # Function Signature ```python def caesar_decoder(encrypted_message: str, shift_key: int) -> str: pass ``` # Input * `encrypted_message` (str): the encrypted message that contains alphabetic characters and possibly punctuation, spaces, or digits. It can be of length `1 <= len(encrypted_message) <= 100`. * `shift_key` (int): the shift key used for encryption. It is a positive integer. # Output * Return the original message as a string. # Constraints * The input string can contain both uppercase and lowercase letters. * Other characters (spaces, punctuation, numbers) should remain unchanged. * The shift key can be greater than 26 (multiple rotations). # Example ```python # Example: encrypted_message = \\"ifmmp\\" shift_key = 1 # \'i\' shifted by 1 backward -> \'h\' # \'f\' shifted by 1 backward -> \'e\' # \'m\' shifted by 1 backward -> \'l\' # \'m\' shifted by 1 backward -> \'l\' # \'p\' shifted by 1 backward -> \'o\' caesar_decoder(encrypted_message, shift_key) ``` Expected output: \\"hello\\" # Task Implement the `caesar_decoder` function to decode the `encrypted_message` using the given `shift_key`.","solution":"def caesar_decoder(encrypted_message: str, shift_key: int) -> str: decrypted_message = [] for char in encrypted_message: if char.isalpha(): shift = shift_key % 26 if char.islower(): new_char = chr((ord(char) - shift - ord(\'a\')) % 26 + ord(\'a\')) else: new_char = chr((ord(char) - shift - ord(\'A\')) % 26 + ord(\'A\')) decrypted_message.append(new_char) else: decrypted_message.append(char) return \\"\\".join(decrypted_message)"},{"question":"Plus One Increment Problem Statement You are given a non-negative number represented as an array of digits, where each element in the array contains a single digit. The digits are stored in a big-endian format, meaning that the most significant digit is at the head of the list. Your task is to write a function to add one to the number. The output should be the resultant array of digits after adding one. **Function Signature:** ```python def plus_one(digits: List[int]) -> List[int]: ``` **Input:** * `digits`: A list of integers representing the number, where each element is a single digit between 0 and 9 inclusive. The list may have length from 1 to 10^6. **Output:** * Returns a list of integers representing the incremented number. **Constraints:** * You are not allowed to use any built-in big integer libraries that handle the entire number as a single entity. * Your solution should handle cases efficiently up to the maximum input size. **Performance Requirements:** * Time Complexity should be O(n), where n is the number of digits. * Space Complexity should be O(1) if performing in-place modification, or O(n) if returning a new list. Example: ```python plus_one([1, 2, 3]) -> [1, 2, 4] plus_one([9, 9, 9]) -> [1, 0, 0, 0] plus_one([0]) -> [1] plus_one([2, 9, 9]) -> [3, 0, 0] ``` **Scenario:** Imagine you\'re developing a financial application that needs to handle incrementing very large integer identifiers stored as arrays of single digits due to system limitations on integer size. Your task is to ensure that these identifiers are incremented correctly. Edge Cases: 1. Handling the whole number being composed of 9\'s, such as [9, 9, 9, ...] 2. The number having trailing zeroes after addition. **Hint:** Use iteration from the least significant digit towards the most significant, ensuring to manage carries properly.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Increments the number represented as an array of digits by 1. Args: digits: List of integers where each integer is a digit (0-9). Returns: List of integers representing the number after adding one. n = len(digits) for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If we\'re here, it means all the digits were 9 return [1] + digits"},{"question":"Problem Statement You are tasked with enhancing the graph traversal algorithms to improve their efficiency and handle edge cases better. Your primary goal is to implement an iterative version of the shortest path finding algorithm using breadth-first search (BFS). # Detailed Requirements # Function Signature ```python def bfs_shortest_path(graph: dict, start: str, end: str) -> list: pass ``` # Inputs * `graph`: A dictionary representing a graph where keys are node labels and values are lists of adjacent nodes. * `start`: The starting node for the path. * `end`: The destination node for the path. # Output * A list representing the shortest path from `start` to `end`. If no path exists, return `None`. # Constraints * The graph may contain cycles. * Nodes are represented as string labels. * Nodes in `graph` are unique. * The graph and all nodes provided exist. # Scenario Imagine you are designing a system for a city\'s public transit network. Nodes represent stations and edges represent direct routes between stations. Given the public transit map (graph), you need to quickly find the shortest route between any two stations. This functionality can help design optimal routes for passengers and display the shortest path on a navigation app. # Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(bfs_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] print(bfs_shortest_path(graph, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] print(bfs_shortest_path(graph, \'A\', \'G\')) # Output: None ``` # Implementation Hints * Use a queue to manage the frontier of the search. * Track visited nodes to avoid revisiting and hence cycles. * Keep track of path to ensure you can reconstruct the shortest path when the end node is reached.","solution":"from collections import deque def bfs_shortest_path(graph: dict, start: str, end: str) -> list: Find the shortest path using BFS from start node to end node in a graph. Parameters: graph (dict): A dictionary representing the graph. start (str): The starting node. end (str): The destination node. Returns: list: A list representing the shortest path from start to end. If no path exists, return None. if start == end: return [start] # Initialize the queue with the start node and the path taken so far queue = deque([(start, [start])]) visited = set() while queue: # Pop the first node and path current_node, path = queue.popleft() # Explore neighbors for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == end: return path + [end] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None"},{"question":"**Scenario**: Imagine you are working on a software tool that requires efficiently managing a sorted list of user ratings. Users frequently add new ratings, and these ratings need to be inserted into the current sorted list quickly without re-sorting the entire list. Your task is to implement a function that can handle these insertions efficiently. **Task**: Write a Python function `insert_and_sort` that inserts a new rating into an existing sorted list of ratings, ensuring the list remains sorted after the insertion. You must use the provided helper function `search_insert` to locate the right insertion position. **Function Signature**: ```python def insert_and_sort(sorted_ratings: List[int], new_rating: int) -> List[int]: ``` **Input**: - `sorted_ratings`: A list of integers representing sorted user ratings. Each rating is between 0 and 100, inclusive. - `new_rating`: An integer between 0 and 100 representing the new rating to be inserted. **Output**: - A list of integers, representing the sorted list of ratings after the new rating has been inserted. **Constraints**: - The length of `sorted_ratings` will not exceed 1000. - You must not use any built-in sort functions. **Example**: ```python # Example 1 sorted_ratings = [1, 3, 5, 6] new_rating = 2 assert insert_and_sort(sorted_ratings, new_rating) == [1, 2, 3, 5, 6] # Example 2 sorted_ratings = [1, 3, 5, 6] new_rating = 7 assert insert_and_sort(sorted_ratings, new_rating) == [1, 3, 5, 6, 7] # Example 3 sorted_ratings = [1, 3, 5, 6] new_rating = 0 assert insert_and_sort(sorted_ratings, new_rating) == [0, 1, 3, 5, 6] ``` **Notes**: - Ensure your function handles edge cases, such as inserting into an empty list. - Consider the performance of your solution in relation to the constraints.","solution":"from typing import List def search_insert(sorted_ratings: List[int], new_rating: int) -> int: Helper function to find the correct insertion position for new_rating in the sorted list sorted_ratings. left, right = 0, len(sorted_ratings) while left < right: mid = (left + right) // 2 if sorted_ratings[mid] < new_rating: left = mid + 1 else: right = mid return left def insert_and_sort(sorted_ratings: List[int], new_rating: int) -> List[int]: Inserts a new rating into an existing sorted list of ratings. pos = search_insert(sorted_ratings, new_rating) return sorted_ratings[:pos] + [new_rating] + sorted_ratings[pos:]"},{"question":"<|Analysis Begin|> # Core Identification - **Algorithm/Data Structure**: This is a validation algorithm. - **Type**: String matching and numerical range validation. - **Main Purpose**: To check if a given string represents valid geographical coordinates. # Complexity - **Time Complexity**: O(n), where n is the length of the input string because each character is checked. - **Space Complexity**: O(1) for the first two solutions since no additional space other than a few variables is used. The regular expression solution uses space proportional to the complexity of the regex pattern, but generally considered O(1). # Principles - Validate characters in the string to ensure they conform to allowed symbols and digits. - Split the string into latitude and longitude components. - Check that both components are within the specified valid numerical ranges. # Characteristics & Applications - **Properties**: The algorithm needs to ensure exact character match for digits and a limited set of symbols. It also ensures numbers are within valid latitude and longitude range. - **Common Use Cases**: Validating user input for geographical location data, ensuring data integrity in location-based services. - **Strengths/Limitations**: - **Strengths**: Simple and straightforward; handles common valid/invalid input scenarios. - **Limitations**: Strict format requirement which might not be robust to slight variations in input format. # Implementation Challenges - **Edge Cases**: - Inputs with invalid characters or symbols. - Input strings with more or less than exactly two coordinate components. - Valid number ranges but malformed strings. - **Performance Bottlenecks**: No significant bottlenecks. However, improper handling of edge cases can lead to incorrect validations. - **Error Scenarios**: Inputs with extra spaces, non-numeric characters, or scientific notation representations (\'e\') can lead to incorrect results or exceptions. - **Optimization Points**: Use regular expressions to simplify and consolidate checks, although this can become complex and harder to debug. <|Analysis End|> <|Question Begin|> # Validate Geographical Coordinates You are required to write a function `is_valid_coordinates(coordinates: str) -> bool` that validates geographical coordinates. # Input - `coordinates`: A string containing latitude and longitude separated by a comma and a space. # Output - Returns `True` if the input string represents valid geographical coordinates, and `False` otherwise. # Geographical Coordinate Rules 1. Latitude value must be between -90 and 90 (inclusive). 2. Longitude value must be between -180 and 180 (inclusive). 3. The input string should only contain digits, \'-\', \'.\', \',\' and a space after the comma. 4. There should be no spaces between the minus sign \'-\' and the digits after it. # Examples **Valid Coordinates:** - \\"-23, 25\\" -> `True` - \\"43.91343345, 143\\" -> `True` - \\"4, -3\\" -> `True` **Invalid Coordinates:** - \\"23.234, - 23.4234\\" -> `False` (space between - and digit) - \\"N23.43345, E32.6457\\" -> `False` (illegal characters \'N\' and \'E\') - \\"6.325624, 43.34345.345\\" -> `False` (too many decimal points) - \\"0, 1,2\\" -> `False` (too many coordinates) # Constraints - You cannot use scientific notation (e.g., \'e\' in the coordinates). # Performance Requirements The function should aim for efficient validation within reasonable runtime and space consumption for typical input sizes. # Function Signature ```python def is_valid_coordinates(coordinates: str) -> bool: pass ``` Implement the function `is_valid_coordinates`, and ensure thorough testing against example cases and edge cases provided.","solution":"def is_valid_coordinates(coordinates: str) -> bool: Validates geographical coordinates. try: lat_str, lon_str = coordinates.split(\\", \\") except ValueError: return False try: lat = float(lat_str) lon = float(lon_str) except ValueError: return False if not (-90 <= lat <= 90): return False if not (-180 <= lon <= 180): return False lat_lon_str = lat_str + lon_str valid_chars = set(\\"0123456789-., \\") for char in lat_lon_str: if char not in valid_chars: return False return lat_str.count(\'.\') <= 1 and lon_str.count(\'.\') <= 1"},{"question":"You are required to implement a priority queue but using a more efficient approach than the linear array provided. Specifically, implement the priority queue using a binary heap (min-heap). The implementation should support efficient insertion and extraction operations. # Requirements: 1. **Class Definition**: Define a `MinPriorityQueue` class. 2. **Methods**: * `size()` - Return the size of the priority queue. * `push(item, priority)` - Insert an item with a given priority into the queue. * `pop()` - Remove and return the item with the highest priority. 3. **Constraints**: * `PriorityQueueNode` class is provided and should be used. * Use a binary heap structure for managing the elements. 4. **Performance**: * The `push` operation should have a time complexity of (O(log n)). * The `pop` operation should also have a time complexity of (O(log n)). # Example: 1. Instantiate the `MinPriorityQueue`: ```python pq = MinPriorityQueue() ``` 2. Insert items into the priority queue: ```python pq.push(\\"task1\\", 5) pq.push(\\"task2\\", 3) pq.push(\\"task3\\", 8) pq.push(\\"task4\\", 1) ``` 3. Remove and return the highest priority item: ```python print(pq.pop()) # Output should be \\"task4\\" print(pq.pop()) # Output should be \\"task2\\" print(pq.size()) # Output should be 2 ``` # Notes: * Handle edge cases where the queue might be empty and no items are available to pop. * Assume that priorities are unique for simplicity.","solution":"import heapq class PriorityQueueNode: def __init__(self, item, priority): self.item = item self.priority = priority def __lt__(self, other): return self.priority < other.priority class MinPriorityQueue: def __init__(self): self.heap = [] def size(self): return len(self.heap) def push(self, item, priority): node = PriorityQueueNode(item, priority) heapq.heappush(self.heap, node) def pop(self): if not self.heap: return None node = heapq.heappop(self.heap) return node.item"},{"question":"You are tasked with implementing a function that takes a nested array of arbitrary depth and produces a single-dimensional array containing all the elements. The function should handle mixed types (e.g., arrays of integers, strings, lists, etc.) and ensure that strings are not treated as iterable for the purpose of flattening. # Function Signature ```python def flatten_array(nested_array: list) -> list: :param nested_array: List containing elements of various types (including nested lists) :return: A flat list containing all elements from nested_array, with no nested lists ``` # Input * `nested_array`: a list which may contain integers, strings, floats, and other lists. # Output * A single-dimensional list containing all elements from `nested_array` in a depth-first manner. # Constraints * Do not use any in-built flattening functions. # Example 1. Input: `[1, [2, [3, 4]], 5]` Output: `[1, 2, 3, 4, 5]` 2. Input: `[1, [\\"a\\", [\\"b\\", \\"c\\"]], [2.5]]` Output: `[1, \\"a\\", \\"b\\", \\"c\\", 2.5]` # Edge Cases 1. Input: `[]` Output: `[]` 2. Input: `[[], [[]], [[[[]]]]]` Output: `[]` # Performance Requirements * The function should handle reasonably large lists. * Ensure the function is optimized in terms of recursion depth handling (if possible). Implement the function `flatten_array` without using any third-party libraries for flattening arrays.","solution":"def flatten_array(nested_array: list) -> list: Takes a nested array of arbitrary depth and produces a single-dimensional array containing all the elements. result = [] def _flatten(sub_array): for item in sub_array: if isinstance(item, list): _flatten(item) else: result.append(item) _flatten(nested_array) return result"},{"question":"# String Reversal Challenge Scenario You are part of a software development team that works on text processing features for a new application. One essential feature is efficiently reversing strings of varying lengths, which will be used in different parts of the application, such as in text editors and data validators. Task Implement a function that can reverse a given string using any of the given methods. Pay close attention to performance and choose the most optimal method based on given constraints. Definition ```python def reverse_string(s: str) -> str: Reverses the given string and returns the reversed string. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. pass ``` Input * `s` (string): The string that needs to be reversed. The length of `s` can range from 0 to 10^6. Output * A string that is the reverse of the input string `s`. Constraints * Time complexity should be O(n), where n is the length of the string. * Space complexity should be O(n), maintaining efficiency and avoiding unnecessary overhead. * The implementation should handle edge cases gracefully. * Avoid using the recursive method for very large strings due to potential limitations in stack depth. Performance Requirements * Consider scalability with respect to the maximum input size. * Optimize the function for readability, maintainability, and efficient resource usage. # Example Cases 1. Input: \\"hello\\" Output: \\"olleh\\" 2. Input: \\"world\\" Output: \\"dlrow\\" 3. Input: \\"a\\" Output: \\"a\\" 4. Input: \\"\\" Output: \\"\\"","solution":"def reverse_string(s: str) -> str: Reverses the given string and returns the reversed string. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. return s[::-1] # Using Python\'s string slicing to efficiently reverse the string"},{"question":"# Scenario As an experienced robber skilled in dynamic programming, you have taken on a new challenge: robbing a sequence of houses under specific constraints. Each house has a certain amount of money, but you can’t rob two consecutive houses due to security systems that will alert the police. # Task Write a function `house_robber(houses)` that determines the maximum amount of money you can rob without triggering any alarms. The function should accept a list of non-negative integers representing the amount of money at each house. # Input * `houses` - a list of non-negative integers where `houses[i]` is the amount of money in the i-th house. # Output * Return an integer representing the maximum amount of money you can rob. # Constraints * Each element in `houses` will be a non-negative integer. * The length of `houses` will be in the range 0 to 10^4. * Performance in terms of time complexity should be O(n), and space complexity should be O(1). # Example ```python print(house_robber([1,2,3,1])) # Output: 4 print(house_robber([2,7,9,3,1])) # Output: 12 ``` # Explanation * In the first example, the optimal solution is to rob houses at index 0 and index 2, obtaining a total of 1 + 3 = 4. * In the second example, you should rob houses at index 1 and index 2, and index 4, for a total of 7 + 5 = 12.","solution":"def house_robber(houses): Determines the maximum amount of money that can be robbed without robbing two consecutive houses. Args: houses (list of int): A list where each element represents the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. if not houses: return 0 prev_max = 0 curr_max = 0 for amount in houses: temp = curr_max curr_max = max(prev_max + amount, curr_max) prev_max = temp return curr_max"},{"question":"You are given two input lists of integers. Implement a `ZigZagIterator` class that alternates between elements from both lists and returns them in a zigzag fashion. # Class Definition Implement the following methods: * `__init__(self, v1: List[int], v2: List[int])`: Initialize the iterator with two lists `v1` and `v2`. * `next(self) -> int`: Returns the next element in zigzag order. * `has_next(self) -> bool`: Returns `True` if there are more elements to iterate, `False` otherwise. # Input For the constructor: * `v1`: List of integers, where 0 <= len(v1) <= 10^5. * `v2`: List of integers, where 0 <= len(v2) <= 10^5. For `next` method: * No input required. For `has_next` method: * No input required. # Output For `next` method: * Returns the next integer in zigzag order. For `has_next` method: * Returns a boolean indicating if there are more elements to iterate. # Constraints * Ensure that the iterator handles edge cases such as one or both input lists being empty. * Optimize operations to ensure efficient retrieval of elements. # Example ```python # Input l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) # Output result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Note You may assume that all integers in the input lists are non-negative. **Hint**: Consider using a queue to manage the order of lists from which elements are fetched.","solution":"from collections import deque class ZigZagIterator: def __init__(self, v1, v2): # Initialize the queues with non-empty lists self.queue = deque([(v1, 0), (v2, 0)]) def next(self): if not self.has_next(): return None # Pop the next list and index v, i = self.queue.popleft() # Retrieve the value result = v[i] # If there are more elements in the list, put it back with the next index if i + 1 < len(v): self.queue.append((v, i + 1)) return result def has_next(self): # Check if there are any elements left in the queue to iterate while self.queue: v, i = self.queue[0] if i < len(v): return True self.queue.popleft() # remove exhausted list return False"},{"question":"# Objective Implement a function to determine whether the given directed graph is strongly connected. This requires you to utilize DFS and graph reversal concepts efficiently. # Function Signature ```python def is_strongly_connected_graph(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Input - **vertex_count** (int): The number of vertices in the graph. - **edges** (List[Tuple[int, int]]): A list of directed edges, where each edge is represented as a tuple (source, target). # Output - **bool**: Returns `True` if the graph is strongly connected, `False` otherwise. # Constraints - 1 ≤ vertex_count ≤ 10^4 - 0 ≤ number of edges ≤ 10^5 - Each vertex is labeled from 0 to vertex_count - 1. # Example ```python # Example 1 vertex_count = 4 edges = [(0, 1), (1, 2), (2, 0), (0, 3), (3, 0)] print(is_strongly_connected_graph(vertex_count, edges)) # Output: True # Example 2 vertex_count = 4 edges = [(0, 1), (1, 2), (2, 0)] print(is_strongly_connected_graph(vertex_count, edges)) # Output: False ``` # Notes - Focus on implementing the graph using adjacency list for memory efficiency. - Ensure that the DFS and graph reversal operations are working correctly and efficiently. - Consider edge cases like isolated nodes, empty edge lists, and fully connected graphs. - Avoid exceeding recursion limits; an iterative approach may be preferred for large graphs.","solution":"from typing import List, Tuple def is_strongly_connected_graph(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque def dfs(graph: defaultdict, start: int, visited: set): stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) if vertex_count == 0: return True graph = defaultdict(list) reverse_graph = defaultdict(list) # Build graph and reverse graph for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) visited = set() # Start DFS from the first node dfs(graph, 0, visited) if len(visited) != vertex_count: return False visited.clear() # Start DFS on reversed graph dfs(reverse_graph, 0, visited) return len(visited) == vertex_count"},{"question":"# Abbreviation Generation Create a function `generate_abbreviations(word: str) -> List[str]` which generates all possible abbreviations for the given input string `word`. An abbreviation is formed by replacing some number of characters with their count in the word. Input: * `word` - A string with length (n) where (0 leq n leq 100). Output: * A list of strings containing all possible abbreviations of the input word. Performance Requirements: * The solution should handle inputs of length up to 100 efficiently, considering both time and space complexity. # Constraints * The input string `word` consists of only lowercase English letters. # Example: ```python print(generate_abbreviations(\\"word\\")) ``` Output: ```python [ \'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\' ] ``` # Note: * The order of the abbreviations in the output list does not matter. * Every character may or may not be counted as a part of an abbreviation. # Edge Cases: * Ensure to address edge cases such as empty strings or single-character strings in your function.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: Generates all possible abbreviations of the given word. def backtrack(pos: int, current: str, count: int): if pos == len(word): if count > 0: current += str(count) abbreviations.append(current) return # Keep the current letter backtrack(pos + 1, current + (str(count) if count > 0 else \'\') + word[pos], 0) # Abbreviate the current letter backtrack(pos + 1, current, count + 1) abbreviations = [] backtrack(0, \'\', 0) return abbreviations"},{"question":"You are given a singly linked list. Your task is to extend the functionality of the provided `is_sorted` function. Specifically, you need to implement a function, `check_and_repair_sorted_linked_list(head)`, that first checks if the linked list is sorted in an ascending order. If it is not sorted, your function should repair the list and sort it in ascending order. Return the modified head of the linked list. If the list is already sorted or is empty, return the head as is. # Constraints - The linked list can contain duplicate values. - You need to ensure the solution has a time complexity of O(n log n) for sorting the linked list. - The space complexity should be O(1), implying no additional data structures like arrays or lists should be used for sorting. # Function Signature ```python def check_and_repair_sorted_linked_list(head: Optional[ListNode]) -> Optional[ListNode]: ``` # Input - `head`: The head node of the singly linked list. # Output - Return the possibly modified head node of the linked list. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: # Input: head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3, None)))) # Output: ListNode(-1, ListNode(1, ListNode(2, ListNode(3, None)))) # Example 2: # Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) # Output: ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) ``` # Additional Notes - You may assume the existence of the `ListNode` class, representing the nodes of the linked list. - Make sure to restore the linked list in-place and do not utilize additional data structures to hold node values for sorting.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def check_and_repair_sorted_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head def is_sorted(head: ListNode) -> bool: current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True def merge_sort(head: ListNode) -> ListNode: if not head or not head.next: return head def split_list(head: ListNode): slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return head, mid def merge_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next tail.next = l1 or l2 return dummy.next left, right = split_list(head) left = merge_sort(left) right = merge_sort(right) return merge_lists(left, right) # Check if the linked list is sorted if is_sorted(head): return head # Sort the linked list using merge sort return merge_sort(head)"},{"question":"# Topological Sorting of Courses Imagine you are tasked with creating a schedule for students to follow, where certain courses have prerequisites. This scenario can be represented by a Directed Acyclic Graph (DAG), where each course is a node, and a directed edge from course A to course B signifies that A must be completed before B. You need to write a function `course_schedule(graph: Dict[int, List[int]]) -> List[int]`, which takes in a dictionary representing the graph and returns a list of courses in a valid order such that all prerequisites are satisfied. Function Signature ```python def course_schedule(graph: Dict[int, List[int]]) -> List[int]: pass ``` Input * `graph`: A dictionary where keys are course numbers (integers), and values are lists of course numbers that are prerequisites. Output * Returns a list of integers representing the courses in a valid order. * If it is not possible to complete the courses due to a cycle, raise a `ValueError(\\"cycle\\")`. Example ```python graph = { 0: [1], 1: [2], 2: [3], 3: [] } assert course_schedule(graph) == [0, 1, 2, 3] graph_with_cycle = { 0: [1], 1: [2], 2: [0] } course_schedule(graph_with_cycle) # should raise ValueError(\\"cycle\\") ``` Notes 1. You may use either the recursive or iterative method provided in the code snippets. 2. Ensure that your solution handles edge cases such as empty graphs, isolated nodes, and cycles. 3. Consider the efficiency of your implementation, keeping the complexity constraints in mind. 4. Provide well-documented code to explain your approach and logic.","solution":"def course_schedule(graph): Returns a list of courses in a valid order such that all prerequisites are satisfied. If there is a cycle in the graph, raises a ValueError(\\"cycle\\"). from collections import defaultdict, deque def topological_sort(vertices, graph): in_degree = {u: 0 for u in vertices} for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([u for u in vertices if in_degree[u] == 0]) top_order = [] while queue: u = queue.popleft() top_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) if len(top_order) == len(vertices): return top_order else: raise ValueError(\\"cycle\\") vertices = set(graph.keys()) for prereqs in graph.values(): vertices.update(prereqs) return topological_sort(vertices, graph)"},{"question":"Detecting Cycle in a Linked List You are given a singly linked list. Your task is to determine if there is a cycle in the linked list using the Floyd\'s Cycle-Finding Algorithm. A linked list is cyclic if and only if there exists a node in the list that can be reached again by continuously following the next pointer. Use the following class definition for the linked list nodes: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Function Signature ```python def has_cycle(head: Node) -> bool: ``` Input - `head` (Node): The head of the linked list. Output - `bool`: Returns `True` if the linked list has a cycle, otherwise `False`. Constraints - The number of nodes is in the range [0, 10^4]. - -10^5 <= Node.val <= 10^5 Performance Requirements - The solution should run in linear time O(n). - The solution should use constant space O(1). Example ```python # Example 1: # Input: head = [3,2,0,-4] where the tail points to the second node # Output: True # Example 2: # Input: head = [1,2] where the tail points to the first node # Output: True # Example 3: # Input: head = [1] with no cycle # Output: False ``` Notes - You may assume the `Node` class and linked list construction are provided separately. - You should focus on the implementation of the `has_cycle` function. - Thoroughly consider edge cases, such as an empty list or a single node with a cycle.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def has_cycle(head: Node) -> bool: Detects a cycle in a linked list using Floyd\'s Cycle-Finding Algorithm. Args: head (Node): The head of the linked list. Returns: bool: True if the linked list has a cycle, otherwise False. if not head: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Cholesky Decomposition Application Context You are given a task to solve a system of linear equations involving a symmetric positive-definite matrix using Cholesky decomposition. Given the matrix A and a vector b, you need to implement a function that first computes the Cholesky decomposition of A and then uses it to find the solution vector x for the equation Ax = b. Problem Statement Write a function `solve_linear_system(A: List[List[float]], b: List[float]) -> List[float]` that takes as input a Hermitian positive-definite matrix A and a vector b, and returns the solution vector x for Ax = b. Constraints - The matrix A is an n x n matrix (2 ≤ n ≤ 100). - The vector b is of length n. - All elements in A and b are floating-point numbers. - The matrix A is assumed to be Hermitian and positive-definite. Function Signature ```python def solve_linear_system(A: List[List[float]], b: List[float]) -> List[float]: pass ``` Input and Output Format - **Input**: - A: List[List[float]] - Hermitian positive-definite matrix of dimension n x n. - b: List[float] - Vector of length n. - **Output**: - List[float] - Solution vector x for the equation Ax = b. Example ```python # Example input A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] b = [1, 2, 3] # Expected output (approximated) x = solve_linear_system(A, b) print(x) # Output should be the solution to Ax = b ``` Implementation Details 1. **Decompose** the matrix A using Cholesky decomposition. 2. **Solve** the system using forward and backward substitution with the decomposed matrix. 3. Handle any possible errors or edge cases.","solution":"from typing import List import numpy as np def solve_linear_system(A: List[List[float]], b: List[float]) -> List[float]: Solves the linear system Ax = b using Cholesky decomposition where A is a Hermitian positive-definite matrix. # Convert inputs to numpy arrays for easier manipulation A_np = np.array(A, dtype=float) b_np = np.array(b, dtype=float) # Cholesky decomposition L_np = np.linalg.cholesky(A_np) # Solve Ly = b for y (forward substitution) y_np = np.linalg.solve(L_np, b_np) # Solve L^T x = y for x (backward substitution) x_np = np.linalg.solve(L_np.T, y_np) # Convert the solution back to a list x = x_np.tolist() return x"},{"question":"Matrix Multiplication with Validations You are tasked to implement a matrix multiplication function with additional validation checks on the inputs. Given two matrices, implement an algorithm to multiply them and return the resulting matrix. Ensure to handle common edge cases and provide meaningful error messages. # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: :type multiplicand: List[List[int]] :type multiplier: List[List[int]] :rtype: List[List[int]] pass ``` # Input 1. `multiplicand`: List of lists where each sub-list represents a row in the matrix. Each row has equal number of columns. 2. `multiplier`: List of lists where each sub-list represents a row in the matrix. Each row has equal number of columns. # Output A new matrix which is the product of `multiplicand` and `multiplier`. # Constraints - The elements of the matrices are integers. - Matrices can be empty or contain empty lists. - The number of columns of the `multiplicand` must equal the number of rows of the `multiplier`. # Performance Requirements - Handle matrices up to size 1000x1000 efficiently. # Example ```python multiply_matrices([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) # Output: [[58, 64], [139, 154]] ``` # Validation Requirements 1. If the number of columns in the `multiplicand` does not match the number of rows in the `multiplier`, raise an Exception with a message \\"Matrices are not compatible for multiplication\\". 2. If the input matrices are empty or contain empty rows, raise an Exception with a message \\"Input matrices must not be empty or contain empty rows\\". Implement the `multiply_matrices` function ensuring to validate the inputs and handle edge cases properly.","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the result. Raises appropriate errors for invalid inputs. :param multiplicand: List[List[int]], the first matrix :param multiplier: List[List[int]], the second matrix :return: List[List[int]], the resulting matrix after multiplication # Validation checks if not multiplicand or not multiplier: raise ValueError(\\"Input matrices must not be empty or contain empty rows\\") # Check for empty rows if any(not row for row in multiplicand) or any(not row for row in multiplier): raise ValueError(\\"Input matrices must not be empty or contain empty rows\\") rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check matrix dimensions for multiplication compatibility if cols_multiplicand != rows_multiplier: raise ValueError(\\"Matrices are not compatible for multiplication\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Task Implement a function to flatten a nested array into a single-level array. # Description Write a function `flatten_array(input_arr)` that takes a nested array `input_arr` as an argument and returns a single-level array containing all the elements of `input_arr` in the order they appear. # Function Signature ```python def flatten_array(input_arr: list) -> list: pass ``` # Input - `input_arr`: a list which may contain nested lists, integers, strings, and other non-iterable types. # Output - The function should return a single-level list containing all the elements from `input_arr` in their respective order. # Constraints - The input list will not be empty. - Elements can be deeply nested (multiple levels of nesting). - Strings within the list should not be decomposed into individual characters. # Performance Requirements - The solution should handle large inputs efficiently. # Example ```python input_arr = [1, [2, [3, 4]], 5] assert flatten_array(input_arr) == [1, 2, 3, 4, 5] input_arr = [1, \'a\', [\'b\', 2, [3, \'c\']], 4] assert flatten_array(input_arr) == [1, \'a\', \'b\', 2, 3, \'c\', 4] input_arr = [[[]], 1, [[[]]], [2, 3], [], [4]] assert flatten_array(input_arr) == [1, 2, 3, 4] ``` # Scenario Consider if you received a JSON response from an API that contains deeply nested lists. Your task is to process this JSON and convert these nested lists into a flat list to simplify the data handling process.","solution":"def flatten_array(input_arr): Flattens a nested list into a single-level list. :param input_arr: a list which may contain nested lists, integers, strings, and other non-iterable types. :return: a single-level list containing all elements from `input_arr` in their respective order. output = [] def flatten(sublist): for item in sublist: if isinstance(item, list): flatten(item) else: output.append(item) flatten(input_arr) return output"},{"question":"**Coding Challenge: Implementing Improved Jump Search** **Scenario**: You are given a sorted list of unique integers representing recorded temperatures over several days. Your goal is to find a particular temperature in the list using a modified version of the jump search algorithm. Instead of a fixed block size, you have decided to implement a dynamic block size that changes based on the square root of Fibonacci numbers for improved efficiency in certain cases. **Function Implementation**: Write a function `improved_jump_search(arr: List[int], target: int) -> int` that takes in a sorted list of integers `arr` and an integer `target`. The function should return the index of the target if found, or -1 if the target is not in the list. **Input**: 1. `arr`: A list of sorted integers [a1, a2, ..., an] where 1 ≤ n ≤ 10^6. 2. `target`: An integer to find in the list. **Output**: * Return an integer representing the index of the target. If the target is not found, return -1. **Constraints**: 1. The list is sorted in ascending order. 2. Each element in the list is unique. **Example**: ```python arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 7 print(improved_jump_search(arr, target)) # Output: 3 arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 20 print(improved_jump_search(arr, target)) # Output: -1 ``` **Additional Information**: * The function should efficiently handle array sizes up to the given constraints. * Consider edge cases such as when the target is the smallest or the largest element, and when the list is very small or very large.","solution":"from math import sqrt from typing import List def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b def improved_jump_search(arr: List[int], target: int) -> int: n = len(arr) if n == 0: return -1 fib_gen = fibonacci() fib_m = next(fib_gen) # Fibonacci[m-1] fib_m1 = next(fib_gen) # Fibonacci[m] fib_m2 = 0 # Fibonacci[m-2] while fib_m1 < n: fib_m2, fib_m, fib_m1 = fib_m, fib_m1, next(fib_gen) offset = -1 while fib_m1 > 1: i = min(offset + fib_m2, n - 1) if arr[i] < target: fib_m1 = fib_m fib_m = fib_m2 fib_m2 = fib_m1 - fib_m offset = i elif arr[i] > target: fib_m1 = fib_m2 fib_m = fib_m - fib_m2 fib_m2 = fib_m1 - fib_m else: return i if fib_m1 and offset < n - 1 and arr[offset + 1] == target: return offset + 1 return -1"},{"question":"# Zigzag Level Order Traversal of a Binary Tree **Objective**: Write a function to perform a zigzag level order traversal on a binary tree. **Description**: Given a binary tree, return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). **Function Signature**: `def zigzag_level_traversal(root: TreeNode) -> List[List[int]]` **Input**: - `root` (TreeNode): The root of the binary tree. **Output**: - `List[List[int]]`: A list of lists, where each nested list contains the values of the nodes at that level, in zigzag order. **Constraints**: - The maximum number of nodes in the binary tree does not exceed 104. - Node values can be any integer. **Scenario**: Imagine you are working on visualizing hierarchical data structures dynamically, where the zigzag traversal helps to highlight levels of data alternatively. Implementing this traversal will assist in your visualization mechanism. **Example**: Given binary tree `[3,9,20,null,null,15,7]`, ``` 3 / 9 20 / 15 7 ``` Return its zigzag level order traversal as: ``` [ [3], [20,9], [15,7] ] ``` **Requirements**: - Implement the function efficiently regarding time and space complexity. - Handle all edge cases (e.g., empty tree, single node tree, unbalanced trees). - Ensure the code is readable and well-documented to explain the logic and steps involved.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def zigzag_level_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.insert(0, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) left_to_right = not left_to_right return result"},{"question":"# Coding Challenge: Subtree Check You are given two binary trees, `s` and `t`. Your task is to write a function to determine if `t` is a subtree of `s`. A subtree of `s` is a node in `s` and all of its descendants that form a tree equivalent to `t`. # Your Function Implement the function `is_subtree(big, small)` where: 1. `big`: A reference to the root of the larger tree `s`. 2. `small`: A reference to the root of the smaller tree `t`. The function should return `True` if `t` is a subtree of `s`, otherwise return `False`. # Input/Output Format * Each node in the binary trees will have the attributes: - `val`: An integer representing the value of the node - `left`: A reference to the left child node (or `None` if no left child) - `right`: A reference to the right child node (or `None` if no right child) * The `big` and `small` trees can have up to `10000` nodes each. * The values stored in nodes are integers and are not necessarily unique. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: s = TreeNode(3) s.left = TreeNode(4) s.right = TreeNode(5) s.left.left = TreeNode(1) s.left.right = TreeNode(2) t = TreeNode(4) t.left = TreeNode(1) t.right = TreeNode(2) print(is_subtree(s, t)) # Expected output: True # Example 2: s = TreeNode(3) s.left = TreeNode(4) s.right = TreeNode(5) s.left.left = TreeNode(1) s.left.right = TreeNode(2) s.left.right.left = TreeNode(0) t = TreeNode(4) t.left = TreeNode(1) t.right = TreeNode(2) print(is_subtree(s, t)) # Expected output: False ``` # Constraints * The given trees will be non-empty. * Consider edge cases where either or both the trees have only one node. # Performance Requirements Strive to achieve an efficient solution that avoids redundant comparisons. Consider handling the edge cases and ensuring your solution is optimized for large inputs. ---","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): if not small: return True # An empty tree is always a subtree if not big: return False # If the larger tree is empty, then it can\'t have any subtrees if is_same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def is_same_tree(p, q): if not p and not q: return True # Both trees are empty if not p or not q: return False # One tree is empty and the other is not if p.val != q.val: return False # The values of the root nodes are different return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"You are provided an integer array. Your task is to implement a sorting function using the Cycle Sort algorithm, which sorts the array in ascending order. Cycle Sort is efficient in terms of minimizing the number of write operations into the array. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input: * `arr`: A list of integers. It can be empty, contain one element, or have duplicates. # Output: * Returns the sorted list of integers in ascending order. # Constraints: * The input list will contain integers in the range `-10^6` to `10^6`. * The length of the input list will be up to `10^3`. # Examples: ```python assert cycle_sort([3, 1, 2]) == [1, 2, 3] assert cycle_sort([4, 3, 1, 6, 2]) == [1, 2, 3, 4, 6] assert cycle_sort([5, 5, 5]) == [5, 5, 5] assert cycle_sort([]) == [] assert cycle_sort([1]) == [1] ``` # Hint: Cycle Sort is an in-place sorting algorithm. Emphasize on optimizing the number of write operations, ensuring each element is placed in its correct position within the same cycle without unnecessary movements.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: writes = 0 # Keeps track of the number of writes to the array # Go through each element and place it in its correct position for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Otherwise, put the item to its right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Scenario: Consider a project management software where tasks are dependent on each other. To execute a series of tasks most efficiently, we need to determine a valid execution sequence that respects these dependencies. # Task: Write a function `find_task_order(dependencies)` that takes a list of task dependencies and returns a valid task execution order. Each dependency is a pair `[a, b]` meaning task `a` must be executed before task `b`. If there is no valid order (due to circular dependencies), return an empty list. # Function Signature: ```python def find_task_order(dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` # Input: - `dependencies`: A list of tuples where each tuple `(a, b)` indicates a direct dependency `a -> b`. # Output: - A list of integers representing a valid task execution order, or an empty list if no valid order exists. # Constraints: - The number of tasks and dependencies can be up to `1000`. - Tasks are represented by integers. - There can be multiple valid orders, returning any one is acceptable. # Example: ```python dependencies = [(1, 2), (2, 3), (3, 4)] assert find_task_order(dependencies) in [[1, 2, 3, 4]] dependencies = [(1, 2), (2, 3), (3, 4), (4, 1)] assert find_task_order(dependencies) == [] ``` # Explanation: - In the first example, the only valid order is [1, 2, 3, 4]. - In the second example, there is no valid order because there is a cycle: 1 -> 2 -> 3 -> 4 -> 1. # Additional Notes: - Be sure to detect cycles when building the order. - Consider edge cases such as tasks with no dependencies.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_task_order(dependencies: List[Tuple[int, int]]) -> List[int]: # Build the graph and in-degree of each node graph = defaultdict(list) in_degree = defaultdict(int) nodes = set() for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 nodes.add(a) nodes.add(b) # Collect nodes without dependencies zero_in_degree_queue = deque([node for node in nodes if in_degree[node] == 0]) topo_order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topo_order) == len(nodes): return topo_order else: return []"},{"question":"# Red-Black Tree Open Range Search **Context**: Consider an e-commerce website where products need to be searchable by price within specified ranges. For efficient search and update operations, the company uses a balanced tree data structure to manage product prices. One of the most suitable data structures for this operation is a Red-Black Tree. **Task**: Write a function `range_search` to find all products whose prices fall within a given range [low, high]. Implement the `range_search` function in the provided Red-Black Tree class. **Function Signature**: ```python def range_search(self, low: int, high: int) -> list: pass ``` **Input**: * `low`: An integer representing the lower bound of the price range. * `high`: An integer representing the upper bound of the price range. **Output**: * A list of dictionaries with node values (product prices) and their colors that lie within the specified range. **Constraints**: * `low` <= `high` * There can be multiple nodes with the same value. * All node values are unique. **Example**: Given a tree with node values inserted as [11, 2, 14, 1, 7, 15, 5, 8, 4], a call to `range_search(5, 14)` should return: ```python [ {\'val\': 5, \'color\': \'black\'}, {\'val\': 7, \'color\': \'red\'}, {\'val\': 8, \'color\': \'black\'}, {\'val\': 11, \'color\': \'black\'}, {\'val\': 14, \'color\': \'black\'} ] ``` **Requirements**: 1. Do not alter the existing Red-Black Tree implementation, except to add your method inside the `RBTree` class definition. 2. Ensure your method does not compromise the Red-Black Tree properties. 3. The method should have a time complexity of O(log n + k), where k is the number of nodes in the specified range. 4. You should handle edge cases, such as when the tree is empty or when no nodes fall in the specified range. **Additional Information**: * Please include proper error handling or assertions to check range validity. * Commentary or documentation on the function logic is encouraged.","solution":"class Node: def __init__(self, val, color=\\"red\\"): self.val = val self.color = color self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = \\"black\\" self.root = self.TNULL def _inorder_helper(self, node, low, high, result_list): if node != self.TNULL: if low < node.val: self._inorder_helper(node.left, low, high, result_list) if low <= node.val <= high: result_list.append({\'val\': node.val, \'color\': node.color}) if high > node.val: self._inorder_helper(node.right, low, high, result_list) def range_search(self, low, high): Returns a list of nodes with values within the range [low, high]. Each element in the list is represented as a dictionary with \'val\' and \'color\'. if low > high: raise ValueError(\\"Low bound cannot be greater than high bound\\") result_list = [] self._inorder_helper(self.root, low, high, result_list) return result_list # Below, include implementations of the Red-Black Tree balancing and insertion methods # typically found in the RBTree class. For the sake of brevity, those are not fully implemented here. # Additional methods for the Red-Black Tree (like insertion, deletion, balancing etc.) # should go here."},{"question":"Implement a function `find_paths(root)` that retrieves all root-to-leaf paths in a binary tree, returning a list of strings, where each string represents a distinct path from the root to a leaf. The tree node structure and a helper method, `TreeNode`, are defined as below. # Context You are tasked with the development of a digital map application that shows all possible paths from a central hub (root) to various destinations (leaves). Each path should be presented as a directed list of waypoints. Your function will be integrated into this map application to generate these route presentations. Tree Node Definition ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Function Signature ```python def find_paths(root: TreeNode) -> list: ``` # Input * `root`: The root node of a binary tree, which could be `None`. # Output * A list of strings, where each string represents a path from the root to a leaf. # Example ```python # Example Binary Tree # 1 # / # 2 3 # # 5 # find_paths(TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3))) # should return [\'1->2->5\', \'1->3\'] ``` # Constraints * The number of nodes in the tree will be in the range [0, 100]. * The value of each node will be in the range [-100, 100]. # Performance Requirements * The solution must demonstrate optimal time complexity of O(N) and space complexity no greater than O(N). Ensure your function handles edge cases, such as empty trees and trees with varying depths. Avoid using external libraries and ensure your code adheres to the stipulated performance requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths(root: TreeNode) -> list: def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \\"->\\" dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \\"\\", paths) return paths"},{"question":"# Context You are tasked with building a search functionality for a medium-sized dataset representing user ID numbers in a system. Since the dataset can dynamically change and is not ordered, a simple search mechanism is required. # Question Implement the `linear_search` function to efficiently locate an element within an unordered list. The function should return the index of the first occurrence of the element, or -1 if the element is not found. # Function Signature ```python def linear_search(array: list, query: int) -> int: Parameters: array : List[int] - A list of integers where the search is performed. query : int - The integer value for which the search is to be performed. Returns: int - The index of the first occurrence of the given element in the array, or -1 if it is not found. # Your code here ``` # Input and Output Formats * **Input**: A list of integers `array` and an integer `query`. * **Output**: An integer indicating the index of the query in the list or -1 if not found. # Example ```python assert linear_search([4, 2, 3, 1, 7, 5], 3) == 2 assert linear_search([4, 2, 3, 1, 7, 5], 6) == -1 assert linear_search([], 3) == -1 assert linear_search([1, 9, 1, 3], 1) == 0 ``` # Constraints * The function should handle empty lists gracefully and return -1 if the list is empty. * Assume all elements in the array are integers. * The function should handle arrays with up to 10,000 integers efficiently. # Performance Requirements * The implementation should execute within a reasonable time for arrays up to 10,000 elements.","solution":"def linear_search(array: list, query: int) -> int: Returns the index of the first occurrence of the query in the array, or -1 if the query is not found. Parameters: array : List[int] - A list of integers where the search is performed. query : int - The integer value for which the search is to be performed. Returns: int - The index of the first occurrence of the given element in the array, or -1 if it is not found. for index, element in enumerate(array): if element == query: return index return -1"},{"question":"# Context: A segment tree is a powerful data structure that allows for efficient range query operations and point updates. You have been given a non-recursive implementation of a segment tree that supports these operations with any commutative function. # Task: Your task is to extend this segment tree to include a new operation: finding the range minimum within a specified range. # Function Implementation: You need to implement the following additional method in the `SegmentTree` class: Method: ```python def range_min(self, l, r): This function should return the minimum value in the range [l, r] (inclusive) in the segment tree. If the range is invalid (e.g., l > r or out of bounds), return None. Parameters: l (int): the starting index of the range. r (int): the ending index of the range. Returns: int/float: the minimum value within the range [l, r] (inclusive). pass ``` # Input: * `l` (int): Starting index of the range (0-based). * `r` (int): Ending index of the range (0-based). # Output: * The minimum value in the range `[l, r]` (inclusive). If the range is invalid, return `None`. # Constraints: 1. 0 <= l, r < size of the array 2. The array contains at least one element. 3. l <= r # Example: ```python mytree = SegmentTree([2, 4, 5, 1, 6], min) print(mytree.range_min(1, 3)) # Output: 1 print(mytree.range_min(2, 4)) # Output: 1 print(mytree.range_min(0, 0)) # Output: 2 print(mytree.range_min(4, 3)) # Output: None (invalid range) ``` # Expectations: - You should leverage the properties of the segment tree to ensure minimum values within the desired range are efficiently computed. - Ensure the function handles edge cases gracefully including invalid ranges.","solution":"class SegmentTree: def __init__(self, data, function=min): Initialize the Segment Tree with a data array and a function. self.n = len(data) self.function = function self.tree = [0] * (2 * self.n) # Build the tree # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Building the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def range_min(self, l, r): Find the minimum value in the range [l, r] (inclusive) in the segment tree. if l > r or l < 0 or r >= self.n: return None # Initialize result with a very large value result = float(\'inf\') # Convert the indexes to the respective leaf locations l += self.n r += self.n while l <= r: if l % 2 == 1: result = min(result, self.tree[l]) l += 1 if r % 2 == 0: result = min(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result"},{"question":"Problem Statement Design and implement the function `effective_anagram` to determine if two given strings are anagrams. Your solution should maintain a linear time complexity and constant space complexity. You need to handle edge cases, such as differing string lengths, appropriately. The strings may contain a mix of lower and uppercase letters but will not contain any special characters or whitespace. # Function Signature ```python def effective_anagram(s1: str, s2: str) -> bool: pass ``` # Input and Output * **Input** - `s1`: A string containing only alphabetic characters (0 <= len(s1) <= 100). - `s2`: A string containing only alphabetic characters (0 <= len(s2) <= 100). * **Output** - Return `True` if `s1` and `s2` are anagrams of each other, else return `False`. # Constraints * `s1` and `s2` may have different cases (i.e., \'A\' and \'a\' should be considered equivalent). # Example ```python print(effective_anagram(\\"apple\\", \\"Pleap\\")) # True print(effective_anagram(\\"apple\\", \\"cherry\\")) # False print(effective_anagram(\\"Listen\\", \\"Silent\\")) # True ``` # Performance Requirements * The implementation should ensure a time complexity of O(n) where n is the length of the strings. * The space complexity should be O(1) due to the fixed size usage for character counts. # Requirements * Convert the strings to a common case to ensure case-insensitive comparison. * Count character occurrences using a fixed-size list or dictionary. * Compare character counts. # Context This problem tests your ability to handle character frequency analysis and manage edge cases effectively, ensuring both efficiency and correctness in your solution.","solution":"def effective_anagram(s1: str, s2: str) -> bool: Determines if two given strings are anagrams. # If lengths are different, they cannot be anagrams if len(s1) != len(s2): return False # Convert both strings to lower case s1 = s1.lower() s2 = s2.lower() # Create a character count for s1 and s2 count = [0] * 26 # Increment the count based on the characters in s1 for char in s1: count[ord(char) - ord(\'a\')] += 1 # Decrement the count based on the characters in s2 for char in s2: count[ord(char) - ord(\'a\')] -= 1 # If any value in count is not zero, then s1 and s2 are not anagrams for cnt in count: if cnt != 0: return False return True"},{"question":"Problem Statement You have been tasked with implementing a Red-Black Tree to manage a dynamic dataset where new elements are frequently inserted and occasionally removed. Your goal is to implement a Red-Black Tree that maintains its properties after each insertion and deletion operation. Objective Implement a Red-Black Tree that can correctly handle insertion and deletion while adhering to the Red-Black Tree properties. Function Descriptions 1. **Insert Function:** - **Function Name:** `insert` - **Input:** - `value` (int): The value to be inserted into the Red-Black Tree. - **Output:** None (modifies the tree in-place) 2. **Delete Function:** - **Function Name:** `delete` - **Input:** - `value` (int): The value to be deleted from the Red-Black Tree. - **Output:** None (modifies the tree in-place) 3. **Inorder Traversal Function:** - **Function Name:** `inorder` - **Input:** None - **Output:** - List of dictionaries, each dictionary containing: - `\'val\'` (int): Node value - `\'color\'` (int): Node color (1 for red, 0 for black) Constraints 1. All node values will be unique integers. 2. Each insertion and deletion operation should maintain the Red-Black Tree properties. 3. The maximum number of nodes in the tree will not exceed (10^4). Performance Requirements Ensure the insertion and deletion operations execute in O(log n) time. Example Usage ```python # Initialize the Red-Black Tree rb_tree = RBTree() # Insert values into the tree values_to_insert = [20, 15, 25, 10, 5, 1, 30] for value in values_to_insert: rb_tree.insert(value) # Perform an inorder traversal of the tree inorder_result = rb_tree.inorder() print(inorder_result) # Expected to print nodes in increasing order with their colors # Delete a value from the tree rb_tree.delete(10) # Perform an inorder traversal again to verify deletion inorder_result = rb_tree.inorder() print(inorder_result) # Expected to print nodes in increasing order excluding the deleted node ``` Note Make sure your code handles the re-balancing of the tree with appropriate rotations and color adjustments as per Red-Black Tree properties. You are not required to implement the entire Red-Black Tree from scratch; you may use provided helper functions like rotation and fix-up methods if needed but ensure they conform to Red-Black Tree definitions.","solution":"class RedBlackNode: def __init__(self, value, color=1): self.value = value self.color = color # 1 for red, 0 for black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RedBlackNode(0, color=0) self.root = self.TNULL def insert(self, key): node = RedBlackNode(key) node.parent = None node.value = key node.left = self.TNULL node.right = self.TNULL node.color = 1 parent = None current = self.root while current != self.TNULL: parent = current if node.value < current.value: current = current.left else: current = current.right node.parent = parent if parent == None: self.root = node elif node.value < parent.value: parent.left = node else: parent.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def delete(self, key): self.delete_node_helper(self.root, key) def inorder(self): inorder_values = [] self.inorder_helper(self.root, inorder_values) return inorder_values def inorder_helper(self, node, inorder_values): if node != self.TNULL: self.inorder_helper(node.left, inorder_values) inorder_values.append({\\"val\\": node.value, \\"color\\": node.color}) self.inorder_helper(node.right, inorder_values) def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.value == key: z = node if node.value <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.fix_delete(x) def fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def minimum(self, node): while node.left != self.TNULL: node = node.left return node"},{"question":"# Scenario: Data Transmission Between Different Systems You\'re part of a team working on a distributed database system. Data bytes need to be converted between integer representations and vice versa, ensuring compatibility between systems potentially using different endianness formats for storage and communication. # Task Write a Python class `EndianConverter` that provides the methods to convert integers to bytes and bytes to integers in both big-endian and little-endian formats. Implement the following methods: 1. **`int_to_bytes_big_endian`**: Converts an integer to a byte array in big-endian format. 2. **`int_to_bytes_little_endian`**: Converts an integer to a byte array in little-endian format. 3. **`bytes_big_endian_to_int`**: Converts a byte array in big-endian format back to an integer. 4. **`bytes_little_endian_to_int`**: Converts a byte array in little-endian format back to an integer. The class should handle edge cases, be optimized for efficiency, and handle large integers properly. Input and Output Formats - **int_to_bytes_big_endian and int_to_bytes_little_endian**: - **Input**: A non-negative integer `num` (0 <= num <= 2^64 - 1). - **Output**: Byte array representing the integer in the specified endian format. - **bytes_big_endian_to_int and bytes_little_endian_to_int**: - **Input**: A byte array `bytestr`. - **Output**: An integer represented by the byte array in the specified endian format. Constraints - You can assume the byte arrays are correctly formed for the respective integer conversions. - Consider the performance of converting very large numbers. - Make sure you handle 0 correctly in all methods. Example ```python ec = EndianConverter() # Example big-endian conversion print(ec.int_to_bytes_big_endian(256)) # Output: b\'x01x00\' print(ec.bytes_big_endian_to_int(b\'x01x00\')) # Output: 256 # Example little-endian conversion print(ec.int_to_bytes_little_endian(256)) # Output: b\'x00x01\' print(ec.bytes_little_endian_to_int(b\'x00x01\')) # Output: 256 ```","solution":"class EndianConverter: @staticmethod def int_to_bytes_big_endian(num): Converts an integer to a byte array in big-endian format. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') @staticmethod def int_to_bytes_little_endian(num): Converts an integer to a byte array in little-endian format. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') @staticmethod def bytes_big_endian_to_int(bytestr): Converts a byte array in big-endian format back to an integer. return int.from_bytes(bytestr, byteorder=\'big\') @staticmethod def bytes_little_endian_to_int(bytestr): Converts a byte array in little-endian format back to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Magic Number Checker A number is said to be a \\"Magic Number\\" if by summing the digits of the number and recursively repeating this process, the final single digit resulting from the iteration is equal to 1. Example: - Number = 50113 => 5 + 0 + 1 + 1 + 3 = 10 => 1 + 0 = 1 (This is a Magic Number) - Number = 1234 => 1 + 2 + 3 + 4 = 10 => 1 + 0 = 1 (This is a Magic Number) - Number = 199 => 1 + 9 + 9 = 19 => 1 + 9 = 10 => 1 + 0 = 1 (This is a Magic Number) - Number = 111 => 1 + 1 + 1 = 3 (This is NOT a Magic Number) Task: Write a function `is_magic_number(n: int) -> bool` that takes an integer `n` as input and returns `True` if it is a Magic Number, otherwise `False`. Input: - An integer `n` (where `0 <= n <= 10^9`). Output: - A boolean value, `True` if the number is a Magic Number, otherwise `False`. Constraints: - The input will always be a non-negative integer. Examples: - `is_magic_number(50113)` should return `True` - `is_magic_number(1234)` should return `True` - `is_magic_number(199)` should return `True` - `is_magic_number(111)` should return `False` Note: The function should efficiently handle the summation and iteration process for very large values of `n`.","solution":"def is_magic_number(n: int) -> bool: Determines if a number is a Magic Number. A Magic Number reduces to 1 after repeated summation of its digits. :param n: Integer number to check. :return: True if n is a Magic Number, False otherwise. def sum_of_digits(num): Helper function to sum the digits of a number. return sum(int(digit) for digit in str(num)) while n >= 10: n = sum_of_digits(n) return n == 1"},{"question":"**Problem Statement: Bubble Sort Optimization** Bubble Sort is a straightforward sorting algorithm that iterates through the list, compares adjacent elements, and swaps them if they are in the wrong order. Despite its simplicity, Bubble Sort can be inefficient when used on large datasets with a time complexity of O(N^2). In this problem, you will implement an optimized version of Bubble Sort. # Requirements: 1. **Optimize the Bubble Sort algorithm** to handle large datasets more effectively. 2. **Early Termination:** The algorithm should stop early if no swaps were made in a pass, indicating the array is already sorted. # Function Signature: ```python def optimized_bubble_sort(arr: list) -> list: ``` # Input: * `arr`: A list of integers, where 0 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. # Output: * A list containing the sorted integers in ascending order. # Constraints: * Your solution should run in O(N^2) time complexity in the worst case scenario. * The algorithm should behave correctly for edge cases such as an empty list or a list with one element. # Example: ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([1]) == [1] assert optimized_bubble_sort([3, 3, 3]) == [3, 3, 3] ``` # Instructions: * Write efficient, clean, and well-commented code. * Consider edge cases and handle them appropriately. * Your function must only return the sorted list and not print anything.","solution":"def optimized_bubble_sort(arr: list) -> list: Optimized Bubble Sort algorithm with early termination if no swaps are made. Args: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers in ascending order. n = len(arr) for i in range(n): swapped = False # Flag to check if any swaps happened in this iteration for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: # Swap if elements are in the wrong order arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # If no elements were swapped in this pass, array is sorted if not swapped: break return arr"},{"question":"You are tasked with implementing an optimized sorting algorithm to sort a list of integers. Although Exchange Sort is simple and illustrative, it is inefficient for large datasets. Your task is to implement the following advanced sorting algorithm: **Merge Sort**. # Merge Sort Analysis * **Type**: Sorting Algorithm. * **Time Complexity**: O(n log n) for all cases (worst, average, and best). * **Space Complexity**: O(n), due to the auxiliary space required for merging. * **Principles**: Merge sort follows the divide-and-conquer paradigm. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves. # Requirements 1. Implement the `merge_sort` function. 2. The input will be a list of integers. 3. The function should return a new sorted list. 4. Avoid sorting the array in place. 5. Consider all edge cases to ensure your implementation is robust. # Function Signature ```python def merge_sort(arr: list) -> list: pass ``` # Example ```python input: [38, 27, 43, 3, 9, 82, 10] output: [3, 9, 10, 27, 38, 43, 82] input: [] output: [] input: [3] output: [3] input: [5, 4, 3, 2, 1] output: [1, 2, 3, 4, 5] ``` **Constraints:** * The input list will have at most `10^4` integers. * Each integer will be between `-10^6` and `10^6`, inclusive. # Scenario You\'re implementing a sorting feature for a large inventory system, where each item is assigned a random unique integer ID. Efficient sorting of these IDs is crucial for inventory management. Implementing `merge_sort` will ensure that even if the inventory grows large, the sorting function will still perform efficiently.","solution":"def merge_sort(arr: list) -> list: Perform a merge sort on the input list and return a new sorted list. if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"Coding Assessment Question # Context: In many real-world applications, efficiently calculating the power of a number is crucial, especially when dealing with large values and avoiding overflow by using modular arithmetic. To assess your understanding of efficient power calculation algorithms, your task is to implement a function based on binary exponentiation. # Task: Implement a function `optimized_power(a: int, n: int, mod: int = None) -> int` that computes the power of a number using binary exponentiation. Your function should support both iterative and recursive implementations. # Specifications: **Function Signature**: ```python def optimized_power(a: int, n: int, mod: int = None) -> int: pass ``` **Parameters**: - `a` (int): The base number. - `n` (int): The exponent. - `mod` (int, optional): The modulus value. Default is `None`. **Returns**: - `int`: The result of (a^n), and if `mod` is specified, returns (a^n % mod). **Constraints**: - ( -10^9 leq a leq 10^9 ) - ( 0 leq n leq 10^9 ) - ( 1 leq text{mod} leq 10^9 ) (if provided) # Requirements: 1. **Efficiency**: Ensure that the time complexity of your implementation is (O(log n)). 2. **Handling Edge Cases**: Appropriately handle edge cases such as (n = 0) and modulo operations. 3. **Iterative and Recursive Approach**: Provide both iterative and recursive versions within the same function. Use a flag to choose the implementation. # Example: ```python assert optimized_power(2, 10) == 1024 assert optimized_power(2, 10, 1000) == 24 assert optimized_power(3, 0) == 1 assert optimized_power(0, 0) == 1 ``` Your function must pass the above test cases. # Notes: - Test for large values of `n` to ensure your function performs efficiently. - Modular arithmetic should help in preventing overflow for large results.","solution":"def optimized_power(a: int, n: int, mod: int = None, use_recursive: bool = False) -> int: Computes the power of a number using binary exponentiation. Parameters: a (int): The base number. n (int): The exponent. mod (int, optional): The modulus value. Default is None. use_recursive (bool): Flag to use the recursive implementation. Default is False. Returns: int: The result of a^n, and if mod is specified, returns a^n % mod. # Helper recursive function for binary exponentiation def recursive_power(x, y, p): if y == 0: return 1 half = recursive_power(x, y // 2, p) half = (half * half) % p if p else half * half if y % 2 == 0: return half else: return (half * x) % p if p else half * x # Iterative approach for binary exponentiation def iterative_power(x, y, p): result = 1 x = x % p if p else x while y > 0: if y % 2 == 1: result = (result * x) % p if p else result * x y = y >> 1 x = (x * x) % p if p else x * x return result if use_recursive: # Use the recursive implementation return recursive_power(a, n, mod) else: # Use the iterative implementation return iterative_power(a, n, mod) # Examples print(optimized_power(2, 10)) # Output: 1024 print(optimized_power(2, 10, 1000)) # Output: 24 print(optimized_power(3, 0)) # Output: 1 print(optimized_power(0, 0)) # Output: 1 print(optimized_power(2, 10, 1000, True))# Output: 24 (recursive approach)"},{"question":"**Scenario**: As a spelling correction tool developer, you must frequently calculate the edit distance between a misspelled word and a candidate correction word. Your task is to create an efficient function to determine this distance, allowing the tool to suggest the closest possible corrections quickly. # Problem Statement Implement the function `edit_distance(word_a: str, word_b: str) -> int` that finds the minimum number of operations (insertions, deletions, or substitutions) required to transform one string (`word_a`) into another (`word_b`). # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ``` # Input * `word_a` (string): The original word. Constraints: 0 <= len(word_a) <= 500. * `word_b` (string): The target word to transform into. Constraints: 0 <= len(word_b) <= 500. # Output * Returns the minimum number of edit operations required. # Constraints 1. If both `word_a` and `word_b` are empty strings, the function should return 0. 2. The function should handle base cases efficiently, and performance should be prioritized for larger inputs within constraints. # Example ```python assert edit_distance(\\"FOOD\\", \\"MONEY\\") == 4 # FOOD -> MOOD -> MOND -> MONED -> MONEY assert edit_distance(\\"AB\\", \\"BCD\\") == 2 # AB -> CB -> BCD or AB -> ACD -> BCD assert edit_distance(\\"\\", \\"ABCDE\\") == 5 # Adding all characters of B to the empty string assert edit_distance(\\"ABCDE\\", \\"\\") == 5 # Deleting all characters from the string assert edit_distance(\\"APPLE\\", \\"APLE\\") == 1 # Removing \'P\' transforms APPLE into APLE ``` # Explanation and Edge Cases - If one string is empty and the other contains n characters, the edit distance is n (all insertions or deletions). - Editing operations include: * **Insertion**: Adding a character to one string. * **Deletion**: Removing a character from one string. * **Substitution**: Replacing a character in one string with another character from the other string. Your implementation should effectively utilize dynamic programming to solve this problem within the given constraints.","solution":"def edit_distance(word_a: str, word_b: str) -> int: m, n = len(word_a), len(word_b) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the table in bottom-up fashion for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to delete all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore last char and recur for remaining string elif word_a[i-1] == word_b[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Scenario As a software developer at an e-commerce company, you are tasked with implementing and optimizing a sorting algorithm that can quickly sort small arrays of transaction data. Given that the data to be sorted is typically small or nearly sorted, you need to implement the Insertion Sort algorithm. However, to ensure robustness and efficiency, your implementation should handle edge cases and minimize unnecessary computations wherever possible. # Task Implement the `optimized_insertion_sort` function. Your function should sort an array of integers in ascending order using an optimized version of insertion sort. The function should also be able to perform additional checks to handle edge cases. # Input * A list of integers, `arr`, where `1 <= len(arr) <= 1000`. * A boolean, `debug`, which toggles the printing of intermediate sorting steps. # Output * A sorted list of integers in ascending order. # Constraints * The array may contain duplicate elements. * The implementation should handle edge cases efficiently. * You can assume all integers are within the range -10^5 to 10^5. # Performance Requirements * The function should handle the worst-case scenario in a time complexity of O(n^2). * The space complexity should remain O(1) i.e., in-place sorting. # Example ```python Input: arr = [4, 3, 2, 10, 12, 1, 5, 6], debug = True Output: [1, 2, 3, 4, 5, 6, 10, 12] Input: arr = [1, 2, 3, 4], debug = False Output: [1, 2, 3, 4] ``` # Implementation Implement the function `optimized_insertion_sort` as specified: ```python def optimized_insertion_sort(arr, debug=False): # Your code here return arr ``` # Note Ensure your implementation handles the following scenarios gracefully: 1. Empty array. 2. Array with one element. 3. Arrays with duplicate elements. 4. Efficiently handle nearly sorted arrays.","solution":"def optimized_insertion_sort(arr, debug=False): Optimized Insertion Sort algorithm that sorts an array of integers in ascending order. Args: arr (list): List of integers to be sorted. debug (bool): If set to True, intermediate sorting steps will be printed. Returns: list: Sorted list of integers in ascending order. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 if debug: print(arr) # Print intermediate state for debugging purposes arr[j + 1] = key if debug: print(arr) # Print intermediate state for debugging purposes return arr"},{"question":"Context: Leah is working on a project that needs generating all possible permutations of a list of distinct integers. Her current solution handles small lists well but is inefficient for larger lists due to high memory use and long execution times. She needs help optimizing her approach while ensuring correctness. Task: Write a Python function `optimized_permute` that: 1. Generates all possible permutations of a given list of distinct integers. 2. Uses an iterative approach to minimize memory overhead. 3. Returns an iterator that yields permutations one at a time to avoid holding all permutations in memory simultaneously. Function Signature: ```python def optimized_permute(elements: List[int]) -> Iterator[List[int]]: pass ``` Input: - `elements`: a list of distinct integers, where (0 leq |elements| leq 9). Output: - An iterator yielding lists, each representing a permutation of the input. Example: ```python result = optimized_permute([1, 2, 3]) for perm in result: print(perm) # Output: # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ``` Constraints: - Your function must not return all permutations at once. - You should strive for minimal recursive depth and memory utilization. Additional Consideration: In your solution, consider edge cases such as an empty list, single-element list, and deeper recursion. Ensure optimal efficiency and thorough testing.","solution":"from typing import List, Iterator import itertools def optimized_permute(elements: List[int]) -> Iterator[List[int]]: Generates all possible permutations of a given list of distinct integers using an iterative approach to minimize memory overhead. Returns an iterator that yields permutations one at a time. return itertools.permutations(elements)"},{"question":"**Scenario**: You are developing a real-time analytics platform that updates sales data and provides quick access to the cumulative sales for various products. To achieve this efficiently, you decide to use a Fenwick Tree (Binary Indexed Tree). **Task**: Implement a class `FenwickTree` that supports the following operations: 1. `update(index, value)`: Update the sales data at a specific product index. 2. `sum(index)`: Return the cumulative sales from the start up to the specified product index. **Input and Output Formats**: * You will be given an initial list of sales data representing sales of different products. * You need to implement methods to update the sales data and retrieve cumulative sales. **Constraints**: * All sales data values will be non-negative integers. * The list length will not exceed 10^5. * Multiple updates and sum queries will be performed. ***Example***: ```python # Initial sales data: [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] # Updates: update(3, 10), update(5, 10) # Queries: sum(3), sum(6) # Expected Output for the queries: # sum(3) -> 14 (2+1+1+10) # sum(6) -> 25 (2+1+1+10+2+3+6) class FenwickTree: def __init__(self, data): Initializes the Fenwick Tree with the given sales data. self.n = len(data) self.bit_tree = [0] * (self.n + 1) for i in range(self.n): self.update(i, data[i]) def update(self, index, value): Updates the sales data at the specified index. :param index: Index of the element to update. :param value: New value to be added at the specified index. index += 1 while index <= self.n: self.bit_tree[index] += value index += index & -index def sum(self, index): Returns the cumulative sales from the start up to the specified product index. :param index: Index up to which the sum is to be calculated. :return: Cumulative sum of sales data up to the specified index. index += 1 result = 0 while index > 0: result += self.bit_tree[index] index -= index & -index return result # Example of usage: # sales_data = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] # ft = FenwickTree(sales_data) # ft.update(3, 10) # print(ft.sum(3)) # Output should be 14 # print(ft.sum(6)) # Output should be 29 ``` Implement the `FenwickTree` class with the described methods considering the above constraints and example.","solution":"class FenwickTree: def __init__(self, data): Initializes the Fenwick Tree with the given sales data. self.n = len(data) self.bit_tree = [0] * (self.n + 1) self.original_data = data.copy() for i in range(self.n): self._update_tree(i, data[i]) def _update_tree(self, index, value): Internal method to update the BIT without modifying the original data. :param index: Index of the element to update. :param value: Value to be added at the specified index. index += 1 while index <= self.n: self.bit_tree[index] += value index += index & -index def update(self, index, value): Updates the sales data at the specified index by adding the value. :param index: Index of the element to update. :param value: New value to be added at the specified index. diff = value - self.original_data[index] self.original_data[index] = value self._update_tree(index, diff) def sum(self, index): Returns the cumulative sales from the start up to the specified product index. :param index: Index up to which the sum is to be calculated. :return: Cumulative sum of sales data up to the specified index. index += 1 result = 0 while index > 0: result += self.bit_tree[index] index -= index & -index return result"},{"question":"You are tasked with designing an LRU (Least Recently Used) Cache using a Doubly Linked List and a HashMap. The LRU Cache should support the following operations: - `get(key)`: Return the value of the key if it exists in the cache, otherwise return -1. - `put(key, value)`: Update the value of the key if it exists in the cache. If the key does not exist, add the key-value pair to the cache. If the cache exceeds its capacity, it should remove the least recently used item before inserting the new item. # Input and Output Formats Input - The capacity of the cache (integer). - Sequence of operations `[(\\"put\\", key, value), (\\"get\\", key)]`. Output - For each `get` operation, return the corresponding value. - For `put` operations, no output is expected. # Constraints - All keys and values are integers. - The number of operations won\'t exceed 10,000. - The capacity is a positive integer. # Performance Requirements - Both operations `get` and `put` must be performed in O(1) average time complexity. # Example ```python # Example 1 operations = [(\\"put\\", 1, 1), (\\"put\\", 2, 2), (\\"get\\", 1), (\\"put\\", 3, 3), (\\"get\\", 2), (\\"put\\", 4, 4), (\\"get\\", 1), (\\"get\\", 3), (\\"get\\", 4)] capacity = 2 # Expected Output # [-1, 1, -1, 3, 4] ``` # Function Signature ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU Cache with given capacity. pass def get(self, key: int) -> int: Retrieve the value of the key if cache contains the key, otherwise return -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if exists. Otherwise, add the key-value pair to the cache. If the cache reaches its capacity, remove the least recently used item before adding the new item. pass # Example Usage cache = LRUCache(2) print(cache.put(1, 1)) # cache: {1=1} print(cache.put(2, 2)) # cache: {1=1, 2=2} print(cache.get(1)) # returns 1 print(cache.put(3, 3)) # cache: {3=3, 1=1}, evicts key 2 print(cache.get(2)) # returns -1 (not found) print(cache.put(4, 4)) # cache: {4=4, 3=3}, evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ```","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node): prev_head = self.head.next self.head.next = node node.prev = self.head node.next = prev_head prev_head.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key]"},{"question":"# Question You have been provided with a directed graph implementation that includes a method to determine whether the graph is strongly connected. A strongly connected graph is one where every node is reachable from every other node. Your task is to extend this implementation. Specifically: 1. Implement a method `find_scc()` in the `Graph` class that returns the list of all the strongly connected components (SCCs) in the graph. 2. Each SCC should be represented as a list of vertices. 3. Return the result as a list of such lists. # Input/Output * **Input**: * A number of vertices `V` (an integer). * A list of edges, each represented as a tuple of the form `(source, target)`. * **Output**: * A list of SCCs, where each SCC is itself a list of vertices. # Constraints * 1 <= V <= 1000 (number of vertices) * 0 <= number of edges <= 5000 # Example Graph: Vertices: 5 Edges: [(1, 0), (0, 2), (2, 1), (0, 3), (3, 4)] Expected Output: ```python [[4], [3], [0, 2, 1]] ``` # Requirements 1. Use the existing `Graph` structure and add the necessary methods. 2. Do not modify existing methods unless necessary for your solution. 3. Ensure proper handling of edge cases as discussed in the analysis section. 4. Ensure that your code runs within reasonable time limits for the given constraints. # Additional Hints * Consider using Kosaraju\'s algorithm or Tarjan\'s algorithm for finding SCCs. * Make sure to efficiently reverse the graph as required by Kosaraju\'s algorithm.","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = {i: [] for i in range(vertices)} def add_edge(self, src, dest): self.graph[src].append(dest) def _dfs(self, v, visited, stack=None): visited[v] = True for i in self.graph[v]: if not visited[i]: self._dfs(i, visited, stack) if stack is not None: stack.append(v) def _reverse_graph(self): reversed_graph = Graph(self.vertices) for src in self.graph: for dest in self.graph[src]: reversed_graph.add_edge(dest, src) return reversed_graph def _fill_order(self, v, visited, stack): visited[v] = True for i in self.graph[v]: if not visited[i]: self._fill_order(i, visited, stack) stack.append(v) def _get_transpose(self): g = Graph(self.vertices) for i in self.graph: for j in self.graph[i]: g.add_edge(j, i) return g def find_scc(self): # Step 1: Fill vertices in stack according to their finishing times stack = [] visited = [False] * self.vertices for i in range(self.vertices): if not visited[i]: self._dfs(i, visited, stack) # Step 2: Create a reversed graph reversed_graph = self._reverse_graph() # Step 3: Process all vertices in the order defined by Stack visited = [False] * self.vertices scc_list = [] while stack: i = stack.pop() if not visited[i]: scc_stack = [] reversed_graph._dfs(i, visited, scc_stack) scc_list.append(scc_stack) return scc_list"},{"question":"# Polynomial and Monomial Operations **Objective**: Implement an advanced function demonstrating your understanding of the provided Monomial and Polynomial data structures. **Task**: Implement a function `differential` that computes the formal differentiation of the given Polynomial and returns a new Polynomial that represents its derivative with respect to the specified variable. **Function Signature**: ```python def differential(poly: Polynomial, variable: int) -> Polynomial: ``` # Input: - `poly`: An object of type `Polynomial`. - `variable`: An integer representing the variable with respect to which the derivative should be taken. # Output: - A `Polynomial` object representing the derivative of the input polynomial with respect to the specified variable. # Constraints: - The input Polynomial object `poly` is well-formed and only contains Monomials with integer exponents. - The variable specified by `variable` exists in the polynomial. # Performance: - The implementation should correctly handle polynomials with multiple variables and terms, ensuring no significant performance bottlenecks for typical sizes expected in standard algebraic manipulations. # Example Scenario: Consider the polynomial `P(x, y) = 3x^2y + 2xy^2 + 5`: - Differentiation with respect to `x`: `dP/dx = 6xy + 2y^2` - Differentiation with respect to `y`: `dP/dy = 3x^2 + 4xy` # Example Inputs and Outputs ```python # Define input polynomial P(x, y) as 3x^2*y + 2*x*y^2 + 5 mon1 = Monomial({1: 2, 2: 1}, 3) mon2 = Monomial({1: 1, 2: 2}, 2) mon3 = Monomial({}, 5) poly = Polynomial([mon1, mon2, mon3]) # Differentiate with respect to variable x (i.e., variable 1) derivative_x = differential(poly, 1) print(derivative_x) # Expected output: Polynomial representing 6*x*y + 2*y^2 # Differentiate with respect to variable y (i.e., variable 2) derivative_y = differential(poly, 2) print(derivative_y) # Expected output: Polynomial representing 3*x^2 + 4*x*y ``` # Note: - Ensure that all edge cases, such as zero coefficients and empty polynomial terms, are handled correctly. - The output Polynomial should be cleaned by removing any terms with zero coefficients.","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # Dictionary with variables as keys and their exponents as values self.coefficient = coefficient def differentiate(self, variable): if variable not in self.exponents: return Monomial({}, 0) # If the variable is not present, derivative is zero new_exponents = self.exponents.copy() new_coeff = self.coefficient * new_exponents[variable] if new_exponents[variable] == 1: del new_exponents[variable] else: new_exponents[variable] -= 1 return Monomial(new_exponents, new_coeff) def __eq__(self, other): return self.exponents == other.exponents and self.coefficient == other.coefficient def __repr__(self): return f\'Monomial(exponents={self.exponents}, coefficient={self.coefficient})\' class Polynomial: def __init__(self, monomials): self.monomials = monomials def differentiate(self, variable): differentiated_monomials = [mon.differentiate(variable) for mon in self.monomials] # Clean the result by removing monomials with zero coefficient differentiated_monomials = [mon for mon in differentiated_monomials if mon.coefficient != 0] return Polynomial(differentiated_monomials) def __eq__(self, other): if len(self.monomials) != len(other.monomials): return False return all(m1 == m2 for m1, m2 in zip(self.monomials, other.monomials)) def __repr__(self): return f\'Polynomial(monomials={self.monomials})\' def differential(poly: Polynomial, variable: int) -> Polynomial: return poly.differentiate(variable)"},{"question":"# Scenario You are working on a software that interfaces with hardware components. The hardware communicates using a 32-bit status register where each bit represents a different flag. As a part of your tasks, you need to provide several utility functions that can manipulate this status register efficiently using bit operations. # Task Write a Python class `StatusRegister` with the following methods: 1. **`get_bit`**: Returns whether a specific bit in the status register is set. 2. **`set_bit`**: Sets a specific bit in the status register. 3. **`clear_bit`**: Clears a specific bit in the status register. 4. **`update_bit`**: Updates a specific bit in the status register to a given value. # Class Definition ```python class StatusRegister: def __init__(self, num): self.num = num def get_bit(self, i): # Implement the function to return whether the i-th bit is set (1) or not (0). pass def set_bit(self, i): # Implement the function to set the i-th bit. pass def clear_bit(self, i): # Implement the function to clear the i-th bit. pass def update_bit(self, i, bit): # Implement the function to update the i-th bit to the value of bit. pass ``` # Input and Output 1. The class constructor takes a single integer `num`, initializing the status register. 2. The methods take the following parameters: * `get_bit(i: int) -> bool`: Returns `True` if the bit is set, otherwise `False`. * `set_bit(i: int) -> None`: Sets the bit at position `i`. * `clear_bit(i: int) -> None`: Clears the bit at position `i`. * `update_bit(i: int, bit: bool) -> None`: Sets the bit at position `i` to the specified `bit` value (`True` for 1, `False` for 0). # Constraints * You can assume that the values for `i` will be in the range 0 to 31 (inclusive). * You can assume the input `num` is a non-negative integer that fits into a 32-bit unsigned integer. # Performance Requirements * Each method should run in constant time O(1). # Example ```python # Example usage: sr = StatusRegister(0b1010) # Initialize the status register with binary 1010 (decimal 10) print(sr.get_bit(1)) # Output: True (2nd bit is 1) sr.set_bit(3) print(bin(sr.num)) # Output: 0b1110 (binary 1110, decimal 14) sr.clear_bit(1) print(bin(sr.num)) # Output: 0b1100 (binary 1100, decimal 12) sr.update_bit(2, 1) print(bin(sr.num)) # Output: 0b1100 (binary 1100, decimal 12) sr.update_bit(2, 0) print(bin(sr.num)) # Output: 0b1000 (binary 1000, decimal 8) ```","solution":"class StatusRegister: def __init__(self, num): self.num = num def get_bit(self, i): Returns whether the i-th bit is set (1) or not (0). return (self.num & (1 << i)) != 0 def set_bit(self, i): Sets the i-th bit. self.num |= 1 << i def clear_bit(self, i): Clears the i-th bit. self.num &= ~(1 << i) def update_bit(self, i, bit): Updates the i-th bit to the value of bit. mask = ~(1 << i) self.num = (self.num & mask) | ((bit & 1) << i)"},{"question":"# Scenario You have been tasked with designing a new communication system that compacts messages by encoding letters into numbers. Each letter corresponds to a number from 1 to 26 (\'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26). However, the messages can only be sent as sequences of digits, and they must be decoded back to letters upon receipt. Your job is to write a function to determine the number of different ways a given encoded message (comprised solely of digits) can be decoded. # Problem Statement You need to implement the function `num_decodings` to determine how many different ways a given encoded message can be decoded. Function Signature ```python def num_decodings(enc_mes: str) -> int: pass ``` Input - `enc_mes` (a string of length `n` where `1 <= n <= 10^4`) only contains digits (\'0\' - \'9\'). Output - Return an integer representing the total number of ways to decode the message. Constraints - The input string will not start with the digit \'0\'. - \'0\' can only be used as part of \'10\' or \'20\'. \'30\' to \'90\' are invalid. - Valid two-digit combinations are from \'10\' to \'26\'. # Examples 1. Input: `enc_mes = \\"12\\"` - Output: 2 - Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. Input: `enc_mes = \\"226\\"` - Output: 3 - Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. Input: `enc_mes = \\"06\\"` - Output: 0 - Explanation: Messages can\'t start with \\"0\\". Hence, no valid decoding exists. # Considerations - Ensure the solution handles edge cases, such as invalid two-digit numbers. - Pay attention to performance requirements, as the input length may go up to 10,000 characters.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \\"0\\": return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if enc_mes[0] != \\"0\\" else 0 for i in range(2, n + 1): if enc_mes[i - 1] != \\"0\\": dp[i] += dp[i - 1] if enc_mes[i - 2] == \\"1\\" or (enc_mes[i - 2] == \\"2\\" and enc_mes[i - 1] <= \\"6\\"): dp[i] += dp[i - 2] return dp[n]"},{"question":"# Question: Implement an optimized function to check if a given stream is 1-sparse and return the unique number if true. The function should handle streams with large numbers efficiently and minimize bit-wise operations. # Requirements: 1. **Function Signature**: ```python def optimized_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: # Your code here ``` 2. **Input Format**: - A list of tuples representing the stream. Each tuple contains an integer and a sign as \'+\' or \'-\'. - Example: `[(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')]` 3. **Output Format**: - Returns the unique integer if the stream is 1-sparse, otherwise returns `None`. 4. **Constraints**: - The stream can contain large numbers (> 32 bits). - The stream size <= 10^5. - Assume each tuple is formatted correctly with valid integers and signs. # Example: ```python # Example Input 1 stream = [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] # Expected Output: 4 # Example Input 2 stream = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] # Expected Output: 2 # Example Input 3 stream = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] # Expected Output: None ``` # Performance Requirements: - The solution should aim to maintain (O(n cdot k)) time complexity and (O(k)) space complexity where (k) is the bit length of the largest integer in the stream.","solution":"from typing import List, Tuple, Optional def optimized_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: total_sum = 0 sum_squared = 0 for value, sign in stream: if sign == \'+\': total_sum += value sum_squared += value * value elif sign == \'-\': total_sum -= value sum_squared -= value * value if total_sum == 0: if sum_squared == 0: return None # All items have pairs and canceled out else: return None # The stream is not 1-sparse else: # check if we can determine a unique number x = sum_squared // total_sum if sum_squared == x * total_sum: return x else: return None"},{"question":"# Markov Chain Transition Probability Checker Problem Statement You are working on a Markov Chain system for a simulation project. Your task is to write a function that checks whether a given Markov Chain is valid. A valid Markov Chain must meet the following criteria: 1. Each state must have at least one outgoing transition. 2. The sum of the probabilities for the outgoing transitions of each state must be exactly 1.0. Function Signature ```python def is_valid_markov_chain(chain: dict) -> bool: Determines whether the given Markov chain is valid based on the criteria mentioned. Parameters: - chain: A dictionary representing the Markov Chain. Returns: - bool: True if the chain is valid, otherwise False. ``` Input * `chain`: A dictionary where each key is a state and the corresponding value is another dictionary representing the transition probabilities to other states. For instance: ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` Output * The function should return `True` if the Markov Chain is valid, otherwise `False`. Constraints * The total number of states will not exceed 10^3. * Each state will have between 1 and 1000 outgoing transitions. * Transition probabilities will be floating-point numbers between 0 and 1 inclusive. * Transition probabilities will total exactly 1.0 within a tolerance of `1e-9`. Example ```python my_chain_valid = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } my_chain_invalid = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.4} # Sum > 1.0 } print(is_valid_markov_chain(my_chain_valid)) # Returns: True print(is_valid_markov_chain(my_chain_invalid)) # Returns: False ``` Performance Requirements * The function should efficiently handle the constraints in terms of number of states and transitions.","solution":"def is_valid_markov_chain(chain): Determines whether the given Markov chain is valid based on the criteria mentioned. Parameters: - chain: A dictionary representing the Markov Chain. Returns: - bool: True if the chain is valid, otherwise False. # Iterate over each state in the chain for state, transitions in chain.items(): # Check if there is at least one outgoing transition if not transitions: return False # Sum the probabilities of the outgoing transitions total_probability = sum(transitions.values()) # Check if the sum of probabilities is approximately equal to 1.0 if not (abs(total_probability - 1.0) < 1e-9): return False # If all states meet the criteria, return True return True"},{"question":"# Problem: Advanced Number Operations You are tasked with implementing a series of functions that perform advanced number operations. These functions will require you to handle integer properties efficiently. Your implementation must account for edge cases carefully and optimize performance as much as possible. **1. Function: `gcd_bitwise`** Implement the function `gcd_bitwise(a: int, b: int) -> int` that calculates the greatest common divisor (GCD) of two non-negative integers using bitwise operations. **Input:** - Two non-negative integers `a` and `b`. **Output:** - The greatest common divisor of `a` and `b`. **Constraints:** - `0 <= a, b <= 10^9` **2. Function: `lcm_with_gcd`** Implement the function `lcm_with_gcd(a: int, b: int) -> int` that calculates the least common multiple (LCM) of two non-negative integers utilizing the `gcd_bitwise` function. **Input:** - Two non-negative integers `a` and `b`. **Output:** - The least common multiple of `a` and `b`. **Constraints:** - `0 <= a, b <= 10^9` **3. Function: `count_trailing_zeros`** Implement the function `count_trailing_zeros(x: int) -> int` to count the number of trailing zero bits in the binary representation of a positive integer `x`. **Input:** - A positive integer `x`. **Output:** - The number of trailing zero bits in the binary representation of `x`. **Constraints:** - `1 <= x <= 10^9` # Examples ```python # gcd_bitwise print(gcd_bitwise(48, 18)) # Output: 6 # lcm_with_gcd print(lcm_with_gcd(12, 15)) # Output: 60 # count_trailing_zeros print(count_trailing_zeros(40)) # Output: 3 print(count_trailing_zeros(34)) # Output: 1 ``` # Guidelines - Your solution should handle all edge cases efficiently. - You must implement error handling for invalid inputs where specified. - Optimize the execution and space complexity as much as possible. - Write clear and concise code with appropriate comments for clarity.","solution":"def gcd_bitwise(a: int, b: int) -> int: Calculates the greatest common divisor (GCD) of two non-negative integers using bitwise operations. if a == 0: return b if b == 0: return a # Finding common factors of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm_with_gcd(a: int, b: int) -> int: Calculates the least common multiple (LCM) of two non-negative integers using the gcd_bitwise function. if a == 0 or b == 0: return 0 return (a // gcd_bitwise(a, b)) * b def count_trailing_zeros(x: int) -> int: Counts the number of trailing zero bits in the binary representation of a positive integer x. count = 0 while x > 0 and (x & 1) == 0: count += 1 x >>= 1 return count"},{"question":"# Question Title: Wiggle Sort Implementation # Description: Given an unsorted array `nums`, your task is to reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]....`. This pattern of alternating peaks and valleys must be maintained throughout the array. Your implementation should perform this rearrangement efficiently. # Function Signature: ```python def wiggle_sort(nums: List[int]) -> None: ``` # Input: - `nums`: A list of integers where `1 <= len(nums) <= 10^4`, and `-10^9 <= nums[i] <= 10^9`. # Output: - The function rearranges the array `nums` in-place to satisfy the wiggle condition. The function does not return anything. # Constraints: - You should perform this operation in O(n) time complexity and O(1) space complexity. # Scenario: Consider an e-commerce site that provides users with product recommendations in a particularly aesthetic pattern where alternate recommendations are higher or lower rated. Your algorithm should assist in rearranging ratings in such a way that results in visually appealing patterns as described. # Example: ```python # Example 1 nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) # Output: nums should be properly wiggled, e.g., [3, 5, 1, 6, 2, 4] # Edge Case 1 nums = [1] wiggle_sort(nums) # Output: nums should remain [1] # Edge Case 2 nums = [2, 1] wiggle_sort(nums) # Output: nums should be properly wiggled, e.g., [1, 2] ``` # Note: - There are multiple valid solutions for the wiggle sorted order. Any order that meets the requirement `nums[0] < nums[1] > nums[2] < nums[3]....` is acceptable. - Ensure your solution strictly adheres to the O(n) time and O(1) space complexity constraints.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Rearranges the elements of `nums` in-place such that nums[0] < nums[1] > nums[2] < nums[3].... for i in range(len(nums) - 1): if i % 2 == 0 and nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] elif i % 2 == 1 and nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Question Problem Statement You are given an absolute path for a file (Unix-style), you need to simplify this path to its canonical form. In Unix-style file systems, a period `.` refers to the current directory, a double period `..` refers to the directory up a level, and multiple consecutive slashes are treated as a single slash. Any extra periods or double periods that move above the root are ignored. Function Signature ```python def simplify_path(path: str) -> str: ``` Input - `path` (str): The absolute path to simplify. Constraints: - The length of `path` will be in the range [1, 3000]. - `path` will consist of English letters, digits, period `.`, slash `/`, and underscores `_`. Output - `str`: The simplified canonical path. Examples ```python simplify_path(\\"/home/\\") # Output: \\"/home\\" simplify_path(\\"/a/./b/../../c/\\") # Output: \\"/c\\" simplify_path(\\"/../\\") # Output: \\"/\\" simplify_path(\\"/home//foo/\\") # Output: \\"/home/foo\\" ``` Guidelines 1. The function should return the canonical path by resolving `..`, `.` and multiple slashes. 2. Pay attention to edge cases like paths only consisting of slashes or `..`. 3. The solution should be optimal with a linear time complexity given the constraints.","solution":"def simplify_path(path: str) -> str: Returns the simplified canonical path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Password Strength Checker **Objective**: Write a function that takes in the length of a password and the password itself and returns the minimum number of characters required to make the password \\"strong\\". A strong password is defined by the following criteria: 1. At least 6 characters in length. 2. Contains at least one digit. 3. Contains at least one lowercase English character. 4. Contains at least one uppercase English character. 5. Contains at least one special character from the set: `!@#%^&*()-+`. Input Format 1. An integer, n, denoting the length of the password. 2. A string of n characters, the password. Output Format Return an integer representing the minimum number of characters that must be added to make the password strong. Constraints - `0 <= n <= 100` - The password consists solely of lowercase/uppercase English alphabets, digits, and special characters. Example **Sample Input 1**: ```plaintext 3 Ab1 ``` **Sample Output 1**: ```plaintext 3 ``` **Sample Explanation 1**: She can make the password strong by adding the characters, for example, `hk`, turning the password into `Ab1hk` which is strong. 2 characters aren\'t enough since the length must be at least 6. **Sample Input 2**: ```plaintext 11 #Algorithms ``` **Sample Output 2**: ```plaintext 1 ``` **Sample Explanation 2**: The password isn\'t strong, but she can make it strong by adding a single digit. Function Signature ```python def strong_password(n, password): # Your code here ```","solution":"def strong_password(n, password): required_length = 6 needed_types = 4 # digit, lowercase, uppercase, special character added_characters = 0 if any(char.isdigit() for char in password): needed_types -= 1 if any(char.islower() for char in password): needed_types -= 1 if any(char.isupper() for char in password): needed_types -= 1 if any(char in \\"!@#%^&*()-+\\" for char in password): needed_types -= 1 min_length_needed = max(0, required_length - n) return max(min_length_needed, needed_types)"},{"question":"Problem Statement As a software developer, you are tasked with enhancing the performance of an existing Shell Sort implementation. The current implementation uses a basic gap sequence, which might not be optimal. Your job is to improve this implementation by selecting a better gap sequence and ensuring the algorithm works efficiently for large datasets. # Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, where (0 leq text{len(arr)} leq 10^6). # Output * A list of integers that are sorted in ascending order. # Constraints 1. You must use the Shell Sort algorithm. 2. You need to optimize the time complexity by using a more efficient gap sequence. # Performance Requirements * Aim to achieve an average-case time complexity better than O(n^2). * The space complexity should remain O(1). # Example Input ```python arr = [23, 42, 4, 16, 8, 15] ``` Output ```python [4, 8, 15, 16, 23, 42] ``` # Notes * Consider different gap sequences, such as Hibbard or Knuth sequences, and choose one that optimizes performance. * Do not use built-in sorting functions (e.g., `sorted()` in Python) for the main sorting logic. Implement the `optimized_shell_sort` function that meets the above requirements.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using Shell Sort algorithm with a more efficient gap sequence. # Using Knuth\'s sequence: h = 3*h + 1 n = len(arr) gap = 1 while gap < n / 3: gap = 3 * gap + 1 # Perform shell sort using the computed gap sequence while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"Context You are developing a file management tool for a multi-platform application. As part of this tool, you need to ensure that paths provided by users are standardized to their absolute forms. Task Implement a function `standardize_paths(paths)` that takes a list of file paths and returns a list of the paths converted to their absolute paths, expanding any user-specific components. Function Signature ```python def standardize_paths(paths: List[str]) -> List[str]: pass ``` Input - **paths**: A list of strings containing file paths. (1 ≤ len(paths) ≤ 10^4) Output - Return a list of absolute paths corresponding to input paths. Constraints - Each path entered is a valid path. - Paths can include user-specific components like `~`. - The function should run efficiently even for large lists. Example ```python paths = [\\"~/Documents\\", \\"/usr/local/bin\\", \\"relative/path/to/file\\"] # Assume the home directory is \\"/home/user\\" # The corresponding absolute paths would be: # [\\"/home/user/Documents\\", \\"/usr/local/bin\\", \\"/current/working/directory/relative/path/to/file\\"] assert standardize_paths(paths) == [\\"/home/user/Documents\\", \\"/usr/local/bin\\", \\"/current/working/directory/relative/path/to/file\\"] ``` Performance Requirements - Ensure the function can handle up to 10,000 paths efficiently. Develop your implementation to accurately handle the above scenarios, taking into consideration various edge cases and ensuring cross-platform compatibility.","solution":"import os from typing import List def standardize_paths(paths: List[str]) -> List[str]: Convert a list of file paths to their absolute forms. Args: - paths (List[str]): A list of string file paths. Returns: - List[str]: A list of absolute paths. return [os.path.abspath(os.path.expanduser(path)) for path in paths]"},{"question":"# Binary Search Implementation with First and Last Occurrence Context: You are given a sorted list of integers. The list is sorted in non-decreasing order (i.e., it may contain duplicates and the values are sorted in increasing order). Your task is to implement two functions to find the first and last occurrences of a given integer in this list. The first function, `first_occurrence`, will return the index of the first occurrence of the integer. The second function, `last_occurrence`, will return the index of the last occurrence of the integer. If the integer is not found in the list, both functions should return `-1`. Function Signatures: ```python def first_occurrence(array: List[int], query: int) -> int: # Your code here def last_occurrence(array: List[int], query: int) -> int: # Your code here ``` Input: - `array`: A list of integers sorted in non-decreasing order (e.g., [1,2,2,2,3,4,5]). - `query`: An integer value to search for within the array. Output: - An integer indicating the index of the first occurrence of the given element in the array for the `first_occurrence` function. - An integer indicating the index of the last occurrence of the given element in the array for the `last_occurrence` function. - Return `-1` if the element is not found. Constraints: - The length of the array will not exceed (10^6). - Elements in the array and the query value will fit within the standard integer range. Example: ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 assert first_occurrence(array, query) == 1 # First occurrence of 2 is at index 1 assert last_occurrence(array, query) == 3 # Last occurrence of 2 is at index 3 array = [1, 1, 2, 3, 3, 3, 5, 5, 5] query = 5 assert first_occurrence(array, query) == 6 # First occurrence of 5 is at index 6 assert last_occurrence(array, query) == 8 # Last occurrence of 5 is at index 8 array = [2, 4, 6, 8] query = 5 assert first_occurrence(array, query) == -1 # 5 is not in the array assert last_occurrence(array, query) == -1 # 5 is not in the array ``` Notes: - Make sure to handle edge cases such as an empty array, a single-element array, and arrays where the queried number does not exist.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of `query` in the `array`. If `query` is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result def last_occurrence(array, query): Returns the index of the last occurrence of `query` in the `array`. If `query` is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Search in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Optimized Cosine Similarity for Large Vectors Context In many machine learning applications, such as document similarity in NLP or user behavior analysis in recommendation systems, computing the cosine similarity between large vectors efficiently is crucial. Your task is to implement an optimized version of the cosine similarity algorithm that leverages vectorized operations to handle large vectors efficiently. Problem Statement Given two 1D lists `vec1` and `vec2` of the same length, implement an optimized function `optimized_cosine_similarity(vec1, vec2)` that returns their cosine similarity. Utilize NumPy for efficient computation. Constraints - Both `vec1` and `vec2` will have the same length and contain at least one element. - The elements of `vec1` and `vec2` will be floating-point numbers. Input - `vec1`: A list of floating-point numbers. - `vec2`: A list of floating-point numbers. Output - A single floating-point number representing the cosine similarity between `vec1` and `vec2`. Example ```python optimized_cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 ``` Requirements - Use NumPy to optimize the computation. - Ensure the function handles large vectors efficiently. - Handle edge cases where vectors may contain very large or very small numbers.","solution":"import numpy as np def optimized_cosine_similarity(vec1, vec2): Computes the cosine similarity between two vectors using NumPy. Arguments: vec1 -- a list of floating-point numbers vec2 -- a list of floating-point numbers Returns: cosine_similarity -- a single floating-point number representing the cosine similarity between vec1 and vec2 # Convert lists to numpy arrays vec1 = np.array(vec1) vec2 = np.array(vec2) # Compute the dot product of the vectors dot_product = np.dot(vec1, vec2) # Compute the norms (magnitudes) of the vectors norm_vec1 = np.linalg.norm(vec1) norm_vec2 = np.linalg.norm(vec2) # Compute the cosine similarity cosine_similarity = dot_product / (norm_vec1 * norm_vec2) return cosine_similarity"},{"question":"# Question: Gnome Sort Analysis and Implementation You work at a company that processes various datasets that need sorting. One of your fellow developers implemented a sorting algorithm named \\"Gnome Sort.\\" However, it seems to have some performance issues with larger datasets, and your task is to analyze it and propose an optimized solution. **Task:** 1. Write a function `gnome_sort(arr)` that sorts an array of integers in non-decreasing order using the Gnome sort algorithm. 2. After implementing `gnome_sort`, analyze its performance in terms of time and space complexity. 3. Implement a more optimized sorting algorithm `optimized_sort(arr)` and achieve at least O(n log n) average time complexity. You may use sorting algorithms like merge sort or quicksort. 4. Ensure your optimized algorithm is properly documented and clearly explained. **Requirements:** 1. Provide a detailed analysis for both Gnome sort and the optimized version addressing: * Time complexity. * Space complexity. * Any provided edge cases. * Possible performance bottlenecks. 2. Write unit tests to verify the correctness of your functions considering edge cases like: * An already sorted array. * An array with duplicate elements. * An array sorted in reverse order. * An array with a single element. **Input Format:** * `arr`: A list of integers where 1 <= `len(arr)` <= 10^5 and -10^9 <= `arr[i]` <= 10^9. **Output Format:** * Return the sorted list of integers from the functions `gnome_sort(arr)` and `optimized_sort(arr)`. **Function Signature:** ```python def gnome_sort(arr: List[int]) -> List[int]: # Your implementation here def optimized_sort(arr: List[int]) -> List[int]: # Your implementation here ```","solution":"def gnome_sort(arr): Sorts an array of integers in non-decreasing order using the Gnome sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def optimized_sort(arr): Sorts an array of integers in non-decreasing order using an optimized sorting algorithm (Merge Sort). Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. if len(arr) > 1: mid = len(arr) // 2 # Finding the mid of the array L = arr[:mid] # Dividing the elements into 2 halves R = arr[mid:] optimized_sort(L) # Sorting the first half optimized_sort(R) # Sorting the second half i = j = k = 0 # Copy data to temp arrays L[] and R[] while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Checking if any element was left while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr # Performance Analysis # Gnome Sort: # Time Complexity: O(n^2) in the worst case, O(n) in the best case when the array is already sorted. # Space Complexity: O(1) as it is an in-place sorting algorithm. # Optimized Sort (Merge Sort): # Time Complexity: O(n log n) in the worst, average, and best cases. # Space Complexity: O(n) due to the additional space used for the temporary arrays."},{"question":"# Euler\'s Totient Function – Enhanced Implementation Problem Statement You are requested to write an enhanced function to compute the Euler Totient Function ϕ(n) for a given integer n. Additionally, the problem extends by asking you also to compute the values for an array of integers. Function Signature ```python def compute_totients(arr: List[int]) -> List[int]: Given an array of integers, computes the Euler Totient Function for each integer in the array. Parameters: arr (List[int]): A list of integers. Returns: List[int]: A list of ϕ(n) corresponding to each integer in the input array. ``` Input - A list of integers `arr` where 1 <= arr[i] <= 10^6 and the list\'s length can be up to 10^5. Output - A list of integers such that the i-th integer is the result of the Euler Totient function ϕ(arr[i]). Constraints - Handle the computational efficiency to accommodate the specified input size. - Ensure accurate handling of all edge cases. Example ```python compute_totients([1, 2, 3, 10, 25, 100]) # Output: [1, 1, 2, 4, 20, 40] ``` Guidelines - Optimize the algorithm considering the possible range up to 10^6. - Sieve Method: Consider precomputing all ϕ values up to the maximum given n in O(n log log n) using sieve. - Think about efficient memory utilization for large maximum n constraint.","solution":"from typing import List def compute_totients(arr: List[int]) -> List[int]: Given an array of integers, computes the Euler Totient Function for each integer in the array. Parameters: arr (List[int]): A list of integers. Returns: List[int]: A list of ϕ(n) corresponding to each integer in the input array. max_n = max(arr) # Initialize list for storing totient values phi = list(range(max_n + 1)) # Sieve method to compute all totient values up to max_n for i in range(2, max_n + 1): if phi[i] == i: # i is a prime number for j in range(i, max_n + 1, i): phi[j] = phi[j] * (i - 1) // i # Map the results to the input array result = [phi[num] for num in arr] return result"},{"question":"# Longest Unique Substring Challenge Imagine you are building a text processing library. One of the functionalities you need to implement is finding the longest substring without repeating characters from a given string. Problem Statement Write a function `find_longest_unique_substring(input_string: str) -> Tuple[int, str]` which takes a single string as input and returns a tuple containing: - The length of the longest substring without repeating characters. - The longest substring itself. If there are multiple substrings with the same longest length, return the first one that appears. Input Format - `input_string` (str): A non-empty string made up of ASCII characters. Output Format - A tuple with two elements: - An integer representing the length of the longest substring without repeating characters. - A string which is the longest substring without repeating characters. Constraints - The length of the input string will be between 1 and 10^5. - The input string will contain only printable ASCII characters. Performance Requirements - Solution should run in O(n) time complexity where n is the length of the input string. - Memory usage should be optimized with respect to the input size. # Example ```python find_longest_unique_substring(\\"abcabcbb\\") # Output: (3, \'abc\') find_longest_unique_substring(\\"bbbbb\\") # Output: (1, \'b\') find_longest_unique_substring(\\"pwwkew\\") # Output: (3, \'wke\') ``` # Notes - Your solution should handle edge cases such as an empty string, strings with identical characters, and strings already composed of unique characters efficiently. - Consider the constraints to ensure your solution operates within acceptable limits for both time and space. # Submission Guidelines Submit your solution as a Python function `find_longest_unique_substring`.","solution":"def find_longest_unique_substring(input_string: str): Function to find the longest substring without repeating characters. Returns a tuple with the length of the longest substring and the substring itself. if not input_string: return (0, \\"\\") max_length = 0 longest_substring = \\"\\" start_index = 0 char_index_map = {} for i, char in enumerate(input_string): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = i current_length = i - start_index + 1 if current_length > max_length: max_length = current_length longest_substring = input_string[start_index:i + 1] return (max_length, longest_substring)"},{"question":"# Integer Decomposition Objective: Write a function to determine how many ways a given positive integer can be decomposed into sums of smaller non-negative integers. This problem demonstrates a fundamental application of dynamic programming and tests your understanding of multi-dimensional array manipulation and summation techniques. Function Signature: ```python def num_ways_to_decompose(n: int) -> int: pass ``` Input: - An integer `n` where (1 leq n leq 1000). Output: - Returns an integer representing the number of ways to decompose `n`. Constraints: - Optimize for (O(n^2)) time complexity. - Minimize additional space usage where possible. - Assume all inputs are valid positive integers within the specified range. Example: ```python Example 1: Input: n = 4 Output: 5 Explanation: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 Example 2: Input: n = 7 Output: 15 Explanation: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Notes: - Your algorithm should efficiently handle edge cases and large inputs up to the provided constraint.","solution":"def num_ways_to_decompose(n: int) -> int: Determine the number of ways to decompose a given positive integer n into sums of smaller non-negative integers. # Create a list to hold the number of ways to decompose each integer up to n dp = [0] * (n + 1) # Base case: there\'s one way to decompose 0 dp[0] = 1 # Iterate through all integers from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Question: Verify Linked List Palindrome Without Space Overhead Given a singly linked list of integers, implement a function to determine if it reads the same backwards as forwards without using additional data structures (such as stacks or dictionaries). You should do this in (O(n)) time and (O(1)) space. Function Signature: ```python def is_palindrome_efficient(head: ListNode) -> bool: ``` Input: * `head`: The head of a singly linked list where each node contains an integer value `val`. Output: * `bool`: Return `True` if the linked list is a palindrome, and `False` otherwise. Constraints: * The number of nodes in the list is in the range `[0, 10^5]`. * `-10^9 <= Node.val <= 10^9`. Scenario: Consider a scenario where memory usage is highly restricted, for example, processing a palindromic sequence in an IoT device with very limited RAM. It is necessary to verify the palindromic property without extra data structures. Example: ```python # Example 1 head = ListNode(1, ListNode(2, ListNode(2, ListNode(1)))) assert is_palindrome_efficient(head) == True # Example 2 head = ListNode(1, ListNode(2)) assert is_palindrome_efficient(head) == False ``` # Notes: * The output should be `True` for the first example as it reads [1 -> 2 -> 2 -> 1] the same backward and forward. * The output should be `False` for the second example as it reads [1 -> 2] forward and [2 -> 1] backward. Additional guidelines: - You should not use any additional data structure (like stack, list, or dict) that consumes extra space. - Reconstructing the list to original after verification is not required but should be kept in mind for robust solutions.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_middle(head): slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next return slow def reverse_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def is_palindrome_efficient(head: ListNode) -> bool: if not head or not head.next: return True middle = find_middle(head) reversed_second_half = reverse_list(middle) first_half_iter = head second_half_iter = reversed_second_half result = True while second_half_iter: if first_half_iter.val != second_half_iter.val: result = False break first_half_iter = first_half_iter.next second_half_iter = second_half_iter.next # Optional: Restore the list (if needed) reverse_list(reversed_second_half) return result"},{"question":"You are tasked with creating a regular expression matcher that supports the special characters \'.\' (dot) and \'*\' (asterisk). The dot matches any single character, and the asterisk matches zero or more of the preceding element. The function must return whether the entire input string matches the given pattern. # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input * `s` (0 <= len(s) <= 1000): The input string. * `p` (0 <= len(p) <= 1000): The pattern string. # Output * Returns a boolean indicating whether the input string matches the pattern. # Constraints * The input string `s` will only contain lowercase letters \'a\'-\'z\'. * The pattern `p` will only contain lowercase letters \'a\'-\'z\', \'.\' and \'*\'. # Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Explanation - `is_match(\\"aa\\", \\"a\\")` should return `False` because the character \'a\' does not match the pattern \'a\' twice. - `is_match(\\"aa\\", \\"aa\\")` should return `True` because the characters \'aa\' match exactly the pattern \'aa\'. - `is_match(\\"aaa\\", \\"aa\\")` should return `False` because the pattern \'aa\' cannot expand to match \'aaa\'. - `is_match(\\"aa\\", \\"a*\\")` should return `True` because the \'*\' allows the preceding \'a\' to match twice. - `is_match(\\"aa\\", \\".*\\")` should return `True` because the \'.\' matches any single character and \'*\' allows it to match the entire input string. - `is_match(\\"ab\\", \\".*\\")` should return `True` because the \'.\' matches any single character, and \'*\' allows it to match \'ab\'. - `is_match(\\"aab\\", \\"c*a*b\\")` should return `True` because \'c*\' can match 0 \'c\', \'a*\' can match \'aa\', and \'b\' can match \'b\'. # Detailed Requirements - The function must handle both `.` and `*` correctly as described. - The entire input string `s` must match the pattern `p`. - Special consideration must be given to edge cases (empty strings, patterns starting or ending with `*`, patterns with multiple `*`).","solution":"def is_match(s: str, p: str) -> bool: Returns whether the input string matches the given pattern. The pattern supports \'.\' which matches any single character, and \'*\' which matches zero or more of the preceding element. # Initialize the DP table m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc should match empty string for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[m][n]"},{"question":"**Context**: You are tasked with optimizing the selection of files to fit into a limited storage device to maximize the importance score of files stored on the device. You are given a list of files, each with its size and importance score. **Objective**: Implement a function `maximize_importance` to determine the maximum importance score that can be achieved given the storage capacity. Function Specification: - **Function Name**: `maximize_importance` - **Parameters**: - `files`: A list of tuples where each tuple contains two integers: `(importance, size)`. - `capacity`: An integer representing the maximum storage capacity. - **Returns**: An integer representing the maximum importance score that can be achieved. Input Constraints: - `1 <= len(files) <= 100` - `0 <= capacity <= 10^4` - `1 <= importance, size <= 1000` Example: ```python capacity = 50 files = [(60, 10), (100, 20), (120, 30)] result = maximize_importance(files, capacity) print(result) # Output should be 220 (files with importance 60 and 120) ``` Instructions: - Write the function `maximize_importance` in Python. - Ensure that your solution handles edge cases such as zero capacity and no files. - Optimize for both time and space complexity.","solution":"def maximize_importance(files, capacity): Determines the maximum importance score that can be achieved given the storage capacity. :param files: List of tuples, where each tuple contains two integers: (importance, size) :param capacity: An integer representing the maximum storage capacity :return: An integer representing the maximum importance score that can be achieved n = len(files) dp = [0] * (capacity + 1) for importance, size in files: for c in range(capacity, size - 1, -1): dp[c] = max(dp[c], dp[c - size] + importance) return dp[capacity]"},{"question":"**Context**: You are working for a software company that requires sorting of several small datasets quickly and efficiently. Given the frequent need to deal with small or partially sorted datasets, they\'ve decided to use the Insertion Sort algorithm due to its simplicity and performance in such scenarios. **Question**: Write a function named `custom_insertion_sort(arr)` that sorts a given list of integers in ascending order using the Insertion Sort algorithm. Your implementation should not use any built-in sort functions or libraries. **Function Signature**: ```python def custom_insertion_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers (0 <= len(arr) <= 1000). **Output**: - A list of integers sorted in ascending order. **Constraints**: - You should handle all possible edge cases such as an empty array, a single-element array, etc. - Optimize the implementation to handle partially sorted arrays efficiently where possible. - The function should complete sorting within a reasonable time frame for the largest input size. **Example**: ```python # Example 1: arr = [5, 2, 9, 1, 5, 6] assert custom_insertion_sort(arr) == [1, 2, 5, 5, 6, 9] # Example 2: arr = [3, 0, -1, 8, 7, 3] assert custom_insertion_sort(arr) == [-1, 0, 3, 3, 7, 8] # Example 3: arr = [] assert custom_insertion_sort(arr) == [] ``` **Explanation**: Your task is to correctly implement the Insertion Sort algorithm as described. Ensure that your solution accounts for all edge cases and adheres to the specified input and output formats.","solution":"def custom_insertion_sort(arr): Sorts a list of integers in ascending order using the Insertion Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. # Edge case for empty array or single element array if len(arr) <= 1: return arr # Perform insertion sort for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"Implement a function to find the k-th smallest element in a Binary Search Tree (BST). Your implementation should handle edge cases effectively and should be optimized for both time and space complexity. Function Signature ```python def find_kth_smallest(root: Node, k: int) -> int: Args: root (Node): The root node of the BST. k (int): The k-th position (1-based). Returns: int: The k-th smallest element in the BST. ``` Input - `root`: A `Node` instance representing the root of the BST. - `k`: An integer representing the 1-based index of the element to find. Output - The k-th smallest element in the BST as an integer. Constraints - The BST contains `N` nodes such that `1 <= k <= N`. - Each node value in the BST is unique. Example Consider the following Binary Search Tree: ``` 100 / 50 150 / / 25 75 125 175 ``` For `k = 2`: ```python find_kth_smallest(n1, 2) # Returns 50 ``` Notes - The function should not modify the input tree. - Optimize for both space and time where possible. - Provide a thorough explanation in comments within your code. Good luck!","solution":"class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def find_kth_smallest(root: Node, k: int) -> int: Returns the k-th smallest element in the BST. Args: root (Node): The root node of the BST. k (int): The k-th position (1-based). Returns: int: The k-th smallest element in the BST. def in_order_traversal(node): Generator function to yield nodes\' values in in-order traversal. if not node: return yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) # Initial count count = 0 # Iterate through the BST in in-order manner for value in in_order_traversal(root): count += 1 if count == k: return value # If we don\'t find the k-th element, raise an error (though it should not happen as per constraints) raise ValueError(\\"k is out of the bounds of the BST\\")"},{"question":"# Factor Combination Generation **Objective**: Write a function `factor_combinations(n: int) -> List[List[int]]` that returns all unique combinations of factors (greater than 1 and less than (n)) that, when multiplied together, produce (n). The factors in each combination should be sorted in ascending order. **Input and Output**: * Input: * An integer (n) (1 ( leq ) n ( leq ) 10(^5)) * Output: * A list of lists, where each inner list contains a unique combination of factors of (n) **Function Signature**: ```python from typing import List def factor_combinations(n: int) -> List[List[int]]: # Your code here ``` **Examples**: ``` Input: 1 Output: [] Input: 37 Output: [] Input: 12 Output: [ [2, 6], [2, 2, 3], [3, 4] ] Input: 32 Output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` **Constraints**: * Factors must be greater than 1 but less than (n). * The same factor combination should not appear more than once. * Combine recursive and iterative designs as necessary to effectively manage time and space complexities. * Consider edge cases such as prime numbers and small values of (n). **Requirements**: Implement two approaches to find factor combinations: 1. **Iterative Depth-First Search**: Implement the factor combination generation iteratively using a stack. 2. **Recursive Depth-First Search**: Implement the factor combination generation recursively. **Scenario**: In competitive programming or during coding interviews, the ability to decompose integers into their lesser factors efficiently and programmatically is a common requirement, grounded in both theoretical and practical computer science knowledge. This task will test your understanding of recursive and iterative approaches, and your ability to handle edge cases efficiently.","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: def backtrack(start, target, path, result): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path, result) path.pop() result = [] backtrack(2, n, [], result) return result"},{"question":"# Question You are tasked with implementing a pair of functions to encode and decode a list of strings. The encoded string should be able to be transmitted seamlessly over a network and reconstructed back into its original form without loss of information. Function Signature: * Implement two functions: `encode` and `decode`. Function Descriptions: 1. **`encode`**: * Input: A list of strings. * Output: A single encoded string. * Process: Encode each string with its length and a specific delimiter to avoid ambiguity during decoding. 2. **`decode`**: * Input: A single encoded string. * Output: The original list of strings. * Process: Decode the encoded string by parsing lengths and substrings to reconstruct the list of strings. Input: * `encode` function: * A list of strings, `strs`, where `strs[i]` is a string containing characters. * `decode` function: * A single string, `s`, which is the result of the `encode` function. Output: * `encode` function: * A single string that is the encoded representation of the input list. * `decode` function: * A list of strings that corresponds to the original list before encoding. Constraints: * You may assume that the list of strings does not contain any numbers or colons (\\":\\") as this implementation does not manage escaping such characters. * The strings contain only ASCII characters. * The input list for `encode` function will have at most 1000 strings. * Each string in the list will have at most 1000 characters. Example: ```python input_list = [\\"hello\\", \\"world\\"] encoded_string = encode(input_list) # encoded_string may be \\"5:hello5:world\\" decoded_list = decode(encoded_string) # decoded_list would be [\\"hello\\", \\"world\\"] ``` Implement the `encode` and `decode` functions ensuring that every encoded string can be reliably decoded. **Note**: Your implementation should be efficient in terms of both time and space complexity.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs: List of strings to encode Returns: Encoded string encoded_str = \'\' for s in strs: length = len(s) encoded_str += f\\"{length}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s: Encoded string Returns: List of original strings decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"You are provided with a list of non-negative integers. Your task is to implement the `radix_sort` function. This function will sort the integers using the radix sort algorithm and return the sorted list. # Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - `arr`: A list of non-negative integers. (0 <= len(arr) <= 10^6; each integer in the list is within the range of a typical 32-bit integer: 0 <= arr[i] <= 2^31 - 1) - `simulation`: A boolean flag (default is `False`) used to denote if the function should print the intermediate iterations of the sorting for educational purposes. # Output - Return the sorted list `arr` after applying the radix sort algorithm. # Constraints 1. If `arr` is empty, return an empty list. 2. Considering the large potential input size, aim to complete the sorting efficiently in O(nk) time complexity. 3. Handle edge cases such as empty arrays, arrays with all same numbers, etc. # Example ```python print(radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(radix_sort([3, 0, 2, 5, 4, 1])) # Output: [0, 1, 2, 3, 4, 5] print(radix_sort([])) # Output: [] print(radix_sort([5, 5, 5, 5, 5])) # Output: [5, 5, 5, 5, 5] ``` # Additional Notes - If `simulation` is `True`, the function should print each iteration of sorting by each digit. Format: `iteration <iteration_number>: <list_elements>`. - You must handle potential performance issues intelligently to optimize the sort for larger datasets. Implement the `radix_sort` in your preferred programming language.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool, iteration: int) -> None: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {iteration}: {arr}\\") def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return [] max1 = max(arr) exp = 1 iteration = 1 while max1 // exp > 0: counting_sort(arr, exp, simulation, iteration) exp *= 10 iteration += 1 return arr"},{"question":"Scenario You are tasked with developing a search application for a library. Books are stored in a database and indexed by unique IDs. Your job is to implement a search function that identifies the position of a given book ID in the list. Problem Statement: Write a function `library_search(database, book_id)` that uses the linear search algorithm to find and return the index of a given `book_id` in the `database`. If the `book_id` is not present in the database, the function should return -1. Function Signature: ```python def library_search(database: List[int], book_id: int) -> int: ``` Input: * `database`: A list of integers representing the book IDs in the library database. * `book_id`: An integer representing the book ID to search for. Output: * An integer representing the index of the book ID in the database. If the book ID is not present, return -1. Constraints: * The `database` can contain up to 10^5 book IDs. * Each `book_id` in the `database` is an integer within the range [1, 10^6]. * The input `book_id` is also an integer within the range [1, 10^6]. Example: ```python database = [234, 567, 890, 123] book_id = 890 Result: 2 database = [101, 202, 303, 404] book_id = 505 Result: -1 ``` Performance Requirements: Aim to maintain an efficient solution with respect to time and space complexity. Your implementation should handle databases with up to 10^5 entries efficiently. # Additional Notes - Ensure your code is well-documented. - Address edge cases adequately. - Write clean and consistent code.","solution":"def library_search(database, book_id): Uses linear search to find the index of the given book_id in the database. If the book_id is not found, returns -1. Parameters: database (List[int]): List of book IDs in the library database. book_id (int): The book ID to search for. Returns: int: The index of the book_id in the database, or -1 if not found. for index, id in enumerate(database): if id == book_id: return index return -1"},{"question":"# Minimal Bit Flip Calculation Objective Implement a function that determines the minimal number of bits required to flip in order to convert an integer `A` into integer `B`. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input * `a` (int): First non-negative integer (0 ≤ a ≤ 2^31-1). * `b` (int): Second non-negative integer (0 ≤ b ≤ 2^31-1). Output * (int): The minimal number of bit flips required to convert `a` to `b`. Constraints * Both `a` and `b` will be between 0 and 2^31-1, inclusive. Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(1), where n is the number of bits in the longer input integer. Examples * Example 1: * Input: `a = 29` (which is `11101` in binary), `b = 15` (which is `01111` in binary) * Output: `2` (at indices `3` and `4` in the 5-bit representation) * Example 2: * Input: `a = 1`, `b = 2` * Output: `2` (binary representations `01` and `10`) Notes * Provide the implementation of the `count_flips_to_convert` method without relying on external libraries. * Ensure to implement edge-case handling where `a` and `b` share common characteristics discussed in the analysis.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bits required to flip in order to convert integer `a` to integer `b`. # XOR a and b to find bits that are different xor_result = a ^ b # Use a counter to count the number of 1s in the XOR result, which represent differing bits count = 0 while xor_result != 0: count += xor_result & 1 # Increment count if the least significant bit is 1 xor_result >>= 1 # Right shift to check the next bit return count"},{"question":"# Moving Average with Variable Window Size Context: In a real-time data monitoring system, it\'s often crucial to observe trends over varying windows of recent data. The given class `MovingAverage` calculates the moving average of a fixed window size, but in a dynamic system, the requirement might change, necessitating varying window sizes. Task: Implement a class `DynamicMovingAverage` that supports calculating the moving average over a variable window size. Implementation: Your implementation should provide the following two methods: 1. `DynamicMovingAverage.next(val: int) -> float`: - Adds an integer to the data stream. - Computes the moving average over the current window size specified at initialization or changed subsequently. 2. `DynamicMovingAverage.updateWindowSize(new_size: int) -> None`: - Updates the window size for the moving average calculation. - If the new size is smaller than the existing size, retain only the most recent elements up to `new_size`. Constraints: - The `next` method should execute in O(1) time complexity. - The window size will always be a positive integer. Expected Input and Output: - `next` method takes an integer and returns the current moving average as a float. - `updateWindowSize` method takes an integer `new_size` and doesn\'t return a value. Example Usage: ```python dma = DynamicMovingAverage(3) print(dma.next(1)) # Output: 1.0 print(dma.next(5)) # Output: 3.0 print(dma.next(3)) # Output: 3.0 print(dma.next(8)) # Output: 5.333333333333333 dma.updateWindowSize(2) print(dma.next(7)) # Output: 7.5 print(dma.next(4)) # Output: 5.5 print(dma.next(3)) # Output: 3.5 ``` Note: - **Edge Case 1**: The window size is updated to be larger while there are fewer elements in the stream. - **Edge Case 2**: Handle scenarios where rapid size adjustments occur in the middle of the stream processing.","solution":"from collections import deque class DynamicMovingAverage: def __init__(self, size: int): Initialize the DynamicMovingAverage with a specific window size. self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Adds an integer to the data stream and computes the moving average. if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue) def updateWindowSize(self, new_size: int) -> None: Updates the window size for the moving average calculation. self.size = new_size while len(self.queue) > self.size: self.sum -= self.queue.popleft()"},{"question":"# Comb Sort Implementation & Performance Analysis Background Comb Sort is a relatively simple yet effective sorting algorithm that improves upon Bubble Sort by eliminating small values (\\"turtles\\") earlier in the sorting process. This algorithm uses a \\"gap\\" to compare and swap elements separated by the gap. The gap starts out large and reduces until it becomes 1. Task You need to implement the Comb Sort algorithm in a function `comb_sort(arr: List[int]) -> List[int]`. This function should take a list of integers as input and return a sorted list in non-decreasing order. # Function Signature ```python from typing import List def comb_sort(arr: List[int]) -> List[int]: # your code here ``` # Input * A list `arr` where: * 0 ≤ len(arr) ≤ 10^4 * -10^6 ≤ arr[i] ≤ 10^6 # Output * The sorted list in non-decreasing order. # Constraints * Focus on optimizing time complexity and ensure the function runs efficiently within the constraint limits. * Handle edge cases such as empty lists and single element lists. # Example ```python assert comb_sort([5, 3, 1, 2, 4]) == [1, 2, 3, 4, 5] assert comb_sort([]) == [] assert comb_sort([10]) == [10] assert comb_sort([5, -3, 0, 2, 4]) == [-3, 0, 2, 4, 5] assert comb_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` # Note Ensure that your implementation: * Follows the described operational steps of the Comb Sort. * Handles all edge cases. * Is efficient within given constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Implements the Comb Sort algorithm to sort a list of integers. def get_next_gap(gap): # Shrink gap by the shrink factor, usually a value of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"}]'),S={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},C={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=c(S,[["render",j],["__scopeId","data-v-cf374c6d"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/41.md","filePath":"drive/41.md"}'),D={name:"drive/41.md"},H=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,H as default};
