import{_ as c,o as s,c as n,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,u,m,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const A=c(q,[["render",R],["__scopeId","data-v-2398fb95"]]),S=JSON.parse(`[{"question":"def is_subsequence(s: str, word: str) -> bool: Check if \`word\` is a subsequence of \`s\`. >>> is_subsequence(\\"abcde\\", \\"a\\") True >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"acd\\") True >>> is_subsequence(\\"abcde\\", \\"bb\\") False def num_matching_subseq(s: str, words: List[str]) -> int: Returns the count of words that are subsequences of \`s\`. >>> num_matching_subseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> num_matching_subseq(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"]) 7 >>> num_matching_subseq(\\"test\\", [\\"t\\", \\"e\\", \\"st\\", \\"te\\", \\"es\\", \\"tes\\"]) 6 >>> num_matching_subseq(\\"xyz\\", [\\"x\\", \\"y\\", \\"z\\", \\"xy\\", \\"xz\\", \\"yz\\", \\"xyz\\", \\"yza\\"]) 7 from solution import is_subsequence, num_matching_subseq def test_is_subsequence(): assert is_subsequence(\\"abcde\\", \\"a\\") == True assert is_subsequence(\\"abcde\\", \\"ace\\") == True assert is_subsequence(\\"abcde\\", \\"acd\\") == True assert is_subsequence(\\"abcde\\", \\"bb\\") == False assert is_subsequence(\\"abcdefg\\", \\"abcdg\\") == True assert is_subsequence(\\"abcdefg\\", \\"gfedcba\\") == False def test_num_matching_subseq_example_1(): s = \\"abcde\\" words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"] assert num_matching_subseq(s, words) == 3 def test_num_matching_subseq_example_2(): s = \\"abc\\" words = [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"] assert num_matching_subseq(s, words) == 7 def test_num_matching_subseq_example_3(): s = \\"test\\" words = [\\"t\\", \\"e\\", \\"st\\", \\"te\\", \\"es\\", \\"tes\\"] assert num_matching_subseq(s, words) == 6 def test_num_matching_subseq_example_4(): s = \\"xyz\\" words = [\\"x\\", \\"y\\", \\"z\\", \\"xy\\", \\"xz\\", \\"yz\\", \\"xyz\\", \\"yza\\"] assert num_matching_subseq(s, words) == 7 def test_edge_cases(): s = \\"a\\" words = [\\"a\\", \\"aa\\", \\"aaa\\"] assert num_matching_subseq(s, words) == 1 s = \\"abcdef\\" words = [\\"f\\", \\"ef\\", \\"def\\", \\"cdef\\"] assert num_matching_subseq(s, words) == 4 s = \\"mnop\\" words = [\\"m\\", \\"n\\", \\"o\\", \\"p\\", \\"mn\\", \\"mo\\", \\"mp\\", \\"mnop\\"] assert num_matching_subseq(s, words) == 8","solution":"def is_subsequence(s, word): Returns True if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def num_matching_subseq(s, words): Returns the count of words that are subsequences of s. return sum(is_subsequence(s, word) for word in words)"},{"question":"from collections import defaultdict, Counter from typing import List, Tuple, Dict def find_most_frequent_product(t: int, test_cases: List[Dict[str, List[Tuple[int, int]]]]) -> List[int]: Find the most frequently clicked product in a given range of click events. t: int - the number of test cases test_cases: List[Dict[str, List[Union[int, List[Tuple[int, int]]]]]] - description of each test case For each test case: - n: int - the number of products - q: int - the number of queries - products: List[int] - the identifiers of the products clicked by the users in sequence - queries: List[Tuple[int, int]] - each tuple contains two integers l and r, describing the subsequence of click events for the query Returns: List[int] - For each query in each test case, a single integer that is the most frequently clicked product in the specified subsequence. Example: >>> t = 1 >>> cases = [ >>> { >>> \\"n\\": 10, >>> \\"q\\": 2, >>> \\"products\\": [3, 1, 2, 2, 3, 3, 4, 4, 4, 1], >>> \\"queries\\": [(1, 5), (2, 10)] >>> } >>> ] >>> find_most_frequent_product(t, cases) [2, 4]","solution":"from collections import defaultdict, Counter def find_most_frequent_product(t, test_cases): results = [] for test in test_cases: n, q, products, queries = test[\\"n\\"], test[\\"q\\"], test[\\"products\\"], test[\\"queries\\"] for query in queries: l, r = query subsequence = products[l-1:r] frequency_counter = Counter(subsequence) most_frequent = min(frequency_counter.items(), key=lambda x: (-x[1], x[0]))[0] results.append(most_frequent) return results"},{"question":"from typing import List def min_operations_to_equalize_array(n: int, a: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. Args: n : int : the length of the array a : List[int] : the elements of the array Returns: int : the minimum number of operations required Examples: >>> min_operations_to_equalize_array(5, [1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize_array(4, [10, 10, 10, 10]) 0 >>> min_operations_to_equalize_array(6, [4, 4, 4, 4, 4, 4]) 0 >>> min_operations_to_equalize_array(3, [1, 1, 2]) 1","solution":"def min_operations_to_equalize_array(n, a): Returns the minimum number of operations required to make all elements of the array equal. Args: n : int : the length of the array a : List[int] : the elements of the array Returns: int : the minimum number of operations required # The number of operations required is the difference between the maximum value and the minimum value in the array. return max(a) - min(a)"},{"question":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determines if the characters in the string \`s\` can be rearranged to form a palindrome. :param s: A string consisting of lowercase English letters :return: True if the input string can be rearranged to form a palindrome, otherwise False >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"abcdefghijklmnopqrstuvwxyz\\") False","solution":"from collections import Counter def can_form_palindrome(s): Determines if the characters in the string \`s\` can be rearranged to form a palindrome. :param s: A string consisting of lowercase English letters :return: True if the input string can be rearranged to form a palindrome, otherwise False # Count occurrences of each character char_count = Counter(s) # A string can form a palindrome if it has at most one character with an odd count odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) return odd_counts <= 1"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit that can be achieved from buying and selling a single stock. :param prices: List of daily stock prices :return: Maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Calculates the maximum profit that can be achieved from buying and selling a single stock. :param prices: List of prices :return: Maximum profit if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def most_frequent_words(strings): Process a list of strings and calculate the frequency of each word in the list. Output the word that occurs most frequently. If there are multiple words with the same highest frequency, output them in alphabetical order. >>> most_frequent_words(['apple', 'banana', 'apple', 'orange', 'banana', 'banana', '#']) == ['banana'] >>> most_frequent_words(['dog', 'cat', 'bird', 'dog', 'cat', 'bird', '#']) == ['bird', 'cat', 'dog']","solution":"def most_frequent_words(strings): if not strings: return [] word_count = {} for word in strings: if word == '#': break if word in word_count: word_count[word] += 1 else: word_count[word] = 1 if not word_count: return [] max_frequency = max(word_count.values()) most_frequent = [word for word, count in word_count.items() if count == max_frequency] return sorted(most_frequent)"},{"question":"def can_sort_grid_lexicographically(n: int, m: int, grid: List[str]) -> str: Determines if the grid can be sorted lexicographically by swapping rows. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid rows :return: \\"YES\\" if the grid can be sorted lexicographically, \\"NO\\" otherwise >>> can_sort_grid_lexicographically(3, 3, [\\"011\\", \\"101\\", \\"110\\"]) \\"YES\\" >>> can_sort_grid_lexicographically(4, 2, [\\"10\\", \\"11\\", \\"01\\", \\"00\\"]) \\"NO\\"","solution":"def can_sort_grid_lexicographically(n, m, grid): Determines if the grid can be sorted lexicographically by swapping rows. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid rows :return: \\"YES\\" if the grid can be sorted lexicographically, \\"NO\\" otherwise # Sort the grid with respect to lexicographic order sorted_grid = sorted(grid) # Compare the sorted grid with the original grid if sorted_grid == grid: return \\"YES\\" else: return \\"NO\\""},{"question":"def num_distinct_paths(grid: List[List[int]]) -> int: Determine the number of distinct paths the robot can take through a grid filled with obstacles. The grid is represented by a 2D array where each cell can either be empty (0) or contain an obstacle (1). The robot can only move down or right at each step, starting from the top-left corner (0,0) to the bottom-right corner (n-1,m-1). >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> num_distinct_paths(grid) 2 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [1, 0, 0] ... ] >>> num_distinct_paths(grid) 0 >>> grid = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> num_distinct_paths(grid) 0 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> num_distinct_paths(grid) 0 >>> grid = [[0]*5 for _ in range(5)] >>> num_distinct_paths(grid) 70","solution":"def num_distinct_paths(grid): n = len(grid) m = len(grid[0]) # If the starting or ending cell is blocked, return 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Initialize a 2D dp array to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Example usage: # grid = [ # [0, 0, 0], # [0, 1, 0], # [0, 0, 0] # ] # print(num_distinct_paths(grid)) # Output: 2"},{"question":"def can_be_palindrome_with_one_swap(S: str) -> str: Determines if a given binary string can be made into a palindrome by performing at most 1 swap between any two distinct positions. -----Constraints----- - The length of the binary string will be between 1 and 10^5 inclusive. >>> can_be_palindrome_with_one_swap(\\"10110\\") 'YES' >>> can_be_palindrome_with_one_swap(\\"111000\\") 'NO' def test_can_be_palindrome_with_one_swap_palindrome_already(): assert can_be_palindrome_with_one_swap(\\"110011\\") == \\"YES\\" def test_can_be_palindrome_with_one_swap_one_mismatch(): assert can_be_palindrome_with_one_swap(\\"10110\\") == \\"YES\\" def test_can_be_palindrome_with_one_swap_two_mismatches_can_swap(): assert can_be_palindrome_with_one_swap(\\"0110\\") == \\"YES\\" def test_can_be_palindrome_with_one_swap_two_mismatches_cannot_swap(): assert can_be_palindrome_with_one_swap(\\"111000\\") == \\"NO\\" def test_can_be_palindrome_with_one_swap_odd_length(): assert can_be_palindrome_with_one_swap(\\"01011\\") == \\"NO\\" def test_can_be_palindrome_with_one_swap_single_character(): assert can_be_palindrome_with_one_swap(\\"0\\") == \\"YES\\" def test_can_be_palindrome_with_one_swap_two_characters_same(): assert can_be_palindrome_with_one_swap(\\"00\\") == \\"YES\\" def test_can_be_palindrome_with_one_swap_two_characters_different(): assert can_be_palindrome_with_one_swap(\\"01\\") == \\"NO\\"","solution":"def can_be_palindrome_with_one_swap(S): Determines if a given binary string can be made into a palindrome by performing at most 1 swap between any two distinct positions. n = len(S) mismatch_indices = [] for i in range(n // 2): if S[i] != S[n - i - 1]: mismatch_indices.append(i) if len(mismatch_indices) > 2: return \\"NO\\" if len(mismatch_indices) == 0: return \\"YES\\" if len(mismatch_indices) == 2: i1, i2 = mismatch_indices if (S[i1] == S[n - i2 - 1] and S[i2] == S[n - i1 - 1]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Given a string S, generate all permutations of the characters in the string and return them as a sorted list. >>> generate_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(\\"bac\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']","solution":"from itertools import permutations def generate_permutations(s): Returns all permutations of the string \`s\` sorted in lexicographical order. perm = [''.join(p) for p in permutations(s)] return sorted(perm)"},{"question":"def nthTermOfGP(G1, G2, N): Returns the Nth term of a geometric progression sequence given the first two terms. Parameters: - G1: First term of the GP. - G2: Second term of the GP. - N: The position of the term to be found. Returns: - The Nth term of the GP. >>> nthTermOfGP(2, 6, 3) 18 >>> nthTermOfGP(3, 9, 4) 81","solution":"def nthTermOfGP(G1, G2, N): Returns the Nth term of a geometric progression sequence given the first two terms. Parameters: - G1: First term of the GP. - G2: Second term of the GP. - N: The position of the term to be found. Returns: - The Nth term of the GP. if N == 1: return G1 elif N == 2: return G2 else: r = G2 / G1 return G1 * (r ** (N - 1))"},{"question":"from typing import List, Tuple def can_hike_ascending_path(N: int, M: int, paths: List[Tuple[int, int]]) -> str: Determines if it is possible to hike from the base camp (node 1) to the summit (node N) following an ascending path that covers all checkpoints exactly once. >>> can_hike_ascending_path(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) \\"Yes\\" >>> can_hike_ascending_path(4, 3, [(1, 2), (1, 3), (2, 4)]) \\"No\\" pass # Unit tests def test_case_1(): N = 4 M = 4 paths = [(1, 2), (2, 3), (3, 4), (1, 3)] assert can_hike_ascending_path(N, M, paths) == \\"Yes\\" def test_case_2(): N = 4 M = 3 paths = [(1, 2), (1, 3), (2, 4)] assert can_hike_ascending_path(N, M, paths) == \\"No\\" def test_case_3(): N = 3 M = 3 paths = [(1, 2), (2, 3), (1, 3)] assert can_hike_ascending_path(N, M, paths) == \\"Yes\\" def test_case_4(): N = 5 M = 4 paths = [(1, 2), (2, 3), (3, 4), (4, 5)] assert can_hike_ascending_path(N, M, paths) == \\"Yes\\" def test_case_5(): N = 2 M = 1 paths = [(1, 2)] assert can_hike_ascending_path(N, M, paths) == \\"Yes\\" def test_case_6(): N = 2 M = 0 paths = [] assert can_hike_ascending_path(N, M, paths) == \\"No\\" def test_case_7(): N = 6 M = 6 paths = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3)] assert can_hike_ascending_path(N, M, paths) == \\"Yes\\"","solution":"def can_hike_ascending_path(N, M, paths): from collections import defaultdict, deque # Build the adjacency list adj_list = defaultdict(list) for u, v in paths: adj_list[u].append(v) adj_list[v].append(u) # Start BFS from the base camp (node 1) queue = deque([(1, [1])]) # Store (current node, path taken) while queue: current_node, path = queue.popleft() if current_node == N and len(path) == N: return \\"Yes\\" for neighbor in adj_list[current_node]: if neighbor > current_node and neighbor not in path: # Ascending path condition queue.append((neighbor, path + [neighbor])) return \\"No\\""},{"question":"def even_difference_pairs_count(n: int, arr: List[int]) -> int: This function takes in an integer n and a list of integers arr. It returns the count of pairs (i, j) where 1 ≤ i < j ≤ n and the absolute difference between the elements ai and aj is even. >>> even_difference_pairs_count(5, [1, 2, 3, 4, 5]) 4 >>> even_difference_pairs_count(3, [10, 20, 30]) 3","solution":"def even_difference_pairs_count(n, arr): This function takes in an integer n and a list of integers arr. It returns the count of pairs (i, j) where 1 ≤ i < j ≤ n and the absolute difference between the elements ai and aj is even. even_count = 0 odd_count = 0 # Counting even and odd numbers in the list for num in arr: if num % 2 == 0: even_count += 1 else: odd_count += 1 # The number of pairs of even numbers even_pairs = even_count * (even_count - 1) // 2 # The number of pairs of odd numbers odd_pairs = odd_count * (odd_count - 1) // 2 # Total pairs where the absolute difference is even (either both numbers are even or both are odd) return even_pairs + odd_pairs"},{"question":"def threeSum(nums): Returns all unique triplets in the array that sum to zero. >>> threeSum([-1, 0, 1, 2, -1, -4]) == [[-1, 0, 1], [-1, -1, 2]] >>> threeSum([1, 2, 3, 4, 5]) == [] >>> threeSum([0, 0, 0, 0]) == [[0, 0, 0]] >>> threeSum([-4, -2, -1, 0, 1, 2, 3]) == [[-4, 1, 3], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] >>> threeSum([-2, -2, 0, 0, 2, 2]) == [[-2, 0, 2]]","solution":"def threeSum(nums): Returns all unique triplets in the array that sum to zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"from typing import List, Tuple def longestCommonPrefix(str1: str, str2: str) -> str: Returns the longest common prefix between str1 and str2. If there is no common prefix, returns \\"-1\\". >>> longestCommonPrefix(\\"geeksforgeeks\\", \\"geeks\\") \\"geeks\\" >>> longestCommonPrefix(\\"hello\\", \\"he\\") \\"he\\" >>> longestCommonPrefix(\\"abc\\", \\"def\\") \\"-1\\" >>> longestCommonPrefix(\\"abcd\\", \\"\\") \\"-1\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases for determining the longest common prefix.","solution":"def longestCommonPrefix(str1, str2): Returns the longest common prefix between str1 and str2. If there is no common prefix, returns \\"-1\\". min_length = min(len(str1), len(str2)) i = 0 while i < min_length and str1[i] == str2[i]: i += 1 if i == 0: return \\"-1\\" else: return str1[:i] def process_test_cases(test_cases): results = [] for str1, str2 in test_cases: results.append(longestCommonPrefix(str1, str2)) return results"},{"question":"from typing import List def maximum_treasure_difference(N: int, treasures: List[int], costs: List[List[int]]) -> int: Find the maximum difference between the value of the treasure collected at the ending room and the cost of traveling from the starting room to the ending room. >>> maximum_treasure_difference(4, [3, 6, 2, 8], [ ... [0, 5, -1, 10], ... [-1, 0, 6, 2], ... [7, -1, 0, 3], ... [4, 12, -1, 0] ... ]) == 6 >>> maximum_treasure_difference(3, [10, 15, 20], [ ... [0, 50, 5], ... [50, 0, -1], ... [5, -1, 0] ... ]) == 15 >>> maximum_treasure_difference(2, [5, 100], [ ... [0, 1], ... [1, 0] ... ]) == 99 >>> maximum_treasure_difference(1, [10], [[0]]) == float('-inf') # No journey possible >>> maximum_treasure_difference(3, [100, 200, 300], [ ... [0, -1, 50], ... [-1, 0, 10], ... [50, 10, 0] ... ]) == 290","solution":"import heapq def maximum_treasure_difference(N, treasures, costs): max_diff = float('-inf') def dijkstra(start): dist = [float('inf')] * N dist[start] = 0 pq = [(0, start)] while pq: current_cost, current_node = heapq.heappop(pq) if current_cost > dist[current_node]: continue for next_node in range(N): if costs[current_node][next_node] != -1: new_cost = dist[current_node] + costs[current_node][next_node] if new_cost < dist[next_node]: dist[next_node] = new_cost heapq.heappush(pq, (new_cost, next_node)) return dist for start in range(N): dist = dijkstra(start) for end in range(N): if start != end and dist[end] < float('inf'): max_diff = max(max_diff, treasures[end] - dist[end]) return max_diff"},{"question":"def max_subarray_sum(arr): Find the maximum possible sum of pollution levels in any contiguous subarray. >>> max_subarray_sum([1, -2, 3, 4]) 7 >>> max_subarray_sum([-3, -2, -1, 4, 3]) 7 >>> max_subarray_sum([-1, -1, -1]) -1 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([10**9] * 5) 5 * 10**9 >>> max_subarray_sum([-10**9, 10**9]) 10**9 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([0, 0, 0]) 0 >>> max_subarray_sum([1, 0, -1, 0, 1]) 1 pass def solve(test_cases): Process multiple test cases and return the results for max subarray sums. >>> solve([ ... [1, -2, 3, 4], ... [-3, -2, -1, 4, 3], ... [-1, -1, -1] ... ]) [7, 7, -1] pass","solution":"def max_subarray_sum(arr): Function to find the maximum possible sum of a contiguous subarray in a given list 'arr'. if not arr: return 0 current_max = max_sum = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) max_sum = max(max_sum, current_max) return max_sum def solve(test_cases): Function to process multiple test cases and return the results for max subarray sums. results = [] for sensors in test_cases: results.append(max_subarray_sum(sensors)) return results # Example usage: t = 3 input_data = [ [1, -2, 3, 4], [-3, -2, -1, 4, 3], [-1, -1, -1] ] # For testing purpose directly print(solve(input_data))"},{"question":"def count_distinct_substrings(s: str) -> int: Count the number of distinct substrings of a given string. The input consists of a single string s of length n (1 ≤ n ≤ 10^6), which consists of only lowercase English letters. The output should be a single integer — the number of distinct substrings of the given string. Examples: >>> count_distinct_substrings(\\"abcd\\") 10 >>> count_distinct_substrings(\\"aaa\\") 6","solution":"class SuffixArray: def __init__(self, s): self.s = s self.n = len(s) self.suffix_array = self.build_suffix_array() self.lcp = self.build_lcp() def build_suffix_array(self): suffixes = sorted((self.s[i:], i) for i in range(self.n)) suffix_array = [suffix[1] for suffix in suffixes] return suffix_array def build_lcp(self): Builds the LCP (Longest Common Prefix) array. rank = [0] * self.n lcp = [0] * self.n for i, suffix in enumerate(self.suffix_array): rank[suffix] = i h = 0 for i in range(self.n): if rank[i] > 0: j = self.suffix_array[rank[i] - 1] while i + h < self.n and j + h < self.n and self.s[i + h] == self.s[j + h]: h += 1 lcp[rank[i]] = h if h > 0: h -= 1 return lcp def count_distinct_substrings(self): total_substrings = sum(self.n - suffix for suffix in self.suffix_array) lcp_sum = sum(self.lcp) return total_substrings - lcp_sum def count_distinct_substrings(s): suffix_array = SuffixArray(s) return suffix_array.count_distinct_substrings()"},{"question":"def decrypt_message(encrypted_message: str) -> str: Decrypt a message that was encrypted by shifting each letter 3 places forward in the alphabet, spaces remain unchanged. >>> decrypt_message(\\"khoor zruog\\") 'hello world' >>> decrypt_message(\\"sbwkrq lv ixq\\") 'python is fun' >>> decrypt_message(\\"d\\") 'a' >>> decrypt_message(\\" \\") ' ' pass","solution":"def decrypt_message(encrypted_message: str) -> str: decrypted_message = [] for char in encrypted_message: if char == ' ': decrypted_message.append(char) else: decrypted_char = chr(((ord(char) - 3) - ord('a')) % 26 + ord('a')) decrypted_message.append(decrypted_char) return ''.join(decrypted_message)"},{"question":"def rearrangeArray(arr, N, M): Rearranges the array such that the absolute difference between any two consecutive elements is at most M. If it's not possible to rearrange, returns -1. >>> rearrangeArray([1, 2, 8, 4, 5], 5, 3) [1, 2, 4, 5, 8] >>> rearrangeArray([3, 6, 9], 3, 1) -1","solution":"def rearrangeArray(arr, N, M): Rearranges the array such that the absolute difference between any two consecutive elements is at most M. If it's not possible to rearrange, returns -1. arr.sort() for i in range(1, N): if abs(arr[i] - arr[i - 1]) > M: return -1 return arr"},{"question":"def delivery_schedule(requests): Generates a delivery schedule based on unique customer requests. Parameters: requests (list of tuples): A list of (customer_name, food_item) tuples. Returns: list: A sorted list of (customer_name, food_item) tuples where each customer appears once with their first requested food item. pass # Sample Test Cases requests = [ (\\"john\\", \\"pizza\\"), (\\"alice\\", \\"burger\\"), (\\"john\\", \\"pasta\\"), (\\"maria\\", \\"salad\\"), (\\"peter\\", \\"sushi\\"), (\\"alice\\", \\"fries\\"), (\\"maria\\", \\"soup\\"), (\\"peter\\", \\"tempura\\"), ] print(delivery_schedule(requests)) # Expected Output: [('alice', 'burger'), ('john', 'pizza'), ('maria', 'salad'), ('peter', 'sushi')] requests = [(\\"john\\", \\"pizza\\")] print(delivery_schedule(requests)) # Expected Output: [('john', 'pizza')] requests = [ (\\"john\\", \\"pizza\\"), (\\"john\\", \\"burger\\"), (\\"john\\", \\"pasta\\") ] print(delivery_schedule(requests)) # Expected Output: [('john', 'pizza')] requests = [ (\\"john\\", \\"pizza\\"), (\\"alice\\", \\"burger\\"), (\\"maria\\", \\"salad\\"), (\\"peter\\", \\"sushi\\") ] print(delivery_schedule(requests)) # Expected Output: [('alice', 'burger'), ('john', 'pizza'), ('maria', 'salad'), ('peter', 'sushi')] requests = [ (\\"zane\\", \\"fries\\"), (\\"abel\\", \\"steak\\"), (\\"john\\", \\"pizza\\"), (\\"marie\\", \\"soup\\"), ] print(delivery_schedule(requests)) # Expected Output: [('abel', 'steak'), ('john', 'pizza'), ('marie', 'soup'), ('zane', 'fries')] requests = [(f\\"user{i}\\", f\\"item{i}\\") for i in range(1, 100000)] print(delivery_schedule(requests)[:10]) # only printing the first 10 to avoid huge output # Expected Output: [('user1', 'item1'), ('user2', 'item2'), ..., ('user10', 'item10')]","solution":"def delivery_schedule(requests): Generates a delivery schedule based on unique customer requests. Parameters: requests (list of tuples): A list of (customer_name, food_item) tuples. Returns: list: A sorted list of (customer_name, food_item) tuples where each customer appears once with their first requested food item. seen_customers = {} for customer, item in requests: if customer not in seen_customers: seen_customers[customer] = item sorted_requests = sorted(seen_customers.items()) return sorted_requests"},{"question":"def largest_rectangle_area(heights): Computes the area of the largest rectangle that can be formed between buildings, where the width of each building is 1 unit. :param heights: List[int] : list of integers representing the heights of buildings :return: int : area of the largest rectangle Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9","solution":"def largest_rectangle_area(heights): Computes the area of the largest rectangle that can be formed between buildings. :param heights: List[int] : list of integers representing the heights of buildings :return: int : area of the largest rectangle stack = [] max_area = 0 heights.append(0) # Append a zero to ensure stack is emptied at the end for i, height in enumerate(heights): while stack and heights[stack[-1]] > height: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def count_eligible_students(students): Returns the number of students eligible for the scholarship. Eligibility criteria: 1. The student must have a GPA of at least 3.5. 2. The student must have completed at least 100 hours of volunteer work. 3. The student must have a recommendation letter from at least one teacher. :param students: List of dictionaries, where each dictionary represents a student :return: Integer, number of students eligible for the scholarship >>> count_eligible_students([ ... {\\"name\\": \\"Alice\\", \\"gpa\\": 3.8, \\"volunteer_hours\\": 120, \\"recommendations\\": [\\"Mr. Smith\\"]}, ... {\\"name\\": \\"Bob\\", \\"gpa\\": 3.4, \\"volunteer_hours\\": 150, \\"recommendations\\": [\\"Ms. Johnson\\"]}, ... {\\"name\\": \\"Charlie\\", \\"gpa\\": 3.6, \\"volunteer_hours\\": 80, \\"recommendations\\": []}, ... {\\"name\\": \\"David\\", \\"gpa\\": 3.9, \\"volunteer_hours\\": 110, \\"recommendations\\": [\\"Mr. Lee\\", \\"Mrs. Clark\\"]} ... ]) == 2 >>> count_eligible_students([]) == 0 >>> count_eligible_students([ ... {\\"name\\": \\"Bob\\", \\"gpa\\": 3.4, \\"volunteer_hours\\": 150, \\"recommendations\\": [\\"Ms. Johnson\\"]}, ... {\\"name\\": \\"Charlie\\", \\"gpa\\": 3.6, \\"volunteer_hours\\": 80, \\"recommendations\\": []} ... ]) == 0 >>> count_eligible_students([ ... {\\"name\\": \\"Alice\\", \\"gpa\\": 3.8, \\"volunteer_hours\\": 120, \\"recommendations\\": [\\"Mr. Smith\\"]}, ... {\\"name\\": \\"David\\", \\"gpa\\": 3.9, \\"volunteer_hours\\": 110, \\"recommendations\\": [\\"Mr. Lee\\", \\"Mrs. Clark\\"]} ... ]) == 2 >>> count_eligible_students([ ... {\\"name\\": \\"Charlie\\", \\"gpa\\": 3.6, \\"volunteer_hours\\": 80, \\"recommendations\\": []}, ... {\\"name\\": \\"David\\", \\"gpa\\": 3.9, \\"volunteer_hours\\": 110, \\"recommendations\\": [\\"Mr. Lee\\", \\"Mrs. Clark\\"]} ... ]) == 1","solution":"def count_eligible_students(students): Returns the number of students eligible for the scholarship. Eligibility criteria: 1. The student must have a GPA of at least 3.5. 2. The student must have completed at least 100 hours of volunteer work. 3. The student must have a recommendation letter from at least one teacher. :param students: List of dictionaries, where each dictionary represents a student :return: Integer, number of students eligible for the scholarship eligible_count = 0 for student in students: if ( student['gpa'] >= 3.5 and student['volunteer_hours'] >= 100 and len(student['recommendations']) > 0 ): eligible_count += 1 return eligible_count"},{"question":"def can_form_pattern(message: str, pattern: str) -> str: Determines if the pattern can be formed by deleting some characters from the message. Parameters: message (str): The original string. pattern (str): The target pattern string. Returns: str: \\"YES\\" if pattern can be obtained from message, otherwise \\"NO\\". >>> can_form_pattern(\\"abpcplea\\", \\"apple\\") \\"YES\\" >>> can_form_pattern(\\"hello\\", \\"world\\") \\"NO\\" >>> can_form_pattern(\\"abcdef\\", \\"ace\\") \\"YES\\"","solution":"def can_form_pattern(message: str, pattern: str) -> str: Determines if the pattern can be formed by deleting some characters from the message. Parameters: message (str): The original string. pattern (str): The target pattern string. Returns: str: \\"YES\\" if pattern can be obtained from message, otherwise \\"NO\\". j = 0 # Pointer for pattern for char in message: if j < len(pattern) and char == pattern[j]: j += 1 if j == len(pattern): return \\"YES\\" return \\"NO\\""},{"question":"def can_form_palindrome(words): Given a list of words, determine if each word can be rearranged to form a palindrome. Args: words (list of str): List of words to be analyzed. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each corresponding word. >>> can_form_palindrome([\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_palindrome([\\"abba\\", \\"abcd\\", \\"racecar\\", \\"carerac\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> can_form_palindrome([\\"a\\"]) [\\"YES\\"] >>> can_form_palindrome([\\"\\"]) [\\"YES\\"] >>> can_form_palindrome([\\"aa\\"]) [\\"YES\\"] >>> can_form_palindrome([\\"ab\\"]) [\\"NO\\"] >>> can_form_palindrome([\\"aA\\"]) [\\"NO\\"]","solution":"def can_form_palindrome(words): Given a list of words, determine if each word can be rearranged to form a palindrome. Args: words (list of str): List of words to be analyzed. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each corresponding word. def is_palindrome_permutation(word): from collections import Counter counts = Counter(word) odd_count = 0 for count in counts.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return \\"NO\\" return \\"YES\\" results = [] for word in words: results.append(is_palindrome_permutation(word)) return results"},{"question":"from typing import List, Tuple def gcd_of_range(P: int, Q: int) -> int: Returns the GCD of all integers from P to Q (both inclusive). >>> gcd_of_range(10, 15) 1 >>> gcd_of_range(5, 5) 5 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases with each test case represented by a tuple of integers (P, Q), returns a list of results where each result is the GCD of all integers from P to Q (both inclusive). >>> process_test_cases([(10, 15), (5, 5)]) [1, 5] >>> process_test_cases([(7, 7), (1, 2)]) [7, 1] pass","solution":"import math def gcd_of_range(P, Q): Returns the GCD of all integers from P to Q (both inclusive). if P == Q: return P return 1 # Because if there are at least two different numbers, their GCD will always be 1 def process_test_cases(test_cases): results = [] for P, Q in test_cases: results.append(gcd_of_range(P, Q)) return results"},{"question":"def final_position(commands: str) -> tuple: Determines the final position of the robot after executing the commands. Args: commands (str): A string consisting of 'U', 'D', 'L', 'R' commands. Returns: tuple: Final coordinates (x, y) of the robot. >>> final_position('UURDDL') (0, 0) >>> final_position('UUUUDDDDRR') (2, 0)","solution":"def final_position(commands): Determines the final position of the robot after executing the commands. Args: commands (str): A string consisting of 'U', 'D', 'L', 'R' commands. Returns: tuple: Final coordinates (x, y) of the robot. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"from datetime import datetime, timedelta def count_urgent_feedbacks(current_time: str, feedbacks: list) -> int: Counts the number of urgent feedbacks submitted in the last 24 hours. Args: current_time (str): The current timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. feedbacks (list): A list of strings, each representing a feedback with severity level and timestamp. Returns: int: The count of urgent feedbacks submitted in the last 24 hours. >>> count_urgent_feedbacks(\\"2023-10-03 14:00:00\\", [ \\"urgent 2023-10-02 14:01:00\\", \\"low 2023-10-02 13:59:59\\", \\"urgent 2023-10-02 13:00:00\\", \\"medium 2023-10-02 15:00:00\\", \\"urgent 2023-10-03 13:59:59\\", \\"urgent 2023-10-03 14:00:00\\" ]) 3 >>> count_urgent_feedbacks(\\"2023-12-01 12:00:00\\", [ \\"low 2023-11-30 12:00:00\\", \\"medium 2023-11-30 12:00:00\\", \\"low 2023-11-30 15:00:00\\", \\"medium 2023-12-01 10:00:00\\" ]) 0 >>> count_urgent_feedbacks(\\"2023-12-01 12:00:00\\", [ \\"urgent 2023-11-30 12:30:00\\", \\"urgent 2023-12-01 11:00:00\\", \\"urgent 2023-11-30 12:00:01\\", \\"urgent 2023-11-30 12:59:59\\" ]) 4 >>> count_urgent_feedbacks(\\"2023-12-01 12:00:00\\", [ \\"urgent 2023-11-30 12:00:01\\", \\"urgent 2023-11-30 12:00:00\\", \\"urgent 2023-12-01 11:59:59\\" ]) 2","solution":"from datetime import datetime, timedelta def count_urgent_feedbacks(current_time, feedbacks): Counts the number of urgent feedbacks submitted in the last 24 hours. Args: current_time (str): The current timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. feedbacks (list): A list of strings, each representing a feedback with severity level and timestamp. Returns: int: The count of urgent feedbacks submitted in the last 24 hours. current_time = datetime.strptime(current_time, \\"%Y-%m-%d %H:%M:%S\\") cutoff_time = current_time - timedelta(hours=24) urgent_count = 0 for feedback in feedbacks: parts = feedback.split(' ', 1) severity = parts[0] timestamp = datetime.strptime(parts[1], \\"%Y-%m-%d %H:%M:%S\\") if severity == \\"urgent\\" and cutoff_time < timestamp <= current_time: urgent_count += 1 return urgent_count"},{"question":"def min_swaps_to_sort(arr): Return the minimum number of swaps required to sort the array. >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 3, 2]) 1 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([7, 1, 3, 2, 4, 5, 6]) 5 >>> min_swaps_to_sort([1, 2, 3, 4, 5, 6]) 0 >>> min_swaps_to_sort([2, 3, 4, 1]) 3","solution":"def min_swaps_to_sort(arr): Return the minimum number of swaps required to sort the array. n = len(arr) arr_pos = [*enumerate(arr)] arr_pos.sort(key=lambda it: it[1]) visited = {i: False for i in range(n)} ans = 0 for i in range(n): if visited[i] or arr_pos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def sum_of_proper_divisors(n: int) -> int: Calculate the sum of all proper divisors of n. >>> sum_of_proper_divisors(6) 6 >>> sum_of_proper_divisors(28) 28 >>> sum_of_proper_divisors(9) 4 >>> sum_of_proper_divisors(12) 16 >>> sum_of_proper_divisors(1) # edge case 0 >>> sum_of_proper_divisors(2) 1 def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(6) False >>> is_prime(28) False >>> is_prime(11) True def process_test_cases(t: int, test_cases: List[int]) -> List[str]: Process t test cases and return the result for each. >>> process_test_cases(3, [6, 28, 9]) [\\"6 NO\\", \\"28 NO\\", \\"4 NO\\"] >>> process_test_cases(2, [12, 2]) [\\"16 NO\\", \\"1 NO\\"]","solution":"def sum_of_proper_divisors(n): Calculate the sum of all proper divisors of n. if n <= 1: return 0 divisors_sum = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i return divisors_sum def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def process_test_cases(t, test_cases): Process t test cases and return the result for each. results = [] for n in test_cases: sum_divisors = sum_of_proper_divisors(n) if is_prime(sum_divisors): results.append(f\\"{sum_divisors} YES\\") else: results.append(f\\"{sum_divisors} NO\\") return results"},{"question":"from typing import List def max_skyline_height_with_parks(N: int, P: int, heights: List[int]) -> int: Returns the maximum height of the skyline with the possibility of parks inserted between buildings. Args: N : int : Number of buildings P : int : Height of the park heights : list : List of integers representing the heights of the buildings Returns: int : Maximum height of the skyline >>> max_skyline_height_with_parks(5, 3, [3, 1, 4, 1, 5]) 5 >>> max_skyline_height_with_parks(4, 2, [4, 4, 4, 4]) 4 >>> max_skyline_height_with_parks(4, 10, [1, 2, 3, 4]) 4 >>> max_skyline_height_with_parks(3, 0, [1, 2, 3]) 3 >>> max_skyline_height_with_parks(5, 2, [5, 4, 3, 2, 1]) 5 >>> max_skyline_height_with_parks(5, 7, [1, 2, 3, 4, 5]) 5 >>> max_skyline_height_with_parks(6, 10, [2, 2, 2, 2, 2, 2]) 2 >>> max_skyline_height_with_parks(1, 1, [1]) 1","solution":"def max_skyline_height_with_parks(N, P, heights): Returns the maximum height of the skyline with the possibility of parks inserted between buildings. Args: N : int : Number of buildings P : int : Height of the park heights : list : List of integers representing the heights of the buildings Returns: int : Maximum height of the skyline max_height = max(heights) # Initial maximum height, considering only the buildings for i in range(N - 1): park_height = min(heights[i], heights[i + 1]) max_height = max(max_height, min(P, park_height)) return max_height"},{"question":"def longestNonDecreasing(temps: List[int]) -> int: Find the longest stretch of days with non-decreasing temperatures. >>> longestNonDecreasing([1, 2, 2, 3, 2, 4, 5, 5]) 4 >>> longestNonDecreasing([5, 4, 3, 2, 1]) 1","solution":"def longestNonDecreasing(temps): Finds the longest stretch of days with non-decreasing temperatures. Parameters: temps: list[int]: list of daily highest temperatures recorded. Returns: int: the length of the longest stretch of non-decreasing temperatures. if not temps: return 0 max_length = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] >= temps[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def lexicographically_smallest_binary_string(N: int, S: str) -> str: Given a binary string S of length N, replace every occurrence of '00' with '01' and every occurrence of '11' with '10' repeatedly to obtain the lexicographically smallest string. Args: N (int): Length of the binary string. S (str): Binary string of length N. Returns: str: Lexicographically smallest binary string. Examples: >>> lexicographically_smallest_binary_string(5, \\"11000\\") '10010' >>> lexicographically_smallest_binary_string(4, \\"1010\\") '1010' >>> lexicographically_smallest_binary_string(6, \\"111111\\") '101010' >>> lexicographically_smallest_binary_string(1, \\"0\\") '0' >>> lexicographically_smallest_binary_string(1, \\"1\\") '1' >>> lexicographically_smallest_binary_string(10, \\"0101010101\\") '0101010101' >>> lexicographically_smallest_binary_string(5, \\"00000\\") '01010' >>> lexicographically_smallest_binary_string(5, \\"11111\\") '10101'","solution":"def lexicographically_smallest_binary_string(N, S): Given a binary string S of length N, replace every occurrence of '00' with '01' and every occurrence of '11' with '10' repeatedly to obtain the lexicographically smallest string. Params: N: int - length of the binary string S: str - binary string of length N Returns: str - lexicographically smallest binary string result = [] i = 0 while i < N: if i+1 < N and S[i] == '0' and S[i+1] == '0': result.append('0') result.append('1') i += 2 elif i+1 < N and S[i] == '1' and S[i+1] == '1': result.append('1') result.append('0') i += 2 else: result.append(S[i]) i += 1 return ''.join(result)"},{"question":"def smallest_subarray_with_k_distinct(arr, k): You are given an array of n integers and an integer k. You need to find out the smallest subarray that contains at least k distinct integers. If no such subarray exists, return -1. >>> smallest_subarray_with_k_distinct([1, 2, 4, 2, 2, 3, 1], 3) 3 >>> smallest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) 5 >>> smallest_subarray_with_k_distinct([1, 1, 1, 1, 1, 1, 1, 1], 4) -1 >>> smallest_subarray_with_k_distinct([1, 2, 3], 4) -1 >>> smallest_subarray_with_k_distinct([1], 1) 1 >>> smallest_subarray_with_k_distinct([1, 1, 1, 1], 1) 1 >>> smallest_subarray_with_k_distinct([1, 1, 1, 1], 2) -1 >>> smallest_subarray_with_k_distinct([1, 2, 3, 4, 5, 6], 6) 6 >>> smallest_subarray_with_k_distinct([1], 1) 1","solution":"def smallest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if k > n: return -1 left = 0 right = 0 min_length = n + 1 count_distinct = 0 freq_map = defaultdict(int) while right < n: if freq_map[arr[right]] == 0: count_distinct += 1 freq_map[arr[right]] += 1 right += 1 while count_distinct >= k: min_length = min(min_length, right - left) freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: count_distinct -= 1 left += 1 return min_length if min_length <= n else -1"},{"question":"def hasUniqueDigits(N: int) -> str: Determines whether the input integer N has all unique digits or not. >>> hasUniqueDigits(12345) \\"Yes\\" >>> hasUniqueDigits(112345) \\"No\\" >>> hasUniqueDigits(1111111) \\"No\\" >>> hasUniqueDigits(7) \\"Yes\\" >>> hasUniqueDigits(9876543210) \\"Yes\\" >>> hasUniqueDigits(99876543210) \\"No\\" >>> hasUniqueDigits(1023456789) \\"Yes\\" >>> hasUniqueDigits(1234567890) \\"Yes\\" >>> hasUniqueDigits(1) \\"Yes\\" >>> hasUniqueDigits(10023) \\"No\\"","solution":"def hasUniqueDigits(N): Determines whether the input integer N has all unique digits or not. Parameters: N (int): The input positive integer Returns: str: \\"Yes\\" if N has all unique digits, otherwise \\"No\\" digit_seen = [False] * 10 # Tracks the occurrence of each digit (0-9) while N > 0: digit = N % 10 # Extract the last digit if digit_seen[digit]: # Check if this digit was seen before return \\"No\\" digit_seen[digit] = True # Mark this digit as seen N //= 10 # Remove the last digit from N return \\"Yes\\""},{"question":"from typing import List def max_difference(arr: List[int]) -> int: Given an array of unique integers, return the largest difference between any two elements where the larger element comes after the smaller one. Examples: >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([7, 9, 5, 6, 3, 2]) 2 >>> max_difference([1, 2, 3, 4, 5]) 4 >>> max_difference([5, 4, 3, 2, 1]) -1 >>> max_difference([1, 2, 90, 10, 110]) 109 >>> max_difference([1, 100]) 99 >>> max_difference([-10, -20, -30, -25, -15, -5]) 25 >>> max_difference(list(range(-5000, 5001))) 10000","solution":"from typing import List def max_difference(arr: List[int]) -> int: Returns the largest difference between any two elements where the larger element comes after the smaller one. if not arr or len(arr) < 2: return 0 min_element = arr[0] max_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - min_element > max_diff: max_diff = arr[i] - min_element if arr[i] < min_element: min_element = arr[i] return max_diff"},{"question":"def expected_books_remain(n, m, k, shelves): Calculate the expected number of books that remain in their original position after k disturbance days. n: int - Number of shelves m: int - Number of books per shelf k: int - Number of disturbance days shelves: List[List[str]] - Initial state of the books on the shelves (not actually used in calculations) pass ''' Unit Test: def test_expected_books_remain_one_day(): assert expected_books_remain(3, 4, 1, [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L']]) == 3 def test_expected_books_remain_multiple_days(): assert expected_books_remain(2, 3, 5, [['A', 'B', 'C'], ['D', 'E', 'F']]) == 2 def test_expected_books_remain_no_disturbance(): assert expected_books_remain(4, 6, 0, [['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P', 'Q', 'R'], ['S', 'T', 'U', 'V', 'W', 'X']]) == 4 def test_expected_books_remain_minimum_values(): assert expected_books_remain(1, 1, 1, [['A']]) == 1 def test_expected_books_remain_maximum_disturbance_days(): assert expected_books_remain(5, 10, 1000, [['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']]*5) == 5 '''","solution":"def expected_books_remain(n, m, k, shelves): Calculate the expected number of books that remain in their original position after k disturbance days. n: int - Number of shelves m: int - Number of books per shelf k: int - Number of disturbance days shelves: List[List[str]] - Initial state of the books on the shelves (not actually used in calculations) # Since after disturbances, each book has 1/m probability of remaining in the same position, # and there are m books per shelf, independently for each shelf. # We expect exactly 1 book to remain in the same position per shelf. # So, for n shelves, the expected number is just n. return n"},{"question":"def rotate_pattern(pattern): Rotates the given pattern 90 degrees clockwise. >>> rotate_pattern([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) [[1, 0, 1], [0, 1, 0], [1, 0, 1]] >>> rotate_pattern([[1, 0, 0, 1], [0, 1, 1, 0]]) [[0, 1], [1, 0], [1, 0], [0, 1]] pass def display_patterns(original, rotated): Displays the original and rotated patterns side by side. >>> display_patterns([[1, 0, 1], [0, 1, 0], [1, 0, 1]], [[1, 0, 1], [0, 1, 0], [1, 0, 1]]) '1 0 1 1 0 1n0 1 0 0 1 0n1 0 1 1 0 1' >>> display_patterns([[1, 0, 0, 1], [0, 1, 1, 0]], [[0, 1], [1, 0], [1, 0], [0, 1]]) '1 0 0 1 0 1n0 1 1 0 1 0' pass def main(input_data): Process input data, rotate patterns and output the results as specified. >>> main('3 3n1 0 1n0 1 0n1 0 1n2 4n1 0 0 1n0 1 1 0n0 0n') '1 0 1 1 0 1n0 1 0 0 1 0n1 0 1 1 0 1nn1 0 0 1 0 1n0 1 1 0 1 0' pass","solution":"def rotate_pattern(pattern): Rotates the given pattern 90 degrees clockwise. M = len(pattern) N = len(pattern[0]) # Create a new matrix for the rotated pattern rotated = [[0] * M for _ in range(N)] # Fill in the rotated matrix for r in range(M): for c in range(N): rotated[c][M - 1 - r] = pattern[r][c] return rotated def display_patterns(original, rotated): Displays the original and rotated patterns side by side. M = len(original) N = len(rotated) output = [] for r in range(M): original_row = ' '.join(map(str, original[r])) if r < N: rotated_row = ' '.join(map(str, rotated[r])) output.append(f\\"{original_row} {rotated_row}\\") else: output.append(original_row) return 'n'.join(output) def main(input_data): Process input data, rotate patterns and output the results as specified. input_lines = input_data.split('n') index = 0 output = [] while index < len(input_lines): line = input_lines[index].strip() if line == '0 0': break M, N = map(int, line.split()) pattern = [] for i in range(M): index += 1 pattern_line = list(map(int, input_lines[index].strip().split())) pattern.append(pattern_line) rotated_pattern = rotate_pattern(pattern) output.append(display_patterns(pattern, rotated_pattern)) index += 1 return 'nn'.join(output)"},{"question":"from typing import List def max_difference(arr: List[int]) -> int: Given an integer array, find and return the maximum difference between any two elements such that the larger element comes after the smaller element in the array. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 # (10-2) >>> max_difference([7, 9, 5, 6, 3, 2]) == 2 # (9-7) >>> max_difference([5, 4, 3, 2, 1]) == -1 # No valid pair exists >>> max_difference([1, 2, 90, 10, 110]) == 109 # (110-1) pass","solution":"from typing import List def max_difference(arr: List[int]) -> int: if not arr or len(arr) < 2: return -1 min_value = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_value: max_diff = max(max_diff, arr[i] - min_value) min_value = min(min_value, arr[i]) return max_diff"},{"question":"def cyclic_shift(s: str, n: int) -> str: Perform n cyclic shifts on the string s and determine the resulting string. >>> cyclic_shift(\\"abcde\\", 2) 'deabc' >>> cyclic_shift(\\"helloworld\\", 1000000000000000000) 'helloworld' pass # Unit Tests def test_cyclic_shift_basic(): assert cyclic_shift(\\"abcde\\", 2) == \\"deabc\\" def test_cyclic_shift_no_shift(): assert cyclic_shift(\\"helloworld\\", 1000000000000000000) == \\"helloworld\\" def test_cyclic_shift_full_cycle(): assert cyclic_shift(\\"abcdef\\", 6) == \\"abcdef\\" def test_cyclic_shift_small_full_cycle(): assert cyclic_shift(\\"a\\", 1) == \\"a\\" def test_cyclic_shift_more_than_length(): assert cyclic_shift(\\"abcde\\", 7) == \\"deabc\\" # 7 % 5 == 2 def test_cyclic_shift_single_character(): assert cyclic_shift(\\"a\\", 1) == \\"a\\" def test_cyclic_shift_large_n(): assert cyclic_shift(\\"helloworld\\", 12345678901234567890) == \\"helloworld\\" # because length is 10, and 12345678901234567890 % 10 == 0","solution":"def cyclic_shift(s, n): Returns the result string after performing n cyclic shifts on s. length = len(s) n = n % length # Effective number of shifts return s[-n:] + s[:-n]"},{"question":"from itertools import combinations from typing import List, Tuple def min_difference(t: int, testcases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible absolute difference between the total skill levels of the two teams. >>> min_difference(3, [(4, [1, 2, 3, 4]), (3, [10, 20, 15]), (5, [2, 2, 2, 2, 2])]) [0, 5, 2] >>> min_difference(1, [(1, [10])]) [10] >>> min_difference(1, [(2, [5, 5])]) [0] >>> min_difference(1, [(2, [5, 10])]) [5] >>> min_difference(1, [(5, [1, 3, 5, 9, 11])]) [1] >>> min_difference(1, [(6, [1, 2, 3, 8, 7, 10])]) [1]","solution":"from itertools import combinations def min_difference(t, testcases): def calculate_min_difference(n, skills): total_sum = sum(skills) half_sum = total_sum // 2 min_diff = float('inf') for i in range(n//2 + 1): for comb in combinations(skills, i): current_sum = sum(comb) diff = abs(total_sum - 2 * current_sum) if diff < min_diff: min_diff = diff return min_diff results = [] for i in range(t): n = testcases[i][0] skills = testcases[i][1] results.append(calculate_min_difference(n, skills)) return results"},{"question":"def closest_to_fifty(tricks: List[int]) -> int: Given a list of trick difficulty levels, returns the total difficulty closest to 50. >>> closest_to_fifty([50]) 50 >>> closest_to_fifty([30]) 30 >>> closest_to_fifty([70]) 70 >>> closest_to_fifty([25, 25]) 50 >>> closest_to_fifty([20, 15, 10, 30, 25]) 50 >>> closest_to_fifty([40, 10, 35, 5]) 50 >>> closest_to_fifty([]) 0 >>> closest_to_fifty([1, 2, 3, 4, 5]) 15","solution":"def closest_to_fifty(tricks): Given a list of trick difficulty levels, returns the total difficulty closest to 50. target = 50 m = len(tricks) # Using dynamic programming to solve the closest sum to 50 problem # Create a set to store the possible sums possible_sums = {0} for trick in tricks: # Add the current trick's difficulty to each of the existing sums in possible_sums new_sums = {current_sum + trick for current_sum in possible_sums} possible_sums.update(new_sums) closest_sum = None for possible_sum in possible_sums: if closest_sum is None or abs(possible_sum - target) < abs(closest_sum - target) or (abs(possible_sum - target) == abs(closest_sum - target) and possible_sum > closest_sum): closest_sum = possible_sum return closest_sum"},{"question":"def final_coordinates(T: int, commands: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Calculate the final coordinates of each car after following its respective commands. Args: T (int): The number of cars. commands (List[Tuple[int, int, int]]): A list of tuples, each containing the initial (x, y) coordinates and direction (theta) of each car. Returns: List[Tuple[int, int]]: A list of tuples representing the final coordinates of each car. >>> final_coordinates(5, [(1, 2, 0), (3, 4, 1), (-1, -2, 2), (5, 5, 3), (0, 0, 1)]) [(2, 2), (3, 5), (-2, -2), (5, 4), (0, 1)] >>> final_coordinates(3, [(0, 0, 0), (-1, -1, 2), (2, 3, 1)]) [(1, 0), (-2, -1), (2, 4)] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, int]]]: Parse the standard input format to extract the number of cars and their respective commands. Args: input_str (str): The input string containing the number of cars and their commands. Returns: Tuple[int, List[Tuple[int, int, int]]]: The number of cars and a list of commands. >>> parse_input(\\"5n1 2 0n3 4 1n-1 -2 2n5 5 3n0 0 1n\\") (5, [(1, 2, 0), (3, 4, 1), (-1, -2, 2), (5, 5, 3), (0, 0, 1)]) >>> parse_input(\\"3n0 0 0n-1 -1 2n2 3 1n\\") (3, [(0, 0, 0), (-1, -1, 2), (2, 3, 1)])","solution":"def final_coordinates(T, commands): results = [] for command in commands: x, y, theta = command if theta == 0: # Move right x += 1 elif theta == 1: # Move up y += 1 elif theta == 2: # Move left x -= 1 elif theta == 3: # Move down y -= 1 results.append((x, y)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) commands = [] for i in range(1, T + 1): x, y, theta = map(int, lines[i].split()) commands.append((x, y, theta)) return T, commands"},{"question":"def are_timestamps_increasing(timestamps: str) -> bool: Verify if all event timestamps are in strictly increasing order. Args: timestamps (str): A space-delimited string of timestamps in \\"HH:MM\\" format. Returns: bool: True if all timestamps are in strictly increasing order, False otherwise. >>> are_timestamps_increasing(\\"09:00 10:00 11:00\\") True >>> are_timestamps_increasing(\\"12:30 12:45 12:40\\") False","solution":"def are_timestamps_increasing(timestamps): Returns True if all timestamps are in strictly increasing order, False otherwise. Args: timestamps (str): A space-delimited string of timestamps in \\"HH:MM\\" format. Returns: bool: True if timestamps are in strictly increasing order, False otherwise. times = timestamps.split() for i in range(len(times) - 1): if times[i] >= times[i + 1]: return False return True"},{"question":"def mergeArrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. >>> mergeArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([4, 5, 6], [1, 2, 3]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeArrays([1, 2, 3], []) [1, 2, 3] >>> mergeArrays([], []) [] >>> mergeArrays([1, 2, 2], [2, 3, 4]) [1, 2, 2, 2, 3, 4] >>> mergeArrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> mergeArrays([-3, -2, -1], [-5, -4, 0]) [-5, -4, -3, -2, -1, 0] >>> mergeArrays([-10, -5, 0], [-6, -4, -2, 3]) [-10, -6, -5, -4, -2, 0, 3]","solution":"def mergeArrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): The first sorted list of integers. arr2 (list): The second sorted list of integers. Returns: list: A sorted list containing all elements from arr1 and arr2. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append any remaining elements from arr1 while i < len(arr1): merged.append(arr1[i]) i += 1 # Append any remaining elements from arr2 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def count_ways_to_reach_distance(D): Function to count distinct ways to reach exactly D units by stepping 1 or 2 units at a time. >>> count_ways_to_reach_distance(4) 5 >>> count_ways_to_reach_distance(7) 21","solution":"def count_ways_to_reach_distance(D): Function to count distinct ways to reach exactly D units by stepping 1 or 2 units at a time. if D <= 0: return 0 if D == 1: return 1 if D == 2: return 2 # Initialize dp array dp = [0] * (D + 1) dp[1] = 1 dp[2] = 2 for i in range(3, D + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[D]"},{"question":"def twoSum(arr, target): Returns indices of the two numbers such that they add up to target. >>> twoSum([2, 7, 11, 15], 9) [1, 2] >>> twoSum([1, 2, 3, 4], 8) -1","solution":"def twoSum(arr, target): Returns indices of the two numbers such that they add up to target. seen = {} for i, num in enumerate(arr): diff = target - num if diff in seen: return [seen[diff] + 1, i + 1] seen[num] = i return -1"},{"question":"def generate_triangle_patterns(d, heights): Generates downward angle triangle pattern for given heights. Parameters: d (int): Number of datasets. heights (list of int): List containing the height (n) of each triangle. Returns: str: String containing all the triangle patterns. alphabet = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" results = [] for height in heights: pattern = [] max_width = height for i in range(1, height + 1): row = alphabet[:i] right_aligned_row = row.rjust(max_width) pattern.append(right_aligned_row) results.append(\\"n\\".join(pattern)) return \\"nn\\".join(results) def process_input(input_text): Processes the text input to extract the number of datasets and respective heights lines = input_text.strip().split(\\"n\\") d = int(lines[0]) heights = [int(lines[i]) for i in range(1, d + 1)] return d, heights def main(input_text): d, heights = process_input(input_text) return generate_triangle_patterns(d, heights) # Example usage and test cases: input_text = \\"2n5n4\\" print(main(input_text))","solution":"def generate_triangle_patterns(d, heights): Generates downward angle triangle pattern for given heights. Parameters: d (int): Number of datasets. heights (list of int): List containing the height (n) of each triangle. Returns: str: String containing all the triangle patterns. alphabet = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" results = [] for height in heights: pattern = [] max_width = height for i in range(1, height + 1): row = alphabet[:i] right_aligned_row = row.rjust(max_width) pattern.append(right_aligned_row) results.append(\\"n\\".join(pattern)) return \\"nn\\".join(results) def process_input(input_text): Processes the text input to extract the number of datasets and respective heights lines = input_text.strip().split(\\"n\\") d = int(lines[0]) heights = [int(lines[i]) for i in range(1, d + 1)] return d, heights def main(input_text): d, heights = process_input(input_text) return generate_triangle_patterns(d, heights)"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Find the k-th largest element in the list of distinct integers. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([7, 10, 4, 3, 20, 15], 3) 10 >>> find_kth_largest([50, 30, 20, 70, 60], 4) 30","solution":"import random def quick_select(nums, low, high, k): pivot = nums[high] i = low for j in range(low, high): if nums[j] > pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[high] = nums[high], nums[i] if i == k: return nums[i] elif i < k: return quick_select(nums, i + 1, high, k) else: return quick_select(nums, low, i - 1, k) def find_kth_largest(nums, k): return quick_select(nums, 0, len(nums) - 1, k - 1)"},{"question":"def optimal_capital(n: int, roads: List[Tuple[int, int]]) -> int: Determine the optimal capital city for the given cities and roads. There are n cities numbered from 1 to n. There are n-1 bidirectional roads connecting the cities. The task is to find the city that can be chosen as the capital such that the maximum distance from the capital to any other city is minimized. Args: n (int): The number of cities. roads (List[Tuple[int, int]]): A list of tuples representing roads between cities. Returns: int: The number of the city that should be chosen as the capital. >>> optimal_capital(4, [(1, 2), (2, 3), (2, 4)]) == 2 >>> optimal_capital(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) in {1} from typing import List, Tuple def test_example_case(): assert optimal_capital(4, [(1, 2), (2, 3), (2, 4)]) == 2 def test_case_single_chain(): assert optimal_capital(3, [(1, 2), (2, 3)]) == 2 def test_case_star(): assert optimal_capital(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) in {1} def test_case_multiple_optimal(): result = optimal_capital(6, [(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)]) assert result in {3, 4} def test_case_complex_structure(): assert optimal_capital(7, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (6, 7)]) == 4","solution":"import collections def optimal_capital(n, roads): def bfs(start): distances = [-1] * (n + 1) queue = collections.deque([start]) distances[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return distances graph = collections.defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) min_max_distance = float('inf') best_city = -1 for city in range(1, n+1): distances = bfs(city) max_distance = max(distances[1:]) if max_distance < min_max_distance: min_max_distance = max_distance best_city = city return best_city"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a subarray of non-negative integers. >>> max_subarray_sum([1, 2, 3, -2, 5]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) 0 >>> max_subarray_sum([1, 2, 3, 0, 4, 5]) 15","solution":"def max_subarray_sum(arr): Returns the maximum sum of a subarray of non-negative integers max_sum = 0 current_sum = 0 for num in arr: if num >= 0: current_sum += num else: current_sum = 0 if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def longest_even_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements are even. >>> longest_even_subarray([1, 2, 4, 6, 1, 2]) == 3 >>> longest_even_subarray([1, 3, 5, 7]) == 0 >>> longest_even_subarray([2, 4, 6, 8]) == 4 >>> longest_even_subarray([2, 2, 2, 2, 1, 2]) == 4 pass # Your implementation here","solution":"def longest_even_subarray(arr): Returns the length of the longest contiguous subarray where all elements are even. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def text_editor(operations: List[str]) -> str: Simulates undo functionality for a series of text editing operations. The operations can be 'add <char>', 'delete', or 'undo'. >>> text_editor([\\"add a\\", \\"add b\\", \\"add c\\", \\"delete\\", \\"undo\\", \\"undo\\"]) == \\"ab\\" >>> text_editor([\\"add a\\", \\"add b\\", \\"undo\\", \\"undo\\", \\"add c\\"]) == \\"c\\" >>> text_editor([\\"add a\\", \\"delete\\", \\"undo\\"]) == \\"a\\" >>> text_editor([\\"add a\\", \\"add b\\", \\"add c\\", \\"undo\\", \\"undo\\", \\"undo\\", \\"add d\\"]) == \\"d\\" >>> text_editor([\\"delete\\", \\"delete\\", \\"undo\\", \\"add a\\"]) == \\"a\\" >>> text_editor([]) == \\"\\" Args: operations (List[str]): List of operations to be applied in order. Returns: str: The resulting text after all operations have been processed.","solution":"def text_editor(operations): text = [] history = [] for operation in operations: if operation.startswith(\\"add \\"): char = operation.split()[1] text.append(char) history.append((\\"add\\", char)) elif operation == \\"delete\\": if text: deleted_char = text.pop() history.append((\\"delete\\", deleted_char)) elif operation == \\"undo\\": if history: last_action, char = history.pop() if last_action == \\"add\\": text.pop() elif last_action == \\"delete\\": text.append(char) return ''.join(text)"},{"question":"def max_sum_after_modification(arr: List[int]) -> int: Compute the maximum sum of any contiguous subarray after performing at most one modification. >>> max_sum_after_modification([1, 2, -3, 4, 5]) 12 >>> max_sum_after_modification([10]) 10 >>> max_sum_after_modification([-10]) 0 >>> max_sum_after_modification([1, 2, 3, 4, 5]) 15 >>> max_sum_after_modification([5, 4, 3, 2, 1]) 15 >>> max_sum_after_modification([-1, -2, -3, -4, -5]) 0 >>> max_sum_after_modification([-1, 2, 3, -2, 5]) 10 >>> max_sum_after_modification([2, -1, 2, 3, -5, 4]) 10","solution":"def max_sum_after_modification(arr): n = len(arr) if n == 1: return max(arr[0], 0) # Arrays to store the maximum subarray sum ending at each index max_end_here = [0] * n max_end_here_with_mod = [0] * n # Kadane's algorithm to find the maximum subarray sum max_end_here[0] = arr[0] max_end_here_with_mod[0] = 0 # Start with no modification total_max = arr[0] for i in range(1, n): # Maximum subarray sum ending at i without modification max_end_here[i] = max(arr[i], max_end_here[i - 1] + arr[i]) # Maximum subarray sum ending at i with exactly one modification max_end_here_with_mod[i] = max(arr[i] + max_end_here_with_mod[i - 1], # Consider modification at the current position 0 if i == 1 else max_end_here[i - 2] + arr[i]) # Update the total max sum considering both scenarios total_max = max(total_max, max_end_here[i], max_end_here_with_mod[i]) return total_max # Example usage input_data = [1, 2, -3, 4, 5] print(max_sum_after_modification(input_data)) # Output should be 12"},{"question":"def fibonacci_branch_count(N): Calculate the number of branches on the Fibonacci Tree immediately before time step N. >>> fibonacci_branch_count(0) 0 >>> fibonacci_branch_count(1) 0 >>> fibonacci_branch_count(4) 2 def process_test_cases(T, cases): Process multiple test cases and return a list of results for the number of branches on the Fibonacci Tree immediately before each given time step. >>> process_test_cases(3, [0, 1, 4]) [0, 0, 2] >>> process_test_cases(4, [2, 3, 5, 6]) [1, 1, 3, 5] from solution import fibonacci_branch_count, process_test_cases def test_fibonacci_branch_count(): assert fibonacci_branch_count(0) == 0 assert fibonacci_branch_count(1) == 0 assert fibonacci_branch_count(2) == 1 assert fibonacci_branch_count(3) == 1 assert fibonacci_branch_count(4) == 2 assert fibonacci_branch_count(5) == 3 assert fibonacci_branch_count(6) == 5 assert fibonacci_branch_count(10) == 34 def test_process_test_cases(): assert process_test_cases(3, [0, 1, 4]) == [0, 0, 2] assert process_test_cases(4, [2, 3, 5, 6]) == [1, 1, 3, 5] assert process_test_cases(2, [10, 15]) == [34, 377]","solution":"def fibonacci_branch_count(N): Calculate the number of branches on the Fibonacci Tree immediately before time step N. if N <= 1: return 0 a, b = 0, 0 for _ in range(2, N + 1): a, b = b, a + b if b == 0: b = 1 return b def process_test_cases(T, cases): results = [] for N in cases: results.append(fibonacci_branch_count(N)) return results"},{"question":"def can_place_obstacles(t: int, test_cases: List[Tuple[Tuple[int, int, int], List[Tuple[int, int]]]]) -> List[str]: Determine if it’s possible to place the obstacles on the grid such that each constraint is satisfied and no two obstacles share a row or column. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[Tuple[int, int]]]]): List of test cases where each test case contains the grid dimensions and constraints. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_place_obstacles(2, [((3, 3, 2), [(1, 1), (2, 2)]), ((3, 3, 3), [(1, 1), (2, 2), (2, 3)])]) ['YES', 'NO'] >>> can_place_obstacles(1, [((3, 3, 0), [])]) ['YES'] >>> can_place_obstacles(1, [((3, 3, 1), [(1, 1)])]) ['YES'] >>> can_place_obstacles(1, [((3, 3, 2), [(1, 1), (1, 2)])]) ['NO'] >>> can_place_obstacles(2, [((4, 4, 3), [(1, 1), (2, 2), (3, 3)]), ((4, 4, 4), [(1, 1), (2, 1), (3, 3), (4, 4)])]) ['YES', 'NO']","solution":"def can_place_obstacles(t, test_cases): results = [] for i in range(t): n, m, k = test_cases[i][0] constraints = test_cases[i][1] if k == 0: results.append(\\"YES\\") continue rows_set = set() cols_set = set() valid = True for r, c in constraints: if r in rows_set or c in cols_set: valid = False break rows_set.add(r) cols_set.add(c) if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def does_string_meet_conditions(s: str, p: List[int]) -> bool: Determine whether the string \`s\` meets the conditions described by array \`p\` for all substrings from length 1 to the length of \`s\`. >>> does_string_meet_conditions(\\"abac\\", [1, 2, 2, 3]) True >>> does_string_meet_conditions(\\"abac\\", [1, 3, 2, 3]) False >>> does_string_meet_conditions(\\"aaa\\", [1, 1, 1]) True def test_does_string_meet_conditions_example_1(): assert does_string_meet_conditions(\\"abac\\", [1, 2, 2, 3]) == True def test_does_string_meet_conditions_example_2(): assert does_string_meet_conditions(\\"abac\\", [1, 3, 2, 3]) == False def test_does_string_meet_conditions_example_3(): assert does_string_meet_conditions(\\"aaa\\", [1, 1, 1]) == True def test_does_string_meet_conditions_single_char(): assert does_string_meet_conditions(\\"a\\", [1]) == True def test_does_string_meet_conditions_all_unique_chars(): assert does_string_meet_conditions(\\"abcd\\", [1, 2, 3, 4]) == True def test_does_string_meet_conditions_all_same_chars(): assert does_string_meet_conditions(\\"aaaa\\", [1, 1, 1, 1]) == True def test_does_string_meet_conditions_mismatched(): assert does_string_meet_conditions(\\"abcd\\", [1, 2, 3, 3]) == False def test_does_string_meet_conditions_empty_string(): assert does_string_meet_conditions(\\"\\", []) == True","solution":"def does_string_meet_conditions(s, p): Determine whether the string \`s\` meets the conditions described by array \`p\` for all substrings from length 1 to the length of \`s\`. Args: s (str): String of lowercase English letters. p (list): List of integers where each element p[i] indicates the number of unique characters in the substring corresponding to s[:i+1]. Returns: bool: True if the string meets the conditions for all substrings, otherwise False. for i in range(len(s)): if len(set(s[:i+1])) != p[i]: return False return True"},{"question":"def reduce_array(arr): Reduces the array by compressing contiguous subarrays of the same value. :param arr: List[int] - array of integers :return: List[int] - reduced array after compression >>> reduce_array([1, 1, 2, 2, 2, 3, 3]) [1, 2, 3] >>> reduce_array([4, 4, 4, 4, 4]) [4] >>> reduce_array([1, 1, 2, 3, 3, 3, 2, 2]) [1, 2, 3, 2] pass def emilias_algorithm(T, test_cases): Applies Emilia's sequence transformation algorithm to multiple test cases. :param T: int - number of test cases :param test_cases: List[Tuple[int, List[int]]] - list of test cases where each test case is a tuple of an integer and an array :return: List[List[int]] - list of reduced arrays for each test case >>> emilias_algorithm(3, [(7, [1, 1, 2, 2, 2, 3, 3]), (5, [4, 4, 4, 4, 4]), (8, [1, 1, 2, 3, 3, 3, 2, 2])]) [[1, 2, 3], [4], [1, 2, 3, 2]] pass","solution":"def reduce_array(arr): n = len(arr) reduced_arr = [] i = 0 while i < n: current_value = arr[i] j = i while j < n and arr[j] == current_value: j += 1 reduced_arr.append(current_value) i = j return reduced_arr def emilias_algorithm(T, test_cases): results = [] for case in test_cases: n, arr = case while True: new_arr = reduce_array(arr) if new_arr == arr: break arr = new_arr results.append(new_arr) return results"},{"question":"def compute_net_balance(transactions): Computes the net balance after processing all transactions. Args: transactions (list of tuples): A list of tuples, where each tuple contains an integer amount and a string type (\\"credit\\" or \\"debit\\"). Returns: int: The net balance after processing all transactions. # Your implementation here from solution import compute_net_balance def test_single_credit_transaction(): transactions = [(100, \\"credit\\")] assert compute_net_balance(transactions) == 100 def test_single_debit_transaction(): transactions = [(50, \\"debit\\")] assert compute_net_balance(transactions) == -50 def test_multiple_transactions(): transactions = [(100, \\"credit\\"), (50, \\"debit\\"), (10, \\"credit\\")] assert compute_net_balance(transactions) == 60 def test_alternating_transactions(): transactions = [(200, \\"credit\\"), (100, \\"debit\\"), (50, \\"debit\\"), (30, \\"credit\\")] assert compute_net_balance(transactions) == 80 def test_all_credits(): transactions = [(50, \\"credit\\"), (150, \\"credit\\"), (200, \\"credit\\")] assert compute_net_balance(transactions) == 400 def test_all_debits(): transactions = [(30, \\"debit\\"), (20, \\"debit\\"), (10, \\"debit\\")] assert compute_net_balance(transactions) == -60 def test_mixed_transactions(): transactions = [(500, \\"credit\\"), (200, \\"debit\\"), (300, \\"debit\\"), (100, \\"credit\\")] assert compute_net_balance(transactions) == 100","solution":"def compute_net_balance(transactions): Computes the net balance after processing all transactions. Args: transactions (list of tuples): A list of tuples, where each tuple contains an integer amount and a string type (\\"credit\\" or \\"debit\\"). Returns: int: The net balance after processing all transactions. net_balance = 0 for amount, t_type in transactions: if t_type == \\"credit\\": net_balance += amount elif t_type == \\"debit\\": net_balance -= amount return net_balance"},{"question":"def find_min_vertex_cover(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Determine the minimum number of streetlights needed and their placement. >>> find_min_vertex_cover(4, 3, [(1, 2), (2, 3), (3, 4)]) (2, [2, 3]) >>> find_min_vertex_cover(2, 1, [(1, 2)]) (1, [1]) or (1, [2]) >>> find_min_vertex_cover(3, 2, [(1, 2), (2, 3)]) (1, [2])","solution":"def find_min_vertex_cover(n, m, edges): from collections import defaultdict graph = defaultdict(set) # Build the graph representation: adjacency list for u, v in edges: graph[u].add(v) graph[v].add(u) # Initialize the set to hold vertex cover vertex_cover = set() while edges: # Pick the node with the highest degree u = max(graph.keys(), key=lambda x: len(graph[x])) # Add this node to the vertex cover vertex_cover.add(u) # Remove all edges connected to this node for v in graph[u]: if (u, v) in edges: edges.remove((u, v)) if (v, u) in edges: edges.remove((v, u)) graph[v].remove(u) # Remove the node from the graph graph.pop(u) return len(vertex_cover), sorted(vertex_cover) # Example usage: n = 4 m = 3 edges = [(1, 2), (2, 3), (3, 4)] print(find_min_vertex_cover(n, m, edges)) # Output should be (2, [2, 3])"},{"question":"def find_winner(n: int, contestants: List[Tuple[int, int]]) -> Tuple[int, int]: Finds the winner of the competition based on the shortest cooking time. :param n: Number of contestants :param contestants: List of tuples where each tuple contains (contestant_number, time_taken) :returns: Tuple of (winner_contestant_number, winner_time) >>> find_winner(5, [(1, 300), (2, 250), (3, 250), (4, 400), (5, 350)]) (2, 250) >>> find_winner(1, [(1, 300)]) (1, 300) >>> find_winner(3, [(1, 100), (2, 100), (3, 200)]) (1, 100) >>> find_winner(4, [(1, 400), (2, 250), (3, 320), (4, 250)]) (2, 250) >>> contestants = [(i, 1440 - i) for i in range(1, 51)] >>> find_winner(50, contestants) (50, 1390)","solution":"def find_winner(n, contestants): Finds the winner of the competition based on the shortest cooking time. :param n: Number of contestants :param contestants: List of tuples where each tuple contains (contestant_number, time_taken) :returns: Tuple of (winner_contestant_number, winner_time) # Initialize the winner to the first contestant winner = contestants[0] # Iterate through the contestants to find the one with the minimum time for contestant in contestants: if (contestant[1] < winner[1]) or (contestant[1] == winner[1] and contestant[0] < winner[0]): winner = contestant return winner"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a height-balanced binary search tree (BST). >>> bst = sorted_array_to_bst([-10, -3, 0, 5, 9]) >>> traversal = pre_order_traversal(bst) >>> set(traversal) == {0, -3, 9, -10, 5} True >>> bst = sorted_array_to_bst([1, 3]) >>> traversal = pre_order_traversal(bst) >>> set(traversal) == {1, 3} or set(traversal) == {3, 1} True >>> bst = sorted_array_to_bst([1]) >>> traversal = pre_order_traversal(bst) >>> traversal == [1] True >>> bst = sorted_array_to_bst([]) >>> bst is None True >>> nums = list(range(-100, 101)) >>> bst = sorted_array_to_bst(nums) >>> traversal = pre_order_traversal(bst) >>> set(traversal) == set(nums) True pass def pre_order_traversal(root): Returns the pre-order traversal of the BST as a list. result = [] if not root: return result result.append(root.val) result.extend(pre_order_traversal(root.left)) result.extend(pre_order_traversal(root.right)) return result","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a height-balanced binary search tree (BST). if not nums: return None def helper(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1) def pre_order_traversal(root): Returns the pre-order traversal of the BST as a list. result = [] if not root: return result result.append(root.val) result.extend(pre_order_traversal(root.left)) result.extend(pre_order_traversal(root.right)) return result"},{"question":"def sieve_of_eratosthenes(n): Implements the Sieve of Eratosthenes algorithm to find all primes up to and including \`n\`, and returns a list of these prime numbers. pass def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to \`n\`. pass def process_input_and_output(input_values): Processes the input list containing test case values and returns the list of corresponding results where each result is the sum of primes up to the provided number. pass import pytest from solution import process_input_and_output def test_sample_input_1(): input_values = [2, 10, 20] expected_output = [17, 77] assert process_input_and_output(input_values) == expected_output def test_small_input(): input_values = [2, 1, 2] expected_output = [0, 2] assert process_input_and_output(input_values) == expected_output def test_medium_input(): input_values = [3, 5, 10, 15] expected_output = [10, 17, 41] assert process_input_and_output(input_values) == expected_output def test_large_input(): input_values = [1, 100000] sum_of_primes_up_to_100000 = 454396537 assert process_input_and_output(input_values) == [sum_of_primes_up_to_100000] def test_varied_input(): input_values = [4, 3, 4, 5, 6] expected_output = [5, 5, 10, 10] assert process_input_and_output(input_values) == expected_output","solution":"import itertools def sieve_of_eratosthenes(n): Implements the Sieve of Eratosthenes algorithm to find all primes up to and including \`n\`, and returns a list of these prime numbers. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to \`n\`. primes = sieve_of_eratosthenes(n) return sum(primes) def process_input_and_output(input_values): Processes the input list containing test case values and returns the list of corresponding results where each result is the sum of primes up to the provided number. results = [] T = input_values[0] for i in range(1, T + 1): n = input_values[i] results.append(sum_of_primes(n)) return results"},{"question":"def second_largest(numbers): Finds the second largest number in a list of integers. If the list has fewer than 2 unique elements, return None. Args: numbers (list): A list of integers. Returns: int/None: The second largest unique number or None if not applicable. >>> second_largest([4, 3, 1, 4, 2]) == 3 >>> second_largest([1, 2, 3, 4]) == 3 >>> second_largest([1, 2, 3, 2, 4, 4]) == 3 >>> second_largest([5, 5, 5, 5]) == None >>> second_largest([1]) == None >>> second_largest([]) == None >>> second_largest([-1, -2, -3, -4]) == -2 >>> second_largest([1, -1, 2, -2, 3, -3]) == 2 >>> second_largest([1000000, 500000, 1000000, 2000000]) == 1000000","solution":"def second_largest(numbers): Finds the second largest number in a list of integers. If the list has fewer than 2 unique elements, return None. Args: numbers (list): A list of integers. Returns: int/None: The second largest unique number or None if not applicable. if len(numbers) < 2: return None first_largest = second_largest = float('-inf') for number in numbers: if number > first_largest: second_largest = first_largest first_largest = number elif first_largest > number > second_largest: second_largest = number if second_largest == float('-inf'): return None return second_largest"},{"question":"from typing import List def min_steps_to_last_row(N: int, M: int, grid: List[str]) -> int: Determine the minimum number of steps required to reach any cell in the last row starting from any cell in the first row, or return -1 if it is impossible. >>> min_steps_to_last_row(5, 5, ['.....', '..X..', '...X.', 'X....', '.....']) 4 >>> min_steps_to_last_row(3, 3, ['..X', '.X.', 'XX.']) -1 >>> min_steps_to_last_row(1, 1, ['.']) 0 >>> min_steps_to_last_row(3, 4, ['....', '.X..', '....']) 2 >>> min_steps_to_last_row(4, 4, ['....', 'XXXX', '....', '....']) -1","solution":"from collections import deque def min_steps_to_last_row(N, M, grid): def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' # Steps: (row increment, column increment) directions = [(0, 1), (1, 0)] # Initialize queue and add all starting points from the first row queue = deque() visited = [[False] * M for _ in range(N)] for c in range(M): if grid[0][c] == '.': queue.append((0, c, 0)) # (row, column, steps) visited[0][c] = True # BFS to find the shortest path while queue: x, y, steps = queue.popleft() # If we reached the last row, return the steps count if x == N - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) # If we finish BFS without reaching the last row, return -1 return -1"},{"question":"def can_obtain_by_k_operations(k: int, s1: str, s2: str) -> str: Determine if s2 can be obtained from s1 with exactly k operations. >>> can_obtain_by_k_operations(3, 'abcdef', 'abcxyz') 'YES' >>> can_obtain_by_k_operations(1, 'hello', 'hxllo') 'YES' >>> can_obtain_by_k_operations(2, 'abcd', 'abcf') 'NO' >>> can_obtain_by_k_operations(0, 'test', 'test') 'YES' >>> can_obtain_by_k_operations(4, 'abcd', 'wxyz') 'YES' >>> can_obtain_by_k_operations(5, 'abcd', 'wxyz') 'NO' >>> can_obtain_by_k_operations(1, 'a', 'b') 'YES' >>> can_obtain_by_k_operations(1, 'abc', 'abc') 'NO'","solution":"def can_obtain_by_k_operations(k, s1, s2): Determine if s2 can be obtained from s1 with exactly k operations. mismatch_count = sum(1 for a, b in zip(s1, s2) if a != b) if mismatch_count == k: return \\"YES\\" else: return \\"NO\\""},{"question":"def marathon_runners(N, M, runner_data): Track which runners stopped at each water station. Args: N (int): Number of runners M (int): Number of water stations runner_data (list of tuples): Each tuple contains a runner's ID and a list of water station IDs they stopped at Returns: list of str: Each element is a string containing a water station ID followed by the IDs of the runners who stopped at that station in sorted order. >>> marathon_runners(3, 3, [(1, [1, 2]), (2, [2, 3]), (3, [1, 3])]) ['1 1 3', '2 1 2', '3 2 3'] >>> marathon_runners(0, 3, []) ['1', '2', '3'] >>> marathon_runners(1, 3, [(1, [1, 2, 3])]) ['1 1', '2 1', '3 1'] >>> marathon_runners(3, 1, [(1, [1]), (2, [1]), (3, [1])]) ['1 1 2 3'] >>> marathon_runners(5, 5, [(1, [2, 4]), (2, [1, 2]), (3, [1, 3]), (4, [3, 4]), (5, [5])]) ['1 2 3', '2 1 2', '3 3 4', '4 1 4', '5 5']","solution":"def marathon_runners(N, M, runner_data): from collections import defaultdict water_stations = defaultdict(list) for runner, stations in runner_data: for station in stations: water_stations[station].append(runner) result = [] for station in range(1, M + 1): if station in water_stations: result.append(f\\"{station} \\" + \\" \\".join(map(str, sorted(water_stations[station])))) else: result.append(f\\"{station}\\") return result"},{"question":"def count_paths_with_obstacles(n: int, m: int, grid: List[List[int]]) -> int: Count the number of distinct ways to reach the bottom-right corner from the top-left corner in a grid with obstacles. >>> count_paths_with_obstacles(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> count_paths_with_obstacles(3, 3, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> count_paths_with_obstacles(3, 3, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 0 >>> count_paths_with_obstacles(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> count_paths_with_obstacles(1, 1, [ ... [0] ... ]) == 1 >>> count_paths_with_obstacles(5, 5, [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == 2","solution":"def count_paths_with_obstacles(n, m, grid): MOD = 998244353 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1]"},{"question":"def compute_lea_operations(n: int, numbers: List[int]) -> Tuple[int, List[str]]: Given a set of numbers, compute the minimum number of \`lea\` assembly instructions required to compute the sum starting from an initial value of 0. Parameters: n (int): The number of elements in the set. numbers (list of int): The numbers to be summed. Returns: tuple: The number of instructions and the list of instructions. >>> compute_lea_operations(3, [2, 3, 7]) (2, [\\"lea ebx, [eax + ebx]\\", \\"lea ecx, [ebx + 4*eax]\\"]) >>> compute_lea_operations(2, [4, 6]) (2, [\\"lea ebx, [4*eax]\\", \\"lea ecx, [2*eax + ebx]\\"])","solution":"def compute_lea_operations(n, numbers): Given a set of numbers, this function computes the minimum number of \`lea\` assembly instructions required to compute the sum. Parameters: n (int): The number of elements in the set. numbers (list of int): The numbers to be summed. Returns: tuple: The number of instructions and the list of instructions. operations = [] registers = ['eax', 'ebx', 'ecx', 'edx'] # Start with the sum being zero in eax sum_register = registers[0] current_register = 1 if n == 1: return 1, [f\\"lea {registers[current_register]}, [{numbers[0]}*{registers[0]}]\\"] # Initial step: load the first value into the next register operations.append(f\\"lea {registers[current_register]}, [{numbers[0]}*{sum_register}]\\") for i in range(1, n): current_op = f\\"lea {registers[current_register]}, [{registers[current_register]} + {numbers[i]//2}*{sum_register}]\\" operations.append(current_op) return len(operations), operations"},{"question":"def longest_subarray_sum(arr, target): Finds the length of the longest contiguous subarray within a given list of integers, arr, that sums to a given value, target. If no such subarray exists, return 0. Examples: >>> longest_subarray_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_sum([1, 2, 3], 6) 3 >>> longest_subarray_sum([1, 2, 3], 7) 0 >>> longest_subarray_sum([1, 2, -1, 2, 3], 4) 4","solution":"def longest_subarray_sum(arr, target): Finds the length of the longest contiguous subarray within a given list of integers, arr, that sums to a given value, target. If no such subarray exists, return 0. sum_indices = {0: -1} total_sum = 0 max_length = 0 for i, num in enumerate(arr): total_sum += num if total_sum - target in sum_indices: max_length = max(max_length, i - sum_indices[total_sum - target]) if total_sum not in sum_indices: sum_indices[total_sum] = i return max_length"},{"question":"def max_candies(N: int, candies: List[int]) -> int: Returns the maximum number of candies that can be collected given the constraint of collecting from at most one pair of consecutive houses. >>> max_candies(6, [3, 2, 5, 10, 7, 8]) 35 >>> max_candies(4, [4, 5, 6, 7]) 22","solution":"def max_candies(N, candies): Returns the maximum number of candies that can be collected given the constraint of collecting from at most one pair of consecutive houses. if N == 1: return candies[0] max_candies_collected = 0 for i in range(N): for j in range(i, N): max_candies_collected = max(max_candies_collected, sum(candies[i:j+1])) return max_candies_collected"},{"question":"def total_reading_time(N: int, M: int) -> int: Calculate the total time spent by Sara reading the book. N: Total number of pages in the book. M: Number of pages read at triple the usual speed. >>> total_reading_time(120, 30) 100 >>> total_reading_time(200, 60) 160 >>> total_reading_time(90, 90) 30 >>> total_reading_time(300, 0) 300 >>> total_reading_time(1000, 999) (999 // 3) + 1 >>> total_reading_time(1, 0) 1","solution":"def total_reading_time(N, M): Calculate the total time spent by Sara reading the book. N: Total number of pages in the book. M: Number of pages read at triple the usual speed. time_for_first_part = M // 3 time_for_rest = N - M return time_for_first_part + time_for_rest"},{"question":"def minimum_maximum_price_difference(n, m, k, prices): Determines the minimum possible maximum price difference for m categories each containing k books out of the n books provided. Args: n : int : Total number of books m : int : Number of categories k : int : Number of books in each category prices : List[int] : List of book prices Returns: int : Minimum possible maximum price difference Examples: >>> minimum_maximum_price_difference(5, 1, 3, [7, 5, 9, 1, 3]) 4 >>> minimum_maximum_price_difference(6, 2, 2, [8, 3, 5, 1, 4, 6]) 1 >>> minimum_maximum_price_difference(4, 1, 2, [10, 12, 20, 15]) 2","solution":"def minimum_maximum_price_difference(n, m, k, prices): Determines the minimum possible maximum price difference for m categories each containing k books out of the n books provided. prices.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = prices[i + k - 1] - prices[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def can_add_chemical(n, r, chemicals_in_storage, reactive_pairs, proposed_chemical): Determines if the proposed chemical can be safely added to the storage. Arguments: n -- number of chemicals currently in the storage r -- number of reactive pairs chemicals_in_storage -- list of chemicals currently in the storage reactive_pairs -- list of tuples, where each tuple contains two chemicals that react with each other proposed_chemical -- the chemical to be proposed for addition Returns: \\"SAFE\\" if the proposed chemical can be safely added, \\"DANGEROUS\\" otherwise. >>> can_add_chemical(3, 2, [\\"H2O\\", \\"NaOH\\", \\"HCl\\"], [(\\"H2O\\", \\"HCl\\"), (\\"H2O\\", \\"NaOH\\")], \\"H2SO4\\") 'SAFE' >>> can_add_chemical(3, 2, [\\"H2O\\", \\"NaOH\\", \\"HCl\\"], [(\\"H2O\\", \\"HCl\\"), (\\"H2O\\", \\"NaOH\\")], \\"HCl\\") 'DANGEROUS'","solution":"def can_add_chemical(n, r, chemicals_in_storage, reactive_pairs, proposed_chemical): Determines if the proposed chemical can be safely added to the storage. Arguments: n -- number of chemicals currently in the storage r -- number of reactive pairs chemicals_in_storage -- list of chemicals currently in the storage reactive_pairs -- list of tuples, where each tuple contains two chemicals that react with each other proposed_chemical -- the chemical to be proposed for addition Returns: \\"SAFE\\" if the proposed chemical can be safely added, \\"DANGEROUS\\" otherwise. # Create a set of reactive pairs for quick lookup reactive_dict = {} for chem1, chem2 in reactive_pairs: if chem1 not in reactive_dict: reactive_dict[chem1] = set() if chem2 not in reactive_dict: reactive_dict[chem2] = set() reactive_dict[chem1].add(chem2) reactive_dict[chem2].add(chem1) # Check if the proposed chemical reacts with any chemical in storage for chem in chemicals_in_storage: if proposed_chemical in reactive_dict and chem in reactive_dict[proposed_chemical]: return \\"DANGEROUS\\" return \\"SAFE\\""},{"question":"def generate_empty_grid(n: int) -> List[List[str]]: Creates an n x n empty grid filled with spaces. def place_word_horizontal(grid: List[List[str]], word: str, row: int, col: int) -> List[List[str]]: Places a word horizontally in the grid starting at the specified row and column. def place_word_vertical(grid: List[List[str]], word: str, row: int, col: int) -> List[List[str]]: Places a word vertically in the grid starting at the specified row and column. def display_grid(grid: List[List[str]]) -> str: Returns a string representation of the grid, with each row as a new line. import pytest def test_generate_empty_grid(): grid = generate_empty_grid(3) assert grid == [[' ', ' ', ' '], [' ', ' ', ' '], [' ', ' ', ' ']] def test_place_word_horizontal_valid(): grid = generate_empty_grid(5) grid = place_word_horizontal(grid, \\"hello\\", 2, 0) assert grid[2] == ['h', 'e', 'l', 'l', 'o'] def test_place_word_horizontal_out_of_bounds(): grid = generate_empty_grid(5) with pytest.raises(IndexError): place_word_horizontal(grid, \\"hello\\", 2, 3) def test_place_word_vertical_valid(): grid = generate_empty_grid(5) grid = place_word_vertical(grid, \\"world\\", 0, 2) assert [grid[i][2] for i in range(5)] == ['w', 'o', 'r', 'l', 'd'] def test_place_word_vertical_out_of_bounds(): grid = generate_empty_grid(5) with pytest.raises(IndexError): place_word_vertical(grid, \\"world\\", 3, 0) def test_display_grid(): grid = generate_empty_grid(3) grid[1][1] = 'x' expected_output = \\" n x n \\" assert display_grid(grid) == expected_output","solution":"from typing import List def generate_empty_grid(n: int) -> List[List[str]]: Creates an n x n empty grid filled with spaces. return [[' ' for _ in range(n)] for _ in range(n)] def place_word_horizontal(grid: List[List[str]], word: str, row: int, col: int) -> List[List[str]]: Places a word horizontally in the grid starting at the specified row and column. if not grid or not word: return grid word_length = len(word) if col + word_length > len(grid[0]) or row >= len(grid): raise IndexError(\\"Word placement goes out of the grid bounds\\") for i in range(word_length): grid[row][col + i] = word[i] return grid def place_word_vertical(grid: List[List[str]], word: str, row: int, col: int) -> List[List[str]]: Places a word vertically in the grid starting at the specified row and column. if not grid or not word: return grid word_length = len(word) if row + word_length > len(grid) or col >= len(grid[0]): raise IndexError(\\"Word placement goes out of the grid bounds\\") for i in range(word_length): grid[row + i][col] = word[i] return grid def display_grid(grid: List[List[str]]) -> str: Returns a string representation of the grid, with each row as a new line. return 'n'.join([''.join(row) for row in grid])"},{"question":"def find_path(n: int, m: int, grid: List[List[int]]) -> Union[List[Tuple[int, int]], int]: Check if there exists a path from the top-left corner to the bottom-right corner in a binary grid, and return one such path if it exists. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): binary grid with 0 (empty) and 1 (blocked) Returns: Union[List[Tuple[int, int]], int]: List of tuples indicating the path coordinates if a path exists, else -1 Examples: >>> find_path(4, 4, [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 0], ... [1, 1, 1, 0] ...]) [(1, 1), (2, 1), (3, 1), (3, 2), (3, 3), (3, 4), (4, 4)] >>> find_path(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ...]) -1","solution":"def find_path(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 def backtrack(x, y): if (x, y) == (n-1, m-1): path.append((x + 1, y + 1)) return True grid[x][y] = 1 path.append((x + 1, y + 1)) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and backtrack(nx, ny): return True path.pop() return False if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] path = [] if backtrack(0, 0): return path else: return -1"},{"question":"def has_zero_sum_subarray(n, temperature_readings): Determines if there is a subarray with sum of zero in the given temperature readings. Parameters: n (int): Number of days (length of the temperature_readings list). temperature_readings (list): List of integers representing temperature readings for n days. Returns: str: \\"YES\\" if there exists a subarray with sum zero, otherwise \\"NO\\". pass def process_test_cases(test_cases): Processes multiple test cases. Parameters: test_cases (list): List of tuples, each containing (n, temperature_readings) for each test case. Returns: list: List of results for each test case. pass def test_has_zero_sum_subarray(): # Test case 1 n = 6 temperature_readings = [1, 2, 3, -3, 4, 5] assert has_zero_sum_subarray(n, temperature_readings) == \\"YES\\" # Test case 2 n = 5 temperature_readings = [1, 2, -2, 4, 5] assert has_zero_sum_subarray(n, temperature_readings) == \\"YES\\" # Test case 3 n = 3 temperature_readings = [1, 2, 3] assert has_zero_sum_subarray(n, temperature_readings) == \\"NO\\" # Additional test cases n = 0 temperature_readings = [] assert has_zero_sum_subarray(n, temperature_readings) == \\"NO\\" n = 4 temperature_readings = [0, 0, 0, 0] assert has_zero_sum_subarray(n, temperature_readings) == \\"YES\\" n = 1 temperature_readings = [1] assert has_zero_sum_subarray(n, temperature_readings) == \\"NO\\" n = 2 temperature_readings = [1, -1] assert has_zero_sum_subarray(n, temperature_readings) == \\"YES\\" n = 5 temperature_readings = [4, -1, -3, 5, 2] assert has_zero_sum_subarray(n, temperature_readings) == \\"YES\\" n = 5 temperature_readings = [1, 2, 3, 4, 5] assert has_zero_sum_subarray(n, temperature_readings) == \\"NO\\" def test_process_test_cases(): test_cases = [ (6, [1, 2, 3, -3, 4, 5]), (5, [1, 2, -2, 4, 5]), (3, [1, 2, 3]) ] results = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(test_cases) == results","solution":"def has_zero_sum_subarray(n, temperature_readings): Determines if there is a subarray with sum of zero in the given temperature readings. Parameters: n (int): Number of days (length of the temperature_readings list). temperature_readings (list): List of integers representing temperature readings for n days. Returns: str: \\"YES\\" if there exists a subarray with sum zero, otherwise \\"NO\\". current_sum = 0 seen_sums = set() for temp in temperature_readings: current_sum += temp if current_sum == 0 or current_sum in seen_sums: return \\"YES\\" seen_sums.add(current_sum) return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases. Parameters: test_cases (list): List of tuples, each containing (n, temperature_readings) for each test case. Returns: list: List of results for each test case. results = [] for n, temperature_readings in test_cases: results.append(has_zero_sum_subarray(n, temperature_readings)) return results"},{"question":"def calculate_ranks(n: int, performances: List[str]) -> List[Tuple[str, int]]: In a talent show competition, participants are ranked based on the average of their top three performance scores. Args: n (int): Number of performance records performances (List[str]): List containing participant's name and score for a performance. Returns: List[Tuple[str, int]]: A list of tuples containing participant's name and their rank. Example: >>> calculate_ranks(7, [\\"alice 500\\", \\"bob 700\\", \\"alice 600\\", \\"alice 700\\", ... \\"bob 800\\", \\"alice 300\\", \\"bob 750\\"]) [(\\"alice\\", 2), (\\"bob\\", 1)] >>> calculate_ranks(4, [\\"david 600\\", \\"charlie 400\\", \\"david 700\\", \\"charlie 500\\"]) [(\\"charlie\\", 2), (\\"david\\", 1)] >>> calculate_ranks(3, [\\"eve 500\\", \\"frank 500\\", \\"eve 600\\"]) [(\\"eve\\", 1), (\\"frank\\", 2)] pass","solution":"def calculate_ranks(n, performances): from collections import defaultdict import math participant_scores = defaultdict(list) for performance in performances: name, score = performance.split() score = int(score) participant_scores[name].append(score) final_scores = [] for participant, scores in participant_scores.items(): scores.sort(reverse=True) top_three_scores = scores[:3] average_score = sum(top_three_scores) / len(top_three_scores) final_scores.append((participant, average_score)) final_scores.sort(key=lambda x: (-x[1], x[0])) ranks = {} current_rank = 0 current_score = None for i, (participant, score) in enumerate(final_scores): if score != current_score: current_rank = i + 1 current_score = score ranks[participant] = current_rank ranked_participants = sorted(ranks.keys()) result = [(participant, ranks[participant]) for participant in ranked_participants] return result"},{"question":"from typing import List def largest_square_with_prime_digit_sum(nums: List[int]) -> int: You are given a list of integers nums. Your task is to find the largest integer in the list which is a perfect square whose digit sum (sum of its digits) is a prime number. If no such integer exists, return -1. Args: nums (List[int]): A list of integers. Returns: int: The largest perfect square with a prime digit sum or -1 if none exists. >>> largest_square_with_prime_digit_sum([16, 25, 36, 49, 50]) 49 >>> largest_square_with_prime_digit_sum([1, 2, 3, 12, 25]) 25","solution":"import math def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def digit_sum(n): Calculate the sum of digits of a number. return sum(int(digit) for digit in str(n)) def largest_square_with_prime_digit_sum(nums): Find the largest perfect square in the list whose digit sum is a prime number. result = -1 for num in nums: if math.isqrt(num) ** 2 == num: # Check if num is a perfect square if is_prime(digit_sum(num)): # Check if digit sum is prime result = max(result, num) # Update result if num is larger return result"},{"question":"from typing import List def min_steps_to_light_bonfires(grid: List[List[str]]) -> int: Determine the minimum number of steps required to light all the bonfires from the starting position. If it is not possible to light all the bonfires, return -1. >>> min_steps_to_light_bonfires([ ... \\"S.F\\", ... \\".#.\\", ... \\"..F\\"]) == 4 >>> min_steps_to_light_bonfires([ ... \\"S..F\\", ... \\".#..\\", ... \\"#.F#\\", ... \\"F..#\\"]) == 7 >>> min_steps_to_light_bonfires([ ... \\"S.#F\\", ... \\".#.#\\", ... \\"#..#\\", ... \\"F..#\\"]) == -1 Args: grid (List[List[str]]): The grid representing the island, bonfires, and obstacles. Returns: int: The minimum steps required or -1 if it's impossible to light all bonfires. pass def process_input(input_data: str) -> List[int]: Process the input data and return a list of results for each test case. >>> process_input('''3 3 ... S.F ... .#. ... ..F ... 4 4 ... S..F ... .#.. ... #.F# ... F..# ... 4 4 ... S.#F ... .#.# ... #..# ... F..# ... 0 0''') == [4, 7, -1] Args: input_data (str): The input string containing multiple test cases. Returns: List[int]: A list of results for each test case. pass","solution":"from collections import deque def min_steps_to_light_bonfires(grid): # Helper func to find the start and bonfire positions def find_positions(grid): start = None bonfires = [] for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'F': bonfires.append((r, c)) return start, bonfires # Helper func to perform BFS from the start position def bfs(start, targets): visited = set() queue = deque([(start, 0)]) targets = set(targets) steps = 0 while queue: (r, c), step = queue.popleft() if (r, c) in visited: continue visited.add((r, c)) if (r, c) in targets: targets.remove((r, c)) if not targets: # All bonfires have been reached return step for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != \\"#\\" and (nr, nc) not in visited: queue.append(((nr, nc), step + 1)) return -1 # If it's not possible to reach all bonfires start, bonfires = find_positions(grid) return bfs(start, bonfires) def process_input(input_data): lines = input_data.strip().split('n') results = [] idx = 0 while idx < len(lines): n, m = map(int, lines[idx].split()) if n == 0 and m == 0: break grid = [list(lines[idx + j + 1]) for j in range(n)] result = min_steps_to_light_bonfires(grid) results.append(result) idx += n + 1 return results"},{"question":"def longest_unique_substring(s: str) -> int: Find the length of the longest sequence of unique characters in a given string. >>> longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> longest_unique_substring(\\"abcdef\\") == 6 # \\"abcdef\\"","solution":"def longest_unique_substring(s): Returns the length of the longest sequence of unique characters in the given string. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def sum_of_digits(N: int) -> int: Find the sum of the digits of a number until you get a single digit. Example: >>> sum_of_digits(38) 2 >>> sum_of_digits(123) 6","solution":"def sum_of_digits(N): Returns the sum of the digits of a number until a single digit is obtained. while N >= 10: N = sum(int(digit) for digit in str(N)) return N"},{"question":"from typing import List, Dict def expand_sentence(s: str, word_dict: Dict[str, List[str]]) -> List[str]: Generate all possible sentences by replacing each word in the input string with its synonyms from the provided dictionary. Args: s (str): The input sentence. word_dict (Dict[str, List[str]]): A dictionary where keys are words and values are lists of synonyms. Returns: List: A list of all possible sentences formed by replacing each dictionary word with its synonyms. Examples: >>> expand_sentence(\\"I like apples\\", {\\"like\\": [\\"love\\", \\"enjoy\\"], \\"apples\\": [\\"fruits\\", \\"oranges\\"]}) [\\"I like apples\\", \\"I like fruits\\", \\"I like oranges\\", \\"I love apples\\", \\"I love fruits\\", \\"I love oranges\\", \\"I enjoy apples\\", \\"I enjoy fruits\\", \\"I enjoy oranges\\"] >>> expand_sentence(\\"I like bananas\\", {\\"like\\": [\\"love\\"], \\"bananas\\": [\\"fruits\\"]}) [\\"I like bananas\\", \\"I like fruits\\", \\"I love bananas\\", \\"I love fruits\\"] >>> expand_sentence(\\"I like apples\\", {}) [\\"I like apples\\"] >>> expand_sentence(\\"happy\\", {\\"happy\\": [\\"joyful\\", \\"content\\"]}) [\\"happy\\", \\"joyful\\", \\"content\\"] >>> expand_sentence(\\"I have a dog\\", {\\"have\\": [\\"own\\", \\"possess\\"], \\"dog\\": [\\"puppy\\", \\"hound\\"]}) [\\"I have a dog\\", \\"I have a puppy\\", \\"I have a hound\\", \\"I own a dog\\", \\"I own a puppy\\", \\"I own a hound\\", \\"I possess a dog\\", \\"I possess a puppy\\", \\"I possess a hound\\"]","solution":"from itertools import product def expand_sentence(s: str, word_dict: dict) -> list: words = s.split() synonyms = [] for word in words: if word in word_dict: synonyms.append([word] + word_dict[word]) else: synonyms.append([word]) all_combinations = list(product(*synonyms)) return [' '.join(combo) for combo in all_combinations]"},{"question":"def twoSum(nums, target): Finds the indices of two numbers in the array that add up to the target. Parameters: nums (list[int]): The array of integers. target (int): The target sum. Returns: list[int]: The indices of the two numbers that add up to the target. Example: >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([-1, -2, -3, -4, -5], -8) [2, 4] >>> twoSum([0, 4, 3, 0], 0) [0, 3] >>> twoSum([1, 2, 3, 4, 5], 10) [] >>> twoSum([3, 3, 4, 2], 6) [0, 1]","solution":"def twoSum(nums, target): Finds the indices of two numbers in the array that add up to the target. Parameters: nums (list[int]): The array of integers. target (int): The target sum. Returns: list[int]: The indices of the two numbers that add up to the target. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i return []"},{"question":"import math from typing import List, Tuple def max_distance(points: List[Tuple[int, int]]) -> float: Find the maximum distance between any two points in a 2D plane. Args: points (List[Tuple[int, int]]): A list of tuples representing the coordinates of the points. Returns: float: The maximum distance between any two points, rounded to 4 decimal places. Example: >>> max_distance([(0, 0), (0, 3), (4, 0)]) 5.0000 pass def process_input(input_data: str) -> str: Process the input data for multiple test cases and return the results. Args: input_data (str): A string containing multiple test cases. Returns: str: The maximum distances for each test case rounded to 4 decimal places, in separate lines. Example: >>> process_input(\\"1n3n0 0n0 3n4 0n\\") '5.0000' pass # Unit tests import pytest def test_max_distance_basic(): points = [(0, 0), (0, 3), (4, 0)] assert abs(max_distance(points) - 5.0000) < 1e-4 def test_max_distance_single_pair(): points = [(1, 1), (4, 5)] assert abs(max_distance(points) - 5.0000) < 1e-4 def test_max_distance_large_gap(): points = [(0, 0), (1000, 1000)] assert abs(max_distance(points) - 1414.2136) < 1e-4 def test_process_input_single_test_case(): input_data = \\"1n3n0 0n0 3n4 0n\\" assert process_input(input_data) == \\"5.0000\\" def test_process_input_multiple_test_cases(): input_data = \\"2n3n0 0n0 3n4 0n2n1 1n4 5n\\" assert process_input(input_data) == \\"5.0000n5.0000\\" def test_process_input_large_coordinates(): input_data = \\"1n2n-1000 -1000n1000 1000n\\" assert process_input(input_data) == \\"2828.4271\\" pytest.main()","solution":"import math def max_distance(points): num_points = len(points) max_dist = 0 for i in range(num_points): for j in range(i + 1, num_points): dist = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2) if dist > max_dist: max_dist = dist return max_dist def process_input(input_data): lines = input_data.strip().split(\\"n\\") index = 0 T = int(lines[index]) index += 1 results = [] for _ in range(T): N = int(lines[index]) index += 1 points = [] for _ in range(N): x, y = map(int, lines[index].split()) points.append((x, y)) index += 1 result = max_distance(points) results.append(f\\"{result:.4f}\\") return \\"n\\".join(results)"},{"question":"def removeDuplicates(s: str) -> str: Removes duplicate characters from the string while maintaining the order of their first occurrence. Parameters: s (str): The input string of lowercase characters. Returns: str: Modified string with duplicates removed. >>> removeDuplicates(\\"programming\\") \\"progamin\\" >>> removeDuplicates(\\"mississippi\\") \\"misp\\" from solution import removeDuplicates def test_removeDuplicates(): # Example 1 assert removeDuplicates(\\"programming\\") == \\"progamin\\" # Example 2 assert removeDuplicates(\\"mississippi\\") == \\"misp\\" # Edge case with empty string assert removeDuplicates(\\"\\") == \\"\\" # Case with no duplicates assert removeDuplicates(\\"abcdef\\") == \\"abcdef\\" # Case with all characters being the same assert removeDuplicates(\\"aaaaaa\\") == \\"a\\" # Mixed case with multiple duplicate characters assert removeDuplicates(\\"abacabad\\") == \\"abcd\\" # Long input case assert removeDuplicates(\\"a\\" * 10000 + \\"b\\" * 10000) == \\"ab\\"","solution":"def removeDuplicates(s): Removes duplicate characters from the string while maintaining the order of their first occurrence. Parameters: s (str): The input string of lowercase characters. Returns: str: Modified string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def min_additional_deliveries(n: int, deliveries: List[Tuple[int, int]]) -> int: Determine the minimum number of additional deliveries required so that every house receives at least one toy. Parameters: - n: int - Number of houses. - deliveries: List of tuples - Existing toy deliveries. Returns: int - Minimum number of additional deliveries required. pass from solution import min_additional_deliveries def test_no_additional_needed(): assert min_additional_deliveries(7, [(1, 3), (4, 5), (6, 7)]) == 0 assert min_additional_deliveries(3, [(1, 3)]) == 0 def test_some_additional_needed(): assert min_additional_deliveries(5, [(1, 2), (4, 5)]) == 1 assert min_additional_deliveries(5, [(2, 2), (4, 5)]) == 2 assert min_additional_deliveries(4, [(1, 1), (2, 2)]) == 2 def test_all_additional_needed(): assert min_additional_deliveries(3, []) == 3 assert min_additional_deliveries(5, []) == 5 def test_edge_cases(): assert min_additional_deliveries(1, []) == 1 assert min_additional_deliveries(1, [(1, 1)]) == 0 assert min_additional_deliveries(100, [(1, 50), (51, 100)]) == 0 assert min_additional_deliveries(100, [(1, 49), (51, 99)]) == 2","solution":"def min_additional_deliveries(n, deliveries): Determine the minimum number of additional deliveries required so that every house receives at least one toy. Parameters: - n: int - Number of houses. - deliveries: List of tuples - Existing toy deliveries. Returns: int - Minimum number of additional deliveries required. covered = [0] * n # Mark the covered houses for (start, end) in deliveries: for i in range(start - 1, end): covered[i] = 1 # Count uncovered houses uncovered_count = covered.count(0) return uncovered_count"},{"question":"def length_of_shortest_substring(s: str) -> int: Find the length of the shortest substring of \`s\` that contains all distinct characters of \`s\`. >>> length_of_shortest_substring(\\"abca\\") == 3 >>> length_of_shortest_substring(\\"aaaa\\") == 1 >>> length_of_shortest_substring(\\"abcabcbb\\") == 3","solution":"def length_of_shortest_substring(s): distinct_chars = set(s) distinct_count = len(distinct_chars) n = len(s) min_length = n for i in range(n): seen_chars = set() for j in range(i, n): seen_chars.add(s[j]) if len(seen_chars) == distinct_count: min_length = min(min_length, j - i + 1) break return min_length"},{"question":"def max_altitude_change(M, alex_altitudes, jamie_altitudes): Determine whether Alex or Jamie recorded the highest change in altitude. Args: M (int): the number of data points. alex_altitudes (List[int]): list of altitudes recorded by Alex. jamie_altitudes (List[int]): list of altitudes recorded by Jamie. Returns: Tuple[str, int]: The name of the person who recorded the highest change in altitude and the value of the maximum change. >>> max_altitude_change(5, [1, 3, 7, 4, 2], [1, 6, 2, 8, 3]) (\\"Jamie\\", 6) >>> max_altitude_change(4, [1, -1, 1, -1], [1, -1, 1, -1]) (\\"Tie\\", 2) from solution import max_altitude_change def test_max_altitude_change_altitudes(): M = 5 alex_altitudes = [1, 3, 7, 4, 2] jamie_altitudes = [1, 6, 2, 8, 3] assert max_altitude_change(M, alex_altitudes, jamie_altitudes) == (\\"Jamie\\", 6) def test_tie_case(): M = 4 alex_altitudes = [1, -1, 1, -1] jamie_altitudes = [1, -1, 1, -1] assert max_altitude_change(M, alex_altitudes, jamie_altitudes) == (\\"Tie\\", 2) def test_alex_wins(): M = 4 alex_altitudes = [1, -5, 1, -1] jamie_altitudes = [2, 0, -2, 0] assert max_altitude_change(M, alex_altitudes, jamie_altitudes) == (\\"Alex\\", 6) def test_jamie_wins(): M = 3 alex_altitudes = [1, 2, 1] jamie_altitudes = [1, 5, 1] assert max_altitude_change(M, alex_altitudes, jamie_altitudes) == (\\"Jamie\\", 4) def test_minimum_input_case(): M = 2 alex_altitudes = [0, 1] jamie_altitudes = [0, -1] assert max_altitude_change(M, alex_altitudes, jamie_altitudes) == (\\"Tie\\", 1)","solution":"def max_altitude_change(M, alex_altitudes, jamie_altitudes): max_change_alex = max(abs(alex_altitudes[i] - alex_altitudes[i+1]) for i in range(M-1)) max_change_jamie = max(abs(jamie_altitudes[i] - jamie_altitudes[i+1]) for i in range(M-1)) if max_change_alex > max_change_jamie: return \\"Alex\\", max_change_alex elif max_change_jamie > max_change_alex: return \\"Jamie\\", max_change_jamie else: return \\"Tie\\", max_change_alex # Example usage: M = 5 alex_altitudes = [1, 3, 7, 4, 2] jamie_altitudes = [1, 6, 2, 8, 3] result = max_altitude_change(M, alex_altitudes, jamie_altitudes) print(result)"},{"question":"def highest_peak(mountains: List[int]) -> int: Returns the height of the highest peak in the list of mountains. A peak is defined as an element which is not lower than its neighbors. >>> highest_peak([2, 3, 4, 3, 2, 5, 2, 4, 6, 4, 3, 2]) 6 >>> highest_peak([6, 5, 4, 3, 2, 1]) 6 >>> highest_peak([0, 0, 0, 0, 0]) 0 from solution import highest_peak def test_single_element(): assert highest_peak([10]) == 10 def test_all_same_elements(): assert highest_peak([5, 5, 5, 5]) == 5 def test_mountains_with_one_peak(): assert highest_peak([1, 3, 2]) == 3 def test_mountains_with_multiple_peaks(): assert highest_peak([2, 3, 4, 3, 2, 5, 2, 4, 6, 4, 3, 2]) == 6 def test_peak_at_the_end(): assert highest_peak([1, 2, 3, 4, 5, 6]) == 6 def test_peak_at_the_beginning(): assert highest_peak([6, 5, 4, 3, 2, 1]) == 6 def test_peaks_with_same_height(): assert highest_peak([2, 5, 5, 4, 3, 5, 4]) == 5 def test_no_peak_in_middle(): assert highest_peak([2, 3, 4, 5, 6]) == 6 def test_zeros_peaks(): assert highest_peak([0, 0, 0, 0, 0]) == 0","solution":"def highest_peak(mountains): Returns the height of the highest peak in the list of mountains. A peak is defined as an element which is not lower than its neighbors. # The special case when mountains list contains only one element if len(mountains) == 1: return mountains[0] n = len(mountains) peaks = [] # Check the first element if mountains[0] >= mountains[1]: peaks.append(mountains[0]) # Check the middle elements for i in range(1, n-1): if mountains[i] >= mountains[i-1] and mountains[i] >= mountains[i+1]: peaks.append(mountains[i]) # Check the last element if mountains[n-1] >= mountains[n-2]: peaks.append(mountains[n-1]) # Return the maximum element from peaks list return max(peaks)"},{"question":"import re def parse_and_sum(s: str) -> int: Parses the input string and returns the sum of all numbers found in the string. Negative numbers are included in the sum. If no numbers are found, returns 0. >>> parse_and_sum(\\"abcd123xyz\\") == 123 >>> parse_and_sum(\\"ab3cd-4xyz18\\") == 17 >>> parse_and_sum(\\"abc\\") == 0","solution":"import re def parse_and_sum(s): Parses the input string and returns the sum of all numbers found in the string. Negative numbers are included in the sum. If no numbers are found, returns 0. # Find all sequences of digits or negative digits numbers = re.findall(r'-?d+', s) # Convert found numbers to integers and sum them up total_sum = sum(int(num) for num in numbers) return total_sum"},{"question":"def find_possible_barcodes(damaged_barcode: str) -> list: Given a barcode string with some unreadable digits marked as '?', return all possible valid 5-digit barcodes. >>> find_possible_barcodes(\\"12?45\\") [\\"12045\\", \\"12145\\", \\"12245\\", \\"12345\\", \\"12445\\", \\"12545\\", \\"12645\\", \\"12745\\", \\"12845\\", \\"12945\\"] >>> find_possible_barcodes(\\"?234?\\") [\\"02340\\", \\"02341\\", \\"02342\\", \\"02343\\", \\"02344\\", \\"02345\\", \\"02346\\", \\"02347\\", \\"02348\\", \\"02349\\", \\"12340\\", \\"12341\\", \\"12342\\", \\"12343\\", \\"12344\\", \\"12345\\", \\"12346\\", \\"12347\\", \\"12348\\", \\"12349\\"]","solution":"def find_possible_barcodes(damaged_barcode): Given a damaged barcode with digits and '?' for unreadable digits, return all possible valid 5-digit barcodes. from itertools import product # List to store the possible barcodes possible_barcodes = [] # Generate all combinations of digits for '?' for combination in product('0123456789', repeat=damaged_barcode.count('?')): barcode = list(damaged_barcode) combination_index = 0 for i in range(len(barcode)): if barcode[i] == '?': barcode[i] = combination[combination_index] combination_index += 1 possible_barcodes.append(''.join(barcode)) # Sort the barcodes numerically possible_barcodes.sort() return possible_barcodes"},{"question":"def longest_increasing_subsequence(sequence): Given a list of integers, find the longest subsequence where the difference between consecutive elements is strictly increasing. Args: sequence (List[int]): A list of integers representing the sequence. Returns: List[int]: The longest strictly increasing subsequence. Examples: >>> longest_increasing_subsequence([2, 1, 3, 2, 2, 4, 3, 5, 2]) [1, 2, 3, 5] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) [2, 3, 7, 101] >>> longest_increasing_subsequence([]) [] >>> longest_increasing_subsequence([10, 20, 10, 30, 10, 40, 10, 50]) [10, 20, 30, 40, 50]","solution":"def longest_increasing_subsequence(sequence): Returns the longest strictly increasing subsequence. if not sequence: return [] # Initialize LIS values for all indexes lis = [[] for _ in range(len(sequence))] lis[0].append(sequence[0]) # Compute optimized LIS values in bottom-up manner for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j] and len(lis[i]) < len(lis[j]) + 1: lis[i] = lis[j].copy() lis[i].append(sequence[i]) # Find the maximum of all lis list longest = [] for subseq in lis: if len(subseq) > len(longest): longest = subseq return longest if __name__ == \\"__main__\\": n = int(input().strip()) sequence = list(map(int, input().strip().split())) result = longest_increasing_subsequence(sequence) for num in result: print(num)"},{"question":"def find_min_abs_diff_subarray(arr): Given an array arr of n integers, find two integers x and y (1 ≤ x < y ≤ n) such that the absolute difference between the sum of elements from index x to y and the sum of the remaining elements in the array is minimized. >>> find_min_abs_diff_subarray([1, 2, 3, 4, 5]) (2, 3) >>> find_min_abs_diff_subarray([-1, 2, -2, 1]) (1, 4)","solution":"def find_min_abs_diff_subarray(arr): n = len(arr) total_sum = sum(arr) min_diff = float('inf') x, y = 1, n # initialize to any valid value # We can scan the array and maintain the sum of elements up to the current index prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Now let's find the best x and y for start in range(n): for end in range(start + 1, n): subarray_sum = prefix_sum[end + 1] - prefix_sum[start] remaining_sum = total_sum - subarray_sum diff = abs(subarray_sum - remaining_sum) if diff < min_diff: min_diff = diff x, y = start + 1, end + 1 # converting to 1-based index return x, y"},{"question":"def can_place_dog(T: int, test_cases: List[Tuple[int, int, int, int]]) -> List[str]: Determines if Chef can place the dog at the specified positions without being on the edges. :param T: Number of test cases (integer) :param test_cases: List of tuples. Each tuple contains four integers (M, N, X, Y) :return: List of strings 'YES' or 'NO' for each test case >>> T = 4 >>> test_cases = [(5, 5, 2, 3), (6, 7, 1, 4), (4, 4, 3, 2), (7, 8, 7, 1)] >>> can_place_dog(T, test_cases) ['YES', 'NO', 'YES', 'NO'] >>> T = 2 >>> test_cases = [(3, 3, 2, 2), (3, 3, 1, 1)] >>> can_place_dog(T, test_cases) ['YES', 'NO'] >>> T = 2 >>> test_cases = [(100, 100, 50, 50), (100, 100, 1, 1)] >>> can_place_dog(T, test_cases) ['YES', 'NO'] >>> T = 4 >>> test_cases = [(4, 4, 1, 2), (4, 4, 4, 3), (4, 4, 2, 1), (4, 4, 3, 4)] >>> can_place_dog(T, test_cases) ['NO', 'NO', 'NO', 'NO']","solution":"def can_place_dog(T, test_cases): Determines if Chef can place the dog at the specified positions without being on the edges. :param T: Number of test cases (integer) :param test_cases: List of tuples. Each tuple contains four integers (M, N, X, Y) :return: List of strings 'YES' or 'NO' for each test case results = [] for case in test_cases: M, N, X, Y = case if 1 < X < M and 1 < Y < N: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def knapsack(values, weights, n, max_weight): Determines the maximum value of items that can be selected without exceeding a specified weight. Args: values (List[int]): List of item values. weights (List[int]): List of item weights. n (int): Number of items. max_weight (int): Maximum allowable weight. Returns: int: Maximum value of items that can be selected without exceeding the specified weight. pass def solve_knapsack_problem(n, items, queries): Handles multiple queries to determine the maximum value of items that can be selected without exceeding specified weights. Args: n (int): Number of items. items (List[Tuple[int, int]]): List of tuples containing item values and weights. queries (List[Tuple[int, int, List[int]]]): List of queries with number of items, maximum weight, and list of item indices. Returns: List[int]: List of maximum values for each query. pass def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 items = [] for i in range(n): V = int(data[idx]) W = int(data[idx + 1]) items.append((V, W)) idx += 2 q = int(data[idx]) idx += 1 queries = [] for i in range(q): M = int(data[idx]) L = int(data[idx + 1]) idx += 2 indices = [int(data[idx + j]) for j in range(M)] idx += M queries.append((M, L, indices)) results = solve_knapsack_problem(n, items, queries) for result in results: print(result) if __name__ == '__main__': main()","solution":"def knapsack(values, weights, n, max_weight): dp = [0] * (max_weight + 1) for i in range(n): for w in range(max_weight, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[max_weight] def solve_knapsack_problem(n, items, queries): results = [] for M, L, indices in queries: values = [items[i - 1][0] for i in indices] weights = [items[i - 1][1] for i in indices] max_value = knapsack(values, weights, M, L) results.append(max_value) return results def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) idx += 1 items = [] for i in range(n): V = int(data[idx]) W = int(data[idx + 1]) items.append((V, W)) idx += 2 q = int(data[idx]) idx += 1 queries = [] for i in range(q): M = int(data[idx]) L = int(data[idx + 1]) idx += 2 indices = [int(data[idx + j]) for j in range(M)] idx += M queries.append((M, L, indices)) results = solve_knapsack_problem(n, items, queries) for result in results: print(result) if __name__ == '__main__': main()"},{"question":"def find_occurrences(arr: List[int], X: int) -> List[int]: Returns the indices of the first and last occurrences of X in the list. If X does not exist in the list, return [-1, -1]. >>> find_occurrences([1, 2, 2, 3, 4, 2, 5], 2) [1, 5] >>> find_occurrences([1, 2, 3, 4, 5], 6) [-1, -1] pass","solution":"def find_occurrences(arr, X): Returns the indices of the first and last occurrences of X in the list. If X does not exist in the list, return [-1, -1] try: first_index = arr.index(X) last_index = len(arr) - 1 - arr[::-1].index(X) # Reverse the list and find the first occurrence return [first_index, last_index] except ValueError: return [-1, -1]"},{"question":"def longest_bitonic_subarray_length(n: int, temperatures: List[int]) -> int: Determine the length of the longest continuous subarray of days where the temperature continuously increases before it starts to decrease. >>> longest_bitonic_subarray_length(7, [2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_bitonic_subarray_length(5, [1, 2, 3, 4, 5]) 0 >>> longest_bitonic_subarray_length(5, [5, 4, 3, 2, 1]) 0 >>> longest_bitonic_subarray_length(6, [1, 3, 5, 4, 2, 1]) 6 >>> longest_bitonic_subarray_length(6, [2, 2, 2, 2, 2, 2]) 0 >>> longest_bitonic_subarray_length(4, [1, 3, 5, 3]) 4","solution":"def longest_bitonic_subarray_length(n, temperatures): if n < 3: return 0 up = [0] * n down = [0] * n for i in range(1, n): if temperatures[i] > temperatures[i - 1]: up[i] = up[i - 1] + 1 for i in range(n-2, -1, -1): if temperatures[i] > temperatures[i + 1]: down[i] = down[i + 1] + 1 max_len = 0 for i in range(n): if up[i] > 0 and down[i] > 0: max_len = max(max_len, up[i] + down[i] + 1) return max_len"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Write a function transpose_matrix that takes a 2D list (matrix) of integers as input and returns the transposed matrix. The transpose of a matrix is obtained by swapping the rows and columns, so the element at position [i][j] in the original matrix becomes the element at position [j][i] in the transposed matrix. >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([ ... [1, 2, 3] ... ]) [[1], [2], [3]] >>> transpose_matrix([ ... [1], ... [2], ... [3] ... ]) [[1, 2, 3]] >>> transpose_matrix([ ... [1] ... ]) [[1]]","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given 2D matrix. # Get dimensions of the matrix rows = len(matrix) cols = len(matrix[0]) # Initialize transposed matrix with switched dimensions transposed = [[0]*rows for _ in range(cols)] # Fill in the transposed matrix for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"def count_distinct_substrings(s: str, n: int) -> int: Returns the number of distinct substrings of length n that can be formed from the given string. >>> count_distinct_substrings('abacab', 3) 4 >>> count_distinct_substrings('aaaa', 2) 1 from solution import count_distinct_substrings def test_example_case(): assert count_distinct_substrings('abacab', 3) == 4 def test_single_char_repeated(): assert count_distinct_substrings('aaaa', 2) == 1 def test_length_equivalent(): assert count_distinct_substrings('abcdef', 6) == 1 def test_distinct_chars(): assert count_distinct_substrings('abcdef', 3) == 4 def test_no_valid_substring(): assert count_distinct_substrings('abcde', 6) == 0 def test_all_substrings_same(): assert count_distinct_substrings('abababab', 2) == 2 def test_distinct_substrings(): assert count_distinct_substrings('abcdef', 2) == 5","solution":"def count_distinct_substrings(s, n): Returns the number of distinct substrings of length n. substrings = set() for i in range(len(s) - n + 1): substrings.add(s[i:i + n]) return len(substrings)"},{"question":"def is_happy_number(n: int) -> bool: Check whether a given positive integer is a happy number. A happy number is defined by the following process: - Replace the number by the sum of the squares of its digits. - Repeat the process until the number equals 1 or it loops endlessly in a cycle that does not include 1. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True >>> is_happy_number(20) False","solution":"def is_happy_number(n): Determines if a number is a happy number. seen = set() while n != 1 and n not in seen: seen.add(n) n = sum(int(char) ** 2 for char in str(n)) return n == 1"},{"question":"from typing import List, Tuple def minimum_cost_traversal(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given a connected undirected graph with \`n\` vertices and \`m\` edges. Each edge has a weight assigned to it. Your task is to perform a minimum-cost traversal of the graph that visits all vertices at least once. You can start at any vertex. >>> minimum_cost_traversal(4, 5, [(1, 2, 3), (2, 3, 4), (1, 3, 2), (3, 4, 7), (2, 4, 1)]) 6 >>> minimum_cost_traversal(3, 3, [(1, 2, 5), (2, 3, 4), (1, 3, 8)]) 9 >>> minimum_cost_traversal(5, 5, [(1, 2, 6), (2, 3, 2), (3, 4, 1), (4, 5, 5), (1, 5, 7)]) 14 >>> minimum_cost_traversal(5, 6, [(1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 4, 1), (4, 5, 1)]) 4 >>> minimum_cost_traversal(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 3","solution":"import heapq import itertools def minimum_cost_traversal(n, m, edges): # Build the graph as an adjacency list graph = [{} for _ in range(n)] for u, v, w in edges: if v-1 in graph[u-1]: if graph[u-1][v-1] > w: graph[u-1][v-1] = w else: graph[u-1][v-1] = w if u-1 in graph[v-1]: if graph[v-1][u-1] > w: graph[v-1][u-1] = w else: graph[v-1][u-1] = w # Prim's algorithm to find the minimum spanning tree weight def mst_cost(start): visited = [False] * n min_heap = [(0, start)] # (cost, vertex) total_cost = 0 edges_used = 0 while min_heap and edges_used < n: cost, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += cost edges_used += 1 for v, w in graph[u].items(): if not visited[v]: heapq.heappush(min_heap, (w, v)) return total_cost total_mst_cost = mst_cost(0) return total_mst_cost"},{"question":"def perform_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, int]]) -> int: Updates the array based on the operations and returns the sum of the elements of the updated array. :param n: Number of elements in the array :param q: Number of operations :param array: Initial array :param operations: List of operations where each tuple is (i, v) >>> perform_operations(5, 3, [1, 2, 3, 4, 5], [(2, 3), (2, -2), (5, 10)]) 26 >>> perform_operations(4, 2, [0, 0, 0, 0], [(1, 7), (3, -5)]) 2","solution":"def perform_operations(n, q, array, operations): Updates the array based on the operations and returns the sum of the elements of the updated array. :param n: int : Number of elements in the array :param q: int : Number of operations :param array: List[int] : Initial array :param operations: List[Tuple[int, int]] : List of operations where each tuple is (i, v) :return: int : Sum of the array after performing all the operations for i, v in operations: array[i-1] += v # Adjust for 1-indexed to 0-indexed return sum(array)"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each letter in the string \`s\` by \`n\` positions in the alphabet. Preserves case and leaves non-alphabet characters unchanged. >>> shift_string(\\"abc\\", 2) \\"cde\\" >>> shift_string(\\"XYZ\\", 3) \\"ABC\\" >>> shift_string(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\"","solution":"def shift_string(s, n): Shifts each letter in the string \`s\` by \`n\` positions in the alphabet. Preserves case and leaves non-alphabet characters unchanged. shifted_string = [] for char in s: if char.isalpha(): if char.islower(): new_char = chr((ord(char) - ord('a') + n) % 26 + ord('a')) else: new_char = chr((ord(char) - ord('A') + n) % 26 + ord('A')) shifted_string.append(new_char) else: shifted_string.append(char) return ''.join(shifted_string)"},{"question":"def relay_race_order(N, P): Determines the running order of the team members in the relay race. Args: N : int Number of team members. P : list of int List where P[i] represents the position of the runner who receives the baton from runner i (1-based index). Returns: list of int The order in which the team members run the relay race. Example: >>> relay_race_order(4, [2, 3, 4, 1]) [1, 2, 3, 4] >>> relay_race_order(3, [3, 1, 2]) [1, 3, 2]","solution":"def relay_race_order(N, P): Determines the running order of the team members in the relay race. Args: N : int Number of team members. P : list of int List where P[i] represents the position of the runner who receives the baton from runner i (1-based index). Returns: list of int The order in which the team members run the relay race. order = [0] * N current_runner = 1 # Starting with runner 1 for i in range(N): order[i] = current_runner current_runner = P[current_runner - 1] return order"},{"question":"def find_last_number(arrays): For each array, apply the reduction rules until no moves can be made, and return the last number remaining in each array. Parameters: arrays (list of lists): A list where each element is an array of integers. Returns: list: A list with the final remaining number for each input array. # Implementation goes here def parse_input_and_solve(input_data): Parses the input data, solves the problem by calling find_last_number, and returns the solution for each array. Parameters: input_data (str): The input data as a string. Returns: list: A list with the final remaining number for each input array. # Implementation goes here # Example usage and test cases import pytest def test_find_last_number(): assert find_last_number([[4, 6, 8]]) == [2] assert find_last_number([[5, 15]]) == [5] assert find_last_number([[10, 10, 10, 10]]) == [10] assert find_last_number([[3, 3, 9, 3, 3]]) == [3] assert find_last_number([[7, 14, 21]]) == [7] def test_parse_input_and_solve(): input_data = \\"3n3 4 6 8n2 5 15n4 10 10 10 10n\\" assert parse_input_and_solve(input_data) == [2, 5, 10] input_data = \\"2n3 7 14 21n5 3 3 9 3 3n\\" assert parse_input_and_solve(input_data) == [7, 3] def test_find_last_number_edge_cases(): assert find_last_number([[1, 1000000]]) == [1] assert find_last_number([[2, 2]]) == [2] if __name__ == \\"__main__\\": pytest.main()","solution":"def find_last_number(arrays): For each array, apply the reduction rules until no moves can be made, and return the last number remaining in each array. Parameters: arrays (list of lists): A list where each element is an array of integers. Returns: list: A list with the final remaining number for each input array. result = [] for array in arrays: while len(set(array)) > 1: max_val = max(array) min_val = min(array) max_index = array.index(max_val) array[max_index] = max_val - min_val result.append(array[0]) return result def parse_input_and_solve(input_data): Parses the input data, solves the problem by calling find_last_number, and returns the solution for each array. Parameters: input_data (str): The input data as a string. Returns: list: A list with the final remaining number for each input array. lines = input_data.strip().split('n') t = int(lines[0]) arrays = [] for i in range(1, len(lines)): arr = list(map(int, lines[i].split())) arrays.append(arr[1:]) # Ignore the first element which is the size return find_last_number(arrays)"},{"question":"def quickselect(arr, low, high, k): A utility function to perform the Quickselect algorithm. def partition(arr, low, high): A utility function to perform the partitioning for Quickselect. def find_kth_smallest_element(n, k, arr): Given a list of distinct integers, find the kth smallest element using the Quickselect algorithm. Parameters: n (int): The size of the list. k (int): The position (1-based) of the smallest element to find. arr (List[int]): The list of distinct integers. Returns: int: The kth smallest element in the list. Examples: >>> find_kth_smallest_element(6, 3, [7, 10, 4, 3, 20, 15]) 7 >>> find_kth_smallest_element(5, 1, [1, 2, 3, 4, 5]) 1 >>> find_kth_smallest_element(5, 5, [1, 2, 3, 4, 5]) 5 >>> find_kth_smallest_element(5, 2, [9, 7, 5, 3, 1]) 3 >>> find_kth_smallest_element(7, 4, [11, 9, 8, 10, 3, 15, 20]) 10","solution":"def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index < k: return quickselect(arr, pivot_index + 1, high, k) else: return quickselect(arr, low, pivot_index - 1, k) def partition(arr, low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def find_kth_smallest_element(n, k, arr): return quickselect(arr, 0, n - 1, k - 1)"},{"question":"def min_items_to_reach_target(prices: List[int], target: int) -> int: Determine the minimum number of items to purchase to reach or exceed the given billing amount. >>> min_items_to_reach_target([100, 200, 300, 400, 500], 700) 2 >>> min_items_to_reach_target([150, 350, 450], 100) 1 >>> min_items_to_reach_target([800, 850, 900, 950], 5000) -1","solution":"def min_items_to_reach_target(prices, target): prices.sort(reverse=True) # Sort prices in descending order total_sum = 0 count = 0 for price in prices: total_sum += price count += 1 if total_sum >= target: return count return -1 # Return -1 if target cannot be met"},{"question":"def maximize_minimum_energy(T, test_cases): You are given an array of positive integers representing the energy levels of N different devices. You also have a budget of B units of energy that can be allocated to boost the energy levels of the devices. Each unit of energy can increase the energy level of a device by 1. Your task is to maximize the minimum energy level among all devices after using the budget optimally. ------ Input Format ------ - The first line of input contains a single integer T, denoting the number of test cases. - Each test case consists of two lines: - The first line contains two space-separated integers N and B — the number of devices and the energy budget. - The second line contains N space-separated integers representing the initial energy levels of the devices. ------ Output Format ------ For each test case, output on a new line the maximum possible minimum energy level among all devices after using up the budget optimally. ------ Constraints ------ 1 ≤ T ≤ 10 1 ≤ N ≤ 10^4 0 ≤ B ≤ 10^9 1 ≤ initial_energy_level ≤ 10^9 ------ Examples ------ >>> maximize_minimum_energy(2, [((3, 6), [1, 3, 2]), ((4, 10), [5, 2, 4, 3])]) [4, 6] >>> maximize_minimum_energy(1, [((2, 5), [1, 2])]) [4] >>> maximize_minimum_energy(1, [((3, 9), [3, 3, 3])]) [6] def test_maximize_minimum_energy(): assert maximize_minimum_energy(2, [((3, 6), [1, 3, 2]), ((4, 10), [5, 2, 4, 3])]) == [4, 6] assert maximize_minimum_energy(1, [((2, 5), [1, 2])]) == [4] assert maximize_minimum_energy(1, [((3, 9), [3, 3, 3])]) == [6] assert maximize_minimum_energy(1, [((5, 0), [1, 2, 3, 4, 5])]) == [1] assert maximize_minimum_energy(1, [((1, 1000000000), [1])]) == [1000000001] if __name__ == \\"__main__\\": test_maximize_minimum_energy() print(\\"All tests passed!\\")","solution":"def maximize_minimum_energy(T, test_cases): def can_achieve_min(energy_levels, B, x): extra_energy_needed = sum(max(0, x - e) for e in energy_levels) return extra_energy_needed <= B results = [] for i in range(T): N, B = test_cases[i][0] energy_levels = test_cases[i][1] low, high = min(energy_levels), max(energy_levels) + B best_min_level = low while low <= high: mid = (low + high) // 2 if can_achieve_min(energy_levels, B, mid): best_min_level = mid low = mid + 1 else: high = mid - 1 results.append(best_min_level) return results"},{"question":"def record_height_and_query_growth(n, operations): Record the height of the plant on given days and query the average growth rate over periods. :param n: number of operations :param operations: list of operations :return: list of results for each query operation Examples: >>> record_height_and_query_growth(6, [\\"record 1 3\\", \\"record 2 8\\", \\"record 3 10\\", \\"record 4 15\\", \\"record 5 18\\", \\"query 2 5\\"]) [\\"3.3333\\"] >>> record_height_and_query_growth(3, [\\"record 1 0\\", \\"record 2 0\\", \\"query 1 2\\"]) [\\"0.0000\\"] # Implement the function here def plant_growth_operations(n, operations): return record_height_and_query_growth(n, operations) # Test cases def test_basic_functionality(): operations = [ \\"record 1 3\\", \\"record 2 8\\", \\"record 3 10\\", \\"record 4 15\\", \\"record 5 18\\", \\"query 2 5\\" ] assert plant_growth_operations(6, operations) == [\\"3.3333\\"] def test_small_sample(): operations = [ \\"record 1 0\\", \\"record 2 0\\", \\"query 1 2\\" ] assert plant_growth_operations(3, operations) == [\\"0.0000\\"] def test_complex_cases(): operations = [ \\"record 10 100\\", \\"record 15 300\\", \\"record 20 400\\", \\"query 10 15\\", \\"query 15 20\\" ] assert plant_growth_operations(5, operations) == [ \\"40.0000\\", \\"20.0000\\" ] def test_with_missing_heights(): operations = [ \\"record 3 6\\", \\"query 1 3\\" ] assert plant_growth_operations(2, operations) == [\\"0.0000\\"] def test_large_input(): operations = [ *(\\"record {} {}\\".format(i, i * 2) for i in range(1, 100001)), \\"query 1 100000\\" ] # growth rate from 1 to 100000 should be approximately 2.0 assert plant_growth_operations(100001, operations)[-1] == \\"2.0000\\"","solution":"def record_height_and_query_growth(n, operations): Record the height of the plant on given days and query the average growth rate over periods. :param n: number of operations :param operations: list of operations :return: list of results for each query operation heights = {} results = [] for operation in operations: op = operation.split() if op[0] == \\"record\\": day = int(op[1]) height = int(op[2]) heights[day] = height elif op[0] == \\"query\\": d1 = int(op[1]) d2 = int(op[2]) if d1 in heights and d2 in heights: growth_rate = (heights[d2] - heights[d1]) / (d2 - d1) results.append(f\\"{growth_rate:.4f}\\") else: results.append(\\"0.0000\\") # Assuming a height of 0 if not recorded return results def plant_growth_operations(n, operations): return record_height_and_query_growth(n, operations)"},{"question":"def isAtOrigin(moves: str) -> bool: Determines if the sequence of moves returns to the origin (0,0). Parameters: moves (str): A string representing the sequence of moves. Returns: bool: True if the moves return to the origin, False otherwise. >>> isAtOrigin(\\"UDLR\\") == True >>> isAtOrigin(\\"UUDDLRLR\\") == True >>> isAtOrigin(\\"UUDLLR\\") == False >>> isAtOrigin(\\"U\\") == False >>> isAtOrigin(\\"\\") == True >>> isAtOrigin(\\"UURRDDLL\\") == True >>> isAtOrigin(\\"UDRL\\" * 2500) == True >>> isAtOrigin(\\"UUDDLRLRU\\") == False","solution":"def isAtOrigin(moves: str) -> bool: Determines if the sequence of moves returns to the origin (0,0). Parameters: moves (str): A string representing the sequence of moves. Returns: bool: True if the moves return to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"from math import sqrt from typing import List, Tuple def calculate_total_effort(n: int, checkpoints: List[Tuple[int, int]]) -> float: Calculate the total effort required to complete the marathon. Parameters: n (int): The number of checkpoints. checkpoints (List[Tuple[int, int]]): List of tuples representing the coordinates of each checkpoint. Returns: float: The total effort rounded to two decimal places. Examples: >>> calculate_total_effort(3, [(0, 0), (3, 4), (6, 8)]) 10.00 >>> calculate_total_effort(4, [(0, 0), (1, 1), (2, 2), (3, 3)]) 4.24","solution":"from math import sqrt def calculate_total_effort(n, checkpoints): Calculate the total effort required to complete the marathon. Parameters: n (int): The number of checkpoints. checkpoints (List[Tuple[int, int]]): List of tuples representing the coordinates of each checkpoint. Returns: float: The total effort rounded to two decimal places. total_effort = 0.0 for i in range(1, n): x1, y1 = checkpoints[i - 1] x2, y2 = checkpoints[i] distance = sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) total_effort += distance return round(total_effort, 2)"},{"question":"def encrypt_string(s: str) -> str: Transform the input string into the corresponding encrypted sequence based on the given rules: Each character in the input string should be replaced by its corresponding position in the alphabet, where 'a' is 1, 'b' is 2, ..., and 'z' is 26. Concatenate all the string representations of the numbers to form the final encrypted sequence. >>> encrypt_string(\\"cab\\") \\"312\\" >>> encrypt_string(\\"hello\\") \\"85121215\\" >>> encrypt_string(\\"xyz\\") \\"242526\\"","solution":"def encrypt_string(s): This function takes a string s composed of lowercase Latin letters and returns an encrypted sequence where each character is replaced by its corresponding position in the alphabet (1 for 'a', 2 for 'b', ..., 26 for 'z'). result = ''.join(str(ord(char) - ord('a') + 1) for char in s) return result"},{"question":"def find_single_occurrence(nums: List[int]) -> int: Returns the integer that appears only once in the sequence. Args: nums (list of int): The input list of integers where all integers except one appear exactly twice. Returns: int: the integer that appears only once. pass def test_single_occurrence_basic(): assert find_single_occurrence([2, 3, 2, 3, 4]) == 4 def test_single_occurrence_all_positive(): assert find_single_occurrence([1, 1, 2, 2, 3]) == 3 def test_single_occurrence_with_large_numbers(): assert find_single_occurrence([1000000000, 1000000000, 1]) == 1 def test_single_occurrence_at_the_start(): assert find_single_occurrence([9, 7, 7, 8, 8]) == 9 def test_single_occurrence_at_the_end(): assert find_single_occurrence([10, 10, 12, 5, 5]) == 12 def test_single_occurrence_large_dataset(): # Create a large dataset with one element occurring once large_dataset = [i for i in range(1, 100001)] * 2 + [100001] assert find_single_occurrence(large_dataset) == 100001","solution":"def find_single_occurrence(nums): Returns the integer that appears only once in the sequence. Args: nums (list of int): The input list of integers where all integers except one appear exactly twice. Returns: int: the integer that appears only once. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"def is_prime(n): Check if a number n is prime. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True pass def solve(test_cases): Solve the problem for each test case in the list of test_cases. >>> solve([1, 2, 7]) [\\"NO\\", \\"YES\\", \\"YES\\"] >>> solve([0, 4, 5, 6]) [\\"NO\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> solve([11, 13, 23, 29]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> solve([34, 35, 36, 37]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_prime(n): Check if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True # Precompute prime status for all numbers from 0 to 60 prime_status = [is_prime(i) for i in range(61)] def solve(test_cases): Solve the problem for each test case. results = [] for y in test_cases: if prime_status[y]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def unique_codes(n: int) -> int: Calculate the total number of unique codes of length n, using the given characters. Each character can be a digit (0-9) or a symbol from the set {A, B, C, D, E, F}. The result should be output modulo (10^9 + 7). >>> unique_codes(3) 4096 >>> unique_codes(5) 1048576 >>> unique_codes(1) 16 from unique_codes import test_unique_codes def test_unique_codes_len_1(): assert unique_codes(1) == 16 def test_unique_codes_len_3(): assert unique_codes(3) == 4096 def test_unique_codes_len_5(): assert unique_codes(5) == 1048576 def test_unique_codes_max_len(): # Use known value or calculation for n = 10^5. Here we just use the function to calculate it. result = unique_codes(10**5) assert isinstance(result, int) # Just ensure it's an integer assert 0 <= result < 10**9 + 7 # It must be within the proper range. # Edge test for minimal n def test_unique_codes_len_minimal(): assert unique_codes(1) == 16 # General case test def test_unique_codes_random_len(): # Example n = 10 expected_result = pow(16, 10, 10**9 + 7) assert unique_codes(10) == expected_result","solution":"def unique_codes(n): MOD = 10**9 + 7 return pow(16, n, MOD)"},{"question":"def partition_items(N: int, C: int, items_data: List[str], K: int) -> Union[str, List[List[int]]]: Partition the items into collections as described by input. Parameters: N (int): The number of items. C (int): The number of characteristics each item has. items_data (List[str]): List of item descriptions, each as a string containing an ID followed by C characteristics. K (int): The number of items each collection should have. Returns: Union[str, List[List[int]]]: A list of collections such that each collection contains K item identifiers, or \\"impossible\\" if it's not possible to form the required collections. Example: >>> partition_items(5, 3, [\\"1 1 2 3\\", \\"2 2 3 4\\", \\"3 1 3 4\\", \\"4 5 6 7\\", \\"5 4 5 6\\"], 2) 'impossible' >>> partition_items(4, 2, [\\"1 1 2\\", \\"2 3 4\\", \\"3 5 6\\", \\"4 7 8\\"], 2) [[1, 2], [3, 4]]","solution":"def can_partition(items, K): from itertools import combinations def check_no_overlap(items): seen = set() for item in items: if any(char in seen for char in item[1:]): return False seen.update(item[1:]) return True N = len(items) if N % K != 0: return \\"impossible\\" num_collections = N // K all_permutations = combinations(items, K) used_items = set() collections = [] for comb in all_permutations: if all(item not in used_items for item in comb) and check_no_overlap(comb): used_items.update(comb) collections.append([item[0] for item in comb]) if len(collections) == num_collections: return collections return \\"impossible\\" def partition_items(N, C, items_data, K): items = [tuple(map(int, item.split())) for item in items_data] results = can_partition(items, K) return results"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Given a sequence of n days, and a list of daily temperatures for those days, determine how many days you would have to wait until a warmer temperature for each day. If there is no future day for which this is possible, put 0 for that day instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50]) [1, 1, 0] >>> daily_temperatures([30, 20, 10, 5]) [0, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Returns a list of integers indicating the number of days to wait for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"def findPair(nums, target): Finds a pair of indices (i, j) such that nums[i] + nums[j] equals the target sum. Returns the pair of indices if such a pair exists, otherwise returns an empty list. Args: nums (List[int]): An array of integers. target (int): The target sum. Returns: List[int]: The list of the pair of indices [i, j] if such a pair exists, otherwise an empty list. Examples: >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([3, 2, 4], 6) [1, 2] >>> findPair([3, 3], 6) [0, 1] from solution import findPair def test_find_pair(): assert findPair([2, 7, 11, 15], 9) == [0, 1] assert findPair([3, 2, 4], 6) == [1, 2] assert findPair([3, 3], 6) == [0, 1] assert findPair([1, 2, 3, 4, 5], 10) == [] assert findPair([0, -1, -2, -3, -4, -5], -8) == [3, 5] assert findPair([1, 2, 3, 4, 5], 8) == [2, 4] def test_find_pair_with_duplicates(): assert findPair([1, 5, 1, 5], 10) == [1, 3] assert findPair([1, 5, 1, 5], 6) == [0, 1] def test_find_pair_edge_cases(): assert findPair([1], 2) == [] assert findPair([], 2) == [] assert findPair([3, 3, 3], 6) == [0, 1] def test_find_pair_negative_and_zero(): assert findPair([0, 4, 3, 0], 0) == [0, 3] assert findPair([-1, -2, -3, -4, -5], -8) == [2, 4] assert findPair([-1, -2, -3, 10], 8) == [1, 3]","solution":"def findPair(nums, target): Finds a pair of indices (i, j) such that nums[i] + nums[j] equals the target sum. Returns the pair of indices if such a pair exists, otherwise returns an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def longest_subarray_within_threshold(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subarray where the difference between the maximum and minimum elements is ≤ k. >>> longest_subarray_within_threshold(5, 3, [1, 3, 5, 7, 9]) 2 >>> longest_subarray_within_threshold(5, 5, [1, 3, 5, 7, 9]) 3 >>> longest_subarray_within_threshold(1, 3, [1]) 1 >>> longest_subarray_within_threshold(2, 2, [2, 1]) 2 >>> longest_subarray_within_threshold(8, 1, [1, 2, 3, 4, 5, 6, 7, 8]) 2 >>> longest_subarray_within_threshold(5, 5, [5, 5, 5, 5, 5]) 5 >>> longest_subarray_within_threshold(4, 1000000000, [1, 2, 3, 4]) 4","solution":"def longest_subarray_within_threshold(n, k, arr): Returns the length of the longest subarray where the difference between the maximum and minimum elements is ≤ k. if not arr: return 0 start = 0 max_len = 1 min_q = [] max_q = [] for end in range(n): while min_q and arr[min_q[-1]] >= arr[end]: min_q.pop() while max_q and arr[max_q[-1]] <= arr[end]: max_q.pop() min_q.append(end) max_q.append(end) while arr[max_q[0]] - arr[min_q[0]] > k: start += 1 if min_q[0] < start: min_q.pop(0) if max_q[0] < start: max_q.pop(0) max_len = max(max_len, end - start + 1) return max_len"},{"question":"def sumOfDigits(s: str) -> int: Given a string of any length that contains both numerical and non-numerical characters, find the sum of all digits in the string. >>> sumOfDigits(\\"abc123\\") 6 >>> sumOfDigits(\\"1a2b3c\\") 6 >>> sumOfDigits(\\"abc\\") 0 >>> sumOfDigits(\\"abc!@#\\") 0","solution":"def sumOfDigits(s): Returns the sum of all digits in the string s. return sum(int(char) for char in s if char.isdigit())"},{"question":"def replace_crosses_with_dots(grid: List[str], N: int, M: int) -> List[str]: Given a grid of stars ('*') and dots ('.'), identify and replace all crosses with dots. A cross extends an equal number of cells horizontally and vertically with a center as a star. Args: grid: List[str] - The initial grid configuration represented as a list of strings. N: int - The number of rows in the grid. M: int - The number of columns in the grid. Returns: List[str] - The modified grid with all crosses replaced by dots. Example: >>> replace_crosses_with_dots([\\"..*..\\", \\"..*..\\", \\"*****\\", \\"..*..\\", \\"..*..\\"], 5, 5) ['.....', '.....', '.....', '.....', '.....'] >>> replace_crosses_with_dots([\\"..*..\\", \\"..*..\\", \\"..*..\\", \\".***.\\", \\".....\\"], 5, 5) ['.....', '.....', '.....', '.....', '.....']","solution":"def replace_crosses_with_dots(grid, N, M): def is_cross(i, j, length): # Check the arm lengths for validity within grid bounds for k in range(1, length+1): if i-k < 0 or i+k >= N or j-k < 0 or j+k >= M: return False if grid[i-k][j] != '*' or grid[i+k][j] != '*' or grid[i][j-k] != '*' or grid[i][j+k] != '*': return False return True def remove_cross(i, j, length): # Replace the stars with dots at the center and arms grid[i][j] = '.' for k in range(1, length+1): grid[i-k][j] = '.' grid[i+k][j] = '.' grid[i][j-k] = '.' grid[i][j+k] = '.' # Make a deep copy of the grid so we don't modify the input directly grid = [list(row) for row in grid] max_cross_length = min(N, M) // 2 for length in range(max_cross_length, 0, -1): for i in range(N): for j in range(M): if grid[i][j] == '*': if is_cross(i, j, length): remove_cross(i, j, length) return [\\"\\".join(row) for row in grid] # Sample use if __name__ == \\"__main__\\": input_grid = [ \\"..*..\\", \\"..*..\\", \\"*****\\", \\"..*..\\", \\"..*..\\" ] N, M = 5, 5 result = replace_crosses_with_dots(input_grid, N, M) for line in result: print(line)"},{"question":"def can_travel_within_cost(n: int, m: int, k: int, bridges: List[Tuple[int, int, int]], start: int, end: int) -> str: Determine whether it is possible to travel from one specific island to another with a total cost that does not exceed a given value. >>> can_travel_within_cost(5, 6, 15, [(1, 2, 3), (1, 3, 10), (2, 4, 7), (3, 4, 5), (3, 5, 1), (4, 5, 3)], 1, 5) 'YES' >>> can_travel_within_cost(4, 3, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 2)], 1, 4) 'NO' from typing import List, Tuple def test_can_travel_within_cost_example1(): n, m, k = 5, 6, 15 bridges = [(1, 2, 3), (1, 3, 10), (2, 4, 7), (3, 4, 5), (3, 5, 1), (4, 5, 3)] start, end = 1, 5 assert can_travel_within_cost(n, m, k, bridges, start, end) == \\"YES\\" def test_can_travel_within_cost_example2(): n, m, k = 4, 3, 5 bridges = [(1, 2, 3), (2, 3, 4), (3, 4, 2)] start, end = 1, 4 assert can_travel_within_cost(n, m, k, bridges, start, end) == \\"NO\\" def test_can_travel_within_cost_no_bridges(): n, m, k = 3, 0, 10 bridges = [] start, end = 1, 3 assert can_travel_within_cost(n, m, k, bridges, start, end) == \\"NO\\" def test_can_travel_within_cost_single_bridge(): n, m, k = 2, 1, 5 bridges = [(1, 2, 5)] start, end = 1, 2 assert can_travel_within_cost(n, m, k, bridges, start, end) == \\"YES\\" def test_can_travel_within_cost_large_k(): n, m, k = 4, 4, 1000000000 bridges = [(1, 2, 10), (2, 3, 5), (3, 4, 20), (1, 4, 100)] start, end = 1, 4 assert can_travel_within_cost(n, m, k, bridges, start, end) == \\"YES\\"","solution":"from heapq import heappush, heappop import sys def can_travel_within_cost(n, m, k, bridges, start, end): graph = [[] for _ in range(n+1)] for u, v, w in bridges: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, start)] # (cost, node) costs = [sys.maxsize] * (n + 1) costs[start] = 0 while pq: current_cost, u = heappop(pq) if current_cost > costs[u]: continue for v, w in graph[u]: new_cost = current_cost + w if new_cost < costs[v] and new_cost <= k: costs[v] = new_cost heappush(pq, (new_cost, v)) return \\"YES\\" if costs[end] <= k else \\"NO\\""},{"question":"def initialize_grid(size=100): Initialize a size x size grid filled with zeros. >>> grid = initialize_grid() >>> len(grid) 100 >>> len(grid[0]) 100 >>> all(cell == 0 for row in grid for cell in row) True def draw_horizontal_line(grid, x, y, length): Draw a horizontal line on the grid starting at (x, y) with a specified length. >>> grid = initialize_grid() >>> draw_horizontal_line(grid, 1, 1, 5) >>> grid[1][1:6] [1, 1, 1, 1, 1] def draw_vertical_line(grid, x, y, length): Draw a vertical line on the grid starting at (x, y) with a specified length. >>> grid = initialize_grid() >>> draw_vertical_line(grid, 2, 2, 3) >>> grid[2][2] 1 >>> grid[3][2] 1 >>> grid[4][2] 1 def process_commands(commands): Process a list of drawing commands and return the resulting grid. >>> commands = [\\"H 1 1 5\\", \\"V 2 2 3\\"] >>> grid = process_commands(commands) >>> grid[1][1:6] [1, 1, 1, 1, 1] >>> grid[2][2] 1 >>> grid[3][2] 1 >>> grid[4][2] 1","solution":"def initialize_grid(size=100): return [[0 for _ in range(size)] for _ in range(size)] def draw_horizontal_line(grid, x, y, length): for i in range(length): grid[x][y + i] = 1 def draw_vertical_line(grid, x, y, length): for i in range(length): grid[x + i][y] = 1 def process_commands(commands): grid = initialize_grid() for command in commands: if command.startswith(\\"H\\"): _, x, y, l = command.split() draw_horizontal_line(grid, int(x), int(y), int(l)) elif command.startswith(\\"V\\"): _, x, y, l = command.split() draw_vertical_line(grid, int(x), int(y), int(l)) elif command == \\"Q\\": break return grid def print_grid(grid): for row in grid: print(\\"\\".join(map(str, row))) # Example usage commands = [ \\"H 1 1 5\\", \\"V 2 2 3\\", \\"Q\\" ] grid = process_commands(commands) print_grid(grid)"},{"question":"def trackUsage(logs: List[str]) -> Dict[str, int]: Returns a dictionary with product names as keys and their usage counts as values. Example usage: >>> trackUsage([\\"keyboard\\", \\"mouse\\", \\"keyboard\\", \\"monitor\\", \\"keyboard\\", \\"mouse\\"]) {'keyboard': 3, 'mouse': 2, 'monitor': 1} >>> trackUsage([\\"laptop\\", \\"headphones\\", \\"laptop\\", \\"mouse\\", \\"headphones\\", \\"headphones\\"]) {'laptop': 2, 'headphones': 3, 'mouse': 1}","solution":"def trackUsage(logs): Returns a dictionary with product names as keys and their usage counts as values. usage_dict = {} for log in logs: if log in usage_dict: usage_dict[log] += 1 else: usage_dict[log] = 1 return usage_dict"},{"question":"def longestSubarray(arr: List[int], threshold: int) -> int: Returns the length of the longest subarray with sum less than or equal to the threshold. >>> longestSubarray([1, 2, 3], 6) == 3 >>> longestSubarray([1, 2, 3, 4, 5], 8) == 3 >>> longestSubarray([1, 1, 1, 1], 10) == 4 >>> longestSubarray([4, 5, 1, 1, 1, 1], 4) == 4 >>> longestSubarray([10**4, 10**4, 10**4], 10**4) == 1 >>> longestSubarray([2], 2) == 1 >>> longestSubarray([10, 20, 30], 5) == 0 pass","solution":"def longestSubarray(arr, threshold): Returns the length of the longest subarray with sum less than or equal to the threshold. max_length = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > threshold: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def count_connected_components(n, m, edges): Count the number of connected components in an undirected graph. Parameters: n (int): The number of nodes. m (int): The number of edges. edges (List[Tuple[int, int]]): A list of edges where each edge connects two nodes. Returns: int: The number of connected components in the graph. Examples: >>> count_connected_components(6, 5, [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6)]) 2 >>> count_connected_components(7, 3, [(1, 2), (2, 3), (4, 5)]) 4 # Example validation print(count_connected_components(6, 5, [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6)])) # Output: 2 print(count_connected_components(7, 3, [(1, 2), (2, 3), (4, 5)])) # Output: 4","solution":"def count_connected_components(n, m, edges): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) while queue: curr_node = queue.popleft() for neighbor in graph[curr_node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() connected_components = 0 for node in range(1, n+1): if node not in visited: bfs(node) connected_components += 1 return connected_components"},{"question":"def max_discount(n: int, promo_codes: List[Tuple[str, int]]) -> int: Returns the maximum discount a customer can receive from valid promo codes. Args: n: int : Number of promo codes promo_codes: List[Tuple[str, int]] : List containing tuples of promo code and discount Returns: int : Maximum discount a valid promo code offers >>> max_discount(3, [(\\"A1B2\\", 50), (\\"C3D4\\", 100), (\\"E5F6G7\\", 75)]) 100 >>> max_discount(4, [(\\"A0B1\\", 20), (\\"B1A2\\", 10), (\\"C0D1\\", 30), (\\"A1C2\\", 25)]) 30 >>> max_discount(2, [(\\"AABB\\", 50), (\\"BBAA\\", 60)]) 0","solution":"def max_discount(n, promo_codes): Returns the maximum discount a customer can receive from valid promo codes. Args: n: int : Number of promo codes promo_codes: List[Tuple[str, int]] : List containing tuples of promo code and discount Returns: int : Maximum discount a valid promo code offers max_discount = 0 for promo, discount in promo_codes: if 'AB' not in promo and 'BA' not in promo: max_discount = max(max_discount, discount) return max_discount"},{"question":"def max_water_volume(heights): Calculate the maximum amount of water that can be trapped between the bars after raining. :param heights: List of integers representing the height of the bars. :return: Integer representing the maximum volume of water trapped. Examples: >>> max_water_volume([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> max_water_volume([4,2,0,3,2,5]) 9 >>> max_water_volume([1,1,1,1]) 0 >>> max_water_volume([1,0,2]) 1 # Your code here","solution":"def max_water_volume(heights): Calculate the maximum amount of water that can be trapped between the bars after raining. :param heights: List of integers representing the height of the bars. :return: Integer representing the maximum volume of water trapped. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def find_best_destination(n: int, m: int, scores: List[List[int]]) -> int: This function finds the destination with the highest cumulative score. Arguments: n -- number of friends m -- number of destinations scores -- matrix of scores given by each friend to each destination Returns: Integer, 1-based index of the destination with the highest cumulative score Example: >>> find_best_destination(3, 4, [[8, 6, 7, 5], [5, 7, 8, 6], [6, 5, 9, 8]]) 3 >>> find_best_destination(2, 2, [[10, 20], [20, 10]]) 1","solution":"def find_best_destination(n, m, scores): This function finds the destination with the highest cumulative score. :param n: Integer, number of friends :param m: Integer, number of destinations :param scores: List of lists, each inner list containing m integers representing scores for each destination by one friend :return: Integer, 1-based index of the destination with the highest cumulative score cumulative_scores = [0] * m for i in range(n): for j in range(m): cumulative_scores[j] += scores[i][j] max_score = max(cumulative_scores) return cumulative_scores.index(max_score) + 1"},{"question":"def can_form_target_string(n: int, string_list: List[str], target: str) -> str: Determines if the target string can be formed by concatenating exactly two different strings from the list. >>> can_form_target_string(3, ['hello', 'world', 'day'], 'helloworld') \\"POSSIBLE\\" >>> can_form_target_string(4, ['a', 'b', 'ab', 'cd'], 'abc') \\"IMPOSSIBLE\\"","solution":"def can_form_target_string(n, string_list, target): Determines if the target string can be formed by concatenating exactly two different strings from the list. string_set = set(string_list) target_len = len(target) for i in range(1, target_len): prefix = target[:i] suffix = target[i:] if prefix in string_set and suffix in string_set and prefix != suffix: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\""},{"question":"def sort_objects(items, attribute): Sorts a list of dictionaries by a given attribute in ascending order. Parameters: items (list): A list of dictionaries. attribute (str): The attribute to sort by. Returns: list: Sorted list of dictionaries or None if attribute is invalid. Examples: >>> items = [{'name': 'apple', 'price': 5}, {'name': 'banana', 'price': 2}, {'name': 'cherry', 'price': 7}] >>> sort_objects(items, 'price') [{'name': 'banana', 'price': 2}, {'name': 'apple', 'price': 5}, {'name': 'cherry', 'price': 7}] >>> sort_objects(items, 'name') [{'name': 'apple', 'price': 5}, {'name': 'banana', 'price': 2}, {'name': 'cherry', 'price': 7}] >>> sort_objects(items, 'weight') None >>> sort_objects(items, 123) None >>> sort_objects('wrong input', 'price') None","solution":"def sort_objects(items, attribute): Sorts a list of dictionaries by a given attribute in ascending order. Parameters: items (list): A list of dictionaries. attribute (str): The attribute to sort by. Returns: list: Sorted list of dictionaries or None if attribute is invalid. if not isinstance(items, list) or not all(isinstance(item, dict) for item in items): return None if not isinstance(attribute, str): return None if not all(attribute in item for item in items): return None return sorted(items, key=lambda x: x[attribute])"},{"question":"from typing import List def find_min_equal_rope_length(ropes: List[int]) -> int: Returns the minimum possible length for the equal length ropes after cutting exactly one rope, ensuring that all resultant ropes are of equal length. >>> find_min_equal_rope_length([4, 3, 2, 5, 6]) 1 >>> find_min_equal_rope_length([8, 1, 7, 3]) 1 >>> find_min_equal_rope_length([10]) 10 >>> find_min_equal_rope_length([5, 5, 5]) 5 >>> find_min_equal_rope_length([]) 0 >>> find_min_equal_rope_length([4, 8, 12, 16]) 4 >>> find_min_equal_rope_length([6, 9, 12, 15]) 3 >>> find_min_equal_rope_length([7, 11]) 1 >>> find_min_equal_rope_length([5, 7, 11]) 1","solution":"from math import gcd from functools import reduce def find_min_equal_rope_length(ropes): Returns the minimum possible length for the equal length ropes after cutting exactly one rope, ensuring that all resultant ropes are of equal length. if not ropes: return 0 total_length = sum(ropes) # Finding the GCD of all rope lengths gives the maximum length of equal segments we can have common_gcd = reduce(gcd, ropes) return common_gcd"},{"question":"def analyze_insects(test_cases): Analyze a dataset of insects and answer queries about them. Args: test_cases (List[dict]): A list of test cases, where each test case is a dictionary with: - n (int): The number of insects - insects (list of tuples): Each tuple containing (species, age, wing_length) - q (int): The number of queries - queries (list of str): Each string is a query in the format \\"average_age species\\" or \\"max_wing_length age\\" Returns: List[str]: The answers to the queries for each test case. Example usage: >>> test_cases = [ >>> { >>> \\"n\\": 3, >>> \\"insects\\": [(\\"bee\\", 2, 5.1), (\\"ant\\", 4, 8.3), (\\"bee\\", 3, 6.2)], >>> \\"q\\": 2, >>> \\"queries\\": [\\"average_age bee\\", \\"max_wing_length 2\\"] >>> }, >>> ] >>> analyze_insects(test_cases) == [\\"2.50\\", \\"8.30\\"] # Your code here # Unit tests def test_case_1(): test_cases = [ { \\"n\\": 3, \\"insects\\": [(\\"bee\\", 2, 5.1), (\\"ant\\", 4, 8.3), (\\"bee\\", 3, 6.2)], \\"q\\": 2, \\"queries\\": [\\"average_age bee\\", \\"max_wing_length 2\\"] } ] assert analyze_insects(test_cases) == [\\"2.50\\", \\"8.30\\"] def test_case_2(): test_cases = [ { \\"n\\": 4, \\"insects\\": [(\\"butterfly\\", 1, 2.5), (\\"butterfly\\", 3, 3.5), (\\"moth\\", 5, 4.5), (\\"fly\\", 2, 1.5)], \\"q\\": 3, \\"queries\\": [\\"average_age butterfly\\", \\"average_age fly\\", \\"max_wing_length 2\\"] } ] assert analyze_insects(test_cases) == [\\"2.00\\", \\"2.00\\", \\"4.50\\"] def test_no_data(): test_cases = [ { \\"n\\": 2, \\"insects\\": [(\\"bee\\", 3, 5.1), (\\"ant\\", 2, 8.3)], \\"q\\": 2, \\"queries\\": [\\"average_age butterfly\\", \\"max_wing_length 5\\"] } ] assert analyze_insects(test_cases) == [\\"No data\\", \\"No data\\"] def test_case_no_insects(): test_cases = [ { \\"n\\": 0, \\"insects\\": [], \\"q\\": 1, \\"queries\\": [\\"average_age bee\\"] } ] assert analyze_insects(test_cases) == [\\"No data\\"] def test_other_cases(): test_cases = [ { \\"n\\": 3, \\"insects\\": [(\\"moth\\", 10, 7.5), (\\"moth\\", 5, 4.5), (\\"moth\\", 7, 6.0)], \\"q\\": 2, \\"queries\\": [\\"average_age moth\\", \\"max_wing_length 5\\"] } ] assert analyze_insects(test_cases) == [\\"7.33\\", \\"7.50\\"]","solution":"def analyze_insects(test_cases): results = [] for case in test_cases: n = case['n'] insects = case['insects'] q = case['q'] queries = case['queries'] species_map = {} max_wing_age_map = [] for species, age, wing_length in insects: if species not in species_map: species_map[species] = [] species_map[species].append(age) if age > 0: max_wing_age_map.append((age, wing_length)) for query in queries: parts = query.split() if parts[0] == \\"average_age\\": species = parts[1] if species not in species_map or len(species_map[species]) == 0: results.append(\\"No data\\") else: avg_age = sum(species_map[species]) / len(species_map[species]) results.append(f\\"{avg_age:.2f}\\") elif parts[0] == \\"max_wing_length\\": age_query = int(parts[1]) possible_wings = [wing_length for age, wing_length in max_wing_age_map if age > age_query] if len(possible_wings) == 0: results.append(\\"No data\\") else: max_wing_length = max(possible_wings) results.append(f\\"{max_wing_length:.2f}\\") return results # Example usage: test_cases = [ { \\"n\\": 3, \\"insects\\": [(\\"bee\\", 2, 5.1), (\\"ant\\", 4, 8.3), (\\"bee\\", 3, 6.2)], \\"q\\": 2, \\"queries\\": [\\"average_age bee\\", \\"max_wing_length 2\\"] }, { \\"n\\": 4, \\"insects\\": [(\\"butterfly\\", 1, 2.5), (\\"butterfly\\", 3, 3.5), (\\"moth\\", 5, 4.5), (\\"fly\\", 2, 1.5)], \\"q\\": 3, \\"queries\\": [\\"average_age butterfly\\", \\"average_age fly\\", \\"max_wing_length 2\\"] } ] print(analyze_insects(test_cases))"},{"question":"def min_path_sum(grid): Given a grid of non-negative integers, returns the minimum sum path from the top-left corner to the bottom-right corner, only moving right or down. pass def parse_input(input_string): Parses the input string to extract the grid. pass # Test Cases def test_min_path_sum_example(): input_string = \\"3 3n1 3 1n1 5 1n4 2 1\\" grid = parse_input(input_string) assert min_path_sum(grid) == 7 def test_min_path_sum_small_grid(): input_string = \\"2 2n1 2n1 1\\" grid = parse_input(input_string) assert min_path_sum(grid) == 3 def test_min_path_sum_single_row(): input_string = \\"1 4n1 2 3 4\\" grid = parse_input(input_string) assert min_path_sum(grid) == 10 def test_min_path_sum_single_column(): input_string = \\"4 1n1n2n3n4\\" grid = parse_input(input_string) assert min_path_sum(grid) == 10 def test_min_path_sum_same_values(): input_string = \\"3 3n1 1 1n1 1 1n1 1 1\\" grid = parse_input(input_string) assert min_path_sum(grid) == 5","solution":"def min_path_sum(grid): Given a grid of non-negative integers, returns the minimum sum path from the top-left corner to the bottom-right corner, only moving right or down. n = len(grid) m = len(grid[0]) # Initialize a dp table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the minimum sum path return dp[-1][-1] def parse_input(input_string): Parses the input string to extract the grid. lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return grid"},{"question":"def can_reach_bottom_right(grid: List[List[int]]) -> bool: Determine if it's possible to reach the bottom-right corner of the grid from the top-left corner. Each cell in the grid represents the height of a building, and a person can move right or down only if the next block height is the same or one level higher. >>> can_reach_bottom_right([ ... [1, 2, 4], ... [2, 3, 5], ... [6, 5, 4] ... ]) False >>> can_reach_bottom_right([ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]) True >>> can_reach_bottom_right([ ... [3, 1], ... [2, 2] ... ]) False pass # complete the function with the logic to determine if the bottom-right corner can be reached def process_test_cases(T: int, test_cases: List[List[List[int]]]) -> List[str]: Process multiple test cases to determine if the bottom-right corner can be reached in each case. >>> T = 3 >>> test_cases = [ ... [ ... [1, 2, 4], ... [2, 3, 5], ... [6, 5, 4] ... ], ... [ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ], ... [ ... [3, 1], ... [2, 2] ... ] ... ] >>> process_test_cases(T, test_cases) ['NO', 'YES', 'NO'] pass # complete the function to process multiple test cases import pytest def test_single_case(): grid = [ [1, 2, 4], [2, 3, 5], [6, 5, 4] ] assert not can_reach_bottom_right(grid) def test_single_case2(): grid = [ [1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1] ] assert can_reach_bottom_right(grid) def test_single_case3(): grid = [ [3, 1], [2, 2] ] assert not can_reach_bottom_right(grid) def test_multiple_cases(): T = 3 test_cases = [ [ [1, 2, 4], [2, 3, 5], [6, 5, 4] ], [ [1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1] ], [ [3, 1], [2, 2] ] ] results = process_test_cases(T, test_cases) assert results == [\\"NO\\", \\"YES\\", \\"NO\\"] def test_simple_2x2_grid(): grid = [ [0, 1], [1, 1] ] assert can_reach_bottom_right(grid) def test_unreachable_grid(): grid = [ [1, 2], [3, 4] ] assert not can_reach_bottom_right(grid) def test_large_grid(): grid = [ [i for i in range(100)] for j in range(100) ] assert can_reach_bottom_right(grid)","solution":"def can_reach_bottom_right(grid): N = len(grid) directions = [(0, 1), (1, 0)] # right and down # Using BFS to find if the path exists from collections import deque queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, N-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited: if grid[nx][ny] >= grid[x][y] and grid[nx][ny] <= grid[x][y] + 1: visited.add((nx, ny)) queue.append((nx, ny)) return False def process_test_cases(T, test_cases): results = [] for i in range(T): grid = test_cases[i] result = can_reach_bottom_right(grid) if result: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_operations(n, operations): Processes a series of operations on a list. The operations can be one of the following forms: 1. \\"insert x y\\": Insert the integer y at position x in the list. 2. \\"get x\\": Get the integer at position x in the list. 3. \\"delete x\\": Remove the integer at position x from the list. The list is initially empty. Args: n (int): The number of operations. operations (List[str]): List of operations to be performed on the list. Returns: List[int]: A list containing the results of all \\"get x\\" operations. >>> process_operations(7, [\\"insert 0 5\\", \\"insert 1 10\\", \\"insert 2 15\\", \\"get 1\\", \\"delete 1\\", \\"get 1\\", \\"insert 1 20\\"]) [10, 15] from typing import List def test_process_operations_example(): operations = [ \\"insert 0 5\\", \\"insert 1 10\\", \\"insert 2 15\\", \\"get 1\\", \\"delete 1\\", \\"get 1\\", \\"insert 1 20\\" ] assert process_operations(7, operations) == [10, 15] def test_process_operations_single_insert_get(): operations = [ \\"insert 0 100\\", \\"get 0\\" ] assert process_operations(2, operations) == [100] def test_process_operations_insert_delete_get(): operations = [ \\"insert 0 100\\", \\"delete 0\\", \\"insert 0 200\\", \\"get 0\\" ] assert process_operations(4, operations) == [200] def test_process_operations_multiple_inserts_and_gets(): operations = [ \\"insert 0 1\\", \\"insert 1 2\\", \\"insert 2 3\\", \\"get 0\\", \\"get 1\\", \\"get 2\\" ] assert process_operations(6, operations) == [1, 2, 3] def test_process_operations_complex_case(): operations = [ \\"insert 0 5\\", \\"insert 1 3\\", \\"insert 2 7\\", \\"get 2\\", \\"delete 1\\", \\"get 1\\", \\"insert 1 4\\", \\"get 1\\", ] assert process_operations(8, operations) == [7, 7, 4]","solution":"def process_operations(n, operations): result = [] my_list = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"insert\\": x = int(parts[1]) y = int(parts[2]) my_list.insert(x, y) elif command == \\"get\\": x = int(parts[1]) result.append(my_list[x]) elif command == \\"delete\\": x = int(parts[1]) del my_list[x] return result"},{"question":"def min_swaps_to_transform(S, T): Returns the minimum number of swaps required to transform sequence S into sequence T. >>> min_swaps_to_transform([1, 3, 2, 4], [4, 2, 1, 3]) 2 >>> min_swaps_to_transform([9, 8, 7, 6, 5], [5, 6, 7, 8, 9]) 2 >>> min_swaps_to_transform([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 0 >>> min_swaps_to_transform([5, 4, 3, 2, 1], [1, 2, 3, 4, 5]) 2 >>> min_swaps_to_transform([1], [1]) 0 >>> min_swaps_to_transform(list(range(1, 100001)), list(range(100000, 0, -1))) 50000","solution":"def min_swaps_to_transform(S, T): Returns the minimum number of swaps required to transform sequence S into sequence T. n = len(S) swaps = 0 # Create a mapping from value to its index in T value_to_index_in_T = {value: i for i, value in enumerate(T)} # Transform S to make it identical to T for i in range(n): correct_value = T[i] if S[i] != correct_value: # Find the index in S which should contain correct_value index_to_swap = value_to_index_in_T[S[i]] # Swap the values S[i], S[index_to_swap] = S[index_to_swap], S[i] # Update the position in the map value_to_index_in_T[S[index_to_swap]] = index_to_swap swaps += 1 return swaps"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of squares of the first n positive integers. >>> sum_of_squares(1) 1 >>> sum_of_squares(2) 5 >>> sum_of_squares(3) 14 >>> sum_of_squares(10) 385 >>> sum_of_squares(100) 338350","solution":"def sum_of_squares(n): Returns the sum of squares of the first n positive integers. return sum(i * i for i in range(1, n + 1))"},{"question":"def min_adjacent_swaps_to_sort_array(arr: List[int]) -> int: Given an array of integers, find the minimum number of adjacent swaps required to sort the array in non-decreasing order. >>> min_adjacent_swaps_to_sort_array([3, 2, 1]) 3 >>> min_adjacent_swaps_to_sort_array([1, 3, 2]) 1 >>> min_adjacent_swaps_to_sort_array([4, 3, 2, 1]) 6 >>> min_adjacent_swaps_to_sort_array([1, 5, 3, 4, 2]) 5 >>> min_adjacent_swaps_to_sort_array([1, 2, 3, 4, 5]) 0","solution":"def min_adjacent_swaps_to_sort_array(arr): Returns the minimum number of adjacent swaps required to sort the array in non-decreasing order. def merge_count_split_inv(arr, temp_arr, left, mid, right): inv_count = 0 i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"from typing import List, Tuple, Dict def monitor_security(N: int, queries: List[Tuple[int, int, int]], updates: Dict[str, List[Tuple[int, int]]]) -> List[str]: Monitor and ensure the security of various city zones in Gotham. Args: - N (int): the number of zones - queries (List[Tuple[int, int, int]]): the list of queries to perform on the zones - updates (Dict[str, List[Tuple[int, int]]]): dictionary containing the edges indicating connections between zones Returns: - List[str]: results of the monitoring queries, \\"YES\\" or \\"NO\\" Example: >>> updates = {\\"edges\\": [(1, 2), (2, 3), (3, 4), (4, 5)]} >>> queries = [(0, 1, 5), (1, 3, 10), (0, 3, 2), (0, 5, 1)] >>> monitor_security(5, queries, updates) [\\"YES\\", \\"YES\\", \\"NO\\"] import pytest def test_monitor_security(): # Test case 1 N = 5 updates = { \\"edges\\": [(1, 2), (2, 3), (3, 4), (4, 5)] } queries = [ (0, 1, 5), (1, 3, 10), (0, 3, 2), (0, 5, 1) ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert monitor_security(N, queries, updates) == expected_output # Test case 2 N = 3 updates = { \\"edges\\": [(1, 2), (2, 3)] } queries = [ (0, 1, 3), (1, 2, 8), (0, 3, 1), (0, 2, 1) ] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert monitor_security(N, queries, updates) == expected_output # Test case 3 N = 4 updates = { \\"edges\\": [(1, 2), (3, 4)] } queries = [ (0, 1, 3), (1, 3, 5), (0, 4, 2), (0, 4, 3) ] expected_output = [\\"NO\\", \\"NO\\", \\"YES\\"] assert monitor_security(N, queries, updates) == expected_output if __name__ == '__main__': pytest.main()","solution":"from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def monitor_security(N, queries, updates): parent = {i: i for i in range(1, N + 1)} rank = {i: 0 for i in range(1, N + 1)} adj_list = defaultdict(list) for u, v in updates[\\"edges\\"]: adj_list[u].append(v) adj_list[v].append(u) union(parent, rank, u, v) results = [] for query in queries: q_type, u, v = query if q_type == 0: res = \\"YES\\" if find(parent, u) == find(parent, v) else \\"NO\\" results.append(res) elif q_type == 1: # Perform security level update # This has no effect on the connectivity in our current DSU representation pass return results"},{"question":"def is_palindromic_number(n: int) -> bool: Determines if a given number is a palindrome. >>> is_palindromic_number(121) True >>> is_palindromic_number(12321) True >>> is_palindromic_number(123) False # Complete the function body def check_palindromic_numbers(t: int, numbers: List[int]) -> List[str]: Checks if each number in the list \`numbers\` is palindromic and returns results as a list. >>> check_palindromic_numbers(3, [121, 12321, 123]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromic_numbers(2, [202, 34543]) [\\"YES\\", \\"YES\\"] # Complete the function body from typing import List def test_is_palindromic_number(): assert is_palindromic_number(121) assert is_palindromic_number(12321) assert not is_palindromic_number(123) assert is_palindromic_number(1) assert is_palindromic_number(0) assert not is_palindromic_number(10) def test_check_palindromic_numbers(): assert check_palindromic_numbers(3, [121, 12321, 123]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert check_palindromic_numbers(2, [202, 34543]) == [\\"YES\\", \\"YES\\"] assert check_palindromic_numbers(4, [123, 456, 789, 987]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"] assert check_palindromic_numbers(2, [99999, 1001]) == [\\"YES\\", \\"YES\\"] assert check_palindromic_numbers(1, [1234321]) == [\\"YES\\"]","solution":"def is_palindromic_number(n): Determines if a given number is a palindrome. str_n = str(n) return str_n == str_n[::-1] def check_palindromic_numbers(t, numbers): Checks if each number in the list \`numbers\` is palindromic and returns results as a list. results = [] for number in numbers: if is_palindromic_number(number): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from collections import deque from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required for the adventurer to reach the bottom-right cell or -1 if it's not possible. >>> min_moves_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_end(3, 3, [\\"..#\\", \\"#.#\\", \\"..#\\"]) -1 >>> min_moves_to_reach_end(1, 1, [\\".\\"]) 0 >>> min_moves_to_reach_end(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> min_moves_to_reach_end(5, 5, [\\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\"]) 8","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): Returns the minimum number of moves required for the adventurer to reach the bottom-right corner or -1 if it is not possible. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col] and grid[new_row][new_col] == '.': visited[new_row][new_col] = True queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def find_pattern_positions(n, dna_sequence, pattern): Returns the starting positions where the pattern is found in the DNA sequence. :param n: length of the DNA sequence (int) :param dna_sequence: the DNA sequence (str) :param pattern: the pattern to search for (str) :return: list of starting positions or [-1] if pattern is not found >>> find_pattern_positions(10, \\"ACGTACGTAG\\", \\"ACG\\") [0, 4] >>> find_pattern_positions(5, \\"AAAAA\\", \\"AA\\") [0, 1, 2, 3] >>> find_pattern_positions(8, \\"CGTAGCTA\\", \\"GTG\\") [-1]","solution":"def find_pattern_positions(n, dna_sequence, pattern): Returns the starting positions where the pattern is found in the DNA sequence. :param n: length of the DNA sequence (int) :param dna_sequence: the DNA sequence (str) :param pattern: the pattern to search for (str) :return: list of starting positions or [-1] if pattern is not found pattern_length = len(pattern) positions = [] for i in range(n - pattern_length + 1): if dna_sequence[i:i + pattern_length] == pattern: positions.append(i) if not positions: return [-1] return positions"},{"question":"def is_circular_list(lst): Returns True if the list is a circular sequence, otherwise False. Example: >>> is_circular_list([1, 2, 3, 1]) True >>> is_circular_list(['a', 'b', 'c', 'a']) True >>> is_circular_list([1, 2, 3, 4]) False if len(lst) < 2: return False return lst[0] == lst[-1] def process_input(input_str): Processes the input string and determines if each list is circular. Returns a list of True/False results. Example: >>> process_input(\\"3n1,2,3,1na,b,c,an1,2,3,4\\") [True, True, False] lines = input_str.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): lst = lines[i].split(',') results.append(is_circular_list(lst)) return results","solution":"def is_circular_list(lst): Returns True if the list is a circular sequence, otherwise False. if len(lst) < 2: return False return lst[0] == lst[-1] def process_input(input_str): Processes the input string and determines if each list is circular. Returns a list of True/False results. lines = input_str.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): lst = lines[i].split(',') results.append(is_circular_list(lst)) return results"},{"question":"from typing import List def knight_arrangements(strengths: List[int]) -> List[List[int]]: Given a list of knight strengths, return all valid arrangements where each knight is stronger than the knight directly next to them. >>> knight_arrangements([3, 1, 2]) [[1, 2, 3], [3, 2, 1]] >>> knight_arrangements([4, 3, 2, 1]) [[1, 2, 3, 4], [4, 3, 2, 1]] >>> knight_arrangements([1]) [[1]] >>> knight_arrangements([2, 1]) [[1, 2], [2, 1]] >>> knight_arrangements([5, 3, 1]) [] >>> knight_arrangements([1, 2, 3, 4, 5]) [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]","solution":"from itertools import permutations def is_valid_arrangement(perm): Check if a given permutation is a valid arrangement where each knight is stronger than the knight directly next to them. for i in range(len(perm) - 1): if abs(perm[i] - perm[i + 1]) != 1: return False return True def knight_arrangements(strengths): Given a list of knight strengths, return all valid arrangements where each knight is stronger than the knight directly next to them. all_permutations = permutations(sorted(strengths)) valid_permutations = [list(perm) for perm in all_permutations if is_valid_arrangement(perm)] return sorted(valid_permutations) # Example usage: strengths = [3, 1, 2] valid_arrangements = knight_arrangements(strengths) for arrangement in valid_arrangements: print(arrangement)"},{"question":"def is_match(s: str, p: str) -> bool: Determine if the string matches the pattern that includes wildcards '*' and '?'. '*' can match any sequence of characters (including an empty sequence). '?' can match any single character. Args: s (str): input string consisting of lowercase letters. p (str): pattern string consisting of lowercase letters, '*' and '?'. Returns: bool: True if the string matches the pattern, otherwise False. Examples: >>> is_match(\\"aa\\", \\"a\\") False >>> is_match(\\"aa\\", \\"*\\") True >>> is_match(\\"cb\\", \\"?a\\") False >>> is_match(\\"adceb\\", \\"*a*b\\") True >>> is_match(\\"acdcb\\", \\"a*c?b\\") False","solution":"def is_match(s: str, p: str) -> bool: # Create a 2D dynamic programming table dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Empty pattern matches empty string # Handle the situation where pattern starts with '*' for j in range(1, len(p) + 1): if p[j-1] == '*': dp[0][j] = dp[0][j-1] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == '*': # '*' can match empty sequence or any sequence dp[i][j] = dp[i][j-1] or dp[i-1][j] elif p[j-1] == '?' or s[i-1] == p[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = False return dp[len(s)][len(p)]"},{"question":"def max_fun_value(t, test_cases): Kevin has a collection of toys, each toy has a certain level of fun associated with it. Kevin wants to maximize the total fun value, but there is a catch: Kevin can only pick a subset of toys such that no two toys in the subset have consecutively increasing IDs. Help Kevin determine the maximum fun value he can obtain. Args: t: int - the number of test cases test_cases: List[Tuple[int, List[int]]] - a list of tuples where each tuple contains an integer n (number of toys) and a list of integers representing fun values. Returns: List[int] - a list containing maximum total fun value for each test case. Example: >>> max_fun_value(3, [(5, [3, 2, 7, 10, 12]), (4, [100, 1, 100, 1]), (3, [5, 5, 10])]) [22, 200, 15] >>> max_fun_value(1, [(1, [50])]) [50]","solution":"def max_fun_value(t, test_cases): results = [] for test in test_cases: n, fun_values = test if n == 0: results.append(0) continue if n == 1: results.append(fun_values[0]) continue dp = [0] * n dp[0] = fun_values[0] dp[1] = max(fun_values[0], fun_values[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + fun_values[i]) results.append(dp[-1]) return results"},{"question":"def max_garden_area(P: int) -> int: Compute the maximum possible area of a rectangular garden that can be enclosed using the given amount of fencing material P. The garden should have sides of integer lengths. >>> max_garden_area(12) 9 >>> max_garden_area(5) 1 >>> max_garden_area(2) 0 >>> max_garden_area(3) 0 >>> max_garden_area(6) 2 >>> max_garden_area(10) 6 >>> max_garden_area(100000) 625000000 >>> max_garden_area(1000000) 62500000000 pass","solution":"def max_garden_area(P): This function computes the maximum possible area of a garden that can be enclosed using the given amount of fencing material P. if P < 3: return 0 max_area = 0 for length in range(1, P // 2): width = (P // 2) - length if length * 2 + width * 2 <= P: area = length * width if area > max_area: max_area = area return max_area"},{"question":"def longestPrefix(strs) -> str: Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. :param strs: list of strings to evaluate :return: longest common prefix from solution import longestPrefix def test_longestPrefix_common_prefix(): assert longestPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" assert longestPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" def test_longestPrefix_no_common_prefix(): assert longestPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" assert longestPrefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" def test_longestPrefix_single_string(): assert longestPrefix([\\"single\\"]) == \\"single\\" def test_longestPrefix_identical_strings(): assert longestPrefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" def test_longestPrefix_mixed_lengths(): assert longestPrefix([\\"abcdef\\", \\"abc\\", \\"abcd\\", \\"ab\\"]) == \\"ab\\" def test_longestPrefix_empty_list(): assert longestPrefix([]) == \\"\\" def test_longestPrefix_prefix_equal_to_whole_first_string(): assert longestPrefix([\\"abc\\", \\"abcdef\\", \\"abcd\\"]) == \\"abc\\" def test_longestPrefix_all_strings_empty(): assert longestPrefix([\\"\\", \\"\\", \\"\\"]) == \\"\\" def test_longestPrefix_one_string_empty(): assert longestPrefix([\\"flower\\", \\"flow\\", \\"\\"]) == \\"\\"","solution":"def longestPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. :param strs: List[str] - list of strings to evaluate :return: str - longest common prefix if not strs: return \\"\\" # Start with the prefix being the first string prefix = strs[0] for string in strs[1:]: while not string.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"def count_unique_elements(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list containing the number of unique elements in specified subarray queries. :param n: int: size of the array :param q: int: number of queries :param array: list of int: the input array :param queries: list of tuples (l, r): each tuple defines a query specifying the indices (1-based) of the subarray :return: list of int: number of unique elements for each query >>> count_unique_elements(5, 3, [1, 2, 3, 2, 1], [(1, 3), (2, 5), (1, 5)]) [3, 3, 3] >>> count_unique_elements(5, 2, [1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [5, 3] >>> count_unique_elements(5, 2, [2, 2, 2, 2, 2], [(1, 3), (1, 5)]) [1, 1] >>> count_unique_elements(1, 1, [42], [(1, 1)]) [1] >>> count_unique_elements(100, 1, list(range(1, 101)), [(1, 100)]) [100]","solution":"def count_unique_elements(n, q, array, queries): Returns a list containing the number of unique elements in specified subarray queries. :param n: int: size of the array :param q: int: number of queries :param array: list of int: the input array :param queries: list of tuples (l, r): each tuple defines a query specifying the indices (1-based) of the subarray :return: list of int: number of unique elements for each query results = [] for l, r in queries: subarray = array[l-1:r] # Convert 1-based to 0-based unique_elements = len(set(subarray)) results.append(unique_elements) return results"},{"question":"from typing import List def count_even_sum_pairs(N: int, A: List[int]) -> int: Returns the number of pairs (i, j) such that i < j and A[i] + A[j] is even. >>> count_even_sum_pairs(4, [1, 2, 3, 4]) 2 >>> count_even_sum_pairs(3, [2, 4, 6]) 3 >>> count_even_sum_pairs(3, [1, 3, 5]) 3 >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(1, [1]) 0 >>> count_even_sum_pairs(6, [1, 2, 3, 4, 5, 6]) 6","solution":"def count_even_sum_pairs(N, A): Returns the number of pairs (i, j) such that i < j and A[i] + A[j] is even. even_count = 0 odd_count = 0 # Counting even and odd elements for num in A: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Number of pairs of even elements even_pairs = even_count * (even_count - 1) // 2 # Number of pairs of odd elements odd_pairs = odd_count * (odd_count - 1) // 2 # Total pairs where the sum is even return even_pairs + odd_pairs"},{"question":"import numpy as np def identity_array(n: int, m: int): Returns an identity array of dimensions n x m using numpy.eye. Parameters: n (int): the number of rows of the array m (int): the number of columns of the array Returns: numpy.ndarray: a 2-D identity array Examples: >>> identity_array(3, 3) [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]] >>> identity_array(3, 2) [[1.0, 0.0], [0.0, 1.0], [0.0, 0.0]] >>> identity_array(1, 3) [[1.0, 0.0, 0.0]] >>> identity_array(3, 1) [[1.0], [0.0], [0.0]] >>> identity_array(1, 1) [[1.0]]","solution":"import numpy as np def identity_array(n, m): Returns an identity array of dimensions n x m using numpy.eye. Parameters: n (int): the number of rows of the array m (int): the number of columns of the array Returns: numpy.ndarray: a 2-D identity array return np.eye(n, m).tolist()"},{"question":"def summarize_pastry_inventory(inventory): Summarizes the total quantities of each type of pastry from the inventory list. Parameters: inventory (list of str): A list of strings where each string contains a pastry name and a quantity, separated by a space. Returns: list of str: A list of strings where each string contains the pastry name and the total quantity, sorted alphabetically by the pastry name. >>> summarize_pastry_inventory([\\"Croissant 10\\", \\"Donut 5\\", \\"Eclair 0\\", \\"Muffin 7\\", \\"Croissant 3\\", \\"Donut 8\\", \\"Muffin 0\\"]) [\\"Croissant 13\\", \\"Donut 13\\", \\"Muffin 7\\"] >>> summarize_pastry_inventory([\\"Croissant 0\\", \\"Donut 0\\", \\"Eclair 0\\"]) [] >>> summarize_pastry_inventory([\\"Croissant 10\\", \\"Donut 5\\"]) [\\"Croissant 10\\", \\"Donut 5\\"] >>> summarize_pastry_inventory([]) [] >>> summarize_pastry_inventory([\\"Croissant 0\\", \\"Donut 5\\", \\"Croissant 3\\"]) [\\"Croissant 3\\", \\"Donut 5\\"] >>> summarize_pastry_inventory([\\"Croissant 1000\\", \\"Donut 500\\", \\"Croissant 2000\\", \\"Donut 3000\\"]) [\\"Croissant 3000\\", \\"Donut 3500\\"]","solution":"def summarize_pastry_inventory(inventory): Summarizes the total quantities of each type of pastry from the inventory list. Parameters: inventory (list of str): A list of strings where each string contains a pastry name and a quantity, separated by a space. Returns: list of str: A list of strings where each string contains the pastry name and the total quantity, sorted alphabetically by the pastry name. pastry_counts = {} for item in inventory: pastry, quantity = item.split() quantity = int(quantity) if pastry in pastry_counts: pastry_counts[pastry] += quantity else: pastry_counts[pastry] = quantity # Filter out pastries with a total quantity of zero result = [f\\"{pastry} {quantity}\\" for pastry, quantity in pastry_counts.items() if quantity > 0] # Sort result alphabetically by pastry name result.sort() return result"},{"question":"def additional_self_study_hours(T, test_cases): Computes the additional self-study hours required to balance the schedule for each test case. Parameters: T (int): The number of test cases test_cases (list of tuples): Each tuple contains two lists of integers. The first list represents lecture hours (L) for 7 days, and the second list represents self-study hours (S) for 7 days. Returns: list: A list of integers where each integer represents the additional self-study hours needed. from typing import List, Tuple def test_example_cases(): T = 2 test_cases = [ ([3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7]), ([10, 10, 10, 10, 10, 10, 10], [5, 5, 5, 5, 5, 5, 5]) ] assert additional_self_study_hours(T, test_cases) == [14, 35] def test_no_additional_needed(): T = 1 test_cases = [ ([2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2]) ] assert additional_self_study_hours(T, test_cases) == [0] def test_all_zero_hours(): T = 1 test_cases = [ ([0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]) ] assert additional_self_study_hours(T, test_cases) == [0] def test_max_lectures_and_self_studies(): T = 1 test_cases = [ ([24, 24, 24, 24, 24, 24, 24], [24, 24, 24, 24, 24, 24, 24]) ] assert additional_self_study_hours(T, test_cases) == [0] def test_zero_lectures_some_self_studies(): T = 1 test_cases = [ ([0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1]) ] assert additional_self_study_hours(T, test_cases) == [-7]","solution":"def additional_self_study_hours(T, test_cases): Computes the additional self-study hours required to balance the schedule for each test case. Parameters: T (int): The number of test cases test_cases (list of tuples): Each tuple contains two lists of integers. The first list represents lecture hours (L) for 7 days, and the second list represents self-study hours (S) for 7 days. Returns: list: A list of integers where each integer represents the additional self-study hours needed. results = [] for lectures, self_studies in test_cases: total_lectures = sum(lectures) total_self_studies = sum(self_studies) additional_hours_needed = total_lectures - total_self_studies results.append(additional_hours_needed) return results"},{"question":"def min_trees_to_cut(n, heights): Function to find the minimum number of trees to cut such that the heights form a strictly increasing sequence. Args: n (int): Number of trees. heights (list): List of integers representing the heights of trees. Returns: int: Minimum number of trees to cut. Example: >>> min_trees_to_cut(5, [3, 7, 5, 6, 9]) 1 >>> min_trees_to_cut(6, [9, 8, 7, 6, 5, 4]) 5 from solution import min_trees_to_cut def test_example_1(): assert min_trees_to_cut(5, [3, 7, 5, 6, 9]) == 1 def test_example_2(): assert min_trees_to_cut(6, [9, 8, 7, 6, 5, 4]) == 5 def test_all_increasing(): assert min_trees_to_cut(5, [1, 2, 3, 4, 5]) == 0 def test_all_decreasing(): assert min_trees_to_cut(4, [4, 3, 2, 1]) == 3 def test_mixed_values(): assert min_trees_to_cut(5, [4, 3, 5, 2, 6]) == 2 def test_single_tree(): assert min_trees_to_cut(1, [10]) == 0 def test_alternating(): assert min_trees_to_cut(7, [1, 3, 2, 4, 3, 5, 4]) == 3","solution":"def min_trees_to_cut(n, heights): Function to find the minimum number of trees to cut such that the heights form a strictly increasing sequence. Args: n (int): Number of trees. heights (list): List of integers representing the heights of trees. Returns: int: Minimum number of trees to cut. # Dynamic programming array to keep the length of longest increasing subsequence ending at each index dp = [1] * n # Compute lengths of longest increasing subsequence for each index for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence longest_increasing_subseq_length = max(dp) # Minimum number of trees to cut is total number of trees minus the length of longest increasing subsequence return n - longest_increasing_subseq_length"},{"question":"def sort_books_by_popularity(T, test_cases): Sorts books based on their ratings for each test case and returns a list of sorted ratings. Higher ratings appear earlier and the relative order of books with the same rating is preserved. Args: T: int : The number of test cases test_cases: List[Tuple(int, List[int])] : A list of tuples where the first element is the number of books and the second element is the list of ratings for the books. Returns: List[List[int]] : A list of lists where each inner list contains the sorted ratings for each test case Example: >>> sort_books_by_popularity(2, [(5, [5, 2, 9, 9, 5]), (4, [1, 3, 2, 2])]) [[9, 9, 5, 5, 2], [3, 2, 2, 1]] >>> sort_books_by_popularity(1, [(6, [4, 6, 4, 2, 3, 1])]) [[6, 4, 4, 3, 2, 1]]","solution":"def sort_books_by_popularity(T, test_cases): Sorts books based on their ratings for each test case and returns a list of sorted ratings. Higher ratings appear earlier and the relative order of books with the same rating is preserved. results = [] for i in range(T): N = test_cases[i][0] ratings = test_cases[i][1] sorted_ratings = sorted(ratings, key=lambda x: -x) results.append(sorted_ratings) return results"},{"question":"def can_measure_water(a: int, b: int, c: int) -> str: Determines if it is possible to measure exactly c liters using two jugs with capacities a and b. :param int a: Capacity of the first jug :param int b: Capacity of the second jug :param int c: Desired amount of water :return: \\"YES\\" if it is possible to measure exactly c liters, otherwise \\"NO\\" :rtype: str >>> can_measure_water(3,5,4) \\"YES\\" >>> can_measure_water(2,6,5) \\"NO\\" >>> can_measure_water(1,2,3) \\"YES\\"","solution":"def can_measure_water(a, b, c): Determines if it is possible to measure exactly c liters using two jugs with capacities a and b. :param int a: Capacity of the first jug :param int b: Capacity of the second jug :param int c: Desired amount of water :return: \\"YES\\" if it is possible to measure exactly c liters, otherwise \\"NO\\" :rtype: str if c == 0: return \\"YES\\" if c > a + b: return \\"NO\\" def gcd(x, y): while y != 0: x, y = y, x % y return x # Check if c is a multiple of the gcd of a and b if c % gcd(a, b) == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def fibonacci(n: int) -> int: Returns the n-th term in the Fibonacci sequence using a recursive function. >>> fibonacci(7) 13 >>> fibonacci(30) 832040 from solution import fibonacci def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_recursive_cases(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 assert fibonacci(6) == 8 assert fibonacci(7) == 13 assert fibonacci(8) == 21 assert fibonacci(9) == 34 assert fibonacci(10) == 55 def test_fibonacci_edge_cases(): assert fibonacci(30) == 832040","solution":"def fibonacci(n): Returns the n-th term in the Fibonacci sequence using a recursive function. if n <= 1: return n else: return fibonacci(n - 1) + fibonacci(n - 2)"},{"question":"def account_balance(transactions): Returns the final account balance after processing a list of transactions. Each transaction is a string in the format \\"D amount\\" for deposits and \\"W amount\\" for withdrawals. Parameters: transactions (list): List of transaction strings. Returns: int: The final balance of the account. >>> account_balance([\\"D 300\\", \\"D 200\\", \\"D 100\\", \\"D 50\\"]) == 650 >>> account_balance([\\"W 300\\", \\"W 200\\", \\"W 100\\", \\"W 50\\"]) == -650 >>> account_balance([\\"D 300\\", \\"W 200\\", \\"D 100\\", \\"W 50\\"]) == 150 >>> account_balance([]) == 0 >>> account_balance([\\"D 500\\"]) == 500 >>> account_balance([\\"W 500\\"]) == -500 >>> account_balance([\\"D 1000000\\", \\"W 999999\\", \\"D 500000\\"]) == 500001 >>> account_balance([\\"D 0\\", \\"W 0\\"]) == 0","solution":"def account_balance(transactions): Returns the final account balance after processing a list of transactions. Each transaction is a string in the format \\"D amount\\" for deposits and \\"W amount\\" for withdrawals. Parameters: transactions (list): List of transaction strings. Returns: int: The final balance of the account. balance = 0 for transaction in transactions: type_, amount = transaction.split() amount = int(amount) if type_ == \\"D\\": balance += amount elif type_ == \\"W\\": balance -= amount return balance"},{"question":"from typing import List, Tuple def sum_of_squares_of_digits(n: int) -> int: Compute the sum of the squares of the digits of the number n. >>> sum_of_squares_of_digits(19) 82 >>> sum_of_squares_of_digits(82) 68 pass def reaches_one_within_k_steps(a0: int, K: int) -> str: Determine if the sequence starting from a0 reaches 1 within K steps. >>> reaches_one_within_k_steps(19, 10) \\"YES\\" >>> reaches_one_within_k_steps(82, 5) \\"YES\\" >>> reaches_one_within_k_steps(7, 2) \\"NO\\" pass def solution(test_cases: List[Tuple[int, int]]) -> List[str]: For each test case, determine if the sequence reaches 1 within K steps. >>> solution([(19, 10), (82, 5), (7, 2)]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass def main(input_data: str) -> None: Parses the input data and prints the result for each test case. >>> main(\\"3n19 10n82 5n7 2n\\") YES YES NO pass","solution":"def sum_of_squares_of_digits(n): Compute the sum of the squares of the digits of the number n. return sum(int(digit)**2 for digit in str(n)) def reaches_one_within_k_steps(a0, K): Determine if the sequence starting from a0 reaches 1 within K steps. for _ in range(K): if a0 == 1: return \\"YES\\" a0 = sum_of_squares_of_digits(a0) return \\"NO\\" def solution(test_cases): results = [] for a0, K in test_cases: result = reaches_one_within_k_steps(a0, K) results.append(result) return results # ------ Input parsing and function calling for the given problem ------ def main(input_data): data = input_data.strip().split('n') T = int(data[0]) test_cases = [tuple(map(int, line.split())) for line in data[1:T+1]] results = solution(test_cases) for result in results: print(result)"},{"question":"def max_non_overlapping_banners(n, banners): Determine the maximum number of non-overlapping banners that can be set up. :param n: Integer, the number of banners. :param banners: List of tuples, each containing two integers representing the start and end positions of a banner. :return: Integer, the maximum number of non-overlapping banners. >>> max_non_overlapping_banners(5, [(1, 3), (2, 5), (7, 10), (9, 13), (11, 15)]) == 3 >>> max_non_overlapping_banners(4, [(0, 2), (1, 4), (3, 5), (4, 6)]) == 2 >>> max_non_overlapping_banners(1, [(0, 1)]) == 1 >>> max_non_overlapping_banners(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_banners(3, [(0, 10), (1, 11), (2, 12)]) == 1 >>> max_non_overlapping_banners(5, [(1, 4), (2, 6), (8, 10), (9, 12), (13, 15)]) == 3","solution":"def max_non_overlapping_banners(n, banners): Determine the maximum number of non-overlapping banners that can be set up. :param n: Integer, the number of banners. :param banners: List of tuples, each containing two integers representing the start and end positions of a banner. :return: Integer, the maximum number of non-overlapping banners. # Sorting banners based on their end positions (greedy approach) banners.sort(key=lambda x: x[1]) max_banners = 0 current_end = -1 for start, end in banners: if start >= current_end: max_banners += 1 current_end = end return max_banners"},{"question":"def solve(n: int) -> List[int]: In this function, you will be given an integer \`n\`, and your task is to find a pair of prime numbers such that their sum is equal to \`n\`. If multiple such pairs exist, return the pair with the smallest difference, and if there are still multiple pairs with the same difference, return the pair where the smaller prime number is the smallest. If no such pair exists, return an empty array. Examples: >>> solve(10) [5, 5] >>> solve(12) [5, 7] >>> solve(4) [2, 2] >>> solve(20) [7, 13] >>> solve(1) [] >>> solve(0) [] # your code here from typing import List def test_solve(): assert solve(10) == [5, 5], \\"Expected [5, 5] for input 10\\" assert solve(12) == [5, 7], \\"Expected [5, 7] for input 12\\" assert solve(4) == [2, 2], \\"Expected [2, 2] for input 4\\" assert solve(8) == [3, 5], \\"Expected [3, 5] for input 8\\" assert solve(20) == [7, 13], \\"Expected [7, 13] for input 20\\" assert solve(1) == [], \\"Expected [] for input 1\\" assert solve(0) == [], \\"Expected [] for input 0\\" def test_solve_no_pair(): assert solve(1) == [], \\"Expected [] for input 1\\" assert solve(27) == [], \\"Expected [] for input 27\\"","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def solve(n): primes = [i for i in range(2, n) if is_prime(i)] best_pair = [] smallest_difference = float('inf') for prime1 in primes: prime2 = n - prime1 if prime2 in primes: difference = abs(prime1 - prime2) if difference < smallest_difference or (difference == smallest_difference and prime1 < best_pair[0]): best_pair = [prime1, prime2] smallest_difference = difference return best_pair if best_pair else []"},{"question":"def ensure_section_end(text: str) -> str: Ensures the string ends with the phrase '[end of section]'. >>> ensure_section_end(\\"This is a document section. [end of section]\\") == \\"This is a document section. [end of section]\\" >>> ensure_section_end(\\"This is a document section.\\") == \\"This is a document section. [end of section]\\" >>> ensure_section_end(\\"This is a document section. \\") == \\"This is a document section. [end of section]\\" >>> ensure_section_end(\\"\\") == \\" [end of section]\\" >>> ensure_section_end(\\"This is a document section. [end of section] extra\\") == \\"This is a document section. [end of section] extra [end of section]\\" pass","solution":"def ensure_section_end(text: str) -> str: Ensures the string ends with the phrase '[end of section]'. if text.endswith('[end of section]'): return text else: return text.rstrip() + ' [end of section]'"},{"question":"def largest_gcd_subset(arr): Returns the size of the largest subset such that the GCD of the subset is greater than 1. >>> largest_gcd_subset([2, 4, 6, 8, 10]) == 5 >>> largest_gcd_subset([5, 10, 15, 20]) == 4 pass def process_test_cases(T, test_cases): Processes T test cases to determine the size of the largest subset for each case. >>> process_test_cases(1, [(5, [2, 4, 6, 8, 10])]) == [5] >>> process_test_cases(1, [(4, [5, 10, 15, 20])]) == [4] pass","solution":"from math import gcd from functools import reduce from collections import Counter def largest_gcd_subset(arr): Returns the size of the largest subset such that the GCD of the subset is greater than 1. max_value = max(arr) count = Counter(arr) largest_size = 0 # We start from 2 because GCD must be greater than 1 for g in range(2, max_value + 1): current_size = 0 for multiple in range(g, max_value + 1, g): current_size += count[multiple] largest_size = max(largest_size, current_size) return largest_size def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] result = largest_gcd_subset(arr) results.append(result) return results"},{"question":"from typing import List, Tuple def shortest_path(N: int, M: int, passages: List[Tuple[int, int, int]]) -> int: Find the shortest path from room 1 to room N, ensuring the ninjas reach the artifact with minimum travel distance. Args: N (int): The number of rooms. M (int): The number of passages. passages (List[Tuple[int, int, int]]): List of passages represented by tuples (u, v, w) Returns: int: The length of the shortest path from room 1 to room N or -1 if it is impossible. Examples: >>> shortest_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 6 >>> shortest_path(5, 4, [(1, 2, 2), (2, 3, 1), (3, 4, 3), (4, 2, 1)]) -1 def test_shortest_path_simple(): N = 5 M = 6 passages = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1) ] assert shortest_path(N, M, passages) == 6 def test_no_path(): N = 5 M = 4 passages = [ (1, 2, 2), (2, 3, 1), (3, 4, 3), (4, 2, 1) ] assert shortest_path(N, M, passages) == -1 def test_direct_path(): N = 2 M = 1 passages = [ (1, 2, 5) ] assert shortest_path(N, M, passages) == 5 def test_multiple_paths(): N = 4 M = 5 passages = [ (1, 2, 1), (2, 4, 1), (1, 3, 4), (3, 4, 1), (2, 3, 2) ] assert shortest_path(N, M, passages) == 2 def test_large_graph(): N = 10000 M = 1 passages = [(1, 10000, 999)] assert shortest_path(N, M, passages) == 999 def test_disconnected_graph(): N = 3 M = 1 passages = [(1, 2, 1)] assert shortest_path(N, M, passages) == -1","solution":"import heapq import sys def shortest_path(N, M, passages): Finds the shortest path from room 1 to room N given the number of rooms N, number of passages M and the list of passages. graph = {i: [] for i in range(1, N+1)} for u, v, w in passages: graph[u].append((v, w)) # Dijkstra's algorithm distances = {i: float('inf') for i in range(1, N+1)} distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[N] if distances[N] != float('inf') else -1"},{"question":"from typing import List def find_unique_number(sequence: List[int]) -> int: Given a sequence of numbers where each number appears exactly twice except one number which appears exactly once, returns the number that appears exactly once. >>> find_unique_number([4, 1, 2, 1, 2]) 4 >>> find_unique_number([5, 3, 4, 3, 5, 4, 6]) 6 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Given a list of test cases where each test case is a sequence of numbers, returns a list of the numbers that appear exactly once in each test case. >>> process_test_cases([[4, 1, 2, 1, 2], [5, 3, 4, 3, 5, 4, 6]]) [4, 6]","solution":"def find_unique_number(sequence): Given a sequence of numbers where each number appears exactly twice except one number which appears exactly once, returns the number that appears exactly once. unique_number = 0 for num in sequence: unique_number ^= num return unique_number def process_test_cases(test_cases): results = [] for sequence in test_cases: results.append(find_unique_number(sequence)) return results"},{"question":"def process_grid(m, n, k, sequence, grid): Processes the input and computes the required output based on the provided grid, sequence, and integers m, n, and k. :param m: Number of rows of the grid :param n: Number of columns of the grid :param k: An integer parameter :param sequence: A list of integers (sequence of numbers) :param grid: 2D list representing the grid :return: Calculated result # Your implementation here def test_process_grid(): m, n, k = 5, 4, 4 sequence = [2, 2, 5, 5] grid = [ \\"BCDE\\", \\"A.CB\\", \\".B.A\\", \\"DECD\\", \\"EDAB\\" ] assert process_grid(m, n, k, sequence, grid) == 56 # Placeholder expected value needs to be verified def test_additional_case(): m, n, k = 3, 3, 3 sequence = [1, 1, 1] grid = [ \\"ABD\\", \\"CBA\\", \\"DAD\\" ] assert process_grid(m, n, k, sequence, grid) == 9 # Placeholder expected value needs to be verified","solution":"def process_grid(m, n, k, sequence, grid): Processes the input and computes the required output. :param m: Number of rows of the grid :param n: Number of columns of the grid :param k: An integer parameter :param sequence: A list of integers (sequence of numbers) :param grid: 2D list representing the grid :return: Calculated result # Example implementation for demonstration # This part of the implementation should be adjusted based on specific requirements result = sum(sequence) * k # Placeholder computation return result # Example invocation # m, n, k = 5, 4, 4 # sequence = [2, 2, 5, 5] # grid = [ # \\"BCDE\\", # \\"A.CB\\", # \\".B.A\\", # \\"DECD\\", # \\"EDAB\\" # ] # print(process_grid(m, n, k, sequence, grid)) # Caution: adjust implementation for your actual needs"},{"question":"def count_pairs_with_sum(nums: List[int], k: int) -> int: Returns the count of unique pairs in the list nums that sum up to k. >>> count_pairs_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_pairs_with_sum([-1, 0, 1, 2], 0) 1","solution":"def count_pairs_with_sum(nums, k): Returns the count of unique pairs in the list nums that sum up to k. seen = set() pairs = set() for num in nums: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return len(pairs)"},{"question":"def min_sweetness_diff(test_cases): Determines the minimum difference in sweetness levels between any two candies given to two different friends for all test cases. Parameters: test_cases (list of tuple): A list where each tuple contains the number of candies (N) and a list of N integers representing the sweetness levels. Returns: list: A list containing the minimum difference for each test case. # Write your code here # Sample test cases test_cases_1 = [(3, [1, 5, 3]), (5, [1, 9, 3, 8, 5]), (4, [10, 20, 30, 40])] expected_1 = [2, 1, 10] assert min_sweetness_diff(test_cases_1) == expected_1 test_cases_2 = [(2, [10, 20]), (2, [5, 9]), (3, [2, 4, 6])] expected_2 = [10, 4, 2] assert min_sweetness_diff(test_cases_2) == expected_2 test_cases_3 = [(4, [7, 4, 10, 1]), (3, [15, 7, 100]), (5, [10, 10, 10, 10, 10])] expected_3 = [3, 8, 0] assert min_sweetness_diff(test_cases_3) == expected_3","solution":"def min_sweetness_diff(test_cases): Determines the minimum difference in sweetness levels between any two candies given to two different friends for all test cases. Parameters: test_cases (list of tuple): A list where each tuple contains the number of candies (N) and a list of N integers representing the sweetness levels. Returns: list: A list containing the minimum difference for each test case. results = [] for N, sweetness_levels in test_cases: sweetness_levels.sort() min_diff = float('inf') for i in range(1, N): min_diff = min(min_diff, sweetness_levels[i] - sweetness_levels[i - 1]) results.append(min_diff) return results"},{"question":"def calculate_total_price(price_per_item, quantity): Calculates the total price after applying the appropriate discount based on quantity purchased. Args: price_per_item (float): The price of a single item. quantity (int): The quantity of items purchased. Returns: float: The total price after discount, rounded to two decimal places. >>> calculate_total_price(10.00, 10) == 100.00 >>> calculate_total_price(15.50, 19) == 294.50 >>> calculate_total_price(10.00, 20) == 190.00 >>> calculate_total_price(25.00, 25) == 593.75 >>> calculate_total_price(10.00, 50) == 450.00 >>> calculate_total_price(30.00, 60) == 1620.00 >>> calculate_total_price(10.00, 100) == 800.00 >>> calculate_total_price(50.00, 150) == 6000.00 >>> calculate_total_price(10.00, 0) == 0.00 >>> calculate_total_price(100.00, 1) == 100.00 >>> calculate_total_price(10.00, 99) == 891.00 >>> calculate_total_price(10.00, 20) == 190.00","solution":"def calculate_total_price(price_per_item, quantity): Calculates the total price after applying the appropriate discount based on quantity purchased. Args: price_per_item (float): The price of a single item. quantity (int): The quantity of items purchased. Returns: float: The total price after discount, rounded to two decimal places. if quantity >= 100: discount = 0.20 elif quantity >= 50: discount = 0.10 elif quantity >= 20: discount = 0.05 else: discount = 0.00 total_price = price_per_item * quantity * (1 - discount) return round(total_price, 2)"},{"question":"def longestZeroSumSubarray(arr): Finds the longest subarray with a sum equal to 0. If there are multiple subarrays with the same length, return the first occurring one. >>> longestZeroSumSubarray([1, 2, -3, 1, 2, -3, 3]) == [1, 2, -3, 1, 2, -3] >>> longestZeroSumSubarray([1, 2, 3]) == [] >>> longestZeroSumSubarray([-1, 1, -1, 1, -1, 1]) == [-1, 1, -1, 1, -1, 1] >>> longestZeroSumSubarray([0, 0, 0, 0]) == [0, 0, 0, 0]","solution":"def longestZeroSumSubarray(arr): Finds the longest subarray with sum equal to 0. Args: arr (list of int): The input array. Returns: list of int: The longest subarray with sum equal to 0. sum_indices = {} curr_sum = 0 max_len = 0 start_index = 0 for i in range(len(arr)): curr_sum += arr[i] if curr_sum == 0: # Update the largest length subarray with the sum 0 starting from the beginning if i + 1 > max_len: max_len = i + 1 start_index = 0 if curr_sum in sum_indices: # If current sum has been seen before if i - sum_indices[curr_sum] > max_len: max_len = i - sum_indices[curr_sum] start_index = sum_indices[curr_sum] + 1 else: # Store the index against the sum sum_indices[curr_sum] = i return arr[start_index:start_index + max_len]"},{"question":"def count_valid_playlists(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determines the number of different ways to pick non-empty playlists of songs from the library such that the total duration matches a specific value, while ensuring each selected song is at least a certain minimum length. >>> count_valid_playlists(2, [{'n': 4, 'S': 10, 'songs': [3, 4, 2, 6], 'L': 3}, {'n': 3, 'S': 8, 'songs': [5, 5, 5], 'L': 3}]) [1, 0] >>> count_valid_playlists(1, [{'n': 4, 'S': 15, 'songs': [1, 2, 3, 4], 'L': 5}]) [0]","solution":"def count_valid_playlists(t, test_cases): def subset_sum_count(songs, total, min_len): n = len(songs) dp = [[0] * (total + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(total + 1): dp[i][j] = dp[i - 1][j] if j >= songs[i - 1] and songs[i - 1] >= min_len: dp[i][j] += dp[i - 1][j - songs[i - 1]] return dp[n][total] results = [] for case in test_cases: n, S, songs, L = case['n'], case['S'], case['songs'], case['L'] valid_songs = [song for song in songs if song >= L] if not valid_songs: results.append(0) else: results.append(subset_sum_count(valid_songs, S, L)) return results"},{"question":"def assign_patterns(N, P, patterns): Assigns unique patterns to each of the N cookies from the provided pattern list, or returns 'Impossible' if not enough patterns for unique assignment. Parameters: N (int): The number of cookies (friends). P (int): The number of available patterns. patterns (list of str): A list of binary patterns. Returns: list of str: The list of patterns assigned to each cookie or [\\"Impossible\\"] if assignment is not possible. pass from solution import assign_patterns def test_assign_patterns_basic(): assert assign_patterns(3, 4, [\\"0110\\", \\"1001\\", \\"0011\\", \\"1100\\"]) == [\\"0110\\", \\"1001\\", \\"0011\\"] def test_assign_patterns_not_enough_patterns(): assert assign_patterns(4, 4, [\\"0110\\", \\"1001\\", \\"0011\\", \\"1100\\"]) == [\\"Impossible\\"] assert assign_patterns(4, 3, [\\"0110\\", \\"1001\\", \\"0011\\"]) == [\\"Impossible\\"] def test_assign_patterns_minimum_input(): assert assign_patterns(1, 1, [\\"0\\"]) == [\\"0\\"] assert assign_patterns(1, 5, [\\"0101\\", \\"1010\\", \\"1100\\", \\"0001\\", \\"1111\\"]) == [\\"0101\\"] def test_assign_patterns_exactly_enough_patterns(): assert assign_patterns(3, 3, [\\"1111\\", \\"0000\\", \\"1010\\"]) == [\\"1111\\", \\"0000\\", \\"1010\\"] def test_assign_patterns_repeat_cases(): patterns = [\\"0000\\", \\"0001\\", \\"0010\\", \\"0011\\", \\"0100\\", \\"0101\\", \\"0110\\", \\"0111\\", \\"1000\\", \\"1001\\", \\"1010\\", \\"1011\\", \\"1100\\", \\"1101\\", \\"1110\\", \\"1111\\"] assert assign_patterns(5, 16, patterns) == [\\"0000\\", \\"0001\\", \\"0010\\", \\"0011\\", \\"0100\\"] assert assign_patterns(16, 16, patterns) == patterns assert assign_patterns(17, 16, patterns) == [\\"Impossible\\"]","solution":"def assign_patterns(N, P, patterns): Assigns unique patterns to each of the N cookies from the provided pattern list, or returns 'Impossible' if not enough patterns for unique assignment. Parameters: N (int): The number of cookies (friends). P (int): The number of available patterns. patterns (list of str): A list of binary patterns. Returns: list of str: The list of patterns assigned to each cookie or [\\"Impossible\\"] if assignment is not possible. if N > P: return [\\"Impossible\\"] return patterns[:N]"},{"question":"class VendingMachine: def __init__(self): Initialize the vending machine with stock and prices for the items. self.stock = { \\"Soda\\": 5, \\"Chips\\": 5, \\"Water\\": 5, \\"Candy\\": 5 } self.prices = { \\"Soda\\": 45, \\"Chips\\": 35, \\"Water\\": 20, \\"Candy\\": 15 } def buy_item(self, item, money_inserted): Simulate buying an item from the vending machine. Args: item (str): Item to buy from the machine (\\"Soda\\", \\"Chips\\", \\"Water\\", or \\"Candy\\") money_inserted (int): The amount of money inserted into the machine Returns: int/str: The change to be given back if purchase is successful, \\"Out of stock\\" if the item is out of stock, or \\"Not enough money\\" if the inserted money is less than the price. pass # Instance of the VendingMachine vending_machine = VendingMachine() def simulate_vending_machine(input_item, input_money): Simulate the vending machine behavior. Args: input_item (str): The item to buy. input_money (int): The amount of money inserted. Returns: int/str: the change or appropriate message based on the transaction. >>> simulate_vending_machine(\\"Soda\\", 50) 5 >>> simulate_vending_machine(\\"Water\\", 20) 0 >>> simulate_vending_machine(\\"Chips\\", 30) Out of stock >>> simulate_vending_machine(\\"Candy\\", 10) Not enough money pass","solution":"class VendingMachine: def __init__(self): self.stock = { \\"Soda\\": 5, \\"Chips\\": 5, \\"Water\\": 5, \\"Candy\\": 5 } self.prices = { \\"Soda\\": 45, \\"Chips\\": 35, \\"Water\\": 20, \\"Candy\\": 15 } def buy_item(self, item, money_inserted): if self.stock[item] == 0: return \\"Out of stock\\" if money_inserted < self.prices[item]: return \\"Not enough money\\" self.stock[item] -= 1 return money_inserted - self.prices[item] # Instance of the VendingMachine vending_machine = VendingMachine() def simulate_vending_machine(input_item, input_money): result = vending_machine.buy_item(input_item, input_money) return result"},{"question":"def longest_palindromic_subsequence(arr: List[int]) -> int: Given a list of integers, find the length of the longest subsequence that is a palindrome. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest palindromic subsequence. Examples: >>> longest_palindromic_subsequence([1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence([1]) 1 >>> longest_palindromic_subsequence([1, 2, 3, 4]) 1 >>> longest_palindromic_subsequence([5, 5, 5, 5, 5]) 5 from solution import longest_palindromic_subsequence def test_example_case(): assert longest_palindromic_subsequence([1, 2, 3, 2, 1, 4]) == 5 def test_single_element(): assert longest_palindromic_subsequence([1]) == 1 def test_two_elements_palindrome(): assert longest_palindromic_subsequence([1, 1]) == 2 def test_two_elements_non_palindrome(): assert longest_palindromic_subsequence([1, 2]) == 1 def test_all_elements_same(): assert longest_palindromic_subsequence([5, 5, 5, 5, 5]) == 5 def test_no_palindrome(): assert longest_palindromic_subsequence([1, 2, 3, 4]) == 1 def test_large_input(): # Testing with a list from 1 to 1000 assert longest_palindromic_subsequence(list(range(1, 1001))) == 1","solution":"def longest_palindromic_subsequence(arr): n = len(arr) # Create a dp array initialized to 0 dp = [[0] * n for _ in range(n)] # Every single element is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Check all subsequences of length greater than 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if arr[i] == arr[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) # The longest palindromic subsequence length will be in dp[0][n-1] return dp[0][n-1]"},{"question":"def maxProjects(workers, projects): Determine the maximum number of projects that can be completed using the available workers, adhering to the skill level order and constraints. Args: workers (List[int]): List of integers representing the skill level of each worker. projects (List[int]): List of integers representing the skill level required for each project. Returns: int: The maximum number of projects that can be completed. >>> maxProjects([3, 1, 4, 1, 5], [2, 1, 3, 4]) 4 >>> maxProjects([2, 3], [1, 2, 3, 4]) 2 >>> maxProjects([1, 2, 3, 4, 5], [3, 2]) 2 >>> maxProjects([1, 1, 1], [2, 2, 2]) 0 >>> maxProjects([1, 2, 3, 4], [1, 2, 3, 4]) 4","solution":"def maxProjects(workers, projects): workers.sort() projects.sort() worker_index = 0 project_index = 0 completed_projects = 0 while worker_index < len(workers) and project_index < len(projects): if workers[worker_index] >= projects[project_index]: completed_projects += 1 project_index += 1 worker_index += 1 return completed_projects"},{"question":"def longestSubarray(arr: List[int], n: int, k: int) -> List[int]: Given an array \`arr\` and an integer \`k\`, returns the longest subarray where the sum is divisible by \`k\`. If multiple subarrays have the same length, returns the one with the smallest starting index. >>> longestSubarray([2, 7, 6, 1, 4, 5], 6, 3) [7, 6, 1, 4] >>> longestSubarray([10, 2, -2, -20, 10], 5, 5) [10, 2, -2, -20, 10] >>> longestSubarray([1, 2, 3], 3, 6) [1, 2, 3] >>> longestSubarray([1, 3, 5], 3, 7) [] >>> longestSubarray([2, -2, 2, -2, 2], 5, 2) [2, -2, 2, -2, 2]","solution":"def longestSubarray(arr, n, k): Given an array \`arr\` and an integer \`k\`, returns the longest subarray where the sum is divisible by \`k\`. If multiple subarrays have the same length, returns the one with the smallest starting index. # Dictionary to store {mod: index} mod_dict = {0: -1} max_len = 0 start_idx = -1 current_sum = 0 for i in range(n): current_sum += arr[i] mod = current_sum % k if mod < 0: mod += k if mod in mod_dict: if i - mod_dict[mod] > max_len: max_len = i - mod_dict[mod] start_idx = mod_dict[mod] + 1 else: mod_dict[mod] = i if start_idx == -1: return [] return arr[start_idx:start_idx + max_len]"},{"question":"import math from typing import List def smallest_perfect_square_greater_than_t_cases(t: int, cases: List[int]) -> List[int]: Find the smallest perfect square greater than each of the given numbers. Parameters: t (int): the number of test cases. cases (List[int]): the list of integers for each test case. Returns: List[int]: a list containing the smallest perfect square greater than each of the given numbers. >>> smallest_perfect_square_greater_than_t_cases(3, [5, 10, 20]) [9, 16, 25] >>> smallest_perfect_square_greater_than_t_cases(1, [0]) [1] >>> smallest_perfect_square_greater_than_t_cases(5, [0, 0, 1, 2, 3]) [1, 1, 4, 4, 4] >>> smallest_perfect_square_greater_than_t_cases(3, [100, 250, 500]) [121, 256, 529] >>> smallest_perfect_square_greater_than_t_cases(3, [1000, 5000, 10000]) [1024, 5041, 10201]","solution":"import math def smallest_perfect_square_greater_than_t_cases(t, cases): results = [] for n in cases: next_square_root = math.ceil(math.sqrt(n + 1)) results.append(next_square_root ** 2) return results"},{"question":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the elements of the array \`nums\` to the right by \`k\` steps. Args: nums (List[int]): List of integers to rotate. k (int): Number of steps to rotate the array. Returns: List[int]: The rotated array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, -1, -2, -3, -4], 3) [-2, -3, -4, 0, -1]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the elements of the array \`nums\` to the right by \`k\` steps. Args: nums (List[int]): List of integers to rotate. k (int): Number of steps to rotate the array. Returns: List[int]: The rotated array. n = len(nums) # In case the number of rotations is greater than the length of array k = k % n # Reverse entire list first reverse(nums, 0, n - 1) # Reverse first part (0 to k-1) reverse(nums, 0, k - 1) # Reverse second part (k to n-1) reverse(nums, k, n - 1) return nums def reverse(nums: List[int], start: int, end: int) -> None: Helper function to reverse elements in the list from start to end. Args: nums (List[int]): List to reverse. start (int): Starting index. end (int): Ending index. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1"},{"question":"from typing import List, Tuple def longest_path_dag(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Find the length of the longest path (in terms of the number of edges) a bird can travel without revisiting any location. Args: N : int : The number of locations. M : int : The number of direct paths (edges) between locations. edges : List[Tuple[int, int]] : A list of tuples representing a directed edge from location u to location v. Returns: int : The length of the longest path in the graph without revisiting any location. Example: >>> longest_path_dag(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (3, 6), (1, 5)]) 5 >>> longest_path_dag(5, 0, []) 0 >>> longest_path_dag(2, 1, [(1, 2)]) 1 >>> longest_path_dag(5, 3, [(1, 2), (3, 4), (4, 5)]) 2 >>> longest_path_dag(5, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) 3 pass","solution":"def longest_path_dag(N, M, edges): from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * N # Create the graph for u, v in edges: graph[u-1].append(v-1) indegree[v-1] += 1 # Topological sorting using Kahn's Algorithm topo_sort = [] zero_indegree_queue = deque([i for i in range(N) if indegree[i] == 0]) while zero_indegree_queue: node = zero_indegree_queue.popleft() topo_sort.append(node) for neighbour in graph[node]: indegree[neighbour] -= 1 if indegree[neighbour] == 0: zero_indegree_queue.append(neighbour) # Finding the longest path in the DAG using DP approach longest_path = [0] * N for node in topo_sort: for neighbour in graph[node]: if longest_path[neighbour] < longest_path[node] + 1: longest_path[neighbour] = longest_path[node] + 1 return max(longest_path) # Example usage N = 6 M = 7 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (3, 6), (1, 5) ] print(longest_path_dag(N, M, edges)) # Output: 5"},{"question":"def summarize_orders(orders: List[List[Tuple[int, int]]]) -> Tuple[int, int]: Returns the total revenue and the number of distinct items sold for the given orders. :param orders: List of orders, each order being a list of tuples with (quantity, price) :return: Tuple of total revenue and number of distinct items sold >>> summarize_orders([]) (0, 0) >>> summarize_orders([[(2, 10)]]) (20, 1) >>> summarize_orders([[(2, 10), (3, 5)]]) (2*10 + 3*5, 2) >>> summarize_orders([[(2, 10)], [(1, 10)]]) (2*10 + 1*10, 1) >>> summarize_orders([[(2, 10), (1, 5)], [(1, 10), (3, 5)], [(2, 5)]]) (2*10 + 1*5 + 1*10 + 3*5 + 2*5, 2) >>> summarize_orders([[(3, 7)], [(1, 7), (2, 10)], [(5, 7)]]) (3*7 + 1*7 + 2*10 + 5*7, 2) >>> summarize_orders([[(100, 100)], [(100, 100)], [(95, 75)]]) (100*100 + 100*100 + 95*75, 2)","solution":"def summarize_orders(orders): Returns the total revenue and the number of distinct items sold for the given orders. :param orders: List of orders, each order being a list of tuples with (quantity, price) :return: Tuple of total revenue and number of distinct items sold total_revenue = 0 distinct_items = set() for order in orders: for q, p in order: total_revenue += q * p distinct_items.add(p) return total_revenue, len(distinct_items)"},{"question":"def find_max_weight_path(n, m, E, C, tunnels): Determines the maximum weight of the mineral that can be safely transported from planet E to planet C using the existing tunnels. Args: n (int): Number of planets. m (int): Number of space tunnels. E (int): Starting planet. C (int): Destination planet. tunnels (List[Tuple[int, int, int]]): List of tuples representing the tunnel connections and weight limits. Returns: int: Maximum weight of the mineral that can be transported safely. >>> find_max_weight_path(4, 4, 1, 4, [(1, 2, 5), (2, 3, 8), (3, 4, 6), (1, 3, 4)]) 5 >>> find_max_weight_path(4, 2, 1, 4, [(1, 2, 5), (3, 4, 6)]) 0 pass def process_input(input_data): Processes the input data and returns the results for each dataset. Args: input_data (str): Multiline string input data containing multiple datasets. Returns: List[int]: List of results for each dataset. >>> input_data = '''4 4 ... 1 4 ... 1 2 5 ... 2 3 8 ... 3 4 6 ... 1 3 4 ... 0 0''' >>> process_input(input_data) [5] >>> input_data = '''4 4 ... 1 4 ... 1 2 5 ... 2 3 8 ... 3 4 6 ... 1 3 4 ... 3 3 ... 1 2 ... 1 2 3 ... 2 3 4 ... 1 3 2 ... 0 0''' >>> process_input(input_data) [5, 3] pass","solution":"import heapq def find_max_weight_path(n, m, E, C, tunnels): # Construct the graph graph = [[] for _ in range(n + 1)] for A, B, W in tunnels: graph[A].append((B, W)) graph[B].append((A, W)) # Use a max-heap priority queue max_heap = [(-float('inf'), E)] max_weight = [-float('inf')] * (n + 1) max_weight[E] = float('inf') while max_heap: curr_weight, u = heapq.heappop(max_heap) curr_weight = -curr_weight if u == C: return curr_weight for v, weight in graph[u]: min_capacity = min(curr_weight, weight) if min_capacity > max_weight[v]: max_weight[v] = min_capacity heapq.heappush(max_heap, (-min_capacity, v)) return 0 def process_input(input_data): lines = input_data.strip().split('n') i = 0 results = [] while True: # Read first line of the dataset n, m = map(int, lines[i].split()) if n == 0 and m == 0: break # Read second line of the dataset e, c = map(int, lines[i + 1].split()) # Read the tunnels tunnels = [] for j in range(i + 2, i + 2 + m): a, b, w = map(int, lines[j].split()) tunnels.append((a, b, w)) # Calculate the result for the dataset result = find_max_weight_path(n, m, e, c, tunnels) results.append(result) # Move to the next dataset i += 2 + m return results"},{"question":"def add_matrices(n: int, m: int, A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Returns the sum of two matrices A and B, each with dimensions n x m. Parameters: n: int - number of rows in the matrices m: int - number of columns in the matrices A: List[List[int]] - first matrix B: List[List[int]] - second matrix Returns: List[List[int]] - resulting matrix after adding A and B element-wise >>> add_matrices(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) [[10, 10, 10], [10, 10, 10], [10, 10, 10]] >>> add_matrices(1, 1, [[1]], [[2]]) [[3]] >>> add_matrices(2, 2, [[1, 2], [3, 4]], [[4, 3], [2, 1]]) [[5, 5], [5, 5]] >>> add_matrices(2, 3, [[0, 0, 0], [0, 0, 0]], [[1, 2, 3], [4, 5, 6]]) [[1, 2, 3], [4, 5, 6]]","solution":"def add_matrices(n, m, A, B): Returns the sum of two matrices A and B, each with dimensions n x m. C = [] for i in range(n): row = [] for j in range(m): row.append(A[i][j] + B[i][j]) C.append(row) return C"},{"question":"def optimize_route(n: int, house_coordinates: List[int]) -> Tuple[int, List[int]]: Determine the optimal order of visiting houses to minimize the total distance traveled. Parameters: n (int): Number of houses. house_coordinates (list of int): Coordinates of the houses. Returns: tuple: Minimal total distance and the optimal visiting order of house coordinates. >>> optimize_route(1, [10]) (20, [10]) >>> optimize_route(5, [-10, 20, 30, -20, 0]) (100, [-20, -10, 0, 20, 30]) >>> optimize_route(3, [-5, 0, 5]) (20, [-5, 0, 5]) >>> optimize_route(3, [5, 0, -5]) (20, [-5, 0, 5]) >>> optimize_route(3, [0, 0, 0]) (0, [0, 0, 0]) >>> optimize_route(3, [-1000000000, 0, 1000000000]) (4000000000, [-1000000000, 0, 1000000000]) pass","solution":"def optimize_route(n, house_coordinates): Determine the optimal order of visiting houses to minimize the total distance traveled. Parameters: n (int): Number of houses. house_coordinates (list of int): Coordinates of the houses. Returns: tuple: Minimal total distance and the optimal visiting order of house coordinates. # Sort the house coordinates house_coordinates.sort() total_distance = 0 current_position = 0 optimal_order = [] for house in house_coordinates: total_distance += abs(house - current_position) current_position = house optimal_order.append(house) # Add the distance from the last house back to start point 0 total_distance += abs(current_position) return total_distance, optimal_order"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> str: Determines if there are any two distinct elements in the list that add up to the target sum. Args: nums (list of int): A list of integers. target (int): The target sum to find in the list. Returns: str: \\"YES\\" if there are two distinct elements that add up to the target sum, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 4, 3, 5], 7) 'YES' >>> has_pair_with_sum([1, 2, 4, 3, 5], 10) 'NO' >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) 'YES' >>> has_pair_with_sum([-1, -2, -3, -4, -5], -2) 'NO' >>> has_pair_with_sum([-1, 2, 3, 7], 6) 'YES' >>> has_pair_with_sum([-1, 2, 3, 7], 12) 'NO' >>> has_pair_with_sum([-1, 1, 3, 4], 0) 'YES' >>> has_pair_with_sum([1, 2, 3, 4], 0) 'NO' >>> has_pair_with_sum([], 5) 'NO' >>> has_pair_with_sum([1], 5) 'NO'","solution":"def has_pair_with_sum(nums, target): Determines if there are any two distinct elements in the list that add up to the target sum. Args: nums (list of int): A list of integers. target (int): The target sum to find in the list. Returns: str: \\"YES\\" if there are two distinct elements that add up to the target sum, otherwise \\"NO\\". seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List def minCoins(coins: List[int], amount: int) -> int: Returns the minimum number of coins needed to make up the given amount, or -1 if it's not possible. Args: coins (List[int]): List of coin denominations. amount (int): The target amount. Returns: int: Minimum number of coins needed to make the amount, or -1 if not possible. Examples: >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1 >>> minCoins([1, 3, 4], 6) 2 >>> minCoins([5, 3, 1], 7) 3","solution":"def minCoins(coins, amount): Returns the minimum number of coins needed to make up the given amount, or -1 if it's not possible. Args: coins (List[int]): List of coin denominations. amount (int): The target amount. Returns: int: Minimum number of coins needed to make the amount, or -1 if not possible. # Initialize DP array to a large number, assuming the amount cannot be negative. dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def maximizeProfit(prices): Returns the maximum profit that can be achieved by buying one stock and then selling it later. If no profit can be achieved, return 0. Example: >>> maximizeProfit([7, 1, 5, 3, 6, 4]) 5 >>> maximizeProfit([7, 6, 4, 3, 1]) 0 >>> maximizeProfit([1, 2, 90, 10, 110]) 109 pass # Unit tests def test_maximizeProfit_normal_cases(): assert maximizeProfit([7, 1, 5, 3, 6, 4]) == 5 # buy at 1 and sell at 6 assert maximizeProfit([1, 2, 90, 10, 110]) == 109 # buy at 1 and sell at 110 def test_maximizeProfit_no_profit(): assert maximizeProfit([7, 6, 4, 3, 1]) == 0 # no profit is possible assert maximizeProfit([5, 4, 3, 2, 1]) == 0 # no profit is possible def test_maximizeProfit_empty_prices(): assert maximizeProfit([]) == 0 # empty list returns 0 def test_maximizeProfit_single_price(): assert maximizeProfit([5]) == 0 # only one price, no transaction possible def test_maximizeProfit_same_prices(): assert maximizeProfit([3, 3, 3, 3, 3]) == 0 # no increase in price def test_maximizeProfit_increasing_prices(): assert maximizeProfit([1, 2, 3, 4, 5]) == 4 # buy at 1 and sell at 5 def test_maximizeProfit_decreasing_then_increasing(): assert maximizeProfit([9, 1, 5, 3, 6, 4]) == 5 # buy at 1 and sell at 6","solution":"def maximizeProfit(prices): Returns the maximum profit that can be achieved by buying one stock and then selling it later. If no profit can be achieved, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List, Tuple def find_winner_of_game(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the winner of the game given the initial array of integers. Each test case consists of an integer n followed by an array of n positive integers. The function should return a list of strings. Each entry in the list should be 'Petya' if Petya wins the game with optimal play, or 'Vasya' if Vasya wins the game. >>> find_winner_of_game(2, [(3, [6, 9, 12]), (4, [2, 3, 5, 7])]) ['Petya', 'Vasya'] >>> find_winner_of_game(1, [(5, [4, 8, 12, 16, 20])]) ['Petya'] results = [] for n, array in test_cases: # Logic to determine the winner of the game return results","solution":"def find_winner_of_game(t, test_cases): results = [] for test_case in test_cases: n, array = test_case # If the number of elements in the array is odd, Petya wins, else Vasya wins. results.append(\\"Petya\\" if n % 2 == 1 else \\"Vasya\\") return results"},{"question":"def parse_input(input_string: str) -> List[List[Union[int, Tuple[str, str, int]]]]: Parse the input string to extract test cases. >>> parse_input(\\"3nA X 5nB Y 2nC Z 1n0\\") [[3, ('A', 'X', 5), ('B', 'Y', 2), ('C', 'Z', 1)]] def process_tasks(test_cases: List[List[Union[int, Tuple[str, str, int]]]]) -> List[str]: Process the tasks and determine the order in which tasks should be processed to minimize the total waiting time. >>> process_tasks([[3, ('A', 'X', 5), ('B', 'Y', 2), ('C', 'Z', 1)]]) ['Z Y X'] def task_management(input_string: str) -> None: Manage the tasks based on the input string and print the order in which tasks should be processed. >>> task_management(\\"3nA X 5nB Y 2nC Z 1n0\\") \\"Z Y Xn\\"","solution":"def process_tasks(test_cases): results = [] for case in test_cases: tasks = sorted(case[1:], key=lambda x: x[2]) # Sort by priority level results.append(' '.join([task[1] for task in tasks])) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") index = 0 test_cases = [] while index < len(lines): T = int(lines[index]) if T == 0: break case = [T] for i in range(index + 1, index + 1 + T): employee, task, priority = lines[i].split() case.append((employee, task, int(priority))) test_cases.append(case) index += 1 + T return test_cases def task_management(input_string): test_cases = parse_input(input_string) results = process_tasks(test_cases) for result in results: print(result)"},{"question":"def max_duration(N, M, durations): Given a list of message durations, determine the maximum total duration that can be achieved without exceeding the limit N. :param N: The maximum allowed total duration. :param M: The number of messages. :param durations: List containing the duration of each message. :return: The maximum total duration that can be achieved without exceeding the limit. >>> max_duration(10, 3, [4, 5, 1]) == 10 >>> max_duration(15, 5, [10, 8, 5, 7, 3]) == 15 >>> max_duration(7, 4, [2, 2, 3, 5]) == 7 >>> max_duration(10, 5, [2, 2, 2, 2, 2]) == 10 >>> max_duration(6, 2, [10, 15]) == 0 >>> max_duration(10, 3, [3, 4, 5]) == 9 >>> max_duration(12, 5, [1, 4, 5, 6, 8]) == 12","solution":"def max_duration(N, M, durations): Given a list of message durations, determine the maximum total duration that can be achieved without exceeding the limit N. :param N: The maximum allowed total duration. :param M: The number of messages. :param durations: List containing the duration of each message. :return: The maximum total duration that can be achieved without exceeding the limit. dp = [0] * (N + 1) for duration in durations: for j in range(N, duration - 1, -1): dp[j] = max(dp[j], dp[j-duration] + duration) return dp[N]"},{"question":"def smallest_lexicographical_palindrome(t: int, test_cases: List[str]) -> List[str]: Write a function that takes a string as input and determines if it is possible to rearrange the characters of the string to form a palindromic string. If it is possible, return the palindromic string with the smallest lexicographical order. Otherwise, return the string \\"NOT POSSIBLE\\". Args: t (int): the number of test cases. test_cases (List[str]): a list of strings to check. Returns: List[str]: List containing smallest lexicographical palindromic string or \\"NOT POSSIBLE\\" for each input string. >>> smallest_lexicographical_palindrome(1, [\\"aabb\\"]) [\\"abba\\"] >>> smallest_lexicographical_palindrome(1, [\\"abc\\"]) [\\"NOT POSSIBLE\\"]","solution":"def smallest_lexicographical_palindrome(t, test_cases): def can_form_palindrome(s): from collections import Counter count = Counter(s) odd_count = sum(1 for c in count if count[c] % 2 != 0) return odd_count <= 1 def form_smallest_palindrome(s): from collections import Counter count = Counter(s) left_half = [] middle_char = '' for char in sorted(count): if count[char] % 2 != 0: middle_char = char left_half.append(char * (count[char] // 2)) left_half = ''.join(left_half) right_half = left_half[::-1] return left_half + middle_char + right_half results = [] for s in test_cases: if can_form_palindrome(s): results.append(form_smallest_palindrome(s)) else: results.append(\\"NOT POSSIBLE\\") return results # Example usage t = 2 test_cases = [\\"aabb\\", \\"abc\\"] print(smallest_lexicographical_palindrome(t, test_cases))"},{"question":"def find_target_in_grid(n, grid, target): Finds the position of the target in the n x n grid. Parameters: n (int): size of the grid grid (List[List[int]]): n x n grid of integers target (int): the integer to find in the grid Returns: Tuple[int, int] or int: position (1-based) of the target in the grid, or -1 if not found Example: >>> find_target_in_grid(4, [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], 5) (2, 2) >>> find_target_in_grid(3, [[1, 4, 7], [2, 5, 8], [3, 6, 9]], 10) -1","solution":"def find_target_in_grid(n, grid, target): Finds the position of the target in the n x n grid. Parameters: n (int): size of the grid grid (List[List[int]]): n x n grid of integers target (int): the integer to find in the grid Returns: Tuple[int, int] or int: position (1-based) of the target in the grid, or -1 if not found row, col = 0, n - 1 while row < n and col >= 0: if grid[row][col] == target: return (row + 1, col + 1) elif grid[row][col] > target: col -= 1 else: row += 1 return -1"},{"question":"def minimized_sum_of_max_values(n: int, k: int, arr: List[int]) -> int: This function distributes the sequence into k subsequences to minimize the sum of the maximum values of these subsequences. :param n: int: The number of integers in arr :param k: int: The number of subsequences :param arr: list: The list of integers :return: int: The minimized sum of the maximum values of the k subsequences >>> minimized_sum_of_max_values(5, 3, [3, 1, 4, 1, 5]) 12 >>> minimized_sum_of_max_values(7, 2, [1, 2, 3, 4, 5, 6, 7]) 13 from typing import List def test_minimized_sum_of_max_values_case1(): assert minimized_sum_of_max_values(5, 3, [3, 1, 4, 1, 5]) == 12 def test_minimized_sum_of_max_values_case2(): assert minimized_sum_of_max_values(7, 2, [1, 2, 3, 4, 5, 6, 7]) == 13 def test_minimized_sum_of_max_values_case3(): assert minimized_sum_of_max_values(4, 4, [1, 1, 1, 1]) == 4 def test_minimized_sum_of_max_values_case4(): assert minimized_sum_of_max_values(6, 3, [2, 2, 2, 2, 2, 2]) == 6 def test_minimized_sum_of_max_values_case5(): assert minimized_sum_of_max_values(6, 1, [1,1,2,2,3,3]) == 3","solution":"def minimized_sum_of_max_values(n, k, arr): This function distributes the sequence into k subsequences to minimize the sum of the maximum values of these subsequences. :param n: int: The number of integers in arr :param k: int: The number of subsequences :param arr: list: The list of integers :return: int: The minimized sum of the maximum values of the k subsequences arr.sort(reverse=True) return sum(arr[:k])"},{"question":"from typing import List, Tuple def min_cost_transport(m: int, n: int, grid: List[str], start: Tuple[int, int], end: Tuple[int, int]) -> int: Calculate the minimum cost to transport an amenity from start to end avoiding obstacles in the grid. >>> min_cost_transport(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\"#.#..\\", \\".....\\"], (0, 0), (4, 4)) 8 >>> min_cost_transport(3, 3, [\\"...\\", \\".#.\\", \\"...\\"], (0, 0), (2, 2)) 4 >>> min_cost_transport(1, 2, [\\"..\\"], (0, 0), (0, 1)) 1 >>> min_cost_transport(3, 3, [\\"...\\", \\"#\\", \\"...\\"], (0, 0), (2, 2)) -1 >>> min_cost_transport(5, 5, [\\".....\\", \\".#.\\", \\"..#..\\", \\"#.#..\\", \\".....\\"], (0, 0), (0, 0)) 0","solution":"from collections import deque def min_cost_transport(m, n, grid, start, end): def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set([(start[0], start[1])]) while queue: x, y, cost = queue.popleft() if (x, y) == (end[0], end[1]): return cost for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, cost + 1)) return -1"},{"question":"from typing import List def findMissing(arr: List[int]) -> int: Given an array of integers, find and return the smallest positive integer that is missing from the array. >>> findMissing([3, 4, -1, 1]) 2 >>> findMissing([1, 2, 0]) 3 >>> findMissing([7, 8, 9, 11, 12]) 1 def test_example_cases(): assert findMissing([3, 4, -1, 1]) == 2 assert findMissing([1, 2, 0]) == 3 assert findMissing([7, 8, 9, 11, 12]) == 1 def test_empty_array(): assert findMissing([]) == 1 def test_array_with_all_negatives(): assert findMissing([-1, -2, -3]) == 1 def test_array_with_all_positive_consecutive(): assert findMissing([1, 2, 3, 4, 5]) == 6 def test_array_with_large_numbers(): assert findMissing([100, 101, 102]) == 1 def test_array_with_duplicates(): assert findMissing([1, 1, 2, 2]) == 3 def test_single_element(): assert findMissing([1]) == 2 assert findMissing([2]) == 1","solution":"def findMissing(arr): n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def can_partition(n: int, k: int) -> str: Determines whether it is possible to partition the integer n into exactly k distinct, positive integers. >>> can_partition(8, 3) \\"YES\\" >>> can_partition(15, 4) \\"YES\\" >>> can_partition(7, 4) \\"NO\\" >>> can_partition(21, 6) \\"YES\\" >>> can_partition(10, 5) \\"NO\\" def partition_test_cases(test_cases: List[Tuple[int, int]]) -> List[str]: Handles multiple test cases and returns a list of results for each case. >>> partition_test_cases([(8, 3), (15, 4), (7, 4)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> partition_test_cases([(21, 6), (12, 4), (10, 5)]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_partition(n, k): Determines whether it is possible to partition the integer n into exactly k distinct, positive integers. Parameters: n (int): The integer to be partitioned. k (int): The number of distinct positive integers required. Returns: str: \\"YES\\" if the partition is possible, \\"NO\\" otherwise. # Minimum sum required for k distinct integers is sum of first k integers min_sum = k * (k + 1) // 2 # Check if the minimum sum is less than or equal to n if min_sum <= n: return \\"YES\\" else: return \\"NO\\" # Function to handle multiple test cases def partition_test_cases(test_cases): results = [] for case in test_cases: n, k = case results.append(can_partition(n, k)) return results"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. Args: heights (List[int]): List of non-negative integers representing the heights of the histogram bars. Returns: int: The area of the largest rectangle in the histogram. Examples: >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4 from solution import largestRectangleArea def test_sample_input_1(): assert largestRectangleArea([2,1,5,6,2,3]) == 10 def test_sample_input_2(): assert largestRectangleArea([2,4]) == 4 def test_single_element(): assert largestRectangleArea([2]) == 2 assert largestRectangleArea([5]) == 5 def test_all_same_height(): assert largestRectangleArea([3, 3, 3, 3, 3]) == 15 assert largestRectangleArea([6, 6, 6, 6]) == 24 def test_mixed_heights(): assert largestRectangleArea([1, 2, 3, 4, 5]) == 9 # From the third element to the fifth element assert largestRectangleArea([5, 4, 3, 2, 1]) == 9 # From the first element to the third element def test_zero_height(): assert largestRectangleArea([0, 2, 0, 1, 0]) == 2 assert largestRectangleArea([0, 0, 0, 0, 0]) == 0","solution":"def largestRectangleArea(heights): Find the largest rectangle area in the histogram with bar heights given by the heights array. stack = [] # stack to store the indices of the histogram bars max_area = 0 # variable to keep track of the maximum area # Append a 0 height to handle the computation at the end heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"def can_decrypt_message(t: str, m: int, rules: List[Tuple[str, str]]) -> str: Determine if it is possible to restore the original message from the encrypted message using the given transformation rules. >>> can_decrypt_message(\\"hello\\", 3, [('h', 'e'), ('e', 'l'), ('l', 'o')]) == \\"YES\\" >>> can_decrypt_message(\\"abcde\\", 2, [('a', 'b'), ('c', 'd')]) == \\"NO\\" >>> can_decrypt_message(\\"a\\", 1, [('b', 'a')]) == \\"YES\\" >>> can_decrypt_message(\\"z\\", 1, [('a', 'b')]) == \\"NO\\" >>> can_decrypt_message(\\"ttttt\\", 5, [('s', 't'), ('t', 'u'), ('u', 'v'), ('v', 'w'), ('w', 'x')]) == \\"YES\\" >>> can_decrypt_message(\\"eeeee\\", 3, [('a', 'b'), ('b', 'c'), ('c', 'd')]) == \\"NO\\"","solution":"def can_decrypt_message(t, m, rules): from collections import defaultdict, deque # Create graph of transformations def make_graph(rules): graph = defaultdict(list) for a, b in rules: graph[b].append(a) return graph # Perform a BFS to check if we can reverse the transformation for each letter in t def can_transform_to_original(graph, letter): queue = deque([letter]) visited = set() while queue: current = queue.popleft() if current in original_letters: return True for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False # Extract all original letters from the rules original_letters = set(a for a, b in rules) # Create transformation graph transformation_graph = make_graph(rules) # Check if each letter in the encrypted message can be transformed back to any original letter for char in t: if not can_transform_to_original(transformation_graph, char): return \\"NO\\" return \\"YES\\""},{"question":"def has_pair_with_sum(arr: list, k: int) -> bool: Determines if there are any two distinct numbers in the array that add up to k. Args: arr (list of int): The array of integers. k (int): The target sum. Returns: bool: True if there are two distinct numbers that add up to k, else False. Examples: >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False pass def test_has_pair_with_sum(): assert has_pair_with_sum([10, 15, 3, 7], 17) == True assert has_pair_with_sum([1, 2, 3, 9], 8) == False assert has_pair_with_sum([1, 2, 4, 4], 8) == True assert has_pair_with_sum([5, 6, 2, 3], 13) == False assert has_pair_with_sum([], 5) == False assert has_pair_with_sum([1, 3, 4, 4, 5, 7], 8) == True assert has_pair_with_sum([2, 4, 6, 8], 14) == True assert has_pair_with_sum([-1, -2, -3, -4, -5, 0], -3) == True assert has_pair_with_sum([-1, -2, -3, -4, -5], -10) == False assert has_pair_with_sum([6, 1, 4, 10, 15, 1], 11) == True # Running the test if __name__ == \\"__main__\\": test_has_pair_with_sum() print(\\"All tests passed.\\")","solution":"def has_pair_with_sum(arr, k): Determines if there are any two distinct numbers in the array that add up to k. Args: arr (list of int): The array of integers. k (int): The target sum. Returns: bool: True if there are two distinct numbers that add up to k, else False. seen = set() for number in arr: complement = k - number if complement in seen: return True seen.add(number) return False"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a series of queries on an array of integers. Each query will require finding the result of a specified operation over a subarray defined by given indices. The operations are: 1. Calculate the sum of the elements in the subarray. 2. Find the maximum element in the subarray. 3. Find the minimum element in the subarray. Parameters: n (int): The length of the array. q (int): The number of queries. array (List[int]): The array of integers. queries (List[Tuple[int, int, int]]): The queries to be processed. Returns: List[int]: The results of the queries. Examples: >>> process_queries(5, 3, [1, 3, -2, 8, 4], [(1, 1, 3), (2, 0, 4), (3, 2, 4)]) [9, 8, -2] >>> process_queries(4, 2, [10, -10, 20, -20], [(1, 0, 3), (1, 1, 3)]) [0, -10] >>> process_queries(4, 2, [1, 2, 3, 4], [(2, 0, 2), (2, 1, 3)]) [3, 4] >>> process_queries(5, 2, [0, -1, -2, -3, -4], [(3, 0, 3), (3, 1, 4)]) [-3, -4] >>> process_queries(6, 3, [5, -3, 6, -2, 4, -1], [(1, 2, 4), (2, 0, 5), (3, 1, 3)]) [8, 6, -3]","solution":"def process_queries(n, q, array, queries): results = [] for query in queries: t, l, r = query subarray = array[l:r+1] if t == 1: # Calculate sum result = sum(subarray) elif t == 2: # Find maximum result = max(subarray) elif t == 3: # Find minimum result = min(subarray) results.append(result) return results # Example usage: # n = 5 # q = 3 # array = [1, 3, -2, 8, 4] # queries = [(1, 1, 3), (2, 0, 4), (3, 2, 4)] # output = process_queries(n, q, array, queries) # print(output) # Should print: [9, 8, -2]"},{"question":"def find_missing_number(nums, n): Given an array nums containing n distinct numbers in the range [0, n], returns the missing number in the range. pass def process_test_cases(test_cases): Takes a list of test cases and produces the missing number for each pass def test_find_missing_number(): assert find_missing_number([3, 0, 1], 3) == 2 assert find_missing_number([2, 0], 2) == 1 assert find_missing_number([3, 0, 1, 4], 4) == 2 assert find_missing_number([0], 1) == 1 assert find_missing_number([0, 1, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 2 def test_process_test_cases(): test_cases = [ ([3, 0, 1], 3), ([2, 0], 2), ([3, 0, 1, 4], 4), ] expected_results = [2, 1, 2] assert process_test_cases(test_cases) == expected_results test_cases = [ ([], 0), ([0], 1), ] expected_results = [0, 1] assert process_test_cases(test_cases) == expected_results","solution":"def find_missing_number(nums, n): Given an array nums containing n distinct numbers in the range [0, n], returns the missing number in the range. total_sum = n * (n + 1) / 2 array_sum = sum(nums) return int(total_sum - array_sum) def process_test_cases(test_cases): Takes a list of test cases and produces the missing number for each results = [] for nums, n in test_cases: results.append(find_missing_number(nums, n)) return results"},{"question":"def diagonal_difference(mat): Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. Args: mat (List[List[int]]): A square matrix of integers. Returns: int: The absolute difference. >>> diagonal_difference([ [11, 2, 4], [4, 5, 6], [10, 8, -12] ]) 15 >>> diagonal_difference([ [6, 2, 1, 4], [2, 3, 4, 5], [5, 1, 3, 2], [7, 4, 6, 1] ]) 3 def solve(T, test_cases): Given a number of test cases and corresponding square matrices, computes the absolute differences between the sums of their primary and secondary diagonals. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples, where each tuple contains an integer N (size of the matrix) and an N x N matrix represented as a list of lists. Returns: List[int]: A list containing the absolute differences for each test case. >>> solve(2, [ (3, [ [11, 2, 4], [4, 5, 6], [10, 8, -12] ]), (4, [ [6, 2, 1, 4], [2, 3, 4, 5], [5, 1, 3, 2], [7, 4, 6, 1] ]) ]) [15, 3] from solution import diagonal_difference, solve def test_diagonal_difference_example(): mat = [ [11, 2, 4], [4, 5, 6], [10, 8, -12] ] assert diagonal_difference(mat) == 15 def test_diagonal_difference_another_example(): mat = [ [6, 2, 1, 4], [2, 3, 4, 5], [5, 1, 3, 2], [7, 4, 6, 1] ] assert diagonal_difference(mat) == 3 def test_solve(): T = 2 test_cases = [ (3, [ [11, 2, 4], [4, 5, 6], [10, 8, -12] ]), (4, [ [6, 2, 1, 4], [2, 3, 4, 5], [5, 1, 3, 2], [7, 4, 6, 1] ]) ] expected = [15, 3] assert solve(T, test_cases) == expected def test_diagonal_difference_single_element(): mat = [ [1] ] assert diagonal_difference(mat) == 0 def test_diagonal_difference_zero_matrix(): mat = [ [0, 0], [0, 0] ] assert diagonal_difference(mat) == 0 def test_diagonal_difference_negative_values(): mat = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert diagonal_difference(mat) == 0 # Both diagonals have sum -15","solution":"def diagonal_difference(mat): Returns the absolute difference between the sums of the primary and secondary diagonals of a square matrix. N = len(mat) primary_sum = sum(mat[i][i] for i in range(N)) secondary_sum = sum(mat[i][N - i - 1] for i in range(N)) return abs(primary_sum - secondary_sum) def solve(T, test_cases): results = [] for k in range(T): N = test_cases[k][0] mat = test_cases[k][1] results.append(diagonal_difference(mat)) return results"},{"question":"def find_median_prime(n: int, sequence: List[int]) -> int: Find the median of all prime numbers in the sequence, rounded to the nearest integer. If there are no prime numbers, return -1. Args: n: The number of integers in the sequence. sequence: A list of integers. Returns: The median of prime numbers rounded to the nearest integer, or -1 if there are no prime numbers. >>> find_median_prime(5, [3, 5, 12, 7, 14]) 5 >>> find_median_prime(4, [4, 6, 8, 10]) -1 from solution import find_median_prime def test_no_primes(): assert find_median_prime(4, [4, 6, 8, 10]) == -1 def test_all_primes(): assert find_median_prime(5, [3, 5, 7, 11, 13]) == 7 def test_some_primes(): assert find_median_prime(5, [3, 5, 12, 7, 14]) == 5 def test_one_prime(): assert find_median_prime(1, [7]) == 7 def test_even_number_of_primes(): assert find_median_prime(6, [3, 5, 7, 11, 13, 17]) == 9 def test_large_numbers(): assert find_median_prime(5, [9999991, 99999931, 99999941, 99999959, 99999971]) == 99999941","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def find_median_prime(n, sequence): primes = [num for num in sequence if is_prime(num)] if not primes: return -1 primes.sort() mid = len(primes) // 2 if len(primes) % 2 == 1: return primes[mid] else: return round((primes[mid - 1] + primes[mid]) / 2)"},{"question":"def find_subarray_with_sum_zero(T: int, test_cases: list) -> list: Given an array of integers, find if there exists a subarray with sum equal to 0. >>> find_subarray_with_sum_zero(2, [(5, [4, 2, -3, 1, 6]), (5, [4, 2, 0, 1, 6])]) [\\"YES\\", \\"YES\\"] >>> find_subarray_with_sum_zero(3, [(3, [1, 2, 3]), (2, [5, -7]), (4, [1, 2, 3, 4])]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def find_subarray_with_sum_zero(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] seen = set() current_sum = 0 found = False for num in arr: current_sum += num if current_sum == 0 or current_sum in seen: results.append(\\"YES\\") found = True break seen.add(current_sum) if not found: results.append(\\"NO\\") return results"},{"question":"def plant_flowers(n: int, k: int) -> List[int]: Returns a possible arrangement of flowers such that no two adjacent flowers are of the same type, or \\"Not possible\\" if it cannot be done. :param n: Total number of flowers to be planted :param k: Number of different types of flowers available :return: A possible arrangement as a list of integers or \\"Not possible\\" >>> plant_flowers(5, 3) [1, 2, 3, 1, 2] >>> plant_flowers(1, 1) [1] >>> plant_flowers(2, 1) \\"Not possible\\" >>> plant_flowers(100, 2)[:10] [1, 2, 1, 2, 1, 2, 1, 2, 1, 2] >>> plant_flowers(10, 1) \\"Not possible\\" >>> plant_flowers(6, 6) [1, 2, 3, 4, 5, 6] >>> plant_flowers(3, 10) [1, 2, 3] >>> plant_flowers(10, 3) [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]","solution":"def plant_flowers(n, k): Returns a possible arrangement of flowers such that no two adjacent flowers are of the same type, or \\"Not possible\\" if it cannot be done. :param n: Total number of flowers to be planted :param k: Number of different types of flowers available :return: A possible arrangement as a list of integers or \\"Not possible\\" if k == 1 and n > 1: return \\"Not possible\\" arrangement = [] for i in range(n): arrangement.append((i % k) + 1) return arrangement"},{"question":"from typing import List def find_max_submatrix(matrix: List[List[int]], k: int) -> List[List[int]]: Given a 2D matrix of size NxM filled with integers, find the maximum sum of a submatrix with dimensions kxk. If there are multiple submatrices with the maximum sum, return the one which appears first while scanning from the top-left to the bottom-right. If k is greater than the dimensions of the matrix, return -1. Examples: >>> find_max_submatrix([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ], 2) [[11, 12], [15, 16]] >>> find_max_submatrix([ [1, -2, -3], [-4, 5, -6], [-7, 8, 9] ], 1) [[9]] >>> find_max_submatrix([ [1, 2], [3, 4] ], 3) -1","solution":"from typing import List def find_max_submatrix(matrix: List[List[int]], k: int) -> List[List[int]]: n = len(matrix) m = len(matrix[0]) if k > n or k > m: return -1 max_sum = -float('inf') result_submatrix = [] for i in range(n - k + 1): for j in range(m - k + 1): current_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k)) if current_sum > max_sum: max_sum = current_sum result_submatrix = [matrix[x][j:j+k] for x in range(i, i+k)] return result_submatrix"},{"question":"def minimal_max_pages(n: int, pages: List[int], k: int) -> int: Find the minimal possible value for the maximum number of pages in any stack when the books are optimally stacked. >>> minimal_max_pages(6, [5, 7, 2, 6, 8, 3], 3) 12 >>> minimal_max_pages(5, [1, 1, 1, 1, 1], 5) 1 # Implementation here def test_minimal_max_pages(): assert minimal_max_pages(6, [5, 7, 2, 6, 8, 3], 3) == 12 assert minimal_max_pages(5, [1, 1, 1, 1, 1], 5) == 1 assert minimal_max_pages(5, [10, 10, 10, 10, 10], 1) == 50 assert minimal_max_pages(4, [4, 4, 4, 4], 2) == 8 assert minimal_max_pages(7, [7, 2, 5, 10, 8, 15, 7], 3) == 22 def test_minimal_max_pages_edge(): assert minimal_max_pages(1, [1000], 1) == 1000 assert minimal_max_pages(2, [2, 2], 1) == 4 assert minimal_max_pages(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 15","solution":"def minimal_max_pages(n, pages, k): def can_stack(max_pages): stack_count, current_sum = 1, 0 for page in pages: if current_sum + page > max_pages: stack_count += 1 current_sum = page if stack_count > k: return False else: current_sum += page return True low, high = max(pages), sum(pages) while low < high: mid = (low + high) // 2 if can_stack(mid): high = mid else: low = mid + 1 return low"},{"question":"def rotateMatrix(matrix): Rotates the given NxN matrix by 90 degrees in-place in the clockwise direction. Args: matrix (List[List[int]]): The 2D list representing the matrix to be rotated. Returns: List[List[int]]: The matrix rotated 90 degrees clockwise. Example 1: >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotateMatrix(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] Example 2: >>> matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]] >>> rotateMatrix(matrix) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] Constraints: - 1 <= matrix dimensions <= 20 - -1000 <= matrix[i][j] <= 1000 pass","solution":"def rotateMatrix(matrix): Rotates the given NxN matrix by 90 degrees in-place in the clockwise direction. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_swaps_to_sort(books): Calculate the minimum number of swaps required to sort the books in ascending order of pages. Parameters: books (list): A list of integers representing the number of pages in each book. Returns: int: Minimum number of swaps required to sort the books. >>> min_swaps_to_sort([3, 1, 5, 2, 4]) 4 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> min_swaps_to_sort([2, 3, 1]) 2 >>> min_swaps_to_sort([1]) 0 >>> min_swaps_to_sort([1000, 999, 998, 997, 996, 995, 994, 993, 992, 991]) 5","solution":"def min_swaps_to_sort(books): Calculate the minimum number of swaps required to sort the books in ascending order of pages. Parameters: books (list): A list of integers representing the number of pages in each book. Returns: int: Minimum number of swaps required to sort the books. n = len(books) # Create a list of tuples where each tuple is (book pages, original index) book_with_index = [(books[i], i) for i in range(n)] # Sort the list by book pages book_with_index.sort(key=lambda x: x[0]) visited = [False] * n num_swaps = 0 for i in range(n): # if a book is already visited or in the correct place, skip it if visited[i] or book_with_index[i][1] == i: continue # Find the size of the current cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = book_with_index[x][1] cycle_size += 1 if cycle_size > 0: num_swaps += (cycle_size - 1) return num_swaps"},{"question":"def count_zero_sum_pairs(test_cases): Given a list of test cases, where each test case consists of an integer representing the number of integers in the array and the array itself, compute the number of pairs of integers (i, j) where i < j such that their sum is zero. Parameters: test_cases (List[Tuple[int, List[int]]]): List of tuples containing the number of integers and the list of integers for each test case. Returns: List[int]: A list containing the number of pairs whose sum is zero for each test case. Examples: >>> count_zero_sum_pairs([(4, [-1, 1, 2, -2]), (5, [3, -3, 0, 1, -1])]) [2, 2] >>> count_zero_sum_pairs([(3, [1, 2, 3]), (4, [-1, -2, -3, -4])]) [0, 0] # Write your code here def parse_input(input_str): Parses the given input string into the respective integer and list of integers for each test case. Parameters: input_str (str): Input string representing the number of test cases, the size of the arrays, and the arrays themselves. Returns: List[Tuple[int, List[int]]]: A list of tuples containing the number of integers and the list of integers for each test case. Examples: >>> input_str = \\"2n4n-1 1 2 -2n5n3 -3 0 1 -1n\\" >>> parse_input(input_str) [(4, [-1, 1, 2, -2]), (5, [3, -3, 0, 1, -1])] # Write your code here","solution":"def count_zero_sum_pairs(test_cases): results = [] for case in test_cases: n, arr = case count = 0 seen = {} for num in arr: if -num in seen: count += 1 seen[-num] -= 1 if seen[-num] == 0: del seen[-num] else: if num in seen: seen[num] += 1 else: seen[num] = 1 results.append(count) return results # Helper function to parse input def parse_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases"},{"question":"def birthday_reminder(initial_data, operations): Sophie is eager to track her friends' birthdays and wants to build a birthday reminder program. She starts with an initial list of friends, each associated with a particular month of the year. She then performs a series of operations to update or query this list. Each operation is one of the following: 1. Add a new friend with their birthday month. 2. Update the birthday month of an existing friend. 3. Query the friends who have their birthdays in a specific month. Your task is to help Sophie by writing a program that maintains and processes these operations efficiently. -----Constraints----- - The list of friends can have a maximum of 100,000 entries. - Each friend's name is a string of lowercase English letters (1 to 20 characters long). - The months are labeled from 1 (January) to 12 (December). - The total number of operations is up to 200,000. -----Input----- Input is given from Standard Input in the following format: N Friend_1 Month_1 Friend_2 Month_2 : Friend_N Month_N Q Operation_1 Operation_2 : Operation_Q where: - N is the initial number of friends (0 ≤ N ≤ 100,000). - Each of the next N lines contains Friend_i and Month_i, indicating the initial month of Friend_i's birthday. - Q is the number of operations. - Each of the next Q lines describes an operation in one of the following formats: - \\"ADD Friend Month\\" to add a new friend's birthday month. - \\"UPDATE Friend Month\\" to update the birthday month of an existing friend. - \\"QUERY Month\\" to list friends who have their birthdays in the specified month. -----Output----- For each \\"QUERY\\" operation, print the names of the friends who have their birthdays in the specified month in lexicographical order. If no friend has a birthday in that month, print \\"NONE\\". Examples: >>> initial_data = [(\\"alice\\", 1), (\\"bob\\", 2)] >>> operations = [\\"ADD charlie 3\\", \\"UPDATE alice 2\\", \\"QUERY 1\\", \\"QUERY 2\\", \\"QUERY 3\\"] >>> birthday_reminder(initial_data, operations) ['NONE', 'alice bob', 'charlie'] >>> initial_data = [(\\"alice\\", 1)] >>> operations = [\\"UPDATE alice 2\\", \\"QUERY 1\\", \\"QUERY 2\\"] >>> birthday_reminder(initial_data, operations) ['NONE', 'alice'] pass # write your code here","solution":"def birthday_reminder(initial_data, operations): from collections import defaultdict # Dictionary mapping friend names to their birthday months friends_to_month = {} # Dictionary mapping months to a set of friend names month_to_friends = defaultdict(set) # Process initial data for friend, month in initial_data: friends_to_month[friend] = month month_to_friends[month].add(friend) results = [] # Process operations for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": friend = parts[1] month = int(parts[2]) friends_to_month[friend] = month month_to_friends[month].add(friend) elif parts[0] == \\"UPDATE\\": friend = parts[1] new_month = int(parts[2]) old_month = friends_to_month[friend] month_to_friends[old_month].remove(friend) friends_to_month[friend] = new_month month_to_friends[new_month].add(friend) elif parts[0] == \\"QUERY\\": month = int(parts[1]) friends_in_month = sorted(month_to_friends[month]) if friends_in_month: results.append(' '.join(friends_in_month)) else: results.append(\\"NONE\\") return results"},{"question":"def max_unique_flowers(n: int, flower_types: List[int]) -> int: Henry has a garden with several flowering plants, and he loves to collect the seeds produced by these plants to grow new ones. Each plant grows exactly one type of flower and has a certain height. One day, Henry decides to arrange his plants in such a way that he gets the maximum number of unique flowers in a single view by selecting some contiguous section of his garden's row. Your task is to help Henry determine the maximum number of unique flowers in any contiguous section of his garden. Note that all the plants in his garden are aligned in a straight row. Parameters: n (int): The number of plants in Henry's garden. flower_types (List[int]): List of integers representing the type of flower for each plant. Returns: int: The maximum number of unique flowers in any contiguous section of the garden. Examples: >>> max_unique_flowers(7, [1, 2, 1, 3, 4, 2, 4]) 4 >>> max_unique_flowers(5, [1, 1, 1, 1, 1]) 1 >>> max_unique_flowers(1, [1]) 1","solution":"def max_unique_flowers(n, flower_types): Returns the maximum number of unique flowers in any contiguous section of the garden. if n == 0: return 0 flower_set = set() start = 0 max_count = 0 for end in range(n): while flower_types[end] in flower_set: flower_set.remove(flower_types[start]) start += 1 flower_set.add(flower_types[end]) max_count = max(max_count, end - start + 1) return max_count"},{"question":"class Zoo: A simple zoo management system to keep track of animals and their data. Methods: add_animal(name: str, species: str, age: int, gender: str) -> bool: Adds an animal to the zoo. get_animal(name: str) -> dict: Retrieves data of a specific animal. update_animal(name: str, species: str = None, age: int = None, gender: str = None) -> bool: Updates data of a specific animal. remove_animal(name: str) -> bool: Removes a specific animal from the zoo. list_animals() -> list: Lists names of all animals in the zoo. Example usage: >>> zoo = Zoo() >>> zoo.add_animal(\\"Leo\\", \\"Lion\\", 5, \\"Male\\") True >>> zoo.add_animal(\\"Mia\\", \\"Elephant\\", 8, \\"Female\\") True >>> zoo.get_animal(\\"Leo\\") {'species': 'Lion', 'age': 5, 'gender': 'Male'} >>> zoo.update_animal(\\"Leo\\", age=6) True >>> zoo.get_animal(\\"Leo\\") {'species': 'Lion', 'age': 6, 'gender': 'Male'} >>> zoo.remove_animal(\\"Leo\\") True >>> zoo.list_animals() ['Mia'] >>> zoo.add_animal(\\"Zara\\", \\"Zebra\\", 4, \\"Female\\") True >>> zoo.list_animals() ['Mia', 'Zara'] >>> zoo.update_animal(\\"Mia\\", species=\\"Giraffe\\", age=9) True >>> zoo.get_animal(\\"Mia\\") {'species': 'Giraffe', 'age': 9, 'gender': 'Female'} def add_animal(self, name: str, species: str, age: int, gender: str) -> bool: pass def get_animal(self, name: str) -> dict: pass def update_animal(self, name: str, species: str = None, age: int = None, gender: str = None) -> bool: pass def remove_animal(self, name: str) -> bool: pass def list_animals(self) -> list: pass","solution":"class Zoo: def __init__(self): self.animals = {} def add_animal(self, name: str, species: str, age: int, gender: str) -> bool: if name in self.animals: return False self.animals[name] = {'species': species, 'age': age, 'gender': gender} return True def get_animal(self, name: str) -> dict: if name not in self.animals: return {} return self.animals[name] def update_animal(self, name: str, species: str = None, age: int = None, gender: str = None) -> bool: if name not in self.animals: return False if species: self.animals[name]['species'] = species if age is not None: self.animals[name]['age'] = age if gender: self.animals[name]['gender'] = gender return True def remove_animal(self, name: str) -> bool: if name not in self.animals: return False del self.animals[name] return True def list_animals(self) -> list: return sorted(self.animals.keys())"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string so that all numbers appear before all words while preserving the relative order within each group. >>> rearrange_string(\\"apple 1 banana 2 oranges 3 4 grapes\\") '1 2 3 4 apple banana oranges grapes' >>> rearrange_string(\\"4 3 2 1\\") '4 3 2 1' >>> rearrange_string(\\"apple banana oranges grapes\\") 'apple banana oranges grapes' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"3 apples 1 banana 2 oranges\\") '3 1 2 apples banana oranges' >>> rearrange_string(\\"apple\\") 'apple' >>> rearrange_string(\\"1\\") '1' >>> rearrange_string(\\"123 apple 2 banana\\") '123 2 apple banana'","solution":"def rearrange_string(s): Rearranges the string so that all numbers appear before all words while preserving the relative order within each group. if not s: return \\"\\" words = s.split() numbers = [word for word in words if word.isdigit()] letters = [word for word in words if not word.isdigit()] return ' '.join(numbers + letters)"},{"question":"def create_webpage(languages_per_country: Dict[str, List[str]]) -> str: Creates an HTML formatted string displaying countries and their respective languages. >>> languages_per_country = { ... \\"USA\\": [\\"English\\", \\"Spanish\\"], ... \\"France\\": [\\"French\\"], ... \\"India\\": [\\"Hindi\\", \\"English\\", \\"Tamil\\"] ... } >>> create_webpage(languages_per_country) \\"<h2>France</h2>n<ul>n <li>French</li>n</ul>n<h2>India</h2>n<ul>n <li>English</li>n <li>Hindi></li>n <li>Tamil></li>n</ul>n<h2>USA</h2>n<ul>n <li>English</li>n <li>Spanish</li>n</ul>\\" pass def test_create_webpage_simple(): input_data = { \\"USA\\": [\\"English\\", \\"Spanish\\"], \\"France\\": [\\"French\\"], \\"India\\": [\\"Hindi\\", \\"English\\", \\"Tamil\\"] } expected_output = ( \\"<h2>France</h2>n<ul>n\\" \\" <li>French</li>n\\" \\"</ul>n\\" \\"<h2>India</h2>n<ul>n\\" \\" <li>English</li>n\\" \\" <li>Hindi</li>n\\" \\" <li>Tamil</li>n\\" \\"</ul>n\\" \\"<h2>USA</h2>n<ul>n\\" \\" <li>English</li>n\\" \\" <li>Spanish</li>n\\" \\"</ul>\\" ) assert create_webpage(input_data) == expected_output def test_create_webpage_single_language(): input_data = { \\"Germany\\": [\\"German\\"], \\"Spain\\": [\\"Spanish\\"] } expected_output = ( \\"<h2>Germany</h2>n<ul>n\\" \\" <li>German</li>n\\" \\"</ul>n\\" \\"<h2>Spain</h2>n<ul>n\\" \\" <li>Spanish</li>n\\" \\"</ul>\\" ) assert create_webpage(input_data) == expected_output def test_create_webpage_multiple_languages(): input_data = { \\"Canada\\": [\\"English\\", \\"French\\"], \\"Switzerland\\": [\\"German\\", \\"French\\", \\"Italian\\", \\"Romansh\\"] } expected_output = ( \\"<h2>Canada</h2>n<ul>n\\" \\" <li>English</li>n\\" \\" <li>French</li>n\\" \\"</ul>n\\" \\"<h2>Switzerland</h2>n<ul>n\\" \\" <li>French</li>n\\" \\" <li>German</li>n\\" \\" <li>Italian</li>n\\" \\" <li>Romansh</li>n\\" \\"</ul>\\" ) assert create_webpage(input_data) == expected_output","solution":"def create_webpage(languages_per_country): Creates an HTML formatted string displaying countries and their respective languages. :param languages_per_country: A dictionary with country names as keys and lists of languages as values :return: A string containing the HTML content # Sort the country names alphabetically sorted_countries = sorted(languages_per_country.keys()) # Initialize an empty list to hold parts of the HTML html_parts = [] # Iterate over sorted countries for country in sorted_countries: html_parts.append(f\\"<h2>{country}</h2>\\") html_parts.append(\\"<ul>\\") # Sort the languages for the current country alphabetically sorted_languages = sorted(languages_per_country[country]) for language in sorted_languages: html_parts.append(f\\" <li>{language}</li>\\") html_parts.append(\\"</ul>\\") # Join all parts into a single string with new lines return \\"n\\".join(html_parts)"},{"question":"from typing import List def count_hamming_groups(binaries: List[str]) -> int: Group the binary numbers based on their Hamming distance and return the number of groups formed. The Hamming distance is the number of positions at which the corresponding bits are different. Two binary numbers are considered to be in the same group if their Hamming distance is less than or equal to 2. >>> count_hamming_groups([\\"10100\\", \\"00100\\", \\"10110\\", \\"11100\\", \\"11011\\"]) 2 >>> count_hamming_groups([\\"000\\", \\"001\\", \\"011\\", \\"100\\"]) 1 >>> count_hamming_groups([\\"000\\", \\"111\\"]) 2 >>> count_hamming_groups([\\"10100\\"]) 1 >>> count_hamming_groups([]) 0 >>> count_hamming_groups([\\"111\\", \\"111\\", \\"111\\"]) 1","solution":"from typing import List def hamming_distance(str1: str, str2: str) -> int: Calculate the Hamming distance between two binary strings. return sum(c1 != c2 for c1, c2 in zip(str1, str2)) def count_hamming_groups(binaries: List[str]) -> int: Group the binary numbers based on their Hamming distance and return the number of groups formed. if not binaries: return 0 n = len(binaries) visited = [False] * n def dfs(index): Depth First Search to explore all binaries connected to the binary at \`index\`. stack = [index] while stack: i = stack.pop() for j in range(n): if not visited[j] and hamming_distance(binaries[i], binaries[j]) <= 2: visited[j] = True stack.append(j) group_count = 0 for i in range(n): if not visited[i]: visited[i] = True dfs(i) group_count += 1 return group_count"},{"question":"def sort_and_move_zeros(nums): Takes a list of integers and returns a list of those integers, sorted in ascending order, but with all the zeros moved to the end. >>> sort_and_move_zeros([0, 2, 3, 0, 1, 4]) [1, 2, 3, 4, 0, 0] >>> sort_and_move_zeros([3, 1, 2]) [1, 2, 3] >>> sort_and_move_zeros([0, 0, 0]) [0, 0, 0] >>> sort_and_move_zeros([]) [] >>> sort_and_move_zeros([0]) [0] >>> sort_and_move_zeros([5]) [5] >>> sort_and_move_zeros([1, 2, 3, 0, 0]) [1, 2, 3, 0, 0] >>> sort_and_move_zeros([4, 0, 3, 2, 0, 1]) [1, 2, 3, 4, 0, 0]","solution":"def sort_and_move_zeros(nums): Returns a list of integers sorted in ascending order, but with all zeros moved to the end. non_zeros = [x for x in nums if x != 0] zeros = [x for x in nums if x == 0] return sorted(non_zeros) + zeros"},{"question":"def merge_intervals(intervals): Merges all overlapping intervals. Parameters: intervals (List[List[int]]): List of intervals where each interval is represented as [start, end] Returns: List[List[int]]: Merged list of intervals ordered by their start times. # Implement the function to merge overlapping intervals def process_intervals(test_cases): Processes multiple test cases and merges intervals for each test case. Parameters: test_cases (List[List[List[int]]]): A list of test cases where each test case is a list of intervals Returns: List[List[List[int]]]: Merged intervals for each test case. # Implement the function to process multiple test cases # Test cases from solution import merge_intervals, process_intervals def test_merge_intervals_no_overlap(): intervals = [[1, 2], [3, 4], [5, 6]] expected = [[1, 2], [3, 4], [5, 6]] assert merge_intervals(intervals) == expected def test_merge_intervals_with_overlap(): intervals = [[1, 3], [2, 6], [8, 10]] expected = [[1, 6], [8, 10]] assert merge_intervals(intervals) == expected def test_merge_intervals_complex_overlap(): intervals = [[1, 4], [4, 5], [7, 10], [2, 8]] expected = [[1, 10]] assert merge_intervals(intervals) == expected def test_merge_intervals_single_interval(): intervals = [[1, 5]] expected = [[1, 5]] assert merge_intervals(intervals) == expected def test_process_intervals(): test_cases = [ [[1, 3], [2, 6], [8, 10]], [[1, 4], [4, 5], [7, 10], [2, 8]] ] expected = [[[1, 6], [8, 10]], [[1, 10]]] assert process_intervals(test_cases) == expected","solution":"def merge_intervals(intervals): Merges all overlapping intervals. Parameters: intervals (List[List[int]]): List of intervals where each interval is represented as [start, end] Returns: List[List[int]]: Merged list of intervals ordered by their start times. if not intervals: return [] # Sort the intervals by their start time. intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # Overlapping intervals, merge them last_merged[1] = max(last_merged[1], current[1]) else: # No overlap, add the current interval to merged list merged.append(current) return merged def process_intervals(test_cases): Processes multiple test cases and merges intervals for each test case. Parameters: test_cases (List[List[List[int]]]): A list of test cases where each test case is a list of intervals Returns: List[List[List[int]]]: Merged intervals for each test case. result = [] for intervals in test_cases: result.append(merge_intervals(intervals)) return result"},{"question":"import heapq from typing import List class PriorityQueue: A priority queue that supports addition and retrieval of k smallest and k largest elements. def __init__(self): self.elements = [] def add(self, x: int): Add an integer to the priority queue. :param x: Integer to add pass def getKsmallest(self, k: int) -> List[int]: Retrieve the k smallest elements from the priority queue. :param k: Number of smallest elements to retrieve :return: List of k smallest elements in non-decreasing order pass def getKlargest(self, k: int) -> List[int]: Retrieve the k largest elements from the priority queue. :param k: Number of largest elements to retrieve :return: List of k largest elements in non-increasing order pass def process_operations(operations: List[str]) -> List[str]: Process a list of operations on the priority queue. :param operations: A list of operations in the format described :return: A list of results for \\"getKsmallest\\" and \\"getKlargest\\" operations pq = PriorityQueue() results = [] for op in operations: if op.startswith(\\"add\\"): _, x = op.split() pq.add(int(x)) elif op.startswith(\\"getKsmallest\\"): _, k = op.split() result = ' '.join(map(str, pq.getKsmallest(int(k)))) results.append(result) elif op.startswith(\\"getKlargest\\"): _, k = op.split() result = ' '.join(map(str, pq.getKlargest(int(k)))) results.append(result) return results # Unit Tests def test_basic_operations(): operations = [ \\"add 3\\", \\"add 1\\", \\"add 4\\", \\"add 1\\", \\"add 5\\", \\"getKsmallest 2\\", \\"add 9\\", \\"add 2\\", \\"getKlargest 3\\", \\"getKsmallest 10\\", ] expected_output = [ \\"1 1\\", \\"9 5 4\\", \\"1 1 2 3 4 5 9\\" ] assert process_operations(operations) == expected_output def test_less_elements_than_requested(): operations = [ \\"add 1\\", \\"add 2\\", \\"getKsmallest 5\\", \\"getKlargest 5\\", ] expected_output = [ \\"1 2\\", \\"2 1\\", ] assert process_operations(operations) == expected_output def test_empty_queue(): operations = [ \\"getKsmallest 1\\", \\"getKlargest 1\\", ] expected_output = [ \\"\\", \\"\\", ] assert process_operations(operations) == expected_output def test_single_element_operations(): operations = [ \\"add 5\\", \\"getKsmallest 1\\", \\"getKlargest 1\\", ] expected_output = [ \\"5\\", \\"5\\", ] assert process_operations(operations) == expected_output def test_large_operations(): operations = [\\"add \\" + str(i) for i in range(1000)] # Add 0 to 999 operations.append(\\"getKsmallest 10\\") operations.append(\\"getKlargest 10\\") expected_output = [ \\"0 1 2 3 4 5 6 7 8 9\\", \\"999 998 997 996 995 994 993 992 991 990\\", ] assert process_operations(operations) == expected_output","solution":"import heapq class PriorityQueue: def __init__(self): self.elements = [] def add(self, x): heapq.heappush(self.elements, x) def getKsmallest(self, k): return heapq.nsmallest(k, self.elements) def getKlargest(self, k): return heapq.nlargest(k, self.elements) def process_operations(operations): pq = PriorityQueue() results = [] for op in operations: if op.startswith(\\"add\\"): _, x = op.split() pq.add(int(x)) elif op.startswith(\\"getKsmallest\\"): _, k = op.split() result = ' '.join(map(str, pq.getKsmallest(int(k)))) results.append(result) elif op.startswith(\\"getKlargest\\"): _, k = op.split() result = ' '.join(map(str, pq.getKlargest(int(k)))) results.append(result) return results"},{"question":"def closestPerfectNumber(N: int, D: int, X: int) -> int: Determine the smallest integer greater than or equal to N that contains the favorite digit at least X times. Parameters: N (int): Starting number (1 ≤ N ≤ 10^7) D (int): Favorite digit (0 ≤ D ≤ 9) X (int): Required occurrences (1 ≤ X ≤ 7) Returns: int: The smallest integer greater than or equal to N that contains the favorite digit at least X times. Examples: >>> closestPerfectNumber(100, 1, 2) 101 >>> closestPerfectNumber(500, 3, 1) 503 >>> closestPerfectNumber(700, 0, 3) 1000 >>> closestPerfectNumber(1, 0, 1) 10 >>> closestPerfectNumber(123, 7, 2) 177 >>> closestPerfectNumber(9999999, 9, 2) 9999999 >>> closestPerfectNumber(1, 1, 1) 1 >>> closestPerfectNumber(1, 9, 2) 99 pass","solution":"def closestPerfectNumber(N, D, X): Returns the smallest integer greater than or equal to N that contains the favorite digit D at least X times. while True: if str(N).count(str(D)) >= X: return N N += 1"},{"question":"from typing import List def word_break(s: str, word_dict: List[str]) -> List[str]: Given a string s and a dictionary of words dict, determine if s can be segmented into a sequence of one or more dictionary words. Return all such possible segmentations in any order. >>> word_break(\\"catsanddog\\", [\\"cat\\",\\"cats\\",\\"and\\",\\"sand\\",\\"dog\\"]) [\\"cats and dog\\",\\"cat sand dog\\"] >>> word_break(\\"pineapplepenapple\\", [\\"apple\\",\\"pen\\",\\"applepen\\",\\"pine\\",\\"pineapple\\"]) [\\"pine apple pen apple\\",\\"pineapple pen apple\\",\\"pine applepen apple\\"] >>> word_break(\\"catsandog\\", [\\"cats\\",\\"dog\\",\\"sand\\",\\"and\\",\\"cat\\"]) [] # Your code here # Unit tests def test_example_1(): s = \\"catsanddog\\" word_dict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] output = [\\"cats and dog\\", \\"cat sand dog\\"] result = word_break(s, word_dict) assert sorted(result) == sorted(output) def test_example_2(): s = \\"pineapplepenapple\\" word_dict = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] output = [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] result = word_break(s, word_dict) assert sorted(result) == sorted(output) def test_example_3(): s = \\"catsandog\\" word_dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] output = [] result = word_break(s, word_dict) assert result == output def test_empty_string(): s = \\"\\" word_dict = [\\"cat\\", \\"dog\\"] output = [\\"\\"] result = word_break(s, word_dict) assert result == output def test_no_possible_segmentations(): s = \\"abcdef\\" word_dict = [\\"ab\\", \\"cd\\", \\"efg\\"] output = [] result = word_break(s, word_dict) assert result == output def test_single_word_match(): s = \\"cat\\" word_dict = [\\"cat\\"] output = [\\"cat\\"] result = word_break(s, word_dict) assert result == output","solution":"def word_break_helper(s, word_dict, start, memo): if start in memo: return memo[start] if start == len(s): return [\\"\\"] segmentations = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_dict: subsequences = word_break_helper(s, word_dict, end, memo) for subsequence in subsequences: if subsequence: segmentations.append(word + \\" \\" + subsequence) else: segmentations.append(word) memo[start] = segmentations return segmentations def word_break(s, word_dict): return word_break_helper(s, set(word_dict), 0, {})"},{"question":"from typing import List def evaluate_expression(expression: str) -> str: Evaluate and simplify the mathematical expression containing fractions and basic arithmetic operations. Params: - expression (str): The mathematical expression as a string. Returns: - str: The simplified result in fraction form or \\"undefined\\" if there is a division by zero. >>> evaluate_expression(\\"3/4 + 2/3\\") \\"17/12\\" >>> evaluate_expression(\\"5/6 * 3/4\\") \\"5/8\\" >>> evaluate_expression(\\"1/2 + 3\\") \\"7/2\\" pass def main(input_lines: List[str]) -> List[str]: Process a list of mathematical expressions and return their simplified results. Params: - input_lines (List[str]): List of mathematical expression strings. Returns: - List[str]: List of simplified results for each expression. pass from solution import evaluate_expression, main def test_evaluate_expression(): assert evaluate_expression(\\"3/4 + 2/3\\") == \\"17/12\\" assert evaluate_expression(\\"5/6 * 3/4\\") == \\"5/8\\" assert evaluate_expression(\\"1/2 + 3\\") == \\"7/2\\" assert evaluate_expression(\\"1/2 / 0\\") == \\"undefined\\" assert evaluate_expression(\\"10/0\\") == \\"undefined\\" assert evaluate_expression(\\"3 - 3\\") == \\"0\\" assert evaluate_expression(\\"1/4 + 1/4\\") == \\"1/2\\" def test_main(): input_data = [ \\"3/4 + 2/3\\", \\"5/6 * 3/4\\", \\"1/2 + 3\\", \\"0\\" ] expected_output = [ \\"17/12\\", \\"5/8\\", \\"7/2\\" ] assert main(input_data) == expected_output input_data = [ \\"1/2 / 0\\", \\"10/0\\", \\"3 - 3\\", \\"1/4 + 1/4\\", \\"0\\" ] expected_output = [ \\"undefined\\", \\"undefined\\", \\"0\\", \\"1/2\\" ] assert main(input_data) == expected_output","solution":"from fractions import Fraction import re def evaluate_expression(expression): Evaluate and simplify the mathematical expression containing fractions and basic arithmetic operations. Params: - expression (str): The mathematical expression as a string. Returns: - str: The simplified result in fraction form or \\"undefined\\" if there is a division by zero. try: # Replace fractions with Fraction objects def replace_fraction(match): return f'Fraction({match.group(1)}, {match.group(2)})' expression = re.sub(r'(d+)/(d+)', replace_fraction, expression) # Use try-except to catch division by zero try: # Evaluate the expression result = eval(expression) # If result is a Fraction, convert it to string in its lowest terms if isinstance(result, Fraction): return str(result) else: return str(Fraction(result)) except ZeroDivisionError: return \\"undefined\\" except Exception as e: return \\"undefined\\" def main(input_lines): results = [] for line in input_lines: line = line.strip() if line == \\"0\\": break results.append(evaluate_expression(line)) return results"},{"question":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. >>> first_non_repeating_char(\\"swiss\\") == \\"w\\" >>> first_non_repeating_char(\\"reliable\\") == \\"r\\" >>> first_non_repeating_char(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_char(\\"123123456\\") == \\"4\\" >>> first_non_repeating_char(\\"aabbc\\") == \\"c\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"a\\") == \\"a\\" >>> first_non_repeating_char(\\"abcabc\\") == \\"\\" >>> first_non_repeating_char(\\"abacabad\\") == \\"c\\"","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. # Dictionary to store count of each character char_count = {} # Count each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character found return \\"\\""},{"question":"def intersection(nums1, nums2): Given two arrays, nums1 and nums2, both consisting of non-negative integers, find the intersection of the two arrays, which means the elements that appear in both arrays. The output should contain no duplicate elements and can be in any order. Example: >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def intersection(nums1, nums2): set_nums1 = set(nums1) set_nums2 = set(nums2) intersection_set = set_nums1 & set_nums2 return list(intersection_set)"},{"question":"from typing import List, Dict, Tuple class Commodity: def __init__(self, name: str, weight: float, fragility: str): self.name = name self.weight = weight self.fragility = fragility def group_commodities(commodities: List[Commodity]) -> Dict[str, List[Tuple[str, float]]]: Organizes the commodities into separate groups based on their fragility level and returns the details of each group in a dictionary. >>> commodities = [Commodity(\\"Vase\\", 2.5, \\"Fragile\\"), Commodity(\\"Book\\", 1.2, \\"Non-Fragile\\"), Commodity(\\"Mirror\\", 3.0, \\"Extremely Fragile\\"), Commodity(\\"Laptop\\", 1.5, \\"Fragile\\"), Commodity(\\"Chair\\", 5.0, \\"Non-Fragile\\")] >>> group_commodities(commodities) {\\"Fragile\\": [(\\"Vase\\", 2.5), (\\"Laptop\\", 1.5)], \\"Non-Fragile\\": [(\\"Book\\", 1.2), (\\"Chair\\", 5.0)], \\"Extremely Fragile\\": [(\\"Mirror\\", 3.0)]} >>> group_commodities([]) {\\"Fragile\\": [], \\"Non-Fragile\\": [], \\"Extremely Fragile\\": []} >>> commodities = [Commodity(\\"Statue\\", 3.4, \\"Fragile\\")] >>> group_commodities(commodities) {\\"Fragile\\": [(\\"Statue\\", 3.4)], \\"Non-Fragile\\": [], \\"Extremely Fragile\\": []} >>> commodities = [Commodity(\\"Painting\\", 2.1, \\"Fragile\\"), Commodity(\\"Glass\\", 0.8, \\"Extremely Fragile\\"), Commodity(\\"Cushion\\", 0.3, \\"Non-Fragile\\"), Commodity(\\"Plate\\", 0.5, \\"Extremely Fragile\\"), Commodity(\\"Sofa\\", 10.0, \\"Non-Fragile\\"), Commodity(\\"Phone\\", 1.1, \\"Fragile\\")] >>> group_commodities(commodities) {\\"Fragile\\": [(\\"Painting\\", 2.1), (\\"Phone\\", 1.1)], \\"Non-Fragile\\": [(\\"Cushion\\", 0.3), (\\"Sofa\\", 10.0)], \\"Extremely Fragile\\": [(\\"Glass\\", 0.8), (\\"Plate\\", 0.5)]}","solution":"from typing import List, Dict, Tuple class Commodity: def __init__(self, name: str, weight: float, fragility: str): self.name = name self.weight = weight self.fragility = fragility def group_commodities(commodities: List[Commodity]) -> Dict[str, List[Tuple[str, float]]]: result = { \\"Fragile\\": [], \\"Non-Fragile\\": [], \\"Extremely Fragile\\": [] } for commodity in commodities: if commodity.fragility in result: result[commodity.fragility].append((commodity.name, commodity.weight)) return result"},{"question":"class Room: The Room class models a system of interconnected rooms in a text-based adventure game. - Allows dynamic creation of rooms as the player moves. - Interconnects rooms in the appropriate directions. - Keeps track of room connections and player's current location. - Provides a \`move(direction)\` method which allows the player to move to a new room in the given direction or create a new room in that direction. - Maintains a record of all the rooms the player has visited. >>> Room.all_rooms = [] >>> current_room = Room() >>> next_room = current_room.move('north') >>> len(Room.all_rooms) 2 >>> next_room.exits['south'] == current_room True >>> same_room = current_room.move('north') >>> same_room == next_room True all_rooms = [] def __init__(self): self.exits = {'north': None, 'south': None, 'east': None, 'west': None} Room.all_rooms.append(self) def connect_rooms(self, direction, room): opposite = {'north': 'south', 'south': 'north', 'east': 'west', 'west': 'east'} if self.exits[direction] is None: self.exits[direction] = room room.exits[opposite[direction]] = self def move(self, direction): if direction in self.exits: if self.exits[direction] is None: new_room = Room() self.connect_rooms(direction, new_room) return self.exits[direction] else: raise ValueError(\\"Invalid direction\\")","solution":"class Room: all_rooms = [] def __init__(self): self.exits = {'north': None, 'south': None, 'east': None, 'west': None} Room.all_rooms.append(self) def connect_rooms(self, direction, room): opposite = {'north': 'south', 'south': 'north', 'east': 'west', 'west': 'east'} if self.exits[direction] is None: self.exits[direction] = room room.exits[opposite[direction]] = self def move(self, direction): if direction in self.exits: if self.exits[direction] is None: new_room = Room() self.connect_rooms(direction, new_room) return self.exits[direction] else: raise ValueError(\\"Invalid direction\\") # Instantiate rooms and navigate between them as per the described requirements. current_room = Room() # Starting room"},{"question":"def validate_operations(operations): Validates a sequence of operations for adherence to specific rules regarding open and close contexts. Args: operations (list of str): List of operation strings. Returns: bool: True if the sequence is valid, False otherwise. pass def test_valid_operations(): assert validate_operations([\\"open\\", \\"read\\", \\"write\\", \\"close\\"]) == True def test_invalid_out_of_context_operation(): assert validate_operations([\\"read\\", \\"open\\", \\"write\\", \\"close\\"]) == False def test_extra_close_operation(): assert validate_operations([\\"open\\", \\"read\\", \\"close\\", \\"close\\"]) == False def test_operations_without_closing_context(): assert validate_operations([\\"open\\", \\"read\\", \\"write\\"]) == False def test_nested_operations_valid(): assert validate_operations([\\"open\\", \\"open\\", \\"read\\", \\"close\\", \\"close\\"]) == True def test_nested_operations_invalid(): assert validate_operations([\\"open\\", \\"open\\", \\"read\\", \\"close\\"]) == False def test_single_open_invalid(): assert validate_operations([\\"open\\"]) == False def test_single_close_invalid(): assert validate_operations([\\"close\\"]) == False def test_empty_context_operations_valid(): assert validate_operations([\\"open\\", \\"close\\"]) == True def test_consecutive_operations_valid(): assert validate_operations([\\"open\\", \\"read\\", \\"close\\", \\"open\\", \\"write\\", \\"close\\"]) == True","solution":"def validate_operations(operations): Validates a sequence of operations for adherence to specific rules regarding open and close contexts. Args: operations (list of str): List of operation strings. Returns: bool: True if the sequence is valid, False otherwise. context_depth = 0 for operation in operations: if operation == \\"open\\": context_depth += 1 elif operation == \\"close\\": context_depth -= 1 if context_depth < 0: return False else: if context_depth == 0: return False return context_depth == 0"},{"question":"def categorize_elements(input_list): Categorizes elements in the input_list by their data types. Parameters: input_list (list): List of arbitrary elements. Returns: dict: Dictionary with keys as data types and values as lists of elements of that type. Examples: >>> categorize_elements([1, \\"a\\", 3.14, True, [\\"b\\", \\"c\\"], None, 2]) {int: [1, 2], str: [\\"a\\"], float: [3.14], bool: [True], list: [[\\"b\\", \\"c\\"]], type(None): [None]} >>> categorize_elements([\\"hello\\", 42, False, None, [1, 2, 3], 3.14]) {str: [\\"hello\\"], int: [42], bool: [False], type(None): [None], list: [[1, 2, 3]], float: [3.14]} >>> categorize_elements([]) {} >>> categorize_elements([1]) {int: [1]} >>> categorize_elements([1, 2, 3, 4, 5]) {int: [1, 2, 3, 4, 5]}","solution":"def categorize_elements(input_list): Categorizes elements in the input_list by their data types. Parameters: input_list (list): List of arbitrary elements. Returns: dict: Dictionary with keys as data types and values as lists of elements of that type. categorized_dict = {} for element in input_list: element_type = type(element) if element_type not in categorized_dict: categorized_dict[element_type] = [] categorized_dict[element_type].append(element) return categorized_dict"},{"question":"def min_max_subarray_sum(A: List[int], N: int, K: int) -> int: Split the array into K non-empty contiguous subarrays such that the sum of the maximum subarray sums is minimized. >>> min_max_subarray_sum([5, 3, 1, 2, 6, 8, 2], 7, 3) 10 >>> min_max_subarray_sum([1, 2, 3, 4, 5], 5, 2) 9 def process_test_cases(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple test cases and return the minimum possible value of the maximum subarray sum for each test case. >>> T = 1 >>> cases = [(7, 3, [5, 3, 1, 2, 6, 8, 2])] >>> process_test_cases(T, cases) [10] >>> T = 1 >>> cases = [(5, 2, [1, 2, 3, 4, 5])] >>> process_test_cases(T, cases) [9] >>> T = 1 >>> cases = [(1, 1, [123456789])] >>> process_test_cases(T, cases) [123456789] >>> T = 2 >>> cases = [(7, 3, [5, 3, 1, 2, 6, 8, 2]), (5, 2, [1, 2, 3, 4, 5])] >>> process_test_cases(T, cases) [10, 9] >>> T = 1 >>> cases = [(1, 1, [0])] >>> process_test_cases(T, cases) [0]","solution":"def min_max_subarray_sum(A, N, K): def can_split(mid): count = 1 current_sum = 0 for num in A: if current_sum + num <= mid: current_sum += num else: count += 1 current_sum = num if count > K: return False return True left, right = max(A), sum(A) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left def process_test_cases(T, cases): results = [] for case in cases: N, K, A = case results.append(min_max_subarray_sum(A, N, K)) return results"},{"question":"def rotate_matrix(matrix): Rotate the NxN matrix by 90 degrees clockwise in-place. Rotating the matrix involves first transposing the matrix and then reversing each row. :param matrix: List of lists where each inner list represents a row of the matrix. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] pass def print_matrix(matrix): Prints the NxN matrix to standard output. :param matrix: List of lists where each inner list represents a row of the matrix. Example: >>> matrix = [ ... [13, 9, 5, 1], ... [14, 10, 6, 2], ... [15, 11, 7, 3], ... [16, 12, 8, 4] ... ] >>> print_matrix(matrix) 13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 pass def test_rotate_matrix(): def test_small_matrix(): matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] rotate_matrix(matrix) assert matrix == expected_output def test_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_matrix(matrix) assert matrix == expected_output def test_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotate_matrix(matrix) assert matrix == expected_output def test_identity_matrix(): matrix = [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] expected_output = [ [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0] ] rotate_matrix(matrix) assert matrix == expected_output def test_single_element_matrix(): matrix = [ [1] ] expected_output = [ [1] ] rotate_matrix(matrix) assert matrix == expected_output test_small_matrix() test_3x3_matrix() test_4x4_matrix() test_identity_matrix() test_single_element_matrix()","solution":"def rotate_matrix(matrix): N = len(matrix) # Transpose the matrix for i in range(N): for j in range(i + 1, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(N): matrix[i].reverse() return matrix def print_matrix(matrix): for row in matrix: print(' '.join(map(str, row)))"},{"question":"from typing import List, Tuple def maximize_subarray_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Find a permutation of the array that maximizes the sum of the maximum and minimum element in each contiguous subarray of length \`3\`. >>> maximize_subarray_sum(2, [(3, [3, 1, 2]), (4, [1, 4, 3, 2])]) [[3, 1, 2], [4, 1, 3, 2]] from solution import maximize_subarray_sum def test_case1(): t = 2 test_cases = [ (3, [3, 1, 2]), (4, [1, 4, 3, 2]) ] expected = [ [3, 1, 2], [4, 1, 3, 2] ] assert maximize_subarray_sum(t, test_cases) == expected def test_case2(): t = 1 test_cases = [ (5, [5, 2, 1, 4, 3]) ] expected = [ [5, 1, 4, 2, 3] ] assert maximize_subarray_sum(t, test_cases) == expected def test_case3(): t = 2 test_cases = [ (3, [9, 7, 3]), (4, [2, 8, 6, 4]) ] expected = [ [9, 7, 3], [8, 2, 6, 4] ] assert maximize_subarray_sum(t, test_cases) == expected","solution":"def maximize_subarray_sum(t, test_cases): results = [] for case in test_cases: n = case[0] nums = case[1] if n == 3: # If there are only 3 elements, return them as the only permutation possible results.append(nums) else: # Sort the array to get max and min positions clearer nums.sort(reverse=True) result = [] # Follow the pattern max, min, max from sorted array to maximize results for i in range(n): if i % 2 == 0: result.append(nums[i//2]) else: result.append(nums[-(i//2 + 1)]) results.append(result) return results"},{"question":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even-valued terms in the Fibonacci sequence that are less than or equal to n. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(100) 44 pass # Implement the function here","solution":"def sum_even_fibonacci(n): Returns the sum of all even-valued terms in the Fibonacci sequence that are less than or equal to n. a, b = 0, 1 even_sum = 0 while a <= n: if a % 2 == 0: even_sum += a a, b = b, a + b return even_sum"},{"question":"def max_packages_delivered(n: int, k: int, packages: List[Tuple[int, int, int, int, int, int]]) -> int: Calculate the maximum number of packages that can be delivered within their respective time constraints. Parameters: n (int): Size of the city grid (n x n) k (int): Number of packages packages (List[Tuple[int, int, int, int, int, int]]): List of package details, each tuple contains six integers representing the pick-up time, pick-up coordinates, delivery time, and delivery coordinates. Returns: int: Maximum number of successfully delivered packages Example: >>> max_packages_delivered(5, 3, [(2, 1, 2, 10, 3, 3), (4, 5, 1, 16, 2, 4), (9, 2, 5, 20, 4, 4)]) 2 >>> max_packages_delivered(6, 5, [(1, 2, 3, 10, 6, 6), (3, 4, 1, 15, 2, 5), (7, 3, 4, 18, 1, 1), (9, 5, 5, 14, 2, 2), (12, 1, 6, 20, 5, 3)]) 3","solution":"def max_packages_delivered(n, k, packages): # Function to calculate Manhattan distance def manhattan(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) # Sort packages by pickup time (is already sorted as per problem statement) packages.sort() dp = [0] * (k + 1) # dp[i] represents the maximum packages delivered by picking up i-th package for i in range(1, k + 1): pi, px, py, di, dx, dy = packages[i - 1] j = i - 1 while j > 0: pj, qx, qy, qd, rx, ry = packages[j - 1] if pi >= pj + manhattan(rx, ry, px, py): dp[i] = max(dp[i], dp[j] + 1) break j -= 1 dp[i] = max(dp[i], dp[i - 1], 1) return max(dp)"},{"question":"def min_operations_to_equalize(n: int, sequence: List[int]) -> int: Determines the minimum number of operations needed to make all elements in the sequence equal. >>> min_operations_to_equalize(5, [1, 2, 1, 2, 1]) 3 >>> min_operations_to_equalize(3, [3, 3, 3]) 0 >>> min_operations_to_equalize(4, [5, 2, 5, 2]) 6","solution":"def min_operations_to_equalize(n, sequence): Determines the minimum number of operations needed to make all elements in the sequence equal. Parameters: n (int): Number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: int: The minimum number of operations needed to make all elements equal. max_element = max(sequence) min_operations = sum(max_element - x for x in sequence) return min_operations"},{"question":"def find_elements_appearing_twice(arr): This function finds all elements that appear exactly twice in the array. Args: arr: List of integers Returns: List of integers that appear exactly twice >>> find_elements_appearing_twice([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_elements_appearing_twice([1, 1, 2, 2, 3, 3]) [1, 2, 3] >>> find_elements_appearing_twice([1, 2, 3, 4, 5]) [-1] >>> find_elements_appearing_twice([1]) [-1] pass def process_test_cases(T, test_cases): Process multiple test cases to find elements appearing exactly twice. Args: T: Number of test cases test_cases: List containing each test case as a tuple of (N, arr) Returns: List of results for each test case >>> process_test_cases(2, [(6, [4, 3, 2, 7, 8, 2, 3, 1]), (5, [1, 1, 2, 2, 3, 3])]) [[2, 3], [1, 2, 3]] >>> process_test_cases(1, [(5, [1, 1, 2, 2, 3, 3])]) [[1, 2, 3]] >>> process_test_cases(1, [(5, [1, 2, 3, 4, 5])]) [[-1]] pass","solution":"def find_elements_appearing_twice(arr): This function finds all elements that appear exactly twice in the array. Args: arr: List of integers Returns: List of integers that appear exactly twice n = len(arr) result = [] # Traverse the array for i in range(n): # Use the value as the index (absolute value is required due to potential negative marking) index = abs(arr[i]) - 1 # If the value at that index is positive, negate it to mark it as visited if arr[index] > 0: arr[index] = -arr[index] else: # If it's already negative, it means this is the second occurrence result.append(abs(arr[i])) # Restore the original array values by making all elements positive for i in range(n): if arr[i] < 0: arr[i] = -arr[i] return result if result else [-1] def process_test_cases(T, test_cases): Process multiple test cases to find elements appearing exactly twice. Args: T: Number of test cases test_cases: List containing each test case as a tuple of (N, arr) Returns: List of results for each test case results = [] for i in range(T): N, arr = test_cases[i] result = find_elements_appearing_twice(arr) results.append(result) return results"},{"question":"def maximum_weight(T, test_cases): Returns the maximum weight Alice can carry for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers N and M Returns: list of int: Maximum weights for each test case >>> maximum_weight(4, [(3, 5), (7, 2), (10, 10), (0, 8)]) [105, 100, 250, 120] >>> maximum_weight(1, [(0, 0)]) [0] >>> maximum_weight(3, [(1, 1), (0, 10), (10, 0)]) [25, 150, 100] >>> maximum_weight(2, [(100, 0), (0, 100)]) [1000, 1500] >>> maximum_weight(2, [(0, 0), (50, 50)]) [0, 1250]","solution":"def maximum_weight(T, test_cases): Returns the maximum weight Alice can carry for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers N and M Returns: list of int: Maximum weights for each test case result = [] for N, M in test_cases: max_weight = (N * 10) + (M * 15) result.append(max_weight) return result"},{"question":"def transform_sequence(N: int, K: int, sequence: List[int]) -> List[int]: Transform the sequence based on the specified rule for K steps. Args: - N: length of the sequence (an integer). - K: number of steps to perform (an integer). - sequence: initial sequence (a list of integers). Returns: - A list representing the state of the sequence after K steps. >>> transform_sequence(5, 3, [1, 2, 3, 4, 5]) [4, 5, 6, 7, 8] >>> transform_sequence(4, 2, [4, 1, 3, 2]) [6, 3, 5, 4] >>> transform_sequence(1, 5, [7]) [12] >>> transform_sequence(3, 4, [2, 2, 2]) [6, 6, 6] >>> transform_sequence(5, 1000000000, [1, 2, 3, 4, 5]) [1000000001, 1000000002, 1000000003, 1000000004, 1000000005] >>> transform_sequence(3, 2, [-1, -2, -3]) [1, 0, -1]","solution":"def transform_sequence(N, K, sequence): Transforms the sequence based on the specified rule for K steps. Args: - N: length of the sequence (an integer). - K: number of steps to perform (an integer). - sequence: initial sequence (a list of integers). Returns: - A list representing the state of the sequence after K steps. # The problem can be simplified: every pair will increment one element by 1 per step. # Hence, every element will be incremented by K per the rule. return [x + K for x in sequence]"},{"question":"class Bank: A simple bank system that supports account creation, deposits, withdrawals, balance checking, and transfers. Example usage: >>> bank = Bank() >>> account_1 = bank.create_account() >>> account_2 = bank.create_account() >>> bank.deposit(account_1, 500) >>> bank.deposit(account_2, 300) >>> bank.check_balance(account_1) 500 >>> bank.check_balance(account_2) 300 >>> bank.transfer(account_1, account_2, 200) >>> bank.check_balance(account_1) 300 >>> bank.check_balance(account_2) 500 >>> bank.withdraw(account_2, 100) >>> bank.check_balance(account_2) 400 def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self): Creates a new account in the bank. Returns: int: The account number of the newly created account. pass def deposit(self, account_number, amount): Deposits a specified amount of money into the given account. Args: account_number (int): The account number to deposit into. amount (float): The amount of money to deposit. Raises: ValueError: If the account number is invalid or the amount is non-positive. pass def withdraw(self, account_number, amount): Withdraws a specified amount of money from the given account, provided there are sufficient funds. Args: account_number (int): The account number to withdraw from. amount (float): The amount of money to withdraw. Raises: ValueError: If the account number is invalid or the amount is non-positive. pass def check_balance(self, account_number): Checks the balance of the given account. Args: account_number (int): The account number to check the balance of. Returns: float: The current balance of the account. Raises: ValueError: If the account number is invalid. pass def transfer(self, from_account, to_account, amount): Transfers a specified amount of money from one account to another, provided there are sufficient funds in the sender's account. Args: from_account (int): The account number to transfer money from. to_account (int): The account number to transfer money to. amount (float): The amount of money to transfer. Raises: ValueError: If the account numbers are invalid or the amount is non-positive. pass","solution":"class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self): account_number = self.next_account_number self.accounts[account_number] = 0 self.next_account_number += 1 return account_number def deposit(self, account_number, amount): if account_number in self.accounts: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.accounts[account_number] += amount else: raise ValueError(\\"Invalid account number.\\") def withdraw(self, account_number, amount): if account_number in self.accounts: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.accounts[account_number] >= amount: self.accounts[account_number] -= amount else: print(\\"Insufficient funds.\\") else: raise ValueError(\\"Invalid account number.\\") def check_balance(self, account_number): if account_number in self.accounts: return self.accounts[account_number] else: raise ValueError(\\"Invalid account number.\\") def transfer(self, from_account, to_account, amount): if from_account in self.accounts and to_account in self.accounts: if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount else: print(\\"Insufficient funds.\\") else: raise ValueError(\\"Invalid account number.\\")"},{"question":"def fibonacci(N: int) -> int: Returns the N'th term of the Fibonacci series. >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(1) 1 >>> fibonacci(0) 0 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(50) 12586269025","solution":"def fibonacci(N): Returns the N'th term of the Fibonacci series. if N == 0: return 0 elif N == 1: return 1 a, b = 0, 1 for _ in range(2, N+1): a, b = b, a + b return b"},{"question":"from typing import List, Tuple def will_collide(path1: Tuple[int, int, int, int], path2: Tuple[int, int, int, int]) -> bool: Determines if two paths will collide. Args: path1 (tuple): The start and end coordinates of the first path. path2 (tuple): The start and end coordinates of the second path. Returns: bool: True if the paths collide, False otherwise. pass def count_non_colliding_pairs(test_cases: List[Tuple[int, List[Tuple[int, int, int, int]]]]) -> List[int]: Count the number of non-colliding pairs of robots for each test case. Args: test_cases (list): A list of test cases, where each test case contains an integer and a list of tuples representing paths. Returns: list: A list of integers representing the number of non-colliding pairs for each test case. pass def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): R = int(data[idx]) idx += 1 paths = [] for _ in range(R): x_start, y_start, x_end, y_end = map(int, data[idx:idx + 4]) paths.append((x_start, y_start, x_end, y_end)) idx += 4 test_cases.append((R, paths)) results = count_non_colliding_pairs(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def will_collide(path1, path2): Determines if two paths will collide. # Unpack the points x1_start, y1_start, x1_end, y1_end = path1 x2_start, y2_start, x2_end, y2_end = path2 # Generate all points in path 1 points1 = set() if x1_start == x1_end: # Vertical line for y in range(min(y1_start, y1_end), max(y1_start, y1_end) + 1): points1.add((x1_start, y)) else: # Horizontal line for x in range(min(x1_start, x1_end), max(x1_start, x1_end) + 1): points1.add((x, y1_start)) # Generate all points in path 2 points2 = set() if x2_start == x2_end: # Vertical line for y in range(min(y2_start, y2_end), max(y2_start, y2_end) + 1): points2.add((x2_start, y)) else: # Horizontal line for x in range(min(x2_start, x2_end), max(x2_start, x2_end) + 1): points2.add((x, y2_start)) # Check for intersection return len(points1 & points2) > 0 def count_non_colliding_pairs(test_cases): results = [] for case in test_cases: R, paths = case non_colliding_pairs = 0 for i in range(R): for j in range(i + 1, R): if not will_collide(paths[i], paths[j]): non_colliding_pairs += 1 results.append(non_colliding_pairs) return results # Main function to read input and output results def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): R = int(data[idx]) idx += 1 paths = [] for _ in range(R): x_start, y_start, x_end, y_end = map(int, data[idx:idx + 4]) paths.append((x_start, y_start, x_end, y_end)) idx += 4 test_cases.append((R, paths)) results = count_non_colliding_pairs(test_cases) for result in results: print(result)"},{"question":"def min_moves_to_uniform_string(s: str) -> int: Given a string consisting of lowercase letters, determine the minimum number of moves needed to make all characters in the string the same. In one move, you can choose any character and change it to any other lowercase letter. Parameters: s (str): The input string consisting of lowercase letters. Returns: int: The minimum number of moves needed to make all characters in the string the same. Example: >>> min_moves_to_uniform_string(\\"abac\\") 2 >>> min_moves_to_uniform_string(\\"aaaa\\") 0 >>> min_moves_to_uniform_string(\\"abcde\\") 4","solution":"def min_moves_to_uniform_string(s): Given a string consisting of lowercase letters, determine the minimum number of moves needed to make all characters in the string the same. In one move, you can choose any character and change it to any other lowercase letter. Parameters: s (str): The input string consisting of lowercase letters. Returns: int: The minimum number of moves needed to make all characters in the string the same. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the maximum frequency of any character max_freq = max(char_count.values()) # The minimum number of moves needed to make all characters the same return len(s) - max_freq"},{"question":"def is_possible_to_make_identical(N: int, sequence: List[int]) -> str: Function to determine if the sequence can be transformed into identical elements using the allowed operation. >>> is_possible_to_make_identical(3, [4, 8, 12]) \\"YES\\" >>> is_possible_to_make_identical(4, [1, 2, 3, 5]) \\"NO\\" Unit Test: from solution import is_possible_to_make_identical def test_case_1(): assert is_possible_to_make_identical(3, [4, 8, 12]) == \\"YES\\" def test_case_2(): assert is_possible_to_make_identical(4, [1, 2, 3, 5]) == \\"NO\\" def test_case_3(): assert is_possible_to_make_identical(2, [5, 10]) == \\"YES\\" def test_case_4(): assert is_possible_to_make_identical(5, [1, 3, 9, 12, 15]) == \\"NO\\" def test_case_5(): assert is_possible_to_make_identical(4, [36, 72, 108, 144]) == \\"YES\\" def test_case_6(): assert is_possible_to_make_identical(3, [2, 3, 6]) == \\"NO\\" def test_case_7(): assert is_possible_to_make_identical(5, [0, 0, 0, 0, 0]) == \\"YES\\" def test_case_8(): assert is_possible_to_make_identical(4, [24, 36, 96, 108]) == \\"YES\\"","solution":"def is_possible_to_make_identical(N, sequence): Function to determine if the sequence can be transformed into identical elements. # GCD function def gcd(a, b): while b: a, b = b, a % b return a # Calculate GCD for the entire list result = sequence[0] for num in sequence: result = gcd(result, num) if result == 1: return \\"NO\\" return \\"YES\\""},{"question":"def longest_arithmetic_subarray(nums: List[int]) -> int: Given an integer array nums, return the length of the longest arithmetic subarray. An arithmetic subarray is a subarray that contains at least two elements and the difference between consecutive elements is the same. >>> longest_arithmetic_subarray([3, 6, 9, 12]) 4 >>> longest_arithmetic_subarray([1, 2, 2, 5, 7, 8, 8, 9]) 2 >>> longest_arithmetic_subarray([1, 3, 5, 7, 9, 11, 13]) 7 >>> longest_arithmetic_subarray([10, 0, 20, 30, 40, 50]) 4 >>> longest_arithmetic_subarray([5, 7, 11, 13, 17, 19, 20]) 2 from typing import List def test_example_1(): assert longest_arithmetic_subarray([3, 6, 9, 12]) == 4 def test_example_2(): assert longest_arithmetic_subarray([1, 2, 2, 5, 7, 8, 8, 9]) == 2 def test_example_3(): assert longest_arithmetic_subarray([1, 3, 5, 7, 9, 11, 13]) == 7 def test_example_4(): assert longest_arithmetic_subarray([10, 0, 20, 30, 40, 50]) == 4 def test_example_5(): assert longest_arithmetic_subarray([5, 7, 11, 13, 17, 19, 20]) == 2 def test_single_element_array(): assert longest_arithmetic_subarray([1]) == 0 def test_two_element_array(): assert longest_arithmetic_subarray([1, 2]) == 2 def test_large_array(): nums = list(range(1, 10001)) assert longest_arithmetic_subarray(nums) == 10000 def test_no_subarray(): assert longest_arithmetic_subarray([-1, 2, -3, 4, -5, 6, -7, 8, -9]) == 2","solution":"def longest_arithmetic_subarray(nums): if len(nums) < 2: return 0 longest_length = 2 current_length = 2 common_difference = nums[1] - nums[0] for i in range(2, len(nums)): current_difference = nums[i] - nums[i - 1] if current_difference == common_difference: current_length += 1 else: common_difference = current_difference current_length = 2 longest_length = max(longest_length, current_length) return longest_length"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a given number n is prime. def all_1_or_prime(lst: List[int]) -> bool: Determines whether every element in the list is either 1 or a prime number. >>> all_1_or_prime([1, 2, 3, 5, 7]) True >>> all_1_or_prime([1, 2, 3, 4]) False","solution":"def is_prime(n): Helper function to determine if a given number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def all_1_or_prime(lst): Determines whether every element in the list is either 1 or a prime number. for num in lst: if num != 1 and not is_prime(num): return False return True"},{"question":"def sum_of_min_values(grid: List[List[int]]) -> str: Given a grid of size N x M filled with integers, find the sum of the minimum values from each row, and then determine if this sum is even or odd. >>> sum_of_min_values([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 'Even' >>> sum_of_min_values([ ... [-1, -2], ... [-3, -4] ... ]) 'Even' from typing import List def test_sum_of_min_values(): # Test case 1 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert sum_of_min_values(grid) == \\"Even\\" # Test case 2 grid = [ [-1, -2], [-3, -4] ] assert sum_of_min_values(grid) == \\"Even\\" # Test case 3 grid = [ [2, 2, 3], [4, 5, 6], [7, 8, 11] ] assert sum_of_min_values(grid) == \\"Odd\\" # Test case 4 grid = [ [1000000000, 2, 3], [4, -1000000000, 6], [7, 8, -1000000000] ] assert sum_of_min_values(grid) == \\"Even\\" # Test case 5 grid = [ [11, 22, 33], [4, 55, -66], [7, -8, 9] ] assert sum_of_min_values(grid) == \\"Odd\\" # Test case 6: smallest grid possible grid = [[1]] assert sum_of_min_values(grid) == \\"Odd\\" grid = [[2]] assert sum_of_min_values(grid) == \\"Even\\" # Test case 7: grid with all identical numbers grid = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert sum_of_min_values(grid) == \\"Odd\\" # Test case 8: negative numbers grid = [ [-5, -1, -3], [-2, -3, -4], [-1, -6, -2] ] assert sum_of_min_values(grid) == \\"Odd\\"","solution":"def sum_of_min_values(grid): Given a grid of size N x M filled with integers, find the sum of the minimum values from each row, and then determine if this sum is even or odd. Args: grid (List[List[int]]): The grid of integers. Returns: str: \\"Even\\" if the sum of the minimum values is even, \\"Odd\\" if it is odd. sum_of_mins = sum(min(row) for row in grid) return \\"Even\\" if sum_of_mins % 2 == 0 else \\"Odd\\""},{"question":"class Library: A class used to represent a Library catalog system that allows operations to: 1. Record a new book with its genre. 2. Query all book IDs belonging to a specific genre. 3. Query the genre of a specific book ID. def __init__(self): pass def add_book(self, book_id: int, genre: str): Add a book with the given identifier and genre to the library. Args: book_id (int): The book's identifier. genre (str): The book's genre. pass def get_genre(self, book_id: int) -> str: Query the genre of the book with the specified identifier. Args: book_id (int): The book's identifier. Returns: str: The genre of the book. pass def get_books_by_genre(self, genre: str) -> list: Query the list of all book identifiers that belong to the specified genre. Args: genre (str): The genre to query. Returns: list: The list of book identifiers in ascending order. pass import pytest def test_add_and_get_genre(): library = Library() library.add_book(101, \\"fiction\\") library.add_book(102, \\"science\\") assert library.get_genre(101) == \\"fiction\\" assert library.get_genre(102) == \\"science\\" def test_get_books_by_genre(): library = Library() library.add_book(101, \\"fiction\\") library.add_book(103, \\"fiction\\") library.add_book(104, \\"math\\") library.add_book(105, \\"fiction\\") assert library.get_books_by_genre(\\"fiction\\") == [101, 103, 105] assert library.get_books_by_genre(\\"math\\") == [104] def test_adding_books_orders_ids(): library = Library() library.add_book(103, \\"fiction\\") library.add_book(101, \\"fiction\\") library.add_book(104, \\"fiction\\") assert library.get_books_by_genre(\\"fiction\\") == [101, 103, 104]","solution":"class Library: def __init__(self): self.book_genre_map = {} self.genre_books_map = {} def add_book(self, book_id, genre): self.book_genre_map[book_id] = genre if genre not in self.genre_books_map: self.genre_books_map[genre] = [] self.genre_books_map[genre].append(book_id) self.genre_books_map[genre].sort() def get_genre(self, book_id): return self.book_genre_map.get(book_id, '') def get_books_by_genre(self, genre): return self.genre_books_map.get(genre, [])"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string as input and returns the length of the longest substring with no repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"\\") 0","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List, Tuple def find_farthest(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine who ends up farther from the starting point, or if both are at the same distance. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer N (number of movements) and a list of integers representing the movements on the number line. Returns: List[str]: For each test case, returns \\"LAURA\\" if Laura ends up farther, \\"MARK\\" if Mark ends up farther, and \\"EQUAL\\" if both are the same distance from the starting point. Example: >>> find_farthest(1, [(5, [1, -2, 3, -1, 2])]) [\\"EQUAL\\"] >>> find_farthest(1, [(4, [2, -1, -1, 2])]) [\\"EQUAL\\"] >>> find_farthest(1, [(6, [3, -3, 2, -2, 1, -1])]) [\\"EQUAL\\"]","solution":"def find_farthest(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] movements = test_cases[i][1] laura_position = sum(movements) mark_position = sum(movements[::-1]) if abs(laura_position) > abs(mark_position): results.append(\\"LAURA\\") elif abs(laura_position) < abs(mark_position): results.append(\\"MARK\\") else: results.append(\\"EQUAL\\") return results # Example usage T = 3 test_cases = [ (5, [1, -2, 3, -1, 2]), (4, [2, -1, -1, 2]), (6, [3, -3, 2, -2, 1, -1]) ] print(find_farthest(T, test_cases)) # Output should be [\\"EQUAL\\", \\"EQUAL\\", \\"EQUAL\\"] # Note: The reasoning in the explanation provided for the sample input seems incorrect as reversing # the movements doesn't change the final position; both will end up at the same place. # Correcting it with this assumption."},{"question":"def max_projects(N, B, budgets): Returns the maximum number of projects that can be fully funded without exceeding the total budget. :param int N: The number of projects. :param int B: The total budget of the company. :param list budgets: The list of project budgets. :return: The maximum number of projects that can be fully funded. :rtype: int >>> max_projects(5, 50, [10, 20, 30, 40, 50]) 2 >>> max_projects(3, 60, [25, 20, 15]) 3","solution":"def max_projects(N, B, budgets): Returns the maximum number of projects that can be fully funded without exceeding the total budget. :param int N: The number of projects. :param int B: The total budget of the company. :param list budgets: The list of project budgets. :return: The maximum number of projects that can be fully funded. :rtype: int # Sort the budgets in ascending order budgets.sort() # Initialize the count of projects and the running total of spent budget count = 0 total_spent = 0 # Iterate through the sorted budgets for budget in budgets: if total_spent + budget <= B: total_spent += budget count += 1 else: break return count"},{"question":"from typing import List, Tuple def top_selling_books(books: List[Tuple[str, str, int]], genre: str, K: int) -> List[str]: Returns the titles of the top K best-selling books in a given genre. >>> books = [ ... (\\"Book A\\", \\"Fiction\\", 150), ... (\\"Book B\\", \\"Non-Fiction\\", 200), ... (\\"Book C\\", \\"Fiction\\", 100), ... (\\"Book D\\", \\"Fiction\\", 300), ... (\\"Book E\\", \\"History\\", 250), ... (\\"Book F\\", \\"Fiction\\", 80) ... ] >>> top_selling_books(books, \\"Fiction\\", 2) [\\"Book D\\", \\"Book A\\"] >>> top_selling_books(books, \\"Science\\", 1) []","solution":"def top_selling_books(books, genre, K): Returns the titles of the top K best-selling books in a given genre. # Filter the books by the given genre genre_books = [book for book in books if book[1] == genre] # Sort the filtered books by the number of copies sold in descending order sorted_books = sorted(genre_books, key=lambda x: x[2], reverse=True) # Extract the titles of the top K books top_k_titles = [book[0] for book in sorted_books[:K]] return top_k_titles"},{"question":"def luhn_check(card_number: str) -> str: Validate a credit card number using the Luhn algorithm. Args: card_number (str): The credit card number as a string. Returns: str: \\"Valid\\" if the card number is valid according to the Luhn algorithm, \\"Invalid\\" otherwise. >>> luhn_check(\\"4532015112830366\\") \\"Valid\\" >>> luhn_check(\\"6011514433546201\\") \\"Valid\\" >>> luhn_check(\\"4532015112830367\\") \\"Invalid\\" >>> luhn_check(\\"6011514433546209\\") \\"Invalid\\"","solution":"def luhn_check(card_number): Validate a credit card number using the Luhn algorithm. Args: card_number (str): The credit card number as a string. Returns: str: \\"Valid\\" if the card number is valid according to the Luhn algorithm, \\"Invalid\\" otherwise. def digits_of(n): return [int(d) for d in str(n)] digits = digits_of(card_number) checksum = 0 # Process the digits from the rightmost side, but skip the last digit initially for i in range(len(digits) - 1): if i % 2 == 0: # Doubling every second digit from the right where i starts from 0 (actually the second-to-last digit) doubled = digits[-2-i] * 2 if doubled > 9: doubled -= 9 checksum += doubled else: # Add digits which were not doubled checksum += digits[-2-i] checksum += digits[-1] # Add the check digit # Check if the total is a multiple of 10 if checksum % 10 == 0: return \\"Valid\\" else: return \\"Invalid\\""},{"question":"def extract_and_concatenate_substrings(s: str) -> str: Extracts and concatenates all substrings from the given string while removing any duplicates. The extracted substrings maintain their order of first appearance. >>> extract_and_concatenate_substrings(\\"[abc][def][ghi][abc][ghi]\\") == \\"abcdefghi\\" >>> extract_and_concatenate_substrings(\\"[abc][abc][abc]\\") == \\"abc\\" >>> extract_and_concatenate_substrings(\\"[abc][][def]\\") == \\"abcdef\\" >>> extract_and_concatenate_substrings(\\"[a][abcd][ab][abcd]\\") == \\"aabcdab\\"","solution":"def extract_and_concatenate_substrings(s): Extracts and concatenates all substrings from the given string while removing any duplicates. The extracted substrings maintain their order of first appearance. seen = set() result = [] n = len(s) i = 0 while i < n: if s[i] == '[': j = i + 1 while j < n and s[j] != ']': j += 1 substring = s[i+1:j] if substring not in seen: seen.add(substring) result.append(substring) i = j i += 1 return ''.join(result)"},{"question":"from typing import List def max_profit(n: int, r: int, values: List[int], risks: List[List[int]]) -> int: Determine the maximum profit Alyssa can achieve without exceeding the given risk threshold. Args: - n (int): number of treasure locations - r (int): risk threshold - values (List[int]): list of values for each treasure - risks (List[List[int]]): matrix of risks between each pair of treasures Returns: - int: maximum profit achievable within the risk threshold Examples: >>> n, r = 4, 5 >>> values = [8, 15, 20, 30] >>> risks = [ >>> [0, 1, 2, 3], >>> [1, 0, 4, 2], >>> [2, 4, 0, 1], >>> [3, 2, 1, 0] >>> ] >>> max_profit(n, r, values, risks) 50 >>> n, r = 3, 2 >>> values = [10, 20, 30] >>> risks = [ >>> [0, 2, 3], >>> [2, 0, 1], >>> [3, 1, 0] >>> ] >>> max_profit(n, r, values, risks) 50 pass import pytest def test_example_1(): n = 4 r = 5 values = [8, 15, 20, 30] risks = [ [0, 1, 2, 3], [1, 0, 4, 2], [2, 4, 0, 1], [3, 2, 1, 0] ] assert max_profit(n, r, values, risks) == 50 def test_example_2(): n = 3 r = 2 values = [10, 20, 30] risks = [ [0, 2, 3], [2, 0, 1], [3, 1, 0] ] assert max_profit(n, r, values, risks) == 50 def test_low_risk_allows_all_treasures(): n = 3 r = 6 values = [5, 10, 15] risks = [ [0, 1, 2], [1, 0, 3], [2, 3, 0] ] assert max_profit(n, r, values, risks) == 30 def test_single_allowed_pair(): n = 3 r = 1 values = [10, 20, 30] risks = [ [0, 1, 2], [1, 0, 1], [2, 1, 0] ] assert max_profit(n, r, values, risks) == 50 def test_no_combinations_within_risk(): n = 3 r = 0 values = [10, 20, 30] risks = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert max_profit(n, r, values, risks) == 0","solution":"from itertools import combinations def max_profit(n, r, values, risks): max_prof = 0 # Check all combinations of 2 to n treasures for k in range(2, n + 1): for combo in combinations(range(n), k): total_risk = sum(risks[i][j] for i in combo for j in combo if i != j) // 2 if total_risk <= r: total_profit = sum(values[i] for i in combo) max_prof = max(max_prof, total_profit) return max_prof n = 4 r = 5 values = [8, 15, 20, 30] risks = [ [0, 1, 2, 3], [1, 0, 4, 2], [2, 4, 0, 1], [3, 2, 1, 0] ] print(max_profit(n, r, values, risks)) # Expected output: 50"},{"question":"def get_primes(N): Returns a list of prime numbers from 1 to N. >>> get_primes(10) [2, 3, 5, 7] >>> get_primes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def get_primes(N): Returns a list of prime numbers from 1 to N. if N < 2: return [] primes = [] is_prime = [True] * (N + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for p in range(2, N + 1): if is_prime[p]: primes.append(p) for multiple in range(p * p, N + 1, p): is_prime[multiple] = False return primes"},{"question":"def is_same_start_end_character(s: str) -> bool: Determines whether a given string starts and ends with the same character, ignoring case. >>> is_same_start_end_character(\\"Level\\") == True >>> is_same_start_end_character(\\"Zebra\\") == False >>> is_same_start_end_character(\\"aPplea\\") == True >>> is_same_start_end_character(\\"dRhD\\") == True >>> is_same_start_end_character(\\"x\\") == True","solution":"def is_same_start_end_character(s: str) -> bool: Determines whether a given string starts and ends with the same character, ignoring case. if len(s) < 1: return False # Convert both the first and last characters to lowercase start_char = s[0].lower() end_char = s[-1].lower() return start_char == end_char"},{"question":"def max_coins(n: int, coins: List[int]) -> int: You have a sequence of boxes, each with a certain number of gold coins. You can pick boxes to maximize the total number of coins collected under the following restriction: If you pick a box, you cannot pick two adjacent boxes. Parameters: n (int): The number of boxes. coins (List[int]): List of integers where each integer represents the number of gold coins in each box. Returns: int: The maximum number of gold coins you can collect without picking any two adjacent boxes. Examples: >>> max_coins(5, [3, 2, 5, 10, 7]) 15 >>> max_coins(4, [3, 2, 7, 10]) 13 from typing import List def test_single_box(): assert max_coins(1, [10]) == 10 def test_two_boxes(): assert max_coins(2, [10, 5]) == 10 def test_multiple_boxes(): assert max_coins(5, [3, 2, 5, 10, 7]) == 15 assert max_coins(4, [3, 2, 7, 10]) == 13 assert max_coins(6, [5, 1, 1, 5, 1, 5]) == 15 def test_no_boxes(): assert max_coins(0, []) == 0 def test_alternate_picking(): assert max_coins(5, [10, 1, 1, 10, 1]) == 20 def test_all_same_values(): assert max_coins(5, [5, 5, 5, 5, 5]) == 15 def test_zero_coins(): assert max_coins(5, [0, 0, 0, 0, 0]) == 0","solution":"def max_coins(n, coins): Given a list of boxes and the coins in each box, returns the maximum number of coins that can be collected without picking two adjacent boxes. :param n: int -- the number of boxes :param coins: List[int] -- the number of coins in each box :return: int -- the maximum number of coins that can be collected if n == 0: return 0 if n == 1: return coins[0] # dp[i] will store the maximum number of coins that can be collected from the first i boxes dp = [0] * n dp[0] = coins[0] dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + coins[i]) return dp[n-1]"},{"question":"def top_student(students): Returns the name of the student with the highest average score. Args: students (list): A list of dictionaries containing student names and their scores. Returns: str: The name of the student with the highest average score. In case of a tie, the name that comes first alphabetically. # Your code here # Unit tests def test_top_student_single_student(): assert top_student([{\\"name\\": \\"Alice\\", \\"mathematics\\": 85, \\"science\\": 90, \\"english\\": 88}]) == \\"Alice\\" def test_top_student_tie_average(): assert top_student([ {\\"name\\": \\"Alice\\", \\"mathematics\\": 85, \\"science\\": 90, \\"english\\": 88}, {\\"name\\": \\"Bob\\", \\"mathematics\\": 85, \\"science\\": 90, \\"english\\": 88} ]) == \\"Alice\\" def test_top_student_different_averages(): assert top_student([ {\\"name\\": \\"Alice\\", \\"mathematics\\": 85, \\"science\\": 90, \\"english\\": 88}, {\\"name\\": \\"Bob\\", \\"mathematics\\": 90, \\"science\\": 88, \\"english\\": 85}, {\\"name\\": \\"Charlie\\", \\"mathematics\\": 85, \\"science\\": 85, \\"english\\": 85} ]) == \\"Alice\\" def test_top_student_complex_case(): assert top_student([ {\\"name\\": \\"Alice\\", \\"mathematics\\": 90, \\"science\\": 90, \\"english\\": 90}, {\\"name\\": \\"Bob\\", \\"mathematics\\": 100, \\"science\\": 80, \\"english\\": 80}, {\\"name\\": \\"Charlie\\", \\"mathematics\\": 90, \\"science\\": 90, \\"english\\": 90} ]) == \\"Alice\\" def test_top_student_different_number_of_students(): assert top_student([ {\\"name\\": \\"Alice\\", \\"mathematics\\": 50, \\"science\\": 60, \\"english\\": 70}, {\\"name\\": \\"Bob\\", \\"mathematics\\": 55, \\"science\\": 65, \\"english\\": 75}, {\\"name\\": \\"Charlie\\", \\"mathematics\\": 60, \\"science\\": 70, \\"english\\": 80}, {\\"name\\": \\"David\\", \\"mathematics\\": 55, \\"science\\": 65, \\"english\\": 75}, {\\"name\\": \\"Eve\\", \\"mathematics\\": 65, \\"science\\": 75, \\"english\\": 85} ]) == \\"Eve\\"","solution":"def top_student(students): Returns the name of the student with the highest average score. Args: students (list): A list of dictionaries containing student names and their scores. Returns: str: The name of the student with the highest average score. In case of a tie, the name that comes first alphabetically. max_average = -1 top_student_name = \\"\\" for student in students: average_score = (student['mathematics'] + student['science'] + student['english']) / 3 if average_score > max_average or (average_score == max_average and student['name'] < top_student_name): max_average = average_score top_student_name = student['name'] return top_student_name"},{"question":"def consecutive_targets_hit(t: int, cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the maximum number of consecutive targets Alexandra can hit starting from the given value \`k\`. >>> consecutive_targets_hit(3, [(5, [1, 2, 3, 4, 5], 1), (6, [3, 4, 5, 6, 7, 8], 4), (4, [10, 11, 12, 13], 9)]) [5, 5, 0] >>> consecutive_targets_hit(1, [(5, [1, 3, 5, 7, 9], 2)]) [0]","solution":"def consecutive_targets_hit(t, cases): results = [] for i in range(t): n = cases[i][0] A = cases[i][1] k = cases[i][2] # Convert A to a set for fast lookup target_set = set(A) # Initialize the number of hits hits = 0 # Start hitting from the given k while k in target_set: hits += 1 k += 1 # Append the result for this test case results.append(hits) return results"},{"question":"def length_of_longest_word(s: str) -> int: Returns the length of the longest word in the string s. >>> length_of_longest_word('the quick brown fox jumps over the lazy dog') == 5 >>> length_of_longest_word(' ') == 0 >>> length_of_longest_word('hello') == 5","solution":"def length_of_longest_word(s): Returns the length of the longest word in the string s. if not s.strip(): return 0 words = s.split() longest_word_length = max(len(word) for word in words) return longest_word_length"},{"question":"from typing import List from collections import Counter def can_transform(s1: str, s2: str) -> str: Determines if you can transform s1 into s2 using swap operations among adjacent characters. >>> can_transform(\\"abccba\\", \\"baccab\\") \\"Yes\\" >>> can_transform(\\"abc\\", \\"bbc\\") \\"No\\"","solution":"def can_transform(s1, s2): Determines if you can transform s1 into s2 using swap operations among adjacent characters. from collections import Counter # Count the frequency of characters in both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Compare character frequencies if counter_s1 == counter_s2: return \\"Yes\\" else: return \\"No\\""},{"question":"def forming_magic_square(s: List[List[int]]) -> int: Given a 3x3 grid, compute the minimum cost required to convert it into a magic square. The cost is defined as the absolute difference between the original and the new values of the changed elements. >>> forming_magic_square([[4, 9, 2], [3, 5, 7], [8, 1, 6]]) 0 >>> forming_magic_square([[4, 8, 2], [3, 5, 7], [8, 1, 6]]) 1 >>> forming_magic_square([[5, 3, 4], [1, 5, 8], [6, 4, 2]]) 7 >>> forming_magic_square([[4, 5, 8], [2, 4, 1], [1, 9, 7]]) 14 >>> forming_magic_square([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 36 def test_forming_magic_square_no_change(): s = [ [4, 9, 2], [3, 5, 7], [8, 1, 6] ] assert forming_magic_square(s) == 0 def test_forming_magic_square_one_change(): s = [ [4, 8, 2], [3, 5, 7], [8, 1, 6] ] assert forming_magic_square(s) == 1 def test_forming_magic_square_multiple_changes(): s = [ [5, 3, 4], [1, 5, 8], [6, 4, 2] ] assert forming_magic_square(s) == 7 def test_forming_magic_square_another_case(): s = [ [4, 5, 8], [2, 4, 1], [1, 9, 7] ] assert forming_magic_square(s) == 14 def test_forming_magic_square_all_same_numbers(): s = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert forming_magic_square(s) == 36","solution":"def forming_magic_square(s): # All possible 3x3 magic squares magic_squares = [ [8, 1, 6, 3, 5, 7, 4, 9, 2], [6, 1, 8, 7, 5, 3, 2, 9, 4], [2, 9, 4, 7, 5, 3, 6, 1, 8], [4, 9, 2, 3, 5, 7, 8, 1, 6], [8, 3, 4, 1, 5, 9, 6, 7, 2], [4, 3, 8, 9, 5, 1, 2, 7, 6], [6, 7, 2, 1, 5, 9, 8, 3, 4], [2, 7, 6, 9, 5, 1, 4, 3, 8] ] s_flat = [num for row in s for num in row] # Calculate the minimum cost to convert the input square to any of the magic squares min_cost = float('inf') for magic in magic_squares: cost = sum(abs(s_flat[i] - magic[i]) for i in range(9)) if cost < min_cost: min_cost = cost return min_cost"},{"question":"class Library: def __init__(self, books): Initialize the Library with a dictionary of books. :param books: Dictionary where keys are book titles and values are the number of copies available. pass def borrow(self, title): Borrow a book from the library. :param title: The title of the book to be borrowed. :return: \\"Borrowed successfully\\" if the book is available, \\"Book not available\\" otherwise. pass def return_book(self, title): Return a book to the library. :param title: The title of the book to be returned. :return: \\"Returned successfully\\" pass def report(self): Generate a report of the books available in the library. :return: List of tuples containing the title of the book and the number of available copies, sorted by the book title. pass from solution import Library def test_borrow_book_success(): lib = Library({'Book A': 2, 'Book B': 0}) assert lib.borrow('Book A') == \\"Borrowed successfully\\" assert lib.books['Book A'] == 1 def test_borrow_book_not_available(): lib = Library({'Book A': 2, 'Book B': 0}) assert lib.borrow('Book B') == \\"Book not available\\" assert lib.books['Book B'] == 0 def test_return_book_existing(): lib = Library({'Book A': 2, 'Book B': 0}) assert lib.return_book('Book A') == \\"Returned successfully\\" assert lib.books['Book A'] == 3 def test_return_book_new(): lib = Library({'Book A': 2, 'Book B': 0}) assert lib.return_book('Book C') == \\"Returned successfully\\" assert lib.books['Book C'] == 1 def test_report(): lib = Library({'Book A': 2, 'Book B': 0, 'Book C': 1}) report = lib.report() expected_report = [('Book A', 2), ('Book B', 0), ('Book C', 1)] assert report == expected_report","solution":"class Library: def __init__(self, books): Initialize the Library with a dictionary of books. :param books: Dictionary where keys are book titles and values are the number of copies available. self.books = books def borrow(self, title): Borrow a book from the library. :param title: The title of the book to be borrowed. :return: \\"Borrowed successfully\\" if the book is available, \\"Book not available\\" otherwise. if self.books.get(title, 0) > 0: self.books[title] -= 1 return \\"Borrowed successfully\\" return \\"Book not available\\" def return_book(self, title): Return a book to the library. :param title: The title of the book to be returned. :return: \\"Returned successfully\\" if title in self.books: self.books[title] += 1 else: self.books[title] = 1 return \\"Returned successfully\\" def report(self): Generate a report of the books available in the library. :return: List of tuples containing the title of the book and the number of available copies, sorted by the book title. return sorted(self.books.items())"},{"question":"from typing import List def solve(test_cases: List[str]) -> List[str]: You are given a string S consisting of lowercase alphabets. Your task is to arrange the characters of the string in such a way that no two adjacent characters are the same. If such an arrangement is not possible, return \\"No\\". Otherwise, return any possible arrangement. Args: test_cases: List of strings. Returns: List of results for each test case: \\"No\\" if it is not possible to rearrange the string such that no two adjacent characters are the same, otherwise, any valid arrangement. Examples: >>> solve([\\"aab\\", \\"aaab\\", \\"abc\\"]) [\\"aba\\", \\"No\\", \\"abc\\"] >>> solve([\\"a\\"]) [\\"a\\"]","solution":"from collections import Counter import heapq def rearrange_string(s): freq = Counter(s) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # Decrement the count (since count is negative) rearranged_str = ''.join(result) if len(rearranged_str) != len(s): return \\"No\\" return rearranged_str def solve(test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"class TimespanManager: A manager to handle timespans. Allows adding, removing, and retrieving time ranges. Methods: - addRange(start, end): Adds a range from start to end. - removeRange(start, end): Removes a range from start to end. - getRanges(): Returns a list of all current time ranges. Example usage: >>> manager = TimespanManager() >>> manager.addRange(1, 5) >>> manager.getRanges() [[1, 5]] >>> manager.addRange(10, 20) >>> manager.getRanges() [[1, 5], [10, 20]] >>> manager.addRange(15, 25) >>> manager.getRanges() [[1, 5], [10, 25]] # merged with previous range >>> manager.removeRange(10, 15) >>> manager.getRanges() [[1, 5], [16, 25]] def __init__(self): self.ranges = [] def addRange(self, start, end): # Implementation here pass def removeRange(self, start, end): # Implementation here pass def getRanges(self): # Implementation here pass def test_add_remove_and_get_ranges_basic(): manager = TimespanManager() manager.addRange(1, 5) assert manager.getRanges() == [[1, 5]] manager.addRange(10, 20) assert manager.getRanges() == [[1, 5], [10, 20]] manager.addRange(15, 25) assert manager.getRanges() == [[1, 5], [10, 25]] def test_add_remove_and_get_ranges_remove(): manager = TimespanManager() manager.addRange(1, 5) manager.addRange(10, 20) manager.addRange(15, 25) manager.removeRange(10, 15) assert manager.getRanges() == [[1, 5], [16, 25]] manager.removeRange(2, 3) assert manager.getRanges() == [[1, 1], [4, 5], [16, 25]] def test_add_range_merge(): manager = TimespanManager() manager.addRange(5, 10) manager.addRange(1, 4) manager.addRange(2, 6) assert manager.getRanges() == [[1, 10]] def test_remove_range_within_range(): manager = TimespanManager() manager.addRange(1, 10) manager.removeRange(3, 7) assert manager.getRanges() == [[1, 2], [8, 10]] def test_remove_range_multiple_splits(): manager = TimespanManager() manager.addRange(1, 10) manager.removeRange(2, 5) manager.removeRange(7, 8) assert manager.getRanges() == [[1, 1], [6, 6], [9, 10]]","solution":"class TimespanManager: def __init__(self): self.ranges = [] def addRange(self, start, end): new_ranges = [] i = 0 # Merge all non-overlapping ranges before the new range while i < len(self.ranges) and self.ranges[i][1] < start: new_ranges.append(self.ranges[i]) i += 1 # Merge all overlapping ranges with the new range while i < len(self.ranges) and self.ranges[i][0] <= end: start = min(start, self.ranges[i][0]) end = max(end, self.ranges[i][1]) i += 1 new_ranges.append([start, end]) # Add all non-overlapping ranges after the new range while i < len(self.ranges): new_ranges.append(self.ranges[i]) i += 1 self.ranges = new_ranges def removeRange(self, start, end): new_ranges = [] for rng in self.ranges: if rng[1] < start or rng[0] > end: new_ranges.append(rng) # No overlap else: if rng[0] < start: new_ranges.append([rng[0], start - 1]) if rng[1] > end: new_ranges.append([end + 1, rng[1]]) self.ranges = new_ranges def getRanges(self): return self.ranges"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> Union[List[Tuple[int, int]], str]: Given an array of integers, find and print all pairs of integers that sum up to the target value. Each pair is printed in ascending order based on the first element of the pair. If there are multiple pairs with the same first element, they are sorted based on the second element. If no such pairs exist, return \\"No pairs found\\". >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs_with_sum([10, 20, 10, -10, -20], 0) [(-20, 20), (-10, 10)] >>> find_pairs_with_sum([1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum([5, 6, 7, 8], 3) \\"No pairs found\\" >>> find_pairs_with_sum([-1, -2, -3, 3, 2, 1], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([1000000000, 2000000000, -1000000000, -2000000000], 0) [(-2000000000, 2000000000), (-1000000000, 1000000000)]","solution":"def find_pairs_with_sum(arr, target): Given an array of integers, find and print all pairs of integers that sum up to the target value. Each pair is printed in ascending order based on the first element of the pair. If there are multiple pairs with the same first element, they are sorted based on the second element. If no such pairs exist, print \\"No pairs found\\". arr.sort() pairs = set() seen = {} for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen[num] = 1 sorted_pairs = sorted(pairs) return sorted_pairs if sorted_pairs else \\"No pairs found\\""},{"question":"from typing import List def decide_who_to_invite(T: int, test_cases: List[List[int]]) -> List[str]: Decides who John should invite based on the better gift value from Alice and Bob. Parameters: T (int): Number of test cases test_cases (list of lists): Each sub-list contains 4 integers [GA, TA, GB, TB] Returns: list: A list containing the string \\"Alice\\", \\"Bob\\", or \\"Either\\" for each test case pass # Unit Tests def test_case_1(): T = 3 test_cases = [ [10, 20, 15, 15], [30, 25, 20, 30], [50, 50, 50, 50], ] expected_results = [\\"Either\\", \\"Alice\\", \\"Either\\"] assert decide_who_to_invite(T, test_cases) == expected_results def test_alice_gives_better_gift(): T = 1 test_cases = [ [20, 30, 10, 20], ] expected_results = [\\"Alice\\"] assert decide_who_to_invite(T, test_cases) == expected_results def test_bob_gives_better_gift(): T = 1 test_cases = [ [10, 20, 30, 15], ] expected_results = [\\"Bob\\"] assert decide_who_to_invite(T, test_cases) == expected_results def test_equal_gifts(): T = 1 test_cases = [ [25, 25, 20, 30], ] expected_results = [\\"Either\\"] assert decide_who_to_invite(T, test_cases) == expected_results def test_edge_case_min_values(): T = 1 test_cases = [ [1, 1, 1, 1], ] expected_results = [\\"Either\\"] assert decide_who_to_invite(T, test_cases) == expected_results def test_edge_case_max_values(): T = 1 test_cases = [ [100, 100, 100, 100], ] expected_results = [\\"Either\\"] assert decide_who_to_invite(T, test_cases) == expected_results","solution":"def decide_who_to_invite(T, test_cases): Decides who John should invite based on the better gift value from Alice and Bob. Parameters: T (int): Number of test cases test_cases (list of lists): Each sub-list contains 4 integers [GA, TA, GB, TB] Returns: list: A list containing the string \\"Alice\\", \\"Bob\\", or \\"Either\\" for each test case results = [] for i in range(T): GA, TA, GB, TB = test_cases[i] gift_value_alice = GA + TA gift_value_bob = GB + TB if gift_value_alice > gift_value_bob: results.append(\\"Alice\\") elif gift_value_alice < gift_value_bob: results.append(\\"Bob\\") else: results.append(\\"Either\\") return results"},{"question":"def prefix_sum(arr): Computes and returns the prefix sum array for the given input array arr. Parameters: arr (list of int): Input array of integers Returns: list of int: Prefix sum array Examples: >>> prefix_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> prefix_sum([5, -2, 7, 3]) [5, 3, 10, 13] >>> prefix_sum([]) [] >>> prefix_sum([5]) [5]","solution":"def prefix_sum(arr): Computes and returns the prefix sum array for the given input array arr. Parameters: arr (list of int): Input array of integers Returns: list of int: Prefix sum array if not arr: return [] prefix = [0] * len(arr) prefix[0] = arr[0] for i in range(1, len(arr)): prefix[i] = prefix[i - 1] + arr[i] return prefix"},{"question":"def find_winner(n: int, cards: List[int]) -> int: Determine the index of the player who wins the round. Parameters: n (int): number of players cards (list of int): cards dealt to each player Returns: int: index of the winning player, or -1 if there's a tie for the highest card Examples: >>> find_winner(5, [2, 5, 7, 3, 7]) -1 >>> find_winner(4, [1, 3, 8, 7]) 2 >>> find_winner(3, [6, 6, 7]) 2","solution":"def find_winner(n, cards): Determine the index of the player who wins the round. Parameters: n (int): number of players cards (list of int): cards dealt to each player Returns: int: index of the winning player, or -1 if there's a tie for the highest card max_card = max(cards) indices = [i for i, card in enumerate(cards) if card == max_card] if len(indices) != 1: return -1 else: return indices[0]"},{"question":"from typing import List, Tuple def count_word_pairs(sentences: List[str]) -> dict: Given several sentences, count the frequency of each word pair that appears. When the user types a word, suggest the next word based on the highest frequency of the pair occurrences. If there are multiple words with the same frequency, suggest the one that comes lexicographically first. def generate_output(suggestions: dict) -> List[str]: Generates the output for each unique word in the input sentences. Output the word followed by the most frequent subsequent word. If a word does not have any subsequent words, output only the word. def main(N: int, sentences: List[str]) -> List[str]: Main function to read sentences, process word pairs and generate the required output. >>> main(3, [\\"hello world this is a test\\", \\"this is a test case\\", \\"test case scenario\\"]) [\\"a test\\", \\"case scenario\\", \\"hello world\\", \\"is a\\", \\"test case\\", \\"this is\\", \\"world this\\"] # Test cases def test_count_word_pairs(): sentences = [ \\"hello world this is a test\\", \\"this is a test case\\", \\"test case scenario\\" ] expected_output = { 'hello': 'world', 'world': 'this', 'this': 'is', 'is': 'a', 'a': 'test', 'test': 'case', 'case': 'scenario' } assert count_word_pairs(sentences) == expected_output def test_generate_output(): suggestions = { 'hello': 'world', 'world': 'this', 'this': 'is', 'is': 'a', 'a': 'test', 'test': 'case', 'case': 'scenario' } expected_output = [ \\"a test\\", \\"case scenario\\", \\"hello world\\", \\"is a\\", \\"test case\\", \\"this is\\", \\"world this\\", ] assert generate_output(suggestions) == expected_output def test_main(): sentences = [ \\"hello world this is a test\\", \\"this is a test case\\", \\"test case scenario\\" ] expected_output = [ \\"a test\\", \\"case scenario\\", \\"hello world\\", \\"is a\\", \\"test case\\", \\"this is\\", \\"world this\\", ] assert main(3, sentences) == expected_output","solution":"def count_word_pairs(sentences): from collections import defaultdict, Counter word_pair_freq = defaultdict(Counter) for sentence in sentences: words = sentence.split() for i in range(len(words) - 1): word_pair_freq[words[i]][words[i+1]] += 1 suggestions = {} for word, counter in word_pair_freq.items(): most_common_word = sorted(counter.items(), key=lambda x: (-x[1], x[0]))[0][0] suggestions[word] = most_common_word return suggestions def generate_output(suggestions): result = [] for word, next_word in sorted(suggestions.items()): result.append(f\\"{word} {next_word}\\") return result def main(N, sentences): suggestions = count_word_pairs(sentences) output = generate_output(suggestions) return output"},{"question":"def categorize_books(N: int, book_scores: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Categorize books into genres based on the highest score. Args: N: int : number of books book_scores: List[Tuple[id: int, f_score: int, nf_score: int, s_score: int]]: list containing scores for each book Returns: List[Tuple[id: int, genre: int]]: list containing the genre for each book based on highest score","solution":"def categorize_books(N, book_scores): results = [] for book in book_scores: book_id, f_score, nf_score, s_score = book # Determine the highest score and corresponding genre if f_score >= nf_score and f_score >= s_score: genre = 1 elif nf_score >= s_score: genre = 2 else: genre = 3 results.append((book_id, genre)) return results"},{"question":"def sort_titles(titles: List[str]) -> List[str]: Returns a list of book titles sorted in alphabetical order. Args: titles (list): List of book titles (strings) Returns: list: List of book titles sorted alphabetically Examples: >>> sort_titles([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Pride and Prejudice\\", \\"Jane Eyre\\"]) [\\"1984\\", \\"Jane Eyre\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] >>> sort_titles([\\"The Great Gatsby\\"]) [\\"The Great Gatsby\\"] >>> sort_titles([\\"To Kill a Mockingbird\\", \\"The Great Gatsby\\", \\"Pride and Prejudice\\", \\"Jane Eyre\\", \\"1984\\"]) [\\"1984\\", \\"Jane Eyre\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"]","solution":"def sort_titles(titles): Returns a list of book titles sorted in alphabetical order. Args: titles (list): List of book titles (strings) Returns: list: List of book titles sorted alphabetically return sorted(titles)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression involving addition, subtraction, multiplication, and division. The expression can include integers, operators (\`+\`, \`-\`, \`*\`, \`/\`), and spaces. The expression will be valid and should be evaluated using standard operator precedence. >>> evaluate_expression(\\"3 + 5 * 2\\") # 13 >>> evaluate_expression(\\"10 + 2 * 6\\") # 22 >>> evaluate_expression(\\"100 * 2 + 12\\") # 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") # 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") # 100","solution":"import re def evaluate_expression(expression): Evaluates a mathematical expression involving addition, subtraction, multiplication, and division. The expression can include integers, operators (\`+\`, \`-\`, \`*\`, \`/\`), and spaces. It follows standard operator precedence rules. # Removing spaces from the expression for easier processing expression = expression.replace(' ', '') # Using Python's eval function to evaluate the expression # since it naturally respects operator precedence and parentheses try: result = eval(expression) except Exception as e: raise ValueError(\\"Invalid expression: \\" + str(e)) return result"},{"question":"def minimum_maximum_latency(P, Q, connections): Determine the minimum possible value of the maximum latency between any two cities on planet Zog. P: Number of cities Q: Number of possible cables connections: List of tuples representing the cables with format (a, b, l), where 'a' connects to 'b' with latency 'l' >>> minimum_maximum_latency(4, 5, [(1, 2, 3), (1, 3, 5), (2, 3, 4), (2, 4, 8), (3, 4, 2)]) 4 >>> minimum_maximum_latency(2, 1, [(1, 2, 7)]) 7","solution":"def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_maximum_latency(P, Q, connections): connections.sort(key=lambda x: x[2]) parent = list(range(P + 1)) rank = [0] * (P + 1) max_latency = 0 for a, b, l in connections: if find(parent, a) != find(parent, b): union(parent, rank, a, b) max_latency = l P -= 1 if P == 1: break return max_latency def main(): import sys input = sys.stdin.read data = input().split() P = int(data[0]) Q = int(data[1]) connections = [] index = 2 for _ in range(Q): a = int(data[index]) b = int(data[index + 1]) l = int(data[index + 2]) connections.append((a, b, l)) index += 3 print(minimum_maximum_latency(P, Q, connections)) if __name__ == \\"__main__\\": main()"},{"question":"def count_pairs_with_sum(arr, k): Counts the number of distinct pairs (i, j) in the array such that i < j and arr[i] + arr[j] = k. pass def process_test_cases(test_cases): Processes multiple test cases and returns the results. pass def main(T, test_cases): Main function to handle input and output for multiple test cases. pass # Unit Test import pytest def test_count_pairs_basic_cases(): assert count_pairs_with_sum([1, 2, 3, 4, 5], 7) == 2 assert count_pairs_with_sum([1, 5, 1, 5], 1) == 0 assert count_pairs_with_sum([3, 5, 2], 8) == 1 assert count_pairs_with_sum([1, 2, 3], 5) == 1 assert count_pairs_with_sum([1, 2, 3, 3], 6) == 1 def test_process_test_cases(): test_cases = [ {'nk': (5, 7), 'array': [1, 2, 3, 4, 5]}, {'nk': (4, 1), 'array': [1, 5, 1, 5]}, {'nk': (3, 8), 'array': [3, 5, 2]}, ] assert process_test_cases(test_cases) == [2, 0, 1] def test_main(capsys): T = 3 test_cases = [ {'nk': (5, 7), 'array': [1, 2, 3, 4, 5]}, {'nk': (4, 1), 'array': [1, 5, 1, 5]}, {'nk': (3, 8), 'array': [3, 5, 2]}, ] main(T, test_cases) captured = capsys.readouterr() assert captured.out == \\"2n0n1n\\"","solution":"def count_pairs_with_sum(arr, k): Counts the number of distinct pairs (i, j) in the array such that i < j and arr[i] + arr[j] = k. seen = {} count = 0 for num in arr: complement = k - num if complement in seen and seen[complement] > 0: count += 1 seen[complement] -= 1 else: if num in seen: seen[num] += 1 else: seen[num] = 1 return count def process_test_cases(test_cases): results = [] for case in test_cases: n, k = case['nk'] array = case['array'] results.append(count_pairs_with_sum(array, k)) return results def main(T, test_cases): results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def trap(height): Given a list of non-negative integers representing the amount of rainwater trapped at different sections, compute how much water can be trapped after filling it. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([1]) 0 >>> trap([0,0,0,0,0]) 0 >>> trap([0,1,2,3,4,5]) 0 >>> trap([5,4,3,2,1,0,1,2,3,4,5]) 25 >>> trap([1,1,1,1,1]) 0","solution":"def trap(height): Returns the amount of rainwater trapped. if not height: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) water_trapped += right_max - height[right] return water_trapped"},{"question":"from typing import List, Tuple def find_critical_roads(n: int, m: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Identify all the critical roads in the city. Args: n (int): Number of buildings m (int): Number of roads edges (List[Tuple[int, int]]): List of tuples representing the roads between buildings Returns: List[Tuple[int, int]]: List of critical roads. If there are no critical roads, return [\\"None\\"]. Examples: >>> find_critical_roads(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) [(3, 4), (4, 5)] >>> find_critical_roads(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) [\\"None\\"]","solution":"def find_critical_roads(n, m, edges): from collections import defaultdict, deque def dfs(node, parent): nonlocal time visited[node] = True ids[node] = low[node] = time time += 1 for neighbor in graph[node]: if neighbor == parent: continue if not visited[neighbor]: dfs(neighbor, node) low[node] = min(low[node], low[neighbor]) if ids[node] < low[neighbor]: critical_edges.append(tuple(sorted((node, neighbor)))) else: low[node] = min(low[node], ids[neighbor]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) ids = [0] * (n + 1) low = [0] * (n + 1) critical_edges = [] time = 0 for i in range(1, n + 1): if not visited[i]: dfs(i, -1) if critical_edges: critical_edges.sort() return critical_edges else: return [\\"None\\"] # Function to parse input and output result def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) m = int(data[idx + 1]) idx += 2 edges = [] for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) edges.append((u, v)) idx += 2 result = find_critical_roads(n, m, edges) for edge in result: print(*edge) if __name__ == \\"__main__\\": main()"},{"question":"def minimize_max_difference(arr): Rearranges the given array to minimize the maximum absolute difference between any two consecutive elements. >>> minimize_max_difference([10, 1, 9, 7, 3]) [1, 3, 7, 9, 10] >>> minimize_max_difference([4, 10, 2, 7]) [2, 4, 7, 10]","solution":"def minimize_max_difference(arr): Rearranges the given array to minimize the maximum absolute difference between any two consecutive elements. arr.sort() return arr"},{"question":"def maxDistinctSubarray(N: int, A: List[int], K: int) -> int: Given an array A[] of N integers and an integer K, find the maximum number of distinct integers among all possible contiguous subarrays of size K. >>> maxDistinctSubarray(7, [4, 1, 1, 3, 1, 4, 2], 3) 3 >>> maxDistinctSubarray(5, [1, 2, 1, 2, 3], 2) 2","solution":"def maxDistinctSubarray(N, A, K): Returns the maximum number of distinct integers among all possible contiguous subarrays of size K. if K > N: return 0 max_distinct = 0 freq = {} distinct_count = 0 # Initialize the first window's frequency dictionary for i in range(K): if A[i] not in freq: freq[A[i]] = 0 distinct_count += 1 freq[A[i]] += 1 max_distinct = max(max_distinct, distinct_count) for i in range(K, N): # Remove the first element of the previous window start_element = A[i - K] if freq[start_element] == 1: distinct_count -= 1 freq[start_element] -= 1 if freq[start_element] == 0: del freq[start_element] # Add the new element end_element = A[i] if end_element not in freq: freq[end_element] = 0 distinct_count += 1 freq[end_element] += 1 max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"def can_form_valid_sequence(nums): Determines if it is possible to rearrange nums such that the difference between adjacent nums is exactly 1. >>> can_form_valid_sequence([4, 2, 1, 3]) \\"YES\\" >>> can_form_valid_sequence([10, 11, 13]) \\"NO\\" >>> can_form_valid_sequence([-1, 1, 0, -2, 2]) \\"YES\\" def solve_puzzle(game_inputs): Processes multiple test cases for the puzzle game to determine if a valid sequence can be formed. Parameters: game_inputs (list of lists of tuples): Each sublist contains (N, nums) where: - N (int): Number of tiles - nums (list of int): List of tile numbers Returns: list of str: Each element is \\"YES\\" or \\"NO\\" for the corresponding test case >>> solve_puzzle([(4, [4, 2, 1, 3]), (3, [10, 11, 13]), (5, [-1, 1, 0, -2, 2])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve_puzzle([(1, [2]), (5, [2, 3, 4, 5, 6])]) [\\"YES\\", \\"YES\\"]","solution":"def can_form_valid_sequence(nums): Determines if it is possible to rearrange nums such that the difference between adjacent nums is exactly 1. nums.sort() for i in range(1, len(nums)): if nums[i] - nums[i-1] != 1: return \\"NO\\" return \\"YES\\" def solve_puzzle(game_inputs): Processes multiple test cases for the puzzle game to determine if a valid sequence can be formed. Parameters: game_inputs (list of lists of tuples): Each sublist contains (N, nums) where: - N (int): Number of tiles - nums (list of int): List of tile numbers Returns: list of str: Each element is \\"YES\\" or \\"NO\\" for the corresponding test case results = [] for n, nums in game_inputs: results.append(can_form_valid_sequence(nums)) return results"},{"question":"def longest_contiguous_subarray_same_parity(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements have the same parity. >>> longest_contiguous_subarray_same_parity(7, [5, 2, 2, 6, 6, 5, 7]) 4 >>> longest_contiguous_subarray_same_parity(5, [2, 4, 6, 8, 10]) 5 >>> longest_contiguous_subarray_same_parity(4, [1, 3, 5, 7]) 4 >>> longest_contiguous_subarray_same_parity(6, [1, 2, 3, 4, 5, 6]) 1 >>> longest_contiguous_subarray_same_parity(1, [1]) 1 >>> longest_contiguous_subarray_same_parity(2, [7, 5]) 2 >>> longest_contiguous_subarray_same_parity(2, [7, 8]) 1 >>> longest_contiguous_subarray_same_parity(0, []) 0","solution":"def longest_contiguous_subarray_same_parity(n, arr): Returns the length of the longest contiguous subarray where all elements have the same parity. if n == 0: return 0 max_length = current_length = 1 for i in range(1, n): if (arr[i] % 2) == (arr[i - 1] % 2): current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def num_decodings(s: str) -> int: Return the number of ways to decode the encoded message. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"012\\") 0 >>> num_decodings(\\"8\\") 1 >>> num_decodings(\\"100\\") 0 >>> num_decodings(\\"2101\\") 1 >>> num_decodings(\\"11106\\") 2","solution":"def num_decodings(s: str) -> int: Return the number of ways to decode the encoded message. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"def determine_winner(n: int, t: int, array: List[int]) -> str: Determine if John or Mike wins the game. Parameters: n (int): The number of elements in the array. t (int): The threshold value. array (list): The list of integers. Returns: str: \\"John\\" if John wins, otherwise \\"Mike\\". >>> determine_winner(5, 3, [4, 2, 3, 1, 5]) 'John' >>> determine_winner(3, 7, [1, 2, 3, 4, 5, 6]) 'Mike'","solution":"def determine_winner(n, t, array): This function determines who wins the game given the array and threshold value. Parameters: n (int): The number of elements in the array. t (int): The threshold value. array (list): The list of integers. Returns: str: \\"John\\" if John wins, otherwise \\"Mike\\". for number in array: if number >= t: return \\"John\\" return \\"Mike\\""},{"question":"def array_sum(nums): Returns the sum of the elements in the list nums. Parameters: nums (list): A list of integers. Returns: int: The sum of the elements in nums. Examples: >>> array_sum([1, 2, 3, 4, 5]) 15 >>> array_sum([10, -2, 4, 1]) 13","solution":"def array_sum(nums): Returns the sum of the elements in the list nums. Parameters: nums (list): A list of integers. Returns: int: The sum of the elements in nums. return sum(nums)"},{"question":"def find_substring_indices(T: int, test_cases: List[Tuple[str, str]]) -> List[int]: Determines if S2 is a substring of S1 for each test case and returns the starting index or -1 if not found. Args: T (int): Total number of test cases. test_cases (List[Tuple[str, str]]): List of tuples where each tuple contains strings S1 and S2. Returns: List[int]: List of starting indices of S2 in S1 for each test case or -1 if S2 is not found in S1. Example: >>> find_substring_indices(3, [(\\"hello\\", \\"ll\\"), (\\"hello\\", \\"world\\"), (\\"abcde\\", \\"cd\\")]) [2, -1, 2] >>> find_substring_indices(1, [(\\"a\\", \\"b\\")]) [-1] # Unit Tests: from solution import find_substring_indices def test_find_substring_indices_case1(): T = 3 test_cases = [(\\"hello\\", \\"ll\\"), (\\"hello\\", \\"world\\"), (\\"abcde\\", \\"cd\\")] assert find_substring_indices(T, test_cases) == [2, -1, 2] def test_find_substring_indices_case2(): T = 1 test_cases = [(\\"testcases\\", \\"case\\")] assert find_substring_indices(T, test_cases) == [4] def test_find_substring_indices_case3(): T = 2 test_cases = [(\\"abcdefgh\\", \\"z\\"), (\\"mnopqrtuv\\", \\"qr\\")] assert find_substring_indices(T, test_cases) == [-1, 4] def test_find_substring_indices_case4(): T = 1 test_cases = [(\\"substring\\", \\"string\\")] assert find_substring_indices(T, test_cases) == [3] def test_find_substring_indices_case5(): T = 1 test_cases = [(\\"a\\", \\"a\\")] assert find_substring_indices(T, test_cases) == [0] def test_find_substring_indices_case6(): T = 1 test_cases = [(\\"a\\", \\"b\\")] assert find_substring_indices(T, test_cases) == [-1]","solution":"def find_substring_indices(T, test_cases): For each test case, determines if S2 is a substring of S1 and returns the starting index or -1 if not found. results = [] for i in range(T): S1, S2 = test_cases[i] index = S1.find(S2) results.append(index) return results # Example usage: # T = 3 # test_cases = [(\\"hello\\", \\"ll\\"), (\\"hello\\", \\"world\\"), (\\"abcde\\", \\"cd\\")] # print(find_substring_indices(T, test_cases)) # Output: [2, -1, 2]"},{"question":"def can_form_target(t: str, s: str) -> str: Determines if the target word \`t\` can be formed by reordering and transforming the characters in the source word \`s\`. Parameters: t (str): target word s (str): source word Returns: str: \\"Yes\\" if \`t\` can be formed from \`s\`, \\"No\\" otherwise Example: >>> can_form_target(\\"abc\\", \\"def\\") 'Yes' >>> can_form_target(\\"abcd\\", \\"def\\") 'No'","solution":"def can_form_target(t, s): Determines if the target word \`t\` can be formed by reordering and transforming the characters in the source word \`s\`. Parameters: t (str): target word s (str): source word Returns: str: \\"Yes\\" if \`t\` can be formed from \`s\`, \\"No\\" otherwise if len(t) != len(s): return \\"No\\" return \\"Yes\\""},{"question":"def max_overlapping_queries(queries: List[Tuple[int, int]]) -> int: Returns the maximum number of overlapping queries at any moment. >>> max_overlapping_queries([(1, 4), (2, 6)]) 2 >>> max_overlapping_queries([(5, 10), (15, 20), (25, 30)]) 1 >>> max_overlapping_queries([(1, 5), (2, 6), (3, 7), (4, 8)]) 4","solution":"def max_overlapping_queries(queries): Returns the maximum number of overlapping queries at any moment. events = [] for (start, end) in queries: events.append((start, 'start')) events.append((end, 'end')) # Sort events first by time, then by type ('end' before 'start' in case of tie) events.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"def min_subsequences_to_sort(N: int, lengths: List[int]) -> int: This function receives the number of strings of lights N and their lengths, and returns the minimal number of contiguous subsequences that need to be sorted individually for the entire sequence of lights to be sorted. >>> min_subsequences_to_sort(7, [5, 2, 3, 6, 7, 2, 8]) 3 >>> min_subsequences_to_sort(1, [5]) 1","solution":"def min_subsequences_to_sort(N, lengths): This function returns the minimal number of contiguous subsequences that need to be sorted individually for the entire sequence to be sorted. if N <= 1: return 1 subsequences = 1 for i in range(1, N): if lengths[i] < lengths[i - 1]: subsequences += 1 return subsequences"},{"question":"def manage_sanctuary(T, test_cases): Manage the migration bird sanctuary with species updates and queries. Parameters: T (int): The number of test cases. test_cases (list): A list of tuples, each containing: N, Q (tuple): Number of species and number of queries populations (list): Initial populations for each species queries (list): List of update or query requests Returns: list: List of results for each query. Example Test Cases: >>> T = 1 >>> test_cases = [ ... ((3, 5), [10, 20, 30], [('U', 2, 5), ('Q', 2), ('U', 3, -10), ('Q', 3), ('Q', 1)]) ... ] >>> manage_sanctuary(T, test_cases) [25, 20, 10] >>> T = 1 >>> test_cases = [ ... ((2, 3), [0, 0], [('U', 1, 100), ('Q', 1), ('Q', 2)]) ... ] >>> manage_sanctuary(T, test_cases) [100, 0] >>> T = 1 >>> test_cases = [ ... ((4, 4), [5, 15, 25, 35], [('Q', 1), ('U', 4, 10), ('Q', 4), ('Q', 2)]) ... ] >>> manage_sanctuary(T, test_cases) [5, 45, 15] >>> T = 2 >>> test_cases = [ ... ((2, 3), [0, 10], [('U', 1, 5), ('Q', 1), ('Q', 2)]), ... ((3, 2), [10, 20, 30], [('Q', 3), ('U', 2, -5)]) ... ] >>> manage_sanctuary(T, test_cases) [5, 10, 30] >>> T = 1 >>> test_cases = [ ... ((3, 4), [100, 200, 300], [('Q', 1), ('U', 2, 50), ('Q', 2), ('Q', 3)]) ... ] >>> manage_sanctuary(T, test_cases) [100, 250, 300]","solution":"def manage_sanctuary(T, test_cases): results = [] for t in range(T): N, Q = test_cases[t][0] populations = test_cases[t][1] for query in test_cases[t][2]: if query[0] == 'U': x = query[1] - 1 # Convert to 0-based index y = query[2] populations[x] += y elif query[0] == 'Q': x = query[1] - 1 # Convert to 0-based index results.append(populations[x]) return results"},{"question":"def search_books(datasets): Search books by query in title and return information of matching books sorted by the number of pages in descending order, and by title in lexicographical order. >>> datasets = [ ... { 'n': 3, 'books': [ (1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 218), (2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 281), (3, \\"1984\\", \\"George Orwell\\", 328) ], 'query': \\"Mockingbird\\" }, ... { 'n': 2, 'books': [ (4, \\"Fahrenheit 451\\", \\"Ray Bradbury\\", 194), (5, \\"Brave New World\\", \\"Aldous Huxley\\", 311) ], 'query': \\"World\\" } ... ] >>> search_books(datasets) ['2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\" 281', '5 \\"Brave New World\\" \\"Aldous Huxley\\" 311'] >>> datasets = [ ... { 'n': 3, 'books': [ (1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 218), (2, \\"1984\\", \\"George Orwell\\", 328), (3, \\"Brave New World\\", \\"Aldous Huxley\\", 311) ], 'query': \\"Harry Potter\\" } ... ] >>> search_books(datasets) [\\"No match found\\"] >>> datasets = [ ... { 'n': 4, 'books': [ (1, \\"Python Programming\\", \\"John Doe\\", 250), (2, \\"Advanced Python\\", \\"Jane Doe\\", 300), (3, \\"Python Basics\\", \\"Jim Beam\\", 200), (4, \\"Python Cookbook\\", \\"Alex Martelli\\", 400) ], 'query': \\"Python\\" } ... ] >>> search_books(datasets) ['4 \\"Python Cookbook\\" \\"Alex Martelli\\" 400', '2 \\"Advanced Python\\" \\"Jane Doe\\" 300', '1 \\"Python Programming\\" \\"John Doe\\" 250', '3 \\"Python Basics\\" \\"Jim Beam\\" 200'] >>> datasets = [ ... { 'n': 2, 'books': [ (1, \\"Dune\\", \\"Frank Herbert\\", 412), (2, \\"The Dune Trilogy\\", \\"Frank Herbert\\", 896) ], 'query': \\"dune\\" } ... ] >>> search_books(datasets) ['2 \\"The Dune Trilogy\\" \\"Frank Herbert\\" 896', '1 \\"Dune\\" \\"Frank Herbert\\" 412']","solution":"def search_books(datasets): Search books by query in title and return information of matching books sorted by the number of pages (descending) and lexicographical order of title. results = [] for data in datasets: n = data['n'] books = data['books'] query = data['query'] matching_books = [] for book_id, title, author, pages in books: if query.lower() in title.lower(): matching_books.append((book_id, title, author, pages)) if not matching_books: results.append(\\"No match found\\") else: matching_books.sort(key=lambda x: (-x[3], x[1])) for book in matching_books: results.append(f'{book[0]} \\"{book[1]}\\" \\"{book[2]}\\" {book[3]}') return results"},{"question":"def longest_common_prefix(strings: List[str]) -> str: Returns the longest common prefix among the list of strings. Args: strings (List[str]): A list of strings containing only lowercase letters and having the same length. Returns: str: The longest common prefix among all the strings. If no common prefix exists, returns an empty string. Examples: >>> longest_common_prefix([\\"abc\\", \\"abd\\", \\"abe\\", \\"abf\\", \\"abg\\"]) \\"ab\\" >>> longest_common_prefix([\\"abcdeq\\", \\"abcdef\\", \\"abcdel\\", \\"abcdef\\"]) \\"abcde\\" >>> longest_common_prefix([\\"abcd\\", \\"bcda\\", \\"cdab\\"]) \\"\\"","solution":"def longest_common_prefix(strings): Returns the longest common prefix among the list of strings. if not strings: return \\"\\" # Initialize the prefix to the first string prefix = strings[0] for s in strings[1:]: # Find the common prefix between the current prefix and string s common_length = min(len(prefix), len(s)) for i in range(common_length): if prefix[i] != s[i]: common_length = i break prefix = prefix[:common_length] if not prefix: break return prefix"},{"question":"def rle_encode(input_string: str) -> str: Encodes the given string using Run-Length Encoding (RLE) algorithm. Parameters: input_string (str): Non-empty string containing only lowercase alphabets. Returns: str: Run-Length Encoded string. >>> rle_encode(\\"aaabbc\\") 'a3b2c1' >>> rle_encode(\\"abcd\\") 'a1b1c1d1' >>> rle_encode(\\"wwwwaaadexxxxxx\\") 'w4a3d1e1x6' >>> rle_encode(\\"a\\") 'a1' >>> rle_encode(\\"b\\") 'b1' >>> rle_encode(\\"aaaaaaaaaaa\\") 'a11' >>> rle_encode(\\"abababab\\") 'a1b1a1b1a1b1a1b1' >>> rle_encode(\\"\\") ''","solution":"def rle_encode(input_string): Encodes the given string using Run-Length Encoding (RLE) algorithm. Parameters: input_string (str): Non-empty string containing only lowercase alphabets. Returns: str: Run-Length Encoded string. if not input_string: return \\"\\" encoded_str = \\"\\" count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: encoded_str += prev_char + str(count) prev_char = char count = 1 # To add the last run of characters encoded_str += prev_char + str(count) return encoded_str"},{"question":"def generate_diamond(n): Generates a diamond shape using asterisks with the given width \`n\` for the middle row. >>> generate_diamond(1) \\"*n\\" >>> generate_diamond(3) \\" * n *** n*****n *** n * n\\" >>> generate_diamond(5) \\" * n *** n ***** n ******* n*********n ******* n ***** n *** n * n\\" >>> generate_diamond(0) \\"\\" >>> generate_diamond(-3) \\"\\" >>> generate_diamond(2) \\" * n***n * n\\"","solution":"def generate_diamond(n): Generates a diamond shape using asterisks with the given width \`n\` for the middle row. if n <= 0: return \\"\\" diamond = [] # Upper part including the middle row for i in range(n): line = ' ' * (n - i - 1) + '*' * (2 * i + 1) + ' ' * (n - i - 1) diamond.append(line) # Lower part excluding the middle row for i in range(n-2, -1, -1): line = ' ' * (n - i - 1) + '*' * (2 * i + 1) + ' ' * (n - i - 1) diamond.append(line) return 'n'.join(diamond) + 'n'"},{"question":"def max_beauty(n, k, m, beauty_values, magic_values): Calculates the maximum possible beauty of the potion while ensuring the magic does not exceed the given threshold. Args: n (int): number of flowers. k (int): number of consecutive flowers to pick. m (int): magic threshold. beauty_values (list of int): beauty values of the flowers. magic_values (list of int): magic values of the flowers. Returns: int or str: the maximum possible beauty or \\"impossible\\" if the conditions cannot be met. >>> max_beauty(7, 3, 1000, [5, 1, 9, 8, 3, 2, 7], [2, 4, 1, 2, 5, 3, 4]) 20 >>> max_beauty(5, 2, 5, [4, 8, 2, 1, 3], [6, 7, 8, 9, 10]) \\"impossible\\" def test_max_beauty(): assert max_beauty(7, 3, 1000, [5, 1, 9, 8, 3, 2, 7], [2, 4, 1, 2, 5, 3, 4]) == 20 assert max_beauty(5, 2, 5, [4, 8, 2, 1, 3], [6, 7, 8, 9, 10]) == \\"impossible\\" assert max_beauty(1, 1, 10, [5], [7]) == 5 assert max_beauty(1, 1, 5, [5], [7]) == \\"impossible\\" assert max_beauty(5, 3, 100, [3, 3, 3, 3, 3], [1, 1, 1, 1, 1]) == 9 assert max_beauty(5, 3, 1, [3, 3, 3, 3, 3], [2, 2, 2, 2, 2]) == \\"impossible\\" assert max_beauty(10, 5, 100000, [1000]*10, [1000]*10) == \\"impossible\\" assert max_beauty(10, 5, 1000000000, [1000]*10, [1]*10) == 5000","solution":"def max_beauty(n, k, m, beauty_values, magic_values): def calculate_beauty_and_magic(start): beauty_sum = sum(beauty_values[start:start + k]) magic_product = 1 for i in range(start, start + k): magic_product *= magic_values[i] return beauty_sum, magic_product max_beauty = -1 for i in range(n - k + 1): beauty_sum, magic_product = calculate_beauty_and_magic(i) if magic_product <= m: max_beauty = max(max_beauty, beauty_sum) if max_beauty == -1: return \\"impossible\\" else: return max_beauty"},{"question":"class WordBreaker: def __init__(self, dictionary: List[str]): Initializes the object with a given dictionary of valid words. pass def canSegment(self, string: str) -> bool: Returns true if the string can be segmented into valid words defined in the dictionary, and false otherwise. >>> dictionary = [\\"apple\\", \\"pen\\"] >>> wordBreaker = WordBreaker(dictionary) >>> wordBreaker.canSegment(\\"applepenapple\\") True >>> dictionary = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] >>> wordBreaker = WordBreaker(dictionary) >>> wordBreaker.canSegment(\\"catsandog\\") False >>> dictionary = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] >>> wordBreaker = WordBreaker(dictionary) >>> wordBreaker.canSegment(\\"catsanddog\\") True >>> dictionary = [\\"bed\\", \\"bath\\", \\"bedbath\\", \\"and\\", \\"beyond\\"] >>> wordBreaker = WordBreaker(dictionary) >>> wordBreaker.canSegment(\\"bedbathandbeyond\\") True pass","solution":"class WordBreaker: def __init__(self, dictionary): self.word_set = set(dictionary) def canSegment(self, string): dp = [False] * (len(string) + 1) dp[0] = True for i in range(1, len(string) + 1): for j in range(i): if dp[j] and string[j:i] in self.word_set: dp[i] = True break return dp[len(string)]"},{"question":"def can_match_stock_levels(N: int, s: List[int], t: List[int]) -> bool: Determines if it is possible to match stock levels to target stock levels using the allowed swap operations. >>> can_match_stock_levels(5, [5, 1, 3, 2, 4], [3, 2, 1, 5, 4]) True >>> can_match_stock_levels(4, [2, 2, 2, 2], [3, 4, 2, 1]) False >>> can_match_stock_levels(3, [8, 3, 7], [3, 7, 8]) True","solution":"def can_match_stock_levels(N, s, t): Determines if it is possible to match stock levels to target stock levels using the allowed swap operations. return sorted(s) == sorted(t)"},{"question":"def find_highest_binary_string(binaries: list) -> str: Returns the binary string with the highest decimal value from the list of binary strings. Params: - binaries (list of str): list containing binary strings Returns: - str: the binary string with the highest decimal value def main(input_line: str) -> str: Given a string of binary numbers separated by space, returns the binary number that has the highest decimal value Params: - input_line (str): the input string containing binary numbers separated by space Returns: - str: the binary string with the highest decimal value","solution":"def find_highest_binary_string(binaries): Returns the binary string with the highest decimal value from the list of binary strings. Params: - binaries (list of str): list containing binary strings Returns: - str: the binary string with the highest decimal value max_value = -1 max_binary = None for binary in binaries: decimal_value = int(binary, 2) if decimal_value > max_value: max_value = decimal_value max_binary = binary return max_binary def main(input_line): Given a string of binary numbers separated by space, returns the binary number that has the highest decimal value Params: - input_line (str): the input string containing binary numbers separated by space Returns: - str: the binary string with the highest decimal value binaries = input_line.split() return find_highest_binary_string(binaries)"},{"question":"def library_system(queries): A clerk at a local library wanted to implement an automated system to track the borrowing and returning of books. The system needs to maintain a list of currently borrowed books and perform various operations based on librarian queries. Each book has a unique identifier, and each librarian query is in one of the following formats: 1. \\"BORROW book_id\\" - This means a book with identifier 'book_id' is borrowed and should be added to the list of borrowed books. 2. \\"RETURN book_id\\" - This means a book with identifier 'book_id' is returned and should be removed from the list of borrowed books. 3. \\"QUERY book_id\\" - This means the system should check whether a book with identifier 'book_id' is currently borrowed or not. Write a program to implement this system. For each \\"QUERY\\" operation, the program should output \\"BORROWED\\" if the book is currently borrowed or \\"AVAILABLE\\" if the book has been returned. You can assume each book identifier is unique and consists of alphanumeric characters. Input A sequence of queries where each query consists of a single string in one of the specified formats. The end of input is indicated by a single line with the word \\"END\\". Output For each \\"QUERY\\" operation, output either \\"BORROWED\\" or \\"AVAILABLE\\" on a new line. Example: >>> queries = [ \\"BORROW book123\\", \\"BORROW book456\\", \\"QUERY book123\\", \\"RETURN book123\\", \\"QUERY book123\\", \\"QUERY book456\\", \\"RETURN book456\\", \\"QUERY book789\\", \\"END\\" ] >>> library_system(queries) [\\"BORROWED\\", \\"AVAILABLE\\", \\"BORROWED\\", \\"AVAILABLE\\"] from solution import library_system def test_library_system(): queries = [ \\"BORROW book123\\", \\"BORROW book456\\", \\"QUERY book123\\", \\"RETURN book123\\", \\"QUERY book123\\", \\"QUERY book456\\", \\"RETURN book456\\", \\"QUERY book789\\", \\"END\\" ] expected_output = [ \\"BORROWED\\", \\"AVAILABLE\\", \\"BORROWED\\", \\"AVAILABLE\\" ] assert library_system(queries) == expected_output def test_library_system_with_no_queries(): queries = [ \\"END\\" ] expected_output = [] assert library_system(queries) == expected_output def test_library_system_with_no_borrows(): queries = [ \\"QUERY book123\\", \\"QUERY book456\\", \\"END\\" ] expected_output = [ \\"AVAILABLE\\", \\"AVAILABLE\\" ] assert library_system(queries) == expected_output def test_library_system_all_books_returned(): queries = [ \\"BORROW book123\\", \\"BORROW book456\\", \\"RETURN book123\\", \\"RETURN book456\\", \\"QUERY book123\\", \\"QUERY book456\\", \\"END\\" ] expected_output = [ \\"AVAILABLE\\", \\"AVAILABLE\\" ] assert library_system(queries) == expected_output def test_library_system_all_books_borrowed(): queries = [ \\"BORROW book123\\", \\"BORROW book456\\", \\"QUERY book123\\", \\"QUERY book456\\", \\"END\\" ] expected_output = [ \\"BORROWED\\", \\"BORROWED\\" ] assert library_system(queries) == expected_output","solution":"def library_system(queries): borrowed_books = set() results = [] for query in queries: if query == \\"END\\": break operation, book_id = query.split() if operation == \\"BORROW\\": borrowed_books.add(book_id) elif operation == \\"RETURN\\": borrowed_books.discard(book_id) elif operation == \\"QUERY\\": if book_id in borrowed_books: results.append(\\"BORROWED\\") else: results.append(\\"AVAILABLE\\") return results"},{"question":"from collections import defaultdict, deque import math from typing import List, Tuple def shortestPathDAG(N: int, edges: List[Tuple[int, int, int]], start: int) -> List[float]: Returns the shortest path from start node to all other nodes in a DAG. If there is no path to a node, the distance is represented as infinity (INF). >>> shortestPathDAG(5, [(1, 2, 2), (1, 3, 6), (2, 4, 3), (2, 5, 4), (3, 4, 2), (4, 5, 1)], 1) [0, 2, 6, 5, 6] >>> shortestPathDAG(4, [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 3)], 1) [0, 1, 3, 6] >>> shortestPathDAG(4, [(1, 2, 1), (1, 3, 4), (2, 3, 3), (3, 4, 2)], 1) [0, 1, 4, 6] >>> shortestPathDAG(6, [(1, 2, 1), (1, 3, 5), (2, 3, 2), (2, 4, 6), (3, 4, 2), (3, 5, 3), (4, 5, 1), (4, 6, 7), (5, 6, 2)], 1) [0, 1, 3, 5, 6, 8] >>> shortestPathDAG(3, [(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1) [0, 5, 15] >>> shortestPathDAG(4, [(1, 2, 1), (3, 4, 1)], 1) [0, 1, float('inf'), float('inf')] # Implementation here","solution":"from collections import defaultdict, deque import math def shortestPathDAG(N, edges, start): Returns the shortest path from start node to all other nodes in a DAG. # Initialize the graph graph = defaultdict(list) indegree = [0] * N # Build the adjacency list for the graph and track the indegree of each node for u, v, w in edges: graph[u-1].append((v-1, w)) indegree[v-1] += 1 # Topological sort using Kahn's algorithm topo_order = [] queue = deque([node for node in range(N) if indegree[node] == 0]) while queue: node = queue.popleft() topo_order.append(node) for neighbor, weight in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Initialize distances with infinity distances = [math.inf] * N distances[start-1] = 0 # Relax edges in topological order for node in topo_order: if distances[node] != math.inf: for neighbor, weight in graph[node]: if distances[neighbor] > distances[node] + weight: distances[neighbor] = distances[node] + weight return distances"},{"question":"from typing import List, Tuple, Union class MedianFinder: def __init__(self): self.nums = [] def insert(self, x: int) -> None: Inserts x into the data structure. pass def delete(self, x: int) -> None: Deletes one occurrence of x from the data structure. pass def find_median(self) -> Union[str, float]: Finds the median of the current elements. >>> mf = MedianFinder() >>> mf.insert(3) >>> mf.insert(10) >>> mf.insert(5) >>> mf.find_median() 5 >>> mf.delete(5) >>> mf.find_median() 6.5 >>> mf.delete(3) >>> mf.find_median() 10 pass def median_operations(operations: List[Tuple[int, ...]]) -> List[Union[str, float]]: Performs a list of median operations and returns the results of all median queries. >>> operations = [(1, 3), (1, 10), (1, 5), (3,), (2, 5), (3,), (2, 3), (3,)] >>> median_operations(operations) [5, 6.5, 10] >>> operations = [(1, 8), (3,), (2, 8), (3,)] >>> median_operations(operations) [8, 'Empty'] >>> operations = [(1, 1), (1, 2), (1, 3), (1, 4), (3,), (2, 3), (3,)] >>> median_operations(operations) [2.5, 2.0] >>> operations = [(3,)] >>> median_operations(operations) ['Empty'] >>> operations = [(1, 5), (1, 5), (1, 5), (3,), (2, 5), (3,)] >>> median_operations(operations) [5, 5] pass","solution":"import bisect class MedianFinder: def __init__(self): self.nums = [] def insert(self, x): bisect.insort(self.nums, x) def delete(self, x): idx = bisect.bisect_left(self.nums, x) if idx != len(self.nums) and self.nums[idx] == x: del self.nums[idx] def find_median(self): n = len(self.nums) if n == 0: return \\"Empty\\" if n % 2 == 1: return self.nums[n // 2] else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2 def median_operations(operations): median_finder = MedianFinder() results = [] for operation in operations: if operation[0] == 1: median_finder.insert(operation[1]) elif operation[0] == 2: median_finder.delete(operation[1]) elif operation[0] == 3: results.append(median_finder.find_median()) return results"},{"question":"def total_printing_time(n: int, pages: List[int], m: int) -> int: Calculates the number of minutes needed to print all documents. :param n: int, number of documents :param pages: list of int, number of pages in each document :param m: int, number of pages the printer can print per minute :return: int, number of minutes needed to print all documents >>> total_printing_time(3, [3, 3, 3], 2) == 5 >>> total_printing_time(5, [5, 4, 5, 4, 4], 3) == 8 >>> total_printing_time(1, [7], 3) == 3 >>> total_printing_time(2, [1, 1], 5) == 1 >>> total_printing_time(10, [10]*10, 10) == 10 >>> total_printing_time(4, [1, 1, 1, 1], 5) == 1 >>> total_printing_time(100, [1000000000]*100, 1) == 100000000000 pass","solution":"def total_printing_time(n, pages, m): Calculates the number of minutes needed to print all documents. :param n: int, number of documents :param pages: list of int, number of pages in each document :param m: int, number of pages the printer can print per minute :return: int, number of minutes needed to print all documents total_pages = sum(pages) total_minutes = (total_pages + m - 1) // m # Using ceiling division return total_minutes"},{"question":"def smallest_enclosing_rectangle_area(points): Given a list of points, calculates the area of the smallest rectangle that can enclose all the points. The rectangle's sides are aligned with the coordinate axes. :param points: List of tuples, where each tuple represents a point (x, y) :return: The area of the smallest enclosing rectangle >>> smallest_enclosing_rectangle_area([(0, 0), (1, 2), (3, 1)]) == 6.0 >>> smallest_enclosing_rectangle_area([(0, 0)]) == 0.0 >>> smallest_enclosing_rectangle_area([(0, 0), (1000, 1000)]) == 1000000.0","solution":"def smallest_enclosing_rectangle_area(points): Given a list of points, this function calculates the area of the smallest rectangle that can enclose all the points. The rectangle's sides are aligned with the coordinate axes. :param points: List of tuples, where each tuple represents a point (x, y) :return: The area of the smallest enclosing rectangle if not points: return 0.0 min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) width = max_x - min_x height = max_y - min_y return float(width * height) # Example function to read input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)] print(\\"{:.15f}\\".format(smallest_enclosing_rectangle_area(points)))"},{"question":"def remove_consecutive_chars(s: str) -> str: Removes the minimum number of characters from the string s such that no three consecutive identical characters remain. >>> remove_consecutive_chars(\\"aaabbbccc\\") == \\"aabbcc\\" >>> remove_consecutive_chars(\\"aabbaabb\\") == \\"aabbaabb\\" >>> remove_consecutive_chars(\\"abcabcabc\\") == \\"abcabcabc\\" # your code here def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the resulting strings after removal of characters. Arguments: T -- Number of test cases test_cases -- List of test case strings Returns: List of resulting strings after processing each test case >>> process_test_cases(3, [\\"aaabbbccc\\", \\"aabbaabb\\", \\"abcabcabc\\"]) == [\\"aabbcc\\", \\"aabbaabb\\", \\"abcabcabc\\"] >>> process_test_cases(2, [\\"aaa\\", \\"aaaaa\\"]) == [\\"aa\\", \\"aa\\"] # your code here","solution":"def remove_consecutive_chars(s): Removes the minimum number of characters from the string s such that no three consecutive identical characters remain. result = [] for char in s: if len(result) >= 2 and result[-1] == char and result[-2] == char: continue # Skip the current char to avoid three consecutive identical chars result.append(char) return ''.join(result) def process_test_cases(T, test_cases): Processes multiple test cases and returns the resulting strings after removal of characters. Arguments: T -- Number of test cases test_cases -- List of test case strings Returns: List of resulting strings after processing each test case results = [] for s in test_cases: results.append(remove_consecutive_chars(s)) return results"},{"question":"def manage_inventory(current, new_weapons, limit): Manages the character's inventory by adding new weapons up to the specified limit. current: List of strings representing weapons currently carried. new_weapons: List of strings representing new weapons available to pick up. limit: Integer representing the maximum number of weapons the character can carry. Return: List of strings representing the final set of weapons carried. Examples: >>> manage_inventory([\\"sword\\", \\"dagger\\"], [\\"bow\\", \\"axe\\"], 3) [\\"sword\\", \\"dagger\\", \\"bow\\"] >>> manage_inventory([\\"sword\\", \\"dagger\\", \\"staff\\"], [\\"bow\\", \\"axe\\"], 4) [\\"sword\\", \\"dagger\\", \\"staff\\", \\"bow\\"] >>> manage_inventory([\\"sword\\"], [\\"bow\\", \\"axe\\", \\"dagger\\"], 2) [\\"sword\\", \\"bow\\"] >>> manage_inventory([\\"sword\\", \\"dagger\\"], [], 5) [\\"sword\\", \\"dagger\\"] >>> manage_inventory([], [\\"bow\\", \\"axe\\", \\"dagger\\"], 0) [] # Implementation here","solution":"def manage_inventory(current, new_weapons, limit): Manages the character's inventory by adding new weapons up to the specified limit. current: List of strings representing weapons currently carried. new_weapons: List of strings representing new weapons available to pick up. limit: Integer representing the maximum number of weapons the character can carry. Return: List of strings representing the final set of weapons carried. total_weapons = len(current) # Add new weapons until the limit is reached for weapon in new_weapons: if total_weapons < limit: current.append(weapon) total_weapons += 1 else: break return current"},{"question":"def min_operations_to_smallest_string(t: int, cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of operations needed to make the lexicographically smallest string possible. Parameters: t (int): The number of test cases. cases (List[Tuple[int, str]]): A list of tuples, where each tuple contains an integer representing the length of the string and the string itself. Returns: List[int]: A list of integers, each representing the minimum number of operations needed for the corresponding test case. Examples: >>> min_operations_to_smallest_string(3, [(5, 'dcbae'), (3, 'abc'), (6, 'abbcca')]) [2, 0, 1] >>> min_operations_to_smallest_string(2, [(4, 'dcba'), (4, 'abcd')]) [2, 0] >>> min_operations_to_smallest_string(1, [(3, 'cab')]) [1] >>> min_operations_to_smallest_string(1, [(2, 'ba')]) [1] >>> min_operations_to_smallest_string(1, [(5, 'aaaaa')]) [0]","solution":"def min_operations_to_smallest_string(t, cases): results = [] for i in range(t): n, s = cases[i] sorted_s = ''.join(sorted(s)) diff_count = 0 for j in range(n): if s[j] != sorted_s[j]: diff_count += 1 # Each mismatch can be corrected by reversing operations = diff_count // 2 results.append(operations) return results"},{"question":"def robo_walker(t: int, test_cases: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[str]: Determines if there exists a valid path that visits all checkpoints exactly once for each test case. Args: t: The number of test cases. test_cases: A list of tuples, where each tuple contains the following: - n: The number of rows in the grid. - m: The number of columns in the grid. - p: The number of checkpoints. - checkpoints: A list of tuples representing the coordinates of the checkpoints. Returns: A list of strings where each string is \\"YES\\" if a valid path exists for the respective test case, otherwise \\"NO\\". Example: >>> robo_walker(1, [(4, 4, 2, [(0, 1), (2, 3)])]) [\\"YES\\"] >>> robo_walker(1, [(4, 4, 3, [(0, 1), (2, 3), (0, 0)])]) [\\"NO\\"] pass","solution":"def find_valid_path(n, m, checkpoints): from itertools import permutations def is_valid_path(path): visited = set() for x, y in path: if (x, y) in visited: return False visited.add((x, y)) return True for perm in permutations(checkpoints): if is_valid_path(perm): return \\"YES\\" return \\"NO\\" def robo_walker(t, test_cases): result = [] for i in range(t): n, m, p, checkpoints = test_cases[i] result.append(find_valid_path(n, m, checkpoints)) return result"},{"question":"def find_peak_element(arr): Returns the index of any peak element in the array. The index is 1-based. >>> find_peak_element([1, 3, 2, 4, 1]) 2 >>> find_peak_element([1, 2, 3]) 3 from typing import List def find_peak_element(arr: List[int]) -> int: Find the index of any one peak element in the array.","solution":"def find_peak_element(arr): Returns the index of any peak element in the array. The index is 1-based. n = len(arr) # If there's only one element, it's a peak if n == 1: return 1 # Check the first and last elements if arr[0] > arr[1]: return 1 if arr[n - 1] > arr[n - 2]: return n # Check middle elements for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: return i + 1 # If no peak is found, return -1 (shouldn't happen with valid inputs) return -1"},{"question":"def can_guarantee_win(a: int, b: int) -> str: Determines whether you can guarantee a win given the initial numbers of stones in two piles. >>> can_guarantee_win(7, 6) 'Yes' >>> can_guarantee_win(14, 14) 'No' def test_can_guarantee_win_example_1(): assert can_guarantee_win(7, 6) == 'Yes' def test_can_guarantee_win_example_2(): assert can_guarantee_win(14, 14) == 'No' def test_can_guarantee_win_min_values(): assert can_guarantee_win(1, 1) == 'No' def test_can_guarantee_win_max_values(): assert can_guarantee_win(100, 100) == 'No' def test_can_guarantee_win_odd_sum(): assert can_guarantee_win(51, 50) == 'Yes' def test_can_guarantee_win_even_sum(): assert can_guarantee_win(50, 50) == 'No' def test_can_guarantee_win_large_odd_and_even(): assert can_guarantee_win(99, 100) == 'Yes'","solution":"def can_guarantee_win(a, b): Determines whether you can guarantee a win given the initial numbers of stones in two piles. You can guarantee a win if a + b is odd, otherwise, you cannot guarantee a win. return 'Yes' if (a + b) % 2 != 0 else 'No'"},{"question":"from typing import List def vertical_order(level_order: List[int]) -> List[List[int]]: Given a binary tree represented by a list of its node values in level order traversal, return the vertical order traversal of its nodes' values. The vertical order traversal of a binary tree is a traversal where we visit all nodes from top to bottom in each vertical column. Columns are ordered from left to right, and nodes in the same column are ordered based on their row number (level in the tree) and then by their order of appearance in that row from left to right. >>> vertical_order([3, 9, 20, None, None, 15, 7]) [[9], [3, 15], [20], [7]] >>> vertical_order([1, 2, 3, 4, 5, 6, 7]) [[4], [2], [1, 5, 6], [3], [7]] pass # Implement the function here","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(level_order): Build a binary tree from level order list if not level_order: return None iter_data = iter(level_order) root = TreeNode(next(iter_data)) queue = deque([root]) while queue: node = queue.popleft() try: left_val = next(iter_data) if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(iter_data) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def verticalOrderTraversal(root): The vertical order traversal of a binary tree. if not root: return [] cols = defaultdict(list) queue = deque([(root, 0, 0)]) # (node, column, row) while queue: node, col, row = queue.popleft() if node: cols[col].append((row, node.val)) queue.append((node.left, col - 1, row + 1)) queue.append((node.right, col + 1, row + 1)) sorted_cols = sorted(cols.items()) result = [] for col, values in sorted_cols: values.sort() # Python's default tuple sorting (first by row, then value) result.append([val for row, val in values]) return result def vertical_order(level_order): Creates the binary tree from level order list and returns its vertical order traversal. root = build_tree(level_order) return verticalOrderTraversal(root)"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that all letters come before digits. Letters are sorted in alphabetical order and digits are sorted in ascending order. >>> rearrange_string(\\"a3b7c2d1\\") \\"abcd1237\\" >>> rearrange_string(\\"x4y5z6a2b1\\") \\"abxyz12456\\" def test_rearrange_string_with_mix(): assert rearrange_string(\\"a3b7c2d1\\") == \\"abcd1237\\" assert rearrange_string(\\"x4y5z6a2b1\\") == \\"abxyz12456\\" def test_rearrange_string_only_letters(): assert rearrange_string(\\"dcba\\") == \\"abcd\\" assert rearrange_string(\\"zyx\\") == \\"xyz\\" def test_rearrange_string_only_digits(): assert rearrange_string(\\"4321\\") == \\"1234\\" assert rearrange_string(\\"987654321\\") == \\"123456789\\" def test_rearrange_string_empty(): assert rearrange_string(\\"\\") == \\"\\" def test_rearrange_string_letters_and_digits_separated(): assert rearrange_string(\\"abcd1234\\") == \\"abcd1234\\" assert rearrange_string(\\"1234abcd\\") == \\"abcd1234\\"","solution":"def rearrange_string(s: str) -> str: Rearranges the input string such that all letters come before digits. Letters are sorted in alphabetical order and digits are sorted in ascending order. :param s: Input string containing letters and digits :return: Transformed string with sorted letters followed by sorted digits letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits)"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. Params: s1: A string s2: A string Returns: True if s1 is a permutation of s2, False otherwise. Examples: >>> are_permutations(\\"abc\\", \\"cab\\") True >>> are_permutations(\\"abc\\", \\"def\\") False >>> are_permutations(\\"abcd\\", \\"abc\\") False >>> are_permutations(\\"test\\", \\"test\\") True >>> are_permutations(\\"a!c@b#\\", \\"#b@c!a\\") True >>> are_permutations(\\"Abc\\", \\"cab\\") False >>> are_permutations(\\"\\", \\"\\") True","solution":"def are_permutations(s1, s2): Determines if one string is a permutation of the other. Params: s1: A string s2: A string Returns: True if s1 is a permutation of s2, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def reconstruct_route(n, logged_route): Reconstructs the unique sequence of delivery points each drone was originally supposed to visit. Parameters: n (int): The total number of delivery points. logged_route (list): The sequence of logged delivery points with possible revisits. Returns: list: The original route with each delivery point visited exactly once. def process_input(input_data): Processes the input for multiple test cases to determine the unique sequence of delivery points for each drone's route. Parameters: input_data (str): The input as a single string which includes multiple test cases. Returns: str: The output where each line contains the space-separated sequence of unique delivery points for each respective test case. import unittest class TestDeliveryRoutes(unittest.TestCase): def test_reconstruct_route(self): self.assertEqual(reconstruct_route(5, [1, 2, 3, 2, 4, 5, 3, 2, 1, 4, 5]), [1, 2, 3, 4, 5]) self.assertEqual(reconstruct_route(4, [1, 3, 2, 3, 4, 1]), [1, 3, 2, 4]) self.assertEqual(reconstruct_route(3, [3, 3, 3, 2, 2, 1]), [3, 2, 1]) self.assertEqual(reconstruct_route(1, [1]), [1]) self.assertEqual(reconstruct_route(5, [5, 4, 3, 2, 1, 5, 4, 3, 2, 1]), [5, 4, 3, 2, 1]) def test_process_input(self): input_data = \\"5n1 2 3 2 4 5 3 2 1 4 5n4n1 3 2 3 4 1n0n\\" expected_output = \\"1 2 3 4 5n1 3 2 4\\" self.assertEqual(process_input(input_data), expected_output) input_data = \\"3n3 3 3 2 2 1n0n\\" expected_output = \\"3 2 1\\" self.assertEqual(process_input(input_data), expected_output) input_data = \\"1n1n0n\\" expected_output = \\"1\\" self.assertEqual(process_input(input_data), expected_output) input_data = \\"5n5 4 3 2 1 5 4 3 2 1n0n\\" expected_output = \\"5 4 3 2 1\\" self.assertEqual(process_input(input_data), expected_output) input_data = \\"0n\\" expected_output = \\"\\" self.assertEqual(process_input(input_data), expected_output)","solution":"def reconstruct_route(n, logged_route): Reconstructs the unique sequence of delivery points each drone was originally supposed to visit. Parameters: n (int): The total number of delivery points. logged_route (list): The sequence of logged delivery points with possible revisits. Returns: list: The original route with each delivery point visited exactly once. unique_route = [] visited = set() for point in logged_route: if point not in visited: unique_route.append(point) visited.add(point) return unique_route def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") results = [] i = 0 while i < len(input_lines): n = int(input_lines[i]) if n == 0: break logged_route = list(map(int, input_lines[i+1].split())) unique_route = reconstruct_route(n, logged_route) results.append(\\" \\".join(map(str, unique_route))) i += 2 return \\"n\\".join(results)"},{"question":"def determine_winner(n: int, arr: List[int]) -> str: Determine if Aptos will win or lose given the initial configuration of the array. Aptos and Benji are playing a game with an array of n integers. The game proceeds in rounds and alternates between the two players, starting with Aptos. In each round, the current player must choose any positive integer from the array and remove it. The remaining elements of the array are then reduced by one. A player loses if they cannot make a valid move on their turn, meaning there are no positive integers left in the array to remove. Assume both players use optimal strategies. Determine if Aptos, starting the game, will win or lose given the initial configuration of the array. >>> determine_winner(5, [2, 3, 4, 1, 3]) \\"Benji\\" >>> determine_winner(1, [1]) \\"Aptos\\" Parameters: n (int): The number of elements in the array. arr (list of int): The array of elements. Returns: str: \\"Aptos\\" if Aptos will win, otherwise \\"Benji\\".","solution":"def determine_winner(n, arr): Determine if Aptos will win given the initial configuration of the array. Aptos starts first with an optimal strategy. Parameters: n (int): The number of elements in the array. arr (list of int): The array of elements. Returns: str: \\"Aptos\\" if Aptos will win, otherwise \\"Benji\\". # The number of distinct non-zero integers in the array determines the outcome. # If the number of such distinct integers is odd, Aptos wins, otherwise Benji wins. distinct_non_zero_count = sum(1 for x in set(arr) if x > 0) if distinct_non_zero_count % 2 == 1: return \\"Aptos\\" else: return \\"Benji\\" # Example usage: # print(determine_winner(5, [2, 3, 4, 1, 3])) # Output: \\"Benji\\""},{"question":"def min_path_cost(grid): Returns the minimum cost required to travel from the top-left to the bottom-right corner of the grid. >>> min_path_cost([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_path_cost([[1, 3, 1, 2], [3, 4, 2, 1], [1, 2, 3, 1], [3, 1, 2, 1]]) 10 >>> min_path_cost([[5]]) 5 >>> min_path_cost([[1, 2], [3, 4]]) 7 >>> min_path_cost([[1000000000, 1000000000], [1000000000, 1000000000]]) 3000000000","solution":"def min_path_cost(grid): Returns the minimum cost required to travel from the top-left to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Create a dp table to store the minimum cost to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer will be in the bottom-right corner return dp[-1][-1] def read_input(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) grid = [] idx = 2 for i in range(n): row = list(map(int, data[idx:idx+m])) grid.append(row) idx += m return n, m, grid def solve(): n, m, grid = read_input() result = min_path_cost(grid) print(result)"},{"question":"def max_optimal_days(x: int, m: int, n: int, sunlight_hours: List[int]) -> int: Determine the maximum number of days Loella's plant can grow optimally. Args: x (int): Total water available in milliliters. m (int): Water required per day in milliliters. n (int): Sunlight required per day in hours. sunlight_hours (List[int]): List of sunlight hours available each day. Returns: int: Maximum number of days the plant can grow optimally. Examples: >>> max_optimal_days(10, 2, 3, [4, 3, 2, 5, 1]) 3 >>> max_optimal_days(5, 2, 1, [1, 1, 2, 3]) 2 >>> max_optimal_days(7, 3, 2, [2, 1, 3, 3, 2]) 2","solution":"def max_optimal_days(x, m, n, sunlight_hours): days = 0 for hours in sunlight_hours: if hours >= n and x >= m: days += 1 x -= m if x < m: break return days # Example usage x = 10 m = 2 n = 3 sunlight_hours = [4, 3, 2, 5, 1] print(max_optimal_days(x, m, n, sunlight_hours)) # Output: 3"},{"question":"def text_editor(n: int, operations: List[str]) -> str: Linda is building a simple text editor and needs to implement an undo operation. The text editor initially contains an empty string. Each operation is either adding a character to the string, or undoing the latest operation. This function takes the number of operations \`n\` and a list of \`n\` operations, and returns the final string after performing all the operations. >>> text_editor(5, [\\"ADD a\\", \\"ADD b\\", \\"UNDO\\", \\"ADD c\\", \\"ADD d\\"]) == \\"acd\\" >>> text_editor(3, [\\"ADD a\\", \\"UNDO\\", \\"UNDO\\"]) == \\"\\" >>> text_editor(7, [\\"ADD x\\", \\"ADD y\\", \\"UNDO\\", \\"ADD z\\", \\"UNDO\\", \\"UNDO\\", \\"UNDO\\"]) == \\"\\"","solution":"def text_editor(n, operations): string = [] history = [] for op in operations: if op.startswith(\\"ADD\\"): _, char = op.split() string.append(char) history.append((\\"ADD\\", char)) elif op == \\"UNDO\\": if history: last_op, char = history.pop() if last_op == \\"ADD\\": string.pop() return \\"\\".join(string)"},{"question":"def rectangles_overlap(x1, y1, x2, y2, x3, y3, x4, y4): Determine if two rectangles overlap. Parameters: x1, y1: Coordinates of the lower-left corner of the first rectangle x2, y2: Coordinates of the upper-right corner of the first rectangle x3, y3: Coordinates of the lower-left corner of the second rectangle x4, y4: Coordinates of the upper-right corner of the second rectangle Returns: \\"YES\\" if the rectangles overlap, \\"NO\\" otherwise >>> rectangles_overlap(0, 0, 2, 2, 1, 1, 3, 3) \\"YES\\" >>> rectangles_overlap(0, 0, 1, 1, 2, 2, 3, 3) \\"NO\\" >>> rectangles_overlap(-1, -1, 1, 1, 0, 0, 2, 2) \\"YES\\" >>> rectangles_overlap(0, 0, 1, 1, 1, 1, 2, 2) \\"NO\\" >>> rectangles_overlap(0, 0, 3, 3, 1, 1, 2, 2) \\"YES\\" >>> rectangles_overlap(1, 1, 4, 4, 2, 2, 3, 3) \\"YES\\" >>> rectangles_overlap(0, 0, 2, 2, 3, 3, 4, 4) \\"NO\\" >>> rectangles_overlap(0, 0, 1, 1, 0, 1, 2, 2) \\"NO\\"","solution":"def rectangles_overlap(x1, y1, x2, y2, x3, y3, x4, y4): Determine if two rectangles overlap. Parameters: x1, y1: Coordinates of the lower-left corner of the first rectangle x2, y2: Coordinates of the upper-right corner of the first rectangle x3, y3: Coordinates of the lower-left corner of the second rectangle x4, y4: Coordinates of the upper-right corner of the second rectangle Returns: \\"YES\\" if the rectangles overlap, \\"NO\\" otherwise # Check if one rectangle is to the left of the other if x1 >= x4 or x3 >= x2: return \\"NO\\" # Check if one rectangle is above the other if y1 >= y4 or y3 >= y2: return \\"NO\\" return \\"YES\\""},{"question":"def is_safe_reachable(n: int, m: int, k: int, grid: List[List[str]]) -> str: Determines if it's possible to reach 'E' from 'S' in the grid while passing through at least one '+' and within k steps. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Maximum number of steps allowed. grid (List[List[str]]): The grid representation with cells - '.', '#', 'S', 'E', '+' Returns: str: \\"YES\\" if it is possible for the robot to reach 'E' from 'S' passing through at least one safety zone '+' within k steps, otherwise \\"NO\\". >>> is_safe_reachable(4, 4, 5, [ ... \\"S...\\", ... \\"..+.\\", ... \\".E\\", ... \\"....\\" ...]) \\"YES\\" >>> is_safe_reachable(3, 3, 4, [ ... \\"S#.\\", ... \\"+\\", ... \\"..E\\" ...]) \\"NO\\" pass # Implement the logic to determine if it's possible to reach 'E'. def solve(grid_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]: Processes multiple test cases to determine results for each grid configuration. Args: grid_cases (List[Tuple[int, int, int, List[str]]]): The list of test cases where each test case contains n, m, k, and the grid. Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\"). results = [] for case in grid_cases: n, m, k, grid = case result = is_safe_reachable(n, m, k, grid) results.append(result) return results def test_is_safe_reachable(): grid_cases = [ (4, 4, 5, [ \\"S...\\", \\"..+.\\", \\".E\\", \\"....\\" ]), (3, 3, 4, [ \\"S#.\\", \\"+\\", \\"..E\\" ]), (1, 1, 1, [ \\"S\\" ]), (1, 2, 2, [ \\"SE\\" ]), (3, 3, 6, [ \\"S+.\\", \\"...\\", \\"..E\\" ]), ] results = solve(grid_cases) assert results == [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] if __name__ == \\"__main__\\": test_is_safe_reachable() print(\\"All tests passed.\\")","solution":"from collections import deque def is_safe_reachable(n, m, k, grid): Determines if it's possible to reach 'E' from 'S' in the grid while passing through at least one '+' and within k steps. start = end = None safety_zones = set() # Find the start, end, and safety zones for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) elif grid[i][j] == '+': safety_zones.add((i, j)) if not start or not end or not safety_zones: return \\"NO\\" # Direction vectors for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Perform BFS from the start location queue = deque([(start[0], start[1], 0, False)]) visited = set([(start[0], start[1], False)]) while queue: x, y, steps, passed_safety = queue.popleft() # If we exceed step limit, continue to the next if steps > k: continue # Check if end is reached with at least one safety zone passed if (x, y) == end and passed_safety: return \\"YES\\" # Explore all four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny, passed_safety or (nx, ny) in safety_zones) not in visited: visited.add((nx, ny, passed_safety or (nx, ny) in safety_zones)) queue.append((nx, ny, steps + 1, passed_safety or (nx, ny) in safety_zones)) return \\"NO\\" def solve(grid_cases): results = [] for case in grid_cases: n, m, k, grid = case result = is_safe_reachable(n, m, k, grid) results.append(result) return results"},{"question":"def count_beautiful_triplets(n: int, d: int, arr: List[int]) -> int: Counts the number of beautiful triplets in the given array. >>> count_beautiful_triplets(7, 3, [1, 2, 4, 5, 7, 8, 10]) 3 >>> count_beautiful_triplets(5, 5, [1, 2, 3, 4, 5]) 0 >>> count_beautiful_triplets(4, 0, [5, 5, 5, 5]) 4 >>> count_beautiful_triplets(3, 1, [1, 2, 3]) 1 >>> count_beautiful_triplets(8, 2, [1, 3, 5, 7, 9, 11, 13, 15]) 6 pass","solution":"def count_beautiful_triplets(n, d, arr): Counts the number of beautiful triplets in the given array. Parameters: n (int): The size of the array. d (int): The integer difference described in the problem. arr (list of int): The elements of the array. Returns: int: The number of beautiful triplets in the array. count = 0 for i in range(n): for j in range(i+1, n): if arr[j] - arr[i] == d: for k in range(j+1, n): if arr[k] - arr[j] == d: count += 1 return count"},{"question":"def longest_substring_k_distinct(s: str, k: int, queries: List[Tuple[int, int]]) -> List[int]: Determine the length of the longest substring that contains no more than k distinct characters in specified ranges of the string s for each query. Args: s (str): The input string. k (int): The maximum number of distinct characters allowed in the substring. queries (List[Tuple[int, int]]): A list of tuples where each tuple represents a query with the starting and ending indices (1-based) of the substring. Returns: List[int]: A list of integers where each integer is the length of the longest substring for the corresponding query. Example: >>> longest_substring_k_distinct(\\"abcba\\", 2, [(1, 3), (2, 5)]) [2, 3]","solution":"def longest_substring_k_distinct(s, k, queries): from collections import defaultdict def get_max_len_substring(left, right): char_count = defaultdict(int) max_len = 0 distinct_chars = 0 start = left for end in range(left, right + 1): if char_count[s[end]] == 0: distinct_chars += 1 char_count[s[end]] += 1 while distinct_chars > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: distinct_chars -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len results = [] for left, right in queries: # Convert 1-based to 0-based indexing results.append(get_max_len_substring(left - 1, right - 1)) return results"},{"question":"def remaining_time_for_marathon(test_cases): Given the time limit for the marathon and the current time spent by a participant, calculate how much more time each participant has to complete the marathon. Parameters: test_cases : List[Tuple[int, int]] List of tuples where each tuple consists of two integers: the time limit for the marathon and the current time spent by the participant. Returns: List[int] List of integers where each integer represents the remaining time for the corresponding participant. >>> remaining_time_for_marathon([(300, 120), (180, 90), (150, 145), (100, 60)]) [180, 90, 5, 40] >>> remaining_time_for_marathon([(100, 60)]) [40] >>> remaining_time_for_marathon([(300, 60)]) [240] >>> remaining_time_for_marathon([(180, 179)]) [1] def parse_input(input_data): Parse the input data for the marathon time calculation. Parameters: input_data : str Multi-line string where the first line contains the number of test cases T, followed by T lines each containing two integers L and C. Returns: List[Tuple[int, int]] List of tuples where each tuple consists of two integers: the time limit for the marathon and the current time spent by the participant. >>> parse_input(\\"4n300 120n180 90n150 145n100 60\\") [(300, 120), (180, 90), (150, 145), (100, 60)] >>> parse_input(\\"1n100 60\\") [(100, 60)] >>> parse_input(\\"1n300 60\\") [(300, 60)] >>> parse_input(\\"1n180 179\\") [(180, 179)]","solution":"def remaining_time_for_marathon(test_cases): results = [] for L, C in test_cases: results.append(L - C) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:]] return test_cases"},{"question":"def find_triplets(n: int, T: int, arr: List[int]) -> List[Tuple[int, int, int]]: This function finds all unique triplets in the array that sum up to target value T. Parameters: n (int): Number of elements in the array. T (int): Target sum. arr (list of int): Array of integers. Returns: list of tuple: List of triplets that sum up to T. >>> find_triplets(6, 0, [-1, 0, 1, 2, -1, -4]) [(-1, -1, 2), (-1, 0, 1)] >>> find_triplets(7, 0, [0, -1, 2, -3, 1, -2, 3]) [(-3, 0, 3), (-3, 1, 2), (-2, -1, 3), (-2, 0, 2), (-1, 0, 1)]","solution":"def find_triplets(n, T, arr): This function finds all unique triplets in the array that sum up to target value T. Parameters: n (int): Number of elements in the array. T (int): Target sum. arr (list of int): Array of integers. Returns: list of tuple: List of triplets that sum up to T. arr.sort() triplets = set() for i in range(n): left, right = i + 1, n - 1 while left < right: sum_triplet = arr[i] + arr[left] + arr[right] if sum_triplet == T: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif sum_triplet < T: left += 1 else: right -= 1 return sorted(list(triplets)) # To get the output as specified in the problem statement def format_output(triplets): This function formats the triplets for output. Parameters: triplets (list of tuples): List of triplets. Returns: str: Formatted string for output. return \\"n\\".join(\\" \\".join(map(str, triplet)) for triplet in triplets)"},{"question":"def longest_vowel_subsequence_length(S: str) -> int: Returns the length of the longest subsequence of S which consists of only vowels. Parameters: S (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest subsequence of vowels in S. Examples: >>> longest_vowel_subsequence_length(\\"aeiou\\") 5 >>> longest_vowel_subsequence_length(\\"abecidofu\\") 5 >>> longest_vowel_subsequence_length(\\"xyz\\") 0 pass def process_test_cases(test_cases: list) -> list: Processes a list of test cases and returns a list with the results for each test case. Parameters: test_cases (list): List of input strings, each string consisting of lowercase alphabets. Returns: list: List of integers representing the length of the longest subsequence of vowels for each test case. Examples: >>> process_test_cases([\\"aeiou\\", \\"abecidofu\\", \\"xyz\\"]) [5, 5, 0] >>> process_test_cases([\\"abcdefgh\\", \\"uoeia\\", \\"qwrtypsdfghjklzxcvbnm\\"]) [2, 5, 0] pass","solution":"def longest_vowel_subsequence_length(S: str) -> int: Returns the length of the longest subsequence of S which consists of only vowels. vowels = {'a', 'e', 'i', 'o', 'u'} return sum(1 for char in S if char in vowels) def process_test_cases(test_cases: list) -> list: Processes a list of test cases and returns a list with the results for each test case. results = [] for S in test_cases: results.append(longest_vowel_subsequence_length(S)) return results"},{"question":"def calculate_loan_repayment(A: int, R: int, Y: int) -> float: Calculates the total amount to be repaid after Y years with an annual increase rate of R percent. :param A: Initial loan amount (int) :param R: Annual increase rate in percentage (int) :param Y: Number of years (int) :return: Total amount to be repaid after Y years, rounded to two decimal places (float) >>> calculate_loan_repayment(1000, 10, 2) 1210.00 >>> calculate_loan_repayment(5000, 5, 10) 8144.47","solution":"def calculate_loan_repayment(A, R, Y): Calculates the total amount to be repaid after Y years with an annual increase rate of R percent. :param A: Initial loan amount (int) :param R: Annual increase rate in percentage (int) :param Y: Number of years (int) :return: Total amount to be repaid after Y years, rounded to two decimal places (float) rate = R / 100 total_amount = A * (1 + rate) ** Y return round(total_amount, 2)"},{"question":"def can_form_palindromic_pair(s: str) -> str: Checks if the given string can be split into two segments of equal length such that one segment reversed equals the other segment. Args: s (str): The input string of even length. Returns: str: 'YES' if it can be split as described, 'NO' otherwise. Examples: >>> can_form_palindromic_pair(\\"abccba\\") 'YES' >>> can_form_palindromic_pair(\\"abcdef\\") 'NO' >>> can_form_palindromic_pair(\\"noppon\\") 'YES' def verify_messages(T: int, messages: List[str]) -> List[str]: Processes multiple test cases to check if each string can be split into valid palindromic pairs. Args: T (int): Number of test cases. messages (list of str): List of strings to be verified. Returns: list of str: Results for each test case, 'YES' or 'NO'. Examples: >>> verify_messages(3, [\\"abccba\\", \\"abcdef\\", \\"noppon\\"]) ['YES', 'NO', 'YES'] >>> verify_messages(2, [\\"abbaabba\\", \\"abcd\\"]) ['YES', 'NO'] >>> verify_messages(1, [\\"aabbcc\\"]) ['NO']","solution":"def can_form_palindromic_pair(s): Checks if the given string can be split into two segments of equal length such that one segment reversed equals the other segment. Args: s (str): The input string of even length. Returns: str: 'YES' if it can be split as described, 'NO' otherwise. mid = len(s) // 2 first_half = s[:mid] second_half = s[mid:] if first_half == second_half[::-1]: return 'YES' else: return 'NO' def verify_messages(T, messages): Processes multiple test cases to check if each string can be split into valid palindromic pairs. Args: T (int): Number of test cases. messages (list of str): List of strings to be verified. Returns: list of str: Results for each test case, 'YES' or 'NO'. return [can_form_palindromic_pair(s) for s in messages]"},{"question":"def min_roads_to_block(n: int, roads: List[Tuple[int, int]]) -> int: Given a number of towns \`n\` and a list of roads connecting them, find the minimum number of roads whose removal would disconnect the kingdom into two parts such that it is not possible to travel from one part to the other. >>> min_roads_to_block(4, [(1, 2), (1, 3), (2, 4)]) 1 >>> min_roads_to_block(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 1 >>> min_roads_to_block(3, [(1, 2), (1, 3)]) 1 >>> min_roads_to_block(5, [(1, 2), (2, 3), (3, 4), (3, 5)]) 1 >>> min_roads_to_block(2, [(1, 2)]) 1","solution":"def min_roads_to_block(n, roads): Given a tree with n nodes (towns) and n-1 edges (roads), this function returns the minimum number of roads whose removal would disconnect the graph. # Since the graph is a tree, removing any single edge will disconnect the graph. return 1"},{"question":"def count_unique_integers(n: int, integers_list: List[int]) -> int: Returns the count of unique integers in the list. Parameters: n (int): The number of elements in the list. integers_list (list of int): The list of integers. Returns: int: The count of unique integers in the list. >>> count_unique_integers(6, [1, 2, 2, 3, 4, 4]) 4 >>> count_unique_integers(5, [7, 7, 7, 7, 7]) 1","solution":"def count_unique_integers(n, integers_list): Returns the count of unique integers in the list. Parameters: n (int): The number of elements in the list. integers_list (list of int): The list of integers. Returns: int: The count of unique integers in the list. return len(set(integers_list))"},{"question":"def find_anagrams(text: List[str]) -> Union[str, Tuple[str, str]]: Finds and returns two words that are anagrams of each other in the given text. If no such pair exists, returns \\"NO ANAGRAMS\\". >>> find_anagrams(['listen silent']) ('listen', 'silent') >>> find_anagrams(['no anagrams here']) 'NO ANAGRAMS' >>> find_anagrams(['bat tab', 'word sword', 'random words']) ('bat', 'tab') def solve(tests: List[List[str]]) -> List[str]: Solves the problem for multiple test cases. >>> solve([['listen silent', 'no anagrams here']]) ['listen silent'] >>> solve([['bat tab', 'word sword', 'random words']]) ['bat tab'] >>> solve([['no anagram', 'another line']]) ['NO ANAGRAMS'] >>> solve([['hello olleh', 'different words']]) ['hello olleh'] >>> solve([['parallel radar', 'silent listen']]) ['silent listen']","solution":"def find_anagrams(text): Finds and returns two words that are anagrams of each other in the given text. If no such pair exists, return \\"NO ANAGRAMS\\". word_dict = {} for line in text: words = line.split() for word in words: sorted_word = ''.join(sorted(word)) if sorted_word in word_dict: return word_dict[sorted_word], word word_dict[sorted_word] = word return \\"NO ANAGRAMS\\" def solve(tests): results = [] for test in tests: anagram_pair = find_anagrams(test) if isinstance(anagram_pair, tuple): results.append(' '.join(anagram_pair)) else: results.append(anagram_pair) return results"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the string s such that no two adjacent characters are the same. If no such arrangement is possible, return an empty string. >>> rearrange_string(\\"aaabb\\") \\"ababa\\" >>> rearrange_string(\\"aaab\\") \\"\\" >>> rearrange_string(\\"aab\\") \\"aba\\" pass def test_example1(): assert rearrange_string('aaabb') in ['ababa', 'abbaa', 'baaba', 'baaab'] def test_example2(): assert rearrange_string('aaab') == '' def test_example3(): assert rearrange_string('aab') in ['aba'] def test_single_char(): assert rearrange_string('a') == 'a' def test_two_distinct_chars(): assert rearrange_string('ab') == 'ab' def test_multiple_valid_solutions(): output = rearrange_string('aabb') assert output in ['abab', 'baba'] def test_no_valid_solution(): assert rearrange_string('aaaa') == '' def test_large_input(): # Test a large input to check for performance s = 'a' * 50000 + 'b' * 50000 rearranged = rearrange_string(s) assert rearranged != '' for i in range(len(rearranged) - 1): assert rearranged[i] != rearranged[i + 1]","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Rearranges the string s such that no two adjacent characters are the same. If no such arrangement is possible, return an empty string. # Frequency count of characters in the string counter = Counter(s) max_heap = [] # Create a max heap based on character frequencies for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if max_heap: freq, char = heappop(max_heap) else: return \\"\\" result.append(char) # Since we are using a max heap (using negative frequencies), increment the frequency if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Because freq is negative, add 1 to decrease frequency return \\"\\".join(result)"},{"question":"def maxHistogramArea(heights): # Helper function to calculate the maximum area in a histogram pass def maxRectangle(matrix): Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. >>> maxRectangle([[1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1], [1, 0, 0, 1]]) 4 >>> maxRectangle([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> maxRectangle([[0, 0], [0, 1]]) 1 pass def findLargestRectangleInMatrix(T, test_cases): results = [] for case in test_cases: R, C, matrix = case results.append(maxRectangle(matrix)) return results","solution":"def maxHistogramArea(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def maxRectangle(matrix): if not matrix: return 0 max_area = 0 current_row = [0] * len(matrix[0]) for row in matrix: for index in range(len(row)): current_row[index] = current_row[index] + 1 if row[index] == 1 else 0 max_area = max(max_area, maxHistogramArea(current_row)) return max_area def findLargestRectangleInMatrix(T, test_cases): results = [] for case in test_cases: R, C, matrix = case results.append(maxRectangle(matrix)) return results"},{"question":"from typing import List, Tuple def find_course_order(N: int, M: int, course_pairs: List[Tuple[int, int]]) -> List[int]: Determine the order of course completion given the prerequisites. >>> find_course_order(4, 3, [(2, 1), (3, 2), (4, 3)]) [1, 2, 3, 4] >>> find_course_order(3, 3, [(1, 2), (2, 3), (3, 1)]) []","solution":"from collections import defaultdict, deque def find_course_order(N, M, course_pairs): # Create a graph to store the prerequisites graph = defaultdict(list) indegree = [0] * (N + 1) # Build the graph and the indegree array for a, b in course_pairs: graph[b].append(a) indegree[a] += 1 # Perform topological sort using Kahn's algorithm queue = deque([i for i in range(1, N + 1) if indegree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all courses are not in the order, return an empty list if len(order) != N: return [] return order"},{"question":"def max_distance(n, students): Given the number of students and a list of tuples where each tuple contains (initial energy, energy loss per kilometer), this function calculates the maximum distance each student can run before their energy depletes. Parameters: n (int): The number of students students (list of tuples): A list containing tuples of (E, L) for each student Returns: list of int: A list of maximum distances each student can run >>> max_distance(3, [(10, 2), (15, 3), (20, 4)]) [5, 5, 5] >>> max_distance(1, [(1, 1)]) [1] >>> max_distance(2, [(1, 1000), (1000, 1)]) [0, 1000]","solution":"def max_distance(n, students): Given the number of students and a list of tuples where each tuple contains (initial energy, energy loss per kilometer), this function calculates the maximum distance each student can run before their energy depletes. Parameters: n (int): The number of students students (list of tuples): A list containing tuples of (E, L) for each student Returns: list of int: A list of maximum distances each student can run distances = [] for energy, loss_per_km in students: max_dist = energy // loss_per_km distances.append(max_dist) return distances"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Computes the maximum profit that can be achieved from a single transaction. Parameters: prices (List[int]): List of stock prices where prices[i] is the price of the stock on the ith day. Returns: int: Maximum profit that can be achieved. If no profit can be made, returns 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Computes the maximum profit that can be achieved from a single transaction. Parameters: prices (List[int]): List of stock prices where prices[i] is the price of the stock on the ith day. Returns: int: Maximum profit that can be achieved. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2","solution":"def min_operations(s, t): Returns the minimum number of operations required to convert string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # Deleting all characters from s[0:i] for j in range(n + 1): dp[0][j] = j # Inserting all characters to form t[0:j] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def max_pieces_of_circle(n: int) -> int: Calculate the maximum number of pieces of a circle that can be achieved with up to n straight cuts. >>> max_pieces_of_circle(3) 7 >>> max_pieces_of_circle(5) 16","solution":"def max_pieces_of_circle(n): Returns the maximum number of pieces a circle can be divided into with n straight cuts. if n < 0 or n > 10**6: raise ValueError(\\"Invalid input. n must be in the range 0 <= n <= 10^6\\") return (n**2 + n + 2) // 2"},{"question":"def twoSum(n: int, arr: List[int], k: int) -> int: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] is equal to k. Parameters: n (int): The number of elements in the array. arr (list of int): The array of integers. k (int): The target sum. Returns: int: 1 if such indices exist, otherwise 0. Examples: >>> twoSum(5, [1, 2, 3, 9, 10], 8) 0 >>> twoSum(4, [1, 20, 3, 4], 24) 1","solution":"def twoSum(n, arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] = k. Parameters: n (int): The number of elements in the array. arr (list of int): The array of integers. k (int): The target sum. Returns: int: 1 if such indices exist, otherwise 0. seen = set() for value in arr: if k - value in seen: return 1 seen.add(value) return 0"},{"question":"def process_test_cases(test_cases: List[str]) -> List[str]: Determine if each binary tree in the given test cases satisfies the BinarySumTree property. >>> process_test_cases([\\"1 2 3 N N 2 1\\"]) [\\"Case #1: No\\"] >>> process_test_cases([\\"10 4 6 1 3 2 4\\"]) [\\"Case #1: Yes\\"] >>> process_test_cases([\\"1 2 N\\"]) [\\"Case #1: Yes\\"] >>> process_test_cases([\\"15 5 10 1 4 6 4\\"]) [\\"Case #1: Yes\\"] >>> process_test_cases([\\"1 1 3 1 0 1 2\\"]) [\\"Case #1: No\\"] >>> process_test_cases([\\"6 3 3 1 2 N N\\"]) [\\"Case #1: Yes\\"] >>> process_test_cases([ \\"1 2 3 N N 2 1\\", \\"10 4 6 1 3 2 4\\", \\"1 2 N\\" ]) [ \\"Case #1: No\\", \\"Case #2: Yes\\", \\"Case #3: Yes\\" ]","solution":"from collections import deque def is_binary_sum_tree(tree): if not tree or tree[0] == 'N': return True idx = 0 q = deque([tree[idx]]) idx += 1 while q: node = q.popleft() if node == 'N': continue left_val = tree[idx] if idx < len(tree) else 'N' if left_val != 'N': q.append(left_val) idx += 1 right_val = tree[idx] if idx < len(tree) else 'N' if right_val != 'N': q.append(right_val) idx += 1 if node != 'N' and left_val != 'N' and right_val != 'N': if node != str(int(left_val) + int(right_val)): return False return True def process_test_cases(test_cases): results = [] for i, case in enumerate(test_cases): result = is_binary_sum_tree(case.split()) results.append(f\\"Case #{i+1}: {'Yes' if result else 'No'}\\") return results"},{"question":"def appearance_count(lst, num): Given a list \`lst\` and an integer \`num\`, returns the number of times each element up to and including \`num\` appears in the list. The result should be returned as a dictionary where the keys are the elements and the values are their respective counts. >>> appearance_count([1, 2, 2, 3, 4, 4, 4, 5], 4) == {1: 1, 2: 2, 3: 1, 4: 3} >>> appearance_count([5, 5, 5, 6, 6, 7], 5) == {5: 3} >>> appearance_count([1, 1, 2, 3, 3, 3], 1) == {1: 2} >>> appearance_count([6, 7, 8, 9], 5) == {} >>> appearance_count([1, 2, 3, 4], 6) == {1: 1, 2: 1, 3: 1, 4: 1} >>> appearance_count([-1, -2, -2, -3, 0, 1, 2], 0) == {-1: 1, -2: 2, -3: 1, 0: 1} >>> appearance_count([4, 4, 4, 4, 4, 4], 4) == {4: 6}","solution":"def appearance_count(lst, num): Returns a dictionary where the keys are elements in lst up to and including num, and the values are the respective counts of those elements. count_dict = {} for el in lst: if el <= num: if el in count_dict: count_dict[el] += 1 else: count_dict[el] = 1 return count_dict"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a given string s is a palindrome. >>> is_palindrome('racecar') True >>> is_palindrome('hello') False >>> is_palindrome('A Santa at NASA') True >>> is_palindrome('No lemon, no melon') True >>> is_palindrome('world') False def find_palindromes(words: List[str]) -> List[str]: Returns a list of strings from the input list that are palindromes. >>> find_palindromes(['racecar', 'hello', 'A Santa at NASA', 'No lemon, no melon']) ['racecar', 'A Santa at NASA', 'No lemon, no melon'] >>> find_palindromes(['palindrome', 'civic', 'level', 'world']) ['civic', 'level'] >>> find_palindromes(['hello', 'world']) [] >>> find_palindromes([]) [] >>> find_palindromes(['madam', 'deified', 'civic', 'radar', 'level']) ['madam', 'deified', 'civic', 'radar', 'level'] >>> find_palindromes(['Step on no pets', 'Eva, can I see bees in a cave?', 'No lemon, no melon']) ['Step on no pets', 'Eva, can I see bees in a cave?', 'No lemon, no melon']","solution":"def is_palindrome(s): Helper function to check if a given string s is a palindrome # Remove non-alphanumeric characters and convert to lowercase normalized_s = ''.join(char.lower() for char in s if char.isalnum()) return normalized_s == normalized_s[::-1] def find_palindromes(words): Returns a list of strings from the input list that are palindromes. return [word for word in words if is_palindrome(word)]"},{"question":"def two_sum(nums: list[int], target: int) -> tuple[int, int]: Finds two distinct elements in nums that sum up to target and returns their indices as a tuple. Assumes there is exactly one solution. Args: nums (list[int]): The list of integers. target (int): The target sum. Returns: tuple[int, int]: The indices of the two numbers whose sum is equal to target. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 19) (8, 9) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([-10, 20, 10, -20, 30], 0) (0, 2) >>> two_sum([3, 3, 4, 7], 6) (0, 1) pass","solution":"def two_sum(nums: list[int], target: int) -> tuple[int, int]: Finds two distinct elements in nums that sum up to target and returns their indices as a tuple. Assumes there is exactly one solution. Args: nums (list[int]): The list of integers. target (int): The target sum. Returns: tuple[int, int]: The indices of the two numbers whose sum is equal to target. # Dictionary to store the difference between target and the current element # as key and its index as value. num_to_index = {} for index, num in enumerate(nums): difference = target - num if difference in num_to_index: return num_to_index[difference], index num_to_index[num] = index"},{"question":"class Library: A class to manage a library's inventory of books. - addBook(title, year: int) -> bool: Adds a book to the library with the given title and publication year. Returns false if the book already exists with a different year. - setYear(title, year: int) -> bool: Updates the publication year of the given book. Returns false if the book does not exist. - getYear(title) -> int: Returns the publication year of the given book. If the book does not exist, returns -1. - removeBook(title) -> bool: Removes the book with the given title from the library. Returns false if the book does not exist. - getBooks() -> List[str]: Returns the titles of all books in the library in alphabetical order. def __init__(self): Initialize the library with no books. def addBook(self, title: str, year: int) -> bool: >>> lib = Library() >>> lib.addBook(\\"1984\\", 1949) True >>> lib.addBook(\\"1984\\", 1948) False def setYear(self, title: str, year: int) -> bool: >>> lib = Library() >>> lib.addBook(\\"1984\\", 1949) >>> lib.setYear(\\"1984\\", 1950) True >>> lib.setYear(\\"Brave New World\\", 1932) False def getYear(self, title: str) -> int: >>> lib = Library() >>> lib.addBook(\\"1984\\", 1949) >>> lib.getYear(\\"1984\\") 1949 >>> lib.getYear(\\"Brave New World\\") -1 def removeBook(self, title: str) -> bool: >>> lib = Library() >>> lib.addBook(\\"1984\\", 1949) >>> lib.removeBook(\\"1984\\") True >>> lib.removeBook(\\"Brave New World\\") False def getBooks(self) -> List[str]: >>> lib = Library() >>> lib.addBook(\\"1984\\", 1949) >>> lib.addBook(\\"Brave New World\\", 1932) >>> lib.getBooks() [\\"1984\\", \\"Brave New World\\"] # The following tests can be used for validation def test_addBook_new_book(): lib = Library() assert lib.addBook(\\"1984\\", 1949) == True assert lib.addBook(\\"Brave New World\\", 1932) == True def test_addBook_existing_book_same_year(): lib = Library() lib.addBook(\\"1984\\", 1949) assert lib.addBook(\\"1984\\", 1949) == True def test_addBook_existing_book_different_year(): lib = Library() lib.addBook(\\"1984\\", 1949) assert lib.addBook(\\"1984\\", 1950) == False def test_setYear_existing_book(): lib = Library() lib.addBook(\\"1984\\", 1949) assert lib.setYear(\\"1984\\", 1950) == True assert lib.getYear(\\"1984\\") == 1950 def test_setYear_non_existent_book(): lib = Library() assert lib.setYear(\\"1984\\", 1950) == False def test_getYear_existing_book(): lib = Library() lib.addBook(\\"1984\\", 1949) assert lib.getYear(\\"1984\\") == 1949 def test_getYear_non_existent_book(): lib = Library() assert lib.getYear(\\"1984\\") == -1 def test_removeBook_existing_book(): lib = Library() lib.addBook(\\"1984\\", 1949) assert lib.removeBook(\\"1984\\") == True assert lib.getYear(\\"1984\\") == -1 def test_removeBook_non_existent_book(): lib = Library() assert lib.removeBook(\\"1984\\") == False def test_getBooks(): lib = Library() lib.addBook(\\"1984\\", 1949) lib.addBook(\\"Brave New World\\", 1932) assert lib.getBooks() == [\\"1984\\", \\"Brave New World\\"] lib.addBook(\\"Animal Farm\\", 1945) assert lib.getBooks() == [\\"1984\\", \\"Animal Farm\\", \\"Brave New World\\"] def test_getBooks_empty_library(): lib = Library() assert lib.getBooks() == []","solution":"class Library: def __init__(self): self.books = {} def addBook(self, title, year): if title in self.books: if self.books[title] == year: return True else: return False self.books[title] = year return True def setYear(self, title, year): if title not in self.books: return False self.books[title] = year return True def getYear(self, title): if title not in self.books: return -1 return self.books[title] def removeBook(self, title): if title not in self.books: return False del self.books[title] return True def getBooks(self): return sorted(self.books.keys())"},{"question":"def longest_peak_subarray(arr): Returns the length of the longest peak subarray. >>> longest_peak_subarray([1, 2, 3, 4, 5, 3, 1, 2, 3, 4, 0, 10]) 7 >>> longest_peak_subarray([1, 2, 2, 1, 1]) 0","solution":"def longest_peak_subarray(arr): Returns the length of the longest peak subarray. n = len(arr) if n < 3: return 0 longest_peak_length = 0 i = 1 while i < n - 1: is_peak = arr[i - 1] < arr[i] > arr[i + 1] if not is_peak: i += 1 continue # Find left boundary of the peak left = i - 2 while left >= 0 and arr[left] < arr[left + 1]: left -= 1 left += 1 # Find right boundary of the peak right = i + 2 while right < n and arr[right] < arr[right - 1]: right += 1 current_peak_length = right - left if current_peak_length > longest_peak_length: longest_peak_length = current_peak_length # Move i to the end of the current peak i = right return longest_peak_length"},{"question":"def self_dividing_number(num: int) -> bool: Checks if a number is a self-dividing number. >>> self_dividing_number(128) True >>> self_dividing_number(102) False >>> self_dividing_number(1) True >>> self_dividing_number(11) True >>> self_dividing_number(12) True >>> self_dividing_number(15) True def self_dividing_numbers(left: int, right: int) -> List[int]: Returns a list of all self-dividing numbers between left and right, inclusive. >>> self_dividing_numbers(1, 22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] >>> self_dividing_numbers(10, 15) [11, 12, 15] >>> self_dividing_numbers(15, 20) [15] >>> self_dividing_numbers(1, 5) [1, 2, 3, 4, 5]","solution":"def self_dividing_number(num): Checks if a number is a self-dividing number. original_num = num while num > 0: digit = num % 10 if digit == 0 or original_num % digit != 0: return False num //= 10 return True def self_dividing_numbers(left, right): Returns a list of all self-dividing numbers between left and right, inclusive. return [num for num in range(left, right + 1) if self_dividing_number(num)]"},{"question":"import math from typing import List def is_fibonacci(n: int) -> str: Determines if a given number n is a Fibonacci number. A number is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. Parameters: n (int): The number to check Returns: str: \\"Yes\\" if the number is a Fibonacci number, otherwise \\"No\\" Examples: >>> is_fibonacci(5) \\"Yes\\" >>> is_fibonacci(6) \\"No\\"","solution":"import math def is_fibonacci(n): Determines if a given number n is a Fibonacci number. A number is a Fibonacci number if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. Parameters: n (int): The number to check Returns: str: \\"Yes\\" if the number is a Fibonacci number, otherwise \\"No\\" def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x if is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4): return \\"Yes\\" else: return \\"No\\""},{"question":"def longest_alpha_substring_length(s: str) -> int: Returns the length of the longest substring where characters are in alphabetical order. >>> longest_alpha_substring_length(\\"abcaacd\\") 3 >>> longest_alpha_substring_length(\\"a\\") 1 >>> longest_alpha_substring_length(\\"aaaaaa\\") 1 >>> longest_alpha_substring_length(\\"abcdefg\\") 7 >>> longest_alpha_substring_length(\\"abababab\\") 2 >>> longest_alpha_substring_length(\\"\\") 0 >>> longest_alpha_substring_length(\\"gfedcba\\") 1 >>> longest_alpha_substring_length(\\"AbCdEfGh\\") 2 >>> longest_alpha_substring_length(\\"abcabcabc\\") 3","solution":"def longest_alpha_substring_length(s): Returns the length of the longest substring where characters are in alphabetical order. max_length = 1 current_length = 1 if not s: return 0 for i in range(1, len(s)): if s[i] > s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def subset_sum_exists(arr, X): Determines if there exists a subset of the array such that the sum of the subset equals X. Parameters: arr (list): List of positive integers. X (int): Target sum. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". Examples: >>> subset_sum_exists([2, 3, 7, 8, 10], 11) \\"YES\\" >>> subset_sum_exists([1, 2, 3, 4, 5], 20) \\"NO\\"","solution":"def subset_sum_exists(arr, X): Determines if there exists a subset of arr that adds up to X. Parameters: arr (list): List of positive integers. X (int): Target sum. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". n = len(arr) dp = [[False] * (X + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, X + 1): if arr[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return \\"YES\\" if dp[n][X] else \\"NO\\""},{"question":"def min_completion_time(n, task_durations, k): Function to determine the earliest time by which all the tasks are completed. Parameters: n (int): Number of tasks. task_durations (list): List containing the duration of each task. k (int): Number of employees. Returns: int: Earliest time by which all the tasks are completed. pass # Unit Tests def test_single_task_single_employee(): assert min_completion_time(1, [10], 1) == 10 def test_multiple_tasks_single_employee(): assert min_completion_time(5, [10, 15, 20, 25, 30], 1) == 100 def test_five_tasks_two_employees(): assert min_completion_time(5, [5, 8, 3, 7, 2], 2) == 13 def test_three_tasks_three_employees(): assert min_completion_time(3, [4, 5, 6], 3) == 6 def test_even_distribution_tasks(): assert min_completion_time(6, [2, 2, 2, 2, 2, 2], 3) == 4 def test_more_employees_than_tasks(): assert min_completion_time(3, [1, 2, 3], 5) == 3 def test_large_tasks_small_workers(): assert min_completion_time(4, [100000, 100000, 100000, 100000], 2) == 200000","solution":"import heapq def min_completion_time(n, task_durations, k): Function to determine the earliest time by which all the tasks are completed. Parameters: n (int): Number of tasks. task_durations (list): List containing the duration of each task. k (int): Number of employees. Returns: int: Earliest time by which all the tasks are completed. if k >= n: return max(task_durations) # Use a min-heap to track the current workload assigned to each employee. employee_workloads = [0] * k heapq.heapify(employee_workloads) # Assign each task duration to the employee with the least current workload. for duration in sorted(task_durations, reverse=True): min_workload = heapq.heappop(employee_workloads) heapq.heappush(employee_workloads, min_workload + duration) # The time to complete all tasks will be determined by the employee with the maximum workload. return max(employee_workloads)"},{"question":"def max_height_difference(N: int, heights: List[int]) -> int: Determine the maximum height difference between any two adjacent students in an optimal lineup sorted in non-decreasing order. :param N: Integer, number of students :param heights: List of integers, heights of students :return: Integer, the maximum difference in height between any two adjacent students in the optimized lineup >>> max_height_difference(5, [4, 2, 3, 5, 1]) 1 >>> max_height_difference(1, [10]) 0 >>> max_height_difference(2, [5, 5]) 0 >>> max_height_difference(2, [3, 8]) 5 >>> max_height_difference(5, [1, 2, 3, 4, 5]) 1 >>> max_height_difference(5, [5, 4, 3, 2, 1]) 1 >>> max_height_difference(5, [1, 10, 20, 30, 40]) 10 >>> max_height_difference(6, [4, 2, 2, 3, 5, 1]) 1 >>> max_height_difference(4, [7, 7, 7, 7]) 0","solution":"def max_height_difference(N, heights): Function to determine the maximum difference in height between any two adjacent students in the optimal lineup. :param N: Integer, number of students :param heights: List of integers, heights of students :return: Integer, the maximum difference in height between any two adjacent students in non-decreasing order if N <= 1: return 0 # Sort the heights array heights.sort() # Initialize the maximum difference to 0 max_diff = 0 # Iterate through the sorted list to find the maximum difference between adjacent elements for i in range(1, N): max_diff = max(max_diff, heights[i] - heights[i - 1]) return max_diff"},{"question":"def findUnique(nums: List[int]) -> int: Given a list of integers, where each integer appears exactly twice, except for one integer that appears only once, identify the integer that appears only once. >>> findUnique([4, 3, 2, 4, 1, 3, 2]) 1 >>> findUnique([7, 2, 2, 3, 3]) 7 >>> findUnique([10, 10, 3, 4, 4]) 3","solution":"def findUnique(nums): Finds the unique integer in a list where every other integer appears exactly twice except for one. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"def findBestDays(prices): Given a list of integers, each element represents the price of a stock on a particular day. Determines the maximum profit that can be made by buying and then later selling one share of the stock. Args: prices (List[int]): List of stock prices by day Returns: Tuple[int, int]: A tuple of two integers representing the best days (0-based indices) to buy and sell to achieve maximum profit. If no profit can be made, returns (-1, -1). Example: >>> findBestDays([7, 1, 5, 3, 6, 4]) (1, 4) >>> findBestDays([7, 6, 4, 3, 1]) (-1, -1) pass from solution import findBestDays def test_example_1(): assert findBestDays([7, 1, 5, 3, 6, 4]) == (1, 4) def test_example_2(): assert findBestDays([7, 6, 4, 3, 1]) == (-1, -1) def test_no_prices(): assert findBestDays([]) == (-1, -1) def test_single_price(): assert findBestDays([10]) == (-1, -1) def test_two_prices_profit(): assert findBestDays([1, 5]) == (0, 1) def test_two_prices_no_profit(): assert findBestDays([5, 1]) == (-1, -1) def test_all_same_prices(): assert findBestDays([5, 5, 5, 5, 5]) == (-1, -1) def test_decreasing_then_increasing(): assert findBestDays([10, 9, 2, 3, 6, 7]) == (2, 5) def test_increasing_then_decreasing(): assert findBestDays([1, 3, 6, 7, 2, 1]) == (0, 3)","solution":"def findBestDays(prices): Returns a tuple containing two integers representing the days on which to buy and sell the stock to achieve the maximum profit. If no profit can be made, returns (-1, -1). if not prices or len(prices) < 2: return (-1, -1) min_price = prices[0] min_day = 0 max_profit = 0 buy_day = sell_day = 0 for i in range(1, len(prices)): if prices[i] < min_price: min_price = prices[i] min_day = i elif prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_day sell_day = i if max_profit == 0: return (-1, -1) return (buy_day, sell_day)"},{"question":"from typing import List def min_repaints_to_avoid_adjacent_genres(n: int, genres: List[int]) -> int: Calculate the minimum time required to repaint books so that no two adjacent books have the same genre. >>> min_repaints_to_avoid_adjacent_genres(5, [1, 2, 1, 2, 1]) 0 >>> min_repaints_to_avoid_adjacent_genres(3, [1, 1, 2]) 1","solution":"def min_repaints_to_avoid_adjacent_genres(n, genres): if n == 1: return 0 repaint_count = 0 for i in range(1, n): if genres[i] == genres[i - 1]: repaint_count += 1 # Find a new genre that's different from the previous and next genre for new_genre in range(1, 11): if (i == n-1 or new_genre != genres[i+1]) and new_genre != genres[i-1]: genres[i] = new_genre break return repaint_count"},{"question":"def calculate_total_rental_cost(days_rented: List[int]) -> int: Calculates the total rental cost for all books combined based on the number of days each book was rented. :param days_rented: List of integers where each integer represents the number of days a book was rented :return: Integer total rental cost Examples: >>> calculate_total_rental_cost([4, 7, 10]) 22 >>> calculate_total_rental_cost([5, 3]) 10","solution":"def calculate_total_rental_cost(days_rented): Calculates the total rental cost for all books combined based on the number of days each book was rented. :param days_rented: List of integers where each integer represents the number of days a book was rented :return: Integer total rental cost total_cost = 0 for days in days_rented: if days <= 5: total_cost += 5 else: total_cost += 5 + (days - 5) return total_cost"},{"question":"def count_badges(test_cases): Determine the number of participants who will receive badges based on their scores. Each participant will receive a badge if their score is the maximum among all scores recorded thus far when iterated from left to right. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple represents a test case. Returns: List[int]: List of integers, each integer representing the number of participants who will receive badges in the corresponding test case. Example: >>> count_badges([(5, [1, 2, 3, 2, 5]), (4, [1, 2, 3, 4])]) [4, 4]","solution":"def count_badges(test_cases): results = [] for case in test_cases: N = case[0] scores = case[1] max_score = -1 badges = 0 for score in scores: if score > max_score: max_score = score badges += 1 results.append(badges) return results"},{"question":"def can_robot_reach_destination(N, M, Sx, Sy, Dx, Dy, obstacles): Determine if the robot can reach its destination without hitting any obstacles. >>> can_robot_reach_destination(5, 5, 1, 1, 5, 5, [(1, 2), (2, 3), (3, 4)]) 'ROBOT REACHED' >>> can_robot_reach_destination(5, 5, 1, 1, 5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 4)]) 'OBSTACLE DETECTED' >>> can_robot_reach_destination(3, 3, 1, 1, 3, 3, []) 'ROBOT REACHED' >>> can_robot_reach_destination(4, 4, 2, 2, 2, 2, [(1, 1)]) 'ROBOT REACHED' >>> can_robot_reach_destination(1000, 1000, 1, 1, 1000, 1000, []) 'ROBOT REACHED' >>> can_robot_reach_destination(1000, 1000, 1, 1, 1000, 1000, [(x, 500) for x in range(1, 1001)]) 'OBSTACLE DETECTED'","solution":"from collections import deque def can_robot_reach_destination(N, M, Sx, Sy, Dx, Dy, obstacles): grid = [[0]*M for _ in range(N)] for x, y in obstacles: grid[x-1][y-1] = 1 # Mark obstacles in the grid def is_valid_move(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(Sx-1, Sy-1)]) grid[Sx-1][Sy-1] = -1 # Mark the start point to avoid revisiting while queue: x, y = queue.popleft() if x == Dx-1 and y == Dy-1: return \\"ROBOT REACHED\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny): queue.append((nx, ny)) grid[nx][ny] = -1 # Mark as visited return \\"OBSTACLE DETECTED\\" def parse_input_and_run(): import sys input = sys.stdin.read data = input().strip().split() N, M, Sx, Sy, Dx, Dy = map(int, data[:6]) K = int(data[6]) obstacles = [] for i in range(K): x, y = map(int, data[7 + 2*i:9 + 2*i]) obstacles.append((x, y)) result = can_robot_reach_destination(N, M, Sx, Sy, Dx, Dy, obstacles) print(result)"},{"question":"from typing import List, Tuple def construct_sequence(M: int, Y: int) -> List[int]: Constructs an array B of length M such that the sum of elements of all contiguous sub-arrays of length Y is odd. If it's impossible to construct such an array, return [-1]. Args: M (int): The length of the array B. Y (int): The length of the contiguous sub-arrays. Returns: List[int]: The constructed array B or [-1] if it's impossible to construct such an array. >>> construct_sequence(5, 1) [1, 3, 5, 7, 9] >>> construct_sequence(5, 2) [1, 1, 1, 1, 1] >>> construct_sequence(5, 3) [2, 1, 2, 1, 2] def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[List[int]]: Processes multiple test cases for constructing sequences. Args: test_cases (List[Tuple[int, int]]): A list of tuples, each containing M and Y. Returns: List[List[int]]: A list of results for each test case. >>> process_test_cases([(5, 1), (5, 2), (5, 3)]) [[1, 3, 5, 7, 9], [1, 1, 1, 1, 1], [2, 1, 2, 1, 2]] >>> process_test_cases([(6, 4), (7, 5), (5, 10**9)]) [[1, 1, 1, 1, 1, 1], [2, 1, 2, 1, 2, 1, 2], [1, 1, 1, 1, 1]] >>> process_test_cases([(1, 1), (3, 2)]) [[1], [1, 1, 1]]","solution":"def construct_sequence(M, Y): if Y == 1: # Any odd number sequence will work return [i * 2 + 1 for i in range(M)] elif Y % 2 == 0: # Y is even, all elements can be 1 to get all even-length subarray sums even return [1] * M else: # Y is odd, mix of odd and even to get odd-length subarray sums odd sequence = [] for i in range(M): if i % 2 == 0: sequence.append(2) else: sequence.append(1) return sequence def process_test_cases(test_cases): results = [] for M, Y in test_cases: result = construct_sequence(M, Y) if result: results.append(result) else: results.append([-1]) return results # Read input def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): M = int(data[index]) Y = int(data[index + 1]) test_cases.append((M, Y)) index += 2 results = process_test_cases(test_cases) for result in results: if result == [-1]: print(-1) else: print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"def nextHigherWithSameBits(N: int) -> int: Given a non-negative integer N, returns the next higher number with the same number of set bits (1s) in its binary representation. >>> nextHigherWithSameBits(5) 6 >>> nextHigherWithSameBits(8) 16","solution":"def nextHigherWithSameBits(N): Returns the next higher number with the same number of set bits as N. # Compute the rightmost non-trailing zero bit right_most_non_trailing_zero = N & -N next_higher_one_bit = N + right_most_non_trailing_zero right_ones_pattern = N ^ next_higher_one_bit right_ones_pattern = right_ones_pattern // right_most_non_trailing_zero right_ones_pattern >>= 2 next_number = next_higher_one_bit | right_ones_pattern return next_number"},{"question":"def has_cycle_of_length_four(N: int, M: int, edges: List[Tuple[int, int]]) -> str: Determine if an undirected graph contains any simple cycle of length exactly 4. Args: N (int): The number of vertices in the graph. M (int): The number of edges in the graph. edges (List[Tuple[int, int]]): The edges in the graph. Returns: str: \\"YES\\" if there exists a cycle of length exactly 4, otherwise \\"NO\\". Examples: >>> has_cycle_of_length_four(5, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) \\"YES\\" >>> has_cycle_of_length_four(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\"","solution":"def has_cycle_of_length_four(N, M, edges): from collections import defaultdict graph = defaultdict(list) # Build the adjacency list for the graph for u, v in edges: graph[u].append(v) graph[v].append(u) # Check for any cycles of length 4 for node in range(1, N + 1): # A dictionary to keep track of two-hops neighbors second_hop_neighbors = defaultdict(list) for neighbor in graph[node]: for second_neighbor in graph[neighbor]: if second_neighbor != node: second_hop_neighbors[second_neighbor].append(neighbor) for second_neighbor in second_hop_neighbors: if len(second_hop_neighbors[second_neighbor]) > 1: return \\"YES\\" return \\"NO\\""},{"question":"def process_grid(n: int, m: int, grid: List[List[int]]) -> List[int]: Given an n x m grid filled with integers, find the largest prime number within each row. If a row does not contain any prime number, return -1 for that row. >>> process_grid(3, 4, [[10, 15, 3, 7], [5, 6, 8, 13], [1, 4, 8, 6]]) [7, 13, -1] >>> process_grid(1, 4, [[10, 11, 2, 7]]) [11] >>> process_grid(1, 4, [[8, 10, 12, 14]]) [-1] >>> process_grid(3, 3, [[8, 10, 12], [14, 18, 20], [21, 22, 24]]) [-1, -1, -1] >>> process_grid(3, 4, [[2, 3, 4, 5], [6, 8, 9, 10], [13, 17, 19, 23]]) [5, -1, 23] >>> process_grid(3, 4, [[10, 15, 3, 1000003], [13, 6, 8, 999983], [1, 4, 8, 6]]) [1000003, 999983, -1]","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def largest_prime_in_rows(grid): Finds the largest prime number within each row of the grid. If a row does not contain any prime number, return -1 for that row. result = [] for row in grid: largest_prime = -1 for num in row: if is_prime(num): largest_prime = max(largest_prime, num) result.append(largest_prime) return result def process_grid(n, m, grid): Process the input grid and return the largest prime number in each row. return largest_prime_in_rows(grid)"},{"question":"from typing import List def canFormPalindrome(s: str) -> str: Returns \\"YES\\" if any permutation of the input string s can form a palindrome, otherwise returns \\"NO\\". >>> canFormPalindrome(\\"civic\\") 'YES' >>> canFormPalindrome(\\"ivicc\\") 'YES' >>> canFormPalindrome(\\"hello\\") 'NO'","solution":"def canFormPalindrome(s): Returns \\"YES\\" if any permutation of the input string s can form a palindrome, otherwise returns \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be able to form a palindrome, there should be at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"import heapq import sys def shortest_paths_from_source(n, m, s, edges): Find the shortest time for the light to travel from the starting crystal to all other crystals within the palace. Args: n (int): Number of crystals (nodes). m (int): Number of transmission lines (edges). s (int): Starting crystal number. edges (list of tuples): Transmission lines where each tuple contains (u, v, l) representing a transmission line between crystal u and crystal v with length l. Returns: str: Newline separated shortest time it takes for light to travel from the starting crystal to each other crystal. If a crystal is unreachable, return -1 for that crystal. Example: >>> n = 5 >>> m = 6 >>> s = 1 >>> edges = [ ... (1, 2, 3), ... (1, 3, 2), ... (2, 3, 1), ... (2, 4, 5), ... (3, 4, 8), ... (4, 5, 2) ... ] >>> shortest_paths_from_source(n, m, s, edges) '0n3n2n8n10' >>> n = 4 >>> m = 3 >>> s = 1 >>> edges = [ ... (1, 2, 1), ... (2, 3, 1), ... (3, 4, 1) ... ] >>> shortest_paths_from_source(n, m, s, edges) '0n1n2n3' pass","solution":"import heapq import sys def shortest_paths_from_source(n, m, s, edges): # Initialize the adjacency list graph = [[] for _ in range(n + 1)] for u, v, length in edges: graph[u].append((length, v)) graph[v].append((length, u)) # Dijkstra's algorithm to find the shortest path from source \`s\` distances = [float('inf')] * (n + 1) distances[s] = 0 min_heap = [(0, s)] # (distance, node) while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for length, v in graph[u]: distance = current_distance + length if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) # Print the result result = [] for i in range(1, n + 1): if distances[i] == float('inf'): result.append(\\"-1\\") else: result.append(str(distances[i])) return \\"n\\".join(result)"},{"question":"import math from typing import List, Tuple def find_common_page_count(A: int, B: int) -> int: Returns the smallest number of pages such that both Jamie and Sam can find a book with the same page count, given they select books with page counts that are multiples of A and B respectively. >>> find_common_page_count(4, 6) 12 >>> find_common_page_count(10, 15) 30 >>> find_common_page_count(7, 5) 35 pass def process_queries(queries: List[Tuple[int, int]]) -> List[int]: Processes a list of queries and returns the results for each query. Each query contains two integers A and B. >>> process_queries([(4, 6), (10, 15), (7, 5), (21, 6), (100, 75)]) [12, 30, 35, 42, 300] >>> process_queries([(1, 1), (100, 200), (15, 20)]) [1, 200, 60] pass","solution":"import math def find_common_page_count(A, B): Returns the smallest number of pages such that both Jamie and Sam can find a book with the same page count, given they select books with page counts that are multiples of A and B respectively. # Using the formula for LCM (Least Common Multiple) return abs(A * B) // math.gcd(A, B) def process_queries(queries): Processes a list of queries and returns the results for each query. Each query contains two integers A and B. results = [] for A, B in queries: results.append(find_common_page_count(A, B)) return results"},{"question":"from collections import defaultdict, deque def is_rotation_proof(n: int, m: int, highways: List[Tuple[int, int]]) -> str: Determines if the aerial highway network is rotation-proof. >>> is_rotation_proof(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) \\"YES\\" >>> is_rotation_proof(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\"","solution":"from collections import defaultdict, deque def is_rotation_proof(n, m, highways): Determines if the aerial highway network is rotation-proof. if m < n: # If there are fewer highways than stations, it's not rotation-proof return \\"NO\\" adjacency_list = defaultdict(list) reverse_adjacency_list = defaultdict(list) for u, v in highways: adjacency_list[u].append(v) reverse_adjacency_list[v].append(u) def bfs(start, adjacency): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbour in adjacency[node]: if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) return visited # Check if all nodes are reachable from node 1 visited_from_start = bfs(1, adjacency_list) # Check if we can reach node 1 from all nodes (using the reversed graph) visited_to_start = bfs(1, reverse_adjacency_list) # Check if all nodes are reachable from any node and vice versa is_reachable = all(visited_from_start[1:]) and all(visited_to_start[1:]) return \\"YES\\" if is_reachable else \\"NO\\" # Example usage: # highways = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)] # print(is_rotation_proof(4, 5, highways)) # Output: \\"YES\\""},{"question":"def symmetric_sum(nums): Returns a new list where each element is the sum of pairs of elements from the original list that are equidistant from the ends. Parameters: nums (list of int): List of integers of even length. Returns: list of int: New list with the summed pairs. Examples: >>> symmetric_sum([1, 2, 3, 4, 5, 6]) [7, 7, 7] >>> symmetric_sum([10, 20, 30, 40, 50, 60, 70, 80]) [90, 90, 90, 90] >>> symmetric_sum([9, 9, 9, 9, 9, 9, 9, 9]) [18, 18, 18, 18] >>> symmetric_sum([1, 8, 3, 4, 6, 5, 7, 2]) [3, 15, 8, 10] >>> symmetric_sum([0, 1, 2, 3, 4, 0]) [0, 5, 5] # Your code here","solution":"def symmetric_sum(nums): Returns a new list where each element is the sum of pairs of elements from the original list that are equidistant from the ends. Parameters: nums (list of int): List of integers of even length. Returns: list of int: New list with the summed pairs. result = [] n = len(nums) // 2 for i in range(n): result.append(nums[i] + nums[-(i + 1)]) return result # Example Usage print(symmetric_sum([1, 2, 3, 4, 5, 6])) # Output: [7, 7, 7] print(symmetric_sum([10, 20, 30, 40, 50, 60, 70, 80])) # Output: [90, 90, 90, 90]"},{"question":"def minTollCost(N: int, M: int, roads: List[List[int]]) -> int: Find the minimum toll cost to connect all houses using Kruskal's algorithm. >>> minTollCost(4, 5, [[1, 2, 5], [1, 3, 10], [2, 3, 7], [2, 4, 4], [3, 4, 3]]) 12 >>> minTollCost(3, 3, [[1, 2, 2], [2, 3, 3], [1, 3, 4]]) 5 from typing import List def test_minTollCost_example1(): N = 4 M = 5 roads = [[1, 2, 5], [1, 3, 10], [2, 3, 7], [2, 4, 4], [3, 4, 3]] assert minTollCost(N, M, roads) == 12 def test_minTollCost_example2(): N = 3 M = 3 roads = [[1, 2, 2], [2, 3, 3], [1, 3, 4]] assert minTollCost(N, M, roads) == 5 def test_minTollCost_no_roads(): N = 1 M = 0 roads = [] assert minTollCost(N, M, roads) == 0 def test_minTollCost_all_equal(): N = 4 M = 6 roads = [[1, 2, 1], [1, 3, 1], [1, 4, 1], [2, 3, 1], [2, 4, 1], [3, 4, 1]] assert minTollCost(N, M, roads) == 3 def test_minTollCost_large_values(): N = 3 M = 3 roads = [[1, 2, 10000], [2, 3, 10000], [1, 3, 9999]] assert minTollCost(N, M, roads) == 19999","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minTollCost(N, M, roads): roads.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(N+1): parent.append(node) rank.append(0) minimum_toll_cost = 0 edges_used = 0 for road in roads: if edges_used == N - 1: break u, v, toll = road root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: minimum_toll_cost += toll edges_used += 1 union(parent, rank, root_u, root_v) return minimum_toll_cost"},{"question":"from typing import List def find_even_index(arr: List[int]) -> int: Find an index in the list where the sum of the integers to the left is equal to the sum of the integers to the right. >>> find_even_index([1,2,3,4,3,2,1]) 3 >>> find_even_index([1,100,50,-51,1,1]) 1 >>> find_even_index([1,2,3,4,5,6]) -1 >>> find_even_index([20,10,30,10,10,15,35]) 3","solution":"def find_even_index(arr): Find an index in the list where the sum of the integers to the left is equal to the sum of the integers to the right. :param arr: List of integers :return: Index if such a point exists, -1 otherwise for i in range(len(arr)): if sum(arr[:i]) == sum(arr[i+1:]): return i return -1"},{"question":"def is_sum_of_consecutive_integers(n: int) -> str: Determine if a number can be expressed as the sum of two or more consecutive positive integers. Args: n (int): The number to check. Returns: str: \\"YES\\" if the number can be expressed as the sum of two or more consecutive positive integers, otherwise \\"NO\\". Examples: >>> is_sum_of_consecutive_integers(9) 'YES' >>> is_sum_of_consecutive_integers(15) 'YES' >>> is_sum_of_consecutive_integers(8) 'NO' pass def batch_is_sum_of_consecutive_integers(test_cases: List[int]) -> List[str]: Determine if each number in a list of test cases can be expressed as the sum of two or more consecutive positive integers. Args: test_cases (List[int]): A list of numbers to check. Returns: List[str]: A list of results for each number in the test cases, where each result is \\"YES\\" or \\"NO\\". Examples: >>> batch_is_sum_of_consecutive_integers([9, 15, 8, 1, 2, 3, 10, 12, 21]) ['YES', 'YES', 'NO', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES'] pass # Unit tests def test_is_sum_of_consecutive_integers(): assert is_sum_of_consecutive_integers(9) == \\"YES\\" assert is_sum_of_consecutive_integers(15) == \\"YES\\" assert is_sum_of_consecutive_integers(8) == \\"NO\\" assert is_sum_of_consecutive_integers(1) == \\"NO\\" assert is_sum_of_consecutive_integers(2) == \\"NO\\" assert is_sum_of_consecutive_integers(3) == \\"YES\\" assert is_sum_of_consecutive_integers(10) == \\"YES\\" assert is_sum_of_consecutive_integers(12) == \\"YES\\" assert is_sum_of_consecutive_integers(21) == \\"YES\\" def test_batch_is_sum_of_consecutive_integers(): test_cases = [9, 15, 8, 1, 2, 3, 10, 12, 21] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert batch_is_sum_of_consecutive_integers(test_cases) == expected_results","solution":"def is_sum_of_consecutive_integers(n): Determine if a number can be expressed as the sum of two or more consecutive positive integers. for k in range(2, int((2 * n) ** 0.5) + 1): if (n - k * (k - 1) // 2) % k == 0: return \\"YES\\" return \\"NO\\" def batch_is_sum_of_consecutive_integers(test_cases): results = [] for n in test_cases: results.append(is_sum_of_consecutive_integers(n)) return results"},{"question":"from typing import List def schedule_conflicts(conf_schedule: List[List[int]]) -> int: Determine the minimum number of conferences that need to be rescheduled to remove all conflicts. Args: conf_schedule (list of lists): Each list contains a conference identifier followed by the time slots the conference is using. Returns: int: The minimum number of conferences that must be rescheduled to remove all conflicts. >>> schedule_conflicts([ ... [1, 1, 2], ... [2, 2, 3], ... [3, 1, 3] ... ]) == 1 >>> schedule_conflicts([ ... [1, 1, 4], ... [2, 2, 5], ... [3, 3, 6] ... ]) == 0 >>> schedule_conflicts([ ... [1, 1, 2, 3], ... [2, 2, 3, 4], ... [3, 1, 4] ... ]) == 1 >>> schedule_conflicts([ ... [1, 1, 2], ... [2, 1, 2], ... [3, 1, 2] ... ]) == 2 >>> schedule_conflicts([ ... [i, i, i+1] for i in range(1, 100, 2) ... ]) == 0 >>> schedule_conflicts([ ... [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ... ]) == 0","solution":"from collections import defaultdict def schedule_conflicts(conf_schedule): Determine the minimum number of conferences that need to be rescheduled to remove all conflicts. Args: conf_schedule (list of lists): Each list contains a conference identifier followed by the time slots the conference is using. Returns: int: The minimum number of conferences that must be rescheduled to remove all conflicts. time_slot_dict = defaultdict(list) for conf in conf_schedule: conf_id = conf[0] for slot in conf[1:]: time_slot_dict[slot].append(conf_id) conflict_count = defaultdict(int) for conf_ids in time_slot_dict.values(): if len(conf_ids) > 1: for conf_id in conf_ids: conflict_count[conf_id] += 1 reschedule_count = 0 while conflict_count: # Find the conference with the most conflicts max_conflict_id = max(conflict_count, key=conflict_count.get) reschedule_count += 1 # Remove this conference from conflicting lists for slot in conf_schedule[max_conflict_id - 1][1:]: time_slot_dict[slot].remove(max_conflict_id) if len(time_slot_dict[slot]) <= 1: for conf_id in time_slot_dict[slot]: if conf_id in conflict_count: del conflict_count[conf_id] del conflict_count[max_conflict_id] return reschedule_count"},{"question":"def sortland(n, wealth): Given n towns and their respective wealth values, return the 1-based indices of the towns with the least wealth, median wealth, and greatest wealth. >>> sortland(5, [4, 1, 7, 3, 9]) (2, 1, 5) >>> sortland(3, [10, 5, 20]) (2, 1, 3)","solution":"def sortland(n, wealth): Returns the 1-based indices of towns with the least wealth, median wealth, and greatest wealth. # Store the wealth values with their original indices indexed_wealth = list(enumerate(wealth)) # Sort by wealth values indexed_wealth.sort(key=lambda x: x[1]) # Extract the indices which are 1-based least_wealth_index = indexed_wealth[0][0] + 1 median_wealth_index = indexed_wealth[n // 2][0] + 1 greatest_wealth_index = indexed_wealth[-1][0] + 1 return least_wealth_index, median_wealth_index, greatest_wealth_index"},{"question":"def two_sum(nums, target): Write a function that, given an array of integers and an integer target, returns the indices of the two numbers such that they add up to the target. Assume each input would have exactly one solution, and you may not use the same element twice. :param nums: List of integers. :param target: Integer target. :return: List containing two indices. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] from solution import two_sum def test_two_sum_example1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_two_sum_example2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_two_sum_example3(): assert two_sum([3, 3], 6) == [0, 1] def test_two_sum_negatives(): assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] def test_two_sum_mixed_signs(): assert two_sum([1, -3, 4, 2], -1) == [1, 3] def test_two_sum_single_solution(): assert two_sum([1, 2, 3, 4, 5], 9) == [3, 4] def test_two_sum_large_numbers(): assert two_sum([1000000000, 2, -1000000000], 0) == [0, 2]","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. :param nums: List of integers. :param target: Integer target. :return: List containing two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"def can_knight_defeat_dragons(n, s, dragons): Determines if there is an order of battles such that the knight can defeat all dragons without his strength ever dropping to zero or below. Args: - n: int, number of dragons - s: int, initial strength of the knight - dragons: list of int, strengths of the dragons Returns: - \\"YES\\" if there is an order of battles such that the knight can defeat all dragons, otherwise \\"NO\\". >>> can_knight_defeat_dragons(3, 8, [5, 4, 3]) 'YES' >>> can_knight_defeat_dragons(3, 4, [5, 3, 4]) 'NO'","solution":"def can_knight_defeat_dragons(n, s, dragons): Determines if there is an order of battles such that the knight can defeat all dragons without his strength ever dropping to zero or below. Args: - n: int, number of dragons - s: int, initial strength of the knight - dragons: list of int, strengths of the dragons Returns: - \\"YES\\" if there is an order of battles such that the knight can defeat all dragons, otherwise \\"NO\\". dragons.sort(reverse=True) # Sort dragons by descending strength for dragon in dragons: if s <= dragon: return \\"NO\\" s += dragon # Knight's strength increases by the dragon's strength return \\"YES\\""},{"question":"def maximize_product(N: int, arr: List[int]) -> int: Return the maximum possible product of the remaining elements in the array. >>> maximize_product(3, [1, 2, 3]) 6 >>> maximize_product(4, [5, 5, 5, 5]) 20 >>> maximize_product(2, [10, 10]) 20","solution":"def maximize_product(n, arr): This function returns the maximum possible product of the remaining elements in the array if we perform the described operation any number of times. total_sum = sum(arr) # After combining all elements into one single element with sum of all original elements, # the product of the remaining elements in the array will be the sum itself. return total_sum"},{"question":"def max_path_sum(matrix): Returns the maximum path sum in the matrix where you can start and end at any cell and there is no limit on the number of cells in the path. Each cell can be visited multiple times while forming the desired path. >>> max_path_sum([ ... [1, 2, 3, 4], ... [4, 5, 6, 7], ... [7, 8, 9, 10], ... [10, 11, 12, 13] ... ]) == 13 >>> max_path_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -1","solution":"def max_path_sum(matrix): Returns the maximum path sum in the matrix where you can start and end at any cell and there is no limit on the number of cells in the path. Each cell can be visited multiple times while forming the desired path. m = len(matrix) n = len(matrix[0]) # The algorithm to be used here is to find the maximum number in the matrix max_val = float('-inf') for row in range(m): for col in range(n): if matrix[row][col] > max_val: max_val = matrix[row][col] return max_val"},{"question":"def redesign_city(n: int, m: int, H: List[List[int]]) -> List[List[int]]: Redesign the city such that each row and each column of the matrix is strictly increasing in height. >>> redesign_city(3, 3, [[1, 2, 3], [2, 3, 4], [3, 4, 5]]) [[1, 2, 3], [2, 3, 4], [3, 4, 5]] >>> redesign_city(2, 2, [[5, 6], [7, 8]]) [[5, 6], [7, 8]] >>> redesign_city(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) [[1, 2, 3], [2, 3, 4], [3, 4, 5]] pass","solution":"def redesign_city(n, m, H): result = [[0]*m for _ in range(n)] # We need to start with the initial heights while making sure rows and columns are strictly increasing max_rows = [0] * n max_cols = [0] * m # Step 1: Ensure each row is strictly increasing for i in range(n): for j in range(m): if j == 0: result[i][j] = H[i][j] else: result[i][j] = max(result[i][j-1] + 1, H[i][j]) max_rows[i] = result[i][-1] # Store the max height in the row # Step 2: Ensure each column is strictly increasing for j in range(m): for i in range(n): if i == 0: result[i][j] = max(result[i][j], H[i][j]) else: result[i][j] = max(result[i-1][j] + 1, result[i][j], H[i][j]) max_cols[j] = result[i][j] # Store the max height in the column return result"},{"question":"def max_balanced_substring(s: str) -> int: Returns the maximum length of a balanced substring for the given string s. >>> max_balanced_substring(\\"(()())\\") == 6 >>> max_balanced_substring(\\")()())\\") == 4 >>> max_balanced_substring(\\"()((()))\\") == 8 >>> max_balanced_substring(\\")(\\") == 0 >>> max_balanced_substring(\\"\\") == 0 >>> max_balanced_substring(\\"(()\\") == 2 >>> max_balanced_substring(\\"())\\") == 2 >>> max_balanced_substring(\\"()()())\\") == 6 pass def max_balanced_substring_multiple_cases(test_cases: List[str]) -> List[int]: For a list of multiple test cases, returns the list of results for each test case. >>> test_cases = [\\"(()())\\", \\")()())\\", \\"()((()))\\"] >>> max_balanced_substring_multiple_cases(test_cases) == [6, 4, 8] pass","solution":"def max_balanced_substring(s): Returns the maximum length of a balanced substring for the given string s. stack = [] max_len = 0 last_invalid = -1 for i, char in enumerate(s): if char == '(': stack.append(i) else: if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - last_invalid) else: last_invalid = i return max_len def max_balanced_substring_multiple_cases(test_cases): For a list of multiple test cases, returns the list of results for each test case. results = [] for case in test_cases: results.append(max_balanced_substring(case)) return results"},{"question":"from typing import List def is_valid_date(date_str: str) -> bool: Determines if a given date string is valid. >>> is_valid_date(\\"2020-02-29\\") True >>> is_valid_date(\\"2019-04-31\\") False >>> is_valid_date(\\"2020-13-10\\") False >>> is_valid_date(\\"2100-02-29\\") False pass","solution":"def is_valid_date(date_str): Determines if a given date string is valid. # Split the date into year, month, and day parts = date_str.split('-') if len(parts) != 3: return False year_str, month_str, day_str = parts # Check if all parts are of the correct length if len(year_str) != 4 or len(month_str) != 2 or len(day_str) != 2: return False # Convert strings to integers try: year = int(year_str) month = int(month_str) day = int(day_str) except ValueError: return False # Check if the month is valid if month < 1 or month > 12: return False # Number of days in each month month_days = { 1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31 } # Adjust for leap year if month == 2 and is_leap_year(year): month_days[2] = 29 # Check if the day is valid if day < 1 or day > month_days.get(month, 0): return False return True def is_leap_year(year): Determines if a given year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True return False return True return False"},{"question":"def findWord(matrix, word): Find a word in the matrix. The word can be formed by consecutive characters horizontally, vertically, or diagonally from any direction. >>> matrix = [ ... ['A', 'B', 'C', 'D'], ... ['E', 'F', 'G', 'H'], ... ['I', 'J', 'K', 'L'], ... ['M', 'N', 'O', 'P'] ... ] >>> findWord(matrix, \\"FGH\\") True >>> findWord(matrix, \\"BGK\\") False # Your code here","solution":"def findWord(matrix, word): def is_valid_position(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) def search_from(i, j, word_index, direction): if word_index == len(word): return True if not is_valid_position(i, j) or matrix[i][j] != word[word_index]: return False next_i, next_j = i + direction[0], j + direction[1] return search_from(next_i, next_j, word_index + 1, direction) directions = [ (0, 1), # horizontal right (1, 0), # vertical down (1, 1), # diagonal down-right (0, -1), # horizontal left (-1, 0), # vertical up (-1, -1), # diagonal up-left (1, -1), # diagonal down-left (-1, 1) # diagonal up-right ] for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == word[0]: for direction in directions: if search_from(i, j, 0, direction): return True return False"},{"question":"import heapq def minimal_toll_cost(n: int, m: int, roads: list, unavailable: list, s: int, d: int) -> int: Calculate the minimal total toll cost to travel from city \`s\` to city \`d\` without using any unavailable roads. Args: n (int): Number of cities. m (int): Number of roads. roads (list): A list of roads where each road is described by three integers (u, v, c) which denotes a road from city u to city v with a toll cost c. unavailable (list): A list of unavailable roads where each road is described by two integers (p, q) which indicate that the road between cities p and q is unavailable. s (int): Starting city. d (int): Destination city. Returns: int: The minimal total toll cost or -1 if there is no valid path. adjacency_list = {i: [] for i in range(1, n + 1)} unavailable_set = set() for u, v, c in roads: adjacency_list[u].append((v, c)) adjacency_list[v].append((u, c)) for p, q in unavailable: unavailable_set.add((p, q)) unavailable_set.add((q, p)) def dijkstra(start, end): min_heap = [(0, start)] cost_to_reach = {i: float('inf') for i in range(1, n + 1)} cost_to_reach[start] = 0 while min_heap: current_cost, current_city = heapq.heappop(min_heap) if current_city == end: return current_cost if current_cost > cost_to_reach[current_city]: continue for neighbor, cost in adjacency_list[current_city]: if (current_city, neighbor) in unavailable_set: continue new_cost = current_cost + cost if new_cost < cost_to_reach[neighbor]: cost_to_reach[neighbor] = new_cost heapq.heappush(min_heap, (new_cost, neighbor)) return -1 result = dijkstra(s, d) return result # Example unit test cases def test_minimal_toll_cost(): assert minimal_toll_cost(5, 6, [(1, 2, 5), (1, 3, 10), (2, 4, 2), (3, 4, 1), (4, 5, 3), (2, 5, 9)], [(1, 4)], 1, 5) == 10 assert minimal_toll_cost(4, 5, [(1, 2, 4), (1, 3, 7), (2, 3, 1), (2, 4, 5), (3, 4, 3)], [(1, 3), (2, 3)], 1, 4) == 9 assert minimal_toll_cost(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 4)], [], 1, 3) == 4 assert minimal_toll_cost(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)], [(1, 3)], 1, 3) == 2 assert minimal_toll_cost(6, 7, [(1, 2, 2), (2, 3, 4), (1, 4, 10), (4, 5, 3), (5, 6, 1), (3, 6, 8), (3, 4, 2)], [(4, 5), (5, 6)], 1, 6) == 14 assert minimal_toll_cost(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)], [(1, 4)], 1, 4) == 3 if __name__ == \\"__main__\\": test_minimal_toll_cost()","solution":"import heapq def minimal_toll_cost(n, m, roads, unavailable, s, d): adjacency_list = {i: [] for i in range(1, n + 1)} unavailable_set = set() for u, v, c in roads: adjacency_list[u].append((v, c)) adjacency_list[v].append((u, c)) for p, q in unavailable: unavailable_set.add((p, q)) unavailable_set.add((q, p)) def dijkstra(start, end): min_heap = [(0, start)] cost_to_reach = {i: float('inf') for i in range(1, n + 1)} cost_to_reach[start] = 0 while min_heap: current_cost, current_city = heapq.heappop(min_heap) if current_city == end: return current_cost if current_cost > cost_to_reach[current_city]: continue for neighbor, cost in adjacency_list[current_city]: if (current_city, neighbor) in unavailable_set: continue new_cost = current_cost + cost if new_cost < cost_to_reach[neighbor]: cost_to_reach[neighbor] = new_cost heapq.heappush(min_heap, (new_cost, neighbor)) return -1 result = dijkstra(s, d) return result"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix from a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"a\\", \\"b\\", \\"c\\"]) '' >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longest_common_prefix([\\"a\\", \\"ab\\", \\"abc\\"]) 'a'","solution":"def longest_common_prefix(strs): Returns the longest common prefix from a list of strings. if not strs: return \\"\\" # Take the shortest string as the base for comparison min_len = min(len(s) for s in strs) common_prefix = \\"\\" for i in range(min_len): # Take the character from the first string as a reference char = strs[0][i] if all(s[i] == char for s in strs): common_prefix += char else: break return common_prefix"},{"question":"def all_unique_characters(s: str) -> bool: Determines if all characters in the string are unique. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. >>> all_unique_characters(\\"abcdefghijk\\") True >>> all_unique_characters(\\"hello\\") False","solution":"def all_unique_characters(s): Determines if all characters in the string are unique. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. char_set = set() for char in s: if char in char_set: return False char_set.add(char) return True"},{"question":"import itertools from typing import List def custom_playlists(n: int, k: int, songs: List[str]) -> List[int]: Determine the number of distinct playlists that can be created by selecting non-overlapping substrings and rearranging them. >>> custom_playlists(3, 4, ['abcd', 'aabb', 'wxyz']) [24, 6, 24] >>> custom_playlists(1, 3, ['aaa']) [1] >>> custom_playlists(2, 4, ['aabb', 'bbaa']) [6, 6] >>> custom_playlists(1, 5, ['abcde']) [120] def test_custom_playlists(): assert custom_playlists(1, 4, [\\"abcd\\"]) == [24] # 4! = 24 assert custom_playlists(3, 4, [\\"abcd\\", \\"aabb\\", \\"wxyz\\"]) == [24, 6, 24] assert custom_playlists(1, 3, [\\"aaa\\"]) == [1] # Only one combination: 'aaa' assert custom_playlists(2, 4, [\\"aabb\\", \\"bbaa\\"]) == [6, 6] assert custom_playlists(1, 5, [\\"abcde\\"]) == [120] # 5! = 120","solution":"import itertools def factorial(n): if n == 0 or n == 1: return 1 return n * factorial(n-1) def calculate_playlists_count(song): k = len(song) all_permutations = set([''.join(p) for p in itertools.permutations(song)]) return len(all_permutations) def custom_playlists(n, k, songs): results = [] for song in songs: results.append(calculate_playlists_count(song)) return results def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) songs = data[2:2 + n] results = custom_playlists(n, k, songs) for result in results: print(result)"},{"question":"def kthSmallest(arr, N, k): This function finds the kth smallest element in an array using the Quickselect algorithm. Parameters: arr (List[int]): The array of integers. N (int): The size of the array. k (int): The position of the smallest element to find (1-based index). Returns: int: The kth smallest element in the array. from typing import List import random def test_kthSmallest_1(): N = 6 k = 2 arr = [7, 10, 4, 3, 20, 15] assert kthSmallest(arr, N, k) == 4 def test_kthSmallest_2(): N = 6 k = 5 arr = [7, 10, 4, 3, 20, 15] assert kthSmallest(arr, N, k) == 15 def test_kthSmallest_3(): N = 5 k = 3 arr = [7, 10, 4, 3, 20] assert kthSmallest(arr, N, k) == 7 def test_kthSmallest_single_element(): N = 1 k = 1 arr = [10] assert kthSmallest(arr, N, k) == 10 def test_kthSmallest_duplicates(): N = 6 k = 3 arr = [1, 5, 5, 5, 8, 9] assert kthSmallest(arr, N, k) == 5 def test_kthSmallest_large_k(): N = 6 k = 6 arr = [12, 35, 1, 10, 34, 1] assert kthSmallest(arr, N, k) == 35","solution":"import random def kthSmallest(arr, N, k): This function finds the kth smallest element in an array using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = random.randint(left, right) pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, N - 1, k - 1)"},{"question":"def max_subarray_sum(arr): Function to find maximum subarray sum. >>> max_subarray_sum([1, 2, -1, 2]) 4 >>> max_subarray_sum([-3, 4, -1, 2, 1]) 6 def process_test_cases(test_cases): Function to process multiple test cases. >>> process_test_cases([[1, 2, -1, 2], [-3, 4, -1, 2, 1]]) [4, 6] >>> process_test_cases([[-1, -2, -3, -4], [5, 4, -1, 7, 8], [0, 0, 0, 0]]) [-1, 23, 0]","solution":"def max_subarray_sum(arr): Function to find maximum subarray sum. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(test_cases): Function to process multiple test cases. results = [] for case in test_cases: arr = case results.append(max_subarray_sum(arr)) return results"},{"question":"def max_energy(n: int, f: int, e: int, segments: List[Tuple[int, int]]) -> int: Calculate the maximum total energy that can be gained by the end of the journey without running out of fuel. >>> max_energy(5, 10, 0, [(2, 5), (3, 7), (4, 3), (5, 8), (2, 6)]) == 21 from typing import List, Tuple def test_example(): n = 5 f = 10 e = 0 segments = [(2, 5), (3, 7), (4, 3), (5, 8), (2, 6)] assert max_energy(n, f, e, segments) == 21 def test_single_segment(): n = 1 f = 2 e = 0 segments = [(2, 5)] assert max_energy(n, f, e, segments) == 5 def test_single_segment_inadequate_fuel(): n = 1 f = 1 e = 0 segments = [(2, 5)] assert max_energy(n, f, e, segments) == 0 def test_multiple_segments_exact_fuel(): n = 3 f = 3 e = 0 segments = [(1, 1), (1, 2), (1, 3)] assert max_energy(n, f, e, segments) == 6 def test_large_input(): n = 1000 f = 10000 e = 5000 segments = [(10, 20) for _ in range(1000)] assert max_energy(n, f, e, segments) == 25000","solution":"def max_energy(n, f, e, segments): # Initialize a 2D list for DP tracking dp = [[-float('inf')] * (f + 1) for _ in range(n + 1)] dp[0][f] = e # Starting point, initial fuel and initial energy # Populate the DP table for i in range(n): fi, ei = segments[i] for current_fuel in range(f + 1): if dp[i][current_fuel] != -float('inf'): # Skip the segment, carry over the energy dp[i + 1][current_fuel] = max(dp[i + 1][current_fuel], dp[i][current_fuel]) # Take the segment if enough fuel is present if current_fuel >= fi: dp[i + 1][current_fuel - fi] = max(dp[i + 1][current_fuel - fi], dp[i][current_fuel] + ei) # Return the maximum energy possible by the end of all segments return max(dp[n]) # Example n = 5 f = 10 e = 0 segments = [(2, 5), (3, 7), (4, 3), (5, 8), (2, 6)] print(max_energy(n, f, e, segments)) # Expected output: 21"},{"question":"from typing import List, Tuple def minimum_total_distance(N: int, M: int, P: int, distribution_centers: List[int], roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum total distance required to ensure all distribution centers can communicate. Args: N (int): Number of cities. M (int): Number of roads. P (int): Number of distribution centers. distribution_centers (List[int]): List of distribution centers' indices. roads (List[Tuple[int, int, int]]): List of tuples, each containing two cities and the road length between them. Returns: int: The minimum total distance required to ensure all distribution centers can communicate. Examples: >>> minimum_total_distance(5, 6, 3, [1, 3, 5], [(1, 2, 2), (2, 3, 3), (2, 4, 4), (3, 5, 1), (4, 5, 6), (5, 1, 7)]) 6 >>> minimum_total_distance(4, 5, 2, [1, 4], [(1, 2, 5), (2, 3, 6), (3, 4, 7), (1, 3, 15), (2, 4, 8)]) 13 >>> minimum_total_distance(3, 3, 2, [1, 3], [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2","solution":"def floyd_warshall(n, roads): # Initialize distance matrix dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for (u, v, w) in roads: dist[u-1][v-1] = w dist[v-1][u-1] = w # Apply Floyd-Warshall for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def minimum_spanning_tree_cost(p_indices, dist): import heapq p = len(p_indices) in_tree = [False] * p min_heap = [(0, 0)] # (cost, start_node) total_cost = 0 while min_heap: cost, u_index = heapq.heappop(min_heap) if in_tree[u_index]: continue in_tree[u_index] = True total_cost += cost for v_index in range(p): if not in_tree[v_index] and u_index != v_index: heapq.heappush(min_heap, (dist[p_indices[u_index] - 1][p_indices[v_index] - 1], v_index)) return total_cost def minimum_total_distance(N, M, P, distribution_centers, roads): dist = floyd_warshall(N, roads) return minimum_spanning_tree_cost(distribution_centers, dist)"},{"question":"from typing import List, Tuple def is_magic_matrix(matrix: List[List[int]], r1: int, c1: int, r2: int, c2: int) -> str: pass def magic_matrix_submatrices(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[str]: Check how many Magic Matrix submatrices exist within the matrix. >>> matrix = [ ... [4, 4, 4, 4], ... [4, 4, 4, 4], ... [4, 4, 4, 4], ... [4, 4, 4, 4] ...] >>> queries = [(1, 1, 2, 2), (1, 1, 3, 4), (2, 2, 4, 4)] >>> magic_matrix_submatrices(matrix, queries) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_magic_matrix(matrix, r1, c1, r2, c2): rows_sum = [sum(matrix[i][c1:c2 + 1]) for i in range(r1, r2 + 1)] cols_sum = [sum(matrix[i][j] for i in range(r1, r2 + 1)) for j in range(c1, c2 + 1)] if len(set(rows_sum)) != 1 or len(set(cols_sum)) != 1: return \\"NO\\" return \\"YES\\" def magic_matrix_submatrices(matrix, queries): results = [] for (r1, c1, r2, c2) in queries: results.append(is_magic_matrix(matrix, r1 - 1, c1 - 1, r2 - 1, c2 - 1)) return results"},{"question":"def minimum_power_level(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Find the minimum power level achievable for any bottle after at most one treatment on each bottle. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): A list of tuples with each tuple containing N (int): Number of bottles. M (int): Number of potion types. power_levels (List[int]): List of power levels of the potions in the bottles. increase_amounts (List[int]): List of the fixed increase amounts for each type of potion. Returns: List[int]: A list of integers representing the minimum power level for each test case after at most one treatment on each bottle. >>> minimum_power_level(2, [(5, 3, [4, 6, 8, 3, 7], [2, 1, 3]), (4, 2, [5, 5, 5, 5], [0, 2])]) [4, 5]","solution":"def minimum_power_level(T, test_cases): results = [] for case in test_cases: N, M, power_levels, increase_amounts = case min_power_level = float('inf') for i in range(N): current_power = power_levels[i] for j in range(M): new_power = current_power + increase_amounts[j] if new_power < min_power_level: min_power_level = new_power results.append(min_power_level) return results T = 2 test_cases = [ (5, 3, [4, 6, 8, 3, 7], [2, 1, 3]), (4, 2, [5, 5, 5, 5], [0, 2]) ] print(minimum_power_level(T, test_cases)) # Example output would be: [4, 5]"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from a list of daily stock prices. You must buy before you sell. :param prices: List[int] :return: int >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> max_profit([2, 2, 2, 2, 2, 2]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a list of daily stock prices. You must buy before you sell. :param prices: List[int] :return: int if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif (price - min_price) > max_profit: max_profit = price - min_price return max_profit"},{"question":"def longest_unique_substring(s: str) -> int: Given a string of lowercase characters, find out the length of the longest substring without repeating characters. The substring should be as long as possible while maintaining the order of the characters as it appears in the original string. Parameters: s (str): A string of lowercase characters Returns: int: The length of the longest substring without repeating characters. Examples: >>> longest_unique_substring(\\"abcaefgb\\") 6 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"aaaaaa\\") 1 >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"abba\\") 2","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. last_seen = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Given a binary tree, find the maximum path sum. The path must start and end at any node in the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum path sum. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> maxPathSum(root) 6 >>> root = TreeNode(-10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxPathSum(root) 42","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): This function returns the maximum path sum in a binary tree. The path can start and end at any node. def helper(node): nonlocal max_sum if not node: return 0 # Calculate the maximum path sum through the left child left_sum = max(helper(node.left), 0) # Calculate the maximum path sum through the right child right_sum = max(helper(node.right), 0) # Calculate the maximum path sum with the current node as the root current_sum = node.val + left_sum + right_sum # Update the global maximum path sum if the current path sum is greater max_sum = max(max_sum, current_sum) # For the recursion, return the maximum path sum starting from the current node return node.val + max(left_sum, right_sum) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def count_items_by_category(items): Counts the number of items sold in each of the categories: Electronics, Clothing, and Groceries. Args: items (list of str): A list of strings where each string represents an item and a category separated by a comma. Returns: tuple: A tuple with the counts of Electronics, Clothing, and Groceries items respectively. >>> count_items_by_category([ 'Laptop,Electronics', 'Shirt,Clothing', 'Milk,Groceries', 'Phone,Electronics', 'Pants,Clothing', 'Bread,Groceries', 'TV,Electronics', 'Jacket,Clothing', 'Cheese,Groceries']) (3, 3, 3) >>> count_items_by_category([]) (0, 0, 0) >>> count_items_by_category([ 'Laptop,Electronics', 'Phone,Electronics', 'TV,Electronics']) (3, 0, 0) >>> count_items_by_category([ 'Laptop,Electronics', 'Shirt,Clothing', 'Milk,Groceries', 'Laptop,Electronics', 'Shirt,Clothing']) (2, 2, 1) >>> count_items_by_category([ 'Laptop,Electronics', 'Shirt,InvalidCategory', 'Milk,Groceries']) (1, 0, 1)","solution":"def count_items_by_category(items): Counts the number of items sold in each of the categories: Electronics, Clothing, and Groceries. Args: items (list of str): A list of strings where each string represents an item and a category separated by a comma. Returns: tuple: A tuple with the counts of Electronics, Clothing, and Groceries items respectively. counts = {\\"Electronics\\": 0, \\"Clothing\\": 0, \\"Groceries\\": 0} for item in items: item_name, category = item.split(',') if category in counts: counts[category] += 1 return counts[\\"Electronics\\"], counts[\\"Clothing\\"], counts[\\"Groceries\\"]"},{"question":"def dailyTemperatures(temperatures): Given a sequence of daily temperatures, returns a list of integers where each element corresponds to the number of days you would need to wait until the temperature rises for each day in the input list. If there is no possible future day with a warmer temperature, the corresponding output should be 0. The function should be efficient and complete the task in O(n) time complexity. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([73]) [0] >>> dailyTemperatures([72, 72, 72, 72]) [0, 0, 0, 0] >>> dailyTemperatures([70, 71, 72, 73, 74]) [1, 1, 1, 1, 0] >>> dailyTemperatures([74, 73, 72, 71, 70]) [0, 0, 0, 0, 0] >>> dailyTemperatures([70, 72, 71, 71, 74, 76, 75, 73, 72]) [1, 3, 2, 1, 1, 0, 0, 0, 0]","solution":"def dailyTemperatures(temperatures): This function takes a list of daily temperatures and returns a list with the number of days until a warmer temperature for each day. If there is no future day with a warmer temperature, it returns 0 for that day. n = len(temperatures) result = [0] * n stack = [] for i in range(n - 1, -1, -1): # Traverse the list from the end while stack and temperatures[i] >= temperatures[stack[-1]]: stack.pop() if stack: result[i] = stack[-1] - i stack.append(i) return result"},{"question":"def caesar_cipher(text: str) -> str: Applies the Caesar cipher with a shift of 3 on the given text. Parameters: text (str): Input string to be encrypted. Returns: str: Encrypted string with each letter shifted by 3 positions. Examples: >>> caesar_cipher('abc') 'def' >>> caesar_cipher('xyz') 'abc' >>> caesar_cipher('ABC') 'DEF' >>> caesar_cipher('XYZ') 'ABC' >>> caesar_cipher('Hello, World!') 'Khoor, Zruog!'","solution":"def caesar_cipher(text): Applies the Caesar cipher with a shift of 3 on the given text. Parameters: text (str): Input string to be encrypted. Returns: str: Encrypted string with each letter shifted by 3 positions. result = [] for char in text: if char.isalpha(): shift = 3 if char.islower(): result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) elif char.isupper(): result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"class Warehouse: def __init__(self, m): self.stacks = [[] for _ in range(m)] def push(self, s, x): self.stacks[s].append(x) def pop(self, s): if self.stacks[s]: self.stacks[s].pop() def peek(self, s): if self.stacks[s]: return self.stacks[s][-1] else: return \\"empty\\" def process_warehouse_operations(m, q, queries): Process a series of warehouse stack operations. Args: m (int): Number of stacks. q (int): Number of queries. queries (List[Tuple[int, ...]]): A list of queries where each query is a tuple indicating the type of operation and its parameters. Returns: List[Any]: Results of the peek operations (if any). >>> process_warehouse_operations(3, 10, [ (0, 0, 5), (0, 1, 10), (0, 2, 15), (2, 0), (2, 1), (2, 2), (1, 1), (2, 1), (1, 0), (2, 0) ]) [5, 10, 15, 'empty', 'empty'] result = [] warehouse = Warehouse(m) for query in queries: if query[0] == 0: _, s, x = query warehouse.push(s, x) elif query[0] == 1: _, s = query warehouse.pop(s) elif query[0] == 2: _, s = query result.append(warehouse.peek(s)) return result def test_warehouse_operations_case_1(): m = 3 q = 10 queries = [ (0, 0, 5), (0, 1, 10), (0, 2, 15), (2, 0), # expect 5 (2, 1), # expect 10 (2, 2), # expect 15 (1, 1), (2, 1), # expect empty (1, 0), (2, 0), # expect empty ] expected = [5, 10, 15, \\"empty\\", \\"empty\\"] result = process_warehouse_operations(m, q, queries) assert result == expected def test_warehouse_operations_no_peek(): m = 1 q = 3 queries = [ (0, 0, 1), (0, 0, 2), (0, 0, 3), ] expected = [] result = process_warehouse_operations(m, q, queries) assert result == expected def test_warehouse_operations_all_empty_peek(): m = 2 q = 2 queries = [ (2, 0), # expect empty (2, 1), # expect empty ] expected = [\\"empty\\", \\"empty\\"] result = process_warehouse_operations(m, q, queries) assert result == expected def test_warehouse_operations_mixed_operations(): m = 2 q = 6 queries = [ (0, 0, 5), (0, 1, 7), (2, 0), # expect 5 (2, 1), # expect 7 (1, 0), (2, 0), # expect empty ] expected = [5, 7, \\"empty\\"] result = process_warehouse_operations(m, q, queries) assert result == expected def test_warehouse_operations_large_numbers(): m = 2 q = 4 queries = [ (0, 0, 999999), (0, 1, 888888), (2, 0), # expect 999999 (2, 1), # expect 888888 ] expected = [999999, 888888] result = process_warehouse_operations(m, q, queries) assert result == expected","solution":"class Warehouse: def __init__(self, m): self.stacks = [[] for _ in range(m)] def push(self, s, x): self.stacks[s].append(x) def pop(self, s): if self.stacks[s]: self.stacks[s].pop() def peek(self, s): if self.stacks[s]: return self.stacks[s][-1] else: return \\"empty\\" def process_warehouse_operations(m, q, queries): warehouse = Warehouse(m) result = [] for query in queries: if query[0] == 0: _, s, x = query warehouse.push(s, x) elif query[0] == 1: _, s = query warehouse.pop(s) elif query[0] == 2: _, s = query result.append(warehouse.peek(s)) return result"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int]], s: int, t: int) -> int: Determine the shortest path from the starting node to the target node in a maze represented as a graph. Args: n : int : The number of nodes in the graph. m : int : The number of edges in the graph. edges : List[Tuple[int, int]] : A list of tuples where each tuple represents an edge between two nodes. s : int : The starting node. t : int : The target node. Returns: int : The length of the shortest path from node s to node t, or -1 if no such path exists. >>> shortest_path(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (4, 6)], 1, 6) 3 >>> shortest_path(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], 1, 5) 1 >>> shortest_path(4, 2, [(1, 2), (3, 4)], 1, 4) -1 >>> shortest_path(2, 1, [(1, 2)], 1, 2) 1 >>> shortest_path(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)], 1, 4) 2 >>> shortest_path(3, 2, [(1, 2), (2, 3)], 1, 1) 0","solution":"from collections import deque, defaultdict def shortest_path(n, m, edges, s, t): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) queue = deque([s]) distances = {s: 0} while queue: node = queue.popleft() if node == t: return distances[node] for neighbor in graph[node]: if neighbor not in distances: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return -1"},{"question":"def perform_operations(n: int, L: List[int], N: int, commands: List[str]) -> List[Union[int, str]]: Perform a series of count and index operations on the list L based on the provided commands. >>> n = 9 >>> L = [1, 2, 3, 3, 3, 4, 5, 6, 3] >>> N = 5 >>> commands = [\\"count 3\\", \\"index 3\\", \\"count 5\\", \\"index 2\\", \\"index 10\\"] >>> perform_operations(n, L, N, commands) [4, 2, 1, 1, \\"ValueError: 10 is not in list\\"]","solution":"def perform_operations(n, L, N, commands): results = [] for command in commands: operation, value = command.split() value = int(value) if operation == 'count': results.append(L.count(value)) elif operation == 'index': try: results.append(L.index(value)) except ValueError: results.append(f\\"ValueError: {value} is not in list\\") return results # Example usage: n = 9 L = [1, 2, 3, 3, 3, 4, 5, 6, 3] N = 5 commands = [ \\"count 3\\", \\"index 3\\", \\"count 5\\", \\"index 2\\", \\"index 10\\" ] print(perform_operations(n, L, N, commands))"},{"question":"def characterFrequency(s: str) -> List[Tuple[str, int]]: Determine the frequency of each character in the string. The frequencies are returned as a list of tuples, sorted in descending order of frequency, and lexicographically in ascending order if frequencies are the same. >>> characterFrequency(\\"tree\\") [('e', 2), ('r', 1), ('t', 1)] >>> characterFrequency(\\"cccaaa\\") [('a', 3), ('c', 3)]","solution":"def characterFrequency(s): from collections import Counter # Count the frequency of each character count = Counter(s) # Convert to list of tuples and sort by frequency (descending) # and then lexicographically by character (ascending) sorted_count = sorted(count.items(), key=lambda x: (-x[1], x[0])) return sorted_count"},{"question":"def minimum_difference_pair(arrays, target): Given an array of integers, find two elements in the array such that their difference is closest to a given target value. >>> minimum_difference_pair([(5, 1, 3, 15, 11, 2)], 5) [4] >>> minimum_difference_pair([(4, 19, 10, 7, 12)], 3) [3] >>> minimum_difference_pair([(2, 1, 10)], 8) [9] >>> minimum_difference_pair([(3, 1, 10, 5)], 6) [5] >>> minimum_difference_pair([(5, 1, 1, 1, 1, 1)], 0) [0] Given an array of integers, find two elements in the array such that their difference is closest to a given target value. You need to return the absolute difference of these two elements. :param arrays: List of tuples where each tuple starts with an integer n, followed by n integers representing the elements of the array :param target: An integer representing the target value :return: A list of single integers which is the absolute difference of the two closest elements in the array for each test case","solution":"def minimum_difference_pair(arrays, target): results = [] for array in arrays: n = array[0] elements = array[1:] min_diff = float('inf') for i in range(n): for j in range(i + 1, n): diff = abs(elements[i] - elements[j]) if abs(diff - target) < abs(min_diff - target): min_diff = diff results.append(min_diff) return results"},{"question":"def search_matrix(matrix, X): Determines if a given integer X exists in the matrix. Each row and each column of the matrix is sorted in non-decreasing order. :param matrix: List of List of integers :param X: Integer to search for :return: \\"YES\\" if X is found, else \\"NO\\" >>> search_matrix([[1, 4, 7], [2, 5, 9], [3, 6, 10]], 5) \\"YES\\" >>> search_matrix([[1, 4, 7], [2, 5, 9], [3, 6, 10]], 8) \\"NO\\" >>> search_matrix([], 5) \\"NO\\" >>> search_matrix([[10]], 10) \\"YES\\" >>> search_matrix([[10]], 5) \\"NO\\" >>> search_matrix([[-1000000, -999999, -999998], [-999997, -999996, -999995], [-999994, -999993, -999992]], -999995) \\"YES\\" >>> search_matrix([[-1000000, -999999, -999998], [-999997, -999996, -999995], [-999994, -999993, -999992]], 999999) \\"NO\\"","solution":"def search_matrix(matrix, X): Determines if a given integer X exists in the matrix. Each row and each column of the matrix is sorted in non-decreasing order. :param matrix: List of List of integers :param X: Integer to search for :return: \\"YES\\" if X is found, else \\"NO\\" if not matrix: return \\"NO\\" M, N = len(matrix), len(matrix[0]) row, col = 0, N - 1 while row < M and col >= 0: if matrix[row][col] == X: return \\"YES\\" elif matrix[row][col] > X: col -= 1 else: row += 1 return \\"NO\\""},{"question":"from typing import List def count_divisible_subsequences(n: int, a: int, b: int, arr: List[int]) -> int: Determine the number of non-contiguous subsequences of the list such that the sum of the subsequence elements is divisible by b, and the length of the subsequence is at least a. >>> count_divisible_subsequences(5, 2, 3, [3, 6, 5, 8, 2]) 5 >>> count_divisible_subsequences(4, 1, 2, [2, 4, 6, 8]) 15","solution":"from itertools import combinations def count_divisible_subsequences(n, a, b, arr): count = 0 for length in range(a, n+1): for subsequence in combinations(arr, length): if sum(subsequence) % b == 0: count += 1 return count"},{"question":"def shortestPath(N, M, grid): Returns the length of the shortest path from the top-left to the bottom-right cell in the grid. If there is no valid path, returns -1. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: List[List[str]], representation of the grid :return: int, length of the shortest path or -1 if no path exists Example usage: >>> grid1 = [ ... ['.', '.', '.', '#'], ... ['#', '#', '.', '#'], ... ['.', '.', '.', '.'], ... ['.', '#', '#', '.'] ... ] >>> shortestPath(4, 4, grid1) 6 >>> grid2 = [ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['#', '#', '.'] ... ] >>> shortestPath(3, 3, grid2) -1 import pytest from solution import shortestPath def test_example1(): N = 4 M = 4 grid = [ ['.', '.', '.', '#'], ['#', '#', '.', '#'], ['.', '.', '.', '.'], ['.', '#', '#', '.'] ] assert shortestPath(N, M, grid) == 6 def test_example2(): N = 3 M = 3 grid = [ ['.', '#', '.'], ['#', '#', '.'], ['#', '#', '.'] ] assert shortestPath(N, M, grid) == -1 def test_single_cell_path(): N = 1 M = 1 grid = [['.']] assert shortestPath(N, M, grid) == 0 def test_single_cell_wall(): N = 1 M = 1 grid = [['#']] assert shortestPath(N, M, grid) == -1 def test_blocked_path(): N = 5 M = 5 grid = [ ['.', '#', '.', '.', '.'], ['#', '#', '#', '#', '.'], ['.', '#', '.', '#', '.'], ['.', '#', '.', '#', '.'], ['.', '.', '#', '#', '.'] ] assert shortestPath(N, M, grid) == -1 def test_clear_path(): N = 3 M = 3 grid = [ ['.', '.', '.',], ['.', '.', '.',], ['.', '.', '.',] ] assert shortestPath(N, M, grid) == 4","solution":"from collections import deque def shortestPath(N, M, grid): Returns the length of the shortest path from the top-left to the bottom-right cell in the grid. If there is no valid path, returns -1. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: List[List[str]], representation of the grid :return: int, length of the shortest path or -1 if no path exists if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # stores (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == N-1 and y == M-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def process_tasks(n: int, tasks: List[Tuple[str, int, int]]) -> List[str]: Returns the identifiers of tasks in order of their priority. >>> process_tasks(4, [(\\"task1\\", 10, 1), (\\"task2\\", 5, 2), (\\"task3\\", 12, 3), (\\"task4\\", 5, 4)]) [\\"task3\\", \\"task1\\", \\"task2\\", \\"task4\\"] >>> process_tasks(3, [(\\"task1\\", 5, 1), (\\"task2\\", 5, 2), (\\"task3\\", 5, 3)]) [\\"task1\\", \\"task2\\", \\"task3\\"] >>> process_tasks(3, [(\\"task1\\", -5, 1), (\\"task2\\", 0, 2), (\\"task3\\", -1, 3)]) [\\"task2\\", \\"task3\\", \\"task1\\"] >>> process_tasks(1, [(\\"task1\\", 10, 1)]) [\\"task1\\"] def parse_input(input_lines: List[str]) -> Tuple[int, List[Tuple[str, int, int]]]: Parses the input lines into the number of tasks and a list of tasks with their priorities. >>> parse_input([\\"4\\", \\"task1 10\\", \\"task2 5\\", \\"task3 12\\", \\"task4 5\\"]) (4, [(\\"task1\\", 10, 1), (\\"task2\\", 5, 2), (\\"task3\\", 12, 3), (\\"task4\\", 5, 4)]) >>> parse_input([\\"3\\", \\"task1 5\\", \\"task2 5\\", \\"task3 5\\"]) (3, [(\\"task1\\", 5, 1), (\\"task2\\", 5, 2), (\\"task3\\", 5, 3)]) def main(input_lines: List[str]): Main function to read input lines, process the tasks, and print the task identifiers in order.","solution":"def process_tasks(n, tasks): Returns the identifiers of tasks in order of their priority. # Sort tasks by priority in descending order. If priorities are the same, sort by original index. sorted_tasks = sorted(tasks, key=lambda x: (-x[1], x[2])) # Extract and return only the task identifiers return [task[0] for task in sorted_tasks] def parse_input(input_lines): n = int(input_lines[0]) tasks = [] for i in range(1, n + 1): parts = input_lines[i].split() identifier = parts[0] priority = int(parts[1]) tasks.append((identifier, priority, i)) return n, tasks def main(input_lines): n, tasks = parse_input(input_lines) task_order = process_tasks(n, tasks) for task in task_order: print(task)"},{"question":"def count_species_with_vowels(species_codes): Determine how many of the species codes contain at least one vowel. Args: species_codes: List[str] - List of species codes. Returns: int - Number of species codes containing at least one vowel. >>> count_species_with_vowels([\\"cactus\\", \\"fern\\", \\"sequoia\\", \\"spruce\\", \\"pine\\"]) == 3 >>> count_species_with_vowels([\\"brlq\\", \\"xztr\\", \\"ghs\\"]) == 0 >>> count_species_with_vowels([\\"a\\", \\"e\\", \\"i\\", \\"o\\", \\"u\\"]) == 5 >>> count_species_with_vowels([\\"apple\\", \\"plm\\", \\"orng\\"]) == 2 >>> count_species_with_vowels([]) == 0 >>> count_species_with_vowels([\\"a\\", \\"b\\", \\"c\\", \\"e\\", \\"x\\"]) == 2 >>> count_species_with_vowels([\\"species\\" + str(i) for i in range(100000)]) == 100000","solution":"def count_species_with_vowels(species_codes): vowels = set('aeiou') count = 0 for code in species_codes: if any(char in vowels for char in code): count += 1 return count # Example usage: # species_codes = [\\"cactus\\", \\"fern\\", \\"sequoia\\", \\"spruce\\", \\"pine\\"] # print(count_species_with_vowels(species_codes)) # Output: 3"},{"question":"import math from typing import List def is_perfect_square(n: int) -> bool: Check if a number is a perfect square. root = int(math.sqrt(n)) return n == root * root def organize_books(book_ids: List[int]) -> List[int]: Organize the book identifiers such that perfect squares come first, followed by non-perfect squares sorted in ascending order. >>> organize_books([16, 3, 4, 10, 25, 2]) [16, 4, 25, 2, 3, 10] >>> organize_books([1, 7, 9, 12, 15, 20]) [1, 9, 7, 12, 15, 20]","solution":"import math def is_perfect_square(n): Check if a number is a perfect square. root = int(math.sqrt(n)) return n == root * root def organize_books(book_ids): Organize the book identifiers such that perfect squares come first, followed by non-perfect squares sorted in ascending order. perfect_squares = [x for x in book_ids if is_perfect_square(x)] non_perfect_squares = sorted([x for x in book_ids if not is_perfect_square(x)]) return perfect_squares + non_perfect_squares"},{"question":"def sieve_of_eratosthenes(max_num): Computes prime numbers up to max_num using the Sieve of Eratosthenes. sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, isqrt(max_num) + 1): if sieve[start]: for multiple in range(start * start, max_num + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def primes_in_range(m, p): Finds all prime numbers in the range [m, p]. all_primes = sieve_of_eratosthenes(p) return [prime for prime in all_primes if m <= prime <= p] def max_subarray_length_divisible_by_primes(n, m, p, A): Finds the maximum length of a subarray divisible by at least one prime in range [m, p]. Parameters: n (int): Length of the array. m (int): Lower bound of the range of prime numbers. p (int): Upper bound of the range of prime numbers. A (List[int]): The array of integers. Returns: int: The maximum length of the subarray. primes = primes_in_range(m, p) max_len = 0 current_len = 0 for num in A: if any(num % prime == 0 for prime in primes): current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len def solve(t, test_cases): Solves the problem for multiple test cases. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, int, List[int]]]): List of test case tuples. Returns: List[int]: List of results for each test case. results = [] for i in range(t): n, m, p, A = test_cases[i] result = max_subarray_length_divisible_by_primes(n, m, p, A) results.append(result) return results import pytest def test_example_1(): t = 2 test_cases = [ (6, 2, 5, [6, 10, 15, 20, 25, 30]), (5, 3, 7, [14, 21, 28, 35, 42]), ] results = solve(t, test_cases) assert results == [6, 5] def test_edge_case_no_primes(): t = 1 test_cases = [ (4, 4, 4, [1, 1, 1, 1]), # there are no primes in range [4, 4] ] results = solve(t, test_cases) assert results == [0] def test_single_element_satisfies(): t = 1 test_cases = [ (1, 2, 5, [10]), # single element divisible by 2 and 5 ] results = solve(t, test_cases) assert results == [1] def test_no_elements_satisfy(): t = 1 test_cases = [ (4, 2, 3, [5, 7, 11, 13]), # no elements divisible by 2 or 3 ] results = solve(t, test_cases) assert results == [0] def test_multiple_prime_factors(): t = 1 test_cases = [ (5, 2, 7, [2, 3, 5, 7, 14]), # all have a prime factor in [2, 7] ] results = solve(t, test_cases) assert results == [5]","solution":"from math import isqrt def sieve_of_eratosthenes(max_num): Computes prime numbers up to max_num using the Sieve of Eratosthenes. sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, isqrt(max_num) + 1): if sieve[start]: for multiple in range(start * start, max_num + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def primes_in_range(m, p): Finds all prime numbers in the range [m, p]. all_primes = sieve_of_eratosthenes(p) return [prime for prime in all_primes if m <= prime <= p] def max_subarray_length_divisible_by_primes(n, m, p, A): primes = primes_in_range(m, p) max_len = 0 current_len = 0 for num in A: if any(num % prime == 0 for prime in primes): current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len def solve(t, test_cases): results = [] for i in range(t): n, m, p, A = test_cases[i] result = max_subarray_length_divisible_by_primes(n, m, p, A) results.append(result) return results"},{"question":"def product_of_all_except_self(nums: List[int]) -> List[int]: Returns a list where each element at index i is the product of all elements in the input list except the one at i. :param nums: List of integers :return: List of integers >>> product_of_all_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_of_all_except_self([5, 3, 2, 6, 4]) == [144, 240, 360, 120, 180] >>> product_of_all_except_self([1, 0, 3, 4]) == [0, 12, 0, 0] >>> product_of_all_except_self([0, 0, 0]) == [0, 0, 0] >>> product_of_all_except_self([42]) == [1] >>> product_of_all_except_self([]) == [] >>> product_of_all_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_of_all_except_self([1, -2, 3, -4]) == [24, -12, 8, -6]","solution":"def product_of_all_except_self(nums): Returns a list where each element at index i is the product of all elements in the input list except the one at i. :param nums: List of integers :return: List of integers n = len(nums) if n == 0: return [] result = [1] * n left_product = 1 right_product = 1 # Compute the product of elements to the left of each index for i in range(n): result[i] = left_product left_product *= nums[i] # Compute the product of elements to the right of each index for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def increasing_sequences(test_cases): Given a list of integers, group them into increasing sequences while preserving the original order. Each number should only appear in one sequence, and each sequence should be as long as possible with strictly increasing elements. Parameters: test_cases (list of tuples): Each tuple contains an integer N and a list of N integers. Returns: list of lists: Each list contains the increasing sequences for the corresponding test case. # Example test cases: # test_cases = [ # (6, [1, 2, 3, 1, 2, 3]), # (7, [5, 6, 3, 4, 7, 8, 9]) # ] # Expected output: # [ # [[1, 2, 3], [1, 2, 3]], # [[5, 6], [3, 4, 7, 8, 9]] # ]","solution":"def increasing_sequences(test_cases): Given a list of integers, group them into increasing sequences while preserving the original order. Each number should only appear in one sequence, and each sequence should be as long as possible with strictly increasing elements. Parameters: test_cases (list of tuples): Each tuple contains an integer N and a list of N integers. Returns: list of lists: Each list contains the increasing sequences for the corresponding test case. results = [] for n, arr in test_cases: sequences = [] current_sequence = [] for i in range(n): if not current_sequence or arr[i] > current_sequence[-1]: current_sequence.append(arr[i]) else: sequences.append(current_sequence) current_sequence = [arr[i]] if current_sequence: sequences.append(current_sequence) results.append(sequences) return results"},{"question":"from typing import List, Tuple class TreeNode: def __init__(self, value): self.value = value self.children = [] def increment_subtree(node: TreeNode, inc: int) -> None: Increment all node values in a specific subtree by a given value. Args: node (TreeNode): The root node of the subtree. inc (int): The value to increment each node in the subtree by. >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(3) >>> root.children = [child1, child2] >>> increment_subtree(root, 2) >>> root.value == 3 True >>> child1.value == 4 True >>> child2.value == 5 True def find_max_in_subtree(node: TreeNode) -> int: Find the maximum value in a specific subtree. Args: node (TreeNode): The root node of the subtree. Returns: int: The maximum value in the subtree. >>> root = TreeNode(1) >>> child1 = TreeNode(2) >>> child2 = TreeNode(3) >>> grandchild = TreeNode(4) >>> child1.children = [grandchild] >>> root.children = [child1, child2] >>> find_max_in_subtree(root) 4 >>> find_max_in_subtree(child1) 4 >>> find_max_in_subtree(child2) 3 def solve_tree_problem(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Solve the tree problem with given queries. Args: n (int): Number of nodes in the tree. values (List[int]): List of values for each node. edges (List[Tuple[int, int]]): List of edges defining the tree. queries (List[Tuple[int, int, int]]): List of queries. Returns: List[int]: Results of the queries of the second type. >>> n = 5 >>> values = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> queries = [(2, 3), (1, 3, 2), (2, 3), (2, 1)] >>> solve_tree_problem(n, values, edges, queries) [5, 7, 7]","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def increment_subtree(node, inc): if node: node.value += inc for child in node.children: increment_subtree(child, inc) def find_max_in_subtree(node): if not node: return float('-inf') max_value = node.value for child in node.children: max_value = max(max_value, find_max_in_subtree(child)) return max_value def solve_tree_problem(n, values, edges, queries): nodes = {i+1: TreeNode(values[i]) for i in range(n)} for u, v in edges: nodes[u].children.append(nodes[v]) results = [] for query in queries: if query[0] == 1: _, x, inc = query increment_subtree(nodes[x], inc) elif query[0] == 2: _, x = query results.append(find_max_in_subtree(nodes[x])) return results"},{"question":"def encrypt_message(k: int, message: str) -> str: Encrypts the message by shifting each alphabetical character by k positions. >>> encrypt_message(3, \\"meet at the treehouse at 5 pm\\") 'phhw dw wkh wuhhkrxvh dw 5 sp' >>> encrypt_message(4, \\"hello, world!\\") 'lipps, asvph!' >>> encrypt_message(0, \\"example\\") 'example' >>> encrypt_message(2, \\"xyz\\") 'zab' >>> encrypt_message(1, \\"aA zZ\\") 'bB aA' >>> encrypt_message(5, \\"1234 @#%\\") '1234 @#%' >>> message = \\"a\\" * 500 >>> encrypted_message = \\"d\\" * 500 >>> encrypt_message(3, message) == encrypted_message True","solution":"def encrypt_message(k, message): Encrypts the message by shifting each alphabetical character by k positions. result = [] for char in message: if char.isalpha(): shift = k % 26 if char.islower(): result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) elif char.isupper(): result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determines if it's possible to rearrange and insert characters into the string \`s\` so that the final string is a palindrome. Args: n : int : length of string s s : str : string consisting only of lowercase English letters Returns: str : \\"YES\\" if a palindrome can be formed, otherwise \\"NO\\" >>> can_form_palindrome(4, \\"aabb\\") \\"YES\\" >>> can_form_palindrome(5, \\"abcde\\") \\"NO\\"","solution":"def can_form_palindrome(n, s): Determines if it's possible to rearrange and insert characters into the string \`s\` so that the final string is a palindrome. from collections import Counter count = Counter(s) odd_counts = sum(1 for v in count.values() if v % 2 != 0) if odd_counts > 1: # More than one character has an odd count means it can't be a palindrome return \\"NO\\" return \\"YES\\""},{"question":"def is_palindrome(n: int) -> bool: Determines if a given non-negative integer is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1221) True >>> is_palindrome(1234567890987654321) True >>> is_palindrome(1234567890123456789) False","solution":"def is_palindrome(n): Determines if a given non-negative integer is a palindrome. if n < 0: return False original = n reverse = 0 while n > 0: reverse = reverse * 10 + n % 10 n = n // 10 return original == reverse"},{"question":"def encrypt_amount(amount: int) -> int: Encrypt the given amount using the specified rules. The last digit of the amount is multiplied by 2. The second last digit of the amount is multiplied by 3. The third last digit of the amount is multiplied by 4. This pattern continues, with the n-th last digit being multiplied by (n+1). Example: >>> encrypt_amount(12345) 164 >>> encrypt_amount(0) 0","solution":"def encrypt_amount(amount): Encrypt the given amount using the specified rules. amount_str = str(amount) encrypted_amount = 0 for i, digit in enumerate(reversed(amount_str)): encrypted_amount += (i + 2) * int(digit) return encrypted_amount"},{"question":"def fraction_to_decimal(numerator: int, denominator: int) -> str: Convert a fraction given as two integers (numerator and denominator) into a string representing its decimal form. If the decimal is repeating, enclose the repeating part in parentheses. >>> fraction_to_decimal(1, 2) '0.5' >>> fraction_to_decimal(2, 3) '0.(6)' >>> fraction_to_decimal(4, 9) '0.(4)' def test_fraction_to_decimal(): assert fraction_to_decimal(1, 2) == \\"0.5\\" assert fraction_to_decimal(2, 3) == \\"0.(6)\\" assert fraction_to_decimal(4, 9) == \\"0.(4)\\" assert fraction_to_decimal(1, 6) == \\"0.1(6)\\" assert fraction_to_decimal(22, 7) == \\"3.(142857)\\" assert fraction_to_decimal(1, 333) == \\"0.(003)\\" assert fraction_to_decimal(4, 333) == \\"0.(012)\\" assert fraction_to_decimal(-50, 8) == \\"-6.25\\" assert fraction_to_decimal(50, -8) == \\"-6.25\\" assert fraction_to_decimal(0, 1) == \\"0\\" assert fraction_to_decimal(1, 7) == \\"0.(142857)\\" if __name__ == '__main__': test_fraction_to_decimal() print(\\"All tests passed.\\")","solution":"def fraction_to_decimal(numerator, denominator): if numerator % denominator == 0: return str(numerator // denominator) sign = '-' if (numerator < 0) ^ (denominator < 0) else '' numerator, denominator = abs(numerator), abs(denominator) integer_part = numerator // denominator remainder = numerator % denominator result = sign + str(integer_part) + '.' remainder_dict = {} while remainder: if remainder in remainder_dict: start = remainder_dict[remainder] result = result[:start] + '(' + result[start:] + ')' break remainder_dict[remainder] = len(result) remainder *= 10 quotient = remainder // denominator result += str(quotient) remainder %= denominator return result"},{"question":"def process_input(input_str: str): Determine the number of unique molecules that can be bonded together starting from a specific molecule through direct and indirect bonds. Args: input_str (str): Input string containing multiple datasets. Each dataset includes n, d followed by n lines of coordinates. Returns: list: Number of unique molecules bonded together for each dataset. Example: >>> process_input(\\"3 10n1.000 1.000n2.000 2.000n15.000 15.000n0 0\\") [2] >>> process_input(\\"5 7n3.000 3.000n10.000 10.000n3.500 4.000n17.000 17.000n1.000 1.500n0 0\\") [3]","solution":"import math def euclidean_distance(x1, y1, x2, y2): return math.sqrt((x2 - x1)**2 + (y2 - y1)**2) def find_bonded_molecules(n, d, molecules): bonded = [False] * n queue = [0] bonded[0] = True count = 1 while queue: current = queue.pop(0) for i in range(n): if not bonded[i] and euclidean_distance(molecules[current][0], molecules[current][1], molecules[i][0], molecules[i][1]) <= d: queue.append(i) bonded[i] = True count += 1 return count def process_input(input_str): datasets = input_str.strip().split(\\"n\\") results = [] index = 0 while index < len(datasets): n, d = map(int, datasets[index].split()) if n == 0 and d == 0: break molecules = [] for i in range(n): index += 1 x, y = map(float, datasets[index].split()) molecules.append((x, y)) results.append(find_bonded_molecules(n, d, molecules)) index += 1 return results"},{"question":"from typing import List def is_wiggle_sequence(n: int, sequence: List[int]) -> str: Determines if the given sequence is a wiggle sequence. Parameters: n (int): number of elements in the sequence sequence (list of int): the sequence of elements Returns: str: \\"YES\\" if the sequence is a wiggle sequence, \\"NO\\" otherwise Examples: >>> is_wiggle_sequence(6, [1, 7, 4, 9, 2, 5]) \\"YES\\" >>> is_wiggle_sequence(5, [1, 4, 7, 2, 5]) \\"NO\\" >>> is_wiggle_sequence(3, [1, 7, 4]) \\"YES\\" def test_is_wiggle_sequence_example1(): assert is_wiggle_sequence(6, [1, 7, 4, 9, 2, 5]) == \\"YES\\" def test_is_wiggle_sequence_example2(): assert is_wiggle_sequence(5, [1, 4, 7, 2, 5]) == \\"NO\\" def test_is_wiggle_sequence_example3(): assert is_wiggle_sequence(3, [1, 7, 4]) == \\"YES\\" def test_is_wiggle_sequence_single_element(): assert is_wiggle_sequence(1, [5]) == \\"YES\\" def test_is_wiggle_sequence_two_elements_positive_diff(): assert is_wiggle_sequence(2, [1, 2]) == \\"YES\\" def test_is_wiggle_sequence_two_elements_negative_diff(): assert is_wiggle_sequence(2, [2, 1]) == \\"YES\\" def test_is_wiggle_sequence_repeated_elements(): assert is_wiggle_sequence(3, [1, 1, 1]) == \\"NO\\" def test_is_wiggle_sequence_mixed_repeats(): assert is_wiggle_sequence(5, [1, 2, 2, 3, 1]) == \\"NO\\" def test_is_wiggle_sequence_alternating_signs(): assert is_wiggle_sequence(4, [3, 5, 2, 9]) == \\"YES\\"","solution":"def is_wiggle_sequence(n, sequence): Determines if the given sequence is a wiggle sequence. Parameters: n (int): number of elements in the sequence sequence (list of int): the sequence of elements Returns: str: \\"YES\\" if the sequence is a wiggle sequence, \\"NO\\" otherwise if n < 2: return \\"YES\\" diffs = [] for i in range(1, n): diff = sequence[i] - sequence[i - 1] if diff != 0: diffs.append(diff) if len(diffs) == 0: return \\"NO\\" for i in range(1, len(diffs)): if diffs[i] * diffs[i - 1] >= 0: return \\"NO\\" return \\"YES\\""},{"question":"def extract_domain(email): Extract and return the domain name from the given email address. Parameters: email (str): The email address from which to extract the domain. Returns: str: The domain name extracted from the email. >>> extract_domain(\\"contact@openai.com\\") 'openai.com' >>> extract_domain(\\"user@example.com\\") 'example.com' >>> extract_domain(\\"admin@github.com\\") 'github.com' >>> extract_domain(\\"info@gmail.com\\") 'gmail.com' >>> extract_domain(\\"support@yahoo.co.uk\\") 'yahoo.co.uk'","solution":"def extract_domain(email): Extract and return the domain name from the given email address. Parameters: email (str): The email address from which to extract the domain. Returns: str: The domain name extracted from the email. return email.split('@')[1]"},{"question":"def max_sum_sequence(n: int, sequence: List[int]) -> Union[int, str]: You are given a sequence of N integers. You are allowed to traverse the sequence and pick certain numbers such that the sum of the selected numbers is maximized. However, you have to follow certain rules while picking the numbers: 1. You cannot pick two adjacent numbers. 2. If you pick any number, you have to skip the next two numbers (i.e., if you pick the number at index i, you cannot pick the numbers at index i+1 and index i+2). Input: - n: An integer denoting the number of elements in the sequence. - sequence: A list of N integers. Output: - An integer which represents the maximum sum that can be obtained by selecting elements according to the above rules. If no elements can be picked to achieve a positive sum, return \\"kusoge\\". >>> max_sum_sequence(5, [3, 2, 5, 10, 7]) 15 >>> max_sum_sequence(4, [-1, -2, 4, -5]) 4 >>> max_sum_sequence(3, [-10, -20, -30]) \\"kusoge\\"","solution":"def max_sum_sequence(n, sequence): if n == 0: return \\"kusoge\\" # Initialize the max sums for each position with \\"kusoge\\" case for negative sums dp = [-float('inf')] * n # Base cases for i in range(n): if sequence[i] > 0: dp[i] = sequence[i] break else: return \\"kusoge\\" # If there is no positive number, return \\"kusoge\\" # Fill the dp array considering the given constraints for i in range(1, n): if sequence[i] > 0: dp[i] = max(dp[i], sequence[i]) if i > 1: dp[i] = max(dp[i], dp[i - 2] + sequence[i]) if i > 2: dp[i] = max(dp[i], dp[i - 3] + sequence[i]) # Find the maximum sum in dp array max_sum = max(dp) return max_sum if max_sum > 0 else \\"kusoge\\""},{"question":"def optimal_order(test_cases): Determine the optimal order in which Lancelot should face the dragons to minimize the total time spent facing the dragons. Args: test_cases (list): List containing tuples of (number of dragons, initial power, list of (strength, time) tuples for each dragon). Returns: list: List of strings representing the order of dragon indices or \\"IMPOSSIBLE\\" if the knight cannot defeat all dragons. >>> input_str = \\"2n3 15n3 1n5 3n2 2n2 10n6 5n10 15\\" >>> test_cases = parse_input(input_str) >>> results = optimal_order(test_cases) >>> results == [\\"3 1 2\\", \\"IMPOSSIBLE\\"] True >>> input_str = \\"1n1 20n5 10\\" >>> test_cases = parse_input(input_str) >>> results = optimal_order(test_cases) >>> results == [\\"1\\"] True >>> input_str = \\"1n1 5n10 15\\" >>> test_cases = parse_input(input_str) >>> results = optimal_order(test_cases) >>> results == [\\"IMPOSSIBLE\\"] True >>> input_str = \\"1n3 100n10 1n15 2n20 3\\" >>> test_cases = parse_input(input_str) >>> results = optimal_order(test_cases) >>> results == [\\"1 2 3\\"] True pass def parse_input(input_str): Parse the input string and convert it to a list of test cases. Args: input_str (str): Input string containing the test cases. Returns: list: List of test cases tuples of (number of dragons, initial power, list of (strength, time) tuples for each dragon). >>> input_str = \\"2n3 15n3 1n5 3n2 2n2 10n6 5n10 15\\" >>> test_cases = parse_input(input_str) >>> len(test_cases) 2 >>> test_cases[0] (3, 15, [(3, 1), (5, 3), (2, 2)]) >>> test_cases[1] (2, 10, [(6, 5), (10, 15)]) pass","solution":"def optimal_order(test_cases): results = [] for case in test_cases: n, p, dragons = case dragons_with_index = [(i + 1, s, t) for i, (s, t) in enumerate(dragons)] # Sort dragons by their strength, and then by time if they have the same strength sorted_dragons = sorted(dragons_with_index, key=lambda x: (x[1], x[2])) total_time = 0 possible = True for idx, strength, time in sorted_dragons: if p >= strength: p -= strength total_time += time else: possible = False break if possible: results.append(\\" \\".join(str(idx) for idx, _, _ in sorted_dragons)) else: results.append(\\"IMPOSSIBLE\\") return results # Parsing input and feeding it to the function def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n, p = map(int, lines[index].split()) index += 1 dragons = [] for i in range(n): s, t = map(int, lines[index].split()) dragons.append((s, t)) index += 1 test_cases.append((n, p, dragons)) return test_cases input_str = 2 3 15 3 1 5 3 2 2 2 10 6 5 10 15 test_cases = parse_input(input_str) results = optimal_order(test_cases) for result in results: print(result)"},{"question":"def num_distinct_islands(n: int, grid: List[str]) -> int: Given a square grid of size N x N, each cell can have a value of either '0' or '1', identify the number of distinct islands in the grid. An island is a group of '1's connected vertically or horizontally. Two islands are considered distinct if there is at least one cell in one island that isn't in the other. Examples: >>> num_distinct_islands(5, [\\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\", \\"00001\\"]) 3 >>> num_distinct_islands(3, [\\"111\\", \\"000\\", \\"111\\"]) 2 >>> num_distinct_islands(4, [\\"0000\\", \\"0000\\", \\"0000\\", \\"0000\\"]) 0 >>> num_distinct_islands(4, [\\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\"]) 1","solution":"def num_distinct_islands(n, grid): def dfs(x, y, visited, grid, n): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < n and not visited[cx][cy] and grid[cx][cy] == '1': visited[cx][cy] = True stack.extend([(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]) visited = [[False] * n for _ in range(n)] num_islands = 0 for i in range(n): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: num_islands += 1 dfs(i, j, visited, grid, n) return num_islands"},{"question":"def count_distinct_vowels(text: str) -> str: Determines if the text contains at least one vowel and counts the number of distinct vowels. >>> count_distinct_vowels(\\"Hello World!\\") 'Contains 2 distinct vowels.' >>> count_distinct_vowels(\\"Ths s smpl txt.\\") 'No vowels found.'","solution":"def count_distinct_vowels(text): Determines if the text contains at least one vowel and counts the number of distinct vowels. vowels = set(\\"aeiou\\") found_vowels = set() for char in text.lower(): if char in vowels: found_vowels.add(char) if found_vowels: return f\\"Contains {len(found_vowels)} distinct vowels.\\" else: return \\"No vowels found.\\""},{"question":"def max_dishes(n, m, dishes): Determines the maximum number of dishes the king can successfully prepare. Args: n (int): Number of dishes. m (int): Number of available ingredients. dishes (list): A list of lists where each sublist represents the required ingredients for a dish. Returns: int: Maximum number of dishes that can be prepared. >>> max_dishes(5, 3, [[2, 1, 3], [2, 2, 3], [1, 1], [0], [3, 1, 2, 3]]) == 4 >>> max_dishes(3, 2, [[1, 1], [1, 2], [2, 1, 2]]) == 3 >>> max_dishes(4, 1, [[1, 1], [0], [1, 1], [0]]) == 4 >>> max_dishes(6, 4, [[2, 1, 2], [2, 2, 3], [2, 3, 4], [1, 4], [1, 1], [0]]) == 6 >>> max_dishes(3, 3, [[3, 1, 2, 3], [0], [2, 2, 3]]) == 3 >>> max_dishes(2, 2, [[2, 1, 2], [2, 1, 2]]) == 2","solution":"def max_dishes(n, m, dishes): Determines the maximum number of dishes the king can successfully prepare. Args: n (int): Number of dishes. m (int): Number of available ingredients. dishes (list): A list of lists where each sublist represents the required ingredients for a dish. Returns: int: Maximum number of dishes that can be prepared. return len(dishes) # Simplest case: All provided dishes can be prepared."},{"question":"from typing import List, Tuple def min_groups(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of groups required so that any two participants whose IDs sum to an even number must run together. Args: T: The number of test cases. test_cases: A list of tuples where each tuple contains an integer N (number of participants) and a list of integers representing participant IDs. Returns: A list of integers where each integer represents the minimum number of groups required for the corresponding test case. Examples: >>> min_groups(2, [(5, [2, 4, 3, 5, 7]), (3, [8, 6, 2])]) [2, 1] >>> min_groups(1, [(6, [1, 2, 3, 4, 5, 6])]) [2]","solution":"def min_groups(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] participant_ids = test_cases[i][1] has_even = any(pid % 2 == 0 for pid in participant_ids) has_odd = any(pid % 2 != 0 for pid in participant_ids) if has_even and has_odd: results.append(2) else: results.append(1) return results"},{"question":"def count_characters(s: str) -> dict: Takes a string as an argument and returns a dictionary with each character in the string as the key and the number of times it appears as the value. >>> count_characters(\\"\\") {} >>> count_characters(\\"a\\") {\\"a\\": 1} >>> count_characters(\\"aabb\\") {\\"a\\": 2, \\"b\\": 2} >>> count_characters(\\"abcabc\\") {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2} >>> count_characters(\\"a b c\\") {\\"a\\": 1, \\" \\": 2, \\"b\\": 1, \\"c\\": 1} >>> count_characters(\\"a!a@a#\\") {\\"a\\": 3, \\"!\\": 1, \\"@\\": 1, \\"#\\": 1} >>> count_characters(\\"AaA\\") {\\"A\\": 2, \\"a\\": 1}","solution":"def count_characters(s): Takes a string as an argument and returns a dictionary with each character in the string as the key and the number of times it appears as the value. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def can_distribute_problems_fairly(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determine if it is possible to distribute the problems to participants fairly. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int]]): A list containing tuples with number of participants and total number of problems. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_distribute_problems_fairly(3, [(3, 8), (2, 5), (4, 10)]) ['YES', 'YES', 'NO'] >>> can_distribute_problems_fairly(1, [(7, 19)]) ['NO']","solution":"def can_distribute_problems_fairly(t, test_cases): results = [] for case in test_cases: n, p = case if (p % n == 0) or (p % n == n - 1): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to preprocess input and call function def solve(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n = int(data[index]) p = int(data[index + 1]) index += 2 test_cases.append((n, p)) results = can_distribute_problems_fairly(t, test_cases) for result in results: print(result)"},{"question":"def employee_of_the_month(employee_data): Given a list of employee data tuples (name, department, points), returns a dictionary with departments as keys and the employee with the highest points as values. pass def format_employee_of_the_month(employee_data): Given a list of employee data tuples (name, department, points), returns a list of formatted strings indicating the Employee of the Month for each department in the format \\"<Department>: <Employee's Name> <Points>\\". pass def test_basic_case(): employees = [ (\\"Alice\\", \\"HR\\", 88), (\\"Bob\\", \\"IT\\", 92), (\\"Charlie\\", \\"HR\\", 90), (\\"David\\", \\"IT\\", 85), (\\"Eve\\", \\"HR\\", 88), (\\"Frank\\", \\"IT\\", 92) ] result = employee_of_the_month(employees) assert result == { \\"HR\\": (\\"Charlie\\", 90), \\"IT\\": (\\"Bob\\", 92) } def test_all_employees_same_department(): employees = [ (\\"Alice\\", \\"HR\\", 88), (\\"Bob\\", \\"HR\\", 92), (\\"Charlie\\", \\"HR\\", 90) ] result = employee_of_the_month(employees) assert result == { \\"HR\\": (\\"Bob\\", 92) } def test_single_employee(): employees = [ (\\"Alice\\", \\"HR\\", 88) ] result = employee_of_the_month(employees) assert result == { \\"HR\\": (\\"Alice\\", 88) } def test_equal_points_first_appearance(): employees = [ (\\"Alice\\", \\"HR\\", 88), (\\"Bob\\", \\"HR\\", 88) ] result = employee_of_the_month(employees) assert result == { \\"HR\\": (\\"Alice\\", 88) } def test_empty_employee_list(): employees = [] result = employee_of_the_month(employees) assert result == {} def test_formatting(): employees = [ (\\"Alice\\", \\"HR\\", 88), (\\"Bob\\", \\"IT\\", 92) ] result = format_employee_of_the_month(employees) assert result == [ \\"HR: Alice 88\\", \\"IT: Bob 92\\" ]","solution":"def employee_of_the_month(employee_data): Given a list of employee data tuples (name, department, points), returns a dictionary with departments as keys and the employee with the highest points as values. department_best = {} for name, department, points in employee_data: points = int(points) if department not in department_best: department_best[department] = (name, points) else: if points > department_best[department][1]: department_best[department] = (name, points) return department_best def format_employee_of_the_month(employee_data): best_employees = employee_of_the_month(employee_data) result = [] for department, (name, points) in best_employees.items(): result.append(f\\"{department}: {name} {points}\\") return result"},{"question":"def can_combine(n, m, incompatibles, q, queries): Determine if subsets of ingredients can be combined without incompatibilities. Parameters: - n: Number of ingredients - m: Number of incompatible pairs - incompatibles: List of tuples (u, v) indicating incompatible ingredients - q: Number of queries - queries: List of lists of integers representing the subsets to be checked Returns: - List of \\"YES\\" or \\"NO\\" for each query Examples: >>> can_combine(5, 3, [(1, 2), (2, 3), (4, 5)], 3, [[3, 1, 3, 4], [2, 2, 5], [4, 1, 2, 3, 4]]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_combine(4, 0, [], 2, [[2, 1, 2], [3, 1, 2, 3]]) [\\"YES\\", \\"YES\\"] >>> can_combine(3, 3, [(1, 2), (1, 3), (2, 3)], 2, [[2, 1, 2], [3, 1, 2, 3]]) [\\"NO\\", \\"NO\\"] >>> can_combine(6, 2, [(1, 2), (4, 5)], 2, [[3, 1, 2, 3], [4, 1, 3, 4, 6]]) [\\"NO\\", \\"YES\\"] >>> can_combine(10, 5, [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)], 2, [[5, 1, 3, 5, 7, 9], [6, 1, 2, 3, 4, 5, 6]]) [\\"YES\\", \\"NO\\"] # Example usage: import pytest def test_example(): n = 5 m = 3 incompatibles = [(1, 2), (2, 3), (4, 5)] q = 3 queries = [ [3, 1, 3, 4], [2, 2, 5], [4, 1, 2, 3, 4] ] assert can_combine(n, m, incompatibles, q, queries) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_no_incompatibles(): n = 4 m = 0 incompatibles = [] q = 2 queries = [ [2, 1, 2], [3, 1, 2, 3] ] assert can_combine(n, m, incompatibles, q, queries) == [\\"YES\\", \\"YES\\"] def test_all_incompatible(): n = 3 m = 3 incompatibles = [(1, 2), (1, 3), (2, 3)] q = 2 queries = [ [2, 1, 2], [3, 1, 2, 3] ] assert can_combine(n, m, incompatibles, q, queries) == [\\"NO\\", \\"NO\\"] def test_partial_incompatible(): n = 6 m = 2 incompatibles = [(1, 2), (4, 5)] q = 2 queries = [ [3, 1, 2, 3], [4, 1, 3, 4, 6] ] assert can_combine(n, m, incompatibles, q, queries) == [\\"NO\\", \\"YES\\"] def test_large_input(): n = 10 m = 5 incompatibles = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] q = 2 queries = [ [5, 1, 3, 5, 7, 9], [6, 1, 2, 3, 4, 5, 6] ] assert can_combine(n, m, incompatibles, q, queries) == [\\"YES\\", \\"NO\\"]","solution":"def can_combine(n, m, incompatibles, q, queries): Determine if subsets of ingredients can be combined without incompatibilities. Parameters: - n: Number of ingredients - m: Number of incompatible pairs - incompatibles: List of tuples (u, v) indicating incompatible ingredients - q: Number of queries - queries: List of lists of integers representing the subsets to be checked Returns: - List of \\"YES\\" or \\"NO\\" for each query # Create a dictionary to store incompatibilities incompatible_dict = {i: set() for i in range(1, n + 1)} # Fill the dictionary with incompatible pairs for u, v in incompatibles: incompatible_dict[u].add(v) incompatible_dict[v].add(u) results = [] for query in queries: k = query[0] ingredients = query[1:] is_compatible = True # Check each pair in the subset for i in range(k): for j in range(i + 1, k): if ingredients[j] in incompatible_dict[ingredients[i]]: is_compatible = False break if not is_compatible: break if is_compatible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_operations_to_make_elements_equal(n: int, b: List[int]) -> int: Returns the minimum number of operations required to make all elements equal. >>> min_operations_to_make_elements_equal(4, [1, 2, 1, 3]) 2 >>> min_operations_to_make_elements_equal(3, [1, 1, 1]) 0 >>> min_operations_to_make_elements_equal(5, [1, 3, 5, 7, 9]) 8 >>> min_operations_to_make_elements_equal(5, [5, 5, 5, 5, 5]) 0 from typing import List # Unit Tests def test_all_elements_identical(): assert min_operations_to_make_elements_equal(3, [1, 1, 1]) == 0 assert min_operations_to_make_elements_equal(5, [5, 5, 5, 5, 5]) == 0 def test_increasing_elements(): assert min_operations_to_make_elements_equal(4, [1, 2, 1, 3]) == 2 assert min_operations_to_make_elements_equal(5, [1, 3, 5, 7, 9]) == 8 def test_decreasing_elements(): assert min_operations_to_make_elements_equal(5, [9, 7, 5, 3, 1]) == 8 assert min_operations_to_make_elements_equal(5, [10, 8, 6, 4, 2]) == 8 def test_mixed_elements(): assert min_operations_to_make_elements_equal(6, [3, 1, 3, 2, 5, 4]) == 4 assert min_operations_to_make_elements_equal(7, [10, 1, 1, 1, 10, 1, 10]) == 9","solution":"def min_operations_to_make_elements_equal(n, b): Returns the minimum number of operations required to make all elements equal. max_element = max(b) min_element = min(b) return max_element - min_element"},{"question":"def find_missing_score(q: int, queries: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the missing score based on the number of participants, the expected average score, and the given scores of n-1 participants. >>> find_missing_score(2, [((4, 5), [5, 8, 4]), ((3, 7), [10, 2])]) [3, 9] >>> find_missing_score(1, [((2, 5), [3])]) [7]","solution":"def find_missing_score(q, queries): results = [] for i in range(q): n, k = queries[i][0] scores = queries[i][1] total_score = n * k missing_score = total_score - sum(scores) results.append(missing_score) return results"},{"question":"def find_pair(numbers, k): Finds a pair of distinct numbers from the list that add up to k, ensuring the pair with the smallest first number is returned. If multiple pairs with the same smallest number exist, returns the pair with the smallest second number. Returns an empty list if no such pair exists. >>> find_pair([1, 2, 3, 4, 3, 2, 1], 5) == [1, 4] >>> find_pair([1, 2, 2, 4, 3, 1], 6) == [2, 4] >>> find_pair([1, 2, 3], 6) == [] >>> find_pair([], 5) == [] >>> find_pair([3], 6) == [] >>> find_pair([-1, 1, 2, 3, 5], 4) == [-1, 5] >>> find_pair([1, 2, 3, 8], 15) == [] >>> find_pair([2, 2, 2, 2, 4], 6) == [2, 4] >>> find_pair([1000000, 999999, 1, 5], 1000005) == [5, 1000000]","solution":"def find_pair(numbers, k): Finds a pair of distinct numbers from the list that add up to k, ensuring the pair with the smallest first number is returned. If multiple pairs with the same smallest number exist, returns the pair with the smallest second number. Returns an empty list if no such pair exists. numbers = list(set(numbers)) # Remove duplicates numbers.sort() # Sort the numbers left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == k: return [numbers[left], numbers[right]] elif current_sum < k: left += 1 else: right -= 1 return []"},{"question":"def longest_consonant_substring_length(s: str) -> int: Given a lowercase string consisting of alphabetic characters only, find the length of the longest consonant substring. Consonants are any characters that are not vowels (aeiou). >>> longest_consonant_substring_length(\\"bcdfgh\\") 6 >>> longest_consonant_substring_length(\\"abcdieio\\") 3 >>> longest_consonant_substring_length(\\"i\\") 0 >>> longest_consonant_substring_length(\\"b\\") 1 >>> longest_consonant_substring_length(\\"aeiou\\") 0 >>> longest_consonant_substring_length(\\"\\") 0 >>> longest_consonant_substring_length(\\"aeiubcdf\\") 4","solution":"def longest_consonant_substring_length(s): Returns the length of the longest continuous consonant substring in s. Parameters: s (str): The input string consisting of lowercase alphabetic characters only. Returns: int: The length of the longest continuous consonant substring in s. vowels = 'aeiou' max_length = current_length = 0 for char in s: if char in vowels: current_length = 0 else: current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def max_num_of_ones(binary_strings): Given a list of binary strings, returns a list containing the maximum number of '1's in any subsequence for each binary string. >>> max_num_of_ones(['110101']) [4] >>> max_num_of_ones(['10101']) [3] >>> max_num_of_ones(['11111']) [5] >>> max_num_of_ones(['1000']) [1] >>> max_num_of_ones(['0000']) [0] Parameters: binary_strings (list[str]): List of binary strings Returns: list[int]: List of integers representing the maximum number of '1's in any subsequence","solution":"def max_num_of_ones(binary_strings): Given a list of binary strings, returns a list containing the maximum number of '1's in any subsequence for each binary string. Parameters: binary_strings (list[str]): List of binary strings Returns: list[int]: List of integers representing the maximum number of '1's in any subsequence return [binary_string.count('1') for binary_string in binary_strings]"},{"question":"def findQuadruplet(A, X): Finds four distinct integers in A such that their sum is equal to X. Returns one such quadruplet if found, else returns an empty list. >>> findQuadruplet([1, 2, 3, 4, 5, 6], 10) [1, 2, 3, 4] >>> findQuadruplet([0, -1, 2, -3, 1, 4, -2], 0) [-1, 0, 1, 0] pass def handleTestCases(T, test_cases): Handles multiple test cases as per the input format and returns the results. pass def test_findQuadruplet_multiple_solutions(): A = [1, 2, 3, 4, 5, 6] X = 10 result = findQuadruplet(A, X) assert sum(result) == X and len(result) == 4 def test_findQuadruplet_single_solution(): A = [0, -1, 2, -3, 1, 4, -2] X = 0 result = findQuadruplet(A, X) assert sum(result) == X and len(result) == 4 def test_findQuadruplet_no_solution(): A = [1, 2, 3] X = 10 result = findQuadruplet(A, X) assert result == [] def test_findQuadruplet_large_values(): A = [10**9, -10**9, 10**9, -10**9, 0, 1, -1] X = 0 result = findQuadruplet(A, X) assert sum(result) == X and len(result) == 4 def test_handleTestCases(): test_cases = [ ((6, 10), [1, 2, 3, 4, 5, 6]), ((7, 0), [0, -1, 2, -3, 1, 4, -2]) ] results = handleTestCases(2, test_cases) assert sum(results[0]) == 10 and len(results[0]) == 4 assert sum(results[1]) == 0 and len(results[1]) == 4","solution":"def findQuadruplet(A, X): Finds four distinct integers in A such that their sum is equal to X. Returns one such quadruplet if found, else returns an empty list. A.sort() n = len(A) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = A[i] + A[j] + A[left] + A[right] if current_sum == X: return [A[i], A[j], A[left], A[right]] elif current_sum < X: left += 1 else: right -= 1 return [] def handleTestCases(T, test_cases): results = [] for i in range(T): N, X = test_cases[i][0] A = test_cases[i][1] results.append(findQuadruplet(A, X)) return results"},{"question":"def max_hikes(test_cases): Calculates the maximum number of complete hikes Bob can perform for each test case. Parameters: test_cases (list): A list of tuples with each tuple containing (S, D). Returns: list: A list of integers representing the maximum number of complete hikes for each test case. >>> max_hikes([(50, 10), (20, 5), (15, 7), (30, 15), (25, 8)]) [5, 4, 2, 2, 3] >>> max_hikes([(1, 1), (1, 10), (10, 10)]) [1, 0, 1]","solution":"def max_hikes(test_cases): Calculates the maximum number of complete hikes Bob can perform for each test case. Parameters: test_cases (list): A list of tuples with each tuple containing (S, D). Returns: list: A list of integers representing the maximum number of complete hikes for each test case. results = [] for S, D in test_cases: results.append(S // D) return results # Example usage: # test_cases = [(50, 10), (20, 5), (15, 7), (30, 15), (25, 8)] # print(max_hikes(test_cases)) # Output: [5, 4, 2, 2, 3]"},{"question":"def min_jumps(K: int, obstacles: List[int]) -> int: Returns the minimum number of jumps required for the runner to reach or exceed the position of the furthest obstacle. :param K: int, maximum jump distance. :param obstacles: list of int, sorted positions of obstacles. :return: int, minimum number of jumps required. >>> min_jumps(4, [1, 2, 3, 7]) 2 >>> min_jumps(3, [1, 2, 4, 7]) 3","solution":"def min_jumps(K, obstacles): Returns the minimum number of jumps required for the runner to reach or exceed the position of the furthest obstacle. :param K: int, maximum jump distance. :param obstacles: list of int, sorted positions of obstacles. :return: int, minimum number of jumps required. n = len(obstacles) # Initialize the current position current_position = 0 jumps = 0 i = 0 while current_position < obstacles[-1]: # Perform a jump jumps += 1 # Find the furthest reachable obstacle within the range [current_position, current_position + K] while i < n and obstacles[i] <= current_position + K: i += 1 if i == 0: # No further progress possible (Though given constraints should not lead to this) return -1 # Move to the furthest reachable obstacle current_position = obstacles[i - 1] return jumps"},{"question":"def paint_grid(N: int) -> List[List[int]]: Determines if it is possible to paint the grid into two distinct regions. Returns a valid configuration or \\"Not possible\\" if not feasible. >>> paint_grid(2) [[1, 2], [2, 1]] >>> paint_grid(4) [[1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1]] >>> paint_grid(3) \\"Not possible\\"","solution":"def paint_grid(N): Determines if it is possible to paint the grid into two distinct regions. Returns a valid configuration or \\"Not possible\\" if not feasible. if N % 2 != 0: return \\"Not possible\\" grid = [[0] * N for _ in range(N)] # Fill the grid with alternating pattern to ensure two equal regions for i in range(N): for j in range(N): if (i + j) % 2 == 0: grid[i][j] = 1 else: grid[i][j] = 2 return grid"},{"question":"from typing import List def top_k_frequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the given array of integers. If there are multiple valid answers, any order of elements is correct. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([4, 4, 4, 2, 2, 3, 3, 3], 3) [4, 3, 2] from collections import Counter import heapq def test_top_k_frequent_basic(): assert sorted(top_k_frequent([1, 1, 1, 2, 2, 3], 2)) == [1, 2] def test_top_k_frequent_single_element(): assert top_k_frequent([1], 1) == [1] def test_top_k_frequent_with_multiple_valid_answers(): result = top_k_frequent([4, 4, 4, 2, 2, 3, 3, 3], 3) result.sort() assert result == [2, 3, 4] def test_top_k_frequent_large_input(): nums = [i for i in range(10**5)] k = 50 result = top_k_frequent(nums, k) assert len(result) == k def test_top_k_frequent_equal_frequency(): assert sorted(top_k_frequent([4, 5, 6, 4, 5, 6], 2)) in [[4, 5], [4, 6], [5, 6]]","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements in the given array of integers. If there are multiple valid answers, any order of elements is correct. # Build a frequency map count = Counter(nums) # Use a heap to get the k most frequent elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"from typing import List def canRemoveAllPairs(grid: List[List[int]]) -> bool: Determines if it is possible to remove all pairs of cards from the grid. Each identifier appears exactly twice in the grid. Args: grid (2D list of integers): The grid where each cell contains a card identifier. Returns: bool: True if it is possible to remove all pairs of cards, False otherwise. >>> canRemoveAllPairs([[1, 2, 3], [1, 2, 3]]) True >>> canRemoveAllPairs([[1, 2, 2], [1, 3, 3]]) True >>> canRemoveAllPairs([[1, 2, 3], [4, 5, 6]]) False","solution":"from collections import defaultdict def canRemoveAllPairs(grid): Determines if it is possible to remove all pairs of cards from the grid. Each identifier appears exactly twice in the grid. Args: grid (2D list of integers): The grid where each cell contains a card identifier. Returns: bool: True if it is possible to remove all pairs of cards, False otherwise. # Dictionary to count occurrences of each identifier count_dict = defaultdict(int) for row in grid: for card in row: count_dict[card] += 1 # Check if each card identifier appears exactly twice for count in count_dict.values(): if count != 2: return False return True"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence in a given string. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 pass def solve(test_cases: List[str]) -> List[int]: Given a list of strings, return a list with the length of the longest palindromic subsequence for each string. >>> solve([\\"bbbab\\", \\"cbbd\\"]) [4, 2] >>> solve([\\"abcd\\", \\"aaaabaaa\\"]) [1, 7] pass","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def calculate_val_xy(x: int, y: int, k: int) -> int: Calculates the value of the building at coordinates (x, y) after k update cycles. The value of a building is determined by the sum of points from all its neighboring buildings. >>> calculate_val_xy(0, 0, 0) 0 >>> calculate_val_xy(0, 0, 1) 8 >>> calculate_val_xy(1, 2, 2) 16 >>> calculate_val_xy(-100, 100, 500) 4000","solution":"def calculate_val_xy(x, y, k): Calculates the value of the building at coordinates (x, y) after k update cycles. The value of a building is determined by the sum of points from all its neighboring buildings. if k == 0: return 0 return 8 * k # Example usage of the function # This will be useful for manual inspection before running the test cases. x, y, k = 1, 2, 2 print(calculate_val_xy(x, y, k)) # Expected output: 80"},{"question":"def min_operations_to_transform(source: str, target: str) -> int: Determines the minimum number of operations required to transform the source string into the target string using insert, delete, and replace operations. >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"ac\\") 1 >>> min_operations_to_transform(\\"\\", \\"abc\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"ab\\", \\"abc\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"ab\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"adc\\") 1 >>> min_operations_to_transform(\\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxzy\\") 2","solution":"def min_operations_to_transform(source, target): n = len(source) m = len(target) # Create a DP array to store the edit distance dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the base cases for i in range(n + 1): dp[i][0] = i # if target is empty, remove all characters from source for j in range(m + 1): dp[0][j] = j # if source is empty, insert all characters of target # Fill the DP array according to the operations allowed for i in range(1, n + 1): for j in range(1, m + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[n][m] # Example usage: print(min_operations_to_transform(\\"kitten\\", \\"sitting\\")) # Output: 3 print(min_operations_to_transform(\\"abc\\", \\"ac\\")) # Output: 1"},{"question":"class TaskManager: def __init__(self): Initialize a new TaskManager instance. pass def add_task(self, description, priority): Add a new task with the given description and priority. pass def complete_task(self, description): Mark the task with the given description as completed. pass def list_tasks(self): List all remaining tasks ordered by priority from highest to lowest. >>> manager = TaskManager() >>> manager.add_task(\\"Task1\\", 5) >>> manager.add_task(\\"Task2\\", 10) >>> manager.list_tasks() [\\"Task2 10\\", \\"Task1 5\\"] pass def process_commands(commands): Process a series of task commands. >>> commands = [ ... \\"add Task1 5\\", ... \\"add Task2 10\\", ... \\"list\\", ... \\"complete Task1\\", ... \\"list\\", ... \\"add Task3 1\\", ... \\"list\\" ... ] >>> process_commands(commands) [\\"Task2 10\\", \\"Task1 5\\", \\"Task2 10\\", \\"Task2 10\\", \\"Task3 1\\"] manager = TaskManager() output = [] for command in commands: parts = command.split() if parts[0] == 'add': description = parts[1] priority = int(parts[2]) manager.add_task(description, priority) elif parts[0] == 'complete': description = parts[1] manager.complete_task(description) elif parts[0] == 'list': output.extend(manager.list_tasks()) return output","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, description, priority): self.tasks[description] = priority def complete_task(self, description): if description in self.tasks: del self.tasks[description] def list_tasks(self): sorted_tasks = sorted(self.tasks.items(), key=lambda item: item[1], reverse=True) return [f\\"{description} {priority}\\" for description, priority in sorted_tasks] def process_commands(commands): manager = TaskManager() output = [] for command in commands: parts = command.split() if parts[0] == 'add': description = parts[1] priority = int(parts[2]) manager.add_task(description, priority) elif parts[0] == 'complete': description = parts[1] manager.complete_task(description) elif parts[0] == 'list': output.extend(manager.list_tasks()) return output"},{"question":"def decimal_to_fixed_length_binary(n: int, house_numbers: List[int]) -> List[str]: Converts each house number to a fixed-length binary string. The length of the binary string is determined by the binary representation of the largest number in the list. Args: n: int, number of house numbers house_numbers: list of integers, house numbers in decimal format Returns: list of strings, where each string is the binary representation of each house number with leading zeros to match the length of the largest number's binary representation. >>> decimal_to_fixed_length_binary(5, [3, 7, 2, 15, 6]) ['0011', '0111', '0010', '1111', '0110'] >>> decimal_to_fixed_length_binary(1, [0]) ['0'] from solution import decimal_to_fixed_length_binary def test_single_house_number(): assert decimal_to_fixed_length_binary(1, [3]) == ['11'] assert decimal_to_fixed_length_binary(1, [0]) == ['0'] assert decimal_to_fixed_length_binary(1, [1023]) == ['1111111111'] def test_multiple_house_numbers(): assert decimal_to_fixed_length_binary(5, [3, 7, 2, 15, 6]) == ['0011', '0111', '0010', '1111', '0110'] def test_all_zeros(): assert decimal_to_fixed_length_binary(3, [0, 0, 0]) == ['0', '0', '0'] def test_varied_length_numbers(): assert decimal_to_fixed_length_binary(6, [3, 7, 16, 512, 4, 0]) == ['0000000011', '0000000111', '0000010000', '1000000000', '0000000100', '0000000000'] def test_invalid_house_numbers(): try: decimal_to_fixed_length_binary(2, [-1, 1024]) assert False, \\"Exception should have been raised for out of range input\\" except ValueError: assert True try: decimal_to_fixed_length_binary(3, [1025, 500, 1]) assert False, \\"Exception should have been raised for out of range input\\" except ValueError: assert True","solution":"def decimal_to_fixed_length_binary(n, house_numbers): Converts each house number to a fixed-length binary string. The length of the binary string is determined by the binary representation of the largest number in the list. Args: n: int, number of house numbers house_numbers: list of integers, house numbers in decimal format Returns: list of strings, where each string is the binary representation of each house number with leading zeros to match the length of the largest number's binary representation. if n == 0: return [] if not all(0 <= num < 1024 for num in house_numbers): raise ValueError(\\"House number out of allowed range.\\") max_num = max(house_numbers) max_len = len(bin(max_num)) - 2 # excluding '0b' prefix result = [] for num in house_numbers: binary_str = bin(num)[2:].zfill(max_len) result.append(binary_str) return result # Example usage # print(decimal_to_fixed_length_binary(5, [3, 7, 2, 15, 6]))"},{"question":"def final_sequence_sum(operations: List[str]) -> int: Computes the sum of a sequence after a series of add and remove operations. :param operations: A list of operations. Each operation is a string \\"ADD x\\" or \\"REMOVE x\\". :return: The sum of the elements in the sequence after all operations. >>> final_sequence_sum([\\"ADD 3\\", \\"ADD 5\\", \\"REMOVE 3\\", \\"ADD 7\\", \\"REMOVE 5\\"]) 7 >>> final_sequence_sum([\\"ADD 10\\", \\"ADD 20\\", \\"ADD 10\\"]) 40 >>> final_sequence_sum([\\"ADD 1\\", \\"REMOVE 2\\", \\"ADD 1\\", \\"REMOVE 1\\"]) 1 sequence = []","solution":"def final_sequence_sum(operations): Computes the sum of a sequence after a series of add and remove operations. :param operations: A list of operations. Each operation is a string \\"ADD x\\" or \\"REMOVE x\\". :return: The sum of the elements in the sequence after all operations. sequence = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, x = operation.split() sequence.append(int(x)) elif operation.startswith(\\"REMOVE\\"): _, x = operation.split() x = int(x) for i in range(len(sequence) - 1, -1, -1): if sequence[i] == x: del sequence[i] break return sum(sequence)"},{"question":"def find_median(scores): Given a list of scores, find the median score. If the number of scores is even, the median is the average of the two middle scores. If the number of scores is odd, the median is the middle score. Args: scores (List[int]): List of scores of team members. Returns: float: The median score. pass def sort_teams_by_median(T, N, teams_scores): Sort teams by their median scores in increasing order. Args: T (int): Number of teams. N (int): Number of members in each team. teams_scores (List[List[int]]): List of scores for each team. Returns: List[int]: Sorted list of team indices based on their median scores. pass def marathon(): Main function to read inputs, sort teams by their median scores and print the indices of the teams. pass # Example Usage: if __name__ == \\"__main__\\": marathon()","solution":"def find_median(scores): scores.sort() n = len(scores) mid = n // 2 if n % 2 == 0: # Even number of elements return (scores[mid - 1] + scores[mid]) / 2 else: # Odd number of elements return scores[mid] def sort_teams_by_median(T, N, teams_scores): teams_with_medians = [] for index, scores in enumerate(teams_scores): median_score = find_median(scores) teams_with_medians.append((median_score, index + 1)) # store indices as 1-based # Sort by median score; preserve the original order for ties teams_with_medians.sort(key=lambda x: x[0]) return [team_index for (_, team_index) in teams_with_medians] def marathon(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) N = int(data[1]) teams_scores = [] index = 2 for _ in range(T): scores = list(map(int, data[index:index+N])) teams_scores.append(scores) index += N result = sort_teams_by_median(T, N, teams_scores) for team_index in result: print(team_index)"},{"question":"def are_trees_identical(tree1, tree2): Determines if two binary trees are identical. Args: tree1 (dict): The first binary tree. tree2 (dict): The second binary tree. Returns: bool: True if the trees are identical, False otherwise. Examples: >>> tree1 = { ... \\"value\\": 1, ... \\"left\\": { ... \\"value\\": 2, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": { ... \\"value\\": 3, ... \\"left\\": { ... \\"value\\": 4, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": { ... \\"value\\": 5, ... \\"left\\": None, ... \\"right\\": None ... } ... } ... } >>> tree2 = { ... \\"value\\": 1, ... \\"left\\": { ... \\"value\\": 2, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": { ... \\"value\\": 3, ... \\"left\\": { ... \\"value\\": 4, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": { ... \\"value\\": 5, ... \\"left\\": None, ... \\"right\\": None ... } ... } ... } >>> are_trees_identical(tree1, tree2) True >>> tree1 = { ... \\"value\\": 1, ... \\"left\\": { ... \\"value\\": 2, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": None ... } >>> tree2 = { ... \\"value\\": 1, ... \\"left\\": { ... \\"value\\": 2, ... \\"left\\": { ... \\"value\\": 3, ... \\"left\\": None, ... \\"right\\": None ... }, ... \\"right\\": None ... }, ... \\"right\\": None ... } >>> are_trees_identical(tree1, tree2) False","solution":"def are_trees_identical(tree1, tree2): Determines if two binary trees are identical. Args: tree1 (dict): The first binary tree. tree2 (dict): The second binary tree. Returns: bool: True if the trees are identical, False otherwise. # If both nodes are None, they are identical if not tree1 and not tree2: return True # If one of them is None or their values are not equal, they are not identical if not tree1 or not tree2 or tree1[\\"value\\"] != tree2[\\"value\\"]: return False # Recursively check the left and right subtrees return (are_trees_identical(tree1[\\"left\\"], tree2[\\"left\\"]) and are_trees_identical(tree1[\\"right\\"], tree2[\\"right\\"]))"},{"question":"from typing import List from collections import deque def shortest_path(grid: List[List[int]]) -> int: Given a grid of '0's and '1's, where '0's represent open land and '1's represent walls, find the shortest path from the top-left corner to the bottom-right corner. The path can only move up, down, left, or right, and cannot pass through walls. Args: grid: List[List[int]] - an n x m grid of '0's and '1's where 1 <= n, m <= 100 Returns: int: the length of the shortest path, or -1 if no such path exists Examples: >>> grid = [ [0, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0] ] >>> shortest_path(grid) 7 >>> grid = [ [0, 1], [1, 0] ] >>> shortest_path(grid) -1 >>> grid = [ [0, 0, 0], [1, 1, 0], [1, 0, 0] ] >>> shortest_path(grid) 5 >>> grid = [ [0, 1], [1, 1] ] >>> shortest_path(grid) -1 >>> grid = [[0]] >>> shortest_path(grid) 1 >>> grid = [ [0, 1, 0], [1, 1, 1], [0, 0, 0] ] >>> shortest_path(grid) -1 >>> grid = [[0]*10 for _ in range(10)] >>> shortest_path(grid) 19","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == n - 1 and c == m - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def count_unique_subarrays(N: int, M: int, A: List[int]) -> int: Count the number of unique subarrays of length M with all distinct elements. >>> count_unique_subarrays(5, 3, [1, 2, 1, 2, 3]) 1 >>> count_unique_subarrays(5, 2, [1, 2, 1, 2, 3]) 3 >>> count_unique_subarrays(5, 1, [1, 2, 1, 2, 3]) 3 >>> count_unique_subarrays(6, 3, [1, 2, 3, 4, 5, 6]) 4 >>> count_unique_subarrays(5, 3, [1, 1, 1, 1, 1]) 0 >>> count_unique_subarrays(4, 4, [1, 2, 3, 4]) 1","solution":"def count_unique_subarrays(N, M, A): Count the number of unique subarrays of length M with all distinct elements. unique_subarrays = set() for i in range(N - M + 1): subarray = tuple(A[i:i+M]) if len(subarray) == len(set(subarray)): unique_subarrays.add(subarray) return len(unique_subarrays) # To handle input directly from standard input as mentioned in the problem statement if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) M = int(data[1]) A = list(map(int, data[2:])) result = count_unique_subarrays(N, M, A) print(result)"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def min_semesters(n: int, prerequisites: List[Tuple[int, int]]) -> int: Determine the minimum number of semesters required to complete all the courses. >>> min_semesters(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> min_semesters(3, [(1, 2), (2, 3)]) 3 # Your code here def min_semesters_multiple_cases(cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of semesters required for multiple cases. >>> min_semesters_multiple_cases([(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 2, [(1, 2), (2, 3)])]) [5, 3] >>> min_semesters_multiple_cases([(3, 0, [])]) [1] # Your code here def test_min_semesters_example_cases(): cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 2, [(1, 2), (2, 3)]) ] expected_outputs = [5, 3] assert min_semesters_multiple_cases(cases) == expected_outputs def test_min_semesters_no_prerequisites(): cases = [ (3, 0, []) ] expected_outputs = [1] assert min_semesters_multiple_cases(cases) == expected_outputs def test_min_semesters_complex_prerequisites(): cases = [ (4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) ] expected_outputs = [3] assert min_semesters_multiple_cases(cases) == expected_outputs def test_min_semesters_large_case(): cases = [ (6, 6, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6), (4, 6)]) ] expected_outputs = [4] assert min_semesters_multiple_cases(cases) == expected_outputs","solution":"from collections import deque, defaultdict def min_semesters(n, prerequisites): # Using Kahn's Algorithm to find minimum semesters (Topological Sort) in_degree = [0] * (n + 1) graph = defaultdict(list) for u, v in prerequisites: graph[u].append(v) in_degree[v] += 1 queue = deque() for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) semester_count = 0 studied_courses = 0 while queue: size = len(queue) for _ in range(size): course = queue.popleft() studied_courses += 1 for next_course in graph[course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) semester_count += 1 return semester_count if studied_courses == n else -1 def min_semesters_multiple_cases(cases): results = [] for case in cases: n, m, prerequisites = case results.append(min_semesters(n, prerequisites)) return results"},{"question":"def count_distinct_strings(test_cases: List[str]) -> List[int]: Returns the number of distinct strings for each test case. Args: test_cases (list): List of strings, each string containing characters 'a' to 'z' and possibly '*' characters. Returns: list: List of integers, each representing the number of distinct strings that can be generated for the corresponding test case. >>> count_distinct_strings([\\"a*\\"]) == [26] >>> count_distinct_strings([\\"*ab\\", \\"**c\\"]) == [26, 676] >>> count_distinct_strings([\\"abc\\", \\"defg\\"]) == [1, 1] >>> count_distinct_strings([\\"****\\"]) == [26**4] >>> count_distinct_strings([\\"a*b*c\\", \\"*****\\", \\"abcd\\"]) == [676, 26**5, 1] >>> count_distinct_strings([\\"\\"]) == [1] >>> count_distinct_strings([\\"a\\"]) == [1] >>> count_distinct_strings([\\"*\\"]) == [26]","solution":"def count_distinct_strings(test_cases): Returns the number of distinct strings for each test case. Args: test_cases (list): List of strings, each string containing characters 'a' to 'z' and possibly '*' characters. Returns: list: List of integers, each representing the number of distinct strings that can be generated for the corresponding test case. results = [] for s in test_cases: num_stars = s.count('*') distinct_strings = 26 ** num_stars results.append(distinct_strings) return results # Example usage # test_cases = [\\"a*\\", \\"*ab\\", \\"**c\\"] # print(count_distinct_strings(test_cases)) # Output: [26, 26, 676]"},{"question":"def can_form_domino_line(n, dominoes): Check if a sequence of dominoes can form a line with matching numbers on adjacent ends. >>> can_form_domino_line(3, [1, 2, 2, 3, 3, 1]) == True >>> can_form_domino_line(4, [1, 2, 2, 3, 3, 4, 4, 1]) == True >>> can_form_domino_line(2, [1, 2, 3, 4]) == False def domino_sequences(t, sequences): Determine if sequences of dominoes can form a line with matching numbers on adjacent ends. >>> domino_sequences(3, [(3, 1, 2, 2, 3, 3, 1), (4, 1, 2, 2, 3, 3, 4, 4, 1), (2, 1, 2, 3, 4)]) == [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> domino_sequences(2, [(3, 1, 2, 2, 3, 3, 1), (2, 1, 2, 3, 4)]) == [\\"Yes\\", \\"No\\"]","solution":"def can_form_domino_line(n, dominoes): from collections import defaultdict, deque graph = defaultdict(int) edges = defaultdict(list) for i in range(n): a, b = dominoes[2 * i], dominoes[2 * i + 1] graph[a] += 1 graph[b] += 1 edges[a].append(b) edges[b].append(a) odd_degree_vertices = [v for v in graph if graph[v] % 2 != 0] if len(odd_degree_vertices) not in [0, 2]: return False start_vertex = next(iter(graph)) queue = deque([start_vertex]) visited = set() while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) for neighbor in edges[vertex]: if neighbor not in visited: queue.append(neighbor) if len(visited) == len(graph): return True return False def domino_sequences(t, sequences): results = [] for i in range(t): n = sequences[i][0] dominoes = sequences[i][1:] if can_form_domino_line(n, dominoes): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def calculator(a, operator, b): Simulates a basic calculator capable of performing addition, subtraction, multiplication, and division. Parameters: a (float): The first operand. operator (str): The operator ('+', '-', '*', '/'). b (float): The second operand. Returns: float: The result of the operation, or None if division by zero occurs. >>> calculator(2, '+', 3) 5.0 >>> calculator(5, '-', 2) 3.0 >>> calculator(3, '*', 4) 12.0 >>> calculator(6, '/', 3) 2.0 >>> calculator(4, '/', 0) None >>> calculator(2, '^', 3) Traceback (most recent call last): ... ValueError: Invalid operator","solution":"def calculator(a, operator, b): Returns the result of a basic arithmetic operation between two floats. Parameters: a (float): The first operand. operator (str): The operator ('+', '-', '*', '/'). b (float): The second operand. Returns: float: The result of the operation, or None if division by zero occurs. if operator == '+': return a + b elif operator == '-': return a - b elif operator == '*': return a * b elif operator == '/': if b == 0: return None return a / b else: raise ValueError(\\"Invalid operator\\")"},{"question":"def organize_books(n: int, book_data: List[str]) -> List[str]: Organize books by the number of tags and then alphabetically by their titles. Args: n (int): Number of books. book_data (list of str): Each element is a string with the book title followed by the number of tags and the tags themselves. Returns: list of str: Titles of the books in the desired order. >>> organize_books(3, [\\"the great gatsby 3 classic literature fiction\\", \\"moby dick 2 sea adventure\\", \\"to kill a mockingbird 2 classic fiction\\"]) [\\"moby dick\\", \\"to kill a mockingbird\\", \\"the great gatsby\\"]","solution":"def organize_books(n, book_data): Organizes books based on the number of tags and then by the alphabetical order of the title. Args: n (int): Number of books. book_data (list of str): Each element is a string with the book title followed by the number of tags and the tags themselves. Returns: list of str: Titles of the books in the desired order. books = [] for data in book_data: parts = data.split() title_idx = 0 for i in range(len(parts)): if parts[i].isdigit(): title_idx = i break title = ' '.join(parts[:title_idx]) num_tags = int(parts[title_idx]) books.append((num_tags, title)) books.sort(key=lambda x: (x[0], x[1])) return [title for _, title in books]"},{"question":"from typing import List def solve(inputs: List[str]) -> List[int]: Find the shortest path in a grid from the top-left to the bottom-right, avoiding obstacles. Args: inputs (List[str]): A list of strings representing multiple datasets, each starting with a number n, followed by n lines of grid. Returns: List[int]: A list of integers representing the length of the shortest path for each dataset. If no path exists, it returns -1 for that dataset. Example: >>> solve([\\"5\\", \\".....\\", \\".X.X.\\", \\"...X.\\", \\".X.X.\\", \\".....\\", \\"5\\", \\"XXX..\\", \\"X..XX\\", \\".X..X\\", \\"X...X\\", \\".....\\", \\"0\\"]) [8, -1]","solution":"from collections import deque def shortest_path(grid): n = len(grid) if grid[0][0] == 'X' or grid[n-1][n-1] == 'X': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == n-1 and c == n-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1 def solve(inputs): results = [] idx = 0 while idx < len(inputs): n = int(inputs[idx]) if n == 0: break grid = inputs[idx + 1: idx + 1 + n] results.append(shortest_path(grid)) idx += n + 1 return results"},{"question":"def largest_number(nums: List[int]) -> str: Find the largest number that can be constructed by concatenating all the integers in the array. >>> largest_number([10, 2]) \\"210\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([1]) \\"1\\" >>> largest_number([0]) \\"0\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) \\"9609938824824769735703560743981399\\" >>> largest_number([12, 121]) \\"12121\\" >>> largest_number([121, 12]) \\"12121\\" >>> largest_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) \\"9876543210\\" >>> largest_number([10, 100, 1000, 2]) \\"2101001000\\"","solution":"def compare(x, y): if x + y > y + x: return -1 else: return 1 def largest_number(nums): nums = list(map(str, nums)) for i in range(len(nums)): for j in range(len(nums) - 1, i, -1): if compare(nums[j-1], nums[j]) > 0: nums[j], nums[j-1] = nums[j-1], nums[j] result = ''.join(nums) return result if result[0] != '0' else '0'"},{"question":"def count_palindromic_substrings(S: str) -> int: Count the number of palindromic substrings in a given string S. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"abba\\") 6 pass","solution":"def count_palindromic_substrings(S): Count the number of palindromic substrings in a given string S. n = len(S) count = 0 # Function to expand around the center and count palindromes def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and S[left] == S[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return count"},{"question":"from typing import List def generateMatrix(n: int) -> List[List[int]]: Generate an n x n matrix in a spiral order pattern starting with the number 1. >>> generateMatrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generateMatrix(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ]","solution":"def generateMatrix(n): Generate an n x n matrix in a spiral order pattern starting with the number 1. if n <= 0: return [] matrix = [[0] * n for _ in range(n)] dx, dy = [0, 1, 0, -1], [1, 0, -1, 0] # Directions: right, down, left, up x, y, direction = 0, 0, 0 for i in range(1, n*n + 1): matrix[x][y] = i nx, ny = x + dx[direction], y + dy[direction] if 0 <= nx < n and 0 <= ny < n and matrix[nx][ny] == 0: x, y = nx, ny else: direction = (direction + 1) % 4 x, y = x + dx[direction], y + dy[direction] return matrix"},{"question":"def has_repeated_substring(s: str, k: int) -> str: Determines if there is a substring of length k that appears at least twice in the string. >>> has_repeated_substring(\\"abcabc\\", 3) == \\"YES\\" >>> has_repeated_substring(\\"abcdefg\\", 2) == \\"NO\\" >>> has_repeated_substring(\\"\\", 1) == \\"NO\\" >>> has_repeated_substring(\\"aaaa\\", 1) == \\"YES\\" >>> has_repeated_substring(\\"abcdefgh\\", 3) == \\"NO\\" >>> has_repeated_substring(\\"abcdabcdefg\\", 4) == \\"YES\\" >>> has_repeated_substring(\\"aaaa\\", 4) == \\"NO\\" >>> has_repeated_substring(\\"xyzxy\\", 2) == \\"YES\\"","solution":"def has_repeated_substring(s, k): Determines if there is a substring of length k that appears at least twice in the string s. seen_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] if substring in seen_substrings: return \\"YES\\" seen_substrings.add(substring) return \\"NO\\""},{"question":"def count_cells_greater_than_x(grid: List[List[int]], x: int) -> int: Count the number of cells in the 4x4 grid that contain an integer greater than x. Args: grid (list of list of int): A 4x4 grid of integers. x (int): The threshold integer. Returns: int: The number of cells with an integer greater than x. >>> count_cells_greater_than_x([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]], 10) 6 >>> count_cells_greater_than_x([ ... [1, 2, 3, 4], ... [1, 2, 3, 4], ... [1, 2, 3, 4], ... [1, 2, 3, 4]], 10) 0 >>> count_cells_greater_than_x([ ... [11, 12, 13, 14], ... [15, 16, 17, 18], ... [19, 20, 21, 22], ... [23, 24, 25, 26]], 10) 16 # Your code here from typing import List # Example usage grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] x = 10 print(count_cells_greater_than_x(grid, x)) # Output: 6","solution":"def count_cells_greater_than_x(grid, x): Count the number of cells in the 4x4 grid that contain an integer greater than x. Args: grid (list of list of int): A 4x4 grid of integers. x (int): The threshold integer. Returns: int: The number of cells with an integer greater than x. count = 0 for row in grid: for cell in row: if cell > x: count += 1 return count # Reading input from standard input def read_input(): import sys input = sys.stdin.read().strip().split() grid = [] for i in range(4): grid.append(list(map(int, input[i * 4:(i + 1) * 4]))) x = int(input[16]) return grid, x if __name__ == \\"__main__\\": grid, x = read_input() print(count_cells_greater_than_x(grid, x))"},{"question":"def calculate_score(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculates the player's final score for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (N, cards) where N is the number of cards drawn and cards is a list of integers representing the card values. Returns: list of int: Final scores for each test case. >>> calculate_score(3, [(7, [2, 9, 4, 8, 5, 6, 10]), (4, [7, 1, 5, 3]), (5, [6, 6, 6, 6, 6])]) [38, 16, 30] >>> calculate_score(1, [(3, [1, 2, 3])]) [6] >>> calculate_score(1, [(6, [1, 2, 3, 7, 8, 10])]) [30] >>> calculate_score(1, [(5, [4, 4, 4, 4, 4])]) [20] >>> calculate_score(2, [(1, [10]), (8, [10, 9, 8, 7, 6, 5, 4, 3])]) [10, 40]","solution":"def calculate_score(T, test_cases): Calculates the player's final score for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (N, cards) where N is the number of cards drawn and cards is a list of integers representing the card values. Returns: list of int: Final scores for each test case. results = [] for N, cards in test_cases: if N <= 5: results.append(sum(cards)) else: cards_sorted = sorted(cards, reverse=True) results.append(sum(cards_sorted[:5])) return results"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) == 0 pass def solve(test_cases): Processes multiple test cases and returns the number of unique paths for each. >>> solve([ ... [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0], ... ], ... [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0], ... ], ... [ ... [0, 1], ... [1, 0], ... ], ... [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ] ... ]) == [2, 1, 0, 6] pass","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid with obstacles. if not grid or grid[0][0] == 1: return 0 M, N = len(grid), len(grid[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def solve(test_cases): results = [] for grid in test_cases: results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def nextGreaterNumber(N: int) -> int: Returns the smallest number greater than N formed by rearranging its digits. If no such number exists, returns -1. >>> nextGreaterNumber(123) 132 >>> nextGreaterNumber(321) -1 >>> nextGreaterNumber(115) 151","solution":"def nextGreaterNumber(N): Returns the smallest number greater than N formed by rearranging its digits. If no such number exists, returns -1. # Convert the number to a list of digits digits = list(str(N)) # Find the first digit that can be swapped to make a larger number for i in range(len(digits) - 2, -1, -1): if digits[i] < digits[i + 1]: # Find the smallest digit on right side of digits[i] which is greater than digits[i] for j in range(len(digits) - 1, i, -1): if digits[j] > digits[i]: break # Swap digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Sort the digits after the position i digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(''.join(digits)) return -1"},{"question":"def longest_substring_k_unique(s: str, k: int) -> int: Find the length of the longest substring that consists of exactly k unique characters. >>> longest_substring_k_unique(\\"araaci\\", 2) 4 >>> longest_substring_k_unique(\\"araaci\\", 1) 2 >>> longest_substring_k_unique(\\"cbbebi\\", 3) 5 >>> longest_substring_k_unique(\\"abcde\\", 10) -1","solution":"def longest_substring_k_unique(s, k): if k == 0: return -1 start, max_length = 0, -1 char_frequency = {} for end in range(len(s)): right_char = s[end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] start += 1 if len(char_frequency) == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"def count_splits(s: str, k: int) -> int: Determine the number of ways to split the string s into exactly k non-empty substrings. >>> count_splits(\\"abc\\", 2) 2 >>> count_splits(\\"abcd\\", 3) 3 >>> count_splits(\\"a\\", 1) 1","solution":"def count_splits(s, k): Returns the number of ways to split the string s into exactly k non-empty substrings. n = len(s) # DP table where dp[i][j] will be the number of ways to split s[:i] into j parts dp = [[0] * (k + 1) for _ in range(n + 1)] # Base case: there's only 1 way to split an empty string into 0 parts dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, k + 1): for x in range(i): dp[i][j] += dp[x][j - 1] return dp[n][k]"},{"question":"def calculate_total_water_after_updates(N, T, initial_water_levels, updates): Calculate the new total amount of water needed for the entire garden after updates. N: size of the garden (N x N grid) T: number of days with updates initial_water_levels: a list of lists representing the initial water levels of the plants in the garden updates: a list of tuples, each containing the row and column coordinates of a plant and the additional water required Returns an integer representing the new total amount of water needed for the entire garden after all T updates. >>> N = 3 >>> T = 2 >>> initial_water_levels = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> updates = [ ... (0, 0, 10), ... (2, 2, 5) ... ] >>> calculate_total_water_after_updates(N, T, initial_water_levels, updates) 60 from solution import calculate_total_water_after_updates def test_sample_input_1(): N = 3 T = 2 initial_water_levels = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] updates = [ (0, 0, 10), (2, 2, 5) ] assert calculate_total_water_after_updates(N, T, initial_water_levels, updates) == 60 def test_no_updates(): N = 3 T = 0 initial_water_levels = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] updates = [] assert calculate_total_water_after_updates(N, T, initial_water_levels, updates) == 45 def test_single_update(): N = 2 T = 1 initial_water_levels = [ [1, 1], [1, 1] ] updates = [ (1, 1, 4) ] assert calculate_total_water_after_updates(N, T, initial_water_levels, updates) == 8 def test_multiple_updates_same_cell(): N = 2 T = 3 initial_water_levels = [ [2, 3], [4, 5] ] updates = [ (0, 1, 1), (0, 1, 2), (0, 1, 3) ] assert calculate_total_water_after_updates(N, T, initial_water_levels, updates) == 20 def test_large_water_levels_and_updates(): N = 2 T = 2 initial_water_levels = [ [1000, 1000], [1000, 1000] ] updates = [ (0, 0, 1000), (1, 1, 1000) ] assert calculate_total_water_after_updates(N, T, initial_water_levels, updates) == 6000","solution":"def calculate_total_water_after_updates(N, T, initial_water_levels, updates): # Apply each update to the garden grid for update in updates: r, c, W = update initial_water_levels[r][c] += W # Calculate the total water needed for the entire garden total_water = 0 for row in initial_water_levels: total_water += sum(row) return total_water"},{"question":"def caesar_cipher(message, shift, direction): Encodes the given message using a Caesar cipher. Parameters: message (str): The original message to be encoded. shift (int): The number of positions to shift each letter. direction (str): The direction of the shift, either \\"left\\" or \\"right\\". Returns: str: The encoded message. >>> caesar_cipher(\\"abc\\", 1, \\"right\\") 'bcd' >>> caesar_cipher(\\"abc\\", 3, \\"left\\") 'xyz' >>> caesar_cipher(\\"Hello, World!\\", 3, \\"right\\") 'Khoor, Zruog!' >>> caesar_cipher(\\"Khoor, Zruog!\\", 3, \\"left\\") 'Hello, World!' >>> caesar_cipher(\\"ABC\\", 1, \\"right\\") 'BCD' >>> caesar_cipher(\\"xyz\\", 4, \\"left\\") 'tuv'","solution":"def caesar_cipher(message, shift, direction): Encodes the given message using a Caesar cipher. Parameters: message (str): The original message to be encoded. shift (int): The number of positions to shift each letter. direction (str): The direction of the shift, either \\"left\\" or \\"right\\". Returns: str: The encoded message. if direction not in [\\"left\\", \\"right\\"]: raise ValueError(\\"Direction should be either 'left' or 'right'\\") # Normalize shift value to be within the range 0-25 shift %= 26 if direction == \\"left\\": shift = -shift encoded_message = [] for char in message: if 'A' <= char <= 'Z': new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) elif 'a' <= char <= 'z': new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) else: new_char = char encoded_message.append(new_char) return ''.join(encoded_message)"},{"question":"def can_form_palindrome(n: int) -> str: Returns 'Yes' if the digits of n can be rearranged to form a palindrome, otherwise 'No'. >>> can_form_palindrome(121) 'Yes' >>> can_form_palindrome(1234) 'No' >>> can_form_palindrome(4444) 'Yes' def check_palindromes(test_cases: List[int]) -> List[str]: Returns a list of results for each test case indicating if the digits of the number can be rearranged to form a palindrome. >>> check_palindromes([121, 1234, 4444]) ['Yes', 'No', 'Yes'] >>> check_palindromes([112233, 1234321, 12345]) ['Yes', 'Yes', 'No']","solution":"def can_form_palindrome(n): Returns 'Yes' if the digits of n can be rearranged to form a palindrome, otherwise 'No'. from collections import Counter count = Counter(str(n)) odd_count = sum(1 for digit in count.values() if digit % 2 != 0) return 'Yes' if odd_count <= 1 else 'No' def check_palindromes(test_cases): results = [] for n in test_cases: results.append(can_form_palindrome(n)) return results"},{"question":"def count_contiguous_substrings(S: str, P: str) -> int: Returns the number of unique contiguous substrings of S that match P exactly. >>> count_contiguous_substrings(\\"abracadabra\\", \\"abra\\") 2 >>> count_contiguous_substrings(\\"testpattern\\", \\"pat\\") 1 >>> count_contiguous_substrings(\\"aaaaaaa\\", \\"aaa\\") 5 >>> count_contiguous_substrings(\\"hellohelloyeshello\\", \\"hello\\") 3 >>> count_contiguous_substrings(\\"abcdefgh\\", \\"xyz\\") 0 >>> count_contiguous_substrings(\\"abcdabc\\", \\"a\\") 2 >>> count_contiguous_substrings(\\"abcdef\\", \\"abcdef\\") 1 >>> count_contiguous_substrings(\\"short\\", \\"toolong\\") 0 >>> count_contiguous_substrings(\\"bbbbbb\\", \\"bb\\") 5 >>> count_contiguous_substrings(\\"aaaa\\", \\"aa\\") 3 >>> count_contiguous_substrings(\\"AaAaAa\\", \\"Aa\\") 3 >>> count_contiguous_substrings(\\"AaAaAa\\", \\"aa\\") 0","solution":"def count_contiguous_substrings(S, P): Returns the number of unique contiguous substrings of S that match P exactly. count = 0 len_S = len(S) len_P = len(P) for i in range(len_S - len_P + 1): if S[i:i+len_P] == P: count += 1 return count"},{"question":"def is_prime(x): Helper function to check if a number is prime. pass def next_prime(N): Function to find the smallest prime number greater than N. >>> next_prime(10) 11 >>> next_prime(31) 37 pass from solution import next_prime def test_next_prime_after_10(): assert next_prime(10) == 11 def test_next_prime_after_31(): assert next_prime(31) == 37 def test_next_prime_after_0(): assert next_prime(0) == 2 def test_next_prime_after_1(): assert next_prime(1) == 2 def test_next_prime_after_50(): assert next_prime(50) == 53 def test_next_prime_after_100(): assert next_prime(100) == 101 def test_next_prime_after_997(): assert next_prime(997) == 1009","solution":"def is_prime(x): Helper function to check if a number is prime. if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def next_prime(N): Function to find the smallest prime number greater than N. candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def game_of_life(n: int, m: int, k: int, grid: List[List[str]]) -> int: Determine the number of live cells in the grid after k iterations of Conway's Game of Life. >>> game_of_life(3, 3, 1, [['.', '*', '.'], ['*', '.', '*'], ['.', '*', '.']]) 4 >>> game_of_life(3, 4, 2, [['.', '.', '.', '.'], ['.', '*', '*', '*'], ['.', '.', '.', '.']]) 3 def conways_game_of_life(t: int, test_cases: List[Tuple[int, int, int, List[List[str]]]]) -> List[int]: Process multiple test cases for Conway's Game of Life. >>> conways_game_of_life(2, [ ... (3, 3, 1, [['.', '*', '.'], ['*', '.', '*'], ['.', '*', '.']]), ... (3, 4, 2, [['.', '.', '.', '.'], ['.', '*', '*', '*'], ['.', '.', '.', '.']])]) [4, 3]","solution":"def game_of_life(n, m, k, grid): def count_alive_neighbors(i, j): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '*': count += 1 return count def next_state(): new_grid = [['.' for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): alive_neighbors = count_alive_neighbors(i, j) if grid[i][j] == '*' and alive_neighbors in [2, 3]: new_grid[i][j] = '*' elif grid[i][j] == '.' and alive_neighbors == 3: new_grid[i][j] = '*' return new_grid for _ in range(k): grid = next_state() return sum(row.count('*') for row in grid) def conways_game_of_life(t, test_cases): results = [] for test_case in test_cases: n, m, k, grid = test_case results.append(game_of_life(n, m, k, grid)) return results"},{"question":"def sort_students(n, students): Sorts the given list of students based on grade, last name, age, and ID. Parameters: n (int): Number of students students (list of tuples): Each tuple contains (ID, grade, age, last_name) Returns: list of tuples: Sorted list of students pass def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) students = [] for i in range(1, n + 1): ID, grade, age, last_name = data[i].split() students.append((int(ID), float(grade), int(age), last_name)) sorted_students = sort_students(n, students) for student in sorted_students: print(student[0], student[1], student[2], student[3]) if __name__ == \\"__main__\\": main()","solution":"def sort_students(n, students): Sorts the given list of students based on grade, last name, age, and ID. Parameters: n (int): Number of students students (list of tuples): Each tuple contains (ID, grade, age, last_name) Returns: list of tuples: Sorted list of students # Sort based on the specified criteria students.sort(key=lambda student: (student[1], student[3], student[2], student[0])) return students def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) students = [] for i in range(1, n + 1): ID, grade, age, last_name = data[i].split() students.append((int(ID), float(grade), int(age), last_name)) sorted_students = sort_students(n, students) for student in sorted_students: print(student[0], student[1], student[2], student[3]) if __name__ == \\"__main__\\": main()"},{"question":"def min_colors_after_moves(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum number of distinct marble colors that will remain after making an optimal sequence of moves. >>> min_colors_after_moves(2, 3, [[1, 2, 3], [4, 5, 6]]) == 6 >>> min_colors_after_moves(4, 4, [[1, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]) == 9 >>> min_colors_after_moves(3, 3, [[5, 1, 4], [2, 1, 3], [8, 6, 1]]) == 3 from typing import List def test_case_1(): assert min_colors_after_moves(2, 3, [[1, 2, 3], [4, 5, 6]]) == 6 def test_case_2(): assert min_colors_after_moves(4, 4, [ [1, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15] ]) == 9 def test_case_3(): assert min_colors_after_moves(3, 3, [ [5, 1, 4], [2, 1, 3], [8, 6, 1] ]) == 3 def test_case_4(): assert min_colors_after_moves(1, 1, [[1]]) == 1 def test_case_5(): assert min_colors_after_moves(3, 3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 def test_case_6(): assert min_colors_after_moves(2, 2, [ [1, 2], [3, 4] ]) == 4","solution":"def min_colors_after_moves(n, m, grid): Returns the minimum number of distinct marble colors that will remain. # Since all marbles have distinct colors initially, the solution is simply # the number of distinct colors in the initial grid. colors = set() for row in grid: for color in row: colors.add(color) return len(colors)"},{"question":"def unique_paths(n: int) -> int: Calculates the number of unique paths in an n x n grid. Returns 0 if the input is not a positive integer. >>> unique_paths(1) 1 >>> unique_paths(2) 2 >>> unique_paths(3) 6 >>> unique_paths(4) 20 >>> unique_paths(-1) 0 >>> unique_paths(0) 0 >>> unique_paths(\\"a\\") 0 >>> unique_paths(2.5) 0 pass","solution":"def unique_paths(n): Calculates the number of unique paths in an n x n grid. Returns 0 if the input is not a positive integer. if not isinstance(n, int) or n <= 0: return 0 # Create a 2D array to store the number of paths dp = [[1]*n for _ in range(n)] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"def manage_leaderboard(player_data: List[str], query_ids: List[int]) -> List[Union[int, str]]: Create a program that manages a leaderboard for a competitive game. Players advance through levels by achieving scores, and the leaderboard ranks players based on their highest level achieved and their score within that level. If two players are on the same level, the one with the higher score should be ranked higher. Args: player_data (List[str]): List of strings containing player ID, level, and score in the format \\"id,level,score\\". Input is terminated by the line \\"0,0,0\\". query_ids (List[int]): List of player IDs to query. Returns: List[Union[int, str]]: List of ranks for the queried player IDs or \\"Player not found\\" if the player ID does not exist. Example: >>> manage_leaderboard([\\"1,10,500\\", \\"2,10,600\\", \\"3,20,400\\", \\"4,5,700\\", \\"5,10,500\\", \\"0,0,0\\", \\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"5\\"], [1, 2, 3, 4, 5]) [3, 2, 1, 5, 3] >>> manage_leaderboard([\\"1,10,500\\", \\"0,0,0\\", \\"1\\"], [1]) [1] >>> manage_leaderboard([\\"0,0,0\\"], [1]) [\\"Player not found\\"] >>> manage_leaderboard([\\"1,10,500\\", \\"2,10,600\\", \\"3,10,400\\", \\"0,0,0\\", \\"1\\", \\"2\\", \\"3\\"], [1, 2, 3]) [2, 1, 3] >>> manage_leaderboard([\\"1,10,500\\", \\"2,10,500\\", \\"3,20,400\\", \\"0,0,0\\", \\"1\\", \\"2\\", \\"3\\"], [1, 2, 3]) [2, 2, 1]","solution":"def manage_leaderboard(player_data, query_ids): # Parse the player data players = [] queries = [] idx = 0 while idx < len(player_data): line = player_data[idx].strip() idx += 1 if line == \\"0,0,0\\": break player_id, level, score = map(int, line.split(',')) players.append((player_id, level, score)) # Parse the query IDs while idx < len(player_data): line = player_data[idx].strip() idx += 1 if line: queries.append(int(line)) # Sort players by level descending, then by score descending players.sort(key=lambda x: (-x[1], -x[2])) # Create a rank dictionary rank_dict = {} rank = 1 for idx, player in enumerate(players): if idx > 0: if player[1] == players[idx - 1][1] and player[2] == players[idx - 1][2]: rank_dict[player[0]] = rank else: rank = idx + 1 rank_dict[player[0]] = rank else: rank_dict[player[0]] = rank # Retrieve the ranks for the queried player IDs result = [] for qid in query_ids: if qid in rank_dict: result.append(rank_dict[qid]) else: result.append(\\"Player not found\\") return result"},{"question":"def isBalanced(s: str) -> bool: Determines if a given string has balanced parentheses, brackets, and braces. Args: s (str): The input string containing characters. Returns: bool: True if the string is balanced, False otherwise. >>> isBalanced(\\"(){}[]\\") True >>> isBalanced(\\"[({})]\\") True >>> isBalanced(\\"(]\\") False >>> isBalanced(\\"({[)]}\\") False","solution":"def isBalanced(s): Determines if a given string has balanced parentheses, brackets, and braces. Args: s (str): The input string containing characters. Returns: bool: True if the string is balanced, False otherwise. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False else: # In case the string contains unexpected characters return False return stack == []"},{"question":"def find_missing_book_id(n, logged_ids): This function returns the missing book ID given the total number of books (n) and the list of logged book IDs. >>> find_missing_book_id(5, [1, 2, 3, 5]) 4 >>> find_missing_book_id(4, [3, 1, 4]) 2 >>> find_missing_book_id(3, [1, 3]) 2 >>> find_missing_book_id(2, [2]) 1 >>> find_missing_book_id(1, []) 1 def process_test_cases(test_cases): This function processes multiple test cases and returns a list of missing book IDs. >>> process_test_cases([(5, [1, 2, 3, 5]), (4, [3, 1, 4])]) [4, 2] >>> process_test_cases([(3, [1, 3]), (2, [2]), (1, [])]) [2, 1, 1]","solution":"def find_missing_book_id(n, logged_ids): This function returns the missing book ID given the total number of books (n) and the list of logged book IDs. total_sum = n * (n + 1) // 2 # Sum of first n natural numbers logged_sum = sum(logged_ids) return total_sum - logged_sum def process_test_cases(test_cases): This function processes multiple test cases and returns a list of missing book IDs. results = [] for case in test_cases: n, logged_ids = case missing_id = find_missing_book_id(n, logged_ids) results.append(missing_id) return results"},{"question":"def count_ways(segments): Determine the number of possible ways to complete the journey given the conditions of each segment. >>> count_ways([0, 0, 1, -1]) 7 >>> count_ways([0, 1, 1]) 4 >>> count_ways([0, 0, 0, 0]) 7 def total_ways(T, cases): For each test case, output the total number of possible ways to complete the journey. >>> total_ways(2, [(4, [0, 0, 1, -1]), (3, [0, 1, 1])]) [7, 4] >>> total_ways(1, [(3, [-1, -1, -1])]) [4] >>> total_ways(3, [(1, [1]), (2, [0, 0]), (5, [0, 1, -1, 0, 1])]) [1, 2, 13]","solution":"def count_ways(segments): N = len(segments) dp = [0] * (N + 1) dp[0] = 1 for i in range(1, N + 1): for step in range(1, 4): if i - step >= 0: dp[i] += dp[i - step] return dp[N] def total_ways(T, cases): results = [] for i in range(T): N = cases[i][0] segments = cases[i][1] results.append(count_ways(segments)) return results"},{"question":"def find_highest_scoring_player(test_cases): Given a list of test cases, each containing a list of player IDs and their scores, determine the player with the highest cumulative score. In case of a tie, the player with the lowest ID should be chosen. :param test_cases: List of test case data (list of tuples), where each tuple contains: - an integer N indicating the number of entries - a list of tuples, each containing two integers (P, S), representing the player ID and the score in that game. :return: List of player IDs with the highest cumulative score for each test case. >>> find_highest_scoring_player([(5, [(1, 10), (2, -5), (1, 5), (3, 20), (2, 10)]), (3, [(4, 15), (4, -5), (4, 5)])]) [3, 4] >>> find_highest_scoring_player([(4, [(10, 100), (20, -50), (20, 150), (10, -100)])]) [20] >>> find_highest_scoring_player([(6, [(1, 10), (2, 10), (3, 10), (4, 10), (1, 10), (3, -10)])]) [1]","solution":"def find_highest_scoring_player(test_cases): Given a list of test cases, each containing a list of player IDs and their scores, determine the player with the highest cumulative score. In case of a tie, the player with the lowest ID should be chosen. :param test_cases: List of test case data (list of tuples), where each tuple contains: - an integer N indicating the number of entries - a list of tuples, each containing two integers (P, S), representing the player ID and the score in that game. :return: List of player IDs with the highest cumulative score for each test case. results = [] for N, entries in test_cases: player_scores = {} for P, S in entries: if P in player_scores: player_scores[P] += S else: player_scores[P] = S max_score = None best_player = None for player, score in player_scores.items(): if max_score is None or score > max_score or (score == max_score and player < best_player): max_score = score best_player = player results.append(best_player) return results"},{"question":"from typing import List def sort_words_with_modification(n: int, words: List[str]) -> List[str]: Given a list of words, sorts the words in alphabetical order. You can replace any single character in any word with another alphabetic character (a-z) exactly once before performing the sorting. The function identifies the least alphabetic order of the list that can be achieved by modifying a single character in a single word and then sorting the list. >>> sort_words_with_modification(5, [\\"cat\\", \\"dog\\", \\"banana\\", \\"apple\\", \\"zebra\\"]) ['apple', 'banana', 'cat', 'dog', 'zebra'] >>> sort_words_with_modification(3, [\\"car\\", \\"bike\\", \\"apple\\"]) ['apple', 'bike', 'car'] >>> sort_words_with_modification(1, [\\"single\\"]) ['single'] >>> sort_words_with_modification(4, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) ['abc', 'def', 'ghi', 'jkl'] >>> sort_words_with_modification(100, [\\"word\\"] * 100) [\\"word\\"] * 100","solution":"def sort_words_with_modification(n, words): Identifies the least alphabetic order of the list that can be achieved by modifying a single character in a single word and then sorting the list. def modified_sorted_list(words): Sorts the words in alphabetical order considering the single character modification. words_copy = words[:] overall_min_word = min(words_copy) # start with the lexicographically smaller word # Check and create the minimum lexicographical word # by changing each character to 'a' (minimum possible character) for index, word in enumerate(words_copy): for i in range(len(word)): modified_word = word[:i] + 'a' + word[i+1:] words_copy[index] = modified_word current_min_word = min(words_copy) # If this modification gives a better minimum word, store it if current_min_word < overall_min_word: overall_min_word = current_min_word words_copy[index] = word # revert back to original for next loop return overall_min_word # Find the word that can provide the smallest overall change smallest_word = modified_sorted_list(words) # Use the smallest word to create the final modified list if smallest_word in words: words[words.index(smallest_word)] = smallest_word words.sort() return words # Example usage: # n = 5 # words = [\\"cat\\", \\"dog\\", \\"banana\\", \\"apple\\", \\"zebra\\"] # sorted_list = sort_words_with_modification(n, words) # print(sorted_list) # Output: [\\"apple\\", \\"banana\\", \\"cat\\", \\"dog\\", \\"zebra\\"]"},{"question":"def isStrictlyIncreasing(sequence: List[int]) -> bool: Check if the given sequence is strictly increasing. Parameters: sequence (list): A list of integers Returns: bool: True if the sequence is strictly increasing, False otherwise >>> isStrictlyIncreasing([1, 3, 5, 7, 9]) True >>> isStrictlyIncreasing([2, 2, 3, 4, 5]) False >>> isStrictlyIncreasing([5, 4, 3, 2, 1]) False >>> isStrictlyIncreasing([1]) True >>> isStrictlyIncreasing([]) True >>> isStrictlyIncreasing([1000000000, 1000000001, 1000000002]) True >>> isStrictlyIncreasing([-3, -2, -1, 0, 1]) True >>> isStrictlyIncreasing([-1, -2, -3, -4, -5]) False >>> isStrictlyIncreasing([-10, 0, 10, 20, 30]) True","solution":"def isStrictlyIncreasing(sequence): Check if the given sequence is strictly increasing. Parameters: sequence (list): A list of integers Returns: bool: True if the sequence is strictly increasing, False otherwise for i in range(1, len(sequence)): if sequence[i] <= sequence[i - 1]: return False return True"},{"question":"def path_exists(grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid. The grid can have 3 types of cells: - 'L' for land - 'W' for water - 'R' for rock A path can only traverse through 'L' cells. Parameters: grid (List[List[str]]): The grid represented as a list of lists of strings. Returns: str: \\"Yes\\" if there is a path, otherwise \\"No\\". >>> path_exists([ ... ['L', 'R', 'L'], ... ['L', 'W', 'R'], ... ['L', 'L', 'L'] ... ]) \\"Yes\\" >>> path_exists([ ... ['L', 'R', 'L'], ... ['R', 'R', 'R'], ... ['L', 'L', 'L'] ... ]) \\"No\\" def check_grids(datasets): Checks multiple datasets for the existence of paths from (0,0) to (n-1,m-1) on grids. Parameters: datasets (List[Tuple[Tuple[int, int], List[List[str]]]]): A list of tuples where the first element in each tuple is a pair (n, m) representing the dimensions of the grid, and the second element is the grid itself. Returns: List[str]: A list of \\"Yes\\" or \\"No\\" answers for each dataset. >>> check_grids([((3, 3), [ ... ['L', 'R', 'L'], ... ['L', 'W', 'R'], ... ['L', 'L', 'L']]), ... ((3, 3), [ ... ['L', 'R', 'L'], ... ['R', 'R', 'R'], ... ['L', 'L', 'L']]) ... ]) [\\"Yes\\", \\"No\\"]","solution":"def path_exists(grid): n = len(grid) m = len(grid[0]) def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'L' def dfs(x, y, visited): if x == n-1 and y == m-1: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if (nx, ny) not in visited and is_valid(nx, ny): if dfs(nx, ny, visited): return True return False if grid[0][0] != 'L' or grid[n-1][m-1] != 'L': return \\"No\\" visited = set() return \\"Yes\\" if dfs(0, 0, visited) else \\"No\\" def check_grids(datasets): results = [] for data in datasets: n, m = data[0] grid = data[1] results.append(path_exists(grid)) return results"},{"question":"def can_complete_tasks(tasks): Determines if all tasks can be completed within their respective deadlines. Args: tasks (list of tuples): List of tuples where each tuple contains two integers (duration, deadline). Returns: str: \\"Yes\\" if all tasks can be completed within their deadlines, otherwise \\"No\\". >>> can_complete_tasks([(3, 5), (2, 8), (1, 10)]) == \\"Yes\\" >>> can_complete_tasks([(2, 2), (1, 3), (4, 6)]) == \\"No\\" >>> can_complete_tasks([(5, 5)]) == \\"Yes\\" >>> can_complete_tasks([(10, 5)]) == \\"No\\" >>> can_complete_tasks([(10, 5), (3, 5)]) == \\"No\\" >>> can_complete_tasks([(1, 1), (1, 2), (1, 3), (1, 4)]) == \\"Yes\\" >>> can_complete_tasks([(1, 2), (2, 5), (3, 9), (1, 11)]) == \\"Yes\\"","solution":"def can_complete_tasks(tasks): Determines if all tasks can be completed within their respective deadlines. Args: tasks (list of tuples): List of tuples where each tuple contains two integers (duration, deadline). Returns: str: \\"Yes\\" if all tasks can be completed within their deadlines, otherwise \\"No\\". current_time = 0 for duration, deadline in tasks: current_time += duration if current_time > deadline: return \\"No\\" return \\"Yes\\""},{"question":"def smallest_bounding_volume(n, points): Returns the smallest volume of a cuboid that can enclose all given coral points. >>> n = 3 >>> points = [(1, 2, 3), (4, 5, 6), (7, 8, 9)] >>> abs(smallest_bounding_volume(n, points) - 216.0) < 1e-6 True >>> n = 2 >>> points = [(-100, -100, -100), (100, 100, 100)] >>> abs(smallest_bounding_volume(n, points) - 8000000.0) < 1e-6 True >>> n = 1 >>> points = [(0, 0, 0)] >>> abs(smallest_bounding_volume(n, points) - 0.0) < 1e-6 True >>> n = 4 >>> points = [(-1000, -1000, -1000), (-1000, 1000, 1000), (1000, -1000, 1000), (1000, 1000, -1000)] >>> abs(smallest_bounding_volume(n, points) - 8000000000.0) < 1e-6 True >>> n = 3 >>> points = [(-1000, -1000, -1000), (0, 0, 0), (1000, 1000, 1000)] >>> abs(smallest_bounding_volume(n, points) - 8000000000.0) < 1e-6 True","solution":"def smallest_bounding_volume(n, points): Returns the smallest volume of a cuboid that can enclose all given coral points. # Initializing min and max coordinates min_x = min_y = min_z = float('inf') max_x = max_y = max_z = float('-inf') for x, y, z in points: # Update minimum coordinates if x < min_x: min_x = x if y < min_y: min_y = y if z < min_z: min_z = z # Update maximum coordinates if x > max_x: max_x = x if y > max_y: max_y = y if z > max_z: max_z = z # Compute the dimensions of the bounding cuboid length = max_x - min_x width = max_y - min_y height = max_z - min_z # Compute and return the volume of the cuboid volume = length * width * height return volume if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) points = [(int(data[i]), int(data[i+1]), int(data[i+2])) for i in range(1, len(data), 3)] volume = smallest_bounding_volume(n, points) print(f\\"{volume:.6f}\\")"},{"question":"def max_valid_depth(s: str) -> int: Returns the maximum depth of valid nested parentheses in the string s. If the string contains invalid closing parentheses or invalid characters, return -1. >>> max_valid_depth(\\"(1+(2*3)+((8)/4))+1\\") 3 >>> max_valid_depth(\\"(1)+((2))+(((3)))\\") 3 >>> max_valid_depth(\\"(1+[(2)]/3)\\") -1 >>> max_valid_depth(\\"1+(2*3)/(2-1)\\") 1 >>> max_valid_depth(\\"1)\\") -1 >>> max_valid_depth(\\"123456\\") 0 >>> max_valid_depth(\\"((()))\\") 3 >>> max_valid_depth(\\"\\") 0 >>> max_valid_depth(\\"abc(def)\\") -1","solution":"def max_valid_depth(s): Returns the maximum depth of valid nested parentheses in the string s. If the string contains invalid closing parentheses or invalid characters, return -1. valid_chars = set(\\"0123456789+-*/()\\") for char in s: if char not in valid_chars: return -1 max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 if current_depth < 0: return -1 if current_depth != 0: return -1 return max_depth"},{"question":"def sanitizeMessage(message: str, spamWords: list) -> str: Replaces spam words in the message with asterisks. Args: message (str): The user's message. spamWords (list): A list of spam words to be masked. Returns: str: The sanitized message with spam words replaced by asterisks. Examples: >>> sanitizeMessage(\\"This product is amazing and you can buy it now at a discount!\\", [\\"product\\", \\"buy\\", \\"discount\\"]) 'This ******* is amazing and you can *** it now at a ********!' >>> sanitizeMessage(\\"Buy now! This offer is limited.\\", [\\"Buy\\", \\"offer\\"]) '*** now! This ***** is limited.'","solution":"import re def sanitizeMessage(message, spamWords): Replaces spam words in the message with asterisks. Args: message (str): The user's message. spamWords (list): A list of spam words to be masked. Returns: str: The sanitized message with spam words replaced by asterisks. for spamWord in spamWords: # Regular expression to match the whole word message = re.sub(rf'b{spamWord}b', '*' * len(spamWord), message) return message"},{"question":"def unique_participant_counts(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine the number of days where exactly 'k' unique participant counts were observed. >>> unique_participant_counts(2, [((5, 3), [100, 200, 200, 300, 400]), ((6, 4), [100, 200, 200, 300, 300, 400])]) ['NO', 'YES'] >>> unique_participant_counts(1, [((5, 5), [1, 2, 3, 4, 5])]) ['YES'] >>> unique_participant_counts(1, [((5, 0), [1, 1, 1, 1, 1])]) ['NO'] >>> unique_participant_counts(1, [((1, 1), [1])]) ['YES'] >>> unique_participant_counts(1, [((100, 100), list(range(1, 101)))]) ['YES']","solution":"def unique_participant_counts(T, test_cases): results = [] for test_case in test_cases: N, K = test_case[0] P = test_case[1] unique_counts = len(set(P)) if unique_counts == K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_single_cluster_of_trees(forest_map): Determines if the given forest map has a single cluster of trees. Parameters: forest_map (list of str): the forest grid. Returns: bool: True if there is exactly one cluster of trees, else False. pass def process_input(input_str): Processes the input string and produces the results for each test case. Parameters: input_str (str): the input string containing multiple test cases. Returns: list of str: a list of results (\\"Yes\\" or \\"No\\") for each test case. pass def test_single_cluster(): forest_map = [ \\".T.\\", \\"TTT\\", \\".T.\\" ] assert is_single_cluster_of_trees(forest_map) == True def test_multiple_clusters(): forest_map = [ \\"T..T\\", \\"..T.\\", \\"T.. \\", \\".TTT\\" ] assert is_single_cluster_of_trees(forest_map) == False def test_no_trees(): forest_map = [ \\"...\\", \\"...\\", \\"...\\" ] assert is_single_cluster_of_trees(forest_map) == False def test_complete_cluster(): forest_map = [ \\"TTT\\", \\"TTT\\", \\"TTT\\" ] assert is_single_cluster_of_trees(forest_map) == True def test_process_input_single_case(): input_str = \\"3n.T.nTTTn.T.n0\\" expected_output = [\\"Yes\\"] assert process_input(input_str) == expected_output def test_process_input_multiple_cases(): input_str = \\"3n.T.nTTTn.T.n4nT..Tn..T.nT.. n.TTTn0\\" expected_output = [\\"Yes\\", \\"No\\"] assert process_input(input_str) == expected_output def test_empty_forest(): forest_map = [ \\"...\\", \\"...\\", \\"...\\" ] assert is_single_cluster_of_trees(forest_map) == False","solution":"def is_single_cluster_of_trees(forest_map): Determines if the given forest map has a single cluster of trees. Parameters: forest_map (list of str): the forest grid. Returns: bool: True if there is exactly one cluster of trees, else False. N = len(forest_map) visited = [[False for _ in range(N)] for _ in range(N)] def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= N or forest_map[x][y] == '.' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) cluster_found = False for i in range(N): for j in range(N): if forest_map[i][j] == 'T' and not visited[i][j]: if cluster_found: return False dfs(i, j) cluster_found = True for i in range(N): for j in range(N): if forest_map[i][j] == 'T' and not visited[i][j]: return False return cluster_found def process_input(input_str): lines = input_str.strip().split('n') result = [] index = 0 while index < len(lines): N = int(lines[index]) if N == 0: break forest_map = lines[index + 1 : index + 1 + N] result.append(\\"Yes\\" if is_single_cluster_of_trees(forest_map) else \\"No\\") index += N + 1 return result"},{"question":"from typing import List def sieve_of_eratosthenes(limit: int) -> List[int]: Generate a list of prime numbers up to a given limit. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] pass def get_prime_factors_count(num: int, primes: List[int]) -> int: Calculate the number of distinct prime factors for a given number. >>> primes = sieve_of_eratosthenes(100) >>> get_prime_factors_count(10, primes) 2 >>> get_prime_factors_count(15, primes) 2 >>> get_prime_factors_count(17, primes) 1 >>> get_prime_factors_count(30, primes) 3 pass def max_distinct_prime_factors(arr: List[int]) -> int: Find the maximum number of distinct prime factors in the array. >>> max_distinct_prime_factors([10, 15, 21, 17, 30]) 3 >>> max_distinct_prime_factors([1, 2, 3, 4, 5]) 1 >>> max_distinct_prime_factors([6, 10, 15, 35, 77]) 2 pass","solution":"from collections import defaultdict def sieve_of_eratosthenes(limit): primes = [True] * (limit + 1) p = 2 while p * p <= limit: if primes[p] == True: for i in range(p * p, limit + 1, p): primes[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if primes[p]] return prime_numbers def get_prime_factors_count(num, primes): prime_factors = set() for prime in primes: if prime * prime > num: break while num % prime == 0: prime_factors.add(prime) num //= prime if num > 1: prime_factors.add(num) return len(prime_factors) def max_distinct_prime_factors(arr): # Find all primes up to the maximum element in the array using the sieve of Eratosthenes max_value = max(arr) primes = sieve_of_eratosthenes(max_value) # Calculate the number of distinct prime factors for each element in the array max_prime_factors_count = 0 for num in arr: count = get_prime_factors_count(num, primes) if count > max_prime_factors_count: max_prime_factors_count = count return max_prime_factors_count def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(max_distinct_prime_factors(arr))"},{"question":"def count_pairs_with_sum(n: int, t: int, sequence: List[int]) -> int: Returns the number of distinct pairs of elements in the sequence that add up to the target sum t. >>> count_pairs_with_sum(6, 10, [1, 2, 3, 7, 5, 8]) 2 >>> count_pairs_with_sum(5, 15, [1, 2, 3, 4, 5]) 0 >>> count_pairs_with_sum(4, 6, [1, 2, 3, 3]) 1 >>> count_pairs_with_sum(7, 10, [5, 5, 5, 5, 5, 5, 5]) 1 >>> count_pairs_with_sum(4, 1000000000, [500000000, 500000000, 1000000000, -1000000000]) 1 >>> count_pairs_with_sum(5, 0, [0, 0, 0, 0, 0]) 1 >>> count_pairs_with_sum(4, 0, [1, -1, 2, -2]) 2 >>> count_pairs_with_sum(1, 10, [10]) 0","solution":"def count_pairs_with_sum(n, t, sequence): Returns the number of distinct pairs of elements in the sequence that add up to the target sum t. seen = set() pairs = set() for num in sequence: complement = t - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs) # Example usage: # n, t = 6, 10 # sequence = [1, 2, 3, 7, 5, 8] # print(count_pairs_with_sum(n, t, sequence)) # Output should be 2"},{"question":"def find_frame(n: int, m: int, grid: List[str]) -> Union[Tuple[int, int, int, int], str]: Identify the coordinates of the top-left and bottom-right corners of the smallest possible frame enclosing all '#' tiles in a n x m grid. >>> find_frame(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) \\"No frame needed\\" >>> find_frame(3, 4, [\\"....\\", \\"..\\", \\"....\\"]) (2, 3, 2, 4) >>> find_frame(4, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\".....\\"]) (2, 3, 3, 3) # Test cases def test_no_decorations(): n = 4 m = 4 grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert find_frame(n, m, grid) == \\"No frame needed\\" def test_single_decorated_row(): n = 3 m = 4 grid = [ \\"....\\", \\"..\\", \\"....\\" ] assert find_frame(n, m, grid) == (2, 3, 2, 4) def test_single_decorated_column(): n = 4 m = 5 grid = [ \\".....\\", \\"..#..\\", \\"..#..\\", \\".....\\" ] assert find_frame(n, m, grid) == (2, 3, 3, 3) def test_scattered_decorations(): n = 5 m = 5 grid = [ \\".....\\", \\"..#..\\", \\".....\\", \\".#...\\", \\".....\\" ] assert find_frame(n, m, grid) == (2, 2, 4, 3) def test_large_grid(): n = 5 m = 7 grid = [ \\".......\\", \\"..#..\\", \\".......\\", \\"...#...\\", \\".......\\" ] assert find_frame(n, m, grid) == (2, 3, 4, 5) def test_fully_decorated_grid(): n = 3 m = 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] assert find_frame(n, m, grid) == (1, 1, 3, 3)","solution":"def find_frame(n, m, grid): top, bottom, left, right = n, 0, m, 0 decorated_tiles_found = False for i in range(n): for j in range(m): if grid[i][j] == '#': decorated_tiles_found = True if i < top: top = i if i > bottom: bottom = i if j < left: left = j if j > right: right = j if not decorated_tiles_found: return \\"No frame needed\\" r1 = top c1 = left r2 = bottom c2 = right return r1 + 1, c1 + 1, r2 + 1, c2 + 1"},{"question":"def isDivisible(k: int, N: str) -> bool: Determine if the number N (given as a string) is divisible by k (an integer). Parameters: k (int): The divisor N (str): The number as a string Returns: bool: True if N is divisible by k, False otherwise >>> isDivisible(11, \\"123456789\\") False >>> isDivisible(3, \\"123456\\") True >>> isDivisible(7, \\"49\\") True >>> isDivisible(10, \\"1001\\") False >>> isDivisible(2, \\"1024\\") True >>> isDivisible(5, \\"55555\\") True >>> isDivisible(17, \\"123456789\\") False","solution":"def isDivisible(k, N): Determine if the number N (given as a string) is divisible by k (an integer). # Convert the string to an integer number = int(N) # Check if the number is divisible by k return number % k == 0"},{"question":"def minDeletions(S: str) -> int: Returns the minimum number of operations required to delete all characters of the string S. >>> minDeletions(\\"ababa\\") 5 >>> minDeletions(\\"aaabbb\\") 2 >>> minDeletions(\\"a\\") 1 >>> minDeletions(\\"b\\") 1 >>> minDeletions(\\"\\") 0 >>> minDeletions(\\"abababab\\") 8 >>> minDeletions(\\"aaa\\") 1 >>> minDeletions(\\"bbb\\") 1 >>> minDeletions(\\"aabbaabb\\") 4 >>> minDeletions(\\"abba\\") 3","solution":"def minDeletions(S): Returns the minimum number of operations required to delete all characters of the string S. if not S: return 0 count = 1 # Start with 1 because we need at least one operation for i in range(1, len(S)): if S[i] != S[i - 1]: count += 1 return count"},{"question":"def merge_sorted_arrays(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[List[int]]: Merges T pairs of sorted arrays and returns the result for each pair. pass def format_results(results: List[List[int]]) -> List[str]: Format the merged arrays into the desired output format. pass # Example test cases if __name__ == \\"__main__\\": T = 2 test_cases = [ (3, [1, 3, 5], 4, [2, 4, 6, 8]), (2, [-1, 0], 3, [-2, -2, 2]) ] results = merge_sorted_arrays(T, test_cases) formatted_results = format_results(results) for result in formatted_results: print(result)","solution":"def merge_sorted_arrays(T, test_cases): Merges T pairs of sorted arrays and returns the result for each pair. results = [] for t in range(T): n = test_cases[t][0] A = test_cases[t][1] m = test_cases[t][2] B = test_cases[t][3] # Initialize pointers for both arrays i, j = 0, 0 merged_array = [] # Merge both arrays while i < n and j < m: if A[i] <= B[j]: merged_array.append(A[i]) i += 1 else: merged_array.append(B[j]) j += 1 # Append remaining elements if any while i < n: merged_array.append(A[i]) i += 1 while j < m: merged_array.append(B[j]) j += 1 results.append(merged_array) return results def format_results(results): Format the merged arrays into the desired output format. return [\\" \\".join(map(str, arr)) for arr in results]"},{"question":"def calculate_coding_time(log_entries, participants): Calculate the total coding time in minutes for each participant. Parameters: log_entries (list of str): List of log entries in \\"HH:MM START\\" or \\"HH:MM END\\" format. participants (int): Total number of participants. Returns: list of int: A list where the i-th element represents the total coding time (in minutes) for the i-th participant. Examples: >>> log_entries = [ ... \\"09:00 START\\", ... \\"10:00 END\\", ... \\"11:30 START\\", ... \\"12:30 END\\", ... \\"13:00 START\\", ... \\"14:00 END\\" ... ] >>> participants = 3 >>> calculate_coding_time(log_entries, participants) [60, 60, 60] >>> log_entries = [ ... \\"09:00 START\\", ... \\"10:00 END\\", ... \\"10:30 START\\", ... \\"11:00 END\\", ... \\"11:15 START\\", ... \\"11:45 END\\" ... ] >>> participants = 3 >>> calculate_coding_time(log_entries, participants) [60, 30, 30] >>> log_entries = [ ... \\"09:00 START\\", ... \\"10:00 END\\", ... \\"10:10 START\\", ... \\"10:20 END\\", ... \\"10:30 START\\", ... \\"10:40 END\\" ... ] >>> participants = 1 >>> calculate_coding_time(log_entries, participants) [80] >>> log_entries = [ ... \\"09:00 START\\", ... \\"09:15 END\\", ... \\"09:30 START\\", ... \\"09:45 END\\", ... \\"10:00 START\\", ... \\"10:30 END\\" ... ] >>> participants = 3 >>> calculate_coding_time(log_entries, participants) [15, 15, 30] >>> log_entries = [] >>> participants = 3 >>> calculate_coding_time(log_entries, participants) [0, 0, 0]","solution":"def calculate_coding_time(log_entries, participants): Calculate the total coding time in minutes for each participant. Parameters: log_entries (list of str): List of log entries in \\"HH:MM START\\" or \\"HH:MM END\\" format. participants (int): Total number of participants. Returns: list of int: A list where the i-th element represents the total coding time (in minutes) for the i-th participant. times = [0] * participants start_times = [None] * participants participant_idx = 0 for entry in log_entries: time, action = entry.split() hours, minutes = map(int, time.split(':')) current_minutes = hours * 60 + minutes if action == \\"START\\": start_times[participant_idx] = current_minutes elif action == \\"END\\": times[participant_idx] += current_minutes - start_times[participant_idx] participant_idx = (participant_idx + 1) % participants return times"},{"question":"from typing import List def escape_maze(n: int, m: int, maze: List[List[str]], traps: List[List[int]]) -> str: Determine if you can escape the maze given the maze grid and traps. >>> escape_maze(3, 3, [['.', '#', '.'], ['.', '.', '.'], ['#', '#', '.']], [[0, 0, 0], [0, 0, 0], [0, 1, 0]]) 'Escaped' >>> escape_maze(3, 3, [['.', '#', '.'], ['.', '.', '.'], ['#', '#', '.']], [[0, 0, 0], [0, 0, 0], [1, 1, 1]]) 'Trapped' >>> escape_maze(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 'Escaped' >>> escape_maze(3, 3, [['.', '#', '.'], ['.', '.', '.'], ['#', '#', '.']], [[1, 0, 0], [0, 0, 0], [0, 1, 0]]) 'Trapped' >>> escape_maze(3, 3, [['.', '#', '.'], ['.', '.', '.'], ['#', '#', '.']], [[0, 0, 0], [0, 0, 0], [0, 1, 1]]) 'Trapped' # Implementation here","solution":"def escape_maze(n, m, maze, traps): from collections import deque if maze[0][0] == '#' or maze[-1][-1] == '#' or traps[0][0] == 1 or traps[-1][-1] == 1: return \\"Trapped\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"Escaped\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == '.' and traps[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"Trapped\\" # Example usage: # n, m = 3, 3 # maze = [ # ['.', '#', '.'], # ['.', '.', '.'], # ['#', '#', '.'] # ] # traps = [ # [0, 0, 0], # [0, 0, 0], # [0, 1, 0] # ] # print(escape_maze(n, m, maze, traps)) # Output: Escaped"},{"question":"def check_difference(arr, target): Checks for the existence of two distinct indices i and j in the array such that the absolute difference between elements at these indices is equal to the target. >>> check_difference([5, 20, 3, 2, 50, 80], 78) == \\"Yes\\" >>> check_difference([90, 70, 20, 80, 50], 45) == \\"No\\" >>> check_difference([1, 2, 3, 4, 5], 1) == \\"Yes\\" >>> check_difference([10, 100], 90) == \\"Yes\\" >>> check_difference([10, 10, 10], 0) == \\"Yes\\" >>> check_difference([1, 3, 5, 7, 9], 0) == \\"No\\" >>> check_difference([0, 1, 2, 3, 4], 10) == \\"No\\" >>> check_difference([5, 20, 3, 2, 50, 80], -78) == \\"Yes\\" >>> check_difference([], 1) == \\"No\\"","solution":"def check_difference(arr, target): Checks for the existence of two distinct indices i and j in the array such that the absolute difference between elements at these indices is equal to the target. # Use a set for efficient look-up of seen elements seen = set() for num in arr: if (num + target) in seen or (num - target) in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def max_length_subsequence(N: int, T: int, thicknesses: List[int]) -> int: Determine the maximum possible length of a subsequence of consecutive records that can be placed on the shelf. >>> max_length_subsequence(6, 10, [3, 1, 2, 3, 4, 1]) 4 >>> max_length_subsequence(8, 15, [4, 2, 1, 3, 5, 2, 1, 4]) 6","solution":"def max_length_subsequence(N, T, thicknesses): max_length = 0 current_sum = 0 start = 0 for end in range(N): current_sum += thicknesses[end] while current_sum > T: current_sum -= thicknesses[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def max_boxes(n: int, weights: List[int]) -> int: Given the number of boxes and their weights, find the maximum number of boxes that can be stacked in increasing order of their weights. >>> max_boxes(5, [1, 3, 2, 4, 5]) 4 >>> max_boxes(9, [10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> max_boxes(1, [9]) 1 >>> max_boxes(0, []) 0 >>> max_boxes(5, [5, 4, 3, 2, 1]) 1 >>> max_boxes(5, [3, 3, 3, 3, 3]) 1 >>> max_boxes(8, [10, 20, 10, 30, 20, 30, 40, 50]) 5 >>> max_boxes(6, [1, 3, 2, 4, 3, 5]) 4","solution":"def max_boxes(n, weights): from bisect import bisect_left if n == 0: return 0 dp = [] for weight in weights: pos = bisect_left(dp, weight) if pos == len(dp): dp.append(weight) else: dp[pos] = weight return len(dp)"},{"question":"import heapq from typing import List, Tuple def min_rooms_required(test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determines the minimum number of rooms required to schedule all the workshops without any timing conflicts. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, where each test case is a list of tuples representing start and end times of workshops. Returns: List[int]: A list of integers indicating the minimum number of rooms required for each test case. >>> test_cases = [ >>> [(1,4), (2,5), (6,8)], >>> [(1,3), (2,4), (3,5), (4,6)] >>> ] >>> min_rooms_required(test_cases) [2, 2] def parse_input(input_string: str) -> List[List[Tuple[int, int]]]: Parses the input string and returns a list of test cases. Args: input_string (str): The input string containing the number of test cases, followed by the number of workshops and their start and end times. Returns: List[List[Tuple[int, int]]]: A list of test cases, where each test case is a list of tuples representing start and end times of workshops. >>> input_str = '2n3n1 4n2 5n6 8n4n1 3n2 4n3 5n4 6n' >>> parse_input(input_str) [ [(1, 4), (2, 5), (6, 8)], [(1, 3), (2, 4), (3, 5), (4, 6)] ] # Unit Test def test_min_rooms_required(): input_str = '2n3n1 4n2 5n6 8n4n1 3n2 4n3 5n4 6n' test_cases = parse_input(input_str) assert min_rooms_required(test_cases) == [2, 2] input_str = '1n2n1 2n2 3n' test_cases = parse_input(input_str) assert min_rooms_required(test_cases) == [1] input_str = '1n3n1 10n2 6n8 9n' test_cases = parse_input(input_str) assert min_rooms_required(test_cases) == [2] input_str = '1n1n0 10n' test_cases = parse_input(input_str) assert min_rooms_required(test_cases) == [1] input_str = '1n0n' test_cases = parse_input(input_str) assert min_rooms_required(test_cases) == [0]","solution":"import heapq def min_rooms_required(test_cases): results = [] for workshops in test_cases: if not workshops: # If no workshops, no rooms are needed results.append(0) continue # Sort workshops by start time workshops.sort(key=lambda x: x[0]) # Min-heap to track end times of workshops min_heap = [] # Add the end time of the first workshop heapq.heappush(min_heap, workshops[0][1]) for i in range(1, len(workshops)): # If the current workshop starts after the earliest ending workshop, # we can reuse the room (remove the top of the heap) if workshops[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Allocate a new room (add the end time of the current workshop) heapq.heappush(min_heap, workshops[i][1]) # The size of the heap tells us the minimum number of rooms required results.append(len(min_heap)) return results def parse_input(input_string): input_data = input_string.split() index = 0 t = int(input_data[index]) index += 1 test_cases = [] for _ in range(t): n = int(input_data[index]) index += 1 workshops = [] for _ in range(n): start = int(input_data[index]) index += 1 end = int(input_data[index]) index += 1 workshops.append((start, end)) test_cases.append(workshops) return test_cases"},{"question":"def creature_transformations(N: int, T: List[List[int]], queries: List[Tuple[int, int]]) -> List[Tuple[int, List[int]]]: Determine which creatures a given creature can transform into after exactly k transformations. N: int - Number of creature types. T: List[List[int]] - Transformation matrix. queries: List[Tuple[int, int]] - List of queries with k transformations and initial creature type x. Returns a list of tuples where each tuple contains: - The number of creature types the given creature can transform into. - A list of these creature ids in increasing order. If no creature matches, return -1. Example: >>> N = 5 >>> T = [ >>> [0, 1, 0, 0, 0], >>> [0, 0, 1, 0, 0], >>> [0, 0, 0, 1, 0], >>> [0, 0, 0, 0, 1], >>> [0, 0, 0, 0, 0] >>> ] >>> queries = [(2, 1), (1, 3), (0, 5)] >>> creature_transformations(N, T, queries) [(1, [3]), (1, [4]), (1, [5])] » from typing import List, Tuple from solution import creature_transformations def test_case_1(): N = 5 T = [ [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0] ] queries = [(2, 1), (1, 3), (0, 5)] expected_output = [(1, [3]), (1, [4]), (1, [5])] assert creature_transformations(N, T, queries) == expected_output def test_case_2(): N = 3 T = [ [0, 1, 0], [0, 0, 1], [1, 0, 0] ] queries = [(1, 1), (2, 1), (3, 1), (4, 1)] expected_output = [(1, [2]), (1, [3]), (1, [1]), (1, [2])] assert creature_transformations(N, T, queries) == expected_output def test_case_3(): N = 2 T = [ [0, 1], [1, 0] ] queries = [(1, 1), (1, 2), (2, 1)] expected_output = [(1, [2]), (1, [1]), (1, [1])] assert creature_transformations(N, T, queries) == expected_output def test_case_4(): N = 4 T = [ [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0] ] queries = [(1, 1), (1, 3), (2, 1)] expected_output = [(1, [2]), (1, [4]), (1, [1])] assert creature_transformations(N, T, queries) == expected_output def test_case_5_corner(): N = 1 T = [ [0] ] queries = [(10**6, 1)] expected_output = [(0, [-1])] assert creature_transformations(N, T, queries) == expected_output","solution":"def creature_transformations(N, T, queries): import numpy as np # Convert the transformation matrix to a numpy array for easy matrix multiplication T = np.array(T) # Precompute the powers of the transformation matrix using matrix exponentiation powers = [np.eye(N, dtype=int), T.copy()] for i in range(1, 51): next_power = np.dot(powers[-1], T) % 2 powers.append(next_power) results = [] for k, x in queries: # Find the required power of the transformation matrix current_matrix = np.eye(N, dtype=int) while k > 0: i = min(k, 50) current_matrix = np.dot(current_matrix, powers[i]) % 2 k -= i # Get the transformable creatures after k transformations x -= 1 # Convert to zero-indexed transformable_creatures = [] for i in range(N): if current_matrix[x][i] == 1: transformable_creatures.append(i + 1) if transformable_creatures: results.append((len(transformable_creatures), sorted(transformable_creatures))) else: results.append((0, [-1])) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root: TreeNode) -> List[int]: Function to find the largest value in each row of a binary tree. :param root: TreeNode :return: List[int] Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largestValues(root) [1, 3, 9] >>> root = TreeNode(7) >>> root.left = TreeNode(5) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(9) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(10) >>> root.right.right.left = TreeNode(11) >>> largestValues(root) [7, 8, 10, 11] >>> root = None >>> largestValues(root) [] >>> root = TreeNode(1) >>> largestValues(root) [1] >>> root = TreeNode(-1) >>> root.left = TreeNode(-3) >>> root.right = TreeNode(-2) >>> root.left.left = TreeNode(-5) >>> root.left.right = TreeNode(-4) >>> largestValues(root) [-1, -2, -4] >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> largestValues(root) [1, 1, 1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def largestValues(root): Function to find the largest value in each row of a binary tree. :param root: TreeNode :return: List[int] if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_val = float('-inf') for _ in range(level_size): node = queue.popleft() max_val = max(max_val, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_val) return result"},{"question":"def count_pairs(arr, target): Count the number of distinct pairs (i, j) in the array such that the sum of the two numbers equals the target. >>> count_pairs([1, 5, 7, -1, 5], 6) 3 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([3, 5, 2, -4, 8, 11], 7) 2 >>> count_pairs([1], 2) 0 >>> count_pairs([1, 2, 3, 4], 10) 0 >>> count_pairs([1, 2, 3, 2, 3], 5) 4 >>> count_pairs([-1, -2, -3, -4], -5) 2 >>> count_pairs([1, -1, 2, -2, 3, -3], 0) 3","solution":"def count_pairs(arr, target): Count the number of distinct pairs (i, j) in the array such that the sum of the two numbers equals the target. seen = {} count = 0 for num in arr: complement = target - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"def has_all_unique_chars(s: str) -> bool: Check if a given string has all unique characters. >>> has_all_unique_chars(\\"abcdef\\") # returns True >>> has_all_unique_chars(\\"apple\\") # returns False >>> has_all_unique_chars(\\"1234567890\\") # returns True >>> has_all_unique_chars(\\"112233\\") # returns False","solution":"def has_all_unique_chars(s: str) -> bool: Check if a given string has all unique characters. Parameters: - s: a string consisting of printable ASCII characters Returns: - A boolean value True if all characters in the string are unique, False otherwise if len(s) > 128: # There are only 128 unique ASCII characters, hence any string longer # than this cannot have all unique characters return False char_set = [False] * 128 # Boolean array to store a character's existence for char in s: idx = ord(char) # Getting the ASCII value of the character if char_set[idx]: # If already found in the set return False char_set[idx] = True # Marking the character as found return True"},{"question":"from typing import List def min_steps_to_reach_end(R: int, C: int, grid: List[str]) -> int: Find the minimum number of steps required to travel from the top-left corner of the grid (0,0) to the bottom-right corner, staying within the bounds of the grid. If it's not possible to reach the bottom-right corner, return -1. >>> min_steps_to_reach_end(5, 5, [\\".....\\", \\".#...\\", \\".#.#.\\", \\"...#.\\", \\".#...\\"]) == 8 >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\"#\\", \\"..#\\"]) == -1 >>> min_steps_to_reach_end(2, 2, [\\".#\\", \\"..\\"]) == 2 >>> min_steps_to_reach_end(2, 2, [\\"\\", \\"\\"]) == -1 >>> min_steps_to_reach_end(1, 1, [\\".\\"]) == 0 >>> min_steps_to_reach_end(2, 2, [\\"..\\", \\"..\\"]) == 2","solution":"from collections import deque def min_steps_to_reach_end(R, C, grid): # Directions array for moving in 4 possible directions (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # To keep track of visited cells visited = [[False] * C for _ in range(R)] # Initialize the queue with the starting position (top-left corner) queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True # Start BFS from the top-left corner while queue: r, c, steps = queue.popleft() # If we have reached the bottom-right corner, return the number of steps if r == R - 1 and c == C - 1: return steps # Explore the 4 possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, steps + 1)) # If there is no path to the bottom-right corner, return -1 return -1 # Function to take input and call the function def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = data[2:2 + R] result = min_steps_to_reach_end(R, C, grid) print(result)"},{"question":"def min_length_after_k_operations(n: int, k: int, array: List[int]) -> int: Determines the minimum possible length of the array after performing at most K operations. Each operation consists of selecting a contiguous subarray, and then replacing it with its bitwise AND result. >>> min_length_after_k_operations(5, 2, [3, 5, 1, 9, 14]) == 3 >>> min_length_after_k_operations(6, 3, [4, 6, 2, 8, 4, 7]) == 3","solution":"def min_length_after_k_operations(n, k, array): Determines the minimum possible length of the array after performing at most K operations. Each operation consists of selecting a contiguous subarray, and then replacing it with its bitwise AND result. return max(1, n - k)"},{"question":"from typing import List, Tuple def rearrange_list(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Rearrange list such that elements divisible by d are at beginning. Args: t (int): number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases. Each test case is a tuple where: - First element is a tuple (n, d), the number of elements and the divisor. - Second element is a list of integers representing the list. Returns: List[List[int]]: List of rearranged lists for each test case. Example: >>> rearrange_list(2, [((5, 3), [1, 2, 3, 4, 5]), ((6, 2), [12, 3, 10, 8, 6, 5])]) [[3, 1, 2, 4, 5], [12, 10, 8, 6, 3, 5]] >>> rearrange_list(1, [((4, 1), [1, 2, 3, 4])]) [[1, 2, 3, 4]]","solution":"def rearrange_list(t, test_cases): results = [] for i in range(t): n, d = test_cases[i][0] lst = test_cases[i][1] divisible = [x for x in lst if x % d == 0] not_divisible = [x for x in lst if x % d != 0] results.append(divisible + not_divisible) return results"},{"question":"def first_odd_occurrence(lst: list) -> int: Write a function that takes a list of integers and returns the first integer in the list that appears an odd number of times. If no such integer is found, return None. >>> first_odd_occurrence([4, 5, 4, 5, 5, 4, 4]) 5 >>> first_odd_occurrence([1, 2, 3, 4, 5, 6, 7]) 1 >>> first_odd_occurrence([2, 2, 4, 4]) None >>> first_odd_occurrence([1]) 1 >>> first_odd_occurrence([-1, -1, 2, 2, -3, -3, -3]) -3 >>> first_odd_occurrence([4, 5, 6, 5, 6, 6, 5, 5]) 4 >>> first_odd_occurrence([]) None","solution":"def first_odd_occurrence(lst: list) -> int: from collections import Counter # Count occurrences of each number count = Counter(lst) # Iterate over list to find the first element with odd occurrences for num in lst: if count[num] % 2 == 1: return num # If no odd occurrence found, return None return None"},{"question":"def printDiamond(n: int) -> str: Prints a diamond shape of height and width 2*n-1 with n as input. Args: n : int The number of rows in the top half of the diamond. Returns: str The diamond shape in string format. def test_diamond_3(): expected_output = \\" * n *** n*****n *** n * \\" assert printDiamond(3) == expected_output def test_diamond_4(): expected_output = \\" * n *** n ***** n*******n ***** n *** n * \\" assert printDiamond(4) == expected_output def test_diamond_1(): expected_output = \\"*\\" assert printDiamond(1) == expected_output def test_diamond_2(): expected_output = \\" * n***n * \\" assert printDiamond(2) == expected_output def test_diamond_5(): expected_output = \\" * n *** n ***** n ******* n*********n ******* n ***** n *** n * \\" assert printDiamond(5) == expected_output","solution":"def printDiamond(n): Prints a diamond shape of height and width 2*n-1 with n as input. Args: n : int The number of rows in the top half of the diamond. Returns: str The diamond shape in string format. diamond = [] # Generate the upper part of the diamond for i in range(n): space = ' ' * (n - i - 1) stars = '*' * (2 * i + 1) diamond.append(space + stars + space) # Generate the lower part of the diamond for i in range(n - 2, -1, -1): space = ' ' * (n - i - 1) stars = '*' * (2 * i + 1) diamond.append(space + stars + space) return 'n'.join(diamond)"},{"question":"from typing import List, Dict def analyze_date_range(dates: List[str], range_start: str, range_end: str) -> Dict[str, str]: Analyzes the given dates and returns a dictionary containing the earliest date, the latest date, and the count of dates that fall within the given range (inclusive). Parameters: dates (list of str): A list of date strings in the format \\"YYYY-MM-DD\\". range_start (str): The start date of the range in the format \\"YYYY-MM-DD\\". range_end (str): The end date of the range in the format \\"YYYY-MM-DD\\". Returns: dict: A dictionary with keys \\"earliest_date\\", \\"latest_date\\", and \\"within_range_count\\". Examples: >>> analyze_date_range([\\"2023-01-01\\", \\"2023-01-05\\", \\"2023-01-10\\", \\"2023-01-15\\"], \\"2023-01-05\\", \\"2023-01-10\\") {'earliest_date': '2023-01-01', 'latest_date': '2023-01-15', 'within_range_count': 2} >>> analyze_date_range([\\"2023-01-01\\", \\"2023-01-05\\", \\"2023-01-10\\", \\"2023-01-15\\"], \\"2023-01-01\\", \\"2023-01-15\\") {'earliest_date': '2023-01-01', 'latest_date': '2023-01-15', 'within_range_count': 4}","solution":"from datetime import datetime def analyze_date_range(dates, range_start, range_end): Analyzes the given dates and returns a dictionary containing the earliest date, the latest date, and the count of dates that fall within the given range (inclusive). Parameters: dates (list of str): A list of date strings in the format \\"YYYY-MM-DD\\". range_start (str): The start date of the range in the format \\"YYYY-MM-DD\\". range_end (str): The end date of the range in the format \\"YYYY-MM-DD\\". Returns: dict: A dictionary with keys \\"earliest_date\\", \\"latest_date\\", and \\"within_range_count\\". date_format = \\"%Y-%m-%d\\" date_objects = [datetime.strptime(date, date_format) for date in dates] range_start_date = datetime.strptime(range_start, date_format) range_end_date = datetime.strptime(range_end, date_format) earliest_date = min(date_objects).strftime(date_format) latest_date = max(date_objects).strftime(date_format) within_range_count = sum(range_start_date <= date <= range_end_date for date in date_objects) return { \\"earliest_date\\": earliest_date, \\"latest_date\\": latest_date, \\"within_range_count\\": within_range_count }"},{"question":"def count_subarrays_with_sum_k(n, arr, k): Returns the number of subarrays of arr with a sum equal to k. Parameters: n (int): Number of elements in the array. arr (list of int): The array of elements. k (int): The target sum of the subarrays. Returns: int: The number of subarrays that sum up to k. Examples: >>> count_subarrays_with_sum_k(5, [1, 2, 3, 4, 5], 9) 2 >>> count_subarrays_with_sum_k(3, [1, 1, 1], 2) 2 >>> count_subarrays_with_sum_k(6, [1, 2, 1, 3, 2, 1], 3) 4 # Example test cases to validate the implementation def test_count_subarrays_with_sum_k_example1(): assert count_subarrays_with_sum_k(5, [1, 2, 3, 4, 5], 9) == 2 def test_count_subarrays_with_sum_k_example2(): assert count_subarrays_with_sum_k(3, [1, 1, 1], 2) == 2 def test_count_subarrays_with_sum_k_example3(): assert count_subarrays_with_sum_k(6, [1, 2, 1, 3, 2, 1], 3) == 4 def test_count_subarrays_with_sum_k_single_element_equals_k(): assert count_subarrays_with_sum_k(1, [10], 10) == 1 def test_count_subarrays_with_sum_k_single_element_not_equals_k(): assert count_subarrays_with_sum_k(1, [10], 5) == 0 def test_count_subarrays_with_sum_k_all_elements_identical(): assert count_subarrays_with_sum_k(5, [5, 5, 5, 5, 5], 10) == 4 def test_count_subarrays_with_sum_k_no_subarrays_equals_k(): assert count_subarrays_with_sum_k(4, [1, 2, 3, 4], 15) == 0","solution":"def count_subarrays_with_sum_k(n, arr, k): Returns the number of subarrays of arr with a sum equal to k. Parameters: n (int): Number of elements in the array. arr (list of int): The array of elements. k (int): The target sum of the subarrays. Returns: int: The number of subarrays that sum up to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num difference = current_sum - k if difference in prefix_sums: count += prefix_sums[difference] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def count_unique_paths(N: int, M: int, maze: List[List[int]]) -> int: Determine the number of unique paths from the start position (1, 1) to the end position (N, M) in a maze. The maze is represented by a 2D list where 0 indicates an open cell and 1 indicates a blocked cell. >>> count_unique_paths(3, 4, [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) 2 >>> count_unique_paths(2, 2, [ ... [0, 1], ... [1, 0] ... ]) 0 from solution import count_unique_paths def test_no_blockages(): maze = [ [0, 0], [0, 0] ] assert count_unique_paths(2, 2, maze) == 2 def test_full_blockage(): maze = [ [0, 1], [1, 0] ] assert count_unique_paths(2, 2, maze) == 0 def test_single_blockage(): maze = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert count_unique_paths(3, 3, maze) == 2 def test_with_given_example(): maze = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert count_unique_paths(3, 4, maze) == 2 def test_start_or_end_blocked(): maze_start_blocked = [ [1, 0], [0, 0] ] assert count_unique_paths(2, 2, maze_start_blocked) == 0 maze_end_blocked = [ [0, 0], [0, 1] ] assert count_unique_paths(2, 2, maze_end_blocked) == 0","solution":"def count_unique_paths(N, M, maze): def dfs(x, y): if x == N - 1 and y == M - 1: return 1 if x >= N or y >= M or maze[x][y] == 1: return 0 if memo[x][y] != -1: return memo[x][y] memo[x][y] = dfs(x + 1, y) + dfs(x, y + 1) return memo[x][y] if maze[0][0] == 1 or maze[N-1][M-1] == 1: return 0 memo = [[-1] * M for _ in range(N)] return dfs(0, 0) # Example usage N = 3 M = 4 maze = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] print(count_unique_paths(N, M, maze)) # Output: 2"},{"question":"from typing import List, Tuple def max_finished_projects(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Given the number of compute hours and the list of projects with hours required, return the maximum number of completely finished projects for each test case. Each test case starts with two integers N and C, where N is the number of employees and C is the total number of compute hours available. Each employee can work on some of their projects partially. Args: T: An integer representing the number of test cases. test_cases: A list of tuples each containing: - an integer N representing the number of employees. - an integer C representing the total number of compute hours. - a list of lists, where each sublist contains the number of hours required for each project of an employee. Returns: A list of integers where each integer is the maximum number of completed projects for the respective test case. Example: >>> max_finished_projects(2, [(3, 10, [[4, 6], [1, 2, 3], [7]]), (2, 15, [[6, 9], [5, 10]])]) [4, 2] >>> max_finished_projects(1, [(1, 5, [[5]])]) [1]","solution":"def max_finished_projects(T, test_cases): results = [] for test_case in test_cases: N, C, employees_projects = test_case all_projects = [] for projects in employees_projects: all_projects.extend(projects) all_projects.sort() completed_projects = 0 for hours in all_projects: if C >= hours: C -= hours completed_projects += 1 else: break results.append(completed_projects) return results"},{"question":"def number_of_unique_routes(N: int, coordinates: List[int]) -> int: A drone delivery company wants to optimize their flight routes. Each route is defined by starting and ending coordinates in a 2D plane, and the company has a list of such routes they need to analyze. Two routes are considered redundant if their paths overlap completely or partially. Your task is to find the number of unique, non-overlapping routes the company has after removing the redundant ones. >>> number_of_unique_routes(5, [0, 0, 2, 2, 3, 3, 5, 5, 0, 0, 2, 2, 6, 6, 8, 8, 1, 1, 4, 4]) 3 >>> number_of_unique_routes(3, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6]) 3 >>> number_of_unique_routes(3, [1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2]) 1 >>> number_of_unique_routes(4, [1, 1, 3, 3, 2, 2, 4, 4, 3, 3, 5, 5, 6, 6, 7, 7]) 2 >>> number_of_unique_routes(2, [1, 2, 3, 4, 5, 6, 7, 8]) 2","solution":"def find_unique_routes(routes): def on_segment(p, q, r): Check if point q lies on line segment pr if q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]): return True return False def orientation(p, q, r): Find the orientation of the ordered triple (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 return 1 if val > 0 else 2 def do_intersect(p1, q1, p2, q2): Check if line segment 'p1q1' and 'p2q2' intersect. o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False unique_routes = [] for route in routes: (x1, y1, x2, y2) = route p1, q1 = (x1, y1), (x2, y2) is_unique = True for u_route in unique_routes: (ux1, uy1, ux2, uy2) = u_route up1, uq1 = (ux1, uy1), (ux2, uy2) if do_intersect(p1, q1, up1, uq1): is_unique = False break if is_unique: unique_routes.append(route) return len(unique_routes) # Parsing input def number_of_unique_routes(N, coordinates): routes = [(coordinates[i], coordinates[i+1], coordinates[i+2], coordinates[i+3]) for i in range(0, 4*N, 4)] return find_unique_routes(routes)"},{"question":"class WorkspaceSchedule: def __init__(self): self.bookings = {1: [], 2: [], 3: []} def book(self, room_number, start_time, end_time): Books a room for a given time period. >>> ws = WorkspaceSchedule() >>> ws.book(1, 10, 11) 'Booking successful' >>> ws.book(1, 10, 12) 'Booking failed' pass def cancel(self, room_number, start_time, end_time): Cancels a booking for a room for a given time period. >>> ws = WorkspaceSchedule() >>> ws.book(2, 12, 14) 'Booking successful' >>> ws.cancel(2, 12, 14) 'Cancellation successful' pass def check(self, room_number, time): Checks if a room is available at a given time. >>> ws = WorkspaceSchedule() >>> ws.book(1, 10, 11) 'Booking successful' >>> ws.check(1, 10) 'Not available' pass def show(self, room_number): Displays all bookings for a given room in chronological order. >>> ws = WorkspaceSchedule() >>> ws.book(1, 10, 12) 'Booking successful' >>> ws.book(1, 13, 14) 'Booking successful' >>> ws.show(1) '10-12n13-14' pass def process_operations(operations): Processes a list of operations related to workspace scheduling. >>> ops = [\\"book 1 10 11\\", \\"cancel 1 10 11\\", \\"check 1 10\\", \\"show 1\\"] >>> process_operations(ops) ['Booking successful', 'Cancellation successful', 'Available', 'No bookings'] >>> ops = [\\"book 1 10 11\\", \\"book 1 10 12\\"] >>> process_operations(ops) ['Booking successful', 'Booking failed'] pass","solution":"class WorkspaceSchedule: def __init__(self): self.bookings = {1: [], 2: [], 3: []} def book(self, room_number, start_time, end_time): if not self.is_available(room_number, start_time, end_time): return \\"Booking failed\\" self.bookings[room_number].append((start_time, end_time)) self.bookings[room_number].sort() return \\"Booking successful\\" def cancel(self, room_number, start_time, end_time): if (start_time, end_time) not in self.bookings[room_number]: return \\"Cancellation failed\\" self.bookings[room_number].remove((start_time, end_time)) return \\"Cancellation successful\\" def check(self, room_number, time): for start_time, end_time in self.bookings[room_number]: if start_time <= time <= end_time: return \\"Not available\\" return \\"Available\\" def show(self, room_number): if not self.bookings[room_number]: return \\"No bookings\\" return 'n'.join([f\\"{start_time}-{end_time}\\" for start_time, end_time in self.bookings[room_number]]) def is_available(self, room_number, start_time, end_time): for existing_start, existing_end in self.bookings[room_number]: if max(start_time, existing_start) <= min(end_time, existing_end): return False return True def process_operations(operations): schedule = WorkspaceSchedule() results = [] for operation in operations: parts = operation.split() command = parts[0] room_number = int(parts[1]) if command == \\"book\\": start_time = int(parts[2]) end_time = int(parts[3]) results.append(schedule.book(room_number, start_time, end_time)) elif command == \\"cancel\\": start_time = int(parts[2]) end_time = int(parts[3]) results.append(schedule.cancel(room_number, start_time, end_time)) elif command == \\"check\\": time = int(parts[2]) results.append(schedule.check(room_number, time)) elif command == \\"show\\": results.append(schedule.show(room_number)) return results"},{"question":"def find_pair(arr, K): Determines if there exists a pair of indices (i, j) such that arr[i] + arr[j] = K and i < j. Args: arr (list of int): List of integers K (int): Target sum Returns: bool: True if such a pair exists, False otherwise Examples: >>> find_pair([1, 2, 3, 4, 5], 8) True >>> find_pair([1, 2, 3, 4, 5], 10) False >>> find_pair([-1, -2, -3, -4, -5], -8) True >>> find_pair([1000000000, 2000000000, 3000000000, -2000000000], 1000000000) True >>> find_pair([1], 2) False >>> find_pair([0, 0, 0, 0, 0], 0) True >>> find_pair([1, 1, 1, 1, 1], 2) True >>> find_pair([i for i in range(1, 100001)], 199999) True >>> find_pair([10, 20, 30, 40, 50], 100) False","solution":"def find_pair(arr, K): Determines if there exists a pair of indices (i, j) such that arr[i] + arr[j] = K and i < j. Args: arr (list of int): List of integers K (int): Target sum Returns: bool: True if such a pair exists, False otherwise seen = set() for num in arr: if K - num in seen: return True seen.add(num) return False"},{"question":"def min_cost(grid): Given a 2D grid with costs, compute the minimum travel cost from the top-left to the bottom-right cell. You can move only right or down. def read_input(input_string): Read input, process grids and compute the minimum cost for each grid data set. input_data = input_string.strip().split(\\"n\\") results = [] index = 0 while index < len(input_data): line = input_data[index].strip() M, N = map(int, line.split()) if M == 0 and N == 0: break grid = [] for _ in range(M): index += 1 row = list(map(int, input_data[index].strip().split())) grid.append(row) results.append(min_cost(grid)) index += 1 # move to the next M,N line return results # Example usage: # >>> input_data = \\"3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1n0 0n\\" # >>> read_input(input_data) # [7, 3] # Unit tests: from solution import min_cost, read_input def test_min_cost(): grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost(grid1) == 7 grid2 = [ [1, 2], [1, 1] ] assert min_cost(grid2) == 3 def test_read_input(): input_data = \\"3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1n0 0n\\" expected_output = [7, 3] assert read_input(input_data) == expected_output def test_edge_cases(): grid = [ [1] ] assert min_cost(grid) == 1 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost(grid) == 21","solution":"def min_cost(grid): Given a 2D grid with costs, compute the minimum travel cost from the top-left to the bottom-right cell. You can move only right or down. M = len(grid) N = len(grid[0]) # Create a cost matrix to store the minimum cost path cost = [[0 for _ in range(N)] for _ in range(M)] cost[0][0] = grid[0][0] # Initialize first row of cost matrix for i in range(1, N): cost[0][i] = cost[0][i - 1] + grid[0][i] # Initialize first column of cost matrix for j in range(1, M): cost[j][0] = cost[j - 1][0] + grid[j][0] # Construct the rest of the cost matrix for i in range(1, M): for j in range(1, N): cost[i][j] = min(cost[i - 1][j], cost[i][j - 1]) + grid[i][j] return cost[M - 1][N - 1] def read_input(input_string): input_data = input_string.strip().split(\\"n\\") results = [] index = 0 while index < len(input_data): line = input_data[index].strip() M, N = map(int, line.split()) if M == 0 and N == 0: break grid = [] for _ in range(M): index += 1 row = list(map(int, input_data[index].strip().split())) grid.append(row) results.append(min_cost(grid)) index += 1 # move to the next M,N line return results"},{"question":"def max_trees_in_increasing_order(N, heights): Returns the maximum number of trees Takahashi can collect in an increasing order of their heights. >>> max_trees_in_increasing_order(5, [1, 3, 2, 5, 4]) 3 >>> max_trees_in_increasing_order(4, [4, 3, 2, 1]) 1 >>> max_trees_in_increasing_order(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> max_trees_in_increasing_order(1, [5]) 1 >>> max_trees_in_increasing_order(5, [3, 3, 3, 3, 3]) 1 >>> max_trees_in_increasing_order(7, [3, 1, 4, 1, 5, 9, 2]) 4 >>> max_trees_in_increasing_order(6, [1, 2, 1, 2, 1, 2]) 2","solution":"def max_trees_in_increasing_order(N, heights): Returns the maximum number of trees Takahashi can collect in an increasing order of their heights. if N == 0: return 0 dp = [1] * N # Initialize DP table for maximum lengths for i in range(1, N): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def minSubArrayLen(S: int, nums: List[int]) -> int: Given a list of non-negative integers, find the smallest contiguous subarray of which the sum is at least the given number S. If there is no such subarray, return 0. Args: S : int : Target sum for the subarray nums : List[int] : List of non-negative integers Returns: int : The length of the smallest subarray with sum at least S, or 0 if no such subarray exists. Examples: >>> minSubArrayLen(7, [2,3,1,2,4,3]) 2 >>> minSubArrayLen(4, [1,4,4]) 1 >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1]) 0 import pytest def test_example1(): assert minSubArrayLen(7, [2,3,1,2,4,3]) == 2 def test_example2(): assert minSubArrayLen(4, [1,4,4]) == 1 def test_example3(): assert minSubArrayLen(11, [1,1,1,1,1,1,1,1]) == 0 def test_exact_match(): assert minSubArrayLen(6, [1,1,1,1,2,4]) == 2 def test_no_solution(): assert minSubArrayLen(100, [1,2,3,4,5]) == 0 def test_single_element(): assert minSubArrayLen(3, [3]) == 1 assert minSubArrayLen(5, [3]) == 0 def test_large_array(): nums = [1, 2, 3, 4, 5] * 20000 assert minSubArrayLen(15, nums) == 5","solution":"def minSubArrayLen(S, nums): Returns the length of the smallest contiguous subarray of which the sum is at least S. If there is no such subarray, returns 0. n = len(nums) left = 0 total = 0 min_len = float('inf') for right in range(n): total += nums[right] while total >= S: min_len = min(min_len, right - left + 1) total -= nums[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"from typing import List def number_of_paths(m: int, n: int, x_s: int, y_s: int, x_t: int, y_t: int) -> int: Calculate the number of distinct paths from (x_s, y_s) to (x_t, y_t) in a grid of dimensions m x n, using only right and down moves. >>> number_of_paths(3, 3, 1, 1, 3, 3) 6 >>> number_of_paths(1, 5, 1, 1, 1, 5) 1 >>> number_of_paths(5, 1, 1, 1, 5, 1) 1 >>> number_of_paths(5, 5, 3, 3, 3, 3) 1 >>> number_of_paths(3, 3, 1, 1, 3, 1) 1 >>> number_of_paths(3, 3, 1, 1, 1, 3) 1 >>> number_of_paths(10, 10, 0, 0, 5, 5) 0 >>> number_of_paths(10, 10, 1, 1, 11, 10) 0 >>> number_of_paths(10, 10, 1, 1, 10, 15) 0 pass","solution":"def number_of_paths(m, n, x_s, y_s, x_t, y_t): Calculate the number of distinct paths from (x_s, y_s) to (x_t, y_t) in a grid of dimensions m x n, using only right and down moves. # If the starting or target positions are out of grid bounds, no paths if not (1 <= x_s <= m and 1 <= y_s <= n and 1 <= x_t <= m and 1 <= y_t <= n): return 0 # Translate coordinates from 1-indexed to 0-indexed x_s -= 1 y_s -= 1 x_t -= 1 y_t -= 1 # If the starting point is the target point, there's only one path if (x_s, y_s) == (x_t, y_t): return 1 # Initialize a grid for dynamic programming dp = [[0] * n for _ in range(m)] dp[x_s][y_s] = 1 # Starting point # Fill the dp table for i in range(x_s, x_t + 1): for j in range(y_s, y_t + 1): if i > x_s: dp[i][j] += dp[i - 1][j] if j > y_s: dp[i][j] += dp[i][j - 1] return dp[x_t][y_t]"},{"question":"def max_fruits_in_bowls(n: int, m: int, capacities: List[int], weights: List[int]) -> int: Determine the maximum number of fruits that can be placed into the bowls such that no bowl holds more than one fruit. Parameters: n (int): Number of bowls m (int): Number of fruits capacities (list): List of integers representing the capacities of the bowls weights (list): List of integers representing the weights of the fruits Returns: int: Maximum number of fruits that can be placed into the bowls Example: >>> max_fruits_in_bowls(4, 5, [3, 5, 7, 9], [2, 4, 6, 8, 10]) 4 >>> max_fruits_in_bowls(3, 4, [4, 4, 4], [5, 5, 5, 5]) 0","solution":"def max_fruits_in_bowls(n, m, capacities, weights): Returns the maximum number of fruits that can be placed into the bowls Parameters: n (int): Number of bowls m (int): Number of fruits capacities (list): List of integers representing the capacities of the bowls weights (list): List of integers representing the weights of the fruits Returns: int: Maximum number of fruits that can be placed into the bowls capacities.sort() weights.sort() bowl_pointer = 0 fruit_pointer = 0 fruit_count = 0 while bowl_pointer < n and fruit_pointer < m: if weights[fruit_pointer] <= capacities[bowl_pointer]: fruit_count += 1 fruit_pointer += 1 bowl_pointer += 1 return fruit_count"},{"question":"def is_valid_email(email: str) -> bool: Check if the given email is valid based on the defined criteria. >>> is_valid_email(\\"user.name@domain.com\\") True >>> is_valid_email(\\".username@domain.com\\") False >>> is_valid_email(\\"username@domain..com\\") False >>> is_valid_email(\\"user_name@domain.com\\") True >>> is_valid_email(\\"user123@domain.com\\") True >>> is_valid_email(\\"username@domain123.com\\") True","solution":"import re def is_valid_email(email): Check if the given email is valid based on the defined criteria. pattern = re.compile( r'^[a-zA-Z0-9._]+@[a-zA-Z0-9]+.[a-zA-Z0-9.]*[a-zA-Z0-9]+' ) if not pattern.match(email): return False local_part, domain_part = email.split('@') # Check if local part starts or ends with a dot if local_part.startswith('.') or local_part.endswith('.'): return False # Check if domain part starts, ends with a dot or has consecutive dots if domain_part.startswith('.') or domain_part.endswith('.') or '..' in domain_part: return False return True"},{"question":"def findMaxMin(arr, n): Given an array Arr of size N, find the maximum and minimum elements present in the array. Parameters: arr (list): The list of integers. n (int): The number of elements in the list. Returns: tuple: The maximum and minimum elements in the list. Examples: >>> findMaxMin([3, 1, 4, 1, 5, 9], 6) (9, 1) >>> findMaxMin([7, 2, 8, 6], 4) (8, 2)","solution":"def findMaxMin(arr, n): Returns the maximum and minimum elements in the array. Parameters: arr (list): The list of integers. n (int): The number of elements in the list. Returns: tuple: The maximum and minimum elements in the list. max_element = arr[0] min_element = arr[0] for num in arr[1:]: if num > max_element: max_element = num if num < min_element: min_element = num return (max_element, min_element)"},{"question":"def count_pairs_with_difference_k(arr: List[int], k: int) -> int: Returns the number of pairs (i, j) such that |arr[i] - arr[j]| = k and i != j. >>> count_pairs_with_difference_k([1, 5, 3, 4, 2], 2) == 3 >>> count_pairs_with_difference_k([1, 2, 3, 4, 5], 10) == 0 >>> count_pairs_with_difference_k([1, 2, 3, 4, 1, 1, 4], 3) == 6 >>> count_pairs_with_difference_k([1], 1) == 0 >>> count_pairs_with_difference_k([1, 1, 1, 1, 1], 100000) == 0 >>> count_pairs_with_difference_k(list(range(1, 100001)), 1) == 99999","solution":"def count_pairs_with_difference_k(arr, k): Returns the number of pairs (i, j) such that |arr[i] - arr[j]| = k and i != j. pair_count = 0 value_count = {} for num in arr: if num + k in value_count: pair_count += value_count[num + k] if num - k in value_count: pair_count += value_count[num - k] if num in value_count: value_count[num] += 1 else: value_count[num] = 1 return pair_count"},{"question":"from typing import List def can_form_palindrome(S: str) -> str: Determines if it's possible to make the binary string S a palindrome by performing at most one reverse operation. >>> can_form_palindrome(\\"1100\\") == \\"YES\\" >>> can_form_palindrome(\\"1001\\") == \\"YES\\" >>> can_form_palindrome(\\"111000\\") == \\"NO\\" pass def solve_palindrome_problem(T: int, test_cases: List[str]) -> List[str]: For each binary string in test_cases, determine if it's possible to make it a palindrome by performing at most one reverse operation. >>> solve_palindrome_problem(3, [\\"1100\\", \\"1001\\", \\"111000\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve_palindrome_problem(2, [\\"110\\", \\"10101\\"]) == [\\"YES\\", \\"YES\\"] pass","solution":"def can_form_palindrome(S): Determines if it's possible to make the binary string S a palindrome by performing at most one reverse operation. n = len(S) # Check if S is already a palindrome if S == S[::-1]: return \\"YES\\" # Check if we can make S a palindrome by performing at most one reverse operation diff_count = 0 left, right = 0, n - 1 while left < right: if S[left] != S[right]: diff_count += 1 if diff_count > 2: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" if diff_count <= 2 else \\"NO\\" def solve_palindrome_problem(T, test_cases): results = [] for i in range(T): results.append(can_form_palindrome(test_cases[i])) return results"},{"question":"class BillingSystem: A billing system that keeps track of customers and their usage of services. Methods: - add_service(service_name, rate_per_unit): Adds a new service with the given name and rate per unit. - register_customer(customer_name): Registers a new customer with the given name. - record_usage(customer_name, service_name, units_used): Records the usage of a specified number of units of a service by a customer. - calculate_bill(customer_name): Calculates and returns the total bill for the specified customer. def __init__(self): Initialize the Billing System with no services and customers. def add_service(self, service_name, rate_per_unit): Add a new service with the given name and rate per unit. Args: - service_name (str): The name of the service. - rate_per_unit (float): The rate per unit of the service. def register_customer(self, customer_name): Register a new customer with the given name. Args: - customer_name (str): The name of the customer. def record_usage(self, customer_name, service_name, units_used): Record the usage of a specified number of units of a service by a customer. Args: - customer_name (str): The name of the customer. - service_name (str): The name of the service. - units_used (int): The number of units used. def calculate_bill(self, customer_name): Calculate and return the total bill for the specified customer. Args: - customer_name (str): The name of the customer. Returns: - float: The total bill for the customer. import pytest def test_add_service(): system = BillingSystem() system.add_service(\\"Internet\\", 10.0) assert system.services[\\"Internet\\"] == 10.0 def test_register_customer(): system = BillingSystem() system.register_customer(\\"Alice\\") assert \\"Alice\\" in system.customers def test_record_usage(): system = BillingSystem() system.add_service(\\"Internet\\", 10.0) system.register_customer(\\"Alice\\") system.record_usage(\\"Alice\\", \\"Internet\\", 5) assert system.customers[\\"Alice\\"][\\"Internet\\"] == 5 def test_calculate_bill(): system = BillingSystem() system.add_service(\\"Internet\\", 10.0) system.add_service(\\"Electricity\\", 0.2) system.register_customer(\\"Alice\\") system.record_usage(\\"Alice\\", \\"Internet\\", 5) system.record_usage(\\"Alice\\", \\"Electricity\\", 100) assert system.calculate_bill(\\"Alice\\") == 70.0 # 5*10.0 + 100*0.2 def test_multiple_customers(): system = BillingSystem() system.add_service(\\"Internet\\", 10.0) system.add_service(\\"Electricity\\", 0.2) system.register_customer(\\"Alice\\") system.register_customer(\\"Bob\\") system.record_usage(\\"Alice\\", \\"Internet\\", 5) system.record_usage(\\"Alice\\", \\"Electricity\\", 100) system.record_usage(\\"Bob\\", \\"Internet\\", 10) system.record_usage(\\"Bob\\", \\"Electricity\\", 50) assert system.calculate_bill(\\"Alice\\") == 70.0 assert system.calculate_bill(\\"Bob\\") == 110.0 # 10*10.0 + 50*0.2 def test_service_not_found(): system = BillingSystem() system.register_customer(\\"Alice\\") with pytest.raises(ValueError): system.record_usage(\\"Alice\\", \\"NonExistentService\\", 5) def test_customer_not_found(): system = BillingSystem() system.add_service(\\"Internet\\", 10.0) with pytest.raises(ValueError): system.record_usage(\\"NonExistentCustomer\\", \\"Internet\\", 5) def test_calculate_bill_for_nonexistent_customer(): system = BillingSystem() with pytest.raises(ValueError): system.calculate_bill(\\"NonExistentCustomer\\")","solution":"class BillingSystem: def __init__(self): self.services = {} self.customers = {} def add_service(self, service_name, rate_per_unit): self.services[service_name] = rate_per_unit def register_customer(self, customer_name): self.customers[customer_name] = {} def record_usage(self, customer_name, service_name, units_used): if service_name not in self.services: raise ValueError(\\"Service not found\\") if customer_name not in self.customers: raise ValueError(\\"Customer not found\\") if service_name not in self.customers[customer_name]: self.customers[customer_name][service_name] = 0 self.customers[customer_name][service_name] += units_used def calculate_bill(self, customer_name): if customer_name not in self.customers: raise ValueError(\\"Customer not found\\") total_bill = 0.0 for service_name, units_used in self.customers[customer_name].items(): total_bill += self.services[service_name] * units_used return round(total_bill, 2)"},{"question":"def has_duplicates(test_cases): Determines whether there are any duplicates in the list for each test case. >>> parse_input(\\"3n5n1 2 3 4 5n4n1 1 2 3n6n10 20 30 20 50 60\\") [[1, 2, 3, 4, 5], [1, 1, 2, 3], [10, 20, 30, 20, 50, 60]] >>> has_duplicates([[1, 2, 3, 4, 5], [1, 1, 2, 3], [10, 20, 30, 20, 50, 60]]) [\\"NO\\", \\"YES\\", \\"YES\\"] pass def parse_input(input_data): Helper function to parse the input. >>> parse_input(\\"1n4n1 1 1 1\\") [[1, 1, 1, 1]] pass","solution":"def has_duplicates(test_cases): Determines whether there are any duplicates in the list for each test case. Parameters: test_cases (list of tuple): Each tuple contains a list of integers. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for case in test_cases: elements_set = set(case) if len(elements_set) != len(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Helper function to parse the input def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) elements = list(map(int, lines[index + 1].split())) test_cases.append(elements) index += 2 return test_cases"},{"question":"def find_minimum_cost_to_connect_towns(T: int, data: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Given the number of towns and magical paths, and the cost of each path, find the minimum total magical cost to connect all towns. If it is not possible to connect all towns, return -1. Args: T (int): The number of test cases. data (list): A list of tuples, each containing the number of towns (N), the number of magical paths (M), and a list of tuples where each tuple contains two integers u, v, and w representing a magical path between towns u and v with cost w. Returns: list: A list of integers, each representing the minimum total magical cost to connect all towns for each test case, or -1 if it is not possible. Example: >>> find_minimum_cost_to_connect_towns(2, [(4, 5, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 7), (3, 4, 1)]), (3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 8)])]) [6, 13] >>> find_minimum_cost_to_connect_towns(1, [(4, 2, [(1, 2, 4), (3, 4, 1)])]) [-1] # Sample Unit Test def test_find_minimum_cost_to_connect_towns(): # Test case 1 from the problem statement T = 2 data = [ (4, 5, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 7), (3, 4, 1)]), (3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 8)]) ] expected = [6, 13] result = find_minimum_cost_to_connect_towns(T, data) assert result == expected, f'Expected {expected}, but got {result}' # Test case where not all towns are connected T = 1 data = [ (4, 2, [(1, 2, 4), (3, 4, 1)]) ] expected = [-1] result = find_minimum_cost_to_connect_towns(T, data) assert result == expected, f'Expected {expected}, but got {result}' # Test case with only two towns and one path T = 1 data = [ (2, 1, [(1, 2, 5)]) ] expected = [5] result = find_minimum_cost_to_connect_towns(T, data) assert result == expected, f'Expected {expected}, but got {result}' # Test case with more complex topology T = 1 data = [ (5, 7, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 3), (4, 5, 4), (3, 5, 2)]) ] expected = [8] result = find_minimum_cost_to_connect_towns(T, data) assert result == expected, f'Expected {expected}, but got {result}' # Large case with 1000 towns and full connections T = 1 edges = [(i, i + 1, i % 10 + 1) for i in range(1, 1000)] data = [ (1000, 999, edges) ] expected = [sum(i % 10 + 1 for i in range(1, 1000))] result = find_minimum_cost_to_connect_towns(T, data) assert result == expected, f'Expected {expected}, but got {result}' test_find_minimum_cost_to_connect_towns()","solution":"def find_minimum_cost_to_connect_towns(T, data): from heapq import heappop, heappush import sys def prim(graph, N): # If there are no nodes, no cost is needed. if N == 0: return 0 total_cost = 0 visited = [False] * (N + 1) min_heap = [(0, 1)] # Start with node 1 and 0 cost num_visited = 0 while min_heap and num_visited < N: cost, u = heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += cost num_visited += 1 for v, w in graph[u]: if not visited[v]: heappush(min_heap, (w, v)) return total_cost if num_visited == N else -1 results = [] for case in data: N, M, paths = case graph = [[] for _ in range(N + 1)] for u, v, w in paths: graph[u].append((v, w)) graph[v].append((u, w)) total_cost = prim(graph, N) results.append(total_cost) return results"},{"question":"def is_valid_matched(c: str) -> bool: Determines if the input string of parentheses is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Parameters: c (str): A string consisting of parentheses '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is valid, False otherwise. Examples: >>> is_valid_matched(\\"()\\") True >>> is_valid_matched(\\"()[]{}\\") True >>> is_valid_matched(\\"(]\\") False >>> is_valid_matched(\\"([)]\\") False >>> is_valid_matched(\\"{[]}\\") True pass from solution import is_valid_matched def test_valid_simple_pairs(): assert is_valid_matched(\\"()\\") == True assert is_valid_matched(\\"[]\\") == True assert is_valid_matched(\\"{}\\") == True def test_valid_combined_pairs(): assert is_valid_matched(\\"()[]{}\\") == True assert is_valid_matched(\\"{[()]}\\") == True assert is_valid_matched(\\"{[]}(){}\\") == True def test_invalid_combined_unordered_pairs(): assert is_valid_matched(\\"(]\\") == False assert is_valid_matched(\\"([)]\\") == False assert is_valid_matched(\\"{[}]\\") == False def test_empty_string(): assert is_valid_matched(\\"\\") == True def test_single_open_brackets(): assert is_valid_matched(\\"(\\") == False assert is_valid_matched(\\"[\\") == False assert is_valid_matched(\\"{\\") == False def test_single_close_brackets(): assert is_valid_matched(\\")\\") == False assert is_valid_matched(\\"]\\") == False assert is_valid_matched(\\"}\\") == False def test_only_open_brackets(): assert is_valid_matched(\\"(((\\") == False assert is_valid_matched(\\"[{{[\\") == False def test_only_close_brackets(): assert is_valid_matched(\\")))\\") == False assert is_valid_matched(\\"}}]}}\\") == False def test_mismatched_brackets(): assert is_valid_matched(\\"[(])\\") == False assert is_valid_matched(\\"[(})\\") == False assert is_valid_matched(\\"[{(})]\\") == False","solution":"def is_valid_matched(c): Determines if the input string of parentheses is valid. Parameters: c (str): A string consisting of parentheses '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is valid, False otherwise. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in c: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def traffic_signal_duration(T: int, test_cases: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int]]: Compute total duration of green, yellow, and red lights over given number of cycles. Args: T : int : the number of test cases test_cases : List[Tuple[int, int, int, int]] : a list of tuples where each tuple contains: - N : int : the number of signal cycles - G : int : the duration in seconds of the green light for one cycle - Y : int : the duration in seconds of the yellow light for one cycle - R : int : the duration in seconds of the red light for one cycle Returns: List[Tuple[int, int, int]] : a list of tuples where each tuple contains: - total_green : int : the total duration in seconds spent in green light - total_yellow : int : the total duration in seconds spent in yellow light - total_red : int : the total duration in seconds spent in red light Example: >>> T = 2 >>> test_cases = [(3, 30, 5, 25), (5, 45, 10, 20)] >>> traffic_signal_duration(T, test_cases) [(90, 15, 75), (225, 50, 100)] def format_output(results: List[Tuple[int, int, int]]) -> str: Format the output list of tuples to a string with each tuple on a separate line. Args: results : List[Tuple[int, int, int]] : list of tuples to format Returns: str : formatted string Example: >>> results = [(90, 15, 75), (225, 50, 100)] >>> format_output(results) '90 15 75n225 50 100'","solution":"def traffic_signal_duration(T, test_cases): results = [] for case in test_cases: N, G, Y, R = case total_green = N * G total_yellow = N * Y total_red = N * R results.append((total_green, total_yellow, total_red)) return results def format_output(results): return 'n'.join(' '.join(map(str, result)) for result in results)"},{"question":"class Library: def __init__(self): self.books = [] def add_book(self, book_id, title, author, genre): Adds a new book with the given BookID, Title, Author, and Genre. pass def list_by_author(self): Lists all books sorted alphabetically by the Author's name. Returns: List[Tuple[int, str, str, str]]: Sorted list of books by author name. pass def list_by_genre(self, genre): Lists all books in the specified genre sorted alphabetically by the Author's name. Args: genre (str): The genre to filter books by. Returns: List[Tuple[int, str, str, str]]: Sorted list of books by the specified genre. pass def execute_commands(commands): Executes a list of commands to add, list, and manage books in the library system. Args: commands (List[str]): List of commands to be executed. Returns: List[str]: Output of the executed commands. pass # Test cases def test_library_add_and_list_by_author(): commands = [ \\"ADD 1 The_Hobbit J.R.R._Tolkien Fantasy\\", \\"ADD 2 1984 George_Orwell Dystopian\\", \\"ADD 3 Brave_New_World Aldous_Huxley Dystopian\\", \\"ADD 4 The_Lord_of_the_Rings J.R.R._Tolkien Fantasy\\", \\"LIST BY AUTHOR\\", \\"EXIT\\" ] expected_output = [ \\"3 Brave_New_World Aldous_Huxley Dystopian\\", \\"2 1984 George_Orwell Dystopian\\", \\"1 The_Hobbit J.R.R._Tolkien Fantasy\\", \\"4 The_Lord_of_the_Rings J.R.R._Tolkien Fantasy\\" ] assert execute_commands(commands) == expected_output def test_library_list_by_genre(): commands = [ \\"ADD 1 The_Hobbit J.R.R._Tolkien Fantasy\\", \\"ADD 2 1984 George_Orwell Dystopian\\", \\"ADD 3 Brave_New_World Aldous_Huxley Dystopian\\", \\"ADD 4 The_Lord_of_the_Rings J.R.R._Tolkien Fantasy\\", \\"LIST BY GENRE Dystopian\\", \\"EXIT\\" ] expected_output = [ \\"3 Brave_New_World Aldous_Huxley Dystopian\\", \\"2 1984 George_Orwell Dystopian\\" ] assert execute_commands(commands) == expected_output def test_library_no_output_on_add_and_exit(): commands = [ \\"ADD 1 The_Hobbit J.R.R._Tolkien Fantasy\\", \\"EXIT\\" ] expected_output = [] assert execute_commands(commands) == expected_output","solution":"class Library: def __init__(self): self.books = [] def add_book(self, book_id, title, author, genre): self.books.append((book_id, title, author, genre)) def list_by_author(self): return sorted(self.books, key=lambda x: x[2]) def list_by_genre(self, genre): return sorted([book for book in self.books if book[3] == genre], key=lambda x: x[2]) def execute_commands(commands): library = Library() output = [] for command in commands: parts = command.split() action = parts[0] if action == \\"ADD\\": book_id = int(parts[1]) title = parts[2] author = parts[3] genre = parts[4] library.add_book(book_id, title, author, genre) elif action == \\"LIST\\" and parts[1] == \\"BY\\" and parts[2] == \\"AUTHOR\\": books = library.list_by_author() for book in books: output.append(f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\") elif action == \\"LIST\\" and parts[1] == \\"BY\\" and parts[2] == \\"GENRE\\": genre = parts[3] books = library.list_by_genre(genre) for book in books: output.append(f\\"{book[0]} {book[1]} {book[2]} {book[3]}\\") elif action == \\"EXIT\\": break return output"},{"question":"from typing import List, Tuple def can_assign_deliveries(t: int, cases: List[Tuple[int, List[int], int, List[int]]]) -> List[str]: Determines if it's possible to assign all deliveries into the trucks such that no truck is overloaded. Args: t (int): Number of test cases. cases (List[Tuple[int, List[int], int, List[int]]]): List of test cases where each test case contains: - An integer n, the number of trucks. - List of n integers representing the maximum weight capacity of each truck. - An integer m, the number of deliveries. - List of m integers representing the weight of each delivery. Returns: List[str]: For each test case, \\"Possible\\" if all deliveries can be assigned without overloading any truck, otherwise \\"Impossible\\". >>> can_assign_deliveries(2, [(3, [10, 5, 15], 5, [2, 4, 6, 8, 5]), (2, [8, 8], 3, [9, 4, 3])]) [\\"Possible\\", \\"Impossible\\"] >>> can_assign_deliveries(1, [(2, [5, 5], 3, [3, 2, 1])]) [\\"Possible\\"] >>> can_assign_deliveries(1, [(1, [10], 1, [10])]) [\\"Possible\\"] >>> can_assign_deliveries(1, [(1, [10], 1, [11])]) [\\"Impossible\\"] >>> can_assign_deliveries(1, [(3, [7, 7, 7], 3, [7, 7, 7])]) [\\"Possible\\"] >>> can_assign_deliveries(1, [(2, [10, 15], 4, [3, 6, 8, 9])]) [\\"Impossible\\"] >>> can_assign_deliveries(1, [(3, [10, 10, 10], 3, [10, 10, 10])]) [\\"Possible\\"]","solution":"from typing import List, Tuple def can_assign_deliveries(t: int, cases: List[Tuple[int, List[int], int, List[int]]]) -> List[str]: results = [] for case in cases: n, truck_capacities, m, delivery_weights = case # Sort truck capacities in descending order truck_capacities.sort(reverse=True) # Sort delivery weights in descending order delivery_weights.sort(reverse=True) possible = True for delivery_weight in delivery_weights: assigned = False for i in range(n): if truck_capacities[i] >= delivery_weight: truck_capacities[i] -= delivery_weight assigned = True break if not assigned: possible = False break if possible: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def min_robots_needed(N, W, weights): Returns the minimum number of robots needed to carry all items without exceeding each robot's weight capacity. Parameters: N (int): Number of items. W (int): Maximum weight each robot can carry. weights (list of int): List of item weights. Returns: int: Minimum number of robots needed. Examples: >>> min_robots_needed(3, 10, [4, 8, 6]) 2 >>> min_robots_needed(1, 10, [5]) 1 >>> min_robots_needed(5, 20, [5, 10, 5, 10, 5]) 3","solution":"def min_robots_needed(N, W, weights): Returns the minimum number of robots needed to carry all items without exceeding each robot's weight capacity. Parameters: N (int): Number of items. W (int): Maximum weight each robot can carry. weights (list of int): List of item weights. Returns: int: Minimum number of robots needed. weights.sort(reverse=True) robots = 0 i = 0 j = N - 1 while i <= j: if weights[i] + weights[j] <= W: j -= 1 i += 1 robots += 1 return robots # Example usage N = 3 W = 10 weights = [4, 8, 6] print(min_robots_needed(N, W, weights)) # Output: 2"},{"question":"def max_team_strength(N, K, S): Determine the maximum possible team strength that can be achieved by forming teams with exactly K participants each. Args: N (int): The number of participants. K (int): The number of participants per team. S (List[int]): The list of skill levels of the participants. Returns: int: The maximum possible team strength. Examples: >>> max_team_strength(5, 3, [5, 2, 8, 1, 6]) 19 >>> max_team_strength(4, 2, [3, 9, 2, 7]) 16 >>> max_team_strength(3, 3, [1, 2, 3]) 6 >>> max_team_strength(3, 2, [1000000000, 999999999, 2]) 1999999999 >>> max_team_strength(5, 4, [5, 5, 5, 5, 5]) 20 >>> max_team_strength(1, 1, [1]) 1 >>> max_team_strength(6, 6, [1, 2, 3, 4, 5, 6]) 21","solution":"def max_team_strength(N, K, S): Returns the maximum possible team strength that can be achieved by forming teams with exactly K participants each. Parameters: N (int): The number of participants. K (int): The number of participants per team. S (List[int]): The list of skill levels of the participants. Returns: int: The maximum possible team strength. S.sort(reverse=True) return sum(S[:K])"},{"question":"from typing import List def count_identical_rankings(N: int, preferences: List[List[int]]) -> int: Returns the number of groups of employees who have identical ranking preferences. Args: N (int): Number of employees preferences (list of list of int): A list of N lists, each containing K unique integers. Returns: int: The number of groups of employees with identical preferences. Example: >>> count_identical_rankings(5, [[1, 2, 3, 4, 5], [2, 3, 4, 5, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [2, 3, 4, 5, 1]]) 2 >>> count_identical_rankings(4, [[1, 2, 3, 4, 5], [5, 1, 2, 3, 4], [4, 5, 3, 1, 2], [3, 4, 2, 5, 1]]) 0 >>> count_identical_rankings(3, [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) 1 >>> count_identical_rankings(5, [[1, 2, 3], [3, 2, 1], [1, 2, 3], [3, 2, 1], [2, 3, 1]]) 2 >>> count_identical_rankings(0, []) 0 pass","solution":"from collections import Counter def count_identical_rankings(N, preferences): Returns the number of groups of employees who have identical ranking preferences. Args: N (int): Number of employees preferences (list of list of int): A list of N lists, each containing K unique integers. Returns: int: The number of groups of employees with identical preferences. # Count occurrences of each ranking preference preference_count = Counter(tuple(pref) for pref in preferences) # Count the number of groups with more than one employee identical_groups = sum(1 for count in preference_count.values() if count > 1) return identical_groups"},{"question":"def zigzag_sequence(n: int, arr: List[int]) -> List[int]: Rearranges the given array into a zigzag sequence. Args: - n: integer, the size of the array - arr: list of integers, the array to be rearranged Returns: - list of integers, the rearranged array in zigzag sequence >>> zigzag_sequence(7, [4, 3, 7, 8, 6, 2, 1]) [3, 7, 4, 8, 2, 6, 1] >>> zigzag_sequence(6, [1, 4, 3, 2, 6, 5]) [1, 4, 2, 6, 3, 5] from typing import List def test_example_1(): assert zigzag_sequence(7, [4, 3, 7, 8, 6, 2, 1]) == [1, 8, 2, 7, 3, 6, 4] or zigzag_sequence(7, [4, 3, 7, 8, 6, 2, 1]) == [2, 7, 3, 6, 4, 8, 1] def test_example_2(): assert zigzag_sequence(6, [1, 4, 3, 2, 6, 5]) == [1, 6, 2, 5, 3, 4] or zigzag_sequence(6, [1, 4, 3, 2, 6, 5]) == [1, 4, 2, 5, 3, 6] def test_single_element(): assert zigzag_sequence(1, [10]) == [10] def test_two_elements(): assert zigzag_sequence(2, [5, 10]) == [5, 10] def test_already_zigzag(): assert zigzag_sequence(5, [1, 3, 2, 4, 3]) == [1, 4, 2, 3, 3] or zigzag_sequence(5, [1, 3, 2, 4, 3]) == [1, 3, 2, 4, 3] def test_reverse_sorted(): assert zigzag_sequence(4, [4, 3, 2, 1]) == [1, 4, 2, 3] def test_alternating_high_low(): assert zigzag_sequence(5, [5, 1, 4, 2, 3]) == [1, 5, 2, 4, 3]","solution":"def zigzag_sequence(n, arr): Rearranges the given array into a zigzag sequence. Args: - n: integer, the size of the array - arr: list of integers, the array to be rearranged Returns: - list of integers, the rearranged array in zigzag sequence arr.sort() # Let's work with an alternating high-low approach result = [0] * n left, right = 0, n - 1 for i in range(n): if i % 2 == 0: result[i] = arr[left] left += 1 else: result[i] = arr[right] right -= 1 return result"},{"question":"def int_to_roman(num): Convert an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] # Your code here to return Roman Numeral for the given number def to_roman(n): Returns a list of strings representing the Roman numeral representation of all numbers from 1 to n (inclusive). >>> to_roman(3) [\\"I\\", \\"II\\", \\"III\\"] >>> to_roman(5) [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\"] # Your code here to build a list of Roman Numerals from 1 to n from solution import to_roman def test_to_roman(): assert to_roman(1) == [\\"I\\"] assert to_roman(3) == [\\"I\\", \\"II\\", \\"III\\"] assert to_roman(5) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\"] assert to_roman(10) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\", \\"X\\"] def test_to_roman_edge_cases(): assert to_roman(4) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\"] assert to_roman(9) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\"] assert to_roman(15) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\", \\"X\\", \\"XI\\", \\"XII\\", \\"XIII\\", \\"XIV\\", \\"XV\\"] def test_to_roman_mid_range(): assert to_roman(19) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\", \\"X\\", \\"XI\\", \\"XII\\", \\"XIII\\", \\"XIV\\", \\"XV\\", \\"XVI\\", \\"XVII\\", \\"XVIII\\", \\"XIX\\"] assert to_roman(20) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\", \\"X\\", \\"XI\\", \\"XII\\", \\"XIII\\", \\"XIV\\", \\"XV\\", \\"XVI\\", \\"XVII\\", \\"XVIII\\", \\"XIX\\", \\"XX\\"] assert to_roman(50) == [\\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\", \\"X\\", \\"XI\\", \\"XII\\", \\"XIII\\", \\"XIV\\", \\"XV\\", \\"XVI\\", \\"XVII\\", \\"XVIII\\", \\"XIX\\", \\"XX\\", \\"XXI\\", \\"XXII\\", \\"XXIII\\", \\"XXIV\\", \\"XXV\\", \\"XXVI\\", \\"XXVII\\", \\"XXVIII\\", \\"XXIX\\", \\"XXX\\", \\"XXXI\\", \\"XXXII\\", \\"XXXIII\\", \\"XXXIV\\", \\"XXXV\\", \\"XXXVI\\", \\"XXXVII\\", \\"XXXVIII\\", \\"XXXIX\\", \\"XL\\", \\"XLI\\", \\"XLII\\", \\"XLIII\\", \\"XLIV\\", \\"XLV\\", \\"XLVI\\", \\"XLVII\\", \\"XLVIII\\", \\"XLIX\\", \\"L\\"]","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num def to_roman(n): Returns a list of strings representing the Roman numeral representation of all numbers from 1 to n (inclusive). return [int_to_roman(i) for i in range(1, n + 1)]"},{"question":"def subset_sum_exists(n, S, numbers): Determines if there is a subset of the given integers that sums up to the target sum S. :param n: Number of integers :param S: Target sum :param numbers: List of integers :return: 'YES' if such a subset exists, otherwise 'NO' >>> subset_sum_exists(5, 9, [1, 2, 3, 4, 5]) 'YES' >>> subset_sum_exists(3, 10, [1, 2, 3]) 'NO' >>> subset_sum_exists(4, 3, [1, -1, 3, 2]) 'YES' >>> subset_sum_exists(4, -1, [1, -1, 3, 2]) 'YES' >>> subset_sum_exists(3, -5, [-1, -2, -3]) 'YES' >>> subset_sum_exists(6, 7, [10, -1, 2, 3, 5, -4]) 'YES' >>> subset_sum_exists(6, 50, [-10, -19, -25, -30, -5, 10]) 'NO'","solution":"def subset_sum_exists(n, S, numbers): Determines if there is a subset of the given integers that sums up to the target sum S. :param n: Number of integers :param S: Target sum :param numbers: List of integers :return: 'YES' if such a subset exists, otherwise 'NO' from itertools import combinations # Check all possible subsets for i in range(1, n + 1): for subset in combinations(numbers, i): if sum(subset) == S: return \\"YES\\" return \\"NO\\""},{"question":"def min_changes_to_palindrome(s: str, k: int) -> int: Returns the minimum number of changes required to make s a palindrome if possible within k changes. >>> min_changes_to_palindrome(\\"abca\\", 1) 1 >>> min_changes_to_palindrome(\\"race\\", 2) 2 >>> min_changes_to_palindrome(\\"abc\\", 0) -1 pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[int]: Takes in a list of test cases and returns a list of results for each test case. >>> process_test_cases([(\\"abca\\", 1), (\\"race\\", 2), (\\"abc\\", 0)]) [1, 2, -1] >>> process_test_cases([(\\"abcd\\", 2), (\\"abba\\", 1)]) [2, 0] pass # Unit Tests def test_min_changes_to_palindrome(): assert min_changes_to_palindrome(\\"abca\\", 1) == 1 assert min_changes_to_palindrome(\\"race\\", 2) == 2 assert min_changes_to_palindrome(\\"abc\\", 0) == -1 assert min_changes_to_palindrome(\\"a\\", 0) == 0 assert min_changes_to_palindrome(\\"a\\", 1) == 0 assert min_changes_to_palindrome(\\"aa\\", 0) == 0 assert min_changes_to_palindrome(\\"ab\\", 1) == 1 assert min_changes_to_palindrome(\\"abcd\\", 2) == 2 def test_process_test_cases(): test_cases = [(\\"abca\\", 1), (\\"race\\", 2), (\\"abc\\", 0)] assert process_test_cases(test_cases) == [1, 2, -1] test_cases = [(\\"abcd\\", 2), (\\"abba\\", 1)] assert process_test_cases(test_cases) == [2, 0] test_cases = [(\\"a\\", 0), (\\"a\\", 1), (\\"aa\\", 0), (\\"ab\\", 1)] assert process_test_cases(test_cases) == [0, 0, 0, 1]","solution":"def min_changes_to_palindrome(s, k): Returns the minimum number of changes required to make s a palindrome if possible within k changes. If it's not possible, returns -1. n = len(s) changes_needed = 0 # Count the number of changes needed to make the string a palindrome for i in range(n // 2): if s[i] != s[n - 1 - i]: changes_needed += 1 if changes_needed <= k: return changes_needed else: return -1 def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(min_changes_to_palindrome(s, k)) return results"},{"question":"def is_subsequence(str1: str, str2: str) -> bool: Returns True if str2 is a subsequence of str1, otherwise False. >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False >>> is_subsequence(\\"abcdef\\", \\"abdf\\") True >>> is_subsequence(\\"abcdef\\", \\"abcdeg\\") False","solution":"def is_subsequence(str1, str2): Returns True if str2 is a subsequence of str1, otherwise False. iter_str1 = iter(str1) return all(char in iter_str1 for char in str2)"},{"question":"import math from typing import List, Tuple def is_intersecting_circle(x1: int, y1: int, x2: int, y2: int, cx: int, cy: int, r: int) -> bool: Helper function to determine if a line segment intersects a circle. pass def flight_path(n: int, restricted_zones: List[Tuple[int, int, int]], x_s: int, y_s: int, x_e: int, y_e: int) -> str: Determine if a flight path intersects any restricted zones. Args: n (int): Number of restricted zones. restricted_zones (List[Tuple[int, int, int]]): List of tuples (x, y, r) representing the zones. x_s (int): x-coordinate of the start point. y_s (int): y-coordinate of the start point. x_e (int): x-coordinate of the end point. y_e (int): y-coordinate of the end point. Returns: str: \\"SAFE\\" if the path does not intersect any restricted zone, otherwise \\"RESTRICTED\\". >>> flight_path(2, [(15, 15, 5), (25, 25, 5)], 0, 0, 10, 10) 'SAFE' >>> flight_path(1, [(15, 15, 10)], 0, 0, 30, 30) 'RESTRICTED' pass # Test cases def test_no_intersection(): assert flight_path(2, [(15, 15, 5), (25, 25, 5)], 0, 0, 10, 10) == \\"SAFE\\" def test_single_restricted_zone(): assert flight_path(1, [(15, 15, 10)], 0, 0, 30, 30) == \\"RESTRICTED\\" def test_multiple_restricted_zones(): assert flight_path(3, [(10, 10, 5), (20, 20, 5), (30, 30, 5)], 0, 0, 40, 40) == \\"RESTRICTED\\" def test_edge_case_intersection(): assert flight_path(1, [(50, 50, 50)], 100, 0, 0, 100) == \\"RESTRICTED\\" def test_edge_case_no_intersection(): assert flight_path(1, [(50, 50, 5)], 0, 0, 100, 100) == \\"RESTRICTED\\" def test_path_touching_edge_of_circle(): assert flight_path(1, [(15, 15, 5)], 0, 0, 20, 20) == \\"RESTRICTED\\"","solution":"import math def is_intersecting_circle(x1, y1, x2, y2, cx, cy, r): # Translate coordinates so that the circle's center is at the origin x1, y1, x2, y2 = x1 - cx, y1 - cy, x2 - cx, y2 - cy dx = x2 - x1 dy = y2 - y1 # Coefficients of the quadratic equation a = dx ** 2 + dy ** 2 b = 2 * (x1 * dx + y1 * dy) c = x1 ** 2 + y1 ** 2 - r ** 2 discriminant = b ** 2 - 4 * a * c if discriminant < 0: return False # Find the roots of the quadratic equation t1 = (-b - math.sqrt(discriminant)) / (2 * a) t2 = (-b + math.sqrt(discriminant)) / (2 * a) # Check if the roots are within the segment if (0 <= t1 <= 1) or (0 <= t2 <= 1): return True return False def flight_path(n, restricted_zones, x_s, y_s, x_e, y_e): for (x_i, y_i, r_i) in restricted_zones: if is_intersecting_circle(x_s, y_s, x_e, y_e, x_i, y_i, r_i): return \\"RESTRICTED\\" return \\"SAFE\\""},{"question":"def top_readers_board(log_entries: List[str]) -> List[str]: Generate the Top Readers Board showing the number of books read by each member. >>> top_readers_board([\\"Alice BookA\\", \\"Bob BookB\\", \\"Alice BookC\\"]) [\\"Alice 2\\", \\"Bob 1\\"] >>> top_readers_board([\\"Alice BookA\\", \\"Bob BookB\\", \\"Alice BookC\\", \\"Bob BookD\\"]) [\\"Alice 2\\", \\"Bob 2\\"]","solution":"def top_readers_board(log_entries): from collections import defaultdict reader_books_count = defaultdict(int) for entry in log_entries: name, book = entry.split(maxsplit=1) reader_books_count[name] += 1 sorted_readers = sorted(reader_books_count.items(), key=lambda x: (-x[1], x[0])) result = [f\\"{name} {count}\\" for name, count in sorted_readers] return result"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given number using recursion. >>> factorial(5) 120 >>> factorial(0) 1","solution":"def factorial(n): Returns the factorial of a non-negative integer n using recursion. if n == 0: return 1 else: return n * factorial(n-1)"},{"question":"def min_max_distance_to_hubs(n: int, points: List[Tuple[int, int]]) -> Tuple[float, Tuple[float, float], Tuple[float, float]]: Optimize the delivery routes by placing 2 hubs in such a way that the maximum distance from any delivery point to its nearest hub is minimized. Args: n (int): Number of delivery points. points (List[Tuple[int, int]]): List of tuples representing coordinates of delivery points. Returns: Tuple[float, Tuple[float, float], Tuple[float, float]]: Minimum possible maximum distance followed by the coordinates of the two hubs. >>> min_max_distance_to_hubs(3, [(0, 0), (10, 10), (20, 20)]) (10.000000, (0.000000, 0.000000), (20.000000, 20.000000)) >>> min_max_distance_to_hubs(4, [(0, 0), (1, 1), (2, 2), (3, 3)]) (1.500000, (0.000000, 0.000000), (3.000000, 3.000000)) def test_case_1(): points = [(0, 0), (10, 10), (20, 20)] n = len(points) max_distance, hub1, hub2 = min_max_distance_to_hubs(n, points) assert hub1 == (0, 0) assert hub2 == (20, 20) def test_case_2(): points = [(0, 0), (1, 1), (2, 2), (3, 3)] n = len(points) max_distance, hub1, hub2 = min_max_distance_to_hubs(n, points) assert hub1 == (0, 0) or hub1 == (3, 3) assert hub2 == (3, 3) or hub2 == (0, 0) def test_case_3(): points = [(0, 0), (0, 1), (1, 0), (1, 1)] n = len(points) max_distance, hub1, hub2 = min_max_distance_to_hubs(n, points) assert hub1 == (0, 0) or hub1 == (0, 1) or hub1 == (1, 0) or hub1 == (1, 1) assert hub2 == (0, 0) or hub2 == (0, 1) or hub2 == (1, 0) or hub2 == (1, 1) assert hub1 != hub2 def test_case_4(): points = [(10, 10), (20, 10), (10, 20), (20, 20)] n = len(points) max_distance, hub1, hub2 = min_max_distance_to_hubs(n, points) assert hub1 == (10, 10) or hub1 == (20, 20) assert hub2 == (10, 10) or hub2 == (20, 20) assert hub1 != hub2","solution":"def min_max_distance_to_hubs(n, points): import math from heapq import heappush, heappop def calc_max_distance(hub1, hub2): hub1_distances = [math.dist(hub1, point) for point in points] hub2_distances = [math.dist(hub2, point) for point in points] min_distances = [min(d1, d2) for d1, d2 in zip(hub1_distances, hub2_distances)] return max(min_distances) def find_optimal_hubs(points): # As a simple heuristic, choose the most separated points to be hubs max_distance = -1 hub1, hub2 = None, None for i in range(n): for j in range(i + 1, n): d = math.dist(points[i], points[j]) if d > max_distance: max_distance = d hub1, hub2 = points[i], points[j] return hub1, hub2 hub1, hub2 = find_optimal_hubs(points) max_distance = calc_max_distance(hub1, hub2) return max_distance, hub1, hub2 # Sample input points = [(0, 0), (10, 10), (20, 20)] n = len(points) max_distance, hub1, hub2 = min_max_distance_to_hubs(n, points) print(f\\"{max_distance:.6f}\\") print(f\\"{hub1[0]:.6f} {hub1[1]:.6f}\\") print(f\\"{hub2[0]:.6f} {hub2[1]:.6f}\\")"},{"question":"def find_flora_clusters(N, M, coordinates, growth_paths, P, queries): Analyze and identify if two given trees belong to the same flora cluster or not. Args: - N (int): Number of trees - M (int): Number of growth paths - coordinates (List[List[int]]): List of [x, y] coordinates of each tree - growth_paths (List[List[int]]): List of [a, b] paths between trees - P (int): Number of pairs of trees to be tested - queries (List[List[int]]): List of [u, v] pairs to be tested Returns: - List[str]: List of \\"connected\\" or \\"not connected\\" for each pair Example: >>> N = 5 >>> M = 3 >>> coordinates = [ ... [1, 1], ... [2, 2], ... [3, 3], ... [4, 4], ... [5, 5] ... ] >>> growth_paths = [ ... [1, 2], ... [2, 3], ... [4, 5] ... ] >>> P = 3 >>> queries = [ ... [1, 3], ... [1, 4], ... [4, 5] ... ] >>> find_flora_clusters(N, M, coordinates, growth_paths, P, queries) ['connected', 'not connected', 'connected'] from solution import find_flora_clusters def test_find_flora_clusters_1(): N = 5 M = 3 coordinates = [ [1, 1], [2, 2], [3, 3], [4, 4], [5, 5] ] growth_paths = [ [1, 2], [2, 3], [4, 5] ] P = 3 queries = [ [1, 3], [1, 4], [4, 5] ] assert find_flora_clusters(N, M, coordinates, growth_paths, P, queries) == ['connected', 'not connected', 'connected'] def test_find_flora_clusters_2(): N = 6 M = 5 coordinates = [ [0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0] ] growth_paths = [ [1, 2], [2, 3], [3, 4], [4, 5], [5, 6] ] P = 2 queries = [ [1, 6], [2, 4] ] assert find_flora_clusters(N, M, coordinates, growth_paths, P, queries) == ['connected', 'connected'] def test_find_flora_clusters_3(): N = 4 M = 2 coordinates = [ [0, 0], [1, 1], [2, 2], [3, 3] ] growth_paths = [ [1, 2], [3, 4] ] P = 2 queries = [ [1, 3], [2, 4] ] assert find_flora_clusters(N, M, coordinates, growth_paths, P, queries) == ['not connected', 'not connected'] def test_find_flora_clusters_4(): N = 3 M = 1 coordinates = [ [0, 0], [1, 1], [2, 2] ] growth_paths = [ [1, 2] ] P = 2 queries = [ [1, 2], [1, 3] ] assert find_flora_clusters(N, M, coordinates, growth_paths, P, queries) == ['connected', 'not connected']","solution":"def find_flora_clusters(N, M, coordinates, growth_paths, P, queries): from collections import defaultdict, deque # Convert growth paths to adjacency list graph = defaultdict(list) for a, b in growth_paths: graph[a].append(b) graph[b].append(a) # Helper function to perform BFS or DFS to find connected components def bfs(node, visited, component): queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited[neighbor] = component queue.append(neighbor) # Find all connected components visited = {} component = 0 for i in range(1, N + 1): if i not in visited: component += 1 visited[i] = component bfs(i, visited, component) # Answer the queries results = [] for u, v in queries: if visited.get(u) == visited.get(v): results.append(\\"connected\\") else: results.append(\\"not connected\\") return results # Example usage: N = 5 M = 3 coordinates = [ [1, 1], [2, 2], [3, 3], [4, 4], [5, 5] ] growth_paths = [ [1, 2], [2, 3], [4, 5] ] P = 3 queries = [ [1, 3], [1, 4], [4, 5] ] print(find_flora_clusters(N, M, coordinates, growth_paths, P, queries)) # Output: ['connected', 'not connected', 'connected']"},{"question":"def min_sensors_required(T: int, test_cases: List[Tuple[int, int, List[List[int]], int]]) -> List[int]: Determine the minimum number of sensors needed to ensure that every cell in the grid is within the monitoring range of at least one sensor. If it is not possible to cover the entire grid with the sensors, return -1. >>> T = 2 >>> test_cases = [ ... ( ... 3, 3, ... [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ], ... 2 ... ), ... ( ... 4, 4, ... [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 1] ... ], ... 1 ... ) ... ] >>> min_sensors_required(T, test_cases) == [2, -1] >>> T = 1 >>> test_cases = [ ... ( ... 2, 2, ... [ ... [0, 0], ... [0, 0] ... ], ... 1 ... ) ... ] >>> min_sensors_required(T, test_cases) == [-1] >>> T = 1 >>> test_cases = [ ... ( ... 3, 3, ... [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], ... 1 ... ) ... ] >>> min_sensors_required(T, test_cases) == [9]","solution":"def min_sensors_required(T, test_cases): def is_covered(grid, M, N, D): coverage_grid = [[0] * N for _ in range(M)] for i in range(M): for j in range(N): if grid[i][j] == 1: for x in range(max(0, i - D), min(M, i + D + 1)): for y in range(max(0, j - D), min(N, j + D + 1)): if abs(x - i) + abs(y - j) <= D: coverage_grid[x][y] = 1 for row in coverage_grid: if 0 in row: return False return True results = [] for m in range(T): M, N, grid, D = test_cases[m] if is_covered(grid, M, N, D): sensor_count = sum(row.count(1) for row in grid) results.append(sensor_count) else: results.append(-1) return results"},{"question":"def art_installation(R: int, C: int, K: int, park_grid: List[str], D: int) -> str: Determine if it is possible to place K art pieces on trees in the park grid such that the Euclidean distance between any two art pieces is at least D. Args: R (int): Number of rows in the park grid. C (int): Number of columns in the park grid. K (int): Number of art pieces to be placed. park_grid (List[str]): The grid representation of the park. D (int): Minimum Euclidean distance required between any two art pieces. Returns: str: \\"YES\\" if it is possible to place K art pieces meeting the distance constraint, otherwise \\"NO\\". Example: >>> R, C, K = 5, 5, 3 >>> park_grid = [ ... \\"T.T..\\", ... \\".TT.T\\", ... \\".....\\", ... \\".T.T.\\", ... \\"TTTTT\\" ... ] >>> D = 2 >>> art_installation(R, C, K, park_grid, D) 'YES' >>> R, C, K = 5, 5, 3 >>> park_grid = [ ... \\"T....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\"T....\\" ... ] >>> D = 5 >>> art_installation(R, C, K, park_grid, D) 'NO' from itertools import combinations import math def test_art_installation_example_case(): R, C, K = 5, 5, 3 park_grid = [ \\"T.T..\\", \\".TT.T\\", \\".....\\", \\".T.T.\\", \\"TTTTT\\" ] D = 2 assert art_installation(R, C, K, park_grid, D) == \\"YES\\" def test_art_installation_no_solution(): R, C, K = 5, 5, 3 park_grid = [ \\"T....\\", \\".....\\", \\".....\\", \\".....\\", \\"T....\\" ] D = 5 assert art_installation(R, C, K, park_grid, D) == \\"NO\\" def test_art_installation_min_distance(): R, C, K = 5, 5, 3 park_grid = [ \\"T.T..\\", \\".T.T.\\", \\"T.T..\\", \\".T.T.\\", \\"T.T..\\" ] D = 1 assert art_installation(R, C, K, park_grid, D) == \\"YES\\" def test_art_installation_single_tree(): R, C, K = 5, 5, 1 park_grid = [ \\".....\\", \\".....\\", \\"..T..\\", \\".....\\", \\".....\\" ] D = 1 assert art_installation(R, C, K, park_grid, D) == \\"YES\\" def test_art_installation_max_distance(): R, C, K = 3, 3, 2 park_grid = [ \\"T..\\", \\"...\\", \\"..T\\" ] D = math.sqrt(8) assert art_installation(R, C, K, park_grid, D) == \\"YES\\"","solution":"from itertools import combinations import math def is_valid_distance(x1, y1, x2, y2, D): Check if distance between two points (x1, y1) and (x2, y2) is at least D. return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) >= D def can_place_art_pieces(grid, R, C, K, D): # Collect all positions of 'T' trees = [(i, j) for i in range(R) for j in range(C) if grid[i][j] == 'T'] # Check all combinations of K trees to see if they meet the distance requirement for combo in combinations(trees, K): valid = True for i in range(K): for j in range(i + 1, K): if not is_valid_distance(combo[i][0], combo[i][1], combo[j][0], combo[j][1], D): valid = False break if not valid: break if valid: return \\"YES\\" return \\"NO\\" # Function to process the input and call can_place_art_pieces def art_installation(R, C, K, park_grid, D): return can_place_art_pieces(park_grid, R, C, K, D)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Find the length of the longest substring that contains exactly two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 pass def test_length_of_longest_substring_two_distinct(): assert length_of_longest_substring_two_distinct(\\"eceba\\") == 3 assert length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 assert length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2 assert length_of_longest_substring_two_distinct(\\"aa\\") == 2 assert length_of_longest_substring_two_distinct(\\"a\\") == 1 assert length_of_longest_substring_two_distinct(\\"\\") == 0 assert length_of_longest_substring_two_distinct(\\"abcd\\") == 2 assert length_of_longest_substring_two_distinct(\\"abababab\\") == 8 assert length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 # Running the test test_length_of_longest_substring_two_distinct() print(\\"All tests passed!\\")","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: if len(s) < 2: return len(s) start, max_length = 0, 0 char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_cells_to_paint(m: int, n: int, grid: List[List[int]]) -> int: Given the dimensions and initial state of the grid, returns the minimum number of cells that must be painted such that no two adjacent cells have different colors. >>> min_cells_to_paint(3, 3, [ ... [1, 2, 2], ... [3, 3, 3], ... [4, 4, 4] ... ]) 3 >>> min_cells_to_paint(2, 2, [ ... [1, 1], ... [1, 2] ... ]) 1","solution":"def min_cells_to_paint(m, n, grid): Given the dimensions and initial state of the grid, returns the minimum number of cells that must be painted such that no two adjacent cells have different colors. def dfs(x, y, color): stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == color: visited.add((nx, ny)) stack.append((nx, ny)) visited = set() component_count = 0 for i in range(m): for j in range(n): if (i, j) not in visited: dfs(i, j, grid[i][j]) component_count += 1 return component_count - 1"},{"question":"def shortest_palindrome(s: str) -> str: Given a string, returns the shortest palindrome that can be made by adding characters to the end of the string. >>> shortest_palindrome(\\"race\\") == \\"racecar\\" >>> shortest_palindrome(\\"abab\\") == \\"ababa\\" >>> shortest_palindrome(\\"a\\") == \\"a\\"","solution":"def shortest_palindrome(s): Given a string, returns the shortest palindrome that can be made by adding characters to the end of the string. if s == s[::-1]: # if the string itself is a palindrome return s def is_palindrome(word): return word == word[::-1] for i in range(len(s)): if is_palindrome(s[i:]): return s + s[:i][::-1] return s + s[::-1] # fallback case, should not actually hit this line # Example usage # print(shortest_palindrome(\\"race\\")) should output \\"racecar\\" # print(shortest_palindrome(\\"abab\\")) should output \\"ababa\\""},{"question":"def modify_list(n, a): Modify the list such that all occurrences of the maximum value are replaced with the minimum value, and all occurrences of the minimum value are replaced with the maximum value. Args: n (int): The number of elements in the list. a (List[int]): The list of integers. Returns: List[int]: The modified list of integers. Examples: >>> modify_list(5, [1, 3, 5, 3, 1]) [5, 3, 1, 3, 5] >>> modify_list(6, [-1, 4, 7, 7, -1, 2]) [7, 4, -1, -1, 7, 2]","solution":"def modify_list(n, a): if n == 0: return [] max_val = max(a) min_val = min(a) return [ (min_val if i == max_val else max_val if i == min_val else i) for i in a ]"},{"question":"from typing import List def count_anagram_groups(words: List[str]) -> int: Determines the number of groups of anagrams in the given list of words. Parameters: words (list of str): List of words to be checked for anagram groups. Returns: int: Number of distinct groups of anagrams. >>> count_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\", \\"drolw\\"]) 3 >>> count_anagram_groups([\\"cat\\", \\"act\\", \\"tac\\", \\"dog\\"]) 2 >>> count_anagram_groups([\\"hello\\"]) 1 >>> count_anagram_groups(['cat', 'dog', 'hello', 'world']) 4 >>> count_anagram_groups(['cat', 'act', 'tac', 'dog', 'god', 'hello']) 3 >>> count_anagram_groups([]) 0","solution":"from collections import defaultdict def count_anagram_groups(words): Determines the number of groups of anagrams in the given list of words. Parameters: words (list of str): List of words to be checked for anagram groups. Returns: int: Number of distinct groups of anagrams. anagram_groups = defaultdict(int) for word in words: sorted_word = ''.join(sorted(word)) anagram_groups[sorted_word] += 1 return len(anagram_groups)"},{"question":"def get_kth_id(k: int) -> str: Returns the k-th ID in the sequence of unique IDs assigned to participants. Parameters: k (int): The position in the sequence of IDs (1 ≤ k ≤ 10^6). Returns: str: The k-th ID in the sequence. >>> get_kth_id(1) 'A' >>> get_kth_id(27) 'AA' >>> get_kth_id(53) 'BA' >>> get_kth_id(26) 'Z' >>> get_kth_id(28) 'AB' >>> get_kth_id(1000) 'ALL'","solution":"def get_kth_id(k): Returns the k-th ID in the sequence of unique IDs assigned to participants. Parameters: k (int): The position in the sequence of IDs (1 ≤ k ≤ 10^6). Returns: str: The k-th ID in the sequence. result = [] while k > 0: k -= 1 result.append(chr(k % 26 + ord('A'))) k //= 26 return ''.join(reversed(result))"},{"question":"def process_queries(n: int, queries: List[str]) -> List[str]: Process the changes and queries about the network structure. Parameters: n (int): Number of nodes in the network. queries (List[str]): List of changes and queries. Returns: List[str]: Results of the queries. Example: >>> n = 5 >>> queries = [ \\"A 1 2\\", \\"A 2 3\\", \\"D 1 2\\", \\"P 1 3\\", \\"R 1 2\\", \\"D 1 2\\", \\"P 1 3\\" ] >>> process_queries(n, queries) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def find_paths(adj_list, u, v, visited): if u == v: return True visited[u] = True for neighbor in adj_list[u]: if not visited[neighbor]: if find_paths(adj_list, neighbor, v, visited): return True return False def process_queries(n, queries): adj_list = [[] for _ in range(n + 1)] results = [] for query in queries: parts = query.split() cmd = parts[0] u = int(parts[1]) v = int(parts[2]) if cmd == \\"A\\": adj_list[u].append(v) elif cmd == \\"R\\": if v in adj_list[u]: adj_list[u].remove(v) elif cmd == \\"D\\": if v in adj_list[u]: results.append(\\"YES\\") else: results.append(\\"NO\\") elif cmd == \\"P\\": visited = [False] * (n + 1) if find_paths(adj_list, u, v, visited): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def highest_score(N: int, scores: List[int]) -> int: Calculate the highest possible total score a player can achieve using N darts. Parameters: N (int): Number of darts. scores (list): List of integers representing the possible scores for hitting each target on the dartboard. Returns: int: The highest possible score. >>> highest_score(3, [10, 20, 30, 40]) 120 >>> highest_score(5, [5, 3, 7]) 35","solution":"def highest_score(N, scores): Calculate the highest possible total score a player can achieve using N darts. Parameters: N (int): Number of darts. scores (list): List of integers representing the possible scores for hitting each target on the dartboard. Returns: int: The highest possible score. max_score = max(scores) return N * max_score"},{"question":"def letter_count(s: str) -> str: For each unique letter in the string, output the number of times it appears in the string. The output should display the letters in the order they first appear in the string. >>> letter_count(\\"hello\\") 'h1 e1 l2 o1' >>> letter_count(\\"programming\\") 'p1 r2 o1 g2 a1 m2 i1 n1'","solution":"def letter_count(s): Returns a string that lists each unique letter in the input string \`s\` followed by the number of times it appears in the string, in the order they first appear in the string. from collections import OrderedDict # Use an ordered dictionary to keep track of the count in the order of first appearance count_dict = OrderedDict() # Count occurrences of each character for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 # Create the result string result = ' '.join(f\\"{char}{count}\\" for char, count in count_dict.items()) return result"},{"question":"def total_coins(L): Given the number of levels L, returns the total number of coins collected after completing L levels. pass def multiple_test_cases(T, test_cases): Handles multiple test cases for total_coins. Parameters: T (int): Number of test cases. test_cases (list): List of integers representing L values for each test case. Returns: list: List of results for each test case. pass from solution import total_coins, multiple_test_cases def test_total_coins_single_case(): assert total_coins(1) == 2 assert total_coins(2) == 6 assert total_coins(3) == 14 assert total_coins(4) == 30 assert total_coins(5) == 62 def test_multiple_test_cases(): assert multiple_test_cases(3, [1, 2, 3]) == [2, 6, 14] assert multiple_test_cases(2, [4, 5]) == [30, 62] assert multiple_test_cases(5, [1, 1, 1, 1, 1]) == [2, 2, 2, 2, 2] assert multiple_test_cases(4, [3, 2, 5, 1]) == [14, 6, 62, 2]","solution":"def total_coins(L): Given the number of levels L, returns the total number of coins collected after completing L levels. return sum(2 ** i for i in range(1, L+1)) def multiple_test_cases(T, test_cases): Handles multiple test cases for total_coins. Parameters: T (int): Number of test cases. test_cases (list): List of integers representing L values for each test case. Returns: list: List of results for each test case. results = [] for L in test_cases: results.append(total_coins(L)) return results"},{"question":"def find_element(arr, target): Search for a specific element in an array. Returns True if the target is found in the array and False otherwise. >>> find_element([1, 2, 3, 4, 5], 3) True >>> find_element([1, 2, 3, 4, 5], 6) False >>> find_element([], 1) False >>> find_element([1], 1) True >>> find_element([1], 2) False >>> find_element([1, 2, 3, 1, 2, 3], 3) True >>> find_element([1, 2, 3, 1, 2, 3], 4) False","solution":"def find_element(arr, target): for i in range(len(arr)): if arr[i] == target: return True return False # Example usage print(find_element([1, 2, 3, 4, 5], 3)) # Should return True print(find_element([1, 2, 3, 4, 5], 6)) # Should return False"},{"question":"def searchMatrix(matrix: List[List[int]], target: int) -> bool: Given a matrix of integers where each row is sorted in ascending order and each column is also sorted in ascending order, the function returns a boolean indicating whether the target exists in the matrix. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30]] >>> searchMatrix(matrix, 5) True >>> searchMatrix(matrix, 20) False from solution import searchMatrix def test_search_matrix_found_middle(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert searchMatrix(matrix, target) == True def test_search_matrix_not_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 assert searchMatrix(matrix, target) == False def test_search_matrix_found_corner(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 30 assert searchMatrix(matrix, target) == True def test_search_matrix_one_element_found(): matrix = [ [1] ] target = 1 assert searchMatrix(matrix, target) == True def test_search_matrix_one_element_not_found(): matrix = [ [1] ] target = 2 assert searchMatrix(matrix, target) == False def test_search_matrix_empty_matrix(): matrix = [] target = 1 assert searchMatrix(matrix, target) == False def test_search_matrix_empty_subarray(): matrix = [[]] target = 1 assert searchMatrix(matrix, target) == False","solution":"def searchMatrix(matrix, target): This function takes a matrix where each row is sorted in ascending order and each column is also sorted in ascending order, and a target integer value. It returns a boolean indicating whether the target exists in the matrix. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner and iterate through the matrix while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def longest_distinct_subarray(n, k, a): Returns the length of the longest contiguous subarray where all elements are distinct. >>> longest_distinct_subarray(8, 4, [2, 1, 4, 3, 1, 2, 2, 3]) 4 >>> longest_distinct_subarray(5, 5, [1, 2, 3, 4, 5]) 5 >>> longest_distinct_subarray(5, 1, [1, 1, 1, 1, 1]) 1 >>> longest_distinct_subarray(7, 4, [1, 1, 2, 3, 4, 2, 2]) 4 >>> longest_distinct_subarray(6, 3, [1, 1, 1, 2, 3, 4]) 4 >>> longest_distinct_subarray(100, 100, list(range(1, 101))) 100 >>> longest_distinct_subarray(9, 5, [1, 2, 3, 4, 5, 1, 2, 3, 4]) 5 >>> longest_distinct_subarray(13, 5, [1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1]) 5","solution":"def longest_distinct_subarray(n, k, a): Returns the length of the longest contiguous subarray where all elements are distinct. max_length = 0 start = 0 seen = {} for end in range(n): if a[end] in seen and seen[a[end]] >= start: start = seen[a[end]] + 1 seen[a[end]] = end max_length = max(max_length, end - start + 1) return max_length # Example usage: # n, k = 8, 4 # a = [2, 1, 4, 3, 1, 2, 2, 3] # print(longest_distinct_subarray(n, k, a)) # Output: 4"},{"question":"def minimizeMaxCalories(calories): You are given an array of integers representing the number of calories in each segment of a chocolate bar. You want to break the chocolate bar into exactly two pieces and each piece must contain at least one segment. Your goal is to eat the piece with the maximum total number of calories, but you want to minimize that maximum to control your calorie intake. Args: calories (List[int]): An array of integers representing the number of calories in each segment of a chocolate bar. Returns: int: The minimum possible value of the maximum calorie piece you can get after breaking the chocolate bar into two pieces. Examples: >>> minimizeMaxCalories([4, 5, 9, 7]) 16 >>> minimizeMaxCalories([1, 2, 3, 4, 5]) 9","solution":"def minimizeMaxCalories(calories): n = len(calories) min_max_calories = float('inf') # Iterate through possible splits for i in range(1, n): left_piece = sum(calories[:i]) right_piece = sum(calories[i:]) max_piece = max(left_piece, right_piece) min_max_calories = min(min_max_calories, max_piece) return min_max_calories"},{"question":"def reverse_first_n_characters(S: str, N: int) -> str: Returns a string where the first N characters are reversed, and the rest of the string is unchanged. Parameters: S (str): the input string N (int): the number of characters to reverse from the beginning of the string Returns: str: the resulting string with the first N characters reversed >>> reverse_first_n_characters(\\"helloworld\\", 5) 'ollehworld' >>> reverse_first_n_characters(\\"helloworld\\", 1) 'helloworld' >>> reverse_first_n_characters(\\"helloworld\\", 10) 'dlrowolleh' >>> reverse_first_n_characters(\\"abcdef\\", 3) 'cbadef' >>> reverse_first_n_characters(\\"abcdef\\", 6) 'fedcba'","solution":"def reverse_first_n_characters(S, N): Returns a string where the first N characters are reversed, and the rest of the string is unchanged. Parameters: S (str): the input string N (int): the number of characters to reverse from the beginning of the string Returns: str: the resulting string with the first N characters reversed if not 1 <= N <= len(S): raise ValueError(\\"N must be between 1 and the length of the string S.\\") return S[:N][::-1] + S[N:]"},{"question":"from typing import List, Tuple def find_loading_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine a valid loading order for the modules based on their dependencies. >>> find_loading_order(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) [5, 4, 3, 2, 1] >>> find_loading_order(3, 3, [(1, 2), (2, 3), (3, 1)]) [] pass def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input string to extract number of modules, dependencies, and the list of dependencies. >>> parse_input(\\"5n4n1 2n2 3n3 4n4 5\\") (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) >>> parse_input(\\"3n3n1 2n2 3n3 1\\") (3, 3, [(1, 2), (2, 3), (3, 1)]) pass # Example Tests def test_example_1(): input_str = \\"5n4n1 2n2 3n3 4n4 5\\" n, m, dependencies = parse_input(input_str) assert find_loading_order(n, m, dependencies) == [5, 4, 3, 2, 1] def test_example_2(): input_str = \\"3n3n1 2n2 3n3 1\\" n, m, dependencies = parse_input(input_str) assert find_loading_order(n, m, dependencies) == [] def test_single_module(): input_str = \\"2n1n1 2\\" n, m, dependencies = parse_input(input_str) assert find_loading_order(n, m, dependencies) == [2, 1] def test_no_dependencies(): input_str = \\"3n0\\" n, m, dependencies = parse_input(input_str) assert find_loading_order(n, m, dependencies) == [1, 2, 3] def test_complex_example(): input_str = \\"6n6n2 3n3 4n4 5n5 6n6 1n1 2\\" n, m, dependencies = parse_input(input_str) assert find_loading_order(n, m, dependencies) == []","solution":"from collections import defaultdict, deque def find_loading_order(n, m, dependencies): in_degree = {i: 0 for i in range(1, n + 1)} graph = defaultdict(list) for a, b in dependencies: graph[b].append(a) in_degree[a] += 1 queue = deque([node for node in in_degree if in_degree[node] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) == n: return result else: return [] def parse_input(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) m = int(input_lines[1]) dependencies = [tuple(map(int, line.split())) for line in input_lines[2:]] return n, m, dependencies"},{"question":"def find_max_sum_triplet(arr): Returns the indices i, j, k such that: - 0 ≤ i < j < k < len(arr) - The sum of elements in the triplet (arr[i] + arr[j] + arr[k]) is the maximum possible. Parameters: arr (list): List of integers. Returns: tuple: A tuple containing three integers (i, j, k). # Your code here # Unit tests def test_example_1(): arr = [2, 6, 1, 4, 9] result = find_max_sum_triplet(arr) assert result == (1, 3, 4) def test_example_2(): arr = [-1, -2, -3, -4] result = find_max_sum_triplet(arr) assert result == (0, 1, 2) def test_partially_sorted_array(): arr = [1, 2, 3, 4, 5] result = find_max_sum_triplet(arr) assert result == (2, 3, 4) def test_all_same_values(): arr = [5, 5, 5, 5, 5] result = find_max_sum_triplet(arr) assert result == (0, 1, 2) def test_large_numbers(): arr = [10**9, -10**9, 0, 10**9, -10**9, 10**9] result = find_max_sum_triplet(arr) assert result == (0, 3, 5)","solution":"def find_max_sum_triplet(arr): Returns the indices i, j, k such that: - 0 ≤ i < j < k < len(arr) - The sum of elements in the triplet (arr[i] + arr[j] + arr[k]) is the maximum possible. Parameters: arr (list): List of integers. Returns: tuple: A tuple containing three integers (i, j, k). N = len(arr) if N < 3: return (None, None, None) max_sum = float('-inf') triplet = (-1, -1, -1) for i in range(N-2): for j in range(i+1, N-1): for k in range(j+1, N): current_sum = arr[i] + arr[j] + arr[k] if current_sum > max_sum: max_sum = current_sum triplet = (i, j, k) return triplet"},{"question":"def count_candidates_above_threshold(N: int, scores: List[int], T: int) -> int: Returns the count of candidates who have scored above or equal to the threshold score. Parameters: N (int): The number of candidates. scores (list of int): The scores of the candidates. T (int): The threshold score. Returns: int: The count of candidates scoring above or equal to the threshold score. >>> count_candidates_above_threshold(5, [85, 67, 90, 75, 88], 80) == 3 >>> count_candidates_above_threshold(3, [55, 42, 69], 70) == 0 >>> count_candidates_above_threshold(4, [55, 67, 89, 77], 55) == 4 >>> count_candidates_above_threshold(2, [40, 60], 60) == 1 >>> count_candidates_above_threshold(6, [95, 23, 57, 86, 45, 61], 50) == 4","solution":"def count_candidates_above_threshold(N, scores, T): Returns the count of candidates who have scored above or equal to the threshold score. Parameters: N (int): The number of candidates. scores (list of int): The scores of the candidates. T (int): The threshold score. Returns: int: The count of candidates scoring above or equal to the threshold score. count = 0 for score in scores: if score >= T: count += 1 return count"},{"question":"from typing import List def shortest_path(warehouse: List[str]) -> int: Calculate the minimal distance a robot should travel to pick up all items and return to the starting point. >>> shortest_path([ \\"S..\\", \\".I.\\", \\"..I\\" ]) == 8 >>> shortest_path([ \\"S..I\\", \\".II.\\", \\"..I.\\", \\"....\\" ]) == 10 >>> shortest_path([ \\"S..\\", \\"...\\", \\"...\\" ]) == 0 >>> shortest_path([ \\"S\\", \\"I\\", \\"I\\" ]) == -1 >>> shortest_path([\\"S\\"]) == 0","solution":"from itertools import permutations from collections import deque def shortest_path(warehouse): def bfs(start, grid): Perform Breadth-First Search (BFS) to find the shortest paths from \`start\` distances = {} q = deque([start]) distances[start] = 0 m, n = len(grid), len(grid[0]) while q: x, y = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in distances and grid[nx][ny] != '#': distances[(nx, ny)] = distances[(x, y)] + 1 q.append((nx, ny)) return distances # Read the grid m = len(warehouse) n = len(warehouse[0]) grid = warehouse # Find positions of starting point and items start = (0, 0) items = [] for i in range(m): for j in range(n): if grid[i][j] == 'I': items.append((i, j)) # Return immediately if there are no items if not items: return 0 # BFS from start all_points = [start] + items point_to_index = {point: i for i, point in enumerate(all_points)} dist_matrix = [[0] * len(all_points) for _ in range(len(all_points))] for point in all_points: distances = bfs(point, grid) for dest_point in all_points: if dest_point in distances: dist_matrix[point_to_index[point]][point_to_index[dest_point]] = distances[dest_point] else: dist_matrix[point_to_index[point]][point_to_index[dest_point]] = float('inf') # Calculate shortest path visiting all items and returning to start num_points = len(all_points) min_distance = float('inf') for perm in permutations(range(1, num_points)): total_distance = dist_matrix[0][perm[0]] for i in range(len(perm) - 1): total_distance += dist_matrix[perm[i]][perm[i + 1]] total_distance += dist_matrix[perm[-1]][0] min_distance = min(min_distance, total_distance) return min_distance if min_distance != float('inf') else -1"},{"question":"def format_string(S: str) -> str: Formats the string by removing all non-alphanumeric characters and converting to lowercase. >>> format_string(\\"Hello, World!\\") \\"helloworld\\" >>> format_string(\\"Python_3.8\\") \\"python38\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases. >>> process_test_cases(2, [\\"Hello, World!\\", \\"Python_3.8\\"]) [\\"helloworld\\", \\"python38\\"] >>> process_test_cases(3, [\\"123 ABC !!\\", \\"xyz_456!!!\\", \\"simpleTestCase\\"]) [\\"123abc\\", \\"xyz456\\", \\"simpletestcase\\"]","solution":"def format_string(S): Formats the string by removing all non-alphanumeric characters and converting to lowercase. formatted = ''.join(char.lower() for char in S if char.isalnum()) return formatted def process_test_cases(T, test_cases): Processes multiple test cases. results = [format_string(case) for case in test_cases] return results"},{"question":"def max_sublist_sum(m: int, b: List[int]) -> int: Returns the maximum sum of a sublist (contiguous portion) from the list b. >>> max_sublist_sum(5, [1, -2, 3, 4, -1]) == 7 >>> max_sublist_sum(6, [-3, 2, -1, 4, -2, 1]) == 5 from typing import List def test_single_element_positive(): assert max_sublist_sum(1, [5]) == 5 def test_single_element_negative(): assert max_sublist_sum(1, [-4]) == -4 def test_all_negative_elements(): assert max_sublist_sum(3, [-2, -3, -1]) == -1 def test_mix_positive_and_negative_elements(): assert max_sublist_sum(5, [1, -2, 3, 4, -1]) == 7 assert max_sublist_sum(6, [-3, 2, -1, 4, -2, 1]) == 5 def test_all_positive_elements(): assert max_sublist_sum(4, [2, 3, 1, 4]) == 10 def test_zero_elements(): assert max_sublist_sum(4, [0, 0, 0, 0]) == 0 def test_alternating_positive_and_negative(): assert max_sublist_sum(8, [-2, 3, -4, 5, -6, 7, -8, 9]) == 9 assert max_sublist_sum(6, [-1, 3, -2, 3, 4, -6]) == 8","solution":"def max_sublist_sum(m, b): Returns the maximum sum of a sublist (contiguous portion) from the list b. max_current = max_global = b[0] for i in range(1, m): max_current = max(b[i], max_current + b[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_frequencies(input_string: str) -> dict: Takes a string containing a list of integers separated by commas and spaces, and returns a dictionary with the integer as key and the frequency of its occurrence in the list as value. >>> count_frequencies(\\"1, 2, 2, 3, 3, 3, 4, 4, 4, 4\\") {1: 1, 2: 2, 3: 3, 4: 4} >>> count_frequencies(\\"5\\") {5: 1} >>> count_frequencies(\\"7, 7, 7, 7, 7\\") {7: 5} >>> count_frequencies(\\"1, 10, 100, 1000, 10000\\") {1: 1, 10: 1, 100: 1, 1000: 1, 10000: 1} >>> count_frequencies(\\"-1, -1, 0, 0, 1, 1\\") {-1: 2, 0: 2, 1: 2}","solution":"def count_frequencies(input_string): Takes a string containing a list of integers separated by commas and spaces, and returns a dictionary with the integer as key and the frequency of its occurrence in the list as value. # Split the input string by ', ' to get a list of integers in string format list_of_numbers = input_string.split(', ') # Convert the list of string numbers to a list of integers list_of_numbers = list(map(int, list_of_numbers)) # Create a dictionary to hold the frequencies frequency_dict = {} # Count the frequencies of each number for number in list_of_numbers: if number in frequency_dict: frequency_dict[number] += 1 else: frequency_dict[number] = 1 return frequency_dict"},{"question":"from typing import List, Tuple def max_toll_on_paths(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Finds the maximum toll fee among all roads on the unique path between two cities. Parameters: n (int): The number of cities. roads (List[Tuple[int, int, int]]): Each tuple contains two cities connected by a road and the toll fee for that road. queries (List[Tuple[int, int]]): Each tuple contains two cities for which to find the maximum toll fee on the path between them. Returns: List[int]: The maximum toll fee for each query. Example: >>> max_toll_on_paths(5, [(1, 2, 4), (2, 3, 6), (2, 4, 5), (4, 5, 8)], [(1, 3), (4, 5), (3, 5)]) [6, 8, 8] def test_single_query(): n = 5 roads = [ (1, 2, 4), (2, 3, 6), (2, 4, 5), (4, 5, 8), ] queries = [(1, 3)] assert max_toll_on_paths(n, roads, queries) == [6] def test_multiple_queries(): n = 5 roads = [ (1, 2, 4), (2, 3, 6), (2, 4, 5), (4, 5, 8), ] queries = [(1, 3), (4, 5), (3, 5)] assert max_toll_on_paths(n, roads, queries) == [6, 8, 8] def test_disjoint_cases(): n = 4 roads = [ (1, 2, 2), (1, 3, 3), (3, 4, 1), ] queries = [(2, 4), (1, 4), (3, 2)] assert max_toll_on_paths(n, roads, queries) == [3, 3, 3] def test_minimal_case(): n = 2 roads = [ (1, 2, 9), ] queries = [(1, 2)] assert max_toll_on_paths(n, roads, queries) == [9] def test_large_weights(): n = 3 roads = [ (1, 2, 10**9), (2, 3, 10**9 - 1), ] queries = [(1, 3), (2, 3)] assert max_toll_on_paths(n, roads, queries) == [10**9, 10**9 - 1]","solution":"from collections import defaultdict import sys sys.setrecursionlimit(1000000) class TreePathMaxToll: def __init__(self, n): self.n = n self.graph = defaultdict(list) self.max_toll = [[-1] * 17 for _ in range(n + 1)] self.level = [0] * (n + 1) self.parent = [[-1] * 17 for _ in range(n + 1)] def add_road(self, a, b, w): self.graph[a].append((b, w)) self.graph[b].append((a, w)) def dfs(self, node, par, lvl, weight): self.parent[node][0] = par self.level[node] = lvl self.max_toll[node][0] = weight for (next_node, w) in self.graph[node]: if next_node != par: self.dfs(next_node, node, lvl + 1, w) def precompute(self): self.dfs(1, -1, 0, 0) # Precompute the \`parent\` and \`max_toll\` tables for LCA for j in range(1, 17): for i in range(1, self.n + 1): if self.parent[i][j - 1] != -1: self.parent[i][j] = self.parent[self.parent[i][j - 1]][j - 1] self.max_toll[i][j] = max(self.max_toll[i][j - 1], self.max_toll[self.parent[i][j - 1]][j - 1]) def query(self, u, v): if self.level[u] < self.level[v]: u, v = v, u max_w = 0 # Lift u up to the same level as v for i in range(16, -1, -1): if self.level[u] - (1 << i) >= self.level[v]: max_w = max(max_w, self.max_toll[u][i]) u = self.parent[u][i] # If u and v are same, return the max toll found so far if u == v: return max_w # Find the LCA and maximum toll in the process for i in range(16, -1, -1): if self.parent[u][i] != self.parent[v][i]: max_w = max(max_w, self.max_toll[u][i], self.max_toll[v][i]) u = self.parent[u][i] v = self.parent[v][i] max_w = max(max_w, self.max_toll[u][0], self.max_toll[v][0]) return max_w def max_toll_on_paths(n, roads, queries): tree = TreePathMaxToll(n) for a, b, w in roads: tree.add_road(a, b, w) tree.precompute() results = [] for u, v in queries: results.append(tree.query(u, v)) return results"},{"question":"from typing import List def countTribalVillages(grid: List[List[str]]) -> int: Counts the number of distinct tribal villages in the given grid. Args: grid (List[List[str]]): The input grid representing the kingdom. Returns: int: The number of distinct tribal villages. >>> countTribalVillages([ ... ['T', '.', '.', 'T'], ... ['.', '#', '.', '#'], ... ['T', '#', '#', 'T'], ... ['.', '.', 'T', '.'] ... ]) 5 >>> countTribalVillages([ ... ['T', '.', 'T'], ... ['.', '#', '.'], ... ['.', 'T', '.'] ... ]) 3 >>> countTribalVillages([ ... ['T', 'T', '.', '.', 'T'], ... ['T', '#', '.', '.', '#'], ... ['.', '.', 'T', '.', 'T'], ... ['.', '#', '.', '#', '.'], ... ['T', '.', '.', 'T', 'T'] ... ]) 6 >>> countTribalVillages([['.']]) 0 >>> countTribalVillages([['T']]) 1","solution":"def countTribalVillages(grid): Counts the number of distinct tribal villages in the given grid. Args: grid (List[List[str]]): The input grid representing the kingdom. Returns: int: The number of distinct tribal villages. n = len(grid) m = len(grid[0]) def dfs(x, y): # Check for out of bounds or already visited cells if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] != 'T': return # Mark the cell as visited by setting it to '.' grid[x][y] = '.' # Explore in all 4 directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'T': # Start a DFS to mark all connected 'T' cells dfs(i, j) count += 1 return count"},{"question":"def restore_hat_patterns(n: int, m: int, shuffled_string: str, h: int, patterns: List[str]) -> str: Restore the original order of the hat patterns from the shuffled string. Args: n : int : the number of unique hat patterns m : int : the length of each hat pattern shuffled_string : str : the shuffled string consisting of all colors from the hat patterns h : int : the number of available hat patterns to choose from patterns : List[str] : the list of hat patterns Returns: str : If there is no valid order to restore all patterns, return \\"NO\\". Otherwise, return \\"YES\\" followed by the indexes of the patterns in the order they appear in the string. >>> restore_hat_patterns(3, 2, \\"aabbcc\\", 4, [\\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\"]) 'YESn1 2 3' >>> restore_hat_patterns(3, 2, \\"ababcc\\", 3, [\\"bb\\", \\"aa\\", \\"cc\\"]) 'NO'","solution":"def restore_hat_patterns(n, m, shuffled_string, h, patterns): from collections import Counter # Create a set of available patterns for quick lookup available_patterns = {} for i, pattern in enumerate(patterns): available_patterns[pattern] = i + 1 # store index+1 for each pattern # create a list of all patterns from the shuffled_string string_patterns = [shuffled_string[i:i+m] for i in range(0, len(shuffled_string), m)] # create a counter for all patterns in the shuffled_string counter_string_patterns = Counter(string_patterns) # create a counter for all available patterns counter_available_patterns = Counter(patterns) # check if we have enough patterns in available patterns to match string patterns for pattern, count in counter_string_patterns.items(): if counter_available_patterns[pattern] < count: return \\"NO\\" # If we pass the above check, assign indices to the patterns result_indices_sequence = [available_patterns[pattern] for pattern in string_patterns] return \\"YESn\\" + \\" \\".join(map(str, result_indices_sequence)) # Example usage # restore_hat_patterns(3, 2, \\"aabbcc\\", 4, [\\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\"]) # Expected output: \\"YESn1 2 3\\""},{"question":"def count_important_landmarks(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines how many important landmarks exist in the city for each test case. A building is considered an important landmark if its height is strictly greater than both its adjacent buildings. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[int]]] : A list where each element is a tuple containing an integer N, the number of buildings, and a list of integers representing the heights of the buildings. Returns: List[int] : A list containing the number of important landmarks for each test case. >>> count_important_landmarks(2, [(5, [3, 1, 4, 1, 5]), (6, [1, 2, 3, 4, 3, 2])]) [2, 1] >>> count_important_landmarks(1, [(3, [1, 100, 1])]) [1]","solution":"def count_important_landmarks(T, test_cases): results = [] for case in test_cases: N, buildings = case if N < 3: results.append(0) continue count = 0 for i in range(1, N - 1): if buildings[i] > buildings[i - 1] and buildings[i] > buildings[i + 1]: count += 1 results.append(count) return results"},{"question":"def longest_unique_string_length(test_cases): Given a list of test cases, each containing sets of strings, find the length of the longest string composed of characters from these strings, using each character exactly once. >>> parse_input(\\"2n3nabcdefnghijklnmnopqrn2nxyznabcn\\") [['abcdef', 'ghijkl', 'mnopqr'], ['xyz', 'abc']] >>> longest_unique_string_length([['abcdef', 'ghijkl', 'mnopqr'], ['xyz', 'abc']]) [18, 6] results = [] for case in test_cases: unique_chars = set() for string in case: unique_chars.update(string) results.append(len(unique_chars)) return results def parse_input(input_text): Parse the input text into a format suitable for the longest_unique_string_length function. >>> parse_input(\\"2n3nabcdefnghijklnmnopqrn2nxyznabcn\\") [['abcdef', 'ghijkl', 'mnopqr'], ['xyz', 'abc']] lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 case = [lines[index + i] for i in range(N)] index += N test_cases.append(case) return test_cases","solution":"def longest_unique_string_length(test_cases): results = [] for case in test_cases: unique_chars = set() for string in case: unique_chars.update(string) results.append(len(unique_chars)) return results def parse_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 case = [lines[index + i] for i in range(N)] index += N test_cases.append(case) return test_cases"},{"question":"from typing import List def find_max_consecutive_ones(nums: List[int]) -> int: Returns the maximum number of consecutive 1s in the given list of binary numbers. >>> find_max_consecutive_ones([1, 1, 1, 1]) 4 >>> find_max_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> find_max_consecutive_ones([1, 0, 1, 1, 0, 1]) 2 >>> find_max_consecutive_ones([0, 0, 0, 1, 0, 0]) 1 >>> find_max_consecutive_ones([0, 0, 0, 0]) 0 >>> find_max_consecutive_ones([1]) 1 >>> find_max_consecutive_ones([0]) 0 >>> find_max_consecutive_ones([1] * 5000 + [0] + [1] * 4999) 5000","solution":"from typing import List def find_max_consecutive_ones(nums: List[int]) -> int: Returns the maximum number of consecutive 1s in the given list of binary numbers. max_count = 0 current_count = 0 for num in nums: if num == 1: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"class EventSeating: def __init__(self, n): Initialize the EventSeating with N seats, all initially empty. :param n: Number of seats. self.n = n self.seats = [0] * (n + 1) # Use 1-based indexing for seats def addAttendee(self, seat: int): Adds an attendee to the seat if it's not already occupied. :param seat: The seat number to add an attendee to. def removeAttendee(self, seat: int): Removes an attendee from the seat if it's not already empty. :param seat: The seat number to remove an attendee from. def countAttendees(self, start: int, end: int) -> int: Returns the number of attendees between seats numbered start and end inclusive. :param start: The starting seat number. :param end: The ending seat number. :return: The count of attendees in the specified range. # Example test cases def test_add_attendee(): event_seating = EventSeating(10) event_seating.addAttendee(3) event_seating.addAttendee(5) assert event_seating.seats[3] == 1 assert event_seating.seats[5] == 1 def test_remove_attendee(): event_seating = EventSeating(10) event_seating.addAttendee(3) event_seating.removeAttendee(3) assert event_seating.seats[3] == 0 def test_count_attendees(): event_seating = EventSeating(10) event_seating.addAttendee(2) event_seating.addAttendee(3) event_seating.addAttendee(5) count = event_seating.countAttendees(1, 5) assert count == 3 def test_add_and_remove_attendee(): event_seating = EventSeating(10) event_seating.addAttendee(3) assert event_seating.seats[3] == 1 event_seating.removeAttendee(3) assert event_seating.seats[3] == 0 event_seating.addAttendee(3) assert event_seating.seats[3] == 1 def test_count_empty_seats(): event_seating = EventSeating(10) count = event_seating.countAttendees(1, 10) assert count == 0 def test_count_attendees_partial_range(): event_seating = EventSeating(10) event_seating.addAttendee(5) count = event_seating.countAttendees(4, 6) assert count == 1 count = event_seating.countAttendees(1, 4) assert count == 0","solution":"class EventSeating: def __init__(self, n): Initialize the EventSeating with N seats, all initially empty. :param n: Number of seats. self.n = n self.seats = [0] * (n + 1) # Use 1-based indexing for seats def addAttendee(self, seat: int): Adds an attendee to the seat if it's not already occupied. :param seat: The seat number to add an attendee to. if self.seats[seat] == 0: self.seats[seat] = 1 def removeAttendee(self, seat: int): Removes an attendee from the seat if it's not already empty. :param seat: The seat number to remove an attendee from. if self.seats[seat] == 1: self.seats[seat] = 0 def countAttendees(self, start: int, end: int) -> int: Returns the number of attendees between seats numbered start and end inclusive. :param start: The starting seat number. :param end: The ending seat number. :return: The count of attendees in the specified range. return sum(self.seats[start:end+1])"},{"question":"def count_palindromic_substrings(s: str) -> int: Given a string s consisting of lowercase English letters, count the number of substrings that are palindromes. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"\\") 0 >>> long_string = \\"a\\" * 100 >>> sum(range(1, 101)) # Sum of first 100 natural numbers 5050 >>> count_palindromic_substrings(long_string) 5050 pass","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes centered at i expand_around_center(i, i) # Even length palindromes centered between i and i+1 expand_around_center(i, i + 1) return count"},{"question":"import math def calculate_total_distance(positions): Calculates the total Euclidean distance traveled given a list of positions. total_distance = 0.0 for i in range(1, len(positions)): x1, y1 = positions[i-1] x2, y2 = positions[i] distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) total_distance += distance return total_distance def process_input(input_data): Processes the input data to calculate the total distance traveled by each sensor. index = 0 output = [] while index < len(input_data): num_sensors = int(input_data[index]) if num_sensors == 0: break index += 1 for _ in range(num_sensors): num_positions = int(input_data[index]) index += 1 positions = [] for _ in range(num_positions): x, y = map(int, input_data[index].split()) positions.append((x, y)) index += 1 total_distance = calculate_total_distance(positions) output.append(f\\"{total_distance:.4f}\\") output.append(\\"-----\\") return output # Example usage and expected outputs for testing def test_calculate_total_distance(): assert math.isclose(calculate_total_distance([(0, 0), (3, 4), (6, 8)]), 10.0, rel_tol=1e-4) assert math.isclose(calculate_total_distance([(1, 1), (2, 2), (3, 3), (4, 4)]), 4.2426, rel_tol=1e-4) assert math.isclose(calculate_total_distance([(0, 0), (0, 4)]), 4.0, rel_tol=1e-4) assert math.isclose(calculate_total_distance([(1, 1), (1, 2), (1, 3)]), 2.0, rel_tol=1e-4) def test_process_input(): input_data = [ \\"2\\", \\"3\\", \\"0 0\\", \\"3 4\\", \\"6 8\\", \\"4\\", \\"1 1\\", \\"2 2\\", \\"3 3\\", \\"4 4\\", \\"2\\", \\"2\\", \\"0 0\\", \\"0 4\\", \\"3\\", \\"1 1\\", \\"1 2\\", \\"1 3\\", \\"0\\" ] expected_output = [ \\"10.0000\\", \\"4.2426\\", \\"-----\\", \\"4.0000\\", \\"2.0000\\", \\"-----\\" ] assert process_input(input_data) == expected_output","solution":"import math def calculate_total_distance(positions): Calculates the total Euclidean distance traveled given a list of positions. total_distance = 0.0 for i in range(1, len(positions)): x1, y1 = positions[i-1] x2, y2 = positions[i] distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) total_distance += distance return total_distance def process_input(input_data): Processes the input data to calculate the total distance traveled by each sensor. index = 0 output = [] while index < len(input_data): num_sensors = int(input_data[index]) if num_sensors == 0: break index += 1 for _ in range(num_sensors): num_positions = int(input_data[index]) index += 1 positions = [] for _ in range(num_positions): x, y = map(int, input_data[index].split()) positions.append((x, y)) index += 1 total_distance = calculate_total_distance(positions) output.append(f\\"{total_distance:.4f}\\") output.append(\\"-----\\") return output"},{"question":"def longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. >>> longest_substring(\\"abcabcbb\\") 3 >>> longest_substring(\\"bbbbb\\") 1 >>> longest_substring(\\"pwwkew\\") 3 from solution import longest_substring def test_longest_substring_examples(): assert longest_substring(\\"abcabcbb\\") == 3 assert longest_substring(\\"bbbbb\\") == 1 assert longest_substring(\\"pwwkew\\") == 3 def test_longest_substring_empty_string(): assert longest_substring(\\"\\") == 0 def test_longest_substring_single_char(): assert longest_substring(\\"a\\") == 1 def test_longest_substring_all_unique(): assert longest_substring(\\"abcdef\\") == 6 def test_longest_substring_all_same(): assert longest_substring(\\"aaaaaa\\") == 1 def test_longest_substring_mixed_chars(): assert longest_substring(\\"dvdf\\") == 3 assert longest_substring(\\"anviaj\\") == 5 assert longest_substring(\\"abba\\") == 2 def test_longest_substring_large_case(): assert longest_substring(\\"a\\" * 10000) == 1 assert longest_substring(\\"abcde\\" * 2000) == 5","solution":"def longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_shortest_string(S: str, P: str, K: int) -> str: Returns the shortest string that contains P at least K times. >>> find_shortest_string(\\"abcde\\", \\"cde\\", 2) 'cdecde' >>> find_shortest_string(\\"abc\\", \\"def\\", 3) 'defdefdef' >>> find_shortest_string(\\"abc\\", \\"aaaaa\\", 1) 'aaaaa' >>> find_shortest_string(\\"abc\\", \\"aaaaa\\", 3) 'aaaaaaa' # Tests def test_example_case(): assert find_shortest_string(\\"abcde\\", \\"cde\\", 2) == \\"cdecde\\" def test_no_overlap(): assert find_shortest_string(\\"abc\\", \\"def\\", 3) == \\"defdefdef\\" def test_maximal_overlap(): assert find_shortest_string(\\"abc\\", \\"aaaaa\\", 1) == \\"aaaaa\\" assert find_shortest_string(\\"abc\\", \\"aaaaa\\", 2) == \\"aaaaaa\\" assert find_shortest_string(\\"abc\\", \\"aaaaa\\", 3) == \\"aaaaaaa\\" def test_partial_overlap(): assert find_shortest_string(\\"abc\\", \\"abab\\", 2) == \\"ababab\\" assert find_shortest_string(\\"abc\\", \\"abab\\", 3) == \\"abababab\\" def test_single_character_repeat(): assert find_shortest_string(\\"abc\\", \\"a\\", 5) == \\"aaaaa\\" def test_long_string(): S = \\"a\\" * 100000 P = \\"abc\\" K = 4 assert find_shortest_string(S, P, K) == \\"abcabcabcabc\\" def test_large_k(): assert find_shortest_string(\\"abc\\", \\"def\\", 10000) == \\"def\\" * 10000","solution":"def find_shortest_string(S, P, K): Returns the shortest string that contains P at least K times. # We need to construct a string that will have P repeated K times # and ensure it's the shortest possible. # One way to do this is to repeatedly add the non-overlapping part of P. overlap = [0] * len(P) j = 0 # KMP preprocessing to find overlaps in P for i in range(1, len(P)): while (j > 0 and P[i] != P[j]): j = overlap[j - 1] if P[i] == P[j]: j += 1 overlap[i] = j result = P non_overlap_length = len(P) - overlap[-1] for i in range(1, K): result += P[overlap[-1]:] return result # We assume that the function will be called with input handling elsewhere, # for the sake of focusing on the function logic itself."},{"question":"import re def is_palindrome(s: str) -> bool: Determine whether a given string is a palindrome. The function should ignore spaces, punctuation, and case differences. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(s): Returns whether the given string is a palindrome, ignoring spaces, punctuation, and case. # Use a regular expression to remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def process_logs(input_data: str) -> list: Determines the highest priority message exchange for a given robot within a specific hour. Parameters: input_data (str): Input data containing multiple test cases. Returns: list: List of results for each test case in the format \\"<sender_id> <receiver_id> <priority_level>\\". >>> input_data = \\"2nrobot007 3 5nrobotA robotB 4nrobotB robot007 10nrobot007 robotC 8nalpha 2 2nalpha beta 5ngamma alpha 3\\" >>> process_logs(input_data) [\\"robotB robot007 10\\", \\"alpha beta 5\\"] >>> input_data = \\"1nrobot007 3 5nrobotA robotB 4nrobotB robotX 10nrobotX robotC 8\\" >>> process_logs(input_data) [\\"No messages\\"]","solution":"def highest_priority_message(logs, robot_id, hour): Finds the highest priority message for the given robot_id within the specified hour. Parameters: logs (list): List of message logs as tuples (sender_id, receiver_id, priority_level). robot_id (str): The robot's unique identifier. hour (int): The hour during which the messages were sent. Returns: tuple: The details of the highest priority message (sender_id, receiver_id, priority_level) or \\"No messages\\". highest_priority = -1 best_message = \\"No messages\\" for log in logs: sender_id, receiver_id, priority_level = log # Check if the log involves the specified robot and is in the required hour if robot_id == sender_id or robot_id == receiver_id: if priority_level > highest_priority: highest_priority = priority_level best_message = log return best_message def process_test_case(test_case): robot_id, n, h, *logs = test_case n = int(n) h = int(h) log_details = [tuple(log.split()) for log in logs] for i in range(n): log_details[i] = (log_details[i][0], log_details[i][1], int(log_details[i][2])) result = highest_priority_message(log_details, robot_id, h) if result == \\"No messages\\": return result else: return \\" \\".join(str(x) for x in result) def process_logs(input_data): Processes the input data to find the highest priority message for each test case. Parameters: input_data (str): The input data as described in the question. Returns: list: List of results for each test case. lines = input_data.strip().split('n') t = int(lines[0]) index = 1 results = [] for _ in range(t): test_case = [] robot_id, n, h = lines[index].split() test_case.append(robot_id) test_case.append(n) test_case.append(h) for _ in range(int(n)): index += 1 test_case.append(lines[index]) index += 1 results.append(process_test_case(test_case)) return results"},{"question":"def max_people_in_roller_coaster(testcases): Given a list of test cases with the number of people and their weights, return a list of the maximum number of people that can enter the roller coaster without exceeding the weight limit. testcases: List of tuples, where each tuple contains (N, L, weights) - number of people, weight limit, and list of weights of the people. Returns a list of integers, where each integer is the maximum number of people that can enter for each respective test case. >>> max_people_in_roller_coaster([(5, 10, [1, 2, 3, 4, 5]), (4, 15, [10, 2, 2, 5]), (6, 5, [1, 1, 1, 1, 1, 1])]) [4, 3, 5] >>> max_people_in_roller_coaster([(1, 1, [1]), (2, 3, [2, 3])]) [1, 1] >>> max_people_in_roller_coaster([(10, 1000, [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])]) [4] >>> max_people_in_roller_coaster([(5, 15, [5, 5, 5, 5, 5])]) [3] pass # Parse input def parse_input(input_str): Parse the input string and return the list of test cases. input_str: Input string with the number of test cases, followed by N and L (number of people and the weight limit) on one line, and the weights of the N people on the next line. Returns a list of test cases, where each test case is a tuple containing (N, L, weights). >>> parse_input(\\"3n5 10n1 2 3 4 5n4 15n10 2 2 5n6 5n1 1 1 1 1 1\\") [(5, 10, [1, 2, 3, 4, 5]), (4, 15, [10, 2, 2, 5]), (6, 5, [1, 1, 1, 1, 1, 1])] pass # Convert output to desired format def format_output(results): Convert the list of results to a formatted string. results: List of integers, where each integer is the maximum number of people that can enter for each respective test case. Returns a string with each result on a separate line. >>> format_output([4, 3, 5]) '4n3n5' pass from solution import max_people_in_roller_coaster, parse_input, format_output def test_sample_input(): input_str = \\"3n5 10n1 2 3 4 5n4 15n10 2 2 5n6 5n1 1 1 1 1 1\\" testcases = parse_input(input_str) results = max_people_in_roller_coaster(testcases) output = format_output(results) expected_output = \\"4n3n5\\" assert output == expected_output def test_edge_cases(): input_str = \\"2n1 1n1n2 3n2 3\\" testcases = parse_input(input_str) results = max_people_in_roller_coaster(testcases) output = format_output(results) expected_output = \\"1n1\\" assert output == expected_output def test_large_numbers(): input_str = \\"1n10 1000n100 200 300 400 500 600 700 800 900 1000\\" testcases = parse_input(input_str) results = max_people_in_roller_coaster(testcases) output = format_output(results) expected_output = \\"4\\" # Can pick 100, 200, 300, and 400 => 1000 assert output == expected_output def test_almost_exceeding_limit(): input_str = \\"1n5 15n5 5 5 5 5\\" testcases = parse_input(input_str) results = max_people_in_roller_coaster(testcases) output = format_output(results) expected_output = \\"3\\" # Can pick three 5's => 15 assert output == expected_output","solution":"def max_people_in_roller_coaster(testcases): results = [] for testcase in testcases: N, L, weights = testcase weights.sort() people_count = 0 total_weight = 0 for weight in weights: if total_weight + weight <= L: total_weight += weight people_count += 1 else: break results.append(people_count) return results # Parse input def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0].strip()) testcases = [] idx = 1 for _ in range(T): N, L = map(int, lines[idx].strip().split()) weights = list(map(int, lines[idx + 1].strip().split())) testcases.append((N, L, weights)) idx += 2 return testcases # Convert output to desired format def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"from typing import List, Dict def toll_summary(n: int, transactions: List[str]) -> Dict[str, List[int]]: Generates a summary report of toll transactions. Args: n (int): number of toll transactions. transactions (list of str): list of toll transactions in the format \\"Type Toll\\". Returns: dict: a dictionary with the number of vehicles and total toll collected for each type. >>> toll_summary(6, [\\"car 50\\", \\"truck 100\\", \\"car 50\\", \\"motorcycle 20\\", \\"car 50\\", \\"truck 100\\"]) {'Cars': [3, 150], 'Trucks': [2, 200], 'Motorcycles': [1, 20]}","solution":"def toll_summary(n, transactions): Generates a summary report of toll transactions. Args: n (int): number of toll transactions. transactions (list of str): list of toll transactions in the format \\"Type Toll\\". Returns: dict: a dictionary with the number of vehicles and total toll collected for each type. summary = { \\"car\\": [0, 0], \\"truck\\": [0, 0], \\"motorcycle\\": [0, 0] } for transaction in transactions: vehicle_type, toll = transaction.split() toll = int(toll) summary[vehicle_type][0] += 1 summary[vehicle_type][1] += toll return { \\"Cars\\": summary[\\"car\\"], \\"Trucks\\": summary[\\"truck\\"], \\"Motorcycles\\": summary[\\"motorcycle\\"] } # Sample Input n = 6 transactions = [\\"car 50\\", \\"truck 100\\", \\"car 50\\", \\"motorcycle 20\\", \\"car 50\\", \\"truck 100\\"] # Sample Execution to check the solution summary = toll_summary(n, transactions) print(\\"Cars:\\", summary[\\"Cars\\"]) print(\\"Trucks:\\", summary[\\"Trucks\\"]) print(\\"Motorcycles:\\", summary[\\"Motorcycles\\"])"},{"question":"def max_subarray_sum(test_cases): This function calculates the maximum sum of any contiguous subarray for multiple test cases. Parameters: test_cases (list of tuples): A list where each element is a tuple. The first element of the tuple is an integer N, the number of trees, and the second element is a list of integers representing the power levels of the trees. Returns: list of int: The maximum sum of any contiguous subarray for each test case. pass # Example usage (not part of the solution to the problem, just for context): if __name__ == \\"__main__\\": test_cases = [ (5, [1, -3, 2, 1, -1]), (3, [-2, -3, 4]), ] results = max_subarray_sum(test_cases) for result in results: print(result) # Unit Tests for max_subarray_sum def test_single_element(): assert max_subarray_sum([(1, [5])]) == [5] assert max_subarray_sum([(1, [-5])]) == [-5] def test_all_positive(): assert max_subarray_sum([(4, [1, 2, 3, 4])]) == [10] assert max_subarray_sum([(5, [1, 1, 1, 1, 1])]) == [5] def test_all_negative(): assert max_subarray_sum([(4, [-1, -2, -3, -4])]) == [-1] assert max_subarray_sum([(3, [-5, -6, -7])]) == [-5] def test_mixed_numbers(): assert max_subarray_sum([(5, [1, -3, 2, 1, -1])]) == [3] assert max_subarray_sum([(3, [-2, -3, 4])]) == [4] assert max_subarray_sum([(7, [2, -1, 2, 3, 4, -5, 2])]) == [10] def test_large_case(): large_case = [100000] * 100000 assert max_subarray_sum([(100000, large_case)]) == [10000000000] another_case = [-1] * 99999 + [100000] assert max_subarray_sum([(100000, another_case)]) == [100000]","solution":"def max_subarray_sum(test_cases): This function calculates the maximum sum of any contiguous subarray for multiple test cases. Parameters: test_cases (list of tuples): A list where each element is a tuple. The first element of the tuple is an integer N, the number of trees, and the second element is a list of integers representing the power levels of the trees. Returns: list of int: The maximum sum of any contiguous subarray for each test case. results = [] for N, power_levels in test_cases: max_sum = current_sum = power_levels[0] for i in range(1, N): current_sum = max(power_levels[i], current_sum + power_levels[i]) max_sum = max(max_sum, current_sum) results.append(max_sum) return results # Example usage (not part of the solution to the problem): if __name__ == \\"__main__\\": test_cases = [ (5, [1, -3, 2, 1, -1]), (3, [-2, -3, 4]), ] results = max_subarray_sum(test_cases) for result in results: print(result)"},{"question":"def subarraySum(A, N, K): Given an array A of size N and an integer K, return the number of subarrays whose sum is exactly K. Parameters: A (List[int]): The array of integers. N (int): The size of the array. K (int): The target sum. Returns: int: Number of subarrays whose sum is exactly K. Example: >>> subarraySum([1,2,3,4,5], 5, 5) 2 >>> subarraySum([1,1,1], 3, 3) 1 # Your code here","solution":"def subarraySum(A, N, K): Given an array A of size N and an integer K, return the number of subarrays whose sum is exactly K. current_sum = 0 sum_count = 0 sum_map = {} # Initialize map with 0 sum having single count sum_map[0] = 1 for value in A: current_sum += value if current_sum - K in sum_map: sum_count += sum_map[current_sum - K] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return sum_count"},{"question":"def final_length_after_removals(t, test_cases): Determine the final length of the array after all possible adjacent pairs of equal elements have been removed. Args: t (int): the number of test cases test_cases (list of tuples): list where each tuple contains n (int) and arr (list of int) Returns: list of int: a list of final lengths for each test case >>> final_length_after_removals(4, [ (6, [3, 3, 2, 2, 1, 1]), (5, [1, 2, 2, 3, 3]), (3, [1, 1, 2]), (4, [2, 2, 2, 2]) ]) [0, 1, 1, 0]","solution":"def final_length_after_removals(t, test_cases): def reduce_array(arr): stack = [] for num in arr: if stack and stack[-1] == num: stack.pop() else: stack.append(num) return len(stack) results = [] for n, arr in test_cases: results.append(reduce_array(arr)) return results"},{"question":"def rearrangeArray(arr): Rearranges the array so that all negative numbers appear before all positive numbers. Parameters: arr (list): A list of integers Returns: list: A new list with all negative numbers first, followed by positive numbers. >>> rearrangeArray([-1, 2, -3, 4, -5]) [-1, -3, -5, 2, 4] >>> rearrangeArray([1, -1, 3, -2]) [-1, -2, 1, 3] >>> rearrangeArray([-1, -2, -3, -4, -5]) [-1, -2, -3, -4, -5] >>> rearrangeArray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrangeArray([]) [] >>> rearrangeArray([0, -1, 0, 1, 0, -2]) [-1, -2, 0, 0, 1, 0] >>> rearrangeArray([0, -2, 3, 0, -1, 0]) [-2, -1, 0, 3, 0, 0]","solution":"def rearrangeArray(arr): Rearranges the array so that all negative numbers appear before all positive numbers. Parameters: arr (list): A list of integers Returns: list: A new list with all negative numbers first, followed by positive numbers. negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] return negatives + positives"},{"question":"def subset_sum(nums, target): Returns True if there exists a subset of nums that sums up to the target. :param nums: List of distinct integers. :param target: Positive integer representing the target sum. :return: Boolean value indicating whether the target sum can be achieved by any subset of nums. >>> subset_sum([1, 2, 3, 4, 5], 9) True >>> subset_sum([1, 2, 3, 7, 8], 10) True >>> subset_sum([1, 3, 5, 11, 13], 7) False","solution":"def subset_sum(nums, target): Returns True if there exists a subset of nums that sums up to target. :param nums: List of distinct integers. :param target: Positive integer representing the target sum. :return: Boolean value indicating whether the target sum can be achieved by any subset of nums. n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"def alphanumeric_pattern(a_str): Determines the type of alphanumeric pattern present in the input string. Args: a_str (str): The input string. Returns: str: One of \\"digits-only\\", \\"letters-only\\", \\"alphanumeric\\", or \\"none\\" Examples: >>> alphanumeric_pattern(\\"12345\\") 'digits-only' >>> alphanumeric_pattern(\\"hello\\") 'letters-only' >>> alphanumeric_pattern(\\"hello123\\") 'alphanumeric' >>> alphanumeric_pattern(\\"hello 123\\") 'none' >>> alphanumeric_pattern(\\"!@#\\") 'none' >>> alphanumeric_pattern(\\"abc123!\\") 'none'","solution":"def alphanumeric_pattern(a_str): Determines the type of alphanumeric pattern present in the input string. Args: a_str (str): The input string. Returns: str: One of \\"digits-only\\", \\"letters-only\\", \\"alphanumeric\\", or \\"none\\" if not a_str.isalnum(): return \\"none\\" has_digits = any(char.isdigit() for char in a_str) has_letters = any(char.isalpha() for char in a_str) if has_digits and has_letters: return \\"alphanumeric\\" elif has_digits: return \\"digits-only\\" elif has_letters: return \\"letters-only\\""},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns a list of the first n Fibonacci numbers. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_fibonacci_sequence_length_1(): assert fibonacci_sequence(1) == [0] def test_fibonacci_sequence_length_2(): assert fibonacci_sequence(2) == [0, 1] def test_fibonacci_sequence_length_5(): assert fibonacci_sequence(5) == [0, 1, 1, 2, 3] def test_fibonacci_sequence_length_10(): assert fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_fibonacci_sequence_large_length(): result = fibonacci_sequence(15) expected = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] assert result == expected","solution":"def fibonacci_sequence(n): Returns a list of the first n Fibonacci numbers. if n == 1: return [0] fib_list = [0, 1] for _ in range(2, n): fib_list.append(fib_list[-1] + fib_list[-2]) return fib_list"},{"question":"def find_all_sequences(T: int): Finds all distinct sequences of positive integers that sum up to T. >>> find_all_sequences(5) 1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 1 4 2 3 5 >>> find_all_sequences(1) 1","solution":"def find_sequences(total, current_sequence, result): Helper function to find all distinct sequences of positive integers that sum up to \`total\`. if total == 0: result.append(current_sequence[:]) return start = current_sequence[-1] if current_sequence else 1 for i in range(start, total + 1): current_sequence.append(i) find_sequences(total - i, current_sequence, result) current_sequence.pop() def find_all_sequences(T): Finds all distinct sequences of positive integers that sum up to T. result = [] find_sequences(T, [], result) for sequence in result: print(\\" \\".join(map(str, sequence)))"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Computes the number of days it takes for each day's temperature to rise above the temperature of that day. If it does not rise above, marks with a 0. :param temperatures: List of integers representing daily temperatures. :return: List of integers where each integer corresponds to the number of days it took for the temperature to rise above the temperature at that day. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([50, 40, 30, 20, 10]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 30, 30, 30, 30]) [0, 0, 0, 0, 0] >>> daily_temperatures([70]) [0] >>> daily_temperatures([100, 90, 80, 70, 60]) [0, 0, 0, 0, 0] >>> daily_temperatures([60, 70, 80, 90, 100]) [1, 1, 1, 1, 0] >>> daily_temperatures([73, 72, 75, 71, 69, 72, 76, 73]) [2, 1, 4, 2, 1, 1, 0, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Computes the number of days it takes for each day's temperature to rise above the temperature of that day. If it does not rise above, marks with a 0. :param temperatures: List of integers representing daily temperatures. :return: List of integers where each integer corresponds to the number of days it took for the temperature to rise above the temperature at that day. n = len(temperatures) result = [0] * n stack = [] # Stack to keep track of indices of the temperatures for i in range(n): # Check stack until the current temperature is not higher than the one at the top of the stack while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def generate_codes(pattern): Generates all possible 4-digit codes that match the given pattern. :param pattern: A string of length 4, containing digits '0'-'9' and asterisks '*'. :return: A list of all possible 4-digit codes that match the pattern. # Write your code here # Example test cases # >>> generate_codes(\\"12*4\\") # ['1204', '1214', '1224', '1234', '1244', '1254', '1264', '1274', '1284', '1294'] # # >>> generate_codes(\\"****\\") # Expected output from 0000 to 9999 # # >>> generate_codes(\\"0*34\\") # ['0034', '0134', '0234', '0334', '0434', '0534', '0634', '0734', '0834', '0934'] # # >>> generate_codes(\\"1234\\") # ['1234'] from itertools import product","solution":"def generate_codes(pattern): Generates all possible 4-digit codes that match the given pattern. :param pattern: A string of length 4, containing digits '0'-'9' and asterisks '*'. :return: A list of all possible 4-digit codes that match the pattern. from itertools import product pattern_list = [] for char in pattern: if char == '*': pattern_list.append('0123456789') else: pattern_list.append(char) all_combinations = product(*pattern_list) result = [''.join(comb) for comb in all_combinations] result.sort() return result"},{"question":"class ProjectManager: def __init__(self): self.projects = {} self.order = [] def add(self, id, priority): Add a new project with the specified identifier and priority. # Your code here def update(self, id, priority): Update the priority level of the existing project with the given id. # Your code here def delete(self, id): Remove the project with the given identifier from the list. # Your code here def get_highest_priority(self): Return the id and priority of the project with the highest priority. If multiple projects have the same highest priority, return the one that was added earliest. # Your code here def list_by_priority(self, minP, maxP): Print all projects with priorities within the range minP to maxP inclusive, sorted in descending order of priority, and in case of a tie, in the order they were added. # Your code here # Unit tests import pytest from solution import ProjectManager def test_add(): pm = ProjectManager() pm.add(\\"p1\\", 10) pm.add(\\"p2\\", 20) assert pm.projects == {\\"p1\\": (10, 0), \\"p2\\": (20, 1)} def test_update(): pm = ProjectManager() pm.add(\\"p1\\", 10) pm.add(\\"p2\\", 20) pm.update(\\"p1\\", 30) assert pm.projects[\\"p1\\"] == (30, 0) def test_delete(): pm = ProjectManager() pm.add(\\"p1\\", 10) pm.delete(\\"p1\\") assert \\"p1\\" not in pm.projects def test_get_highest_priority(): pm = ProjectManager() pm.add(\\"p1\\", 10) pm.add(\\"p2\\", 30) pm.add(\\"p3\\", 20) assert pm.get_highest_priority() == (\\"p2\\", 30) def test_list_by_priority(): pm = ProjectManager() pm.add(\\"p1\\", 10) pm.add(\\"p2\\", 30) pm.add(\\"p3\\", 20) assert pm.list_by_priority(15, 30) == [(\\"p2\\", 30), (\\"p3\\", 20)] if __name__ == '__main__': pytest.main()","solution":"class ProjectManager: def __init__(self): self.projects = {} self.order = [] def add(self, id, priority): if id not in self.projects: self.projects[id] = priority, len(self.order) self.order.append(id) def update(self, id, priority): if id in self.projects: old_priority, idx = self.projects[id] self.projects[id] = priority, idx def delete(self, id): if id in self.projects: del self.projects[id] def get_highest_priority(self): if not self.projects: return None highest = max(self.projects.items(), key=lambda x: (x[1][0], -x[1][1])) return highest[0], highest[1][0] def list_by_priority(self, minP, maxP): to_list = [(id, prio) for id, (prio, idx) in self.projects.items() if minP <= prio <= maxP] to_list.sort(key=lambda x: (x[1], -self.projects[x[0]][1]), reverse=True) return to_list"},{"question":"from typing import List, Tuple def time_difference(start: str, finish: str) -> int: Calculate the difference in seconds between start and finish times. Both start and finish are strings in \\"HH:MM:SS\\" format. pass # Implement the logic to calculate time difference in seconds def marathon_times(test_cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[List[int]]: Calculate the total time in seconds for runners in each test case. Args: test_cases: list of tuples, where the first element is the number of runners and the second element is a list of tuples with start and finish times for each runner. Returns: List of lists, where each inner list contains the total times in seconds for the corresponding test case. pass # Implement the logic to compute marathon times for each runner def read_input(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 runners = [] for _ in range(N): start, finish = data[index].split() runners.append((start, finish)) index += 1 test_cases.append((N, runners)) return test_cases if __name__ == \\"__main__\\": test_cases = read_input() results = marathon_times(test_cases) for result in results: for res in result: print(res)","solution":"from datetime import datetime def time_difference(start, finish): Calculate the difference in seconds between start and finish times. Both start and finish are strings in \\"HH:MM:SS\\" format. FMT = '%H:%M:%S' # Time format tdelta = datetime.strptime(finish, FMT) - datetime.strptime(start, FMT) return tdelta.seconds def marathon_times(test_cases): Calculate the total time in seconds for runners in each test case. test_cases: list of tuples, where the first element is the number of runners and the second element is a list of tuples with start and finish times for each runner. results = [] for num_runners, runners in test_cases: case_result = [] for start, finish in runners: case_result.append(time_difference(start, finish)) results.append(case_result) return results def read_input(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 runners = [] for _ in range(N): start, finish = data[index].split() runners.append((start, finish)) index += 1 test_cases.append((N, runners)) return test_cases if __name__ == \\"__main__\\": test_cases = read_input() results = marathon_times(test_cases) for result in results: for res in result: print(res)"},{"question":"def minimum_skill_difference(N: int, K: int, skill_levels: List[int]) -> int: Returns the minimum possible difference in skill levels between the highest and lowest skill levels in any valid team of size K. Parameters: N (int): The number of participants. K (int): The size of each team. skill_levels (list of int): The skill levels of the participants. Returns: int: The minimum possible difference in skill levels. Example: >>> minimum_skill_difference(6, 3, [10, 20, 30, 40, 50, 60]) 20 >>> minimum_skill_difference(5, 2, [1, 2, 3, 4, 5]) 1","solution":"def minimum_skill_difference(N, K, skill_levels): Returns the minimum possible difference in skill levels between the highest and lowest skill levels in any valid team of size K. Parameters: N (int): The number of participants. K (int): The size of each team. skill_levels (list of int): The skill levels of the participants. Returns: int: The minimum possible difference in skill levels. # Sort the skill levels first skill_levels.sort() # Initialize the minimum difference to a large value min_diff = float('inf') # Iterate through the sorted skill levels to find the minimum difference for any team of size K for i in range(N - K + 1): diff = skill_levels[i + K - 1] - skill_levels[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def mission_fuel_selection(T, missions): Determines if it's possible to match the required fuel amount exactly using a subset of fuel tanks. Parameters: T (int): Number of test cases missions (list): List of tuples, each containing the required fuel amount, the list of fuel tank capacities, and number of tanks. Returns: list: List of results for each mission. Each result is either a tuple (\\"YES\\", list of tank capacities) or \\"NO\\" indicating whether the fuel amount can be exactly met using the available fuel tanks.","solution":"def mission_fuel_selection(T, missions): Determines if it's possible to match the required fuel amount exactly using a subset of fuel tanks. Parameters: T (int): Number of test cases missions (list): List of tuples, each containing the required fuel amount, the list of fuel tank capacities, and number of tanks. Returns: list: List of results for each mission. Each result is either a tuple (\\"YES\\", list of tank capacities) or \\"NO\\" indicating whether the fuel amount can be exactly met using the available fuel tanks. results = [] def find_subset_tanks(fuel_required, tanks): n = len(tanks) dp = [[False] * (fuel_required + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(fuel_required + 1): dp[i][j] = dp[i-1][j] if j >= tanks[i-1] and dp[i-1][j - tanks[i-1]]: dp[i][j] = True if not dp[n][fuel_required]: return None selection = [] i, j = n, fuel_required while i > 0 and j > 0: if dp[i][j] and not dp[i-1][j]: selection.append(tanks[i-1]) j -= tanks[i-1] i -= 1 return selection[::-1] for mission in missions: fuel_required, num_tanks, tanks = mission result = find_subset_tanks(fuel_required, tanks) if result is not None: results.append((\\"YES\\", result)) else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def max_rectangle_area(heights: List[int]) -> int: Determine the maximum possible rectangular area that can be formed by choosing a contiguous subarray of buildings. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The maximum rectangular area. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([1, 2, 3, 4]) 6 >>> max_rectangle_area([1, 1, 1, 1]) 4 pass def process_input(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process the test cases and return results for each. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of buildings and the list of building heights. Returns: List[int]: List of maximum rectangular area for each test case. >>> process_input([(6, [2, 1, 5, 6, 2, 3]), (4, [1, 2, 3, 4])]) [10, 6] >>> process_input([(4, [1, 1, 1, 1]), (4, [2, 4, 2, 1])]) [4, 6] >>> process_input([(1, [5]), (2, [2, 3])]) [5, 4] pass","solution":"def max_rectangle_area(heights): Determine the maximum possible rectangular area that can be formed by choosing a contiguous subarray of buildings. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_input(test_cases): Process the test cases and return results for each. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of buildings and the list of building heights. Returns: List[int]: List of maximum rectangular area for each test case. results = [] for _, heights in test_cases: results.append(max_rectangle_area(heights)) return results"},{"question":"def is_valid_parentheses(s: str) -> bool: Returns True if the input string of parentheses is valid, False otherwise. A string of parentheses is valid if every opening parenthesis has a corresponding closing parenthesis and the pairs of parentheses are properly nested. >>> is_valid_parentheses(\\"()\\") == True >>> is_valid_parentheses(\\"()[]{}\\") == True >>> is_valid_parentheses(\\"([{}])\\") == True >>> is_valid_parentheses(\\"(]\\") == False >>> is_valid_parentheses(\\"([)]\\") == False >>> is_valid_parentheses(\\"((()()\\") == False","solution":"def is_valid_parentheses(s): Returns True if the input string of parentheses is valid, False otherwise. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or stack.pop() != matching_parentheses[char]: return False else: return False return stack == []"},{"question":"from typing import List, Union def reorder_list(lst: List[int], k: int) -> Union[str, str]: Determine if it is possible to reorder the list so that each element at index i (0-based) is not equal to i % k. If it is possible, return \\"Yes\\" and the reordered list, else return \\"No Solution\\". >>> reorder_list([1, 2, 3, 4, 5], 3) \\"Yesn2 3 1 5 4\\" >>> reorder_list([1, 1, 1, 1], 1) \\"No Solution\\"","solution":"def reorder_list(lst, k): lst_len = len(lst) if k == 1 and lst_len > 1: # If k == 1 and list has more than one item, it's impossible to meet the condition return \\"No Solution\\" # Sort the list to easily compare elements lst_sorted = sorted(lst) # Try to create a valid reordering for i in range(lst_len): if lst_sorted[i] == i % k: # Swap with the next element if possible if i + 1 < lst_len and lst_sorted[i + 1] != (i % k): lst_sorted[i], lst_sorted[i + 1] = lst_sorted[i + 1], lst_sorted[i] # Swap with the previous element if possible elif i - 1 >= 0 and lst_sorted[i - 1] != (i % k): lst_sorted[i], lst_sorted[i - 1] = lst_sorted[i - 1], lst_sorted[i] else: return \\"No Solution\\" return f\\"Yesn{' '.join(map(str, lst_sorted))}\\""},{"question":"def specialReverse(N: int, K: int, A: List[int]) -> List[int]: Reverse the array from 0 to K-1 and then reverse the array from K to N-1. Finally, reverse the whole array of size N. >>> specialReverse(5, 3, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> specialReverse(7, 4, [1, 2, 3, 4, 5, 6, 7]) [5, 6, 7, 1, 2, 3, 4] >>> specialReverse(4, 4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> specialReverse(1, 1, [1]) [1] >>> specialReverse(5, 1, [1, 2, 3, 4, 5]) [2, 3, 4, 5, 1]","solution":"def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def specialReverse(N, K, A): Reverse the array from 0 to K-1 and then reverse the array from K to N-1. Finally, reverse the whole array of size N. # Reverse the array from 0 to K-1 reverse(A, 0, K-1) # Reverse the array from K to N-1 reverse(A, K, N-1) # Reverse the whole array of size N reverse(A, 0, N-1) return A # Return the array to verify the result in unit tests"},{"question":"def repeatedSubstringPattern(s: str) -> bool: Checks if the string s can be constructed by taking a substring of it and appending multiple copies of the substring together. Constraints: 1 ≤ s.length ≤ 10^4 Args: s (str): Input string Returns: bool: True if the string can be constructed this way, otherwise False Examples: >>> repeatedSubstringPattern(\\"abab\\") True >>> repeatedSubstringPattern(\\"aba\\") False","solution":"def repeatedSubstringPattern(s: str) -> bool: Checks if the string s can be constructed by taking a substring of it and appending multiple copies of the substring together. if not s: return False # Create a new string by concatenating s with itself ss = (s + s)[1:-1] # Remove the first and last character of the concatenated string return s in ss # Check if s exists in the modified concatenated string"},{"question":"def maximizePlants(n: int, m: int, garden: List[List[int]]) -> Tuple[int, int]: Calculate the maximum number of plants in the garden following the rules and the minimum number of removals required. Args: n : int : the number of rows in the garden m : int : the number of columns in the garden garden : List[List[int]] : a 2D array representing the initial state of the garden Returns: Tuple[int, int] : a tuple containing the maximum number of plants and the number of removals needed >>> maximizePlants(3, 4, [[1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]) (3, 1) >>> maximizePlants(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) (0, 0) >>> maximizePlants(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) (1, 0) >>> maximizePlants(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) (3, 6) >>> maximizePlants(4, 4, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) (4, 0)","solution":"def maximizePlants(n, m, garden): max_plants = min(n, m) row_has_plant = [False] * n col_has_plant = [False] * m initial_plants = 0 # Count initial plants and mark rows and columns that have plants for i in range(n): for j in range(m): if garden[i][j] == 1: initial_plants += 1 row_has_plant[i] = True col_has_plant[j] = True rows_with_plants = sum(row_has_plant) cols_with_plants = sum(col_has_plant) # Maximum plants that can be placed is limited by the smaller dimension total actual_max_plants = min(rows_with_plants, cols_with_plants) # Calculating removals needed to achieve this number of plants removals = initial_plants - actual_max_plants return actual_max_plants, removals"},{"question":"def findWinners(n: int, scores: List[int]) -> List[int]: Determines the winner(s) with the highest score and returns the score in ascending order. Parameters: n (int): the number of players scores (list of int): an array of integers representing each player's score Returns: list of int: a list of integers of the highest score(s) in ascending order >>> findWinners(5, [4, 8, 8, 5, 8]) [8, 8, 8] >>> findWinners(4, [1, 1, 1, 1]) [1, 1, 1, 1] >>> findWinners(1, [10]) [10] >>> findWinners(2, [7, 7]) [7, 7] >>> findWinners(5, [2, 3, 4, 4, 3]) [4, 4] >>> findWinners(6, [3, 4, 2, 4, 3, 1]) [4, 4] >>> findWinners(6, [1, 1, 1, 1, 1, 5]) [5] >>> findWinners(6, [5, 1, 1, 1, 1, 1]) [5] pass","solution":"def findWinners(n, scores): Determines the winner(s) with the highest score and returns the score in ascending order. Parameters: n (int): the number of players scores (list of int): an array of integers representing each player's score Returns: list of int: a list of integers of the highest score(s) in ascending order max_score = max(scores) return [max_score] * scores.count(max_score)"},{"question":"def sequence_length(x: int) -> int: Returns the length of the sequence starting from x and ending when it reaches 1. >>> sequence_length(6) 9 >>> sequence_length(3) 8 >>> sequence_length(1) 1 >>> sequence_length(1000000) 153 >>> sequence_length(16) 5 >>> sequence_length(7) 17","solution":"def sequence_length(x): Returns the length of the sequence starting from x and ending when it reaches 1. count = 1 # Start counting from the initial number itself while x != 1: if x % 2 == 0: x = x // 2 else: x = 3 * x + 1 count += 1 return count"},{"question":"def find_longest_chain_word(words): Create a function that takes a list of words and returns the longest word in the list that can be constructed by chaining, where each word in the chain starts with the last letter of the previous word. >>> find_longest_chain_word([\\"cat\\", \\"tiger\\", \\"rabbit\\", \\"elephant\\", \\"raccoon\\", \\"dog\\"]) 'elephant' >>> find_longest_chain_word([\\"dog\\", \\"giraffe\\", \\"elephant\\", \\"mouse\\"]) 'elephant' >>> find_longest_chain_word([\\"apple\\", \\"banana\\", \\"carrot\\"]) 'banana'","solution":"def find_longest_chain_word(words): Function to find the longest word that can be constructed by chaining. # Create a dictionary to map the words by their starting letter word_map = {} for word in words: start_letter = word[0] if start_letter not in word_map: word_map[start_letter] = [] word_map[start_letter].append(word) def dfs(word, visited): max_chain = word if word[-1] in word_map: for next_word in word_map[word[-1]]: if next_word not in visited: visited.add(next_word) current_chain = dfs(next_word, visited) if len(current_chain) > len(max_chain): max_chain = current_chain visited.remove(next_word) return max_chain longest_word = \\"\\" for word in words: word_chain = dfs(word, set()) if len(word_chain) > len(longest_word): longest_word = word_chain return longest_word"},{"question":"from typing import List def min_moves_to_origin(n: int, moves: str) -> int: This function calculates the minimum number of moves required to return the robot to the origin after it completes the given sequence of moves. Args: n (int): number of moves moves (str): sequence of moves consisting of 'U', 'D', 'L', 'R' Returns: int: minimum number of moves to return to origin Examples: >>> min_moves_to_origin(6, \\"UUDDLR\\") 0 >>> min_moves_to_origin(10, \\"UUUULLLLLL\\") 10 >>> min_moves_to_origin(4, \\"LDRR\\") 2","solution":"def min_moves_to_origin(n, moves): This function calculates the minimum number of moves required to return the robot to the origin after it completes the given sequence of moves. x, y = 0, 0 # starting at the origin (0, 0) for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 # The minimum moves required to return to the origin will be the sum of absolute values of x and y. return abs(x) + abs(y)"},{"question":"def min_subarray_length(nums, S): Given a sequence of integers and a target integer S, this function returns the length of the shortest subarray with sum greater than or equal to S. If no such subarray exists, it returns 0. Parameters: nums (List[int]): The sequence of integers. S (int): The target integer. Returns: int: The length of the shortest subarray with sum >= S, or 0 if no such subarray exists. Examples: >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_length([7], 7) 1 >>> min_subarray_length([1,1,1,1,1,1,1,1], 8) 8 >>> min_subarray_length([1, 4, 4], 6) 2 # Your code here","solution":"def min_subarray_length(nums, S): Given a sequence of integers and a target integer S, this function returns the length of the shortest subarray with sum greater than or equal to S. If no such subarray exists, it returns 0. n = len(nums) left = 0 curr_sum = 0 min_length = n + 1 for right in range(n): curr_sum += nums[right] while curr_sum >= S: min_length = min(min_length, right - left + 1) curr_sum -= nums[left] left += 1 return min_length if min_length <= n else 0"},{"question":"def count_visible_students(n: int, heights: List[int]) -> int: Determines the number of students that are visible from the front. >>> count_visible_students(6, [1, 2, 3, 2, 1, 4]) 4 >>> count_visible_students(1, [5]) 1 >>> count_visible_students(4, [1, 2, 3, 4]) 4 >>> count_visible_students(4, [4, 3, 2, 1]) 1 >>> count_visible_students(3, [5, 5, 5]) 1","solution":"def count_visible_students(n, heights): if n == 0: return 0 max_height = heights[0] visible_count = 1 # The first student is always visible for i in range(1, n): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"def sort_and_repeat(lst): Sorts the given list of integers in non-decreasing order and returns a string with each element repeated a number equal to its 1-based index in the sorted list. >>> sort_and_repeat([4, 2, 1, 3]) \\"1 2 2 3 3 3 4 4 4 4\\" >>> sort_and_repeat([5, 1, 4, 2, 3]) \\"1 2 2 3 3 3 4 4 4 4 5 5 5 5 5\\" >>> sort_and_repeat([]) \\"\\" >>> sort_and_repeat([8]) \\"8\\" >>> sort_and_repeat([3, 3, 3]) \\"3 3 3 3 3 3\\" >>> sort_and_repeat([-1, -3, -2]) \\"-3 -2 -2 -1 -1 -1\\" >>> sort_and_repeat([3, -1, 2, -2, 0]) \\"-2 -1 -1 0 0 0 2 2 2 2 3 3 3 3 3\\"","solution":"def sort_and_repeat(lst): Sorts the given list of integers in non-decreasing order and returns a string with each element repeated a number equal to its 1-based index in the sorted list. sorted_list = sorted(lst) result = [] for index, value in enumerate(sorted_list): result.extend([value] * (index + 1)) return \\" \\".join(map(str, result))"},{"question":"def maxReservations(N: int, reservations: List[List[int]]) -> int: Determines the maximum number of non-overlapping reservations. Args: N : int : The number of reservation requests. reservations : List[List[int]] : A 2D list where each element is a list representing the start and end time of a reservation. Returns: int : The maximum number of non-overlapping reservations. >>> maxReservations(3, [[1, 4], [2, 5], [3, 6]]) 1 >>> maxReservations(4, [[1, 2], [2, 3], [3, 4], [4, 5]]) 4","solution":"def maxReservations(N, reservations): Determines the maximum number of non-overlapping reservations. Args: N : int : The number of reservation requests. reservations : List[List[int]] : A 2D list where each element is a list representing the start and end time of a reservation. Returns: int : The maximum number of non-overlapping reservations. if not reservations: return 0 # Sort the reservations based on the end time to apply the greedy approach reservations.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping reservations and the end time of the last added reservation count = 0 last_end_time = 0 # Iterate through the sorted reservations for start, end in reservations: if start >= last_end_time: # If the current reservation starts after the last one ends, include it count += 1 last_end_time = end return count"},{"question":"def max_sum_subsequence(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Computes the maximum possible sum of any subsequence of length k. Args: t (int): Number of test cases. test_cases (list): A list where each element is a tuple containing: - n (int): Number of elements in array. - k (int): Length of subsequence to consider. - arr (list of int): The array of integers. Returns: list: A list containing the maximum sum of subsequence of length k for each test case. >>> max_sum_subsequence(3, [(5, 3, [1, 2, 3, 4, 5]), (6, 2, [-5, -1, 3, 1, 2, 9]), (4, 4, [-10, -5, -1, 0])]) [12, 12, -16]","solution":"def max_sum_subsequence(t, test_cases): Computes the maximum possible sum of any subsequence of length k. Args: t (int): Number of test cases. test_cases (list): A list where each element is a tuple containing: - n (int): Number of elements in array. - k (int): Length of subsequence to consider. - arr (list of int): The array of integers. Returns: list: A list containing the maximum sum of subsequence of length k for each test case. results = [] for i in range(t): n, k, arr = test_cases[i] # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Compute the sum of the first \`k\` elements max_sum = sum(sorted_arr[:k]) results.append(max_sum) return results"},{"question":"def most_frequent_product_in_windows(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the product ID that is most frequently ordered within each given time window. Args: T (int): The number of test cases. test_cases (List[Dict[str, Any]]): A list of dictionaries, each containing the number of orders (N), the number of queries (Q), the list of products, and the list of queries. Returns: List[int]: The list of most frequently ordered product IDs for each query. >>> most_frequent_product_in_windows(2, [ ... {'N': 10, 'Q': 3, 'products': [1, 1, 2, 2, 3, 3, 4, 4, 4, 4], 'queries': [(1, 5), (2, 8), (4, 10)]}, ... {'N': 7, 'Q': 2, 'products': [1, 2, 2, 3, 3, 3, 1], 'queries': [(2, 5), (1, 7)]} ... ]) == [1, 2, 4, 2, 3] >>> most_frequent_product_in_windows(1, [ ... {'N': 5, 'Q': 2, 'products': [1, 2, 3, 2, 1], 'queries': [(1, 3), (2, 4)]} ... ]) == [1, 2] >>> most_frequent_product_in_windows(1, [ ... {'N': 6, 'Q': 1, 'products': [4, 4, 4, 4, 4, 4], 'queries': [(1, 6)]} ... ]) == [4] >>> most_frequent_product_in_windows(1, [ ... {'N': 7, 'Q': 1, 'products': [1, 2, 3, 1, 2, 3, 1], 'queries': [(1, 7)]} ... ]) == [1]","solution":"def most_frequent_product_in_windows(T, test_cases): results = [] for case in test_cases: N, Q = case['N'], case['Q'] products = case['products'] queries = case['queries'] for L, R in queries: window = products[L-1:R] frequency = {} for product in window: if product not in frequency: frequency[product] = 0 frequency[product] += 1 max_frequency = max(frequency.values()) most_frequent_product = min([product for product, count in frequency.items() if count == max_frequency]) results.append(most_frequent_product) return results"},{"question":"class Library: A class to manage book loans and returns in a library. Methods: - loan_book(book_id: int) -> bool - return_book(book_id: int) -> bool - is_available(book_id: int) -> bool >>> library = Library() >>> library.loan_book(1) True >>> library.is_available(1) False >>> library.loan_book(1) False >>> library.return_book(1) True >>> library.is_available(1) True >>> library.return_book(1) False def __init__(self): # Initializes the library system with no books loaned out pass def loan_book(self, book_id: int) -> bool: Loans out the book with the given book_id. Args: book_id (int): The unique identifier of the book to be loaned out. Returns: bool: True if the book was successfully loaned out, False if it was already loaned out. pass def return_book(self, book_id: int) -> bool: Returns the book with the given book_id. Args: book_id (int): The unique identifier of the book to be returned. Returns: bool: True if the book was successfully returned, False if it was not loaned out. pass def is_available(self, book_id: int) -> bool: Checks if the book with the given book_id is available. Args: book_id (int): The unique identifier of the book to check availability. Returns: bool: True if the book is available, False if it is loaned out. pass Unit Test: from solution import Library def test_loan_book(): library = Library() assert library.loan_book(1) == True assert library.loan_book(1) == False def test_return_book(): library = Library() library.loan_book(1) assert library.return_book(1) == True assert library.return_book(1) == False def test_is_available(): library = Library() assert library.is_available(1) == True library.loan_book(1) assert library.is_available(1) == False library.return_book(1) assert library.is_available(1) == True","solution":"class Library: def __init__(self): self.loaned_books = set() def loan_book(self, book_id: int) -> bool: if book_id in self.loaned_books: return False self.loaned_books.add(book_id) return True def return_book(self, book_id: int) -> bool: if book_id not in self.loaned_books: return False self.loaned_books.remove(book_id) return True def is_available(self, book_id: int) -> bool: return book_id not in self.loaned_books"},{"question":"from typing import List, Tuple def shortest_path_with_obstacles(N: int, M: int, S_x: int, S_y: int, D_x: int, D_y: int, K: int, obstacles: List[Tuple[int, int]]) -> int: Calculate the shortest walking path from a given start intersection to a given destination intersection, avoiding any obstacles in a city grid. Parameters: N (int): Number of horizontal streets in the city grid. M (int): Number of vertical avenues in the city grid. S_x (int), S_y (int): Coordinates of the start intersection. D_x (int), D_y (int): Coordinates of the destination intersection. K (int): Number of obstacles on the grid. obstacles (List[Tuple[int, int]]): List of coordinates representing obstacle intersections. Returns: int: The length of the shortest path from the start to the destination, or -1 if no path exists. >>> shortest_path_with_obstacles(5, 5, 0, 0, 4, 4, 3, [(1, 1), (2, 2), (3, 3)]) 8 >>> shortest_path_with_obstacles(5, 5, 0, 0, 4, 4, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (0, 1)]) -1 pass def test_shortest_path_with_obstacles(): assert shortest_path_with_obstacles(5, 5, 0, 0, 4, 4, 3, [(1, 1), (2, 2), (3, 3)]) == 8 assert shortest_path_with_obstacles(5, 5, 0, 0, 4, 4, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (0, 1)]) == -1 assert shortest_path_with_obstacles(3, 3, 0, 0, 2, 2, 0, []) == 4 # No obstacles assert shortest_path_with_obstacles(3, 3, 0, 0, 2, 2, 1, [(1, 1)]) == 4 assert shortest_path_with_obstacles(3, 3, 0, 0, 0, 0, 0, []) == 0 # Start is destination assert shortest_path_with_obstacles(3, 3, 0, 0, 2, 2, 1, [(2, 2)]) == -1 # Destination blocked assert shortest_path_with_obstacles(3, 3, 0, 0, 2, 2, 1, [(0, 0)]) == -1 # Start blocked","solution":"from collections import deque def shortest_path_with_obstacles(N, M, S_x, S_y, D_x, D_y, K, obstacles): obstacles_set = set((x, y) for x, y in obstacles) if (S_x, S_y) in obstacles_set or (D_x, D_y) in obstacles_set: return -1 directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(S_x, S_y, 0)]) visited = set([(S_x, S_y)]) while queue: x, y, dist = queue.popleft() if (x, y) == (D_x, D_y): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and (nx, ny) not in obstacles_set: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def can_form_palindrome(T: int, test_cases: List[str]) -> List[str]: Given a number of test cases and a list of strings, determine whether each string can be rearranged to form a palindrome. >>> can_form_palindrome(2, [\\"aab\\", \\"code\\"]) [\\"YES\\", \\"NO\\"] >>> can_form_palindrome(1, [\\"a\\"]) [\\"YES\\"] >>> can_form_palindrome(1, [\\"aabb\\"]) [\\"YES\\"] >>> can_form_palindrome(1, [\\"aaabb\\"]) [\\"YES\\"] >>> can_form_palindrome(1, [\\"abcd\\"]) [\\"NO\\"] >>> can_form_palindrome(1, [\\"aabb!@#!@#\\"]) [\\"YES\\"] >>> T = 1 >>> test_string = \\"a\\" * 50000 + \\"b\\" * 50000 >>> can_form_palindrome(T, [test_string]) [\\"YES\\"] >>> T = 1 >>> test_string = \\"a\\" * 50000 + \\"b\\" * 49999 + \\"c\\" >>> can_form_palindrome(T, [test_string]) [\\"NO\\"]","solution":"def can_form_palindrome(T, test_cases): def can_be_palindrome(s): from collections import Counter count = Counter(s) odd_counts = 0 for letter in count: if count[letter] % 2 != 0: odd_counts += 1 # For a string to be rearranged into a palindrome # There must be at most one character with an odd count return odd_counts <= 1 results = [] for case in test_cases: if can_be_palindrome(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_min_vertex_cut_set(N, M, edges): Given an undirected connected graph G with N vertices and M edges, determine if there is a set of vertices S that can be removed such that the remaining graph G' is acyclic (i.e., it becomes a forest). The set S should be of minimum size possible. If there are multiple sets of the same size, print any one of them. Args: N (int): number of vertices M (int): number of edges edges (list of tuples): list of edges in the graph Returns: tuple: (size of the set, list of vertices in the set) Example: >>> find_min_vertex_cut_set(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) (1, [3]) >>> find_min_vertex_cut_set(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)]) (1, [1]) >>> find_min_vertex_cut_set(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (3, 6)]) (1, [6]) pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [(int(data[2 + 2 * i]), int(data[2 + 2 * i + 1])) for i in range(M)] result = find_min_vertex_cut_set(N, M, edges) print(result[0]) for v in result[1]: print(v)","solution":"def find_min_vertex_cut_set(N, M, edges): Determine a minimum set of vertices whose removal makes the graph acyclic. Args: N : int : number of vertices M : int : number of edges edges : list of tuples : edges of the graph Returns: tuple : (size of the set, list of vertices in the set) from networkx import Graph import networkx as nx G = Graph() G.add_nodes_from(range(1, N + 1)) G.add_edges_from(edges) def is_acyclic(G): try: nx.find_cycle(G) return False except nx.NetworkXNoCycle: return True # Find a cycle if there is one cycle = None try: cycle = nx.find_cycle(G) except nx.NetworkXNoCycle: cycle = [] if not cycle: return (0, []) # Convert the cycle into a set of vertices cycle_vertices = set() for u, v in cycle: cycle_vertices.add(u) cycle_vertices.add(v) # Removing any single vertex in the cycle should break the cycle vertex_to_remove = cycle_vertices.pop() return (1, [vertex_to_remove]) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [(int(data[2 + 2 * i]), int(data[2 + 2 * i + 1])) for i in range(M)] result = find_min_vertex_cut_set(N, M, edges) print(result[0]) for v in result[1]: print(v)"},{"question":"def can_construct_word(letters: str, word: str) -> str: Determines if 'word' can be constructed using the 'letters'. Each letter can be used only once. Args: letters (str): A string of available letters. word (str): The word to be constructed. Returns: str: \\"YES\\" if the word can be constructed, \\"NO\\" otherwise. >>> can_construct_word(\\"aabcd\\", \\"bac\\") == \\"YES\\" >>> can_construct_word(\\"abc\\", \\"ppq\\") == \\"NO\\" >>> can_construct_word(\\"aabbcc\\", \\"abc\\") == \\"YES\\"","solution":"def can_construct_word(letters, word): Determines if 'word' can be constructed using the 'letters'. Each letter can be used only once. Args: letters (str): A string of available letters. word (str): The word to be constructed. Returns: str: \\"YES\\" if the word can be constructed, \\"NO\\" otherwise. from collections import Counter letter_count = Counter(letters) word_count = Counter(word) for char in word_count: if word_count[char] > letter_count[char]: return \\"NO\\" return \\"YES\\""},{"question":"def shortest_path(n: int, m: int, grid: List[List[str]]) -> int: Finds the length of the shortest path in a grid from top-left to bottom-right, moving only on roads represented by '.' character. >>> n, m = 5, 5 >>> grid = [ ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"#\\", \\"#\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"#\\", \\".\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"] ... ] >>> shortest_path(n, m, grid) 8 >>> n, m = 3, 3 >>> grid = [ ... [\\".\\", \\"#\\", \\".\\"], ... [\\"#\\", \\"#\\", \\"#\\"], ... [\\".\\", \\".\\", \\".\\"] ... ] >>> shortest_path(n, m, grid) -1 >>> n, m = 3, 3 >>> grid = [[\\"#\\", \\".\\", \\".\\"], [\\".\\", \\"#\\", \\".\\"], [\\".\\", \\".\\", \\".\\"]] >>> shortest_path(n, m, grid) -1 >>> n, m = 1, 1 >>> grid = [[\\".\\"]] >>> shortest_path(n, m, grid) 0 >>> n, m = 3, 3 >>> grid = [[\\".\\", \\".\\", \\".\\"],[\\".\\", \\".\\", \\".\\"],[\\".\\", \\".\\", \\".\\"]] >>> shortest_path(n, m, grid) 4 # Implementation here","solution":"from collections import deque def shortest_path(n, m, grid): Finds the shortest path in a grid from top-left to bottom-right, moving only on roads represented by '.' character. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # Function to convert input format into variable def main(): n, m = map(int, input().split()) grid = [input().strip().split() for _ in range(n)] result = shortest_path(n, m, grid) print(result)"},{"question":"def check_password_strength(password: str) -> str: Checks if the given password is strong based on the criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit Parameters: password (str): The password to check Returns: str: \\"strong\\" if the password meets the criteria, otherwise \\"weak\\" >>> check_password_strength(\\"aB1defgh\\") \\"strong\\" >>> check_password_strength(\\"Abcd1234\\") \\"strong\\" >>> check_password_strength(\\"abcD12\\") \\"weak\\" >>> check_password_strength(\\"a1B2c3D4\\") \\"strong\\"","solution":"def check_password_strength(password): Checks if the given password is strong based on the criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit Parameters: password (str): The password to check Returns: str: \\"strong\\" if the password meets the criteria, otherwise \\"weak\\" if len(password) < 8: return \\"weak\\" has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) if has_lower and has_upper and has_digit: return \\"strong\\" else: return \\"weak\\""},{"question":"def number_of_paths(grid): Calculate the number of different paths from top-left to bottom-right of a grid. :param grid: A list of strings representing the grid. :return: The number of different paths. >>> number_of_paths([ ... '...', ... '.#.', ... '...']) == 2 >>> number_of_paths([ ... '.#', ... '#.']) == 0 >>> number_of_paths([ ... '....', ... '....', ... '....']) == 10 >>> number_of_paths([ ... '...', ... '..#', ... '...']) == 3 >>> number_of_paths([ ... '#...', ... '....', ... '....', ... '....']) == 0","solution":"def number_of_paths(grid): Calculate the number of different paths from top-left to bottom-right of a grid. :param grid: A list of strings representing the grid. :return: The number of different paths. N = len(grid) M = len(grid[0]) if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 # Initialize a 2D DP array with zeros dp = [[0] * M for _ in range(N)] # Starting position dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1] def read_input_and_solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] for i in range(2, 2 + N): grid.append(data[i]) return number_of_paths(grid)"},{"question":"def rearrange_queue(heights: List[int]) -> Union[List[int], str]: Function to rearrange the heights of people in a queue to satisfy the given conditions. Args: - heights: List of integers representing the heights of people in the queue. Returns: - List of integers with the rearranged queue or the string \\"IMPOSSIBLE\\" if no valid rearrangement exists. >>> rearrange_queue([4, 2, 7, 6]) [2, 4, 6, 7] >>> rearrange_queue([1, 3, 2]) [1, 2, 3] >>> rearrange_queue([5, 3, 1, 4, 2]) [1, 2, 3, 4, 5] >>> rearrange_queue([1, 1, 1, 1]) IMPOSSIBLE >>> rearrange_queue([100, 99]) [99, 100] pass def solve_photograph_patterns(test_cases: List[List[int]]) -> List[str]: Function to process multiple test cases to solve the photograph arrangement problem. Args: - test_cases: List of lists of integers, where each list represents a test case of heights. Returns: - List of strings, each representing the rearranged queue for a test case or \\"IMPOSSIBLE\\" if no valid rearrangement exists. >>> solve_photograph_patterns([[4, 2, 7, 6], [1, 3, 2], [5, 3, 1, 4, 2]]) [\\"2 4 6 7\\", \\"1 2 3\\", \\"1 2 3 4 5\\"] >>> solve_photograph_patterns([[1, 1, 1, 1]]) [\\"IMPOSSIBLE\\"] >>> solve_photograph_patterns([[100, 99]]) [\\"99 100\\"] pass","solution":"def rearrange_queue(heights): Function to rearrange the heights of people in a queue to satisfy the given conditions. Args: - heights: List of integers representing the heights of people in the queue. Returns: - List of integers with the rearranged queue or the string \\"IMPOSSIBLE\\" if no valid rearrangement exists. n = len(heights) # If there are only two people, they can always be swapped. if n == 2: return heights # Sort heights to simplify the process of finding a valid arrangement heights.sort() for i in range(1, n-1): # Check the given conditions if not (heights[i-1] < heights[i] or heights[i] < heights[i+1]): return \\"IMPOSSIBLE\\" return heights def solve_photograph_patterns(test_cases): results = [] for heights in test_cases: result = rearrange_queue(heights) if result == \\"IMPOSSIBLE\\": results.append(result) else: results.append(\\" \\".join(map(str, result))) return results"},{"question":"def sum_of_elements(n: int, isEven: bool) -> int: Given an integer n and a boolean isEven, create an array nums of length n where nums[i] is the ith positive even number if isEven is true, otherwise nums[i] is the ith positive odd number. Return the sum of all elements in the nums array. >>> sum_of_elements(4, True) 20 >>> sum_of_elements(3, False) 9 >>> sum_of_elements(5, True) 30 >>> sum_of_elements(2, False) 4","solution":"def sum_of_elements(n, isEven): Returns the sum of the first n positive even or odd numbers based on the value of isEven. if isEven: nums = [2 * i for i in range(1, n + 1)] else: nums = [2 * i + 1 for i in range(n)] return sum(nums)"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the string \`s\`. >>> length_of_shortest_word(\\"the quick brown fox\\") == 3 >>> length_of_shortest_word(\\"hello world\\") == 5 >>> length_of_shortest_word(\\"a journey of a thousand miles begins with a single step\\") == 1 >>> length_of_shortest_word(\\"simple and effective\\") == 3 >>> length_of_shortest_word(\\"pneumonoultramicroscopicsilicovolcanoconiosis\\") == 45","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the string \`s\`. words = s.split() return min(len(word) for word in words)"},{"question":"def find_partition_point(arr): For a given array of integers, find its partition point. The partition point is defined as an index \`k\` (0-based) such that the sum of the elements to the left of \`k\` is equal to the sum of the elements to the right of \`k\`. >>> find_partition_point([1, 2, 3, 4, 6]) 3 >>> find_partition_point([1, 1, 1, 2]) 2 >>> find_partition_point([2, 3, 4, 1, 4, 5]) 3 >>> find_partition_point([1, 2]) -1 >>> find_partition_point([1, 3, 2, 1, 1]) -1 >>> find_partition_point([1, 1, 1, 1, 1, 5, 5]) 5 def process_test_cases(test_cases): For processing multiple test cases of finding partition points. >>> process_test_cases([(5, [1, 2, 3, 4, 6]), (4, [1, 1, 1, 2])]) [3, 2] >>> process_test_cases([(2, [1, 2]), (6, [2, 3, 4, 1, 4, 5])]) [-1, 3]","solution":"def find_partition_point(arr): total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): total_sum -= num if left_sum == total_sum: return i left_sum += num return -1 def process_test_cases(test_cases): results = [] for case in test_cases: _, arr = case results.append(find_partition_point(arr)) return results"},{"question":"def can_split_array(ar, k): Determines if the array can be split into two non-empty subarrays such that the sum of the elements in both subarrays is divisible by k. >>> can_split_array([5, 10, 15, 20], 10) \\"YES\\" >>> can_split_array([2, 6, 4], 5) \\"NO\\"","solution":"def can_split_array(ar, k): Determines if the array can be split into two non-empty subarrays such that the sum of the elements in both subarrays is divisible by k. n = len(ar) if n < 2: return \\"NO\\" # Calculate the prefix sums prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i+1] = prefix_sums[i] + ar[i] total_sum = prefix_sums[-1] # Check for possible splits for i in range(1, n): sum1 = prefix_sums[i] # Sum of the first subarray sum2 = total_sum - sum1 # Sum of the second subarray if sum1 % k == 0 and sum2 % k == 0: return \\"YES\\" return \\"NO\\""},{"question":"def is_lucky_palindromic_number(n: int, number: int) -> str: Determines if a given number is a lucky palindromic number. A lucky palindromic number is a number that is palindromic and contains only the digits 3 and 8. Parameters: n (int): Length of the number. number (int): The number to be checked. Returns: str: \\"YES\\" if the number is a lucky palindromic number, otherwise \\"NO\\". >>> is_lucky_palindromic_number(3, 838) \\"YES\\" >>> is_lucky_palindromic_number(4, 8448) \\"NO\\" >>> is_lucky_palindromic_number(6, 888383) \\"NO\\" >>> is_lucky_palindromic_number(1, 3) \\"YES\\" >>> is_lucky_palindromic_number(1, 1) \\"NO\\"","solution":"def is_lucky_palindromic_number(n, number): Determines if a given number is a lucky palindromic number. A lucky palindromic number is a number that is palindromic and contains only the digits 3 and 8. Parameters: n (int): Length of the number. number (int): The number to be checked. Returns: str: \\"YES\\" if the number is a lucky palindromic number, otherwise \\"NO\\". num_str = str(number) if num_str != num_str[::-1]: return \\"NO\\" for digit in num_str: if digit not in {'3', '8'}: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def highest_product(nums: List[int]) -> int: Returns the highest possible product that can be achieved by multiplying exactly three of the integers. >>> highest_product([1, 2, 3, 4, 5]) 60 >>> highest_product([-10, -10, 1, 3, 2, 5]) 500 >>> highest_product([-1, -2, -3, -4, -5]) -6 >>> highest_product([-10, -10, 5, 4, 3, 2]) 500 >>> highest_product([0, 2, 3, 5, 7, -3, -8]) 168 >>> highest_product([2, 3, 4]) 24 >>> highest_product([100, 200, 300, -1, -2, -3]) 6000000","solution":"def highest_product(nums): Returns the highest possible product that can be achieved by multiplying exactly three of the integers. if len(nums) < 3: raise ValueError(\\"The list must contain at least three integers\\") nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def vasya_game(n, a): Optimally plays Vasya's game and returns the sorted array c. Parameters: n (int): The length of the array a. a (list of int): The array of integers to be processed. Returns: list of int: The sorted array c. >>> vasya_game(3, [3, 1, 2]) [1, 2, 3] >>> vasya_game(4, [5, 3, 6, 2]) [2, 3, 5, 6] >>> vasya_game(1, [1]) [1] >>> vasya_game(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> vasya_game(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> vasya_game(4, [2, 2, 2, 2]) [2, 2, 2, 2] >>> vasya_game(5, [1000000000, 999999999, 888888888, 777777777, 666666666]) [666666666, 777777777, 888888888, 999999999, 1000000000] pass","solution":"def vasya_game(n, a): Optimally plays Vasya's game and returns the sorted array c. Parameters: n (int): The length of the array a. a (list of int): The array of integers to be processed. Returns: list of int: The sorted array c. b = [] for num in a: b.append(num) # Now, b has all elements of a in the same order, process to form c c = [] while b: # Always take the last element of b to maintain minimal order in c c.append(b.pop()) c.sort() return c"},{"question":"def clockwise_spiral(n: int) -> List[List[int]]: Returns an n x n matrix filled with numbers from 1 to n^2 in a clockwise spiral pattern. If n <= 0, the function should return an empty list. >>> clockwise_spiral(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> clockwise_spiral(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] >>> clockwise_spiral(0) [] >>> clockwise_spiral(1) [ [1] ] pass","solution":"def clockwise_spiral(n): Returns an n x n matrix filled with numbers from 1 to n^2 in a clockwise spiral pattern. if n <= 0: return [] matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def smallest_range_difference(arr): Find the smallest possible difference R - L such that all elements in arr are within [L, R]. Parameters: arr (List[int]): A list of non-negative integers. Returns: int: The smallest possible difference R - L. Examples: >>> smallest_range_difference([4, 1, 7, 3, 9]) 8 >>> smallest_range_difference([7, 7, 7, 7]) 0 from solution import smallest_range_difference def test_example_case(): assert smallest_range_difference([4, 1, 7, 3, 9]) == 8 def test_empty_array(): assert smallest_range_difference([]) == 0 def test_single_element(): assert smallest_range_difference([5]) == 0 def test_all_elements_same(): assert smallest_range_difference([7, 7, 7, 7]) == 0 def test_ascending_order(): assert smallest_range_difference([1, 2, 3, 4, 5]) == 4 def test_descending_order(): assert smallest_range_difference([9, 7, 5, 3, 1]) == 8 def test_large_numbers(): assert smallest_range_difference([1000000000, 999999999, 1000000001]) == 2 def test_negative_and_positive_numbers(): assert smallest_range_difference([-3, -1, 2, 4]) == 7","solution":"def smallest_range_difference(arr): Returns the smallest possible difference R - L such that all elements in arr are within [L, R]. if not arr: return 0 min_value = min(arr) max_value = max(arr) return max_value - min_value # Example usage: # N = 5 # arr = [4, 1, 7, 3, 9] # print(smallest_range_difference(arr)) # Output: 8"},{"question":"from typing import List, Tuple def subarrayExists(q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[str]: Check if there exists a contiguous subarray whose length is at least m and whose sum is exactly k. Args: q (int): the number of queries A (List[int]): an array of integers queries (List[Tuple[int, int]]): a list of tuples where each tuple contains integers m and k Returns: List[str]: an array of strings, either YES or NO for each query >>> subarrayExists(3, [1, 2, 3, 4, 5], [(2, 9), (3, 6), (2, 12)]) ['YES', 'YES', 'NO'] def test_single_query(): A = [1, 2, 3, 4, 5] queries = [(2, 9)] assert subarrayExists(1, A, queries) == [\\"YES\\"] def test_multiple_queries_yes(): A = [1, 2, 3, 4, 5] queries = [(2, 9), (3, 6)] assert subarrayExists(2, A, queries) == [\\"YES\\", \\"YES\\"] def test_multiple_queries_no_and_yes(): A = [1, 2, 3, 4, 5] queries = [(2, 9), (2, 12)] assert subarrayExists(2, A, queries) == [\\"YES\\", \\"NO\\"] def test_all_yes(): A = [1, 2, 3, 4, 5] queries = [(2, 3), (3, 6)] assert subarrayExists(2, A, queries) == [\\"YES\\", \\"YES\\"] def test_all_no(): A = [1, 2, 3, 4, 5] queries = [(2, 100), (3, 100)] assert subarrayExists(2, A, queries) == [\\"NO\\", \\"NO\\"] def test_no_queries(): A = [1, 2, 3, 4, 5] queries = [] assert subarrayExists(0, A, queries) == [] def test_query_with_negative_numbers(): A = [-1, -2, -3, -4, -5] queries = [(2, -3), (3, -6)] assert subarrayExists(2, A, queries) == [\\"YES\\", \\"YES\\"] def test_large_m_value(): A = [1] * 1000 queries = [(1000, 1000)] assert subarrayExists(1, A, queries) == [\\"YES\\"] def test_large_sum_value(): A = [1] * 1000 queries = [(2, 2000)] assert subarrayExists(1, A, queries) == [\\"NO\\"]","solution":"def subarrayExists(q, A, queries): results = [] n = len(A) for m, k in queries: found = False current_sum = sum(A[:m]) if current_sum == k: results.append(\\"YES\\") continue for i in range(m, n): current_sum += A[i] - A[i - m] if current_sum == k: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def searchMatrix(matrix, X): Determines if the integer X is present in the matrix. Each row is sorted in non-decreasing order from left to right. Each column is sorted in non-decreasing order from top to bottom. :param matrix: List[List[int]] : 2D matrix of integers :param X: int : The integer to search for in the matrix :return: bool : True if X is found in the matrix, False otherwise Example: >>> matrix = [ >>> [1, 3, 5], >>> [2, 6, 8], >>> [4, 7, 9] >>> ] >>> searchMatrix(matrix, 7) True >>> searchMatrix(matrix, 10) False","solution":"def searchMatrix(matrix, X): Determines if the integer X is present in the matrix. Each row is sorted in non-decreasing order from left to right. Each column is sorted in non-decreasing order from top to bottom. :param matrix: List[List[int]] : 2D matrix of integers :param X: int : The integer to search for in the matrix :return: bool : True if X is found in the matrix, False otherwise if not matrix or not matrix[0]: return False N = len(matrix) M = len(matrix[0]) # Start from the top-right corner row = 0 col = M - 1 while row < N and col >= 0: if matrix[row][col] == X: return True elif matrix[row][col] > X: col -= 1 else: row += 1 return False"},{"question":"def make_gift_box(N: int, M: int) -> int: Calculate the number of distinct permutations of chocolates possible to create one gift box of exactly N chocolates using M available types. >>> make_gift_box(1, 1) 1 >>> make_gift_box(3, 3) 6 >>> make_gift_box(2, 3) 6 >>> make_gift_box(3, 5) 60 >>> make_gift_box(4, 3) 0 >>> make_gift_box(5, 10) 30240 >>> make_gift_box(10, 10) 3628800","solution":"MOD = 10**9 + 7 def make_gift_box(N, M): Calculate the number of distinct permutations of chocolates possible to create one gift box of exactly N chocolates using M available types. if N > M: return 0 result = 1 for i in range(M, M-N, -1): result = (result * i) % MOD return result"},{"question":"from typing import List def find_peak_element(nums: List[int]) -> int: Find a peak element and return its index. >>> find_peak_element([1, 2, 3, 1]) in {2} >>> find_peak_element([1, 2, 1, 3, 2]) in {1, 3}","solution":"def find_peak_element(nums): Find a peak element and return its index. n = len(nums) # Early return conditions if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n-1] > nums[n-2]: return n-1 # Binary search for peak element left, right = 0, n-1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def is_path_exist(grid, n, m): Determines if there exists a path from the top-left to the bottom-right corner in a grid with obstacles. >>> is_path_exist([[0, 0, 0], [1, 1, 0], [0, 0, 0]], 3, 3) True >>> is_path_exist([[0, 1, 0], [1, 0, 0], [0, 0, 0]], 3, 3) False def solve(t, test_cases): Determines for multiple test cases whether there exists a path from the top-left to the bottom-right corner of a rectangular grid with obstacles. >>> solve(2, [([[0, 0, 0], [1, 1, 0], [0, 0, 0]], 3, 3), ([[0, 1, 0], [1, 0, 0], [0, 0, 0]], 3, 3)]) [\\"YES\\", \\"NO\\"] >>> solve(1, [([[0, 0], [0, 0]], 2, 2)]) [\\"YES\\"] >>> solve(1, [([[0, 1], [1, 0]], 2, 2)]) [\\"NO\\"] >>> solve(1, [([[0]], 1, 1)]) [\\"YES\\"] >>> solve(1, [([[1]], 1, 1)]) [\\"NO\\"]","solution":"def is_path_exist(grid, n, m): Determines if there exists a path from the top-left to the bottom-right corner in a grid with obstacles. def dfs(x, y, visited): # If out of bounds or on an obstacle, return False if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 1 or visited[x][y]: return False # If we have reached the bottom-right corner, return True if x == n-1 and y == m-1: return True # Mark this cell as visited visited[x][y] = True # Move right or down if dfs(x + 1, y, visited) or dfs(x, y + 1, visited): return True # Backtrack visited[x][y] = False return False visited = [[False for _ in range(m)] for _ in range(n)] return dfs(0, 0, visited) def solve(t, test_cases): results = [] for grid, n, m in test_cases: if is_path_exist(grid, n, m): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_swapped_positions(arr): Function to find the first pair of consecutive swapped elements in a list. Parameters: arr (list): List of integers Returns: tuple: A tuple with two integers representing the 1-based positions of the swapped elements. If no swapped elements found, returns (-1, -1). >>> find_swapped_positions([3, 2, 6, 4, 8]) (1, 2) >>> find_swapped_positions([1, 5, 3, 4, 2, 7]) (2, 3) >>> find_swapped_positions([1, 2, 3, 4]) (-1, -1) >>> find_swapped_positions([3, 1, 2]) (1, 2)","solution":"def find_swapped_positions(arr): Function to find the first pair of consecutive swapped elements in a list. Parameters: arr (list): List of integers Returns: tuple: A tuple with two integers representing the 1-based positions of the swapped elements. If no swapped elements found, returns (-1, -1). for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return (i + 1, i + 2) return (-1, -1)"},{"question":"from typing import List def process_operations(s: str, n: int, operations: List[List[str]]) -> str: Perform a series of operations on the string \`s\`. Each operation is described by a group of three components (op, x, y): - 'R' (reverse) operation: Reverse the substring of \`s\` from index \`x\` to \`y\`, inclusive. - 'C' (concatenate) operation: Concatenate the string \`x\` to the end of the string \`s\`. - 'S' (subset) operation: Check if the string \`x\` is a subset of the string \`y\`. Return the resulting string \`s\` after performing all operations. If a subset operation is performed, return \\"YES\\" or \\"NO\\" accordingly. >>> process_operations(\\"abcde\\", 3, [[\\"R\\", \\"1\\", \\"3\\"], [\\"C\\", \\"xyz\\"], [\\"S\\", \\"xyz\\", \\"deab\\"]]) \\"NO\\" >>> process_operations(\\"hello\\", 2, [[\\"R\\", \\"0\\", \\"4\\"], [\\"C\\", \\"world\\"]]) \\"ollehworld\\" >>> process_operations(\\"abcdef\\", 1, [[\\"R\\", \\"2\\", \\"4\\"]]) \\"abedcf\\" >>> process_operations(\\"test\\", 1, [[\\"C\\", \\"123\\"]]) \\"test123\\" >>> process_operations(\\"abcdef\\", 1, [[\\"S\\", \\"abc\\", \\"bacdef\\"]]) \\"YES\\" >>> process_operations(\\"abcdef\\", 1, [[\\"S\\", \\"xyz\\", \\"abcdef\\"]]) \\"NO\\"","solution":"def manipulate_string(s, operations): result = s for op in operations: if op[0] == 'R': start, end = int(op[1]), int(op[2]) result = result[:start] + result[start:end + 1][::-1] + result[end + 1:] elif op[0] == 'C': concat_str = op[1] result += concat_str elif op[0] == 'S': x, y = op[1], op[2] if all(x.count(char) <= y.count(char) for char in set(x)): return \\"YES\\" else: return \\"NO\\" return result # Function to process the input def process_operations(s, n, operations): return manipulate_string(s, operations)"},{"question":"def max_magical_power(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the maximum magical power Leoric can collect for each test case. :param t: The number of test cases. :param test_cases: A list containing the grid configurations for each test case. :return: A list with the maximum magical power for each test case. >>> max_magical_power(2, [ ... (3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, 2, [ ... [1, 3], ... [2, 4] ... ]) ... ]) == [29, 8] >>> max_magical_power(1, [(1, 1, [[1]])]) == [1] >>> max_magical_power(1, [(100, 100, [[1000] * 100 for _ in range(100)])]) == [199000]","solution":"def max_magical_power(t, test_cases): Calculate the maximum magical power Leoric can collect for each test case. :param t: The number of test cases. :param test_cases: A list containing the grid configurations for each test case. :return: A list with the maximum magical power for each test case. results = [] for case in test_cases: n, m, grid = case dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] results.append(dp[-1][-1]) return results"},{"question":"def summarize_tshirt_requests(n, sizes): Summarizes the t-shirt size requests. Parameters: n (int): Number of participants. sizes (list): List of size requests. Returns: dict: A dictionary with counts of each size. pass def format_size_summary(size_summary): Formats the size summary into the required output format. Parameters: size_summary (dict): A dictionary with counts of each size. Returns: str: A formatted string with counts of each size. pass # Example test cases from solution import summarize_tshirt_requests, format_size_summary def test_summarize_tshirt_requests(): assert summarize_tshirt_requests(5, [\\"M\\", \\"XS\\", \\"S\\", \\"M\\", \\"L\\"]) == { \\"XS\\": 1, \\"S\\": 1, \\"M\\": 2, \\"L\\": 1, \\"XL\\": 0, \\"XXL\\": 0 } assert summarize_tshirt_requests(3, [\\"XXL\\", \\"XL\\", \\"L\\"]) == { \\"XS\\": 0, \\"S\\": 0, \\"M\\": 0, \\"L\\": 1, \\"XL\\": 1, \\"XXL\\": 1 } assert summarize_tshirt_requests(6, [\\"XS\\", \\"XS\\", \\"S\\", \\"S\\", \\"M\\", \\"M\\"]) == { \\"XS\\": 2, \\"S\\": 2, \\"M\\": 2, \\"L\\": 0, \\"XL\\": 0, \\"XXL\\": 0 } def test_format_size_summary(): size_summary = {\\"XS\\": 1, \\"S\\": 1, \\"M\\": 2, \\"L\\": 1, \\"XL\\": 0, \\"XXL\\": 0} formatted_output = format_size_summary(size_summary) expected_output = \\"XS: 1nS: 1nM: 2nL: 1nXL: 0nXXL: 0\\" assert formatted_output == expected_output size_summary = {\\"XS\\": 0, \\"S\\": 2, \\"M\\": 1, \\"L\\": 3, \\"XL\\": 0, \\"XXL\\": 0} formatted_output = format_size_summary(size_summary) expected_output = \\"XS: 0nS: 2nM: 1nL: 3nXL: 0nXXL: 0\\" assert formatted_output == expected_output size_summary = {\\"XS\\": 3, \\"S\\": 0, \\"M\\": 0, \\"L\\": 0, \\"XL\\": 1, \\"XXL\\": 2} formatted_output = format_size_summary(size_summary) expected_output = \\"XS: 3nS: 0nM: 0nL: 0nXL: 1nXXL: 2\\" assert formatted_output == expected_output","solution":"def summarize_tshirt_requests(n, sizes): Summarizes the t-shirt size requests. Parameters: n (int): Number of participants. sizes (list): List of size requests. Returns: dict: A dictionary with counts of each size. size_counts = {\\"XS\\": 0, \\"S\\": 0, \\"M\\": 0, \\"L\\": 0, \\"XL\\": 0, \\"XXL\\": 0} for size in sizes: if size in size_counts: size_counts[size] += 1 return size_counts def format_size_summary(size_summary): Formats the size summary into the required output format. Parameters: size_summary (dict): A dictionary with counts of each size. Returns: str: A formatted string with counts of each size. formatted_output = [] for size in [\\"XS\\", \\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]: formatted_output.append(f\\"{size}: {size_summary[size]}\\") return 'n'.join(formatted_output)"},{"question":"def minOperations(N: int) -> int: Returns the minimum number of operations to reduce N to 1. The allowed operations are: 1. Subtract 1 from N. 2. If N is divisible by 2, divide N by 2. 3. If N is divisible by 3, divide N by 3. Examples: >>> minOperations(10) 3 >>> minOperations(15) 4 Unit Test: def test_minOperations(): assert minOperations(10) == 3 assert minOperations(15) == 4 assert minOperations(1) == 0 assert minOperations(2) == 1 assert minOperations(3) == 1 assert minOperations(4) == 2 assert minOperations(5) == 3 assert minOperations(100) == 7 test_minOperations()","solution":"def minOperations(N): Returns the minimum number of operations to reduce N to 1. if N == 1: return 0 # Initialize a list to store the minimum operations count for each number up to N dp = [float('inf')] * (N + 1) dp[1] = 0 # It takes 0 operations to make 1 from 1 for i in range(2, N + 1): dp[i] = dp[i - 1] + 1 # Subtract 1 operation if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) # Divide by 2 operation if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) # Divide by 3 operation return dp[N]"},{"question":"MOD = 10**9 + 7 def product_exclude_current(arr, queries): You are given an array of integers and a number of queries. Each query consists of a single integer representing an index in the array. For each query, compute the product of all elements in the array except the one at the specified index. Since the result can be very large, return the answer modulo 10^9 + 7. Args: arr: List[int] - The input array of integers queries: List[int] - The list of queries Returns: List[int] - The results for each query Example: >>> product_exclude_current([1, 2, 3, 4, 5, 6], [0, 1, 5]) [720, 360, 120] import pytest from solution import process_input def test_example(): N = 6 Q = 3 array = [1, 2, 3, 4, 5, 6] queries = [0, 1, 5] expected = [720, 360, 120] result = process_input(N, Q, array, queries) assert result == expected def test_with_zero(): N = 5 Q = 2 array = [1, 0, 3, 4, 5] queries = [1, 3] expected = [60, 0] result = process_input(N, Q, array, queries) assert result == expected def test_single_element(): N = 1 Q = 1 array = [1] queries = [0] expected = [1] # By convention, product excluding the single element is 1 result = process_input(N, Q, array, queries) assert result == expected def test_all_ones(): N = 4 Q = 2 array = [1, 1, 1, 1] queries = [1, 2] expected = [1, 1] result = process_input(N, Q, array, queries) assert result == expected def test_large_values(): N = 3 Q = 2 array = [1000, 1000, 1000] queries = [0, 2] expected = [1000000 % MOD, 1000000 % MOD] result = process_input(N, Q, array, queries) assert result == expected","solution":"MOD = 10**9 + 7 def product_exclude_current(arr, queries): Returns an array containing the product of all elements in \`arr\` excluding the element at each index in \`queries\`, modulo 10^9 + 7. n = len(arr) # Compute total product mod MOD total_product = 1 for num in arr: total_product = (total_product * num) % MOD # Collect results for each query results = [] for idx in queries: if arr[idx] == 0: product = 1 for i in range(n): if i != idx: product = (product * arr[i]) % MOD results.append(product) else: product_excluding = (total_product * pow(arr[idx], MOD-2, MOD)) % MOD results.append(product_excluding) return results def process_input(N, Q, array, queries): return product_exclude_current(array, queries)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Function to find the lowest common ancestor of two given nodes in a binary tree. :param TreeNode root: The root of the binary tree. :param TreeNode p: The first node. :param TreeNode q: The second node. :return: The lowest common ancestor of the given nodes. :rtype: TreeNode pass def test_lowest_common_ancestor(): # Construct the tree root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) root.right.left = TreeNode(0) root.right.right = TreeNode(8) p = root.left # Node with value 5 q = root.right # Node with value 1 assert lowest_common_ancestor(root, p, q).val == 3 p = root.left # Node with value 5 q = root.left.right.right # Node with value 4 assert lowest_common_ancestor(root, p, q).val == 5 p = root.left.right.left # Node with value 7 q = root.right.right # Node with value 8 assert lowest_common_ancestor(root, p, q).val == 3 p = root.left.left # Node with value 6 q = root.right.left # Node with value 0 assert lowest_common_ancestor(root, p, q).val == 3 p = root.left.right.left # Node with value 7 q = root.left.right # Node with value 2 assert lowest_common_ancestor(root, p, q).val == 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Function to find the lowest common ancestor of two given nodes in a binary tree. :param TreeNode root: The root of the binary tree. :param TreeNode p: The first node. :param TreeNode q: The second node. :return: The lowest common ancestor of the given nodes. :rtype: TreeNode if root is None or root == p or root == q: return root left_lca = lowest_common_ancestor(root.left, p, q) right_lca = lowest_common_ancestor(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"def has_pair_with_diff(nums: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array nums such that the absolute difference between the elements at these indices is equal to a given number k. :param nums: List[int], array of integers :param k: int, the desired absolute difference :return: bool, True if such a pair exists, False otherwise pass def test_pair_with_diff_exists(): assert has_pair_with_diff([1, 7, 5, 9, 2, 12, 3], 2) == True assert has_pair_with_diff([1, 5, 3, 4, 2], 4) == True assert has_pair_with_diff([1, 11, 19, 21, 7], 10) == True def test_pair_with_diff_not_exists(): assert has_pair_with_diff([1, 2, 3, 4, 5], 5) == False assert has_pair_with_diff([], 1) == False assert has_pair_with_diff([10, 20, 30, 40], 100) == False def test_single_element_array(): assert has_pair_with_diff([5], 3) == False def test_negative_and_zero_difference(): assert has_pair_with_diff([-1, -3, -5, -7], 2) == True assert has_pair_with_diff([0, 5, 10, -5], 5) == True assert has_pair_with_diff([1, 1, 1, 1], 0) == True def test_no_diff(): assert has_pair_with_diff([1, 2, 3, 4, 5], 0) == True # This actually finds (3, 3) pair, and 0 diff","solution":"def has_pair_with_diff(nums, k): Determines if there are two distinct indices i and j in the array nums such that the absolute difference between the elements at these indices is equal to a given number k. :param nums: List[int], array of integers :param k: int, the desired absolute difference :return: bool, True if such a pair exists, False otherwise if len(nums) < 2: return False num_set = set(nums) for num in nums: if (num + k) in num_set or (num - k) in num_set: return True return False"},{"question":"def calculate_total_duration(durations): This function takes a list of non-negative integers representing durations in minutes and returns the total duration formatted as 'DD days, HH:MM'. Args: durations (list): A list of non-negative integers representing durations in minutes. Returns: str: Total duration formatted as 'DD days, HH:MM'. Examples: >>> calculate_total_duration([45, 120, 300, -1]) '00 days, 07:45' >>> calculate_total_duration([1440, 1440, 60, -5]) '02 days, 01:00' from solution import calculate_total_duration def test_no_valid_inputs(): assert calculate_total_duration([]) == \\"00 days, 00:00\\" assert calculate_total_duration([-1, -5]) == \\"00 days, 00:00\\" def test_single_valid_input(): assert calculate_total_duration([45]) == \\"00 days, 00:45\\" assert calculate_total_duration([1440]) == \\"01 days, 00:00\\" def test_multiple_valid_inputs(): assert calculate_total_duration([45, 120, 300, -1]) == \\"00 days, 07:45\\" assert calculate_total_duration([1440, 1440, 60, -5]) == \\"02 days, 01:00\\" assert calculate_total_duration([2880, 1440, 60]) == \\"03 days, 01:00\\" def test_mixed_valid_and_invalid_inputs(): assert calculate_total_duration([45, -1, 120, 300]) == \\"00 days, 07:45\\" assert calculate_total_duration([1440, -1440, 1440, 60, -5]) == \\"02 days, 01:00\\" def test_edge_cases(): assert calculate_total_duration([0, 0, 0, -1]) == \\"00 days, 00:00\\" assert calculate_total_duration([1439, 1]) == \\"01 days, 00:00\\" assert calculate_total_duration([59, 1]) == \\"00 days, 01:00\\" assert calculate_total_duration([1439]) == \\"00 days, 23:59\\"","solution":"def calculate_total_duration(durations): This function takes a list of non-negative integers representing durations in minutes and returns the total duration formatted as 'DD days, HH:MM'. # Filter valid durations (non-negative integers) valid_durations = [duration for duration in durations if duration >= 0] if not valid_durations: return \\"00 days, 00:00\\" # Calculate total minutes total_minutes = sum(valid_durations) # Calculate days, hours and minutes days = total_minutes // (24 * 60) hours = (total_minutes % (24 * 60)) // 60 minutes = total_minutes % 60 # Formatted output return f\\"{days:02d} days, {hours:02d}:{minutes:02d}\\""},{"question":"from typing import List def unique_integers(input_list: List[int]) -> List[int]: Returns a new list containing only the unique integers from the input list in the same order they first appeared. >>> unique_integers([4, 5, 9, 4, 9, 10, 5]) [4, 5, 9, 10] >>> unique_integers([1, 2, 3, 2, 1, 4, 5, 3]) [1, 2, 3, 4, 5] pass def test_unique_integers_basic(): assert unique_integers([4, 5, 9, 4, 9, 10, 5]) == [4, 5, 9, 10] assert unique_integers([1, 2, 3, 2, 1, 4, 5, 3]) == [1, 2, 3, 4, 5] def test_unique_integers_all_unique(): assert unique_integers([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_unique_integers_empty(): assert unique_integers([]) == [] def test_unique_integers_all_duplicates(): assert unique_integers([1, 1, 1, 1, 1]) == [1] assert unique_integers([7, 7, 7, 7, 7]) == [7] def test_unique_integers_large_input(): assert unique_integers(list(range(10000)) * 2) == list(range(10000)) def test_unique_integers_negative_numbers(): assert unique_integers([-1, -2, -3, -2, -1, -4, -5, -3]) == [-1, -2, -3, -4, -5]","solution":"def unique_integers(input_list): Returns a new list containing only the unique integers from the input list in the same order they first appeared. seen = set() unique_list = [] for num in input_list: if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"def find_journey(tickets: List[Tuple[str, str]]) -> str: Given a list of tickets in a railway reservation system, reconstruct the journey. Each ticket is represented as a tuple of two strings (source, destination). >>> find_journey([(\\"Mumbai\\", \\"Pune\\"), (\\"Pune\\", \\"Bangalore\\"), (\\"Bangalore\\", \\"Chennai\\"), (\\"Chennai\\", \\"Hyderabad\\")]) 'Mumbai Pune Bangalore Chennai Hyderabad' >>> find_journey([(\\"Chicago\\", \\"Denver\\"), (\\"NewYork\\", \\"Chicago\\"), (\\"Denver\\", \\"Miami\\")]) 'NewYork Chicago Denver Miami' import pytest def test_find_journey_example_1(): tickets = [(\\"Mumbai\\", \\"Pune\\"), (\\"Pune\\", \\"Bangalore\\"), (\\"Bangalore\\", \\"Chennai\\"), (\\"Chennai\\", \\"Hyderabad\\")] assert find_journey(tickets) == \\"Mumbai Pune Bangalore Chennai Hyderabad\\" def test_find_journey_example_2(): tickets = [(\\"Chicago\\", \\"Denver\\"), (\\"NewYork\\", \\"Chicago\\"), (\\"Denver\\", \\"Miami\\")] assert find_journey(tickets) == \\"NewYork Chicago Denver Miami\\" def test_find_journey_backwards_connection(): tickets = [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\"), (\\"B\\", \\"C\\")] assert find_journey(tickets) == \\"A B C D\\" def test_find_journey_minimal_case(): tickets = [(\\"Start\\", \\"End\\")] assert find_journey(tickets) == \\"Start End\\" def test_find_journey_complex_case(): tickets = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\"), (\\"C\\", \\"D\\")] assert find_journey(tickets) == \\"A B C D E\\"","solution":"def find_journey(tickets): Given a list of tickets in a railway reservation system, reconstruct the journey. Each ticket is represented as a tuple of two strings (source, destination). from collections import defaultdict # Create a mapping from source to destination journey_map = defaultdict(str) destination_set = set() source_set = set() for source, destination in tickets: journey_map[source] = destination source_set.add(source) destination_set.add(destination) # Find the starting station (A starting station will not be in destination_set) start_station = (source_set - destination_set).pop() # Reconstruct the journey journey = [start_station] while start_station in journey_map: start_station = journey_map[start_station] journey.append(start_station) return ' '.join(journey)"},{"question":"def find_smallest_pair(arr): Finds the pair of elements in the array with the smallest absolute difference and returns their values in non-decreasing order. >>> find_smallest_pair([4, 9, 1, 12, 8]) (8, 9) >>> find_smallest_pair([1, 2, 3, 4, 5]) (1, 2) >>> find_smallest_pair([-1, -10, 0, 5, 2]) (-1, 0) >>> find_smallest_pair([1, 3, 4, 5, 10, 12]) (3, 4) or (4, 5) >>> find_smallest_pair([1, 1, 3, 4, 4, 5, 10, 12]) (1, 1) >>> find_smallest_pair([-1000000, 1000000]) (-1000000, 1000000) >>> find_smallest_pair([999999, 1000000]) (999999, 1000000)","solution":"def find_smallest_pair(arr): Finds the pair of elements in the array with the smallest absolute difference and returns their values in non-decreasing order. if len(arr) < 2: return None # Sort the array to make it easier to find pairs with small differences sorted_arr = sorted(arr) min_diff = float('inf') pair = (None, None) for i in range(len(sorted_arr) - 1): diff = abs(sorted_arr[i] - sorted_arr[i + 1]) if diff < min_diff: min_diff = diff pair = (sorted_arr[i], sorted_arr[i + 1]) return pair"},{"question":"class Stack: def __init__(self): self.stack = [] self.max_stack = [] self.history = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) self.history.append((\\"push\\", x)) def pop(self): if not self.stack: return popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() self.history.append((\\"pop\\", popped)) def max(self): if self.max_stack: return self.max_stack[-1] def undo(self): if not self.history: return last_action = self.history.pop() action, value = last_action if action == \\"push\\": self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() elif action == \\"pop\\": self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def perform_operations(operations): Perform a series of operations on a stack. >>> perform_operations([\\"push 3\\", \\"push 5\\", \\"max\\", \\"pop\\", \\"max\\", \\"undo\\", \\"max\\"]) [5, 3, 5] Unit Test: def test_example_case(): operations = [\\"push 3\\", \\"push 5\\", \\"max\\", \\"pop\\", \\"max\\", \\"undo\\", \\"max\\"] assert perform_operations(operations) == [5, 3, 5] def test_push_only(): operations = [\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"max\\"] assert perform_operations(operations) == [3] def test_push_pop_max(): operations = [\\"push 4\\", \\"push 7\\", \\"pop\\", \\"max\\"] assert perform_operations(operations) == [4] def test_push_pop_undo(): operations = [\\"push 4\\", \\"push 7\\", \\"pop\\", \\"undo\\", \\"max\\"] assert perform_operations(operations) == [7] def test_consecutive_max_operations(): operations = [\\"push 10\\", \\"push 20\\", \\"max\\", \\"max\\", \\"max\\", \\"pop\\", \\"max\\"] assert perform_operations(operations) == [20, 20, 20, 10]","solution":"class Stack: def __init__(self): self.stack = [] self.max_stack = [] self.history = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) self.history.append((\\"push\\", x)) def pop(self): if not self.stack: return popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() self.history.append((\\"pop\\", popped)) def max(self): if self.max_stack: return self.max_stack[-1] def undo(self): if not self.history: return last_action = self.history.pop() action, value = last_action if action == \\"push\\": self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() elif action == \\"pop\\": self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def perform_operations(operations): stack = Stack() results = [] for operation in operations: if operation.startswith(\\"push \\"): _, x = operation.split() stack.push(int(x)) elif operation == \\"pop\\": stack.pop() elif operation == \\"max\\": results.append(stack.max()) elif operation == \\"undo\\": stack.undo() return results # Example usage operations = [\\"push 3\\", \\"push 5\\", \\"max\\", \\"pop\\", \\"max\\", \\"undo\\", \\"max\\"] print(perform_operations(operations)) # Output: [5, 3, 5]"},{"question":"def clean_text_file(lines: List[str]) -> List[str]: This function takes a list of strings, where each string represents a line from a text file. It removes leading and trailing whitespace from each line, collapses multiple spaces into a single space, and removes any blank lines. >>> clean_text_file([ \\" This is a sample text. \\", \\" Here is another line. \\", \\" \\", \\"\\", \\" And yet another one. \\" ]) [\\"This is a sample text.\\", \\"Here is another line.\\", \\"And yet another one.\\"] >>> clean_text_file([ \\"This is a line.\\", \\"This is another line.\\" ]) [\\"This is a line.\\", \\"This is another line.\\"] >>> clean_text_file([ \\" \\", \\" \\", \\"\\", ]) [] >>> clean_text_file([ \\" \\", \\"Line one.\\", \\" \\", \\"Line two. \\", \\"\\", \\" Line three. \\" ]) [\\"Line one.\\", \\"Line two.\\", \\"Line three.\\"] >>> clean_text_file([ \\" \\", \\" \\", \\" \\", ]) []","solution":"def clean_text_file(lines): This function takes a list of strings, where each string represents a line from a text file. It removes leading and trailing whitespace from each line, collapses multiple spaces into a single space, and removes any blank lines. cleaned_lines = [] for line in lines: cleaned_line = ' '.join(line.strip().split()) if cleaned_line: cleaned_lines.append(cleaned_line) return cleaned_lines"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers such that they add up to target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 5, 7, 3], 10) [2, 3]","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to target. :param nums: List[int], list of integers :param target: int, target sum :return: List[int], indices of the two numbers num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def is_power_of_three(num: int) -> bool: Given an integer num, return True if num is a power of 3, otherwise return False. >>> is_power_of_three(27) True >>> is_power_of_three(0) False >>> is_power_of_three(9) True >>> is_power_of_three(-27) False","solution":"def is_power_of_three(num): Returns True if num is a power of 3, otherwise False. if num <= 0: return False while num % 3 == 0: num //= 3 return num == 1"},{"question":"def sum_of_maximum_weights(n, edges): You are managing a network of computers connected in a tree structure. Each computer is represented as a node, and each connection between two computers is represented as an edge. The tree structure ensures that there is exactly one path between any two computers. Each edge has a weight representing the time it takes to transfer data between the two computers it connects. Your task is to determine the sum of the maximum weights on all paths from the root computer (node 1) to all other computers in the network. Input: - n : int : The number of computers in the network. - edges : List[Tuple[int, int, int]] : List of edges where each edge contains three integers u, v, w representing an edge between node u and node v with weight w. Output: - int : The sum of the maximum weights on all paths from the root computer to all other computers. Example: >>> sum_of_maximum_weights(5, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 1)]) 12 >>> sum_of_maximum_weights(4, [(1, 2, 6), (1, 3, 2), (3, 4, 8)]) 16","solution":"def sum_of_maximum_weights(n, edges): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # BFS to find the path and maximum weight edge to each node from root (node 1) def bfs(root): max_weights = [0] * (n + 1) visited = [False] * (n + 1) queue = deque([root]) visited[root] = True while queue: node = queue.popleft() for neighbor, weight in graph[node]: if not visited[neighbor]: visited[neighbor] = True max_weights[neighbor] = max(max_weights[node], weight) queue.append(neighbor) return max_weights max_weights = bfs(1) # Sum the maximum weights for all paths from root (node 1) to all other computers return sum(max_weights[2:]) # Example usage: n1 = 5 edges1 = [ (1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 1) ] print(sum_of_maximum_weights(n1, edges1)) # Output: 12 n2 = 4 edges2 = [ (1, 2, 6), (1, 3, 2), (3, 4, 8) ] print(sum_of_maximum_weights(n2, edges2)) # Output: 16"},{"question":"def evaluate_expression(expression: str) -> int: Simulates the behavior of a simple parser for a mathematical expression. The expression will only contain non-negative integers and the '+', '-', '*' and '/' operators. The operators will follow the standard precedence rules and associativity. The division will be integer division. For example: >>> evaluate_expression(\\"3+5*2\\") # should return 13 >>> evaluate_expression(\\"10+2*6\\") # should return 22 >>> evaluate_expression(\\"100*2+12\\") # should return 212 >>> evaluate_expression(\\"100*(2+12)\\") # should return 1400 >>> evaluate_expression(\\"100*(2+12)/14\\") # should return 100","solution":"def evaluate_expression(expression): def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b # ensure integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def shunting_yard(expression): values = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): value = 0 while i < len(expression) and expression[i].isdigit(): value = (value * 10) + int(expression[i]) i += 1 values.append(value) i -= 1 elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': value2 = values.pop() value1 = values.pop() op = operators.pop() values.append(operate(value1, value2, op)) operators.pop() elif expression[i] in ('+', '-', '*', '/'): while (operators and precedence(operators[-1]) >= precedence(expression[i])): value2 = values.pop() value1 = values.pop() op = operators.pop() values.append(operate(value1, value2, op)) operators.append(expression[i]) i += 1 while operators: value2 = values.pop() value1 = values.pop() op = operators.pop() values.append(operate(value1, value2, op)) return values[0] return shunting_yard(expression)"},{"question":"def categorizeMessage(message: str) -> list: Categorizes the given message into math topics based on the presence of specific keywords. Args: message (str): The message to be categorized. Returns: list: A list of categories (algebra, geometry, calculus) that the message falls under. Examples: >>> categorizeMessage(\\"I'm struggling with variable equations in algebra.\\") ['algebra'] >>> categorizeMessage(\\"Calculus involves derivatives and integrals.\\") ['calculus'] >>> categorizeMessage(\\"Is a square a type of rectangle in geometry?\\") ['geometry'] >>> categorizeMessage(\\"Math is fun!\\") []","solution":"def categorizeMessage(message): Categorizes the given message into math topics based on the presence of specific keywords. Args: message (str): The message to be categorized. Returns: list: A list of categories (algebra, geometry, calculus) that the message falls under. categories = { \\"algebra\\": [\\"algebra\\", \\"equation\\", \\"variable\\"], \\"geometry\\": [\\"geometry\\", \\"triangle\\", \\"circle\\", \\"square\\"], \\"calculus\\": [\\"calculus\\", \\"integral\\", \\"derivative\\", \\"limit\\"] } result = [] lower_message = message.lower() for category, keywords in categories.items(): if any(keyword in lower_message for keyword in keywords): result.append(category) return result"},{"question":"def hasPairWithSum(arr: List[int], k: int) -> int: Given a list of \`n\` integers and a positive integer \`k\`, determine if there is a pair of distinct elements in the list such that their sum is equal to \`k\`. Return 1 if such a pair exists, otherwise return 0. >>> hasPairWithSum([10, 15, 3, 7], 17) 1 >>> hasPairWithSum([1, 2, 3, 4, 5], 10) 0 >>> hasPairWithSum([], 5) 0 >>> hasPairWithSum([5], 10) 0 >>> hasPairWithSum([1, 1, 1, 1], 2) 1 >>> hasPairWithSum([1000000, 999999, 999998], 1999999) 1","solution":"def hasPairWithSum(arr, k): seen = set() for num in arr: if k - num in seen: return 1 seen.add(num) return 0"},{"question":"def count_buildings_receiving_sunlight(n: int, heights: List[int]) -> int: Function to count the number of buildings receiving direct sunlight from the left side. Parameters: n (int): Number of buildings. heights (list of int): List of integers representing the heights of the buildings. Returns: int: Number of buildings receiving direct sunlight. Examples: >>> count_buildings_receiving_sunlight(6, [3, 1, 4, 2, 5, 7]) 4 >>> count_buildings_receiving_sunlight(1, [10]) 1","solution":"def count_buildings_receiving_sunlight(n, heights): Function to count the number of buildings receiving direct sunlight from the left side. Parameters: n (int): Number of buildings. heights (list of int): List of integers representing the heights of the buildings. Returns: int: Number of buildings receiving direct sunlight. if n == 0: return 0 count = 1 # The first building always receives direct sunlight max_height = heights[0] for i in range(1, n): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"def final_position(x, y, commands): Returns the final coordinates of the robot after executing the sequence of commands. Parameters: x (int): starting x-coordinate y (int): starting y-coordinate commands (str): sequence of commands Returns: Tuple[int, int]: final (x, y) coordinates >>> final_position(1, 2, \\"\\") (1, 2) >>> final_position(0, 0, \\"U\\") (0, 1) >>> final_position(0, 0, \\"D\\") (0, -1) >>> final_position(0, 0, \\"L\\") (-1, 0) >>> final_position(0, 0, \\"R\\") (1, 0) >>> final_position(1, 2, \\"UUDDLRLR\\") (1, 2) >>> final_position(0, 0, \\"UUU\\") (0, 3) >>> final_position(0, 0, \\"DDDD\\") (0, -4) >>> final_position(0, 0, \\"LLLL\\") (-4, 0) >>> final_position(0, 0, \\"RRRR\\") (4, 0) >>> final_position(1, 1, \\"ULDR\\") (1, 1) >>> final_position(5, 5, \\"RLUD\\") (5, 5) >>> final_position(-1, -1, \\"UDLR\\") (-1, -1)","solution":"def final_position(x, y, commands): Returns the final coordinates of the robot after executing the sequence of commands. Parameters: x (int): starting x-coordinate y (int): starting y-coordinate commands (str): sequence of commands Returns: Tuple[int, int]: final (x, y) coordinates for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y"},{"question":"def valid_chessboard(board: List[str]) -> str: Determines if an 8x8 chessboard setup is valid for a game of chess. >>> valid_chessboard([ \\"rnbqkbnr\\", \\"pppppppp\\", \\"........\\", \\"........\\", \\"........\\", \\"........\\", \\"PPPPPPPP\\", \\"RNBQKBNR\\" ]) == \\"Valid\\" >>> valid_chessboard([ \\"rnbqkbnr\\", \\"pp.ppppp\\", \\"....Q...\\", \\"........\\", \\"........\\", \\"........\\", \\"PPPPPPPP\\", \\"RNBQKBNR\\" ]) == \\"Invalid\\"","solution":"def valid_chessboard(board): Determines if an 8x8 chessboard setup is valid for a game of chess. Parameters: board (list of str): A list containing 8 strings, each with 8 characters. Returns: str: \\"Valid\\" if the chessboard setup is valid, otherwise \\"Invalid\\". if len(board) != 8 or any(len(row) != 8 for row in board): return \\"Invalid\\" piece_count = { 'K': 0, 'Q': 0, 'R': 0, 'B': 0, 'N': 0, 'P': 0, 'k': 0, 'q': 0, 'r': 0, 'b': 0, 'n': 0, 'p': 0 } for row in board: for char in row: if char in piece_count: piece_count[char] += 1 if (piece_count['K'] != 1 or piece_count['k'] != 1 or piece_count['Q'] > 1 or piece_count['q'] > 1 or piece_count['R'] > 2 or piece_count['r'] > 2 or piece_count['B'] > 2 or piece_count['b'] > 2 or piece_count['N'] > 2 or piece_count['n'] > 2 or piece_count['P'] > 8 or piece_count['p'] > 8): return \\"Invalid\\" return \\"Valid\\""},{"question":"def remove_spaces(s: str) -> str: Removes all spaces from the input string while preserving the relative order of the alphabetic characters. :param s: Input string containing lowercase, uppercase alphabetic characters, and spaces. :return: A string with all spaces removed. >>> remove_spaces(\\"Hello World\\") 'HelloWorld' >>> remove_spaces(\\" A B C D E F G \\") 'ABCDEFG' >>> remove_spaces(\\"NoSpacesHere\\") 'NoSpacesHere' >>> remove_spaces(\\"Mixed Spac es\\") 'MixedSpaces' >>> remove_spaces(\\" Leading and trailing \\") 'Leadingandtrailing' >>> remove_spaces(\\"\\") '' >>> remove_spaces(\\"a b c d e\\") 'abcde' >>> remove_spaces(\\" \\") ''","solution":"def remove_spaces(s): Removes all spaces from the input string while preserving the relative order of the alphabetic characters. :param s: Input string containing lowercase, uppercase alphabetic characters, and spaces. :return: A string with all spaces removed. return s.replace(\\" \\", \\"\\")"},{"question":"def isAlmostPalindrome(s: str) -> bool: Determines if a string can become a palindrome by removing at most one character. >>> isAlmostPalindrome(\\"abca\\") True >>> isAlmostPalindrome(\\"abc\\") False pass","solution":"def isAlmostPalindrome(s): This function checks if the input string can become a palindrome by removing at most one character. Parameters: s (str): The input string Returns: bool: True if the string can become a palindrome by removing at most one character, False otherwise. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Either remove s[left] or s[right] return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def largest_non_adjacent_subset(s: str) -> int: Determines the size of the largest subset of characters in which no two characters are adjacent in the original string. >>> largest_non_adjacent_subset(\\"aabbccd\\") 4 >>> largest_non_adjacent_subset(\\"abc\\") 3 >>> largest_non_adjacent_subset(\\"aabbccddeeffgg\\") 7 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns results for each. >>> process_test_cases(3, [\\"aabbccd\\", \\"abc\\", \\"aabbccddeeffgg\\"]) [4, 3, 7] >>> process_test_cases(2, [\\"abcd\\", \\"a\\"]) [4, 1]","solution":"def largest_non_adjacent_subset(s): Determines the size of the largest subset of characters in which no two characters are adjacent in the original string. # Use a set to store characters chars_set = set(s) return len(chars_set) def process_test_cases(t, test_cases): Processes multiple test cases and returns results for each. results = [] for s in test_cases: results.append(largest_non_adjacent_subset(s)) return results"},{"question":"from typing import List def shortest_path_in_maze(m: int, n: int, maze: List[str]) -> str: Returns the number of steps in the shortest path from the top-left corner to the bottom-right corner in the given maze or \\"IMPOSSIBLE\\" if there is no path. >>> shortest_path_in_maze(5, 5, [ ... \\".....\\", ... \\"..#..\\", ... \\"..#..\\", ... \\"..#..\\", ... \\".....\\" ... ]) 8 >>> shortest_path_in_maze(5, 5, [ ... \\".....\\", ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\".....\\" ... ]) 'IMPOSSIBLE' pass","solution":"from collections import deque def shortest_path_in_maze(m, n, maze): Returns the number of steps in the shortest path from the top-left corner to the bottom-right corner in the given maze or \\"IMPOSSIBLE\\" if there is no path. if maze[0][0] == '#' or maze[m-1][n-1] == '#': return \\"IMPOSSIBLE\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set([(0, 0)]) while queue: r, c, steps = queue.popleft() if r == m - 1 and c == n - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and maze[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return \\"IMPOSSIBLE\\" # Example usage: m, n = 5, 5 maze = [ \\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\" ] shortest_path_in_maze(m, n, maze) # Should return 8"},{"question":"def is_magic_square(matrix): Given a matrix of size NxN, determine whether it is a magic square. A magic square is a square matrix in which the sums of the elements in each row, each column, and the two main diagonals are all the same. Args: matrix (List[List[int]]): A 2D list of integers representing the square matrix. Returns: str: \\"YES\\" if it is a magic square, otherwise \\"NO\\". Examples: >>> is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) \\"YES\\" >>> is_magic_square([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"NO\\"","solution":"def is_magic_square(matrix): Given a matrix, determine whether it is a magic square. Args: matrix (List[List[int]]): A 2D list of integers representing the square matrix. Returns: str: \\"YES\\" if it is a magic square, otherwise \\"NO\\". size = len(matrix) if size == 1: return \\"YES\\" # A 1x1 matrix is trivially a magic square # Calculate the magic constant (sum of the first row) magic_sum = sum(matrix[0]) # Check sums of all rows for row in matrix: if sum(row) != magic_sum: return \\"NO\\" # Check sums of all columns for col in range(size): col_sum = sum(matrix[row][col] for row in range(size)) if col_sum != magic_sum: return \\"NO\\" # Check diagonals diagonal1_sum = sum(matrix[i][i] for i in range(size)) diagonal2_sum = sum(matrix[i][size-i-1] for i in range(size)) if diagonal1_sum != magic_sum or diagonal2_sum != magic_sum: return \\"NO\\" return \\"YES\\""},{"question":"def min_spotlights(n: int, r: int, heights: List[int]) -> int: Returns the minimum number of spotlights needed to illuminate all buildings. :param n: int, number of buildings :param r: int, range of each spotlight :param heights: List[int], heights of the buildings :return: int, minimum number of spotlights needed >>> min_spotlights(7, 3, [3, 1, 4, 1, 5, 9, 2]) 3 >>> min_spotlights(5, 2, [1, 1, 1, 1, 1]) 3 >>> min_spotlights(1, 1, [1]) 1 >>> min_spotlights(5, 5, [5, 5, 5, 5, 5]) 1 >>> min_spotlights(8, 2, [1, 2, 3, 4, 5, 6, 7, 8]) 4 >>> min_spotlights(10, 1, [1,1,1,1,1,1,1,1,1,1]) 10 >>> min_spotlights(10, 4, [1,1,1,1,1,1,1,1,1,1]) 3 # Your code here","solution":"def min_spotlights(n, r, heights): Returns the minimum number of spotlights needed to illuminate all buildings. :param n: int, number of buildings :param r: int, range of each spotlight :param heights: List[int], heights of the buildings :return: int, minimum number of spotlights needed spotlights = 0 i = 0 while i < n: spotlights += 1 i += r # place a spotlight and move to the next uncovered building return spotlights"},{"question":"from typing import List, Tuple def longest_ap_subsequence_length(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, returns the length of the longest subsequence that forms an arithmetic progression for each test case. >>> t = 2 >>> test_cases = [ ... (6, [1, 7, 10, 15, 27, 29]), ... (7, [5, 10, 15, 20, 25, 30, 35]) ... ] >>> longest_ap_subsequence_length(t, test_cases) [3, 7] >>> t = 1 >>> test_cases = [(1, [100])] >>> longest_ap_subsequence_length(t, test_cases) [1] >>> t = 1 >>> test_cases = [(2, [10, 20])] >>> longest_ap_subsequence_length(t, test_cases) [2] >>> t = 1 >>> test_cases = [(5, [1, 3, 8, 12, 20])] >>> longest_ap_subsequence_length(t, test_cases) [2] >>> t = 1 >>> test_cases = [(3, [1, 1000000, 1999999])] >>> longest_ap_subsequence_length(t, test_cases) [3] >>> t = 1 >>> test_cases = [(4, [7, 7, 7, 7])] >>> longest_ap_subsequence_length(t, test_cases) [4]","solution":"def longest_ap_subsequence_length(t, test_cases): results = [] for case in test_cases: n, arr = case if n <= 1: results.append(n) continue dp = {} max_length = 1 for i in range(n): dp[i] = {} for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) results.append(max_length) return results # Example usage: # t = 2 # test_cases = [(6, [1, 7, 10, 15, 27, 29]), (7, [5, 10, 15, 20, 25, 30, 35])] # print(longest_ap_subsequence_length(t, test_cases))"},{"question":"def sum_of_digits(s): Write a function that accepts a string of lowercase letters and numbers (0-9). The function should return the sum of all digits in the string while ignoring the letters. Parameters: s (str): A string containing lowercase letters and digits (0-9) Returns: int: The sum of all digits in the input string >>> sum_of_digits(\\"abc123xyz\\") 6 >>> sum_of_digits(\\"a1b2c3\\") 6 >>> sum_of_digits(\\"123\\") 6 >>> sum_of_digits(\\"456\\") 15 >>> sum_of_digits(\\"abcxyz\\") 0 >>> sum_of_digits(\\"qwerty\\") 0 >>> sum_of_digits(\\"\\") 0 >>> sum_of_digits(\\"a1b2!c#3&\\") 6 >>> sum_of_digits(\\"a@1b#2c3\\") 6","solution":"def sum_of_digits(s): Returns the sum of all digits in the input string. Parameters: s (str): A string containing lowercase letters and digits (0-9) Returns: int: The sum of all digits in the input string return sum(int(char) for char in s if char.isdigit())"},{"question":"from typing import List, Tuple, Dict from datetime import datetime def get_top_products(sales_data: List[Dict], start_date: str, end_date: str, k: int) -> List[Tuple[int, int]]: Determines the top \`k\` products with the highest total quantity sold within a specified date range. Args: sales_data (list): A list of dictionaries, where each dictionary represents a sales transaction with keys 'date', 'product_id', and 'quantity'. start_date (str): The start date of the analysis period, inclusive, in 'YYYY-MM-DD' format. end_date (str): The end date of the analysis period, inclusive, in 'YYYY-MM-DD' format. k (int): The number of top products to return. Returns: list: A list of tuples where each tuple contains a product ID and the total quantity sold for that product, sorted first by descending order of quantity, then by ascending order of product ID. >>> sales_data = [ ... {'date': '2023-01-01', 'product_id': 101, 'quantity': 5}, ... {'date': '2023-01-02', 'product_id': 101, 'quantity': 15}, ... {'date': '2023-01-01', 'product_id': 102, 'quantity': 20}, ... {'date': '2023-01-03', 'product_id': 103, 'quantity': 7}, ... {'date': '2023-01-03', 'product_id': 101, 'quantity': 2}, ... {'date': '2023-01-04', 'product_id': 104, 'quantity': 12} ... ] >>> get_top_products(sales_data, '2023-01-01', '2023-01-03', 2) [(101, 22), (102, 20)] >>> sales_data = [ ... {'date': '2023-01-01', 'product_id': 101, 'quantity': 5}, ... {'date': '2023-01-02', 'product_id': 105, 'quantity': 25}, ... {'date': '2023-01-03', 'product_id': 105, 'quantity': 5}, ... {'date': '2023-01-04', 'product_id': 101, 'quantity': 10}, ... {'date': '2023-01-04', 'product_id': 102, 'quantity': 7}, ... {'date': '2023-01-05', 'product_id': 103, 'quantity': 3} ... ] >>> get_top_products(sales_data, '2023-01-01', '2023-01-05', 3) [(105, 30), (101, 15), (102, 7)] pass # Implement the function here","solution":"from collections import defaultdict from datetime import datetime def get_top_products(sales_data, start_date, end_date, k): Determines the top \`k\` products with the highest total quantity sold within a specified date range. Args: sales_data (list): A list of dictionaries, where each dictionary represents a sales transaction with keys 'date', 'product_id', and 'quantity'. start_date (str): The start date of the analysis period, inclusive, in 'YYYY-MM-DD' format. end_date (str): The end date of the analysis period, inclusive, in 'YYYY-MM-DD' format. k (int): The number of top products to return. Returns: list: A list of tuples where each tuple contains a product ID and the total quantity sold for that product, sorted first by descending order of quantity, then by ascending order of product ID. start_date = datetime.strptime(start_date, '%Y-%m-%d') end_date = datetime.strptime(end_date, '%Y-%m-%d') # Dictionary to track total quantity sold for each product product_sales = defaultdict(int) for transaction in sales_data: transaction_date = datetime.strptime(transaction['date'], '%Y-%m-%d') if start_date <= transaction_date <= end_date: product_sales[transaction['product_id']] += transaction['quantity'] # Sorting the products first by total quantity sold (descending), then by product ID (ascending) sorted_products = sorted(product_sales.items(), key=lambda x: (-x[1], x[0])) # Return the top \`k\` products return sorted_products[:k]"},{"question":"def evaluateExpression(expr: str) -> int: Evaluates a given mathematical infix expression and returns the result as an integer. >>> evaluateExpression(\\"3+5\\") == 8 >>> evaluateExpression(\\"3+5*2\\") == 13 >>> evaluateExpression(\\"10+2*6\\") == 22 >>> evaluateExpression(\\"100*2+12\\") == 212 >>> evaluateExpression(\\"100*(2+12)/14\\") == 100 >>> evaluateExpression(\\"8+2/2\\") == 9 >>> evaluateExpression(\\"1+2-3*4/2\\") == -3 pass","solution":"def evaluateExpression(expr): Evaluates a given mathematical infix expression and returns the result as an integer. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def applyOp(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return int(a / b) # Ensure the result is an integer values = [] # Stack to store integers ops = [] # Stack to store operators i = 0 while i < len(expr): if expr[i] == '(': ops.append(expr[i]) elif expr[i].isdigit(): val = 0 while i < len(expr) and expr[i].isdigit(): val = (val * 10) + int(expr[i]) i += 1 values.append(val) i -= 1 elif expr[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(applyOp(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(expr[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(applyOp(val1, val2, op)) ops.append(expr[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(applyOp(val1, val2, op)) return values[-1]"},{"question":"def evaluate_palindromes(test_cases): Evaluate whether each string in the list can be converted to a palindrome by removing at most one character. >>> evaluate_palindromes([\\"abca\\", \\"racecar\\", \\"abc\\"]) ['YES', 'YES', 'NO'] >>> evaluate_palindromes([\\"a\\", \\"aa\\", \\"aaa\\", \\"abcd\\", \\"abccba\\"]) ['YES', 'YES', 'YES', 'NO', 'YES']","solution":"def can_be_palindrome_by_removing_one_char(s: str) -> str: def is_palindrome_range(start, end): return all(s[i] == s[end - i + start] for i in range(start, (end + start) // 2 + 1)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: if is_palindrome_range(l + 1, r) or is_palindrome_range(l, r - 1): return \\"YES\\" else: return \\"NO\\" l += 1 r -= 1 return \\"YES\\" def evaluate_palindromes(test_cases): results = [] for s in test_cases: results.append(can_be_palindrome_by_removing_one_char(s)) return results"},{"question":"def find_groups(N: int, M: int, handshakes: List[Tuple[int, int]]) -> int: Determine the number of groups formed by interconnected handshakes. >>> find_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_groups(6, 4, [(1, 2), (2, 3), (3, 4), (5, 6)]) 2 >>> find_groups(4, 0, []) 4 from collections import defaultdict def test_example_case_1(): assert find_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) == 2 def test_example_case_2(): assert find_groups(6, 4, [(1, 2), (2, 3), (3, 4), (5, 6)]) == 2 def test_example_case_3(): assert find_groups(4, 0, []) == 4 def test_no_handshakes(): assert find_groups(3, 0, []) == 3 def test_all_interconnected(): assert find_groups(3, 3, [(1, 2), (2, 3), (1, 3)]) == 1 def test_multiple_small_groups(): assert find_groups(7, 4, [(1, 2), (2, 3), (4, 5), (6, 7)]) == 3 def test_large_case(): N = 1000 M = 999 handshakes = [(i, i+1) for i in range(1, N)] assert find_groups(N, M, handshakes) == 1","solution":"def find_groups(N, M, handshakes): from collections import defaultdict # Initialize adjacency list for the graph graph = defaultdict(list) # Construct the graph for x, y in handshakes: graph[x].append(y) graph[y].append(x) def bfs(node, visited): queue = [node] while queue: current = queue.pop(0) for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (N + 1) groups = 0 # Iterate through each person for person in range(1, N + 1): if not visited[person]: # If the person has not been visited, it means this is # a new group, so we perform a BFS to mark all reachable nodes groups += 1 visited[person] = True bfs(person, visited) return groups # Reading input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) handshakes = [(int(data[i*2+2]), int(data[i*2+3])) for i in range(M)] print(find_groups(N, M, handshakes))"},{"question":"def compute_minimum_time(k: int, points: List[Tuple[int, int]]) -> int: Compute the minimum time needed for a truck to complete the delivery route visiting each delivery point at least once. def process_input(input_data: str) -> List[int]: Process multiple datasets to find the minimum time for each delivery route. >>> process_input(\\"3n1 1n2 2n3 3n0\\") [2] >>> process_input(\\"2n0 0n1 0n0\\") [1]","solution":"import itertools def compute_minimum_time(k, points): def distance(p1, p2): return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) min_time = float('inf') for perm in itertools.permutations(points): total_time = sum(distance(perm[i], perm[i + 1]) for i in range(k - 1)) min_time = min(min_time, total_time) return min_time def process_input(input_data): results = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): k = int(lines[i]) if k == 0: break points = [] for j in range(k): i += 1 x, y = map(int, lines[i].split()) points.append((x, y)) results.append(compute_minimum_time(k, points)) i += 1 return results"},{"question":"from typing import List def canFormSubsetWithSum(x: int, lengths: List[int]) -> bool: Determines if there is a subset of sticks with lengths that sum up to exactly x. Args: x (int): The desired sum of lengths. lengths (list of int): The list of stick lengths. Returns: bool: True if there is a subset that sums up to x, otherwise False. >>> canFormSubsetWithSum(10, [1, 2, 3, 4, 5, 6]) True >>> canFormSubsetWithSum(11, [1, 3, 5, 9]) False","solution":"def canFormSubsetWithSum(x, lengths): Determines if there is a subset of sticks with lengths that sum up to exactly x. Args: x (int): The desired sum of lengths. lengths (list of int): The list of stick lengths. Returns: bool: True if there is a subset that sums up to x, otherwise False. n = len(lengths) # Use dynamic programming where dp[j] will be True if sum j can be formed using the sticks. dp = [False] * (x + 1) dp[0] = True # A sum of 0 can always be formed by using an empty subset for length in lengths: for j in range(x, length - 1, -1): if dp[j - length]: dp[j] = True return dp[x]"},{"question":"def is_palindrome(s: str) -> str: Returns 'YES' if the given string s is a palindrome, otherwise returns 'NO'. >>> is_palindrome('radar') 'YES' >>> is_palindrome('hello') 'NO' >>> is_palindrome('level') 'YES' # Implementation here def check_palindromes(test_cases: List[str]) -> List[str]: For a list of strings test_cases, returns a list of 'YES' or 'NO' for each string indicating if it is a palindrome or not. >>> check_palindromes(['radar', 'hello', 'level']) ['YES', 'NO', 'YES'] >>> check_palindromes(['a', 'ab', 'aa']) ['YES', 'NO', 'YES'] >>> check_palindromes(['abcd', 'dcba', 'abba']) ['NO', 'NO', 'YES'] # Implementation here","solution":"def is_palindrome(s): Returns 'YES' if the given string s is a palindrome, otherwise returns 'NO'. return 'YES' if s == s[::-1] else 'NO' def check_palindromes(test_cases): For a list of strings test_cases, returns a list of 'YES' or 'NO' for each string indicating if it is a palindrome or not. return [is_palindrome(s) for s in test_cases]"},{"question":"def smallest_lexicographical_rotation(s: str, k: int) -> str: Returns the smallest lexicographical rotation of the string s after exactly k rotations. Params: s (str): the input string k (int): the number of rotations Returns: str: the smallest lexicographical string obtainable after exactly k rotations >>> smallest_lexicographical_rotation(\\"cba\\", 1) \\"acb\\" >>> smallest_lexicographical_rotation(\\"abcdef\\", 2) \\"cdefab\\" from solution import smallest_lexicographical_rotation def test_small_string(): assert smallest_lexicographical_rotation(\\"cba\\", 1) == \\"bac\\" def test_exact_rotation_mid_string(): assert smallest_lexicographical_rotation(\\"abcdef\\", 2) == \\"cdefab\\" def test_full_rotation_returns_same_string(): assert smallest_lexicographical_rotation(\\"abc\\", 3) == \\"abc\\" def test_string_with_one_char(): assert smallest_lexicographical_rotation(\\"z\\", 1) == \\"z\\" def test_full_rotation_on_larger_string(): assert smallest_lexicographical_rotation(\\"zyxwvutsrqponmlkjihgfedcba\\", 26) == \\"zyxwvutsrqponmlkjihgfedcba\\"","solution":"def smallest_lexicographical_rotation(s, k): Returns the smallest lexicographical rotation of the string s after exactly k rotations. Params: s (str): the input string k (int): the number of rotations Returns: str: the smallest lexicographical string obtainable after exactly k rotations n = len(s) k = k % n rotated = s[k:] + s[:k] return rotated"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number from 1 to n in the given list of unique numbers. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_number([1, 2, 4, 6, 3, 7, 8]) == 5 >>> find_missing_number([2, 3, 4]) == 1 >>> find_missing_number([1, 2, 4, 5]) == 3 >>> find_missing_number([1, 2, 3, 4]) == 5 >>> find_missing_number(list(range(1, 100000))) == 50000","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number from 1 to n in the given list of numbers. n = len(nums) + 1 total_sum = n * (n + 1) // 2 # Sum of all numbers from 1 to n current_sum = sum(nums) # Sum of numbers in the array return total_sum - current_sum"},{"question":"def smart_indent(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[List[str]]: Adjust the indentation of each line according to smart indent rules. >>> smart_indent(1, [(3, [ ... \\"START_BLOCK;\\", ... \\" statement1;\\", ... \\"END_BLOCK;\\"])]) [['START_BLOCK;', ' statement1;', 'END_BLOCK;']] >>> smart_indent(1, [(5, [ ... \\"START_BLOCK;\\", ... \\" statement1;\\", ... \\" START_BLOCK;\\", ... \\" statement2;\\", ... \\" END_BLOCK;\\", ... \\"END_BLOCK;\\"])]) [['START_BLOCK;', ' statement1;', ' START_BLOCK;', ' statement2;', ' END_BLOCK;', 'END_BLOCK;']]","solution":"def smart_indent(t, test_cases): results = [] for case in test_cases: n, lines = case indented_lines = [] indent_level = 0 for line in lines: line = line.strip() # remove leading and trailing spaces if line == 'END_BLOCK;': indent_level -= 1 indented_lines.append(' ' * indent_level + line) if line == 'START_BLOCK;': indent_level += 1 results.append(indented_lines) return results # Sample usage t = 2 test_cases = [ (3, [ \\"START_BLOCK;\\", \\" statement1;\\", \\"END_BLOCK;\\" ]), (5, [ \\"START_BLOCK;\\", \\" statement1;\\", \\" START_BLOCK;\\", \\" statement2;\\", \\" END_BLOCK;\\", \\"END_BLOCK;\\" ]) ] results = smart_indent(t, test_cases) for res in results: print(\\"n\\".join(res)) print()"},{"question":"from typing import List, Dict def char_frequencies(strings: List[str]) -> Dict[str, int]: Computes the frequency of each character across a list of strings. Converts all characters to lowercase to ensure case insensitivity, and ignores any non-alphabetic characters. >>> char_frequencies([\\"hello\\"]) {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_frequencies([\\"hello\\", \\"world\\", \\"leetcode\\"]) {'h': 1, 'e': 4, 'l': 4, 'o': 3, 'w': 1, 'r': 1, 'd': 2, 'c': 1, 't': 1} >>> char_frequencies([\\"HeLLo\\", \\"WOrLD\\", \\"LeetCoDE\\"]) {'h': 1, 'e': 4, 'l': 4, 'o': 3, 'w': 1, 'r': 1, 'd': 2, 'c': 1, 't': 1}","solution":"from typing import List, Dict from collections import defaultdict def char_frequencies(strings: List[str]) -> Dict[str, int]: Computes the frequency of each character across a list of strings. Parameters: strings (List[str]): List of strings to analyze. Returns: Dict[str, int]: Dictionary with character frequencies. frequency_dict = defaultdict(int) for string in strings: for char in string: if char.isalpha(): # Ensure only alphabetic characters are counted frequency_dict[char.lower()] += 1 return dict(frequency_dict)"},{"question":"def count_even_sum_pairs(n: int, arr: List[int]) -> int: Determine the number of pairs (i, j) where 1 <= i < j <= n and the sum a_i + a_j is even. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) 6 >>> count_even_sum_pairs(6, [1, 3, 5, 7, 9, 11]) 15","solution":"def count_even_sum_pairs(n, arr): even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count # The number of ways to choose 2 out of even_count even_pairs = even_count * (even_count - 1) // 2 # The number of ways to choose 2 out of odd_count odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"from typing import List, Tuple def shortest_path_cover(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determines the minimal number of shortest paths required to cover all vertices in the graph defined by n vertices and m edges. Parameters: - n (int): Number of vertices in the graph - m (int): Number of edges in the graph - edges (list of tuples): List of edges where each edge is defined by a tuple (u, v) Returns: - int: Minimal number of shortest paths required to cover all vertices >>> shortest_path_cover(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5), (5, 6)]) 1 >>> shortest_path_cover(6, 3, [(1, 2), (2, 3), (4, 5)]) 3 pass def test_example_cases(): assert shortest_path_cover(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5), (5, 6)]) == 1 assert shortest_path_cover(6, 3, [(1, 2), (2, 3), (4, 5)]) == 3 def test_single_node(): assert shortest_path_cover(1, 0, []) == 1 def test_disconnected_graph(): assert shortest_path_cover(4, 2, [(1, 2), (3, 4)]) == 2 assert shortest_path_cover(4, 0, []) == 4 def test_fully_connected_graph(): assert shortest_path_cover(5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) == 1 def test_graph_with_loops(): assert shortest_path_cover(5, 4, [(1, 2), (2, 1), (3, 4), (4, 3)]) == 3 def test_large_disconnected_graph(): n = 1000 m = 2000 edges = [(i, i + 1) for i in range(1, 1000)] # create n-1 edges to form a chain assert shortest_path_cover(n, m, edges) == 1","solution":"def shortest_path_cover(n, m, edges): Determines the minimal number of shortest paths required to cover all vertices in the graph defined by n vertices and m edges. Parameters: - n (int): Number of vertices in the graph - m (int): Number of edges in the graph - edges (list of tuples): List of edges where each edge is defined by a tuple (u, v) Returns: - int: Minimal number of shortest paths required to cover all vertices from collections import defaultdict, deque def bfs(start): Perform BFS and return all visited nodes visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited_global = set() component_count = 0 for node in range(1, n + 1): if node not in visited_global: visited_component = bfs(node) visited_global.update(visited_component) component_count += 1 return component_count"},{"question":"def has_pair_with_difference(arr: List[int], n: int, k: int) -> str: Returns \\"Yes\\" if there are two distinct elements in the array \`arr\` such that their absolute difference is exactly \`k\`, otherwise returns \\"No\\". >>> has_pair_with_difference([1, 4, 7, 2, 9], 5, 3) \\"Yes\\" >>> has_pair_with_difference([1, 2, 3, 4, 5], 5, 10) \\"No\\"","solution":"def has_pair_with_difference(arr, n, k): Returns \\"Yes\\" if there are two distinct elements in the array \`arr\` such that their absolute difference is exactly \`k\`, otherwise returns \\"No\\". elements = set(arr) for num in arr: if (num + k) in elements or (num - k) in elements: return \\"Yes\\" return \\"No\\""},{"question":"def find_continuous_periods(event_type, events, duration): Finds all continuous periods where the specified event type occurs for at least the specified duration. Parameters: - event_type (int): The specific event type of interest. - events (list of tuples): A list of tuples where each tuple contains: - timestamp (int) - event_type (int) - duration (int): The required minimum continuous duration. Returns: - list of tuples: Each tuple contains two integers (start, end) representing the start and end timestamps of a continuous period where the specified event type occurs for at least the specified duration. Examples: >>> find_continuous_periods(1, [(1, 1), (2, 1), (3, 1), (6, 1), (7, 1), (8, 2), (10, 1), (11, 1)], 2) [(1, 3), (6, 7), (10, 11)] >>> find_continuous_periods(2, [(1, 2), (2, 2), (4, 2), (6, 1), (7, 2), (10, 2), (11, 2)], 1) [(1, 2), (4, 4), (7, 7), (10, 11)] >>> find_continuous_periods(3, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 3), (6, 3), (7, 3), (8, 1)], 2) [(5, 7)] >>> find_continuous_periods(1, [(1, 1), (3, 1), (4, 2), (5, 1), (6, 1), (7, 1), (8, 1)], 3) [(5, 8)] >>> find_continuous_periods(4, [(1, 2), (2, 2), (3, 4), (5, 4), (6, 4), (8, 4)], 2) [(5, 6)]","solution":"def find_continuous_periods(event_type, events, duration): Finds all continuous periods where the specified event type occurs for at least the specified duration. Parameters: - event_type (int): The specific event type of interest. - events (list of tuples): A list of tuples where each tuple contains: - timestamp (int) - event_type (int) - duration (int): The required minimum continuous duration. Returns: - list of tuples: Each tuple contains two integers (start, end) representing the start and end timestamps of a continuous period where the specified event type occurs for at least the specified duration. results = [] start = None # Start of a potential continuous period count = 0 for i, (timestamp, e_type) in enumerate(events): if e_type == event_type: if start is None: start = timestamp count += 1 # Check if we reached the required duration at this time if i == len(events) - 1 or events[i + 1][0] - timestamp > 1: if count >= duration: results.append((start, timestamp)) start = None count = 0 else: if start is not None and count >= duration: results.append((start, timestamp - 1)) start = None count = 0 return results"},{"question":"def is_balanced(s: str) -> str: Determines if the string s is balanced. >>> is_balanced(\\"abcde\\") \\"NO\\" >>> is_balanced(\\"aeeiouxyz\\") \\"NO\\" >>> is_balanced(\\"bcdf\\") \\"YES\\" # Implementation here def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if they are balanced. >>> process_test_cases([\\"abcde\\", \\"aeeiouxyz\\", \\"bcdf\\"]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([\\"ae\\", \\"xyz\\", \\"zxy\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"] # Implementation here","solution":"def is_balanced(s): Determines if the string s is balanced. vowels = set('aeiou') n = len(s) for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] vowel_count = sum(1 for char in substring if char in vowels) consonant_count = len(substring) - vowel_count if vowel_count > consonant_count: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases. results = [] for s in test_cases: results.append(is_balanced(s)) return results"},{"question":"from typing import List, Tuple def min_days_to_gather_in_capital(n: int, m: int, roads: List[Tuple[int, int]], people: List[Tuple[int, int]]) -> int: Given a village with n houses connected by n-1 roads and m people living in some of the houses, determine the minimum number of days required for all people to gather in the capital at house 1. Args: n (int): Number of houses. m (int): Number of people. roads (List[Tuple[int, int]]): List of tuples representing roads between houses. people (List[Tuple[int, int]]): List of tuples representing people and their steps per day. Returns: int: Minimum number of days required for all people to gather in the capital. Examples: >>> min_days_to_gather_in_capital(6, 4, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], [(4, 2), (5, 1), (6, 1), (1, 1)]) 2 >>> min_days_to_gather_in_capital(3, 2, [(1, 2), (1, 3)], [(2, 3), (3, 1)]) 1","solution":"from collections import deque, defaultdict def min_days_to_gather_in_capital(n, m, roads, people): Given a village with n houses connected by n-1 roads and m people living in some of the houses, determine the minimum number of days required for all people to gather in the capital at house 1. def bfs(start, graph): queue = deque([start]) distances = {start: 0} while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in distances: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return distances # Graph initialization graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # BFS to find the distance of each house from the capital (house 1) distances_from_capital = bfs(1, graph) # Finding the maximum days required max_days = 0 for house, steps_per_day in people: max_days = max(max_days, (distances_from_capital[house] + steps_per_day - 1) // steps_per_day) return max_days # Sample function usage n = 6 m = 4 roads = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] people = [(4, 2), (5, 1), (6, 1), (1, 1)] print(min_days_to_gather_in_capital(n, m, roads, people)) # Output: 2"},{"question":"def select_segment(n: int, flow_rates: List[int], lengths: List[int], k: int) -> int: Determines the best segment for placing the filterstone to maximize effectiveness. Effectiveness is calculated as e_i = k / (f_i * l_i). Parameters: n (int): The number of segments. flow_rates (list of int): List of flow rates for each segment. lengths (list of int): List of lengths for each segment. k (int): The magical constant. Returns: int: The 1-based index of the segment with the highest effectiveness. >>> select_segment(3, [10, 5, 10], [2, 2, 1], 100) == 2 >>> select_segment(4, [10, 10, 10, 10], [1, 1, 1, 1], 10) == 1 >>> select_segment(3, [1, 2, 3], [1, 2, 3], 6) == 1 >>> select_segment(3, [3, 3, 3], [3, 3, 3], 100) == 1 >>> select_segment(1, [1], [1], 1) == 1 >>> select_segment(1000, list(range(1, 1001)), list(range(1, 1001)), 1000000000) == 1 >>> select_segment(5, [10, 10, 5, 10, 5], [2, 2, 2, 2, 1], 100) == 5","solution":"def select_segment(n, flow_rates, lengths, k): Determines the best segment for placing the filterstone to maximize effectiveness. Effectiveness is calculated as e_i = k / (f_i * l_i). Parameters: n (int): The number of segments. flow_rates (list of int): List of flow rates for each segment. lengths (list of int): List of lengths for each segment. k (int): The magical constant. Returns: int: The 1-based index of the segment with the highest effectiveness. max_effectiveness = 0 best_segment = 0 for i in range(n): effectiveness = k / (flow_rates[i] * lengths[i]) if effectiveness > max_effectiveness: max_effectiveness = effectiveness best_segment = i elif effectiveness == max_effectiveness and i < best_segment: best_segment = i return best_segment + 1"},{"question":"def isValidParentheses(s: str) -> bool: Checks whether the input string s is a valid combination of parentheses. >>> isValidParentheses(\\"()\\") == True >>> isValidParentheses(\\"()[]{}\\") == True >>> isValidParentheses(\\"{[]}\\") == True >>> isValidParentheses(\\"{[()]}\\") == True >>> isValidParentheses(\\"\\") == True >>> isValidParentheses(\\"(]\\") == False >>> isValidParentheses(\\"([)]\\") == False >>> isValidParentheses(\\"(((\\") == False >>> isValidParentheses(\\"))\\") == False >>> isValidParentheses(\\"}\\") == False >>> isValidParentheses(\\"(\\") == False >>> isValidParentheses(\\"]\\") == False >>> isValidParentheses(\\"[\\") == False","solution":"def isValidParentheses(s): Checks whether the input string s is a valid combination of parentheses. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def min_sum_of_distances(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Compute the minimum sum of distances from the depot to the rental locations while fulfilling all rental requests. Args: T: The number of test cases. test_cases: A list of tuples, each containing two integers N and M followed by a list of N rental requests. Returns: A list of integers representing the minimum sum of distances for each test case. Example: >>> min_sum_of_distances(2, [(3, 5, [3, 3, 1]), (4, 3, [2, 3, 3, 2])]) [4, 6] >>> min_sum_of_distances(1, [(5, 10, [2, 2, 2, 2, 2])]) [5] >>> min_sum_of_distances(1, [(2, 2, [2, 2])]) [2] >>> min_sum_of_distances(3, [(3, 4, [2, 3, 4]), (5, 5, [5, 4, 3, 2, 1]), (1, 1000, [999])]) [6, 10, 998]","solution":"def min_sum_of_distances(T, test_cases): results = [] for case in test_cases: N, M, rental_requests = case rental_requests.sort() total_distance = 0 for req in rental_requests: total_distance += abs(1 - req) results.append(total_distance) return results"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Return the values of the nodes that are visible from the right side. >>> rightSideView(TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, right=TreeNode(4)))) == [1, 3, 4] >>> rightSideView(TreeNode(1, None, TreeNode(3))) == [1, 3] >>> rightSideView(None) == []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Return the values of the nodes that are visible from the right side. if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def maxNonAdjacentSum(arr): Finds the maximum sum of a subsequence such that no two numbers in the sequence are adjacent. If all numbers are negative, returns 0. Parameters: arr (list): List of integers. Returns: int: Maximum sum of a subsequence with non-adjacent elements. Examples: >>> maxNonAdjacentSum([3, 2, 5, 10, 7]) 15 >>> maxNonAdjacentSum([-2, 1, 3, -4, 5]) 8 >>> maxNonAdjacentSum([-1, -2, -3]) 0","solution":"def maxNonAdjacentSum(arr): Finds the maximum sum of a subsequence such that no two numbers in the sequence are adjacent. If all numbers are negative, returns 0. Parameters: arr (list): List of integers. Returns: int: Maximum sum of a subsequence with non-adjacent elements. if not arr: return 0 prev_max = 0 curr_max = 0 for num in arr: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return max(curr_max, 0)"},{"question":"def decode_roman_numeral(s: str) -> int: Implement a function called decode_roman_numeral that takes in a string representing a Roman numeral and returns its integer value. Example: >>> decode_roman_numeral(\\"III\\") 3 >>> decode_roman_numeral(\\"IV\\") 4 >>> decode_roman_numeral(\\"IX\\") 9 >>> decode_roman_numeral(\\"LVIII\\") 58 >>> decode_roman_numeral(\\"MCMXCIV\\") 1994","solution":"def decode_roman_numeral(s): Converts a Roman numeral string to an integer. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"from typing import List def mirror_string(S: str) -> str: Given a string S, transform it into its mirrored form. >>> mirror_string(\\"abc\\") 'zyx' >>> mirror_string(\\"hello\\") 'svool' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases for the mirror_string function. >>> process_test_cases(2, [\\"abc\\", \\"hello\\"]) ['zyx', 'svool'] >>> process_test_cases(3, [\\"a\\", \\"b\\", \\"c\\"]) ['z', 'y', 'x'] >>> process_test_cases(1, [\\"xyz\\"]) ['cba'] pass","solution":"def mirror_string(S): Given a string S, transform it into its mirrored form. mirrored = [] for char in S: mirrored.append(chr(219 - ord(char))) return ''.join(mirrored) def process_test_cases(T, test_cases): Process multiple test cases for the mirror_string function. Parameters: T (int): Number of test cases. test_cases (list of str): List of strings to be transformed. Returns: list of str: List of mirrored strings. results = [] for case in test_cases: results.append(mirror_string(case)) return results"},{"question":"from typing import List, Tuple def final_coordinates(moves: List[str]) -> Tuple[int, int]: Determine the final coordinates of the robot after a series of moves. :param moves: List of moves (strings) which can be \\"U\\", \\"D\\", \\"L\\", or \\"R\\". :return: Tuple of final coordinates (x, y). >>> final_coordinates([\\"U\\", \\"D\\", \\"L\\", \\"R\\"]) (0, 0) >>> final_coordinates([\\"U\\", \\"U\\", \\"L\\", \\"R\\", \\"D\\", \\"L\\"]) (-1, 1) >>> final_coordinates([\\"R\\", \\"R\\", \\"U\\", \\"U\\", \\"L\\", \\"D\\"]) (1, 1)","solution":"from typing import List, Tuple def final_coordinates(moves: List[str]) -> Tuple[int, int]: Determine the final coordinates of the robot after a series of moves. :param moves: List of moves (strings) which can be \\"U\\", \\"D\\", \\"L\\", or \\"R\\". :return: Tuple of final coordinates (x, y). x, y = 0, 0 for move in moves: if move == \\"U\\": y += 1 elif move == \\"D\\": y -= 1 elif move == \\"L\\": x -= 1 elif move == \\"R\\": x += 1 return (x, y)"},{"question":"def find_best_scores(test_cases): Find the highest score achieved by each participant in each test case. Args: test_cases(List[Tuple[int, List[Tuple[int, int]]]]): A list of tuples representing the test cases. Each tuple contains: - An integer N denoting the number of submissions. - A list of tuples where each tuple contains two integers: - P_i (participant's unique identifier) - S_i (score of the participant’s submission) Returns: List[Tuple[int, List[Tuple[int, int]]]]: Results for each test case. Each tuple contains: - An integer M representing the number of unique participants in the test case. - A list of tuples where each tuple contains two integers: - P_i (participant's unique identifier) - The highest score S_i for that participant, sorted by participant IDs. Examples: >>> find_best_scores([(5, [(1, 85), (2, 90), (1, 95), (3, 80), (2, 92)]), (4, [(4, 75), (4, 85), (4, 80), (4, 90)])]) [(3, [(1, 95), (2, 92), (3, 80)]), (1, [(4, 90)])] >>> find_best_scores([(3, [(1, 80), (1, 90), (1, 85)])]) [(1, [(1, 90)])]","solution":"def find_best_scores(test_cases): results = [] for case in test_cases: N = case[0] submissions = case[1] best_scores = {} for participant, score in submissions: if participant not in best_scores: best_scores[participant] = score else: best_scores[participant] = max(best_scores[participant], score) sorted_results = sorted(best_scores.items()) results.append((len(sorted_results), sorted_results)) return results"},{"question":"def maxSum(nums): Returns the maximum sum of non-adjacent elements in the array nums. Parameters: nums (list): A list of integers representing the array. Returns: int: The maximum sum of non-adjacent elements. Example: >>> maxSum([3, 2, 5, 10, 7]) 15 >>> maxSum([5, 5, 10, 100, 10, 5]) 110 >>> maxSum([]) 0 >>> maxSum([1, 2, 3]) 4","solution":"def maxSum(nums): Returns the maximum sum of non-adjacent elements in the array nums. Parameters: nums (list): A list of integers representing the array. Returns: int: The maximum sum of non-adjacent elements. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # dp[i] will store the maximum sum of non-adjacent elements from nums[0] to nums[i] dp = [0] * n dp[0] = max(0, nums[0]) dp[1] = max(dp[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def pulsate_messages(messages): Transforms a list of messages into a pulsating animation where each letter of the message \\"lights up\\" and \\"dims down\\" one by one. Args: messages (list): A list of strings where each string is a message to animate. Returns: list: A list of lists, where each inner list contains the animation frames for the corresponding message. >>> pulsate_messages([\\"hello\\"]) [['Hello', 'hEllo', 'heLlo', 'helLo', 'hellO']] >>> pulsate_messages([\\"hi\\", \\"wave\\"]) [['Hi', 'hI'], ['Wave', 'wAve', 'waVe', 'wavE']] >>> pulsate_messages([\\"a\\"]) [['A']] >>> pulsate_messages([\\"aaa\\"]) [['Aaa', 'aAa', 'aaA']] >>> pulsate_messages([\\"He\\"]) [['He', 'HE']] >>> pulsate_messages([\\"abcdefghij\\"]) [['Abcdefghij', 'aBcdefghij', 'abCdefghij', 'abcDefghij', 'abcdEfghij', 'abcdeFghij', 'abcdefGhij', 'abcdefgHij', 'abcdefghIj', 'abcdefghiJ']]","solution":"def pulsate_messages(messages): Transforms a list of messages into a pulsating animation where each letter of the message \\"lights up\\" and \\"dims down\\" one by one. Args: messages (list): A list of strings where each string is a message to animate. Returns: list: A list of lists, where each inner list contains the animation frames for the corresponding message. result = [] for message in messages: frames = [] for i in range(len(message)): frame = message[:i] + message[i].upper() + message[i+1:] frames.append(frame) result.append(frames) return result"},{"question":"def min_seconds_to_reach_destination(city_map: List[str]) -> int: Determine the minimum time required for all cars to reach their respective destinations without causing a gridlock. >>> min_seconds_to_reach_destination([ ... \\"S..\\", ... \\".#.\\", ... \\"..E\\" ... ]) 4 >>> min_seconds_to_reach_destination([ ... \\"S#.\\", ... \\"#\\", ... \\".#E\\" ... ]) -1 def min_time_for_cars(test_cases: List[List[str]]) -> List[int]: For each test case, determine the minimum time required for a car to reach its destination. >>> min_time_for_cars([ ... [\\"S..\\", \\".#.\\", \\"..E\\"], ... [\\"S#.\\", \\"#\\", \\".#E\\"] ... ]) [4, -1]","solution":"from collections import deque def min_seconds_to_reach_destination(city_map): N = len(city_map) M = len(city_map[0]) # Helper functions to find 'S' and 'E' positions def find_positions(): start, end = None, None for i in range(N): for j in range(M): if city_map[i][j] == 'S': start = (i, j) elif city_map[i][j] == 'E': end = (i, j) return start, end start, end = find_positions() if not start or not end: return -1 # invalid input as there must be exactly one 'S' and one 'E' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and city_map[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # If no path found to reach 'E' def min_time_for_cars(test_cases): results = [] for case in test_cases: results.append(min_seconds_to_reach_destination(case)) return results def read_input(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N, M = int(data[idx]), int(data[idx + 1]) idx += 2 city_map = [] for _ in range(N): city_map.append(data[idx]) idx += 1 test_cases.append(city_map) return test_cases if __name__ == '__main__': test_cases = read_input() results = min_time_for_cars(test_cases) for result in results: print(result)"},{"question":"def is_odd_subset_sum_possible(n: int, arr: List[int]) -> str: Returns 'YES' if it is possible to select a subset of the integers such that their sum is odd, otherwise returns 'NO'. >>> is_odd_subset_sum_possible(4, [1, 2, 3, 4]) == 'YES' >>> is_odd_subset_sum_possible(3, [2, 4, 6]) == 'NO'","solution":"def is_odd_subset_sum_possible(n, arr): Returns 'YES' if it is possible to select a subset of the integers such that their sum is odd, otherwise returns 'NO'. has_odd = any(x % 2 != 0 for x in arr) has_even = any(x % 2 == 0 for x in arr) if has_odd: if (has_even and n > 1) or (not has_even and n % 2 != 0): return \\"YES\\" else: return \\"NO\\" else: return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def minRefuelStops(initialFuel: int, finalDestination: int, stations: List[Tuple[int, int]]) -> int: Calculate the minimum number of refueling stops required to reach the destination. :param initialFuel: int - Initial amount of fuel in the aircraft. :param finalDestination: int - Total distance to be covered. :param stations: list of tuples [(distance, fuel), ...] - List of refueling stations. :return: int - Minimum number of refueling stops, or -1 if not possible. pass def test_minRefuelStops_basic(): assert minRefuelStops(10, 60, [(10, 20), (20, 10), (30, 30), (50, 40)]) == 2 def test_minRefuelStops_no_station_needed(): assert minRefuelStops(100, 50, []) == 0 def test_minRefuelStops_impossible(): assert minRefuelStops(1, 1000, [(10, 10), (20, 20), (30, 30)]) == -1 def test_minRefuelStops_exact_fuel(): assert minRefuelStops(10, 10, [(10, 0)]) == 0 def test_minRefuelStops_multiple_stations(): assert minRefuelStops(50, 200, [(50, 50), (100, 100), (150, 80)]) == 2 def test_minRefuelStops_large_input(): assert minRefuelStops(1_000_000_000, 1_000_000_000, [(10, 1), (20, 2), (30, 3)]) == 0","solution":"import heapq def minRefuelStops(initialFuel, finalDestination, stations): Calculate the minimum number of refueling stops required to reach the destination. :param initialFuel: int - Initial amount of fuel in the aircraft. :param finalDestination: int - Total distance to be covered. :param stations: list of tuples [(distance, fuel), ...] - List of refueling stations. :return: int - Minimum number of refueling stops, or -1 if not possible. # Max heap to keep track of the fuel amounts at the stations we can stop at fuel_max_heap = [] stations.append((finalDestination, 0)) # Add destination as the last \\"station\\" current_fuel = initialFuel previous_station_distance = 0 refuel_stops = 0 for distance, fuel in stations: current_fuel -= (distance - previous_station_distance) while fuel_max_heap and current_fuel < 0: current_fuel += -heapq.heappop(fuel_max_heap) refuel_stops += 1 if current_fuel < 0: return -1 heapq.heappush(fuel_max_heap, -fuel) previous_station_distance = distance return refuel_stops"},{"question":"def four_sum(nums): Find all unique quadruplets in the array which gives the sum of zero. >>> four_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 0, 2], [-1, 0, 1, 0]] >>> four_sum([1, 2, 3, 4]) [] >>> four_sum([1, 0, -1, 0, -2, 2]) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([0, 0, 0, 0]) [[0, 0, 0, 0]] >>> four_sum([1, 1, 1, 1, -1, -1, -1, -1, 0, 0, 0, 0]) [[-1, -1, 1, 1], [-1, 0, 0, 1], [0, 0, 0, 0]]","solution":"def four_sum(nums): def k_sum(nums, target, k): res = [] if not nums: return res average_value = target // k if average_value < nums[0] or nums[-1] < average_value: return res if k == 2: return two_sum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for subset in k_sum(nums[i + 1:], target - nums[i], k - 1): res.append([nums[i]] + subset) return res def two_sum(nums, target): res = [] lo, hi = 0, len(nums) - 1 while lo < hi: curr_sum = nums[lo] + nums[hi] if curr_sum < target or (lo > 0 and nums[lo] == nums[lo - 1]): lo += 1 elif curr_sum > target or (hi < len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res nums.sort() return k_sum(nums, 0, 4)"},{"question":"def min_additional_edges_to_complete_binary_tree(n, edges): Determine the minimal number of additional branches (edges) required to transform a unique tree into a fully connected complete binary tree. >>> n, edges = 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] >>> min_additional_edges_to_complete_binary_tree(n, edges) 0 >>> n, edges = 5, [(1, 2), (1, 3), (2, 4), (4, 5)] >>> min_additional_edges_to_complete_binary_tree(n, edges) 2 def parse_input(input_str): Helper function to parse the input string to number of nodes and edges. >>> input_str = \\"5n1 2n1 3n2 4n4 5\\" >>> parse_input(input_str) (5, [(1, 2), (1, 3), (2, 4), (4, 5)])","solution":"def min_additional_edges_to_complete_binary_tree(n, edges): # Function to calculate the height of a complete binary tree with n nodes def height_of_complete_binary_tree(n): height = 0 while (1 << height) - 1 < n: height += 1 return height # Function to calculate the expected number of nodes in a complete binary tree of a certain height def complete_binary_tree_nodes(height): return (1 << height) - 1 height = height_of_complete_binary_tree(n) expected_nodes = complete_binary_tree_nodes(height) # If the current number of nodes is exactly what is expected for a complete binary tree, return 0 if n == expected_nodes: return 0 # Otherwise, calculate the difference additional_nodes = expected_nodes - n return additional_nodes # Helper function to parse the input def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) edges = [] for line in lines[1:]: u, v = map(int, line.split()) edges.append((u, v)) return n, edges # Example usage if __name__ == \\"__main__\\": input_str = 5 1 2 1 3 2 4 4 5 n, edges = parse_input(input_str) print(min_additional_edges_to_complete_binary_tree(n, edges)) # Output: 2"},{"question":"def dna_pattern(dna: str, length: int, pattern: str) -> int: Returns the count of how many times the pattern appears in the DNA fragment. Parameters: dna (str): The DNA fragment. length (int): The length of the pattern to search for. pattern (str): The specific motif to search for in the DNA fragment. Returns: int: The count of how many times the pattern appears in the DNA fragment. >>> dna_pattern(\\"ACGTACGTACGT\\", 3, \\"ACG\\") 3 >>> dna_pattern(\\"AAAACCCCGGGGTTTT\\", 4, \\"CCCC\\") 1 >>> dna_pattern(\\"ATTGCATTGC\\", 2, \\"GC\\") 2 # Implement the function here from solution import dna_pattern def test_dna_pattern_example_1(): assert dna_pattern(\\"ACGTACGTACGT\\", 3, \\"ACG\\") == 3 def test_dna_pattern_example_2(): assert dna_pattern(\\"AAAACCCCGGGGTTTT\\", 4, \\"CCCC\\") == 1 def test_dna_pattern_example_3(): assert dna_pattern(\\"ATTGCATTGC\\", 2, \\"GC\\") == 2 def test_dna_pattern_no_occurrence(): assert dna_pattern(\\"AACCGGTT\\", 3, \\"TAC\\") == 0 def test_dna_pattern_multiple_occurrences(): assert dna_pattern(\\"ATATATATAT\\", 2, \\"AT\\") == 5 def test_dna_pattern_pattern_longer_than_dna(): assert dna_pattern(\\"GATTACA\\", 8, \\"GATTACAT\\") == 0 def test_dna_pattern_empty_dna(): assert dna_pattern(\\"\\", 2, \\"AT\\") == 0 def test_dna_pattern_empty_pattern(): assert dna_pattern(\\"ACGT\\", 0, \\"\\") == 5 # Empty pattern should match between every character def test_dna_pattern_whole_sequence(): assert dna_pattern(\\"ACGT\\", 4, \\"ACGT\\") == 1","solution":"def dna_pattern(dna, length, pattern): Returns the count of how many times the pattern appears in the DNA fragment. Parameters: dna (str): The DNA fragment. length (int): The length of the pattern to search for. pattern (str): The specific motif to search for in the DNA fragment. Returns: int: The count of how many times the pattern appears in the DNA fragment. count = 0 for i in range(len(dna) - length + 1): if dna[i:i+length] == pattern: count += 1 return count"},{"question":"def can_transform(s1: str, s2: str) -> bool: Returns true if s1 can be transformed into s2 by rearranging its characters, otherwise false. >>> can_transform(\\"listen\\", \\"silent\\") == True >>> can_transform(\\"apple\\", \\"pale\\") == False >>> can_transform(\\"test\\", \\"test\\") == True","solution":"def can_transform(s1, s2): Returns true if s1 can be transformed into s2 by rearranging its characters, otherwise false. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"def count_swaps_to_sort(n, array): Returns the number of swaps required to sort the array using bubble sort. >>> count_swaps_to_sort(5, [1, 3, 5, 2, 4]) 3 >>> count_swaps_to_sort(5, [5, 4, 3, 2, 1]) 10 >>> count_swaps_to_sort(3, [2, 3, 1]) 2 def process_test_cases(t, test_cases): Processes multiple test cases and returns the result for each. >>> t = 3 >>> test_cases = [ ... (5, [1, 3, 5, 2, 4]), ... (5, [5, 4, 3, 2, 1]), ... (3, [2, 3, 1]) ... ] >>> process_test_cases(t, test_cases) [3, 10, 2] >>> t = 1 >>> test_cases = [ ... (4, [4, 3, 2, 1]) ... ] >>> process_test_cases(t, test_cases) [6]","solution":"def count_swaps_to_sort(n, array): Returns the number of swaps required to sort the array using bubble sort. swaps = 0 arr = array.copy() for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swaps += 1 return swaps def process_test_cases(t, test_cases): results = [] for i in range(t): n, array = test_cases[i] results.append(count_swaps_to_sort(n, array)) return results"},{"question":"def hasOddSumSubarray(arr): Determines if there exists a contiguous subarray with an odd sum. Parameters: arr (list of int): The list of non-negative integers. Returns: bool: True if such a subarray exists, False otherwise. Examples: >>> hasOddSumSubarray([2, 4, 6, 8, 5]) True >>> hasOddSumSubarray([2, 4, 6, 8]) False >>> hasOddSumSubarray([1, 2, 3, 4, 5]) True","solution":"def hasOddSumSubarray(arr): Determines if there exists a contiguous subarray with an odd sum. Parameters: arr (list of int): The list of non-negative integers. Returns: bool: True if such a subarray exists, False otherwise. for num in arr: if num % 2 == 1: # If there's at least one odd number, we can form a subarray with an odd sum return True return False # If no odd numbers exist, no odd sum subarray can exist"},{"question":"def count_distinct_characters(S): Given a string S, return a matrix containing the number of distinct characters in all its substrings. >>> count_distinct_characters(\\"abc\\") [[1, 2, 3], [0, 1, 2], [0, 0, 1]] >>> count_distinct_characters(\\"aabb\\") [[1, 1, 2, 2], [0, 1, 2, 2], [0, 0, 1, 1], [0, 0, 0, 1]] def process_test_cases(test_cases): Process multiple test cases and return a list of results for each test case. >>> process_test_cases([(3, \\"abc\\"), (4, \\"aabb\\")]) [[[1, 2, 3], [0, 1, 2], [0, 0, 1]], [[1, 1, 2, 2], [0, 1, 2, 2], [0, 0, 1, 1], [0, 0, 0, 1]]] from solution import count_distinct_characters, process_test_cases def test_count_distinct_characters(): assert count_distinct_characters(\\"abc\\") == [ [1, 2, 3], [0, 1, 2], [0, 0, 1] ] assert count_distinct_characters(\\"aabb\\") == [ [1, 1, 2, 2], [0, 1, 2, 2], [0, 0, 1, 1], [0, 0, 0, 1] ] def test_process_test_cases(): test_cases = [ (3, \\"abc\\"), (4, \\"aabb\\") ] expected_results = [ [ [1, 2, 3], [0, 1, 2], [0, 0, 1] ], [ [1, 1, 2, 2], [0, 1, 2, 2], [0, 0, 1, 1], [0, 0, 0, 1] ] ] assert process_test_cases(test_cases) == expected_results def test_edge_cases(): # Single character string assert count_distinct_characters(\\"a\\") == [[1]] # Repeated characters assert count_distinct_characters(\\"aaaa\\") == [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] # Alternating characters assert count_distinct_characters(\\"abab\\") == [ [1, 2, 2, 2], [0, 1, 2, 2], [0, 0, 1, 2], [0, 0, 0, 1] ]","solution":"def count_distinct_characters(S): n = len(S) result = [[0] * n for _ in range(n)] for i in range(n): distinct_chars = set() for j in range(i, n): distinct_chars.add(S[j]) result[i][j] = len(distinct_chars) return result def process_test_cases(test_cases): results = [] for N, S in test_cases: results.append(count_distinct_characters(S)) return results"},{"question":"def longest_descending_segment(n: int, points: List[Tuple[int, int]]) -> int: Determines the longest segment of the hike where Alice is continuously descending. Parameters: n (int): The number of points recorded during the hike. points (list of tuples): The recorded coordinates during the hike. Returns: int: The length of the longest descending segment. >>> longest_descending_segment(6, [(1, 10), (2, 9), (3, 8), (4, 7), (5, 6), (6, 5)]) 5 >>> longest_descending_segment(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 0 >>> longest_descending_segment(7, [(1, 10), (2, 15), (3, 8), (4, 9), (5, 7), (6, 3), (7, 2)]) 3 pass","solution":"def longest_descending_segment(n, points): Determines the longest segment of the hike where Alice is continuously descending. Parameters: n (int): The number of points recorded during the hike. points (list of tuples): The recorded coordinates during the hike. Returns: int: The length of the longest descending segment. if n < 2: return 0 longest_length = 0 current_length = 0 for i in range(1, n): if points[i][1] < points[i-1][1]: current_length += 1 if current_length > longest_length: longest_length = current_length else: current_length = 0 return longest_length"},{"question":"def reverse_sentence(sentence): This function takes a sentence and returns the sentence with each word's characters reversed but with the words in their original order. >>> reverse_sentence(\\"Hello\\") 'olleH' >>> reverse_sentence(\\"Hello World from AI\\") 'olleH dlroW morf IA' >>> reverse_sentence(\\"A B C D E\\") 'A B C D E' >>> reverse_sentence(\\"\\") '' >>> reverse_sentence(\\"Hello World FROM ai\\") 'olleH dlroW MORF ia'","solution":"def reverse_sentence(sentence): This function takes a sentence and returns the sentence with each word's characters reversed but with the words in their original order. return ' '.join(word[::-1] for word in sentence.split())"},{"question":"def word_scramble(scrambled: str, words: List[str]) -> List[str]: Finds all the words in the scrambled string sequentially without rearranging any remaining characters, in the order of their appearance in the words list. >>> word_scramble(\\"hellothisisateststring\\", [\\"hello\\", \\"test\\", \\"string\\"]) == [\\"hello\\", \\"test\\", \\"string\\"] >>> word_scramble(\\"abcdefthequickbrownfoxjumpsoverlazydog\\", [\\"the\\", \\"fox\\", \\"dog\\"]) == [\\"the\\", \\"fox\\", \\"dog\\"] >>> word_scramble(\\"abcdefgh\\", [\\"x\\", \\"y\\", \\"z\\"]) == [] >>> word_scramble(\\"hellothisisateststring\\", [\\"test\\", \\"world\\", \\"string\\"]) == [\\"test\\", \\"string\\"] >>> word_scramble(\\"thequickbrownfoxjumpsoverlazydog\\", [\\"quick\\", \\"fox\\", \\"lazy\\"]) == [\\"quick\\", \\"fox\\", \\"lazy\\"] >>> word_scramble(\\"thequickbrownfoxjumpsoverlazydog\\", [\\"fox\\", \\"lazy\\", \\"quick\\"]) == [\\"fox\\", \\"lazy\\"] >>> word_scramble(\\"helloworldworldhello\\", [\\"hell\\", \\"world\\", \\"o\\"]) == [\\"hell\\", \\"world\\", \\"o\\"] >>> word_scramble(\\"codingisfun\\", [\\"coding\\", \\"code\\", \\"cod\\"]) == [\\"coding\\"] >>> word_scramble(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == [] >>> word_scramble(\\"abc\\", []) == [] pass","solution":"def word_scramble(scrambled, words): Finds all the words in the scrambled string sequentially without rearranging any remaining characters, in the order of their appearance in the words list. :param scrambled: str, the scrambled string :param words: list, list of words to find in the scrambled string :return: list, found words in their order of appearance found_words = [] index = 0 for word in words: pos = scrambled.find(word, index) if pos != -1: found_words.append(word) index = pos + len(word) return found_words"},{"question":"def mergeSortedArrays(array1, array2): Merges two sorted arrays into a single sorted array. Parameters: array1 (list of int): First sorted array. array2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. >>> mergeSortedArrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> mergeSortedArrays([0, 2, 4], [1, 3, 5]) [0, 1, 2, 3, 4, 5] >>> mergeSortedArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeSortedArrays([1, 2, 3], []) [1, 2, 3] >>> mergeSortedArrays([], []) [] >>> mergeSortedArrays([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> mergeSortedArrays([1, 2, 3, 4, 5], [6]) [1, 2, 3, 4, 5, 6] >>> mergeSortedArrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> mergeSortedArrays([2, 2, 2], [2, 2, 2]) [2, 2, 2, 2, 2, 2]","solution":"def mergeSortedArrays(array1, array2): Merges two sorted arrays into a single sorted array. Parameters: array1 (list of int): First sorted array. array2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. merged = [] i, j = 0, 0 len1, len2 = len(array1), len(array2) while i < len1 and j < len2: if array1[i] <= array2[j]: merged.append(array1[i]) i += 1 else: merged.append(array2[j]) j += 1 while i < len1: merged.append(array1[i]) i += 1 while j < len2: merged.append(array2[j]) j += 1 return merged"},{"question":"def process_numbers(x, y): Given two integers x and y, return x * y if x * y is even; otherwise, return x + y. >>> process_numbers(3, 4) # product 12 is even 12 >>> process_numbers(3, 5) # product 15 is odd, sum is 8 8 >>> process_numbers(2, 2) # product 4 is even 4 >>> process_numbers(1, 3) # product 3 is odd, sum is 4 4","solution":"def process_numbers(x, y): Given two integers x and y, return x*y if x*y is even; otherwise, return x+y. product = x * y if product % 2 == 0: return product else: return x + y"},{"question":"def can_be_sorted_with_one_swap(arr: List[int]) -> int: Determines if the array can be sorted in non-decreasing order with at most one swap. Parameters: arr (list of int): The input array. Returns: int: 1 if the array can be sorted with one swap, otherwise 0. Examples: >>> can_be_sorted_with_one_swap([1, 5, 3, 3, 7]) 1 >>> can_be_sorted_with_one_swap([1, 3, 5, 3, 4]) 0 >>> can_be_sorted_with_one_swap([1, 2, 3, 4, 3]) 1","solution":"def can_be_sorted_with_one_swap(arr): Determines if the array can be sorted in non-decreasing order with at most one swap. Parameters: arr (list of int): The input array. Returns: int: 1 if the array can be sorted with one swap, otherwise 0. n = len(arr) orig = arr[:] arr.sort() # Find the elements that are different diff = [i for i in range(n) if arr[i] != orig[i]] # If there are zero or two elements that are out of place, they can be swapped to sort the array if len(diff) == 0 or len(diff) == 2: return 1 return 0"},{"question":"def min_coins(n: int) -> int: Determine the minimum number of coins needed to make a specific amount of money using pennies (1 cent), nickels (5 cents), and dimes (10 cents). >>> min_coins(28) 6 >>> min_coins(7) 3 >>> min_coins(123) 15 >>> min_coins(0) 0 >>> min_coins(1) 1 >>> min_coins(5) 1 >>> min_coins(1000) 100 >>> min_coins(15) 2 >>> min_coins(20) 2 >>> min_coins(16) 3","solution":"def min_coins(n: int) -> int: Returns the minimum number of coins needed to make the given amount in cents using pennies (1 cent), nickels (5 cents), and dimes (10 cents). # Start with the largest denomination num_coins = 0 # Number of dimes (10 cents) num_dimes = n // 10 n -= num_dimes * 10 num_coins += num_dimes # Number of nickels (5 cents) num_nickels = n // 5 n -= num_nickels * 5 num_coins += num_nickels # Number of pennies (1 cent) num_pennies = n num_coins += num_pennies return num_coins"},{"question":"from typing import List, Tuple def find_triplet(arr: List[int], target: int) -> Tuple[int, int, int]: Write a function that takes a list of integers and a target sum. The function should return a tuple of three integers from the list that add up to the target sum. If no such triplet exists, return an empty tuple. Examples: >>> set(find_triplet([12, 3, 4, 1, 6, 9], 24)) in [{12, 3, 9}, {3, 9, 12}, {9, 3, 12}] True >>> set(find_triplet([1, 2, 3, 4, 5], 9)) in [{1, 3, 5}, {2, 3, 4}] True >>> find_triplet([1, 1, 1, 1], 5) () >>> find_triplet([1, 2, 3], 6) (1, 2, 3) >>> set(find_triplet([-1, 0, 1, 2, -1, -4], 0)) in [{-1, -1, 2}, {-1, 0, 1}] True","solution":"def find_triplet(arr, target): arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return (arr[i], arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return ()"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aaaaaa\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"\\") == 0 >>> long_string = \\"a\\" * 10000 >>> length_of_longest_substring(long_string) == 1 >>> long_string_varied = \\"ab\\" * 5000 >>> length_of_longest_substring(long_string_varied) == 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_index_map = {} longest = 0 left = 0 for right in range(n): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"def closestPair(arr, N, S): Given an array of distinct integers arr[] of size N and a target sum S, return a list of two integers whose sum is closest to the target sum S. Examples: >>> closestPair([10, 22, 28, 29, 30], 5, 54) == [22, 30] >>> closestPair([1, 3, 4, 7], 4, 10) == [3, 7] def test_closestPair(): assert closestPair([10, 22, 28, 29, 30], 5, 54) == [22, 30] assert closestPair([1, 3, 4, 7], 4, 10) == [3, 7] assert closestPair([1, 2, 3, 4, 5], 5, 100) == [4, 5] assert closestPair([-1, 2, 1, -4], 4, 1) == [-1, 2] assert closestPair([-1, 3, 8, 2, 9, 5], 6, 12) == [3, 9] assert closestPair([1, 60, -10, 70, -80, 85], 6, 0) == [-80, 85] assert closestPair([], 0, 5) == [] assert closestPair([3], 1, 5) == [] assert closestPair([1, 1, 1, 1], 4, 2) == [1, 1] test_closestPair()","solution":"def closestPair(arr, N, S): Given an array of distinct integers arr[] of size N and a target sum S, return a list of two integers whose sum is closest to the target sum S. if N < 2: return [] # Sort the array arr.sort() left = 0 right = N - 1 # Initialize the result list and smallest difference best_pair = [arr[left], arr[right]] closest_diff = abs(arr[left] + arr[right] - S) while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - S) if current_diff < closest_diff: closest_diff = current_diff best_pair = [arr[left], arr[right]] # Move pointers based on current_sum comparison with S if current_sum < S: left += 1 elif current_sum > S: right -= 1 else: # If exact match found, return immediately return [arr[left], arr[right]] return best_pair"},{"question":"def max_production_lines(n: int, B: int, production_lines: List[Tuple[int, int]]) -> int: Determines the maximum number of production lines that can be built within budget B. :param n: Number of available production lines :param B: Total budget :param production_lines: List of tuples (x_i, y_i) representing the cost and production time of each production line :return: Maximum number of production lines that can be built within the budget >>> max_production_lines(5, 50, [(10, 5), (20, 8), (30, 7), (25, 6), (15, 9)]) 3 >>> max_production_lines(3, 0, [(5, 2), (10, 3), (15, 4)]) 0 >>> max_production_lines(1, 10, [(10, 2)]) 1 >>> max_production_lines(4, 100, [(10, 1), (15, 2), (20, 3), (25, 4)]) 4 >>> max_production_lines(4, 60, [(20, 5), (40, 10), (30, 6), (25, 4)]) 2","solution":"def max_production_lines(n, B, production_lines): Determines the maximum number of production lines that can be built within budget B. :param n: Number of available production lines :param B: Total budget :param production_lines: List of tuples (x_i, y_i) representing the cost and production time of each production line :return: Maximum number of production lines that can be built within the budget # Sort the production lines by their cost production_lines.sort(key=lambda x: x[0]) num_lines = 0 total_cost = 0 for cost, time in production_lines: if total_cost + cost <= B: total_cost += cost num_lines += 1 else: break return num_lines"},{"question":"def minimize_difference(n: int, arr: List[int]) -> int: Partition the set into two subsets such that the absolute difference between the sum of the elements in subset A and the sum of the elements in subset B is minimized. >>> minimize_difference(5, [3, 1, 4, 2, 2]) == 0 >>> minimize_difference(4, [1, 3, 2, 5]) == 1 >>> minimize_difference(2, [10, 20]) == 10 >>> minimize_difference(3, [1, 2, 3]) == 0 >>> minimize_difference(3, [1, 6, 11]) == 4 >>> minimize_difference(6, [3, 1, 4, 1, 5, 9]) == 1","solution":"from itertools import combinations def minimize_difference(n, arr): total_sum = sum(arr) min_diff = float('inf') # Iterate through all possible subsets and find the minimum absolute difference for i in range(n+1): for subset in combinations(arr, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_sum)) return min_diff"},{"question":"def maximal_value_of_items(n, W, items): Marta is planning a hiking trip and wants to pack her backpack efficiently. Her backpack has a maximum weight capacity, and she has a list of essential items she wants to bring, each with a specific weight and value. Marta wants to maximize the total value of the items she can carry without exceeding the weight limit of her backpack. :param n: int - number of items :param W: int - maximum capacity of the backpack :param items: List of tuples - each containing the weight and value of the i-th item :return: int - the maximal value of items Marta can bring Examples: >>> maximal_value_of_items(3, 50, [(20, 40), (50, 100), (30, 60)]) 100 >>> maximal_value_of_items(4, 10, [(5, 10), (4, 7), (3, 4), (2, 2)]) 17 >>> maximal_value_of_items(1, 5, [(5, 10)]) 10 >>> maximal_value_of_items(1, 5, [(6, 10)]) 0 >>> maximal_value_of_items(3, 10, [(5, 10), (5, 10), (5, 10)]) 20 >>> maximal_value_of_items(1, 1, [(1, 1)]) 1","solution":"def knapsack(W, weights, values, n): Returns the maximum value that can be accommodated in the knapsack with given weight capacity W, weights and values of the items. # Initialize a DP table to store the maximum value up to capacity W dp = [0] * (W + 1) for i in range(n): for w in range(W, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[W] def maximal_value_of_items(n, W, items): weights = [item[0] for item in items] values = [item[1] for item in items] return knapsack(W, weights, values, n)"},{"question":"def max_people_path(grid): Determine the shortest path from the top-left corner to the bottom-right corner of the grid that passes through cells with the maximum sum of people. Parameters: grid (List[List[int]]): a 2D grid representing the city map where each cell contains a non-negative integer representing the number of people. Returns: int: the maximum sum of people along the shortest path. Example: >>> grid = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> max_people_path(grid) 29 pass from max_people_path import max_people_path def test_max_people_path_simple(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_people_path(grid) == 29 def test_max_people_path_single_row(): grid = [ [1, 2, 3, 4] ] assert max_people_path(grid) == 10 def test_max_people_path_single_column(): grid = [ [1], [2], [3], [4] ] assert max_people_path(grid) == 10 def test_max_people_path_single_cell(): grid = [ [42] ] assert max_people_path(grid) == 42 def test_max_people_path_large_numbers(): grid = [ [1000, 1000], [1000, 1000] ] assert max_people_path(grid) == 3000 def test_max_people_path_large_grid(): grid = [ [0] * 500 for _ in range(500) ] grid[0][0] = 1 grid[499][499] = 1 assert max_people_path(grid) == 2","solution":"def max_people_path(grid): M = len(grid) N = len(grid[0]) # Create a dp array to store the maximum sum of people up to each cell dp = [[0] * N for _ in range(M)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) # The maximum sum path to the bottom-right corner return dp[M-1][N-1] # Example usage: # M = 3 # N = 3 # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(max_people_path(grid)) # Output: 29"},{"question":"def max_words_formed(s: str, t: str) -> int: Returns the maximum number of words that can be formed using characters from string s, with each word containing characters of string t in the exact order. >>> max_words_formed(\\"ababcb\\", \\"ab\\") 2 >>> max_words_formed(\\"aaaaa\\", \\"aa\\") 2 >>> max_words_formed(\\"abcdef\\", \\"g\\") 0","solution":"def max_words_formed(s, t): Returns the maximum number of words that can be formed using characters from string s, with each word containing characters of string t in the exact order. from collections import Counter # count the frequency of each character in both strings s_count = Counter(s) t_count = Counter(t) # calculate the maximum number of times t can be formed min_count = float('inf') for char in t_count: if char not in s_count: return 0 # find the minimum number of times any character in t can be found in s relative to its count in t min_count = min(min_count, s_count[char] // t_count[char]) return min_count"},{"question":"def determine_winner(t: int, test_cases: List[Tuple[Tuple[int, int], int, List[int]]]) -> List[str]: Determine the winner for each test case based on optimal play strategy. Parameters: t (int): Number of test cases. test_cases (list): List of test case tuples which contains: - first element is a tuple (p, q) - second element is an integer m (length of the sequence) - third element is a list of integers (the sequence) Returns: list: List of strings representing the winner for each test case (\\"John\\" or \\"Jane\\"). Example: >>> determine_winner(2, [((1, 2), 5, [1, 2, 3, 4, 5]), ((3, 5), 4, [10, 10, 10, 20])]) [\\"John\\", \\"Jane\\"] import pytest def test_sample_cases(): t = 2 test_cases = [ ((1, 2), 5, [1, 2, 3, 4, 5]), ((3, 5), 4, [10, 10, 10, 20]) ] expected = [\\"John\\", \\"Jane\\"] assert determine_winner(t, test_cases) == expected def test_all_same_elements(): t = 1 test_cases = [ ((2, 4), 3, [10, 10, 10]) ] assert determine_winner(t, test_cases) == [\\"Jane\\"] def test_distinct_elements(): t = 1 test_cases = [ ((1, 1), 3, [1, 2, 3]) ] assert determine_winner(t, test_cases) == [\\"John\\"] def test_mixed_elements(): t = 1 test_cases = [ ((5, 6), 5, [1, 1, 1, 2, 2]) ] assert determine_winner(t, test_cases) == [\\"Jane\\"] def test_large_case(): t = 1 test_cases = [ ((1000, 999), 2, [500000, 500000]) ] assert determine_winner(t, test_cases) == [\\"Jane\\"]","solution":"def determine_winner(t, test_cases): Determines the winner for each test case based on optimal play strategy. Parameters: t (int): Number of test cases. test_cases (list): List of test case tuples which contains: - first element is a tuple (p, q) - second element is an integer m (length of the sequence) - third element is a list of integers (the sequence) Returns: list: List of strings representing the winner for each test case (\\"John\\" or \\"Jane\\"). results = [] for case in test_cases: p, q = case[0] m = case[1] sequence = case[2] # Set to maintain unique position, set is optimal for search, insert, delete operations positions = set(sequence) # The game's resolution becomes straightforward: if the number of unique positions (m) # is less than the length of the original sequence minus 1, Jane wins (because John # cannot make a move), otherwise, John wins. unique_positions = len(positions) if unique_positions < m: results.append(\\"Jane\\") else: results.append(\\"John\\") return results"},{"question":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Tasks are represented as tuples with start and end times in a 24-hour format. >>> max_non_overlapping_tasks([(1, 4), (2, 5), (6, 8), (5, 7)]) 2 >>> max_non_overlapping_tasks([(0, 6), (1, 4), (3, 5), (5, 7), (8, 9)]) 3","solution":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. # Sort the tasks based on their end times tasks.sort(key=lambda x: x[1]) max_tasks = 0 last_end_time = -1 for start, end in tasks: if start >= last_end_time: max_tasks += 1 last_end_time = end return max_tasks"},{"question":"class CandyBags: def __init__(self, n): Initialize the CandyBags with n empty bags. Args: n: integer, number of candy bags pass def add_candies(self, i, v): Add v candies to the ith bag. Args: i: integer, the index of the bag (1-based index) v: integer, the number of candies to add pass def get_range_sum(self, i, j): Get the total number of candies from bag i to bag j inclusive. Args: i: integer, starting index of the range (1-based index) j: integer, ending index of the range (1-based index) pass def manage_candies(n, operations): Main function to manage candy bags and perform operations. Args: n: integer, number of candy bags operations: list of operations to perform pass #Unit Tests def test_add_candies(): cb = CandyBags(5) cb.add_candies(3, 10) assert cb.candy_bags == [0, 0, 10, 0, 0] def test_get_range_sum(): cb = CandyBags(5) cb.add_candies(3, 10) assert cb.get_range_sum(2, 4) == 10 assert cb.get_range_sum(1, 5) == 10 def test_manage_candies(): operations = [ (1, 3, 10), (2, 2, 4), (1, 2, 5), (2, 1, 3) ] assert manage_candies(5, operations) == [10, 15] def test_manage_candies_empty_bag(): operations = [ (2, 1, 5) ] assert manage_candies(5, operations) == [0] def test_manage_candies_single_add(): operations = [ (1, 1, 5), (2, 1, 1) ] assert manage_candies(5, operations) == [5]","solution":"class CandyBags: def __init__(self, n): Initialize the CandyBags with n empty bags. Args: n: integer, number of candy bags self.candy_bags = [0] * n def add_candies(self, i, v): Add v candies to the ith bag. Args: i: integer, the index of the bag (1-based index) v: integer, the number of candies to add self.candy_bags[i - 1] += v def get_range_sum(self, i, j): Get the total number of candies from bag i to bag j inclusive. Args: i: integer, starting index of the range (1-based index) j: integer, ending index of the range (1-based index) return sum(self.candy_bags[i - 1: j]) def manage_candies(n, operations): Main function to manage candy bags and perform operations. Args: n: integer, number of candy bags operations: list of operations to perform candy_bags = CandyBags(n) output = [] for operation in operations: if operation[0] == 1: _, i, v = operation candy_bags.add_candies(i, v) elif operation[0] == 2: _, i, j = operation result = candy_bags.get_range_sum(i, j) output.append(result) return output"},{"question":"def isBalanced(expression: str) -> bool: Given a string representing a mathematical expression, determine whether the expression has balanced parentheses. The expression contains only the characters '(', ')', '+', '-', '*', '/', and digits. >>> isBalanced(\\"3 + (2 * (1 + 3) / 2)\\") True >>> isBalanced(\\"(3 + 2)) * (1 + 2\\") False >>> isBalanced(\\"((()))\\") True >>> isBalanced(\\")((\\") False pass # Test cases print(isBalanced(\\"3 + (2 * (1 + 3) / 2)\\")) # Expected output: True print(isBalanced(\\"(3 + 2)) * (1 + 2\\")) # Expected output: False print(isBalanced(\\"((()))\\")) # Expected output: True print(isBalanced(\\")((\\")) # Expected output: False","solution":"def isBalanced(expression: str) -> bool: Returns True if the parentheses in the expression are balanced, otherwise False. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def find_out_of_stock_sandwich(sandwiches): Given a list of sales for each type of sandwich, return the index (1-based) of the sandwich type that is out of stock. :param sandwiches: List[int] - A list of sales for each type of sandwich. :return: int - The 1-based index of the sandwich type that is out of stock. >>> find_out_of_stock_sandwich([5, 7, 0, 9, 4]) == 3 >>> find_out_of_stock_sandwich([0, 2, 3]) == 1 >>> find_out_of_stock_sandwich([1, 0, 2, 5]) == 2 >>> find_out_of_stock_sandwich([4, 6, 0, 1]) == 3 >>> find_out_of_stock_sandwich([1, 1, 1, 0, 1]) == 4 >>> find_out_of_stock_sandwich([7, 8, 0, 10, 11, 12]) == 3 >>> find_out_of_stock_sandwich([3, 3, 3, 3, 0, 3]) == 5","solution":"def find_out_of_stock_sandwich(sandwiches): Given a list of sales for each type of sandwich, return the index (1-based) of the sandwich type that is out of stock. :param sandwiches: List[int] - A list of sales for each type of sandwich. :return: int - The 1-based index of the sandwich type that is out of stock. for i, sales in enumerate(sandwiches): if sales == 0: return i + 1"},{"question":"def max_satisfied_requests(m, books, n, requests): Determine how many borrower requests can be fully satisfied given the available copies of the books. Parameters: m (int): Number of books in the library books (list of tuples): List of tuples where each tuple contains a book identifier (str) and an integer indicating the number of available copies n (int): Number of borrowers requests (list of lists): List of lists where each inner list contains the requested book identifiers by a borrower Returns: int: The maximum number of borrower requests that can be fully satisfied Examples: >>> m = 3 >>> books = [('book1', 2), ('book2', 1), ('book3', 5)] >>> n = 4 >>> requests = [['book1', 'book2'], ['book1', 'book3', 'book2'], ['book3'], ['book1', 'book3']] >>> max_satisfied_requests(m, books, n, requests) 3 >>> m = 1 >>> books = [('book1', 1)] >>> n = 1 >>> requests = [['book1']] >>> max_satisfied_requests(m, books, n, requests) 1 import pytest def test_example1(): m = 3 books = [('book1', 2), ('book2', 1), ('book3', 5)] n = 4 requests = [['book1', 'book2'], ['book1', 'book3', 'book2'], ['book3'], ['book1', 'book3']] assert max_satisfied_requests(m, books, n, requests) == 3 def test_single_book_single_request(): m = 1 books = [('book1', 1)] n = 1 requests = [['book1']] assert max_satisfied_requests(m, books, n, requests) == 1 def test_multiple_books_single_request(): m = 2 books = [('book1', 1), ('book2', 1)] n = 1 requests = [['book1', 'book2']] assert max_satisfied_requests(m, books, n, requests) == 1 def test_not_enough_books(): m = 2 books = [('book1', 1), ('book2', 1)] n = 2 requests = [['book1', 'book2'], ['book1', 'book2']] assert max_satisfied_requests(m, books, n, requests) == 1 def test_partial_fulfillment(): m = 3 books = [('book1', 2), ('book2', 1), ('book3', 1)] n = 4 requests = [['book1'], ['book2'], ['book3'], ['book1', 'book3']] assert max_satisfied_requests(m, books, n, requests) == 3 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_satisfied_requests(m, books, n, requests): from collections import defaultdict book_count = defaultdict(int) for book, count in books: book_count[book] += count satisfied_requests = 0 for request in requests: temp_count = book_count.copy() can_fulfill = True for book in request: if temp_count[book] > 0: temp_count[book] -= 1 else: can_fulfill = False break if can_fulfill: satisfied_requests += 1 book_count = temp_count return satisfied_requests # Example Usage # m = 3, books = [('book1', 2), ('book2', 1), ('book3', 5)], n = 4, # requests = [['book1', 'book2'], ['book1', 'book3', 'book2'], ['book3'], ['book1', 'book3']] # max_satisfied_requests(m, books, n, requests) should return 3"},{"question":"def determine_season(days: int) -> str: Determines the type of season based on the given number of days. >>> determine_season(35) 'perfect' >>> determine_season(14) 'sunny' >>> determine_season(20) 'rainy' >>> determine_season(8) 'cloudy'","solution":"def determine_season(days): Determines the type of season based on the given number of days. if days % 35 == 0: return \\"perfect\\" elif days % 7 == 0: return \\"sunny\\" elif days % 5 == 0: return \\"rainy\\" else: return \\"cloudy\\""},{"question":"def max_bridges(N, north_coords, M, south_coords): Given coordinates of houses on the north and south banks, determine the maximum number of bridges that can be built without any two of them crossing each other. Args: N (int): Number of houses on the north bank. north_coords (List[int]): x-coordinates of houses on the north bank. M (int): Number of houses on the south bank. south_coords (List[int]): x-coordinates of houses on the south bank. Returns: int: Maximum number of bridges that can be built without crossing each other. >>> max_bridges(4, [1, 3, 5, 7], 5, [2, 4, 6, 8, 10]) 4 >>> max_bridges(3, [2, 4, 6], 4, [1, 3, 5, 7]) 3 >>> max_bridges(5, [1, 2, 3, 4, 5], 3, [2, 4, 6]) 3 pass def parse_input(input_str): Parses the input string into variables N, north_coords, M, and south_coords. Args: input_str (str): Input in specific format. Returns: Tuple: Parsed values (N, north_coords, M, south_coords) >>> parse_input(\\"3 1 3 5n2 2 4\\") (3, [1, 3, 5], 2, [2, 4]) pass def main(input_str): Main function to handle input parsing and function calling. Args: input_str (str): Input in specific format. Returns: int: Maximum number of bridges that can be built without crossing each other. >>> main(\\"4 1 3 5 7n5 2 4 6 8 10\\") 4 >>> main(\\"3 2 4 6n4 1 3 5 7\\") 3 >>> main(\\"5 1 2 3 4 5n3 2 4 6\\") 3 pass # Unit tests def test_max_bridges_example1(): input_str = \\"4 1 3 5 7n5 2 4 6 8 10\\" assert main(input_str) == 4 def test_max_bridges_example2(): input_str = \\"3 2 4 6n4 1 3 5 7\\" assert main(input_str) == 3 def test_max_bridges_example3(): input_str = \\"5 1 2 3 4 5n3 2 4 6\\" assert main(input_str) == 3 def test_max_bridges_case1(): input_str = \\"2 1 3n3 2 4 6\\" assert main(input_str) == 2 def test_max_bridges_case2(): input_str = \\"3 1 3 5n2 2 4\\" assert main(input_str) == 2 def test_max_bridges_case3(): input_str = \\"3 1 2 3n1 4\\" assert main(input_str) == 1 def test_parse_input(): input_str = \\"3 1 3 5n2 2 4\\" N, north_coords, M, south_coords = parse_input(input_str) assert N == 3 assert north_coords == [1, 3, 5] assert M == 2 assert south_coords == [2, 4]","solution":"def max_bridges(N, north_coords, M, south_coords): Given coordinates of houses on the north and south banks, determine the maximum number of bridges that can be built without any two of them crossing each other. north_coords.sort() south_coords.sort() i, j = 0, 0 max_bridges = 0 while i < N and j < M: if north_coords[i] <= south_coords[j]: max_bridges += 1 i += 1 j += 1 else: j += 1 return max_bridges def parse_input(input_str): Parses the input string into variables N, north_coords, M, and south_coords. lines = input_str.strip().split(\\"n\\") north_data = list(map(int, lines[0].split())) N = north_data[0] north_coords = north_data[1:] south_data = list(map(int, lines[1].split())) M = south_data[0] south_coords = south_data[1:] return N, north_coords, M, south_coords def main(input_str): N, north_coords, M, south_coords = parse_input(input_str) return max_bridges(N, north_coords, M, south_coords)"},{"question":"import math from typing import List def count_permutations(n: int, a: List[int]) -> int: Returns the number of different permutations of the original list by splitting it into sublists and rearranging them. Args: n (int): The number of elements in the list. a (List[int]): The list of integers. Returns: int: The number of different permutations of the original list. Example: >>> count_permutations(4, [1, 2, 3, 4]) 24 >>> count_permutations(3, [5, 6, 7]) 6 >>> count_permutations(5, [9, 9, 8, 8, 7]) 120","solution":"import math def count_permutations(n, a): Returns the number of different permutations of the original list by splitting it into sublists and rearranging them. return math.factorial(n)"},{"question":"from typing import List, Tuple def count_paths_dag(n: int, edges: List[Tuple[int, int]]) -> int: You are given a directed acyclic graph (DAG) with n nodes and m edges. The nodes are labeled from 1 to n. Your task is to find the number of distinct paths from node 1 to node n. Path specification should not contain repeat nodes. Parameters: n (int): The number of nodes in the graph. edges (List[Tuple[int, int]]): The list of directed edges in the graph. Returns: int: The number of distinct paths from node 1 to node n. Examples: >>> count_paths_dag(5, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)]) 3 >>> count_paths_dag(4, [(1, 2), (2, 3), (3, 4)]) 1","solution":"def count_paths_dag(n, edges): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Topological sort using Kahn's algorithm topo_sorted = [] queue = deque([i for i in range(1, n+1) if in_degree[i] == 0]) while queue: node = queue.popleft() topo_sorted.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Dynamic Programming to count paths path_count = {i: 0 for i in range(1, n+1)} path_count[1] = 1 # There is one way to start at the source for node in topo_sorted: for neighbor in graph[node]: path_count[neighbor] += path_count[node] return path_count[n]"},{"question":"def max_consecutive_increasing_days(temperatures): Given an array of integers representing temperatures on different days, this function finds the maximum number of consecutive days where the temperature increases. Args: temperatures (list): A list of integers representing the temperatures. Returns: int: Maximum number of consecutive days with increasing temperatures. Examples: >>> max_consecutive_increasing_days([30, 31, 32, 33, 34]) 4 >>> max_consecutive_increasing_days([31, 31, 30, 29]) 0 >>> max_consecutive_increasing_days([34, 35, 35, 36, 37, 38]) 3","solution":"def max_consecutive_increasing_days(temperatures): Given an array of integers representing temperatures on different days, this function finds the maximum number of consecutive days where the temperature increases. Args: temperatures (list): A list of integers representing the temperatures. Returns: int: Maximum number of consecutive days with increasing temperatures. if not temperatures: return 0 max_count = 0 current_count = 0 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def most_frequent_character(text): Returns the most frequently occurring character in the string. If there are ties, returns the character that appears first. >>> most_frequent_character(\\"a\\") 'a' >>> most_frequent_character(\\"abcabc\\") 'a' >>> most_frequent_character(\\"AttentIOn\\") 't' >>> most_frequent_character(\\"aabbcc\\") 'a' >>> most_frequent_character(\\"bbaa\\") 'b' >>> most_frequent_character(\\"aaAA\\") 'a' >>> most_frequent_character(\\"a1!a1!\\") 'a'","solution":"def most_frequent_character(text): Returns the most frequently occurring character in the string. If there are ties, returns the character that appears first. frequency = {} for char in text: lower_char = char.lower() if lower_char in frequency: frequency[lower_char] += 1 else: frequency[lower_char] = 1 max_frequency = 0 most_frequent_char = None for char in text: lower_char = char.lower() if frequency[lower_char] > max_frequency: max_frequency = frequency[lower_char] most_frequent_char = char return most_frequent_char"},{"question":"def count_pairs_with_difference(arr, k): Counts pairs (i, j) such that i < j and the absolute difference between the elements at those indices is k. >>> count_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference([1, 2, 3], 1) 2 >>> count_pairs_with_difference([1, 6, 11, 16], 5) 3 >>> count_pairs_with_difference([1, 1, 1, 1], 0) 6 >>> count_pairs_with_difference([1, 1, 1, 1], 1) 0 def process_test_cases(test_cases): Processes multiple test cases. >>> process_test_cases([(5, 2, [1, 5, 3, 4, 2]), (3, 1, [1, 2, 3]), (4, 5, [1, 6, 11, 16])]) [3, 2, 3]","solution":"def count_pairs_with_difference(arr, k): Counts pairs (i, j) such that i < j and the absolute difference between the elements at those indices is k. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) == k: count += 1 return count def process_test_cases(test_cases): Processes multiple test cases. results = [] for n, k, arr in test_cases: results.append(count_pairs_with_difference(arr, k)) return results"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> str: Determines if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. Args: nums (list of int): The array of integers. k (int): The maximum allowed index difference. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\". Examples: >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) \\"NO\\" >>> contains_nearby_duplicate([1, 0, 1, 1, 2, 3], 1) \\"YES\\"","solution":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. Args: nums (list of int): The array of integers. k (int): The maximum allowed index difference. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\". index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return \\"YES\\" index_map[num] = i return \\"NO\\""},{"question":"from collections import deque def min_moves_to_reach_target(n, m, grid, s_x, s_y, t_x, t_y): Determine the minimum number of moves needed for the robot to reach the target position on the grid. Returns -1 if the target is unreachable. n: int : number of rows in the grid m: int : number of columns in the grid grid: List[str] : list of strings representing the grid s_x: int : start position x-coordinate s_y: int : start position y-coordinate t_x: int : target position x-coordinate t_y: int : target position y-coordinate >>> min_moves_to_reach_target(5, 5, [\\"..#..\\", \\"..#..\\", \\".....\\", \\"#..\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves_to_reach_target(5, 5, [\\"..#..\\", \\"..#..\\", \\".....\\", \\"#..\\", \\".....\\"], 1, 1, 3, 3) -1 >>> min_moves_to_reach_target(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"], 1, 1, 1, 2) 1 >>> min_moves_to_reach_target(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"], 2, 2, 2, 2) 0 >>> min_moves_to_reach_target(5, 5, [\\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\"], 0, 0, 4, 4) -1","solution":"from collections import deque def min_moves_to_reach_target(n, m, grid, s_x, s_y, t_x, t_y): Determine the minimum number of moves needed for the robot to reach the target position on the grid. Returns -1 if the target is unreachable. if grid[s_x][s_y] == '#' or grid[t_x][t_y] == '#': return -1 # BFS setup queue = deque([(s_x, s_y, 0)]) visited = set((s_x, s_y)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: x, y, moves = queue.popleft() if (x, y) == (t_x, t_y): return moves for d_x, d_y in directions: new_x, new_y = x + d_x, y + d_y if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': visited.add((new_x, new_y)) queue.append((new_x, new_y, moves + 1)) return -1"},{"question":"def rotateArrayByOne(arr): Returns the array after cyclically rotating it by one position to the right. Example 1: >>> rotateArrayByOne([1, 2, 3, 4, 5]) [5, 1, 2, 3, 4] Example 2: >>> rotateArrayByOne([10, 20, 30, 40]) [40, 10, 20, 30] def test_rotate_empty_array(): assert rotateArrayByOne([]) == [] def test_rotate_single_element_array(): assert rotateArrayByOne([1]) == [1] def test_rotate_multiple_elements_array(): assert rotateArrayByOne([1, 2, 3, 4, 5]) == [5, 1, 2, 3, 4] assert rotateArrayByOne([10, 20, 30, 40]) == [40, 10, 20, 30] assert rotateArrayByOne([1, 2, 3]) == [3, 1, 2] def test_rotate_array_with_identical_elements(): assert rotateArrayByOne([7, 7, 7, 7]) == [7, 7, 7, 7]","solution":"def rotateArrayByOne(arr): Returns the array after cyclically rotating it by one position to the right. if not arr: return [] last_element = arr.pop() arr.insert(0, last_element) return arr"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping tasks that can be completed. Args: tasks: A list of tuples where each tuple contains two integers representing the start and end times of tasks. Returns: An integer representing the maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 7), (5, 8)]) 3 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 5)]) 3 import sys input = sys.stdin.read def read_input_and_compute_max_tasks(): data = input().split() n = int(data[0]) tasks = [] for i in range(n): start = int(data[2 * i + 1]) end = int(data[2 * i + 2]) tasks.append((start, end)) return max_non_overlapping_tasks(tasks)","solution":"def max_non_overlapping_tasks(tasks): tasks.sort(key=lambda x: x[1]) # Sort by end time count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count def read_input_and_compute_max_tasks(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) tasks = [] for i in range(n): start = int(data[2 * i + 1]) end = int(data[2 * i + 2]) tasks.append((start, end)) return max_non_overlapping_tasks(tasks)"},{"question":"def longest_subarray_with_bitwise_and_greater_than_zero(n: int, arr: List[int]) -> int: Find the length of the longest subarray such that the bitwise AND of all elements in this subarray is greater than zero. >>> longest_subarray_with_bitwise_and_greater_than_zero(3, [4, 2, 8]) 1 >>> longest_subarray_with_bitwise_and_greater_than_zero(5, [18, 22, 14, 11, 8]) 4","solution":"def longest_subarray_with_bitwise_and_greater_than_zero(n, arr): max_length = 0 current_length = 0 current_and = None for num in arr: if num == 0: current_and = None current_length = 0 else: if current_and is None: current_and = num else: current_and &= num if current_and > 0: current_length += 1 else: current_length = 0 current_and = None max_length = max(max_length, current_length) return max_length"},{"question":"def combination_sum(nums, target): Returns all unique combinations of \`nums\` where the chosen numbers sum to \`target\`. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] def process_test_cases(t, test_cases): Processes multiple test cases to find unique combinations of \`nums\` that sum up to \`target\`. Args: - t (int): Number of test cases. - test_cases (List[Tuple[int, int, List[int]]]): List of test case tuples, each containing \`n\`, \`target\`, and \`nums\`. Returns: List of strings, each containing the combinations for a test case. >>> process_test_cases(2, [(4, 7, [2, 3, 6, 7]), (3, 8, [2, 3, 5])]) [\\"2 2 3n7\\", \\"2 2 2 2n2 3 3n3 5\\"]","solution":"def combination_sum(nums, target): def backtrack(remaining, comb, start): if remaining == 0: results.append(list(comb)) return elif remaining < 0: return for i in range(start, len(nums)): comb.append(nums[i]) backtrack(remaining - nums[i], comb, i) comb.pop() results = [] backtrack(target, [], 0) return results def process_test_cases(t, test_cases): results = [] for case in test_cases: n, target, nums = case combinations = combination_sum(nums, target) if combinations: case_result = \\"n\\".join(\\" \\".join(map(str, comb)) for comb in combinations) else: case_result = \\"No combination\\" results.append(case_result) return results"},{"question":"import heapq from typing import List, Tuple def find_min_delivery_times(N: int, M: int, roads: List[Tuple[int, int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Returns the minimum delivery times for each query from cities C1 to C2. If no route exists, returns -1 for that query. Args: N : int : Number of cities. M : int : Number of roads. roads : List[Tuple[int, int, int]] : List of roads where each road is represented by a tuple (u, v, w) denoting a road from city u to city v with weight w. Q : int : Number of queries. queries : List[Tuple[int, int]] : List of queries where each query is represented by a tuple (C1, C2) denoting the cities to find the delivery time between. Returns: List[int] : List of minimum delivery times for each query. If no route exists, returns -1. >>> find_min_delivery_times(5, 6, [(1, 2, 2), (2, 4, 1), (1, 3, 4), (3, 4, 3), (2, 3, 2), (4, 5, 2)], 3, [(1, 5), (2, 3), (3, 5)]) [5, 2, 5] >>> find_min_delivery_times(4, 2, [(1, 2, 1), (3, 4, 1)], 2, [(1, 4), (2, 3)]) [-1, -1] >>> find_min_delivery_times(3, 3, [(1, 2, 5), (2, 3, 10), (3, 1, 2)], 3, [(1, 1), (2, 2), (3, 3)]) [0, 0, 0] >>> find_min_delivery_times(3, 2, [(1, 2, 3), (2, 3, 4)], 2, [(1, 2), (1, 3)]) [3, 7] >>> find_min_delivery_times(4, 5, [(1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1), (1, 4, 5)], 2, [(1, 4), (2, 4)]) [3, 3]","solution":"import heapq import sys def dijkstra(graph, start): Runs Dijkstra's algorithm on the given graph with the starting node. Returns the shortest path distances from the start node to all others. distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_min_delivery_times(N, M, roads, Q, queries): Returns the minimum delivery times for each query from cities C1 to C2. If no route exists, returns -1 for that query. # Create graph from road data graph = {i: {} for i in range(1, N+1)} for u, v, w in roads: if v in graph[u]: graph[u][v] = min(graph[u][v], w) else: graph[u][v] = w if u in graph[v]: graph[v][u] = min(graph[v][u], w) else: graph[v][u] = w # Store results of Dijkstra's to avoid recomputation min_times = {} results = [] for C1, C2 in queries: if C1 == C2: results.append(0) continue if C1 not in min_times: min_times[C1] = dijkstra(graph, C1) min_time = min_times[C1].get(C2, float('inf')) if min_time == float('inf'): results.append(-1) else: results.append(min_time) return results"},{"question":"from typing import List, Tuple def min_subarray_to_sort(arr: List[int]) -> int: Find the minimum length of the subarray that needs to be sorted to make the entire array sorted. >>> min_subarray_to_sort([1, 3, 2]) 2 >>> min_subarray_to_sort([1, 2, 3, 4, 5]) 0 >>> min_subarray_to_sort([5, 6, 3, 4, 8, 9]) 4 >>> min_subarray_to_sort([1, 3, 5, 7, 2, 6, 8]) 5 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases of the min_subarray_to_sort function. >>> process_test_cases([(3, [1, 3, 2]), (5, [1, 2, 3, 4, 5]), (6, [5, 6, 3, 4, 8, 9]), (7, [1, 3, 5, 7, 2, 6, 8])]) [2, 0, 4, 5] pass","solution":"def min_subarray_to_sort(arr): n = len(arr) left, right = 0, n - 1 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 if left == n - 1: return 0 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 min_val = min(arr[left:right+1]) max_val = max(arr[left:right+1]) while left > 0 and arr[left - 1] > min_val: left -= 1 while right < n - 1 and arr[right + 1] < max_val: right += 1 return right - left + 1 def process_test_cases(test_cases): results = [] for case in test_cases: _, arr = case results.append(min_subarray_to_sort(arr)) return results # Example usage example_test_cases = [ (3, [1, 3, 2]), (5, [1, 2, 3, 4, 5]), (6, [5, 6, 3, 4, 8, 9]), (7, [1, 3, 5, 7, 2, 6, 8]) ] print(process_test_cases(example_test_cases))"},{"question":"def count_ways(T: int, cases: List[int]) -> List[int]: Write a program to help an artist combine different types of rectangular tiles to create a one-dimensional artwork. The artist has three types of tiles: - Type A of size 1x1 - Type B of size 1x2 - Type C of size 1x3 The artist wants to know in how many different ways they can fill a row of length N using any combination of these three types of tiles. The function takes the length N as input and outputs the number of unique ways to fill the row for each test case, modulo 10^9 + 7. Args: T (int): number of test cases. cases (List[int]): list of integers representing the length of the row for each test case. Returns: List[int]: list of integers representing the number of unique ways to fill the row for each test case, modulo 10^9 + 7. Example: >>> count_ways(2, [3, 4]) [4, 7] >>> count_ways(1, [1000]) [695376169] >>> count_ways(1, [1]) [1]","solution":"MOD = 10**9 + 7 def count_ways(T, cases): max_n = max(cases) dp = [0] * (max_n + 1) dp[0] = 1 # There's one way to fill a row of length 0 - doing nothing. if max_n >= 1: dp[1] = 1 # Only one way to fill a row of length 1 - with one 1x1 tile. if max_n >= 2: dp[2] = 2 # Two ways to fill a row of length 2 - with two 1x1 tiles or one 1x2 tile. if max_n >= 3: dp[3] = 4 # Four ways to fill a row of length 3: # (1) Three 1x1 tiles # (2) One 1x1 tile + one 1x2 tile # (3) one 1x2 tile + one 1x1 tile # (4) one 1x3 tile # Calculate number of ways for lengths from 4 to max_n for i in range(4, max_n + 1): dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD result = [] for n in cases: result.append(dp[n]) return result"},{"question":"def has_duplicate(n: int, arr: List[int]) -> str: Determines if there are any duplicate numbers in the list arr. Args: n : int : Number of elements in the list. arr : List[int] : List of integers. Returns: str : \\"Yes\\" if there are duplicates, otherwise \\"No\\". >>> has_duplicate(5, [1, 2, 3, 4, 5]) \\"No\\" >>> has_duplicate(6, [1, 2, 3, 1, 4, 5]) \\"Yes\\"","solution":"def has_duplicate(n, arr): Determines if there are any duplicate numbers in the list arr. Args: n : int : Number of elements in the list. arr : list : List of integers. Returns: str : \\"Yes\\" if there are duplicates, otherwise \\"No\\". seen = set() for num in arr: if num in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def is_monotonic(A: List[int]) -> bool: Determines whether the array A is monotonic (either entirely non-increasing or non-decreasing). Args: A : list of int Returns: bool : True if the array is monotonic, False otherwise. >>> is_monotonic([1, 2, 2, 3, 4]) True >>> is_monotonic([6, 5, 5, 2]) True >>> is_monotonic([1, 3, 2]) False import pytest def test_increasing_array(): assert is_monotonic([1, 2, 2, 3, 4]) == True def test_decreasing_array(): assert is_monotonic([6, 5, 5, 2]) == True def test_non_monotonic_array(): assert is_monotonic([1, 3, 2]) == False def test_single_element_array(): assert is_monotonic([1]) == True def test_all_equal_elements(): assert is_monotonic([5, 5, 5, 5]) == True def test_empty_array(): assert is_monotonic([]) == True def test_large_non_monotonic_array(): assert is_monotonic([1, 2, 3, 4, 3, 2, 1]) == False def test_edge_case_min_max_values(): assert is_monotonic([-1000000000, 0, 1000000000]) == True assert is_monotonic([1000000000, 0, -1000000000]) == True assert is_monotonic([1000000000, 1000000000, 1000000000]) == True","solution":"def is_monotonic(A): Determines whether the array A is monotonic. Args: A : list of int Returns: bool : True if the array is monotonic, False otherwise. if not A: return True increasing = decreasing = True for i in range(len(A) - 1): if A[i] < A[i + 1]: decreasing = False if A[i] > A[i + 1]: increasing = False return increasing or decreasing # Example inputs for testing: # n = 5 # A = [1, 2, 2, 3, 4] # Output: True # n = 4 # A = [6, 5, 5, 2] # Output: True # n = 3 # A = [1, 3, 2] # Output: False"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. Parameters: s (str): A string representing a Roman numeral. Returns: int: The integer representation of the Roman numeral. Examples: >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994 pass","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. Parameters: s (str): A string representing a Roman numeral. Returns: int: The integer representation of the Roman numeral. # Define a dictionary to map Roman numerals to their integer values roman_to_integer = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_integer[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def rearrange_odds_evens(arr): Rearranges an array of integers so that all odd numbers appear before all even numbers, while preserving the relative order of the odd and even numbers from the original array. :param arr: List of integers :return: New list with odd numbers before even numbers, maintaining relative order >>> rearrange_odds_evens([1, 2, 3, 4, 5, 6]) [1, 3, 5, 2, 4, 6] >>> rearrange_odds_evens([6, 7, 5, 8, 9]) [7, 5, 9, 6, 8] >>> rearrange_odds_evens([]) [] >>> rearrange_odds_evens([2]) [2]","solution":"def rearrange_odds_evens(arr): Rearranges an array of integers so that all odd numbers appear before all even numbers, while preserving the relative order of the odd and even numbers from the original array. :param arr: List of integers :return: New list with odd numbers before even numbers, maintaining relative order odds = [x for x in arr if x % 2 != 0] evens = [x for x in arr if x % 2 == 0] return odds + evens"},{"question":"def find_peaks(n: int, heights: List[int]) -> List[int]: Identifies the indices of mountains that are higher than their neighbors. :param n: Number of mountains :param heights: List of integers representing the heights of mountains. :return: List of indices of mountains that qualify as peaks. >>> find_peaks(5, [1, 3, 2, 4, 2]) [1, 3] >>> find_peaks(1, [1]) [0] >>> find_peaks(3, [3, 1, 3]) [0, 2] >>> find_peaks(5, [1, 2, 3, 4, 5]) [4] >>> find_peaks(5, [5, 4, 3, 2, 1]) [0] >>> find_peaks(7, [1, 2, 1, 3, 1, 2, 1]) [1, 3, 5] >>> find_peaks(5, [2, 1, 2, 1, 2]) [0, 2, 4] >>> find_peaks(3, [2, 2, 2]) [] >>> find_peaks(4, [1, 2, 2, 1]) []","solution":"def find_peaks(n, heights): Identifies the indices of mountains that are higher than their neighbors. :param n: Number of mountains :param heights: List of integers representing the heights of mountains. :return: List of indices of mountains that qualify as peaks. peaks = [] # Edge case for when there is only one mountain if n == 1: return [0] for i in range(n): # Check if the mountain at index i is a peak if (i == 0 and heights[i] > heights[i + 1]) or (i == n - 1 and heights[i] > heights[i - 1]) or (0 < i < n - 1 and heights[i] > heights[i - 1] and heights[i] > heights[i + 1]): peaks.append(i) return peaks"},{"question":"def shortest_palindrome(s: str) -> str: Transforms the given string into a palindrome by adding the minimum number of characters in front of it. >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\"","solution":"def shortest_palindrome(s): Transforms the given string into a palindrome by adding the minimum number of characters in front of it. if s == s[::-1]: return s n = len(s) # Compute the temporary string to apply KMP on temp = s + \\"#\\" + s[::-1] lps = [0] * len(temp) # KMP preprocessing to create LPS array i = 1 length = 0 while i < len(temp): if temp[i] == temp[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 # The last value of the LPS array gives us the count of characters from the start # that are part of the longest palindromic suffix. characters_to_add = s[(lps[-1]):][::-1] palindrome = characters_to_add + s return palindrome"},{"question":"def min_street_lamps(T: int, cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of street lamps required to cover the entire road from position 0 to position N. Args: T: Number of test cases. cases: A list containing T elements, where each element is a tuple with three values (M, N, lamps). M is the number of street lamps, N is the length of the road, and lamps is a list of tuples (P, R) where P is the position of a street lamp and R is its illumination range. Returns: A list of integers where each integer represents the minimum number of street lamps required to cover the entire road for each test case. If it’s not possible to cover the entire road with the given street lamps, return -1 for that test case. Example: >>> min_street_lamps(2, [(3, 10, [(1, 5), (5, 3), (8, 2)]), (4, 20, [(2, 8), (5, 7), (13, 3), (18, 5)])]) [2, 3] >>> min_street_lamps(1, [(0, 10, [])]) [-1] >>> min_street_lamps(1, [(2, 10, [(1, 1), (3, 1)])]) [-1] >>> min_street_lamps(1, [(3, 10, [(2, 2), (5, 2), (8, 2)])]) [3] >>> min_street_lamps(1, [(3, 10, [(2, 5), (5, 5), (8, 5)])]) [1] >>> min_street_lamps(1, [(1, 100, [(50, 100)])]) [1]","solution":"def min_street_lamps(T, cases): results = [] for case in cases: M, N, lamps = case intervals = [] for P, R in lamps: start = max(0, P - R) end = min(N, P + R) intervals.append((start, end)) intervals.sort() res = 0 idx = 0 current_end = 0 next_end = 0 while idx < len(intervals) and current_end < N: if intervals[idx][0] > current_end: break while idx < len(intervals) and intervals[idx][0] <= current_end: next_end = max(next_end, intervals[idx][1]) idx += 1 res += 1 current_end = next_end if current_end >= N: break if current_end < N: results.append(-1) else: results.append(res) return results # Function to parse input and invoke the min_street_lamps function def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) current_line = 1 cases = [] for _ in range(T): M, N = map(int, lines[current_line].split()) current_line += 1 lamps = [] for _ in range(M): P, R = map(int, lines[current_line].split()) lamps.append((P, R)) current_line += 1 cases.append((M, N, lamps)) return min_street_lamps(T, cases)"},{"question":"from typing import List def longest_homogeneous_substring_length(S: str) -> int: Returns the length of the longest homogeneous substring in S. >>> longest_homogeneous_substring_length(\\"aabbbcc\\") 3 >>> longest_homogeneous_substring_length(\\"aaaa\\") 4 >>> longest_homogeneous_substring_length(\\"abcde\\") 1 pass def process_test_cases(T: int, cases: List[str]) -> List[int]: Processes multiple test cases for longest_homogeneous_substring_length. Parameters: - T: integer, number of test cases - cases: list of strings, each string is a test case Returns: - list of integers, each integer is the result for the respective test case pass import pytest def test_longest_homogeneous_substring_length(): assert longest_homogeneous_substring_length(\\"aabbbcc\\") == 3 assert longest_homogeneous_substring_length(\\"aaaa\\") == 4 assert longest_homogeneous_substring_length(\\"abcde\\") == 1 assert longest_homogeneous_substring_length(\\"a\\") == 1 assert longest_homogeneous_substring_length(\\"bbbbb\\") == 5 assert longest_homogeneous_substring_length(\\"aabbaaaccc\\") == 3 def test_process_test_cases(): T = 3 cases = [\\"aabbbcc\\", \\"aaaa\\", \\"abcde\\"] expected_results = [3, 4, 1] assert process_test_cases(T, cases) == expected_results T = 2 cases = [\\"a\\", \\"bbbbb\\"] expected_results = [1, 5] assert process_test_cases(T, cases) == expected_results T = 1 cases = [\\"aabbaaaccc\\"] expected_results = [3] assert process_test_cases(T, cases) == expected_results if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_homogeneous_substring_length(S): Returns the length of the longest homogeneous substring in S. max_length = 1 current_length = 1 for i in range(1, len(S)): if S[i] == S[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length def process_test_cases(T, cases): Processes multiple test cases for longest_homogeneous_substring_length. Parameters: - T: integer, number of test cases - cases: list of strings, each string is a test case Returns: - list of integers, each integer is the result for the respective test case results = [] for S in cases: results.append(longest_homogeneous_substring_length(S)) return results"},{"question":"def calculate_points(n: int, submissions: List[int]) -> int: Calculate the total points for a team based on the sequence of correct submissions. Parameters: n (int): The number of submissions. submissions (list): List of integers indicating if a submission is correct (1) or incorrect (0). Returns: int: The total points scored by the team. >>> calculate_points(5, [1, 0, 1, 1, 0]) 270 >>> calculate_points(5, [1, 1, 1, 1, 1]) 400 >>> calculate_points(5, [0, 0, 0, 0, 0]) 0 >>> calculate_points(7, [0, 1, 0, 1, 0, 1, 0]) 270 >>> calculate_points(3, [0, 1, 0]) 100 >>> calculate_points(4, [1, 1, 0, 0]) 190 >>> calculate_points(4, [0, 0, 1, 1]) 190","solution":"def calculate_points(n, submissions): Calculate the total points for a team based on the sequence of correct submissions. Parameters: n (int): The number of submissions. submissions (list): List of integers indicating if a submission is correct (1) or incorrect (0). Returns: int: The total points scored by the team. points = 0 current_points = 100 for submission in submissions: if submission == 1: points += current_points current_points -= 10 return points"},{"question":"def total_elevation_gains(hikes: List[List[int]]) -> List[int]: Calculates the total elevation gain for each hike from the list of elevation changes. >>> total_elevation_gains([[5, -2, 3, 0, 4], [4, 4, -1, 0, -3], [0, -2, 2, 5, -1]]) [12, 8, 7] >>> total_elevation_gains([[1, 2, 3, 4], [10, 20, 30]]) [10, 60] >>> total_elevation_gains([[-1, -2, -3, -4], [-10, -20, -30]]) [0, 0] >>> total_elevation_gains([[-5, 3, -1, 0, 4], [2, -2, 5, -5, 3]]) [7, 10] >>> total_elevation_gains([[0, 0, 0], [0]]) [0, 0] >>> total_elevation_gains([[5], [-3], [0]]) [5, 0, 0] >>> total_elevation_gains([[], []]) [0, 0]","solution":"def total_elevation_gains(hikes): Calculates the total elevation gain for each hike from the list of elevation changes. Parameters: hikes (list of list of int): List of lists where each list represents the elevation changes in a hike. Returns: list of int: List of total elevation gains for each hike. gains = [] for hike in hikes: gain = sum(change for change in hike if change > 0) gains.append(gain) return gains"},{"question":"def almost_palindrome(M: int, T: str) -> str: Determine if the string T can be classified as an \\"almost palindrome\\" by changing exactly one character. Parameters: M (int): The length of the string T. T (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be converted to a palindrome by changing exactly one character, otherwise \\"NO\\". >>> almost_palindrome(5, \\"abcca\\") == \\"YES\\" >>> almost_palindrome(6, \\"abcdef\\") == \\"NO\\" >>> almost_palindrome(1, \\"a\\") == \\"YES\\"","solution":"def almost_palindrome(M, T): Determine if the string T can be classified as an \\"almost palindrome\\" by changing exactly one character. Parameters: M (int): The length of the string T. T (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be converted to a palindrome by changing exactly one character, otherwise \\"NO\\". # Counter to keep track of mismatches mismatch_counter = 0 # Iterate from start and end towards the middle to check mismatches for i in range(M // 2): if T[i] != T[M - 1 - i]: mismatch_counter += 1 # If there are more than one mismatch, it cannot be \\"almost palindrome\\" if mismatch_counter > 1: return \\"NO\\" # If there's exactly one mismatch, or # If no mismatches found for odd-length strings, they can still be almost palindrome if mismatch_counter == 1 or (mismatch_counter == 0 and M % 2 == 1): return \\"YES\\" else: return \\"NO\\""},{"question":"def can_distribute_apples_evenly(n: int) -> str: Determines if it is possible to distribute n apples so that each person gets at least one apple, and each gets an even number of apples. Parameters: n (int): The total number of apples. Returns: str: \\"YES\\" if the distribution is possible, otherwise \\"NO\\". >>> can_distribute_apples_evenly(4) \\"YES\\" >>> can_distribute_apples_evenly(5) \\"NO\\"","solution":"def can_distribute_apples_evenly(n): Determines if it is possible to distribute n apples so that each person gets at least one apple, and each gets an even number of apples. Parameters: n (int): The total number of apples. Returns: str: \\"YES\\" if the distribution is possible, otherwise \\"NO\\". # n must be at least 4 since each needs to get an even number and >= 2 each if n >= 4 and n % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def lengthOfLIS(arr): Returns the length of the longest increasing subsequence in the given array. >>> lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> lengthOfLIS([10]) 1 >>> lengthOfLIS([]) 0 >>> lengthOfLIS([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> lengthOfLIS([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> lengthOfLIS([3, 10, 2, 1, 20]) 3 >>> lengthOfLIS([50, 3, 10, 7, 40, 80]) 4 >>> lengthOfLIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"def lengthOfLIS(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"from typing import List, Tuple def max_subarray_sum(datasets: List[Tuple[int, int, List[int]]]) -> List[int]: Given a list of datasets, where each dataset consists of an integer N (number of elements), an integer L (length of the subarray), and a list of N integers, find the maximum possible sum of a subarray of length L for each dataset. >>> datasets = [(5, 3, [1, 2, 3, 4, 5]), (8, 4, [-1, -2, -3, -4, 1, 2, 3, 4])] >>> max_subarray_sum(datasets) [12, 10] def parse_input(input_str: str) -> List[Tuple[int, int, List[int]]]: Parse the input string and convert it to a list of datasets, where each dataset is a tuple consisting of an integer N (number of elements), an integer L (length of the subarray), and a list of N integers. >>> input_str = \\"5 3n1 2 3 4 5n8 4n-1 -2 -3 -4 1 2 3 4n0\\" >>> parse_input(input_str) [(5, 3, [1, 2, 3, 4, 5]), (8, 4, [-1, -2, -3, -4, 1, 2, 3, 4])] from max_subarray_sum import max_subarray_sum, parse_input def test_max_subarray_sum(): input_str = \\"5 3n1 2 3 4 5n8 4n-1 -2 -3 -4 1 2 3 4n0\\" datasets = parse_input(input_str) results = max_subarray_sum(datasets) assert results == [12, 10] def test_single_element_array(): input_str = \\"1 1n5n0\\" datasets = parse_input(input_str) results = max_subarray_sum(datasets) assert results == [5] def test_all_negative_elements(): input_str = \\"5 2n-1 -2 -3 -4 -5n0\\" datasets = parse_input(input_str) results = max_subarray_sum(datasets) assert results == [-3] def test_large_input(): input_str = \\"1000 500n\\" + \\" \\".join(map(str, range(1000))) + \\"n0\\" datasets = parse_input(input_str) results = max_subarray_sum(datasets) expected_sum = sum(range(500, 1000)) # sum of range 500 to 999 assert results == [expected_sum]","solution":"def max_subarray_sum(datasets): results = [] for data in datasets: N, L, array = data max_sum = float('-inf') for i in range(N - L + 1): current_sum = sum(array[i:i+L]) if current_sum > max_sum: max_sum = current_sum results.append(max_sum) return results def parse_input(input_str): lines = input_str.strip().split('n') datasets = [] i = 0 while i < len(lines): if lines[i] == \\"0\\": break N, L = map(int, lines[i].split()) array = list(map(int, lines[i+1].split())) datasets.append((N, L, array)) i += 2 return datasets"},{"question":"def merge_and_sort_lists(lists): Merge multiple lists and return a sorted list with unique elements. Args: lists (list of list of int): List of lists containing integers Returns: list of int: Sorted list of unique integers Examples: >>> merge_and_sort_lists([[1, 3, 5], [2, 4, 6], [1, 2, 3, 4], [5, 7, 8]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_and_sort_lists([[10, 10, 10], [20, 20, 20], [5, 5, 5]]) [5, 10, 20]","solution":"def merge_and_sort_lists(lists): Merge multiple lists and return a sorted list with unique elements. Args: lists (list of list of int): List of lists containing integers Returns: list of int: Sorted list of unique integers unique_elements = set() # Using a set to automatically handle duplicates for lst in lists: unique_elements.update(lst) # Add all elements of lst to the set return sorted(unique_elements) # Convert set to sorted list and return"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Determine the maximum profit that can be achieved by buying and selling the stock at most twice. >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices or len(prices) < 2: return 0 # Initialize variables for the first and second buys/sells first_buy = float('inf') first_sell = 0 second_buy = float('inf') second_sell = 0 for price in prices: # Update first buy cost first_buy = min(first_buy, price) # Update first sell profit first_sell = max(first_sell, price - first_buy) # Update second buy cost considering profit from first sell second_buy = min(second_buy, price - first_sell) # Update second sell profit second_sell = max(second_sell, price - second_buy) return second_sell"},{"question":"def smallest_subarray_length(n, s, arr): Find the length of the smallest contiguous subarray whose sum is greater than or equal to the target sum. >>> smallest_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> smallest_subarray_length(5, 11, [1, 2, 3, 4, 5]) 3 from solution import smallest_subarray_length def test_example_1(): assert smallest_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 def test_example_2(): assert smallest_subarray_length(5, 11, [1, 2, 3, 4, 5]) == 3 def test_no_valid_subarray(): assert smallest_subarray_length(5, 100, [1, 2, 3, 4, 5]) == 0 def test_entire_array(): assert smallest_subarray_length(5, 15, [1, 2, 3, 4, 5]) == 5 def test_single_element_subarray(): assert smallest_subarray_length(5, 4, [1, 2, 1, 4, 3]) == 1 def test_large_values(): assert smallest_subarray_length(5, 100000, [10000, 20000, 30000, 40000, 50000]) == 3","solution":"def smallest_subarray_length(n, s, arr): min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else 0"},{"question":"def find_heaviest_edge(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Consider a connected undirected graph with n vertices and m edges. Each edge has an integer weight assigned to it. You are to answer the following queries: for each pair of vertices (u, v), find the weight of the heaviest edge on the path from u to v. Parameters: - n (int): number of vertices in the graph - m (int): number of edges in the graph - edges (List[Tuple[int, int, int]]): list of edges where each edge is represented by a tuple (ui, vi, wi) - queries (List[Tuple[int, int]]): list of queries where each query is represented by a tuple (u, v) Returns: - List[int]: a list of integers where each integer corresponds to the weight of the heaviest edge on the path from u to v for each query. If there is no path from u to v, the output should be -1. >>> find_heaviest_edge(5, 4, [(1, 2, 10), (2, 3, 5), (3, 4, 8), (4, 5, 7)], [(1, 5), (2, 4), (1, 3)]) [10, 8, 10] >>> find_heaviest_edge(6, 3, [(1, 2, 4), (2, 3, 2), (4, 5, 3)], [(1, 3), (4, 5), (1, 4)]) [4, 3, -1] >>> find_heaviest_edge(1, 0, [], [(1, 1)]) [-1] >>> find_heaviest_edge(4, 3, [(1, 2, 1000000), (2, 3, 999999), (3, 4, 1000000)], [(1, 4)]) [1000000] pass","solution":"def find_heaviest_edge(n, m, edges, queries): from collections import defaultdict import heapq def build_graph(n, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return graph def dijkstra(graph, start, end, n): heap = [(0, start, -1)] visited = set() max_edge_weight = -1 while heap: cost, node, heaviest = heapq.heappop(heap) if node in visited: continue visited.add(node) if node == end: return heaviest for neighbor, weight in graph[node]: if neighbor not in visited: heapq.heappush(heap, (cost + weight, neighbor, max(heaviest, weight))) return -1 # Build the graph graph = build_graph(n, edges) results = [] for u, v in queries: heaviest_edge = dijkstra(graph, u, v, n) results.append(heaviest_edge) return results # Example usage: n = 5 m = 4 edges = [ (1, 2, 10), (2, 3, 5), (3, 4, 8), (4, 5, 7) ] queries = [ (1, 5), (2, 4), (1, 3) ] print(find_heaviest_edge(n, m, edges, queries)) # Output: [10, 8, 10]"},{"question":"class DictionaryDataStructure: def __init__(self): self.dict = {} def insert(self, key, value): Insert a key-value pair or update the value if the key already exists. pass def delete(self, key): Delete a key-value pair by its key. If the key does not exist, do nothing. pass def search(self, key): Search for a value by its key. If the key does not exist, return -1. pass def process_operations(operations): Processes a series of dictionary operations and returns results for search operations. operations: List of strings representing the operations to be performed. Returns a list of results for each search operation. dds = DictionaryDataStructure() results = [] for op in operations: parts = op.split() if parts[0] == 'I': _, key, value = parts dds.insert(key, int(value)) elif parts[0] == 'D': _, key = parts dds.delete(key) elif parts[0] == 'S': _, key = parts result = dds.search(key) results.append(result) return results # Sample test cases def test_insert_and_search(): operations = [ \\"I apple 5\\", \\"I orange 10\\", \\"S apple\\", \\"S orange\\", \\"S banana\\" ] expected = [5, 10, -1] assert process_operations(operations) == expected def test_delete_operation(): operations = [ \\"I apple 5\\", \\"I orange 10\\", \\"D apple\\", \\"S apple\\", \\"S orange\\" ] expected = [-1, 10] assert process_operations(operations) == expected def test_update_operation(): operations = [ \\"I apple 5\\", \\"I apple 20\\", \\"S apple\\" ] expected = [20] assert process_operations(operations) == expected def test_complex_operations(): operations = [ \\"I apple 5\\", \\"I orange 10\\", \\"S apple\\", \\"D apple\\", \\"S apple\\", \\"S orange\\", \\"I banana 15\\", \\"D orange\\", \\"S orange\\", \\"S banana\\" ] expected = [5, -1, 10, -1, 15] assert process_operations(operations) == expected","solution":"class DictionaryDataStructure: def __init__(self): self.dict = {} def insert(self, key, value): self.dict[key] = value def delete(self, key): if key in self.dict: del self.dict[key] def search(self, key): return self.dict.get(key, -1) def process_operations(operations): dds = DictionaryDataStructure() results = [] for op in operations: parts = op.split() if parts[0] == 'I': _, key, value = parts dds.insert(key, int(value)) elif parts[0] == 'D': _, key = parts dds.delete(key) elif parts[0] == 'S': _, key = parts result = dds.search(key) results.append(result) return results"},{"question":"def winning_strategy(n: int, sequence: List[int]) -> str: Determines whether Yuji has a winning strategy. Parameters: n (int): The length of the sequence. sequence (list): The sequence of integers. Returns: str: The name of the player with the winning strategy, either \\"Yuji\\" or \\"Sato\\". >>> winning_strategy(5, [5, 2, 8, 3, 14]) 'Yuji' >>> winning_strategy(4, [1, 3, 5, 7]) 'Sato'","solution":"def winning_strategy(n, sequence): Determines whether Yuji has a winning strategy. Parameters: n (int): The length of the sequence. sequence (list): The sequence of integers. Returns: str: The name of the player with the winning strategy, either \\"Yuji\\" or \\"Sato\\". even_count = sum(1 for num in sequence if num % 2 == 0) if even_count > 0: return \\"Yuji\\" else: return \\"Sato\\""},{"question":"def digit_root(n: int) -> int: Returns the digit root of a non-negative integer n. >>> digit_root(456) 6 >>> digit_root(942) 6 >>> digit_root(132189) 6 >>> digit_root(5) 5 >>> digit_root(45) 9 >>> digit_root(0) 0 >>> digit_root(1111) 4 >>> digit_root(9999) 9","solution":"def digit_root(n): Returns the digit root of a non-negative integer n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def find_min_diff(n: int, skill_levels: List[int]) -> int: Returns the minimum absolute difference between the sum of skill levels of two teams A and B when optimally divided. :param n: the number of participants :param skill_levels: list of integers representing the skill levels of participants :return: the absolute difference between the sums of the skill levels of two teams Examples: >>> find_min_diff(4, [10, 20, 15, 25]) 0 >>> find_min_diff(6, [1, 6, 11, 5, 10, 15]) 4 from typing import List def test_find_min_diff(): assert find_min_diff(4, [10, 20, 15, 25]) == 0 assert find_min_diff(6, [1, 6, 11, 5, 10, 15]) == 4 assert find_min_diff(2, [1, 2]) == 1 assert find_min_diff(8, [8, 9, 34, 23, 12, 2, 7, 5]) == 0 assert find_min_diff(6, [1, 3, 3, 4, 7, 7]) == 1 test_find_min_diff()","solution":"def find_min_diff(n, skill_levels): Returns the minimum absolute difference between the sum of skill levels of two teams A and B when optimally divided. total_sum = sum(skill_levels) half_n = n // 2 closest_sum = [[False] * (total_sum // 2 + 1) for _ in range(half_n + 1)] closest_sum[0][0] = True for skill in skill_levels: for i in range(half_n, 0, -1): for j in range(total_sum // 2, skill - 1, -1): if closest_sum[i-1][j-skill]: closest_sum[i][j] = True min_diff = float('inf') for i in range(total_sum // 2 + 1): if closest_sum[half_n][i]: team_a_sum = i team_b_sum = total_sum - i min_diff = min(min_diff, abs(team_a_sum - team_b_sum)) return min_diff"},{"question":"def max_unique_in_subarrays(n: int, k: int, arr: List[int]) -> int: Determine the number of unique elements in every contiguous subarray of length k and find the maximum among these counts. >>> max_unique_in_subarrays(7, 4, [1, 2, 1, 3, 4, 2, 3]) 4 >>> max_unique_in_subarrays(5, 3, [1, 1, 1, 1, 1]) 1 >>> max_unique_in_subarrays(5, 3, [1, 2, 3, 4, 5]) 3 >>> max_unique_in_subarrays(10, 5, [1, 2, 1, 3, 4, 2, 5, 6, 7, 8]) 5 >>> max_unique_in_subarrays(1, 1, [1]) 1 >>> max_unique_in_subarrays(2, 1, [1, 2]) 1 >>> max_unique_in_subarrays(2, 2, [1, 1]) 1 >>> max_unique_in_subarrays(2, 2, [1, 2]) 2","solution":"def max_unique_in_subarrays(n, k, arr): from collections import defaultdict unique_count = defaultdict(int) current_unique = 0 max_unique = 0 for i in range(k): if unique_count[arr[i]] == 0: current_unique += 1 unique_count[arr[i]] += 1 max_unique = current_unique for i in range(k, n): if unique_count[arr[i - k]] == 1: current_unique -= 1 unique_count[arr[i - k]] -= 1 if unique_count[arr[i]] == 0: current_unique += 1 unique_count[arr[i]] += 1 max_unique = max(max_unique, current_unique) return max_unique"},{"question":"from typing import List def min_moves_to_deliver(n: int, grid: List[str]) -> int: Computes the minimum number of moves required for the delivery truck to get from the top-left corner to the bottom-right corner in the given grid. :param n: int - the size of the grid :param grid: List[str] - the grid itself :return: int - the minimum number of moves required, or -1 if it is not possible >>> min_moves_to_deliver(5, [\\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\"]) 8 >>> min_moves_to_deliver(3, [\\"...\\", \\"#\\", \\"..#\\"]) -1 >>> min_moves_to_deliver(1, [\\".\\"]) 0 # Your code here if __name__ == \\"__main__\\": import pytest pytest.main() import pytest from solution import min_moves_to_deliver def test_min_moves_ex1(): n = 5 grid = [ \\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\" ] assert min_moves_to_deliver(n, grid) == 8 def test_min_moves_ex2(): n = 3 grid = [ \\"...\\", \\"#\\", \\"..#\\" ] assert min_moves_to_deliver(n, grid) == -1 def test_min_moves_single_cell(): n = 1 grid = [\\".\\"] assert min_moves_to_deliver(n, grid) == 0 def test_min_moves_straight_path(): n = 4 grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert min_moves_to_deliver(n, grid) == 6 def test_min_moves_no_straight_path(): n = 4 grid = [ \\"...#\\", \\".#.#\\", \\".#..\\", \\"#...\\" ] assert min_moves_to_deliver(n, grid) == 6 def test_min_moves_blocked_path(): n = 4 grid = [ \\"....\\", \\".#\\", \\"...#\\", \\"#.\\" ] assert min_moves_to_deliver(n, grid) == -1","solution":"from collections import deque def min_moves_to_deliver(n, grid): Computes the minimum number of moves required for the delivery truck to get from the top-left corner to the bottom-right corner in the given grid. :param n: int - the size of the grid :param grid: List[str] - the grid itself :return: int - the minimum number of moves required, or -1 if it is not possible if n == 1: return 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False]*n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, moves) visited[0][0] = True while queue: row, col, moves = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] == '.': if new_row == n-1 and new_col == n-1: return moves + 1 visited[new_row][new_col] = True queue.append((new_row, new_col, moves + 1)) return -1"},{"question":"from typing import List def digit_to_letter_combinations(digits: str) -> List[str]: Write a function that takes a string of digits and returns all possible strings that can be created by replacing each digit with the corresponding letters on a phone keypad. Example: >>> digit_to_letter_combinations(\\"23\\") ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> digit_to_letter_combinations(\\"2\\") ['a', 'b', 'c'] >>> digit_to_letter_combinations(\\"79\\") ['pw', 'px', 'py', 'pz', 'qw', 'qx', 'qy', 'qz', 'rw', 'rx', 'ry', 'rz', 'sw', 'sx', 'sy', 'sz'] Example Constraints: * The input string will contain only digits between '2' and '9'. * The input string will have a length between 1 and 4.","solution":"from typing import List def digit_to_letter_combinations(digits: str) -> List[str]: if not digits: return [] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return letters = phone_mapping[digits[index]] for letter in letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"def maxActivities(start, end): Given N activities with their start and end times, select the maximum number of activities that can be performed by a single person. Args: start (List[int]): List of start times of the activities. end (List[int]): List of end times of the activities. Returns: int: The maximum number of activities that can be performed by a single person. Examples: >>> maxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) 4 >>> maxActivities([10, 12, 20], [20, 25, 30]) 2 from solution import maxActivities def test_example1(): assert maxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == 4 def test_example2(): assert maxActivities([10, 12, 20], [20, 25, 30]) == 2 def test_single_activity(): assert maxActivities([1], [2]) == 1 def test_no_overlapping(): assert maxActivities([1, 3, 5], [2, 4, 6]) == 3 def test_all_overlapping(): assert maxActivities([1, 1, 1], [2, 2, 2]) == 1 def test_mixed_intervals(): assert maxActivities([1, 2, 3, 3], [2, 3, 4, 5]) == 3 def test_large_number_of_activities(): start = list(range(1, 10**5 + 1)) end = list(range(2, 10**5 + 2)) assert maxActivities(start, end) == 10**5","solution":"def maxActivities(start, end): # Zip the start and end times together and sort by end times activities = sorted(zip(start, end), key=lambda x: x[1]) count = 0 current_end_time = 0 for s, e in activities: if s >= current_end_time: count += 1 current_end_time = e return count"},{"question":"def formatNumber(n): Converts an integer to a string formatted to represent a decimal-like structure. Args: n (int): The integer to be formatted. Returns: str: The formatted string. Examples: >>> formatNumber(5) '0.05' >>> formatNumber(70) '0.70' >>> formatNumber(123) '1.23' >>> formatNumber(4567) '5.67' >>> formatNumber(89012) '0.12'","solution":"def formatNumber(n): Converts an integer to a string formatted to represent a decimal-like structure. Args: n (int): The integer to be formatted. Returns: str: The formatted string. # Extract the last three digits of the number last_three_digits = abs(n) % 1000 # Format the number with leading zeros and one decimal point formatted_str = f\\"{last_three_digits // 100}.{last_three_digits % 100:02d}\\" return formatted_str"},{"question":"def find_tallest_right(n, heights): Given the number of students and their heights, this function returns an array where each value at index \`i\` is the height of the tallest student to the right of the student at index \`i\`. If there is no student to the right, the function will return -1 for that index. :param n: Number of students :param heights: List of students' heights :return: List of tallest heights to the right pass def process_datasets(inputs): Processes multiple datasets of heights to find the tallest student to the right for each student in each dataset. :param inputs: List of integers where each dataset starts with an integer \`n\` followed by \`n\` integers representing the heights of students. The end of the input is indicated by a single line containing a zero. :return: List of results for each dataset as described. pass # Example usage: # # inputs = [5, 5, 3, 8, 3, 2, 4, 2, 7, 4, 3, 1, 10, 0] # process_datasets(inputs) # Output should be: # [[8, 8, 3, 2, -1], [7, 4, 3, -1], [-1]]","solution":"def find_tallest_right(n, heights): Given the number of students and their heights, this function returns an array where each value at index \`i\` is the height of the tallest student to the right of the student at index \`i\`. If there is no student to the right, the function will return -1 for that index. :param n: Number of students :param heights: List of students' heights :return: List of tallest heights to the right if n == 0: return [] tallest_right = [-1] * n max_height = -1 for i in range(n - 1, -1, -1): tallest_right[i] = max_height if heights[i] > max_height: max_height = heights[i] return tallest_right def process_datasets(inputs): Processes multiple datasets of heights to find the tallest student to the right for each student in each dataset. :param inputs: List of integers where each dataset starts with an integer \`n\` followed by \`n\` integers representing the heights of students. The end of the input is indicated by a single line containing a zero. :return: List of results for each dataset as described. results = [] idx = 0 while idx < len(inputs): n = inputs[idx] if n == 0: break heights = inputs[idx + 1: idx + 1 + n] results.append(find_tallest_right(n, heights)) idx += n + 1 return results"},{"question":"def can_fulfill_requests(data: str) -> str: Determines if any merchant can fulfill the customer's entire request within the given constraints. Parameters: data (str): The input data in the specified format. Returns: str: \\"Yes\\" if at least one merchant can fulfill all the customer's requests within the specified price constraints, otherwise \\"No\\". Examples: >>> can_fulfill_requests(\\"2n2nAlicenring 100 gold shinynnecklace 150 gold elegantn3nBobnbracelet 200 silver elegantnearrings 50 gold shinynwatch 300 silver durablen2ngold shiny 120nsilver elegant 250\\") \\"Yes\\" >>> can_fulfill_requests(\\"1n3nCarolnring 75 goldnbracelet 125 silvernnecklace 200 gold shinyn2ngold shiny 150nsilver 130\\") \\"No\\"","solution":"def can_fulfill_requests(merchants, customer_request): Determines if any merchant can fulfill the customer's entire request within the given constraints. merchants: list of dictionaries, each representing a merchant with their items. customer_request: list of tuples, each representing a request with required properties and max price. Returns True if any merchant can fulfill the request, otherwise returns False. for merchant in merchants: merchant_name = merchant[\\"name\\"] items = merchant[\\"items\\"] successful_match = True for request_properties, max_price in customer_request: match_found = False for item in items: item_price = item[\\"price\\"] item_properties = item[\\"properties\\"] if item_price <= max_price and all(prop in item_properties for prop in request_properties): match_found = True break if not match_found: successful_match = False break if successful_match: return True return False # Helper functions to parse inputs def parse_input(data): lines = data.strip().split('n') current_line = 0 M = int(lines[current_line]) current_line += 1 merchants = [] for _ in range(M): N_i = int(lines[current_line]) current_line += 1 merchant_name = lines[current_line] current_line += 1 items = [] for _ in range(N_i): item_info = lines[current_line].split() current_line += 1 item_name = item_info[0] item_price = int(item_info[1]) item_properties = item_info[2:] items.append({\\"name\\": item_name, \\"price\\": item_price, \\"properties\\": item_properties}) merchants.append({\\"name\\": merchant_name, \\"items\\": items}) K = int(lines[current_line]) current_line += 1 customer_request = [] for _ in range(K): request_info = lines[current_line].split() current_line += 1 properties = request_info[:-1] max_price = int(request_info[-1]) customer_request.append((properties, max_price)) return merchants, customer_request # Main function to process input data and determine the output def main(data): merchants, customer_request = parse_input(data) if can_fulfill_requests(merchants, customer_request): return \\"Yes\\" else: return \\"No\\""},{"question":"def execute_tasks(n, m, machine_capacities, tasks): Simulates the execution of tasks given the current state of the factory and outputs the order in which tasks start execution. Parameters: n (int): Number of machines m (int): Number of tasks machine_capacities (list of int): Capacities of the machines tasks (list of tuples): Each tuple contains the priority and required time of a task Returns: list of int: Order of task indices in which they start execution Example: >>> execute_tasks(3, 5, [2, 1, 3], [(5, 7), (3, 2), (1, 5), (4, 3), (3, 4)]) [1, 4, 2, 5, 3] pass # Unit Tests def test_example_case(): n = 3 m = 5 machine_capacities = [2, 1, 3] tasks = [(5, 7), (3, 2), (1, 5), (4, 3), (3, 4)] assert execute_tasks(n, m, machine_capacities, tasks) == [1, 4, 2, 5, 3] def test_all_tasks_same_priority(): n = 2 m = 4 machine_capacities = [2, 2] tasks = [(3, 5), (3, 6), (3, 7), (3, 4)] assert execute_tasks(n, m, machine_capacities, tasks) == [1, 2, 3, 4] def test_insufficient_capacity(): n = 2 m = 3 machine_capacities = [1, 1] tasks = [(2, 5), (1, 6), (3, 4)] assert execute_tasks(n, m, machine_capacities, tasks) == [3, 1] def test_single_machine(): n = 1 m = 4 machine_capacities = [4] tasks = [(1, 1), (2, 2), (3, 3), (4, 4)] assert execute_tasks(n, m, machine_capacities, tasks) == [4, 3, 2, 1] def test_no_tasks(): n = 2 m = 0 machine_capacities = [1, 2] tasks = [] assert execute_tasks(n, m, machine_capacities, tasks) == []","solution":"def execute_tasks(n, m, machine_capacities, tasks): Returns the order of task indices in which they start execution. Parameters: n (int): Number of machines m (int): Number of tasks machine_capacities (list of int): Capacities of the machines tasks (list of tuples): Each tuple contains priority and required time of a task Returns: list of int: Order of task indices in which they start execution # Create a list of tasks with indices indexed_tasks = [(i+1, tasks[i][0], tasks[i][1]) for i in range(m)] # Sort tasks by priority (descending) and by index for stable sort order sorted_tasks = sorted(indexed_tasks, key=lambda x: (-x[1], x[0])) # Initialize machine capacities left machines = [machine_capacities[i] for i in range(n)] # List to store the order of task indices order_of_execution = [] # Assign tasks to machines for task in sorted_tasks: task_index, priority, required_time = task for i in range(n): if machines[i] > 0: # Assign task to the machine and reduce its capacity order_of_execution.append(task_index) machines[i] -= 1 break return order_of_execution # Example usage n = 3 m = 5 machine_capacities = [2, 1, 3] tasks = [(5, 7), (3, 2), (1, 5), (4, 3), (3, 4)] print(execute_tasks(n, m, machine_capacities, tasks)) # Output: [1, 4, 2, 5, 3]"},{"question":"def check_stock_levels(T, cases): Determines if the stock for each product needs to be replenished or not based on the given threshold levels. Args: T (int): Number of test cases. cases (List[Tuple[int, str]]): A list of tuples where each tuple contains a required minimum stock level R and a product ID. Returns: List[str]: List of strings, each being either \\"REPLENISH\\" or \\"STOCK SUFFICIENT\\". pass from typing import List, Tuple def test_single_case_stock_sufficient(): assert check_stock_levels(1, [(50, \\"P123L456100\\")]) == [\\"STOCK SUFFICIENT\\"] def test_single_case_replenish(): assert check_stock_levels(1, [(90, \\"P2L5L40\\")]) == [\\"REPLENISH\\"] def test_multiple_cases(): assert check_stock_levels(3, [(50, \\"P123L456100\\"), (25, \\"P12L78L200\\"), (90, \\"P2L5L40\\")]) == [\\"STOCK SUFFICIENT\\", \\"STOCK SUFFICIENT\\", \\"REPLENISH\\"] def test_edge_case_minimum_stock(): assert check_stock_levels(1, [(30, \\"P1L1L5\\")]) == [\\"REPLENISH\\"] def test_edge_case_maximum_stock(): assert check_stock_levels(1, [(10000, \\"P999L99910000\\")]) == [\\"STOCK SUFFICIENT\\"] def test_edge_case_stock_quantity_only_digits(): assert check_stock_levels(1, [(3, \\"P1L1L3\\")]) == [\\"STOCK SUFFICIENT\\"]","solution":"def check_stock_levels(T, cases): Determines if the stock for each product needs to be replenished or not based on the given threshold levels. Args: T (int): Number of test cases. cases (List[Tuple[int, str]]): A list of tuples where each tuple contains a required minimum stock level R and a product ID. Returns: List[str]: List of strings, each being either \\"REPLENISH\\" or \\"STOCK SUFFICIENT\\". results = [] for case in cases: R, ID = case # Stock Quantity is the last numeric part of the ID stock_quantity = int(''.join(filter(str.isdigit, ID.split('L')[-1]))) if stock_quantity < R: results.append(\\"REPLENISH\\") else: results.append(\\"STOCK SUFFICIENT\\") return results"},{"question":"def transform_to_one(n: int) -> int: Returns the number of operations required to transform integer n to 1 using the described rules. >>> transform_to_one(6) 8 >>> transform_to_one(19) 20 >>> transform_to_one(1) 0 >>> transform_to_one(27) 111 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases for the transform_to_one function. >>> process_test_cases(4, [6, 19, 1, 27]) [8, 20, 0, 111] >>> process_test_cases(2, [1024, 3]) [10, 7] pass","solution":"def transform_to_one(n): Returns the number of operations required to transform integer n to 1 using the described rules. operations = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = n * 3 + 1 operations += 1 return operations def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(transform_to_one(n)) return results"},{"question":"def longestIncreasingSequence(arr: List[int]) -> int: Returns the length of the longest continuous increasing sequence in the array. Parameters: arr (list of int): An array of integers Returns: int: The length of the longest continuous increasing sequence >>> longestIncreasingSequence([1, 3, 5, 4, 7, 8]) 3 >>> longestIncreasingSequence([10]) 1 >>> longestIncreasingSequence([1, 2, 3, 4, 5]) 5 >>> longestIncreasingSequence([7, 7, 7, 7]) 1 >>> longestIncreasingSequence([2, 2, 2, 3, 5, 1, 2, 3, 4]) 4 >>> longestIncreasingSequence([5, 4, 3, 2, 1]) 1 >>> longestIncreasingSequence([]) 0 >>> longestIncreasingSequence([1, 2, 1, 2, 1, 2, 1, 2]) 2","solution":"def longestIncreasingSequence(arr): Returns the length of the longest continuous increasing sequence in the array. Parameters: arr (list of int): An array of integers Returns: int: The length of the longest continuous increasing sequence if not arr: return 0 longest_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length"},{"question":"def calculate_word_sums(file_path): Reads a large text file and calculates the sum of the integers for each word. Args: file_path (str): The path to the input file. Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a word and its corresponding sum, sorted in descending order of the sums. If two words have the same sum, they appear in alphabetical order. >>> calculate_word_sums(\\"sample.txt\\") [('banana', 18), ('orange', 19), ('apple', 15), ('grape', 4)] >>> calculate_word_sums(\\"empty.txt\\") [] >>> calculate_word_sums(\\"single.txt\\") [('apple', 20)] >>> calculate_word_sums(\\"same_sum.txt\\") [('apple', 15), ('banana', 15)]","solution":"def calculate_word_sums(file_path): from collections import defaultdict word_sum_dict = defaultdict(int) with open(file_path, 'r') as file: for line in file: elements = line.split() word = elements[0] numbers = map(int, elements[1:]) word_sum_dict[word] += sum(numbers) sorted_word_sums = sorted(word_sum_dict.items(), key=lambda x: (-x[1], x[0])) return sorted_word_sums"},{"question":"def subset_sum_exists(n: int, S: int, arr: List[int]) -> str: Determines if there is a subset of 'arr' that sums to 'S'. Parameters: n (int): The number of integers. S (int): The target sum. arr (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". >>> subset_sum_exists(5, 9, [3, 34, 4, 12, 5, 2]) == \\"YES\\" >>> subset_sum_exists(3, 13, [1, 5, 11]) == \\"NO\\" >>> subset_sum_exists(4, 0, [1, -1, 2, -2]) == \\"YES\\" pass from solution import subset_sum_exists def test_subset_sum_exists_example1(): assert subset_sum_exists(5, 9, [3, 34, 4, 12, 5, 2]) == \\"YES\\" def test_subset_sum_exists_example2(): assert subset_sum_exists(3, 13, [1, 5, 11]) == \\"NO\\" def test_subset_sum_exists_example3(): assert subset_sum_exists(4, 0, [1, -1, 2, -2]) == \\"YES\\" def test_subset_sum_exists_single_element_equal_sum(): assert subset_sum_exists(1, 5, [5]) == \\"YES\\" def test_subset_sum_exists_single_element_not_equal_sum(): assert subset_sum_exists(1, 5, [1]) == \\"NO\\" def test_subset_sum_exists_large_sum(): assert subset_sum_exists(4, 10**9, [10**4, 10**4, 10**4, 10**4]) == \\"NO\\" def test_subset_sum_exists_zero_sum_with_positives_and_negatives(): assert subset_sum_exists(4, 0, [10, -10, 20, -20]) == \\"YES\\"","solution":"def subset_sum_exists(n, S, arr): Determines if there is a subset of 'arr' that sums to 'S'. Parameters: n (int): The number of integers. S (int): The target sum. arr (list): The list of integers. Returns: str: \\"YES\\" if such a subset exists, otherwise \\"NO\\". def can_sum_to_target(index, current_sum): # Base cases if current_sum == S: return True if index >= n or current_sum > S: return False # Recursive cases: include the current element or exclude it return ( can_sum_to_target(index + 1, current_sum + arr[index]) or can_sum_to_target(index + 1, current_sum) ) result = can_sum_to_target(0, 0) return \\"YES\\" if result else \\"NO\\""},{"question":"def find_median(scores: List[int]) -> Union[int, float]: Returns the median of the list of scores. >>> find_median([10, 30, 20]) 20 >>> find_median([15, 45, 10, 25]) 20 >>> find_median([100, 200]) 150 >>> find_median([50]) 50 >>> find_median([90, 80, 70, 60, 50]) 70 pass def compute_medians(input_string: str) -> List[Union[int, float]]: Processes the input string and returns the medians for each participant in each test case. >>> input_string = '2n3n3 10 30 20n4 15 45 10 25n2 100 200n2n1 50n5 90 80 70 60 50' >>> compute_medians(input_string) [20, 20, 150, 50, 70] >>> input_string = '1n2n2 1 1000000n2 1000000 1' >>> compute_medians(input_string) [500000.5, 500000.5] >>> input_string = '1n2n1 20n1 30' >>> compute_medians(input_string) [20, 30] >>> input_string = '1n1n4 4 3 2 1' >>> compute_medians(input_string) [2.5] pass","solution":"def find_median(scores): Returns the median of the list of scores. scores.sort() n = len(scores) mid = n // 2 if n % 2 == 0: return (scores[mid - 1] + scores[mid]) / 2 else: return scores[mid] def compute_medians(input_string): Processes the input string and returns the medians for each participant in each test case. input_lines = input_string.strip().split('n') index = 0 T = int(input_lines[index]) index += 1 results = [] for _ in range(T): P = int(input_lines[index]) index += 1 for _ in range(P): participant_data = list(map(int, input_lines[index].split())) G_i = participant_data[0] scores = participant_data[1:] median = find_median(scores) results.append(median) index += 1 return results"},{"question":"def optimal_game_winner(buildings, start): Determine the winner of the jumping game between Alice and Bob given the building heights and starting position for Alice. Args: buildings (List[int]): A list of integers where each integer represents the height of a building. start (int): The starting position of Alice. Returns: str: The name of the winner (\\"Alice\\" or \\"Bob\\"). >>> optimal_game_winner([2, 3, 1, 1, 4], 0) \\"Alice\\" >>> optimal_game_winner([1, 2, 1, 2], 2) \\"Bob\\" >>> optimal_game_winner([3, 1, 1, 2, 1, 2], 3) \\"Alice\\" pass def determine_winners(test_cases): Determine the winners of multiple jumping game test cases. Args: test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases where each test case contains a tuple with the number of buildings and the starting position, and a list of integers representing the buildings. Returns: List[str]: A list of winners for each test case in the order they were given. >>> determine_winners([((5, 0), [2, 3, 1, 1, 4]), ((4, 2), [1, 2, 1, 2]), ((6, 3), [3, 1, 1, 2, 1, 2])]) [\\"Alice\\", \\"Bob\\", \\"Alice\\"] pass","solution":"def optimal_game_winner(buildings, start): n = len(buildings) visited = [False] * n def can_jump(pos): if pos < 0 or pos >= n or visited[pos]: return False return True def dfs_turn(pos): visited[pos] = True moves = [pos + buildings[pos], pos - buildings[pos]] for move in moves: if can_jump(move): if not dfs_turn(move): visited[pos] = False return True visited[pos] = False return False return \\"Alice\\" if dfs_turn(start) else \\"Bob\\" def determine_winners(test_cases): results = [] for test in test_cases: n, start = test[0] buildings = test[1] results.append(optimal_game_winner(buildings, start)) return results"},{"question":"def find_first_smaller_element(arr: List[int]) -> int: Returns the first element from the left which is smaller than its preceding element. If no such element is found, returns -1. :param arr: List of integers where each integer is between 1 and 1000 inclusive. :return: First element from the left which is smaller than its preceding element or -1 if not found. >>> find_first_smaller_element([1, 2, 3, 5, 4, 6]) 4 >>> find_first_smaller_element([2, 4, 6, 8, 10]) -1","solution":"def find_first_smaller_element(arr): Returns the first element from the left which is smaller than its preceding element. If no such element is found, returns -1. :param arr: List of integers where each integer is between 1 and 1000 inclusive. :return: First element from the left which is smaller than its preceding element or -1 if not found. for i in range(1, len(arr)): if arr[i] < arr[i-1]: return arr[i] return -1"},{"question":"def min_swaps_to_sort_desc(n: int, arr: List[int]) -> int: Returns the minimum number of swaps required to sort the input array in descending order. >>> min_swaps_to_sort_desc(5, [1, 2, 3, 4, 5]) 2 >>> min_swaps_to_sort_desc(5, [5, 4, 3, 2, 1]) 0 >>> min_swaps_to_sort_desc(3, [2, 3, 1]) 1 >>> min_swaps_to_sort_desc(4, [4, 1, 3, 2]) 2 >>> min_swaps_to_sort_desc(1, [1]) 0 >>> min_swaps_to_sort_desc(6, [6, 5, 4, 3, 2, 1]) 0 pass def test_min_swaps_to_sort_desc(): assert min_swaps_to_sort_desc(5, [1, 2, 3, 4, 5]) == 2 assert min_swaps_to_sort_desc(5, [5, 4, 3, 2, 1]) == 0 assert min_swaps_to_sort_desc(3, [2, 3, 1]) == 1 assert min_swaps_to_sort_desc(4, [4, 1, 3, 2]) == 2 assert min_swaps_to_sort_desc(1, [1]) == 0 assert min_swaps_to_sort_desc(6, [6, 5, 4, 3, 2, 1]) == 0 assert min_swaps_to_sort_desc(6, [1, 6, 3, 5, 2, 4]) == 4 def test_min_swaps_upper_bound(): n = 10**5 arr = list(range(1, n + 1)) assert min_swaps_to_sort_desc(n, arr) == (n // 2) if __name__ == \\"__main__\\": test_min_swaps_to_sort_desc() test_min_swaps_upper_bound()","solution":"def min_swaps_to_sort_desc(n, arr): Returns the minimum number of swaps required to sort the input array in descending order. arr_enumerated = [(value, index) for index, value in enumerate(arr)] arr_enumerated.sort(reverse=True, key=lambda x: x[0]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_enumerated[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_enumerated[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def minimum_cutting_cost(datasets): Calculate the minimum cutting cost needed to fulfill all orders for given datasets. The input is a list of dictionaries, where each dictionary represents a dataset with the following keys: - 'n': number of available rods - 'm': number of target lengths - 'rod_lengths': list of integers representing the lengths of the rods - 'targets': list of tuples, where each tuple contains a target length and its priority The function returns a list of integers, each representing the minimum cutting cost for the corresponding dataset. If it is impossible to fulfill the orders, the function returns -1 for that dataset. Example: >>> datasets = [ ... { ... 'n': 2, ... 'm': 3, ... 'rod_lengths': [100, 200], ... 'targets': [(50, 1), (70, 2), (30, 3)] ... }, ... { ... 'n': 3, ... 'm': 2, ... 'rod_lengths': [150, 300, 200], ... 'targets': [(100, 1), (250, 2)] ... } ... ] >>> minimum_cutting_cost(datasets) [75, 50] pass def test_minimum_cutting_cost(): datasets = [ { 'n': 2, 'm': 3, 'rod_lengths': [100, 200], 'targets': [(50, 1), (70, 2), (30, 3)] }, { 'n': 3, 'm': 2, 'rod_lengths': [150, 300, 200], 'targets': [(100, 1), (250, 2)] } ] assert minimum_cutting_cost(datasets) == [3*25, 2*25] datasets = [ { 'n': 1, 'm': 1, 'rod_lengths': [10], 'targets': [(20, 1)] } ] assert minimum_cutting_cost(datasets) == [-1] def test_edge_cases(): datasets = [ { 'n': 1, 'm': 1, 'rod_lengths': [100], 'targets': [(100, 1)] }, { 'n': 1, 'm': 1, 'rod_lengths': [100], 'targets': [(101, 1)] }, { 'n': 2, 'm': 2, 'rod_lengths': [50, 70], 'targets': [(30, 1), (20, 2)] } ] assert minimum_cutting_cost(datasets) == [25, -1, 2*25] datasets = [ { 'n': 3, 'm': 3, 'rod_lengths': [100, 200, 150], 'targets': [(50, 1), (70, 2), (100, 3)] } ] assert minimum_cutting_cost(datasets) == [3*25]","solution":"def minimum_cutting_cost(datasets): results = [] for dataset in datasets: n, m = dataset['n'], dataset['m'] rod_lengths = list(dataset['rod_lengths']) target_lengths = sorted(dataset['targets'], key=lambda x: x[1]) def can_fulfill_order(rod, target): return rod >= target # Simple greedy approach to minimize cuts based on priority order cuts = 0 for target, _ in target_lengths: for i in range(n): if rod_lengths[i] >= target: rod_lengths[i] -= target cuts += 1 break else: results.append(-1) break else: results.append(cuts * 25) # Assuming fixed cost per cut is 25 return results"},{"question":"def find_lcs_length(input_data: str) -> int: Write a program that reads two sequences of integers and finds their longest common subsequence. A longest common subsequence (LCS) is a subsequence that appears in both sequences in the same order but not necessarily consecutively. The program should output the length of the LCS. Input In the first line, an integer n is given, representing the number of elements in the first sequence. In the second line, n space-separated integers are provided, representing the elements of the first sequence. In the third line, an integer m is given, representing the number of elements in the second sequence. In the fourth line, m space-separated integers are provided, representing the elements of the second sequence. Output Print the length of the longest common subsequence. >>> find_lcs_length(\\"6n1 2 3 4 1n5n3 4 1 2 1 3\\") 3 >>> find_lcs_length(\\"3n1 2 3n3n4 5 6\\") 0 >>> find_lcs_length(\\"1n7n1n7\\") 1 >>> find_lcs_length(\\"1n7n1n8\\") 0 >>> find_lcs_length(\\"10n1 2 3 4 5 6 7 8 9 10n10n10 9 8 7 6 5 4 3 2 1\\") 1 >>> find_lcs_length(\\"5n1 1 1 1 1n3n1 1 1\\") 3","solution":"def longest_common_subsequence(seq1, seq2): This function finds the length of the longest common subsequence between two sequences. n = len(seq1) m = len(seq2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] # Build the dp array from bottom up. for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] # Function to convert input strings to lists and call LCS function def find_lcs_length(input_data): input_lines = input_data.strip().split('n') n = int(input_lines[0].strip()) seq1 = list(map(int, input_lines[1].strip().split())) m = int(input_lines[2].strip()) seq2 = list(map(int, input_lines[3].strip().split())) return longest_common_subsequence(seq1, seq2)"},{"question":"import math def is_perfect_square(x): Check if a number x is a perfect square. s = int(math.isqrt(x)) return s * s == x def count_perfect_squares(arr, queries): Count the number of perfect squares in subarrays specified by the queries. Parameters: arr (list of int): The array of integers. queries (list of tuple): A list of tuples where each tuple contains two integers, L and R, indicating the range of the subarray. Returns: list: A list of integers where each integer is the count of perfect squares in the subarray defined by the corresponding query. >>> count_perfect_squares([1, 2, 4, 7, 9, 16], [(1, 3), (2, 5), (3, 6)]) [2, 2, 3] >>> count_perfect_squares([36, 49, 64, 81, 100], [(1, 5), (2, 4), (3, 3)]) [5, 3, 1] >>> count_perfect_squares([5, 10, 15, 20], [(1, 4), (2, 3)]) [0, 0] pass def process_input(data): Parse the input data to get the array, number of queries, and query ranges. Parameters: data (str): The input data as a single string. Returns: tuple: A tuple containing the array of integers and the list of queries. pass def main(): import sys input = sys.stdin.read data = input() array, queries = process_input(data) results = count_perfect_squares(array, queries) for res in results: print(res)","solution":"import math def is_perfect_square(x): Check if a number x is a perfect square. s = int(math.isqrt(x)) return s * s == x def count_perfect_squares(arr, queries): Count the number of perfect squares in subarrays specified by the queries. perfect_square_flags = [1 if is_perfect_square(x) else 0 for x in arr] prefix_sum = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sum[i] = prefix_sum[i - 1] + perfect_square_flags[i - 1] results = [] for L, R in queries: results.append(prefix_sum[R] - prefix_sum[L - 1]) return results def process_input(data): Parse the input data to get the array, number of queries, and query ranges. lines = data.strip().split('n') N = int(lines[0]) array = list(map(int, lines[1].split())) Q = int(lines[2]) queries = [tuple(map(int, lines[i].split())) for i in range(3, 3 + Q)] return array, queries def main(): import sys input = sys.stdin.read data = input() array, queries = process_input(data) results = count_perfect_squares(array, queries) for res in results: print(res)"},{"question":"from typing import List def can_schedule_matches(P: int, M: int, availability: List[List[int]]) -> str: Determine if it's possible to schedule the matches such that every player can participate in at least one match. >>> can_schedule_matches(3, 3, [[1, 2], [3], [2, 3]]) \\"Possible\\" >>> can_schedule_matches(3, 2, [[1], [2], []]) \\"Not Possible\\" pass def test_case_1(): assert can_schedule_matches(3, 3, [[1, 2], [3], [2, 3]]) == \\"Possible\\" def test_case_2(): assert can_schedule_matches(3, 2, [[1], [2], []]) == \\"Not Possible\\" def test_case_3(): assert can_schedule_matches(2, 3, [[1], [1, 2, 3]]) == \\"Possible\\" def test_case_4(): assert can_schedule_matches(2, 2, [[], [1, 2]]) == \\"Not Possible\\" def test_case_5(): assert can_schedule_matches(3, 3, [[1], [2], [3]]) == \\"Possible\\" def test_case_6(): assert can_schedule_matches(4, 3, [[1], [2], [], [1, 2, 3]]) == \\"Not Possible\\"","solution":"def can_schedule_matches(P, M, availability): # Initialize a set to keep track of players who have at least one available match possible_players = set() # Iterate through the availability list for player_id, matches in enumerate(availability): if matches: possible_players.add(player_id) # Compare the size of possible_players with P if len(possible_players) == P: return \\"Possible\\" else: return \\"Not Possible\\" # Example usage: # P = 3, M = 3, availability = [[1, 2], [3], [2, 3]] # print(can_schedule_matches(3, 3, [[1, 2], [3], [2, 3]])) # Output: \\"Possible\\" # P = 3, M = 2, availability = [[1], [2], []] # print(can_schedule_matches(3, 2, [[1], [2], []])) # Output: \\"Not Possible\\""},{"question":"def canObtainEnergy(target: int, energies: List[int]) -> bool: Determines if there is a non-empty subset of the array energies that sums up to the target value. Args: target (int): The desired level of magical energy. energies (List[int]): The list of magical energies of the individual fruits. Returns: bool: True if there exists a non-empty subset that sums up to the target value, False otherwise. Examples: >>> canObtainEnergy(9, [3, 34, 4, 12, 5, 2]) True >>> canObtainEnergy(30, [8, 6, 7, 5, 3, 10, 9]) True >>> canObtainEnergy(23, [1, 2, 3, 4, 5]) False","solution":"def canObtainEnergy(target, energies): Determines if there is a non-empty subset of the array energies that sums up to the target value. Args: target (int): The desired level of magical energy. energies (List[int]): The list of magical energies of the individual fruits. Returns: bool: True if there exists a non-empty subset that sums up to the target value, False otherwise. n = len(energies) dp = [False] * (target + 1) dp[0] = True for energy in energies: for j in range(target, energy - 1, -1): if dp[j - energy]: dp[j] = True return dp[target]"},{"question":"def calculate(s: str) -> float: Design a function that takes a string representing a mathematical expression containing only single-digit integers, the operators '+', '-', '*', and '/', and parentheses. The function should return the result of evaluating the string as an arithmetic expression. The function should handle the order of operations, including parentheses. >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\"3/2\\") 1.5 >>> calculate(\\"(3+2)*2\\") 10 >>> calculate(\\"3+(2*2)\\") 7 from solution import calculate def test_simple_addition(): assert calculate(\\"3+2\\") == 5 def test_simple_subtraction(): assert calculate(\\"3-2\\") == 1 def test_simple_multiplication(): assert calculate(\\"3*2\\") == 6 def test_simple_division(): assert calculate(\\"6/2\\") == 3 def test_mixed_operations(): assert calculate(\\"3+2*2\\") == 7 def test_operations_with_parentheses(): assert calculate(\\"(3+2)*2\\") == 10 assert calculate(\\"3+(2*2)\\") == 7 def test_expression_with_spaces(): assert calculate(\\" ( 3 + 2 ) * 2 \\") == 10 assert calculate(\\" 3 + (2 * 2) \\") == 7 def test_division_with_floating_point_result(): assert calculate(\\"3/2\\") == 1.5","solution":"def calculate(s: str) -> float: def evaluate(tokens): Evaluate expression in reverse Polish notation. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) else: stack.append(float(token)) return stack[0] def toReversePolish(s: str): Convert the infix expression to reverse Polish notation. priority = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] postfix = [] i = 0 while i < len(s): if s[i] == ' ': i += 1 elif s[i] in '0123456789': num = '' while i < len(s) and s[i] in '0123456789': num += s[i] i += 1 postfix.append(num) elif s[i] in \\"+-*/\\": while (operators and operators[-1] != '(' and priority[operators[-1]] >= priority[s[i]]): postfix.append(operators.pop()) operators.append(s[i]) i += 1 elif s[i] == '(': operators.append(s[i]) i += 1 elif s[i] == ')': while operators and operators[-1] != '(': postfix.append(operators.pop()) operators.pop() i += 1 while operators: postfix.append(operators.pop()) return postfix tokens = toReversePolish(s) return evaluate(tokens)"},{"question":"from typing import List, Dict def max_tasks_employee(employees: List[Dict]) -> int: Returns the employee identifier who has the most number of tasks assigned. In case of a tie, returns the employee with the smallest identifier. >>> max_tasks_employee([{\\"id\\": 1, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 2}]}]) 1 >>> max_tasks_employee([ ... {\\"id\\": 1, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 2}]}, ... {\\"id\\": 2, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 3}, {\\"name\\": \\"task2\\", \\"time\\": 1}]} ... ]) 2 >>> max_tasks_employee([ ... {\\"id\\": 1, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 2}, {\\"name\\": \\"task2\\", \\"time\\": 3}]}, ... {\\"id\\": 2, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 4}, {\\"name\\": \\"task2\\", \\"time\\": 1}]} ... ]) 1 >>> max_tasks_employee([ ... {\\"id\\": 1, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 2}, {\\"name\\": \\"task2\\", \\"time\\": 3}]}, ... {\\"id\\": 2, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 4}]}, ... {\\"id\\": 3, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 1}, {\\"name\\": \\"task2\\", \\"time\\": 2}, {\\"name\\": \\"task3\\", \\"time\\": 1}]} ... ]) 3 >>> max_tasks_employee([ ... {\\"id\\": 1, \\"tasks\\": []}, ... {\\"id\\": 2, \\"tasks\\": []} ... ]) 1 >>> max_tasks_employee([ ... {\\"id\\": 1, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 5}]}, ... {\\"id\\": 2, \\"tasks\\": [{\\"name\\": \\"task1\\", \\"time\\": 2}, {\\"name\\": \\"task2\\", \\"time\\": 1}]} ... ]) 2","solution":"def max_tasks_employee(employees): Returns the employee identifier who has the most number of tasks assigned. In case of a tie, returns the employee with the smallest identifier. max_tasks = -1 employee_id = None for employee in employees: num_tasks = len(employee[\\"tasks\\"]) if num_tasks > max_tasks or (num_tasks == max_tasks and employee[\\"id\\"] < employee_id): max_tasks = num_tasks employee_id = employee[\\"id\\"] return employee_id"},{"question":"def num_paths(H: int, W: int, grid: List[str]) -> int: Implement a function that returns the number of different paths the robot can take to reach the bottom-right corner of the grid, modulo 10^9 + 7. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(3, 3, [\\"#..\\", \\".#.\\", \\"...\\"]) 0 >>> num_paths(1, 3, [\\"...\\"]) 1 >>> num_paths(3, 1, [\\".\\", \\".\\", \\".\\"]) 1 >>> num_paths(3, 4, [\\"....\\", \\"....\\", \\"....\\"]) 10 >>> num_paths(3, 4, [\\"....\\", \\".#..\\", \\"....\\"]) 4","solution":"def num_paths(H, W, grid): MOD = 10**9 + 7 if grid[0][0] == '#' or grid[H-1][W-1] == '#': return 0 dp = [[0] * W for _ in range(H)] dp[0][0] = 1 for i in range(H): for j in range(W): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] dp[i][j] %= MOD return dp[H - 1][W - 1]"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path between two given land cells on the grid. Args: n: int: Number of rows in the grid m: int: Number of columns in the grid grid: List[List[int]]: 2D grid representing the island (0 for land, 1 for water) start: Tuple[int, int]: Starting land cell coordinates (x1, y1) end: Tuple[int, int]: Ending land cell coordinates (x2, y2) Returns: int: Length of the shortest path between the start and end cells. If no such path exists, return -1. >>> shortest_path(5, 5, [[0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]], (1, 1), (5, 5)) 8 >>> shortest_path(3, 3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]], (1, 1), (3, 3)) -1 def test_shortest_path(): # Test case 1: Path exists n = 5 m = 5 grid = [ [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (1, 1) end = (5, 5) assert shortest_path(n, m, grid, start, end) == 8 # Test case 2: No path exists n = 3 m = 3 grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] start = (1, 1) end = (3, 3) assert shortest_path(n, m, grid, start, end) == -1 # Test case 3: Start is water n = 2 m = 2 grid = [ [1, 0], [0, 0] ] start = (1, 1) end = (2, 2) assert shortest_path(n, m, grid, start, end) == -1 # Test case 4: End is water n = 2 m = 2 grid = [ [0, 0], [0, 1] ] start = (1, 1) end = (2, 2) assert shortest_path(n, m, grid, start, end) == -1 # Test case 5: Start and End are the same cell n = 2 m = 2 grid = [ [0, 0], [0, 0] ] start = (1, 1) end = (1, 1) assert shortest_path(n, m, grid, start, end) == 0","solution":"from collections import deque def shortest_path(n, m, grid, start, end): # Direction vectors for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if start or end is water if grid[start[0]-1][start[1]-1] == 1 or grid[end[0]-1][end[1]-1] == 1: return -1 # Create a queue for BFS queue = deque([(start[0]-1, start[1]-1, 0)]) # (row, col, distance) visited = set() visited.add((start[0]-1, start[1]-1)) # Use BFS to find the shortest path while queue: r, c, dist = queue.popleft() if (r, c) == (end[0]-1, end[1]-1): return dist # Check all 4 directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) # If no path is found return -1"},{"question":"import re def increment_path(path: str) -> str: Takes a string representing a filesystem path and increments the version number at the end if it exists. If the path does not end with a version number, the function appends \\"_v1\\" to the end. A version number is defined as an underscore followed by a lowercase 'v' and a positive integer (e.g. \\"_v1\\", \\"_v2\\", etc.). If a version number exists, it should be incremented by 1. If there is no version number, \\"_v1\\" should be appended to the path. >>> increment_path(\\"/user/documents/file\\") '/user/documents/file_v1' >>> increment_path(\\"/user/documents/file_v3\\") '/user/documents/file_v4' >>> increment_path(\\"\\") '_v1' >>> increment_path(\\"/user/documents/file_version\\") '/user/documents/file_version_v1' >>> increment_path(\\"/user/music/song_v10\\") '/user/music/song_v11'","solution":"import re def increment_path(path): Takes a string representing a filesystem path and increments the version number at the end if it exists. If the path does not end with a version number, the function appends \\"_v1\\" to the end. A version number is defined as an underscore followed by a lowercase 'v' and a positive integer (e.g. \\"_v1\\", \\"_v2\\", etc.). If a version number exists, it should be incremented by 1. If there is no version number, \\"_v1\\" should be appended to the path. Parameters: path (str): Filesystem path Returns: str: The incremented or new versioned path match = re.search(r'(_vd+)', path) if match: current_version = match.group(1) version_number = int(current_version[2:]) # Extract the number part new_version = f\\"_v{version_number + 1}\\" new_path = path[:match.start()] + new_version else: new_path = path + \\"_v1\\" return new_path"},{"question":"def calculate_skyline(N: int, skyscrapers: List[List[int]]) -> List[int]: This function calculates the skyline silhouette for the given skyscrapers. Parameters: N (int): Number of skyscrapers skyscrapers (list of list of int): Heights of each skyscraper Returns: list of int: The skyline silhouette >>> calculate_skyline(3, [[3, 0, 3, 2], [4, 1, 1], [2, 3, 2, 1]]) [4, 3, 3, 2] >>> calculate_skyline(2, [[1, 1], [2, 2]]) [2, 2] >>> calculate_skyline(3, [[3, 0, 3], [4, 1], [2, 2, 1, 0]]) [4, 2, 3, 0] >>> calculate_skyline(2, [[1, 5, 3], [1, 0, 4, 6]]) [1, 5, 4, 6] >>> calculate_skyline(0, []) [] >>> calculate_skyline(1, [[0, 0, 0]]) [0, 0, 0] >>> calculate_skyline(2, [[1, 2, 3], [3, 2, 1]]) [3, 2, 3]","solution":"def calculate_skyline(N, skyscrapers): This function calculates the skyline silhouette for the given skyscrapers. Parameters: N (int): Number of skyscrapers skyscrapers (list of list of int): Heights of each skyscraper Returns: list of int: The skyline silhouette if N == 0: return [] max_width = max(len(sk) for sk in skyscrapers) skyline = [0] * max_width for sk in skyscrapers: for pos, height in enumerate(sk): skyline[pos] = max(skyline[pos], height) return skyline"},{"question":"def top_k_recipes(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[List[int]]: Determine the top k most popular recipes after excluding any recipes with negative scores from multiple test cases. Each test case consists of: - An integer N representing the number of recipes. - A list of N integers representing the popularity scores of the recipes. - An integer k representing the number of top recipes to consider. Args: T (int): Number of test cases test_cases (List[Tuple[int, List[int], int]]): List of tuples, each containing: - An integer N, - A list of N integers (popularity scores), - An integer k Returns: List[List[int]]: A list of lists, where each inner list contains the top k popular scores in descending order for each test case. Example: >>> top_k_recipes(2, [(5, [-10, 20, 30, -5, 40], 3), (4, [50, 60, -70, 80], 2)]) [[40, 30, 20], [80, 60]]","solution":"def top_k_recipes(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] scores = test_cases[i][1] k = test_cases[i][2] # Filter out negative scores positive_scores = [score for score in scores if score >= 0] # Sort scores in descending order positive_scores.sort(reverse=True) # Get top k scores top_k = positive_scores[:k] results.append(top_k) return results"},{"question":"def count_unique_necklaces(n: int, necklaces: List[str]) -> int: Returns the number of unique cyclic sequences in the list of necklaces. >>> count_unique_necklaces(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yyy\\"]) == 3 >>> count_unique_necklaces(3, [\\"aaa\\", \\"bbb\\", \\"ccc\\"]) == 3 >>> count_unique_necklaces(4, [\\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\"]) == 1 >>> count_unique_necklaces(4, [\\"abc\\", \\"abc\\", \\"bca\\", \\"cab\\"]) == 1 >>> count_unique_necklaces(100, [\\"a\\"] * 100) == 1 >>> count_unique_necklaces(1, [\\"unique\\"]) == 1","solution":"def rotate_string(s): Returns all cyclic rotations of the string 's'. return [s[i:] + s[:i] for i in range(len(s))] def canonical_form(s): Returns the canonical form of the string 's' by finding the lexicographically smallest rotation of 's'. rotations = rotate_string(s) return min(rotations) def count_unique_necklaces(n, necklaces): Returns the number of unique cyclic sequences in the list of necklaces. unique_forms = set() for necklace in necklaces: canonical = canonical_form(necklace) unique_forms.add(canonical) return len(unique_forms)"},{"question":"def generatePrimes(n: int) -> List[int]: Write a function that takes a single integer parameter, \`n\`, and returns an array of the first \`n\` prime numbers. A prime number is a positive integer greater than 1 that has no positive divisors other than 1 and itself. >>> generatePrimes(5) [2, 3, 5, 7, 11] >>> generatePrimes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] from solution import generatePrimes def test_generatePrimes_first_5_primes(): assert generatePrimes(5) == [2, 3, 5, 7, 11] def test_generatePrimes_first_10_primes(): assert generatePrimes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_generatePrimes_0_primes(): assert generatePrimes(0) == [] def test_generatePrimes_1_prime(): assert generatePrimes(1) == [2] def test_generatePrimes_negative_input(): assert generatePrimes(-5) == [] def test_generatePrimes_larger_number(): assert generatePrimes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]","solution":"def generatePrimes(n): Returns an array of the first n prime numbers. if n <= 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"from typing import List def three_sum(nums: List[int], target: int) -> bool: Determines whether there exist three integers in nums whose sum is equal to target. Returns True if such a combination exists, otherwise returns False. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 4, 5, 6], 20) False >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([1, 2, 3], 6) True >>> three_sum([], 10) False","solution":"def three_sum(nums, target): Determines whether there exist three integers in nums whose sum is equal to target. Returns True if such a combination exists, otherwise returns False. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def encrypt_message(message: str) -> str: Encrypt a given string following specific rules: 1. For each character in the string, compute its ASCII value. 2. For each computed ASCII value, convert it to its corresponding binary representation. 3. Concatenate all binary representations to form a long binary string. 4. Divide the long binary string into 8-bit segments (starting from the left-most bit), where each segment represents an encrypted character. If the last segment is not 8 bits long, pad it with trailing zeros to make it 8 bits. 5. Convert each 8-bit binary segment back to its ASCII character and concatenate these characters to get the final encrypted message. >>> encrypt_message(\\"Hi\\") == \\"Hi\\" >>> encrypt_message(\\"Hello\\") == \\"Hello\\" >>> encrypt_message(\\"A1!Z2@\\") == \\"A1!Z2@\\" >>> encrypt_message(\\"!@#\\") == \\"!@#\\" def test_encrypt_message_single_character(): assert encrypt_message('A') == 'A' assert encrypt_message('Z') == 'Z' def test_encrypt_message_simple_string(): assert encrypt_message('Hi') == 'Hi' assert encrypt_message('Hello') == 'Hello' def test_encrypt_message_includes_spaces(): assert encrypt_message('Hello World') == 'Hello World' def test_encrypt_message_special_characters(): assert encrypt_message('!@#') == '!@#' assert encrypt_message('123') == '123' def test_encrypt_message_mixed_characters(): assert encrypt_message('A1!Z2@') == 'A1!Z2@' def test_encrypt_message_trailing_zeros_padding(): input_string = chr(5) # ASCII 5 in binary is '00000101'. Expect padding to become '00000101' assert encrypt_message(input_string) == input_string","solution":"def encrypt_message(message: str) -> str: binary_string = ''.join(format(ord(char), '08b') for char in message) encrypted_message = ''.join(chr(int(binary_string[i:i+8], 2)) for i in range(0, len(binary_string), 8)) return encrypted_message"},{"question":"def find_peak_index(n: int, a: List[int]) -> int: Determine whether an array has exactly one peak element, and return its index (1-based). If it does not, return -1. >>> find_peak_index(5, [1, 3, 2, 4, 1]) 2 >>> find_peak_index(4, [2, 2, 2, 2]) -1 >>> find_peak_index(6, [1, 2, 3, 4, 5, 6]) -1 from solution import find_peak_index def test_multiple_peaks(): assert find_peak_index(5, [1, 3, 2, 4, 1]) == -1 def test_single_peak(): assert find_peak_index(5, [1, 3, 2, 1, 1]) == 2 def test_no_peaks_flat(): assert find_peak_index(4, [2, 2, 2, 2]) == -1 def test_no_peaks_increasing(): assert find_peak_index(6, [1, 2, 3, 4, 5, 6]) == -1 def test_peak_at_end(): assert find_peak_index(3, [1, 2, 1]) == 2 def test_peak_at_start(): assert find_peak_index(4, [4, 3, 2, 1]) == -1 def test_all_same(): assert find_peak_index(4, [1, 1, 1, 1]) == -1","solution":"def find_peak_index(n, a): peaks = [] for i in range(1, n-1): if a[i-1] < a[i] > a[i+1]: peaks.append(i + 1) if len(peaks) == 1: return peaks[0] else: return -1"},{"question":"from collections import Counter def mostFrequentChar(S: str) -> int: Given a string S consisting of lowercase and uppercase alphabet characters, calculate the frequency of the most occurring character in the string. >>> mostFrequentChar(\\"aabBBcc\\") 2 >>> mostFrequentChar(\\"xyzXYZ\\") 1 >>> mostFrequentChar(\\"a\\") 1 >>> mostFrequentChar(\\"aaaaaa\\") 6 >>> mostFrequentChar(\\"aaBBccDD\\") 2 >>> mostFrequentChar(\\"AaBbCcDdEe\\") 1 >>> large_input = \\"a\\" * 50000 + \\"b\\" * 50000 >>> mostFrequentChar(large_input) 50000","solution":"from collections import Counter def mostFrequentChar(S): Returns the frequency of the most occurring character in the string S. # Count the frequency of each character in the string char_count = Counter(S) # Find and return the maximum frequency return max(char_count.values())"},{"question":"def perform_queries(m: int, p: int, b: List[int], queries: List[List[int]]) -> List[str]: Perform a sequence of queries on array \`b\` of length \`m\`, and return the results of each query. >>> perform_queries(4, 5, [1, 3, 2, 4], [[1, 2, 3], [2, 2], [3], [1, 4, 5], [3]]) ['1 6 2 4', '2 12 4 8', '12', '2 12 4 13', '13'] >>> perform_queries(3, 7, [5, 10, 15], [[3], [1, 1, 5], [3], [2, 3], [3], [1, 2, 2], [3]]) ['15', '10 10 15', '15', '30 30 45', '45', '30 32 45', '45']","solution":"def perform_queries(m, p, b, queries): outputs = [] for query in queries: if query[0] == 1: j, y = query[1], query[2] b[j-1] += y outputs.append(\\" \\".join(map(str, b))) elif query[0] == 2: y = query[1] b = [bi * y for bi in b] outputs.append(\\" \\".join(map(str, b))) elif query[0] == 3: outputs.append(str(max(b))) return outputs"},{"question":"def is_happy_day(day_string: str) -> str: Determines if a day string represents a \\"Happy\\" day (containing a palindromic substring of at least length 2). Args: day_string (str): A string representing a day. Returns: str: \\"Happy\\" if the day is \\"Happy\\", \\"Sad\\" otherwise. Example: >>> is_happy_day(\\"abac\\") \\"Happy\\" >>> is_happy_day(\\"abcdefg\\") \\"Sad\\"","solution":"def is_happy_day(day_string): Determines if a day string represents a \\"Happy\\" day (containing a palindromic substring of at least length 2). Args: day_string (str): A string representing a day. Returns: str: \\"Happy\\" if the day is \\"Happy\\", \\"Sad\\" otherwise. length = len(day_string) for i in range(length - 1): # Check for palindromes of length 2 if day_string[i] == day_string[i + 1]: return \\"Happy\\" # Check for palindromes of length 3 if i + 2 < length and day_string[i] == day_string[i + 2]: return \\"Happy\\" return \\"Sad\\""},{"question":"def canFormArithmeticProgression(arr: List[int]) -> bool: Determines if the given list of integers can be arranged to form an arithmetic progression. Parameters: arr (list of int): The list of integers Returns: bool: True if the integers can form an arithmetic progression, False otherwise Examples: >>> canFormArithmeticProgression([3, 5, 1]) True >>> canFormArithmeticProgression([1, 2, 4]) False","solution":"def canFormArithmeticProgression(arr): Determines if the given list of integers can be arranged to form an arithmetic progression. Parameters: arr (list of int): The list of integers Returns: bool: True if the integers can form an arithmetic progression, False otherwise if len(arr) < 2: return True arr.sort() common_diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_diff: return False return True"},{"question":"def maximumProduct(numbers: List[int]) -> int: Returns the largest possible product of any three distinct numbers from the list. >>> maximumProduct([1, 10, 2, 6, 5, 3]) 300 >>> maximumProduct([-10, -10, 1, 3, 2]) 300 >>> maximumProduct([-3, -2, -1, -4, -5]) -6 >>> maximumProduct([-10, -1, 0, 1, 2, 10]) 100 >>> maximumProduct([1, 2, 3]) 6 >>> maximumProduct([1000, 2000, 3000, 4000, 5000, 6000]) 120000000 >>> maximumProduct([-10, -10, 0, 1, 2]) 200","solution":"def maximumProduct(numbers): Returns the largest possible product of any three distinct numbers from the list. numbers.sort() # Two possible candidates for the largest product: # 1. Product of three largest numbers candidate1 = numbers[-1] * numbers[-2] * numbers[-3] # 2. Product of two smallest numbers (could be negative) and the largest number candidate2 = numbers[0] * numbers[1] * numbers[-1] return max(candidate1, candidate2)"},{"question":"def total_photographs(n, weather_conditions): Given the number of days (n) and a list of weather conditions, returns the total number of photographs Amanda will take in the next n days, both outdoor and indoor. :param n: int: Number of days Amanda plans to photograph :param weather_conditions: List[int]: List of meteorological conditions for each day :return: int: Total number of photographs Amanda will take >>> total_photographs(5, [0, 2, 1, 0, 3]) 5 >>> total_photographs(3, [4, 4, 4]) 3 >>> total_photographs(1, [0]) 1","solution":"def total_photographs(n, weather_conditions): Given the number of days (n) and a list of weather conditions, returns the total number of photographs Amanda will take in the next n days, both outdoor and indoor. :param n: int: Number of days Amanda plans to photograph :param weather_conditions: List[int]: List of meteorological conditions for each day :return: int: Total number of photographs Amanda will take return n"},{"question":"def max_contiguous_subarray_sum(A): Returns the maximum sum of any contiguous subarray within the given array A. >>> max_contiguous_subarray_sum([-2, 1, -3, 4]) 4 >>> max_contiguous_subarray_sum([1, 2, 3, 4, -10]) 10 >>> max_contiguous_subarray_sum([8, -19, 5, -4, 20]) 21 >>> max_contiguous_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_contiguous_subarray_sum([-1, -2, -3, -4]) -1 pass def solve(T, test_cases): Solves multiple test cases, returning the maximum contiguous subarray sum for each. >>> test_cases = [(4, [-2, 1, -3, 4]), (5, [1, 2, 3, 4, -10])] >>> T = 2 >>> solve(T, test_cases) [4, 10] >>> test_cases = [(8, [8, -19, 5, -4, 20]), (8, [-2, -3, 4, -1, -2, 1, 5, -3])] >>> T = 2 >>> solve(T, test_cases) [21, 7] pass def test_max_contiguous_subarray_sum(): assert max_contiguous_subarray_sum([-2, 1, -3, 4]) == 4 assert max_contiguous_subarray_sum([1, 2, 3, 4, -10]) == 10 assert max_contiguous_subarray_sum([8, -19, 5, -4, 20]) == 21 assert max_contiguous_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_contiguous_subarray_sum([-1, -2, -3, -4]) == -1 def test_solve(): test_cases = [ (4, [-2, 1, -3, 4]), (5, [1, 2, 3, 4, -10]) ] T = 2 assert solve(T, test_cases) == [4, 10] test_cases = [ (8, [8, -19, 5, -4, 20]), (8, [-2, -3, 4, -1, -2, 1, 5, -3]) ] T = 2 assert solve(T, test_cases) == [21, 7] import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def max_contiguous_subarray_sum(A): Returns the maximum sum of any contiguous subarray within the given array A. max_so_far = float('-inf') max_ending_here = 0 for num in A: max_ending_here += num if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far def solve(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] results.append(max_contiguous_subarray_sum(A)) return results"},{"question":"def count_higher_earnings_days(earnings): Returns the count of days on which the earnings were higher than the previous day. >>> count_higher_earnings_days([200, 250, 180, 300, 350, 400, 320]) 4 >>> count_higher_earnings_days([200]) 0 >>> count_higher_earnings_days([100, 200, 300, 400, 500]) 4 >>> count_higher_earnings_days([500, 400, 300, 200, 100]) 0 >>> count_higher_earnings_days([100, 200, 100, 200, 100, 200]) 3 >>> count_higher_earnings_days([100, 100, 100, 100, 100]) 0 >>> count_higher_earnings_days([0]*1000) 0 >>> count_higher_earnings_days([i for i in range(1000)]) 999 # your code here","solution":"def count_higher_earnings_days(earnings): Returns the count of days on which the earnings were higher than the previous day. count = 0 for i in range(1, len(earnings)): if earnings[i] > earnings[i - 1]: count += 1 return count"},{"question":"def smallestK(N: int) -> int: Find the smallest number k such that the sum of the squares of the first k positive integers is greater than or equal to N. >>> smallestK(1) 1 >>> smallestK(5) 2 >>> smallestK(15) 4 >>> smallestK(14) 3","solution":"def smallestK(N): Find the smallest number k such that the sum of the squares of the first k positive integers is greater than or equal to N. sum_of_squares = 0 k = 0 while sum_of_squares < N: k += 1 sum_of_squares += k * k return k if sum_of_squares >= N else -1"},{"question":"def count_subarrays_with_product_less_than_k(arr: List[int], k: int) -> int: Determine the number of contiguous subarrays for which the product of all elements in the subarray is less than K. >>> count_subarrays_with_product_less_than_k([10, 5, 2, 6], 100) 8 >>> count_subarrays_with_product_less_than_k([1, 2, 3], 0) 0 def process_test_cases(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Process multiple test cases and return the list of results for each test case. >>> process_test_cases(2, [(4, [10, 5, 2, 6], 100), (3, [1, 2, 3], 0)]) [8, 0]","solution":"def count_subarrays_with_product_less_than_k(arr, k): if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product //= arr[left] left += 1 count += right - left + 1 return count def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr, k = test_cases[i] result = count_subarrays_with_product_less_than_k(arr, k) results.append(result) return results"},{"question":"def is_prime_like(n: int) -> str: Determine whether n is a prime-like number. A number is considered \\"prime-like\\" if it contains exactly three distinct prime factors. >>> is_prime_like(30) == \\"YES\\" >>> is_prime_like(15) == \\"NO\\"","solution":"def is_prime_like(n): Returns \\"YES\\" if the number n contains exactly three distinct prime factors, otherwise \\"NO\\". def prime_factors(n): i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors primes = prime_factors(n) return \\"YES\\" if len(primes) == 3 else \\"NO\\""},{"question":"def min_instructions_to_erase(N: int, M: int, instructions: List[str]) -> int: Determine the minimum number of instructions to erase to make the remaining instructions logically consistent. >>> min_instructions_to_erase(4, 5, [\\"S 1 2\\", \\"C 1 red\\", \\"S 2 3\\", \\"C 2 blue\\", \\"S 3 4\\"]) 1 >>> min_instructions_to_erase(4, 6, [\\"S 1 2\\", \\"S 2 3\\", \\"C 1 red\\", \\"C 3 blue\\", \\"C 2 blue\\", \\"S 1 4\\"]) 2 >>> min_instructions_to_erase(4, 4, [\\"S 1 2\\", \\"C 1 red\\", \\"S 2 3\\", \\"S 3 4\\"]) 0 >>> min_instructions_to_erase(3, 4, [\\"S 1 2\\", \\"C 1 blue\\", \\"S 2 3\\", \\"C 3 red\\"]) 1 >>> min_instructions_to_erase(3, 2, [\\"S 1 3\\", \\"C 2 blue\\"]) 0","solution":"def min_instructions_to_erase(N, M, instructions): parent = list(range(N + 1)) color = [-1] * (N + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX to_erase = 0 for ins in instructions: parts = ins.split() if parts[0] == 'S': a, b = int(parts[1]), int(parts[2]) for i in range(a, b): union(i, i + 1) elif parts[0] == 'C': a, c = int(parts[1]), parts[2] root = find(a) if color[root] == -1: color[root] = c elif color[root] != c: to_erase += 1 for ins in instructions: parts = ins.split() if parts[0] == 'S': a, b = int(parts[1]), int(parts[2]) a_color = color[find(a)] for i in range(a + 1, b + 1): if a_color != -1 and color[find(i)] != -1 and color[find(i)] != a_color: to_erase += 1 break return to_erase # Process input def solve_from_input(input_str): input_lines = input_str.strip().split('n') N, M = map(int, input_lines[0].split()) instructions = input_lines[1:] return min_instructions_to_erase(N, M, instructions)"},{"question":"def addLinkedLists(head1, head2): Add two numbers represented by two linked lists and return the sum as a new linked list. Each linked list represents a positive integer in reverse order. Args: head1: ListNode - The head node of the first linked list. head2: ListNode - The head node of the second linked list. Returns: ListNode - The head node of the resulting linked list representing the sum. Example: >>> list_to_linked_list = lambda lst: list_to_linked_list(lst) >>> linked_list_to_list = lambda node: linked_list_to_list(node) >>> head1 = list_to_linked_list([2, 4, 3]) >>> head2 = list_to_linked_list([5, 6, 4]) >>> linked_list_to_list(addLinkedLists(head1, head2)) [7, 0, 8] >>> head1 = list_to_linked_list([9, 9, 9]) >>> head2 = list_to_linked_list([1]) >>> linked_list_to_list(addLinkedLists(head1, head2)) [0, 0, 0, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addLinkedLists(head1, head2): dummy = ListNode(0) current = dummy carry = 0 while head1 is not None or head2 is not None: x = head1.val if head1 is not None else 0 y = head2.val if head2 is not None else 0 sum = carry + x + y carry = sum // 10 current.next = ListNode(sum % 10) current = current.next if head1 is not None: head1 = head1.next if head2 is not None: head2 = head2.next if carry > 0: current.next = ListNode(carry) return dummy.next"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path in the grid from top-left to bottom-right. If no path exists, returns -1. >>> shortest_path([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ]) 9 >>> shortest_path([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) -1","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path in the grid from top-left to bottom-right. If no path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we reached the bottom-right corner if r == n-1 and c == m-1: return dist # Check all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 # If there's no path"},{"question":"from typing import List, Tuple def zigzag_level_order(n: int, edges: List[Tuple[int, int, str]]) -> List[int]: You are given a binary tree with N nodes, where each node has a unique value between 1 and N. Your task is to perform a zigzag level order traversal of the binary tree, also known as \\"zigzag\\" or \\"spiral\\" traversal, where the nodes at each depth of the tree are traversed alternately from left to right and right to left. >>> zigzag_level_order(7, [(1, 2, 'L'), (1, 3, 'R'), (2, 4, 'L'), (2, 5, 'R'), (3, 6, 'L'), (3, 7, 'R')]) [1, 3, 2, 4, 5, 6, 7] >>> zigzag_level_order(5, [(1, 2, 'L'), (1, 3, 'R'), (2, 4, 'L'), (2, 5, 'R')]) [1, 3, 2, 4, 5]","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def zigzag_level_order(n, edges): if n == 0: return [] nodes = {i: TreeNode(i) for i in range(1, n + 1)} for u, v, c in edges: if c == 'L': nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] root = nodes[1] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_values = deque() for _ in range(level_size): node = current_level.popleft() if left_to_right: level_values.append(node.value) else: level_values.appendleft(node.value) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.extend(level_values) left_to_right = not left_to_right return list(result)"},{"question":"def sort_paintings(n: int, paintings: List[Tuple[int, int]], criteria: str) -> List[Tuple[int, int]]: Sorts a list of paintings based on the given criteria. Parameters: n : int : The number of paintings paintings : list of tuples : List containing tuples of two integers representing height and width criteria : str : The sorting criteria, either \\"width\\" or \\"height\\" Returns: list : Sorted list of paintings Example: >>> sort_paintings(4, [(90, 120), (85, 135), (90, 130), (60, 140)], \\"width\\") [(90, 120), (90, 130), (85, 135), (60, 140)] >>> sort_paintings(3, [(80, 100), (60, 95), (70, 90)], \\"height\\") [(60, 95), (70, 90), (80, 100)]","solution":"def sort_paintings(n, paintings, criteria): Sorts a list of paintings based on the given criteria. Parameters: n : int : The number of paintings paintings : list of tuples : List containing tuples of two integers representing height and width criteria : str : The sorting criteria, either \\"width\\" or \\"height\\" Returns: list : Sorted list of paintings if criteria == \\"width\\": sorted_paintings = sorted(paintings, key=lambda x: x[1]) else: sorted_paintings = sorted(paintings, key=lambda x: x[0]) return sorted_paintings"},{"question":"from typing import List def can_reach_target(grid: List[str], M: int, N: int) -> bool: Determine if the robot can reach the target position on the grid. >>> grid1 = [ ... \\"B.#.\\", ... \\".#.#\\", ... \\"..#T\\", ... \\"....\\" ...] >>> can_reach_target(grid1, 4, 4) True >>> grid2 = [ ... \\"B.#.\\", ... \\".#.#\\", ... \\"..#T\\", ... \\"...#\\" ...] >>> can_reach_target(grid2, 4, 4) False >>> grid3 = [ ... \\"B..#\\", ... \\"...#\\", ... \\"..#T\\", ... \\"....\\" ...] >>> can_reach_target(grid3, 4, 4) True >>> grid4 = [ ... \\"..#.\\", ... \\"B.#.\\", ... \\"..#T\\", ... \\"....\\" ...] >>> can_reach_target(grid4, 4, 4) True >>> grid5 = [ ... \\"B...\\", ... \\"....\\", ... \\"....\\", ... \\"...T\\" ...] >>> can_reach_target(grid5, 4, 4) True >>> grid6 = [ ... \\"B#..\\", ... \\"#..#\\", ... \\"..#T\\", ... \\"#...\\" ...] >>> can_reach_target(grid6, 4, 4) False pass","solution":"from typing import List from collections import deque def can_reach_target(grid: List[str], M: int, N: int) -> bool: # Locate the starting position 'B' and target position 'T' start = None target = None for i in range(M): for j in range(N): if grid[i][j] == 'B': start = (i, j) elif grid[i][j] == 'T': target = (i, j) if not start or not target: return False # Define the directions - North, East, South, West directions = [(-1, 0), (0, 1), (1, 0), (0, -1)] # Use a queue for BFS queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != '#' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def gcd_fib(a: int, b: int) -> int: Function to calculate the GCD of Fib(a) and Fib(b) using the relation: GCD(Fib(a), Fib(b)) = Fib(GCD(a, b)) >>> gcd_fib(10, 15) 5 >>> gcd_fib(21, 21) 10946 >>> gcd_fib(0, 5) 5 >>> gcd_fib(1000, 1001) 1 >>> gcd_fib(1, 1) 1 pass","solution":"def gcd(a, b): Helper function to calculate the GCD of two numbers using the Euclidean algorithm. while b: a, b = b, a % b return a def fib(n): Helper function to calculate the n-th Fibonacci number using matrix exponentiation. This function can effectively compute Fibonacci numbers up to very large n, leveraging the properties of matrix exponentiation. if n == 0: return 0 if n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_pow(M, power): result = [[1, 0], [0, 1]] base = M while power: if power % 2 != 0: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result Q = [[1, 1], [1, 0]] Q_n = matrix_pow(Q, n-1) return Q_n[0][0] def gcd_fib(a, b): Function to calculate the GCD of Fib(a) and Fib(b) using the relation: GCD(Fib(a), Fib(b)) = Fib(GCD(a, b)) gcd_ab = gcd(a, b) return fib(gcd_ab)"},{"question":"def rotateArray(ar, k): Rotates the array to the right by k steps. Parameters: ar (list): Array of integers. k (int): Number of steps to rotate the array to the right. Returns: list: Array after rotating it to the right by k steps. >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotateArray([1], 10) [1] >>> rotateArray([1, 1, 1, 1], 2) [1, 1, 1, 1] >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 1) [7, 1, 2, 3, 4, 5, 6]","solution":"def rotateArray(ar, k): Rotates the array to the right by k steps. Parameters: ar (list): Array of integers. k (int): Number of steps to rotate the array to the right. Returns: list: Array after rotating it to the right by k steps. n = len(ar) k = k % n # In case k is greater than n return ar[-k:] + ar[:-k]"},{"question":"def length_of_shortest_word(sentence: str) -> int: Returns the length of the shortest word in the given sentence. A word is defined as any sequence of non-space characters. >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") == 3 >>> length_of_shortest_word(\\"Hello, world! This is a test sentence.\\") == 1 >>> length_of_shortest_word(\\"To be or not to be, that is the question.\\") == 2 >>> length_of_shortest_word(\\"\\") == 0 # Empty string case >>> length_of_shortest_word(\\"Supercalifragilisticexpialidocious\\") == 34 # Single long word >>> length_of_shortest_word(\\"A quick brown fox.\\") == 1 # Presence of punctuations >>> length_of_shortest_word(\\"123 4567 89\\") == 2 # Digit sequences as words","solution":"def length_of_shortest_word(sentence): Returns the length of the shortest word in the given sentence. A word is defined as any sequence of non-space characters. :param sentence: str :return: int words = sentence.split() if not words: return 0 short_word_length = len(words[0]) for word in words: if len(word) < short_word_length: short_word_length = len(word) return short_word_length"},{"question":"def can_carry_all_items(W: int, N: int, items: List[str]) -> str: Determines if the player can carry all items without exceeding the weight limit. :param W: int, maximum weight limit the player can carry :param N: int, number of items :param items: list of strings, types of items in the inventory :return: str, \\"Yes\\" if the player can carry all items, otherwise \\"No\\" item_weights = { \\"Healing Potion\\": 1, \\"Magic Scroll\\": 2, \\"Sword\\": 3, \\"Shield\\": 4 } # Write your code here def test_example_1(): W = 10 N = 5 items = [\\"Healing Potion\\", \\"Magic Scroll\\", \\"Sword\\", \\"Healing Potion\\", \\"Shield\\"] assert can_carry_all_items(W, N, items) == \\"No\\" def test_example_2(): W = 15 N = 6 items = [\\"Healing Potion\\", \\"Magic Scroll\\", \\"Sword\\", \\"Healing Potion\\", \\"Shield\\", \\"Sword\\"] assert can_carry_all_items(W, N, items) == \\"Yes\\" def test_exact_limit(): W = 10 N = 4 items = [\\"Sword\\", \\"Sword\\", \\"Healing Potion\\", \\"Magic Scroll\\"] assert can_carry_all_items(W, N, items) == \\"Yes\\" def test_over_limit(): W = 5 N = 3 items = [\\"Sword\\", \\"Magic Scroll\\", \\"Healing Potion\\"] assert can_carry_all_items(W, N, items) == \\"No\\" def test_under_limit(): W = 20 N = 7 items = [\\"Healing Potion\\"] * 7 assert can_carry_all_items(W, N, items) == \\"Yes\\" def test_no_items(): W = 10 N = 0 items = [] assert can_carry_all_items(W, N, items) == \\"Yes\\" def test_single_item_yes(): W = 3 N = 1 items = [\\"Sword\\"] assert can_carry_all_items(W, N, items) == \\"Yes\\" def test_single_item_no(): W = 2 N = 1 items = [\\"Sword\\"] assert can_carry_all_items(W, N, items) == \\"No\\"","solution":"def can_carry_all_items(W, N, items): Determines if the player can carry all items without exceeding the weight limit. :param W: int, maximum weight limit the player can carry :param N: int, number of items :param items: list of strings, types of items in the inventory :return: str, \\"Yes\\" if the player can carry all items, otherwise \\"No\\" item_weights = { \\"Healing Potion\\": 1, \\"Magic Scroll\\": 2, \\"Sword\\": 3, \\"Shield\\": 4 } total_weight = 0 for item in items: total_weight += item_weights[item] return \\"Yes\\" if total_weight <= W else \\"No\\""},{"question":"from typing import List def rearrangeArray(arr: List[int]) -> None: Rearranges the array such that all zeroes are moved to the end while maintaining the order of the non-zero elements. >>> arr = [0, 1, 0, 3, 12, 0] >>> rearrangeArray(arr) >>> arr [1, 3, 12, 0, 0, 0] >>> arr = [0, 0, 0, 0, 0] >>> rearrangeArray(arr) >>> arr [0, 0, 0, 0, 0] >>> arr = [1, 2, 3, 4, 5] >>> rearrangeArray(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [0, 4, 0, 5, 0, 6] >>> rearrangeArray(arr) >>> arr [4, 5, 6, 0, 0, 0] >>> arr = [1, 2, 0, 0, 0] >>> rearrangeArray(arr) >>> arr [1, 2, 0, 0, 0] >>> arr = [0, 0, 1, 2, 3] >>> rearrangeArray(arr) >>> arr [1, 2, 3, 0, 0] >>> arr = [0, -1, 0, -3, 12, 0] >>> rearrangeArray(arr) >>> arr [-1, -3, 12, 0, 0, 0]","solution":"from typing import List def rearrangeArray(arr: List[int]) -> None: Rearranges the array such that all zeroes are moved to the end while maintaining the order of the non-zero elements. # Pointer for the next position of the non-zero element last_non_zero_index = 0 # Iterate through the array for i in range(len(arr)): if arr[i] != 0: # Swap only if the current element is non-zero and needed to be swapped if i != last_non_zero_index: arr[last_non_zero_index], arr[i] = arr[i], arr[last_non_zero_index] last_non_zero_index += 1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"def caesar_cipher(text: str, shift: int) -> str: Applies a Caesar cipher shift on each letter in the text. Parameters: text (str): The input string to encrypt. shift (int): The number of positions each letter should be shifted. Returns: str: The encrypted string with all its letters shifted by the specified number of positions. >>> caesar_cipher(\\"Hello, World!\\", 5) 'Mjqqt, Btwqi!' >>> caesar_cipher(\\"abcXYZ\\", 2) 'cdeZAB' >>> caesar_cipher(\\"aBc\\", 1) 'bCd' >>> caesar_cipher(\\"xYz\\", 3) 'aBc' >>> caesar_cipher(\\"Hello, World!\\", 0) 'Hello, World!' >>> caesar_cipher(\\"abc\\", 26) 'abc' >>> caesar_cipher(\\"XYZ\\", 26) 'XYZ' >>> caesar_cipher(\\"123 abc !@#\\", 3) '123 def !@#' >>> caesar_cipher(\\"def\\", -1) 'cde' >>> caesar_cipher(\\"ABC\\", -3) 'XYZ' >>> caesar_cipher(\\"abc\\", 52) 'abc' >>> caesar_cipher(\\"ABC\\", 78) 'ABC'","solution":"def caesar_cipher(text, shift): Applies a Caesar cipher shift on each letter in the text. Parameters: text (str): The input string to encrypt. shift (int): The number of positions each letter should be shifted. Returns: str: The encrypted string with all its letters shifted by the specified number of positions. result = [] for char in text: if char.isupper(): result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) elif char.islower(): result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) else: result.append(char) return ''.join(result)"},{"question":"def count_distinct_pairs(n: int) -> int: Returns the number of distinct pairs (a, b) such that 1 <= a, b <= n and a * b is a perfect square. >>> count_distinct_pairs(2) 2 >>> count_distinct_pairs(3) 3 >>> count_distinct_pairs(4) 6 def solve(t: int, test_cases: List[int]) -> List[int]: For each test case, returns the number of distinct pairs (a, b) such that 1 <= a, b <= n and a * b is a perfect square. >>> solve(3, [2, 3, 4]) [2, 3, 6] >>> solve(1, [1]) [1] >>> solve(2, [4, 5]) [6, 7]","solution":"def count_distinct_pairs(n): Returns the number of distinct pairs (a, b) such that 1 <= a, b <= n and a * b is a perfect square. count = 0 for a in range(1, n + 1): for b in range(a, n + 1): if (a * b)**0.5 == int((a * b)**0.5): count += 1 if a == b else 2 return count def solve(t, test_cases): results = [] for n in test_cases: results.append(count_distinct_pairs(n)) return results"},{"question":"def merge_and_sort_lists(list1, list2): Merge two lists of integers and sort the merged list based on the following rule: The list should be sorted primarily by the descending order of elements, and if two elements are equal, they should be sorted based on which list they came from—elements from the first list should come before elements from the second list. Args: list1 (List[int]): First list of integers. list2 (List[int]): Second list of integers. Returns: List[int]: The merged and sorted list of integers. Examples: >>> merge_and_sort_lists([9, 2, 5, 7], [3, 6, 2, 7]) [9, 7, 7, 6, 5, 3, 2, 2] >>> merge_and_sort_lists([1, 2, 3], [1, 2, 3]) [3, 3, 2, 2, 1, 1]","solution":"def merge_and_sort_lists(list1, list2): Merges two lists and sorts the merged list in descending order. If two elements are equal, elements from the first list come before those from the second list. # Create a list of tuples where each tuple is (element, list_indicator) merged_list = [(num, 1) for num in list1] + [(num, 2) for num in list2] # Sort the merged list based on the element value first (descending), then by list_indicator merged_list.sort(key=lambda x: (-x[0], x[1])) # Return only the elements in the sorted order return [x[0] for x in merged_list]"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Checks if the given two strings are anagrams of each other ignoring case, spaces, and punctuation. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True >>> is_anagram(\\"hello\\", \\"world\\") False","solution":"import string def is_anagram(str1: str, str2: str) -> bool: Checks if the given two strings are anagrams of each other ignoring case, spaces, and punctuation. # Remove spaces and punctuation, and convert to lowercase translator = str.maketrans('', '', string.whitespace + string.punctuation) normalized_str1 = str1.translate(translator).lower() normalized_str2 = str2.translate(translator).lower() # Check if sorted characters of both strings are the same return sorted(normalized_str1) == sorted(normalized_str2)"},{"question":"from typing import List def max_min_distance(n: int, m: int, positions: List[int]) -> int: Returns the maximum possible minimum distance between any two planted trees. Parameters: n (int): The number of planting points. m (int): The number of trees to be planted. positions (List[int]): The positions of the planting points on the road in increasing order. Returns: int: The maximum possible minimum distance between any two planted trees. Examples: >>> max_min_distance(5, 3, [1, 2, 8, 4, 9]) 3 >>> max_min_distance(6, 4, [1, 2, 6, 7, 8, 11]) 2 pass","solution":"def can_place_trees(positions, n, m, min_dist): Helper function to check if m trees can be placed with at least min_dist distance apart. count = 1 # Place the first tree at the first position last_position = positions[0] for i in range(1, n): if positions[i] - last_position >= min_dist: count += 1 last_position = positions[i] if count == m: return True return False def max_min_distance(n, m, positions): Returns the maximum possible minimum distance between any two planted trees. positions.sort() low, high = 1, positions[-1] - positions[0] result = 0 while low <= high: mid = (low + high) // 2 if can_place_trees(positions, n, m, mid): result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"def max_sum_no_adjacent_elements(n: int, array: List[int]) -> int: Finds the maximum possible sum of a subarray with no two adjacent elements. Parameters: n (int): The length of the array. array (List[int]): The list of integers representing the elements of the array. Returns: int: The maximum sum of the subarray with no two adjacent elements. >>> max_sum_no_adjacent_elements(5, [3, 2, 5, 10, 7]) 15 >>> max_sum_no_adjacent_elements(6, [3, 2, 7, 10, 12, 7]) 22 >>> max_sum_no_adjacent_elements(4, [2, 1, 1, 2]) 4","solution":"def max_sum_no_adjacent_elements(n, array): Finds the maximum possible sum of a subarray with no two adjacent elements. Parameters: n (int): The length of the array. array (List[int]): The list of integers representing the elements of the array. Returns: int: The maximum sum of the subarray with no two adjacent elements. if n == 0: return 0 if n == 1: return max(0, array[0]) incl = array[0] excl = 0 for i in range(1, n): new_excl = max(excl, incl) incl = excl + array[i] excl = new_excl return max(incl, excl)"},{"question":"def get_reminder_list(events): Given a list of events with guests attending each event, return the list of guests who should receive a reminder for each event, starting from the second event. Args: events: List of lists, where each sublist represents guest IDs for an event. Returns: reminder_guests: List of lists, where each sublist contains guest IDs who should receive a reminder. >>> get_reminder_list([[1, 2, 3], [2, 3, 4], [1, 2], [2, 5]]) [[4], [1], [5]] >>> get_reminder_list([[5, 6, 7], [8, 5], [5, 9, 8]]) [[8], [9]] >>> get_reminder_list([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[4, 5, 6], [7, 8, 9]] >>> get_reminder_list([[10, 20, 30], [10, 20, 30], [10, 20, 30]]) [[], []] >>> get_reminder_list([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) [[4], [5]]","solution":"def get_reminder_list(events): Given a list of events with guests attending each event, return the list of guests who should receive a reminder for each event, starting from the second event. Args: events: List of lists, where each sublist represents guest IDs for an event. Returns: reminder_guests: List of lists, where each sublist contains guest IDs who should receive a reminder. reminder_guests = [] for i in range(1, len(events)): current_event = events[i] previous_event = events[i - 1] previous_event_set = set(previous_event) reminder_for_current_event = [guest for guest in current_event if guest not in previous_event_set] reminder_guests.append(reminder_for_current_event) return reminder_guests"},{"question":"def smallest_difference_between_highest_quantities(n, quantities): Returns the smallest difference between the two highest quantities in the list. Parameters: n (int): number of ingredients. quantities (list of int): quantities of ingredients. Returns: int: smallest difference between the two highest quantities. >>> smallest_difference_between_highest_quantities(5, [3, 1, 9, 7, 8]) 1 >>> smallest_difference_between_highest_quantities(4, [8, 8, 8, 8]) 0 >>> smallest_difference_between_highest_quantities(3, [10, 5, 15]) 5 >>> smallest_difference_between_highest_quantities(5, [1, 5, 3, 8, 8]) 0 >>> smallest_difference_between_highest_quantities(3, [1, 100, 1]) 99","solution":"def smallest_difference_between_highest_quantities(n, quantities): Returns the smallest difference between the two highest quantities in the list. Parameters: n (int): number of ingredients. quantities (list of int): quantities of ingredients. Returns: int: smallest difference between the two highest quantities. quantities.sort() return abs(quantities[-1] - quantities[-2])"},{"question":"from typing import List, Tuple def manage_dragons(n: int, k: int, q: int, dragons: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Valyria is renowned for its dragon breeding, consisting of several breeds and dragons with specific power levels. Implement the following queries: 1. 1 p x: Add dragon with power level p to breed x. 2. 2 x y: Determine the strongest breed between x and y based on their total power. Args: n (int): Number of initial dragons k (int): Number of breeds q (int): Number of queries dragons (List[Tuple[int, int]]): A list of tuples representing the power and breed of each dragon queries (List[Tuple[int, int, int]]): A list of queries Returns: List[int]: A list of results for each type 2 query Example: >>> manage_dragons(7, 3, 6, [(10, 2), (5, 1), (8, 2), (7, 1), (6, 3), (3, 3), (12, 2)], [(2, 2, 1), (2, 3, 1), (1, 9, 1), (2, 1, 2), (2, 2, 3), (2, 1, 3)]) [2, 1, 2, 2, 1]","solution":"def manage_dragons(n, k, q, dragons, queries): breed_power = [0] * (k + 1) for power, breed in dragons: breed_power[breed] += power results = [] for query in queries: if query[0] == 1: p, x = query[1], query[2] breed_power[x] += p elif query[0] == 2: x, y = query[1], query[2] if breed_power[x] > breed_power[y]: results.append(x) elif breed_power[x] < breed_power[y]: results.append(y) else: results.append(min(x, y)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 from solution import length_of_longest_substring def test_length_of_longest_substring_example_1(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_length_of_longest_substring_example_2(): assert length_of_longest_substring(\\"bbbbb\\") == 1 def test_length_of_longest_substring_example_3(): assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_length_of_longest_substring_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_length_of_longest_substring_all_unique(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_length_of_longest_substring_repeating_characters(): assert length_of_longest_substring(\\"aab\\") == 2 def test_length_of_longest_substring_mixed_characters(): assert length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence. >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([42]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1, 100, 2, 99, 3, 98, 4, 97, 5, 96]) 6","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence. if not sequence: return 0 n = len(sequence) dp = [1] * n # Store the length of LIS up to each element for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) sequence = list(map(int, data[1:])) result = longest_increasing_subsequence(sequence) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_number_of_boxes(n: int, W: int, weights: List[int]) -> int: Return the minimum number of boxes required to pack all items with given weight each box can hold. Return -1 if any item weight exceeds the permissible box weight. >>> min_number_of_boxes(5, 10, [2, 5, 4, 7, 1]) 2 >>> min_number_of_boxes(3, 8, [9, 2, 3]) -1","solution":"from typing import List, Tuple def min_number_of_boxes(n: int, W: int, weights: List[int]) -> int: Return the minimum number of boxes required to pack all items with given weight each box can hold. Return -1 if any item weight exceeds the permissible box weight. # Check if any item exceeds the box weight limit for weight in weights: if weight > W: return -1 # Sort weights in descending order weights.sort(reverse=True) # Use a list to track current weight in each used box boxes = [] for weight in weights: placed = False # Try to place each item in an existing box for i in range(len(boxes)): if boxes[i] + weight <= W: boxes[i] += weight placed = True break # If not placed in any existing box, create a new one if not placed: boxes.append(weight) return len(boxes)"},{"question":"def min_cost_paint_houses(N: int, costs: List[List[int]]) -> int: Calculate the minimum cost to paint N houses such that no two adjacent houses have the same color. >>> min_cost_paint_houses(3, [[17, 2, 17], [16, 16, 5], [14, 3, 19]]) == 10 >>> min_cost_paint_houses(1, [[10, 5, 1]]) == 1 >>> min_cost_paint_houses(2, [[1, 100, 100], [100, 1, 100]]) == 2","solution":"def min_cost_paint_houses(N, costs): if N == 0: return 0 dp = costs[0][:] # Costs of painting the first house for i in range(1, N): new_dp = [0] * 3 new_dp[0] = costs[i][0] + min(dp[1], dp[2]) new_dp[1] = costs[i][1] + min(dp[0], dp[2]) new_dp[2] = costs[i][2] + min(dp[0], dp[1]) dp = new_dp return min(dp) # Function to read input and call the min_cost_paint_houses function def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) costs = [] index = 1 for i in range(N): row = [int(data[index]), int(data[index+1]), int(data[index+2])] costs.append(row) index += 3 result = min_cost_ppaint_houses(N, costs) print(result)"},{"question":"def count_late_processes(test_cases): Determine how many processes will be late given the list of processes along with their execution times and deadlines in the order they arrive. >>> count_late_processes([ (3, [(2, 5), (3, 6), (1, 8)]), (4, [(4, 10), (2, 8), (3, 6), (2, 5)]) ]) == [0, 2] # Implement this function def parse_input(input_data): Parse input data into a format suitable for count_late_processes function. >>> parse_input(\\"2n3n2 5n3 6n1 8n4n4 10n2 8n3 6n2 5\\") == [(3, [(2, 5), (3, 6), (1, 8)]), (4, [(4, 10), (2, 8), (3, 6), (2, 5)])] # Implement this function","solution":"def count_late_processes(test_cases): results = [] for case in test_cases: N = case[0] processes = case[1] current_time = 0 late_count = 0 for execution_time, deadline in processes: current_time += execution_time if current_time > deadline: late_count += 1 results.append(late_count) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) processes = [] index += 1 for _ in range(N): Ti, Di = map(int, lines[index].split()) processes.append((Ti, Di)) index += 1 test_cases.append((N, processes)) return test_cases"},{"question":"def is_anagram_of_palindrome(s: str) -> bool: Determine if a string is an anagram of a palindrome. A string is an anagram of a palindrome if at most one character has an odd frequency. >>> is_anagram_of_palindrome(\\"carrace\\") == True >>> is_anagram_of_palindrome(\\"hello\\") == False pass def process_test_cases(test_cases: List[str]) -> List[str]: Process a list of strings, determining if each string is an anagram of a palindrome. Args: - test_cases (List[str]): A list of strings to be checked. Returns: - List[str]: A list with \\"YES\\" or \\"NO\\" for each input string respectively. >>> process_test_cases([\\"carrace\\", \\"hello\\"]) == [\\"YES\\", \\"NO\\"] >>> process_test_cases([\\"aabb\\", \\"abcba\\", \\"abcde\\", \\"xyz\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_anagram_of_palindrome(s): Determine if a string is an anagram of a palindrome. A string is an anagram of a palindrome if at most one character has an odd frequency. from collections import Counter count = Counter(s) odd_count = sum(1 for char_count in count.values() if char_count % 2 != 0) return odd_count <= 1 def process_test_cases(test_cases): results = [] for s in test_cases: if is_anagram_of_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_task_time_difference(durations: List[int]) -> int: Returns the minimum possible difference in total working time between Worker A and Worker B. >>> min_task_time_difference([1, 2, 3, 4, 5]) 1 >>> min_task_time_difference([10]) 10 >>> min_task_time_difference([5, 5]) 0 >>> min_task_time_difference([10, 2]) 8 >>> min_task_time_difference([1 for _ in range(100)]) 0 >>> min_task_time_difference([1, 3, 4, 9]) 1 >>> min_task_time_difference([6, 5, 4]) 3 >>> min_task_time_difference([8, 7, 6, 5, 4, 3, 2, 1]) 0 pass from typing import List def test_example_case(): assert min_task_time_difference([1, 2, 3, 4, 5]) == 1 def test_single_task(): assert min_task_time_difference([10]) == 10 def test_two_equal_tasks(): assert min_task_time_difference([5, 5]) == 0 def test_two_different_tasks(): assert min_task_time_difference([10, 2]) == 8 def test_large_number_of_small_tasks(): assert min_task_time_difference([1 for _ in range(100)]) == 0 def test_mixed_tasks(): assert min_task_time_difference([1, 3, 4, 9]) == 1 def test_another_case(): assert min_task_time_difference([6, 5, 4]) == 3 def test_advanced_case(): assert min_task_time_difference([8, 7, 6, 5, 4, 3, 2, 1]) == 0","solution":"def min_task_time_difference(durations): Returns the minimum possible difference in total working time between Worker A and Worker B. total_sum = sum(durations) n = len(durations) # Create a DP array to find the subset sum closest to total_sum // 2 dp = [0] * (total_sum // 2 + 1) for duration in durations: for j in range(total_sum // 2, duration - 1, -1): dp[j] = max(dp[j], dp[j - duration] + duration) subset_sum = dp[total_sum // 2] other_subset_sum = total_sum - subset_sum return abs(other_subset_sum - subset_sum)"},{"question":"def can_form_interleaved_string(first: str, second: str, third: str) -> str: Check if the third string can be formed by interleaving the characters of the first two strings. >>> can_form_interleaved_string(\\"abc\\", \\"def\\", \\"adbcef\\") 'Yes' >>> can_form_interleaved_string(\\"abc\\", \\"def\\", \\"abcdefg\\") 'No' >>> can_form_interleaved_string(\\"\\", \\"abc\\", \\"abc\\") 'Yes' >>> can_form_interleaved_string(\\"aaa\\", \\"aaa\\", \\"aaaaaa\\") 'Yes' >>> can_form_interleaved_string(\\"aabcc\\", \\"dbbca\\", \\"aadbbcbcac\\") 'Yes' >>> can_form_interleaved_string(\\"a\\", \\"a\\", \\"a\\") 'No' def test_basic_yes(): assert can_form_interleaved_string(\\"abc\\", \\"def\\", \\"adbcef\\") == \\"Yes\\" def test_basic_no(): assert can_form_interleaved_string(\\"abc\\", \\"def\\", \\"abcdefg\\") == \\"No\\" def test_interleaved_with_empty_string(): assert can_form_interleaved_string(\\"\\", \\"abc\\", \\"abc\\") == \\"Yes\\" assert can_form_interleaved_string(\\"abc\\", \\"\\", \\"abc\\") == \\"Yes\\" assert can_form_interleaved_string(\\"\\", \\"\\", \\"\\") == \\"Yes\\" def test_same_characters(): assert can_form_interleaved_string(\\"aaa\\", \\"aaa\\", \\"aaaaaa\\") == \\"Yes\\" assert can_form_interleaved_string(\\"aaa\\", \\"aaa\\", \\"aaa\\") == \\"No\\" assert can_form_interleaved_string(\\"aaa\\", \\"aaa\\", \\"aaab\\") == \\"No\\" def test_complex_case(): assert can_form_interleaved_string(\\"aabcc\\", \\"dbbca\\", \\"aadbbcbcac\\") == \\"Yes\\" assert can_form_interleaved_string(\\"aabcc\\", \\"dbbca\\", \\"aadbbbaccc\\") == \\"No\\" def test_minimum_length(): assert can_form_interleaved_string(\\"a\\", \\"a\\", \\"a\\") == \\"No\\" assert can_form_interleaved_string(\\"a\\", \\"a\\", \\"aa\\") == \\"Yes\\" def test_maximum_length(): first = \\"a\\" * 100 second = \\"b\\" * 100 third = \\"a\\" * 100 + \\"b\\" * 100 assert can_form_interleaved_string(first, second, third) == \\"Yes\\" third = \\"ab\\" * 100 assert can_form_interleaved_string(first, second, third) == \\"Yes\\"","solution":"def can_form_interleaved_string(first, second, third): # Check if the combined length of 'first' and 'second' matches the length of 'third' if len(first) + len(second) != len(third): return \\"No\\" # Create a 2D list to use as a DP table dp = [[False] * (len(second) + 1) for _ in range(len(first) + 1)] dp[0][0] = True # Fill the dp table for i in range(len(first) + 1): for j in range(len(second) + 1): if i > 0 and first[i - 1] == third[i + j - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and second[j - 1] == third[i + j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return \\"Yes\\" if dp[len(first)][len(second)] else \\"No\\""},{"question":"def max_concurrent_requests(test_cases): Determine the maximum number of concurrent requests the server handled at any time. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases where each test case is a list of requests, and each request is represented by a tuple (t, type). Returns: List[int]: List of integers representing the maximum number of concurrent requests for each test case. Example: >>> parse_input(\\"2n3n(1, 1) (2, -1) (3, 1)n4n(2, 1) (3, 1) (5, -1) (6, -1)\\") [ [(1, 1), (2, -1), (3, 1)], [(2, 1), (3, 1), (5, -1), (6, -1)] ] >>> max_concurrent_requests([[(1, 1), (2, -1), (3, 1)], [(2, 1), (3, 1), (5, -1), (6, -1)]]) [1, 2] def parse_input(input_string): Parses the input string into the required format for the test cases. Args: input_string (str): The input string in the specified format. Returns: List[List[Tuple[int, int]]]: List of test cases where each test case is a list of requests, and each request is represented by a tuple (t, type). Example: >>> parse_input(\\"2n3n(1, 1) (2, -1) (3, 1)n4n(2, 1) (3, 1) (5, -1) (6, -1)\\") [ [(1, 1), (2, -1), (3, 1)], [(2, 1), (3, 1), (5, -1), (6, -1)] ] from solution import max_concurrent_requests, parse_input def test_single_request(): input_string = \\"1n1n(1, 1)\\" test_cases = parse_input(input_string) result = max_concurrent_requests(test_cases) assert result == [1] def test_sample_input_1(): input_string = \\"1n3n(1, 1) (2, -1) (3, 1)\\" test_cases = parse_input(input_string) result = max_concurrent_requests(test_cases) assert result == [1] def test_sample_input_2(): input_string = \\"1n4n(2, 1) (3, 1) (5, -1) (6, -1)\\" test_cases = parse_input(input_string) result = max_concurrent_requests(test_cases) assert result == [2] def test_multiple_test_cases(): input_string = \\"2n3n(1, 1) (2, -1) (3, 1)n4n(2, 1) (3, 1) (5, -1) (6, -1)\\" test_cases = parse_input(input_string) result = max_concurrent_requests(test_cases) assert result == [1, 2] def test_large_number_of_requests(): input_string = \\"1n6n(1, 1) (2, 1) (3, 1) (4, -1) (5, -1) (6, -1)\\" test_cases = parse_input(input_string) result = max_concurrent_requests(test_cases) assert result == [3]","solution":"def max_concurrent_requests(test_cases): results = [] for requests in test_cases: events = [] for t, type in requests: events.append((t, type)) events.sort(key=lambda x: (x[0], -x[1])) max_concurrent = 0 current_concurrent = 0 for time, type in events: current_concurrent += type if current_concurrent > max_concurrent: max_concurrent = current_concurrent results.append(max_concurrent) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) index += 1 requests = eval(\\"[\\" + lines[index].replace(\\") (\\", \\"),(\\") + \\"]\\") test_cases.append(requests) index += 1 return test_cases"},{"question":"def count_unique_substrings(s: str) -> int: Counts the number of unique substrings of the given string s. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 # Function implementation goes here ... def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes the given number of test cases and returns the results for the number of unique substrings for each test case. >>> process_test_cases(2, [\\"abc\\", \\"aaa\\"]) [6, 3] >>> process_test_cases(1, [\\"abcd\\"]) [10] # Function implementation goes here ... from solution import count_unique_substrings, process_test_cases def test_count_unique_substrings(): assert count_unique_substrings(\\"abc\\") == 6 assert count_unique_substrings(\\"aaa\\") == 3 assert count_unique_substrings(\\"abcd\\") == 10 assert count_unique_substrings(\\"a\\") == 1 assert count_unique_substrings(\\"abab\\") == 7 assert count_unique_substrings(\\"ababa\\") == 9 def test_process_test_cases(): assert process_test_cases(2, [\\"abc\\", \\"aaa\\"]) == [6, 3] assert process_test_cases(1, [\\"abcd\\"]) == [10] assert process_test_cases(3, [\\"a\\", \\"ab\\", \\"abc\\"]) == [1, 3, 6]","solution":"def count_unique_substrings(s): Counts the number of unique substrings of the given string s. unique_substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): unique_substrings.add(s[i:j]) return len(unique_substrings) def process_test_cases(T, test_cases): results = [] for i in range(T): results.append(count_unique_substrings(test_cases[i])) return results"},{"question":"def maxIncreasingSubseqSum(n: int, arr: List[int]) -> int: Returns the maximum sum of any subsequence in which the elements appear in increasing order. >>> maxIncreasingSubseqSum(6, [1, 101, 2, 3, 100, 4]) 106 >>> maxIncreasingSubseqSum(5, [1, 2, 3, 4, 5]) 15 >>> maxIncreasingSubseqSum(4, [-1, -2, -3, -4]) -1 >>> maxIncreasingSubseqSum(6, [10, 5, 4, 3, 2, 1]) 10 >>> maxIncreasingSubseqSum(1, [10]) 10 >>> maxIncreasingSubseqSum(0, []) 0 >>> maxIncreasingSubseqSum(5, [-1, 2, -3, 4, -5]) 6 >>> maxIncreasingSubseqSum(5, [5, 4, 3, 2, 1]) 5","solution":"def maxIncreasingSubseqSum(n, arr): Returns the maximum sum of increasing subsequence from the array. if n == 0: return 0 # Initialize dp array where dp[i] will be the max sum of increasing subsequence that ends with arr[i] dp = arr[:] # Start with each element itself being the maximum sum subsequence for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + arr[i]: dp[i] = dp[j] + arr[i] return max(dp)"},{"question":"from typing import List from collections import Counter def min_operations_to_equal_elements(N: int, A: List[int]) -> int: Determine the minimum number of operations required to make all elements in the array equal. Parameters: N (int): The number of elements in the array A (list): A list of integers Returns: int: Minimum number of operations required >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 3 >>> min_operations_to_equal_elements(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements(5, [1, 2, 2, 3, 3]) 3 >>> min_operations_to_equal_elements(1, [100]) 0 >>> min_operations_to_equal_elements(6, [1, 1, 1, 1, 2, 2]) 2","solution":"def min_operations_to_equal_elements(N, A): Determine the minimum number of operations required to make all elements in the array equal. Parameter: N (int): The number of elements in the array A (list): A list of integers Returns: int: Minimum number of operations required # To make all elements equal, we can count the frequency of each element from collections import Counter frequency = Counter(A) # The most frequent element in the array is the one we should aim to make all other elements equal to max_frequency = max(frequency.values()) # The number of operations needed to make all elements equal to the most frequent element return N - max_frequency"},{"question":"def relative_sort(arr, n): Reorders the array such that all the elements equal to 0 appear before the elements equal to 1, which must appear before the elements equal to 2, maintaining their original relative order within groups. >>> relative_sort([2, 0, 2, 1, 1], 5) [0, 1, 1, 2, 2] >>> relative_sort([0, 1, 0, 2, 1, 2, 0], 7) [0, 0, 0, 1, 1, 2, 2] pass def process_test_cases(q, test_cases): Process multiple test cases for the relative_sort function. >>> process_test_cases(1, [(5, [2, 0, 2, 1, 1])]) '0 1 1 2 2' >>> process_test_cases(2, [(7, [0, 1, 0, 2, 1, 2, 0]), (4, [2, 2, 0, 1])]) '0 0 0 1 1 2 2n0 1 2 2' pass","solution":"def relative_sort(arr, n): return sorted(arr, key=lambda x: (x != 0, x != 1)) def process_test_cases(q, test_cases): results = [] for case in test_cases: n, arr = case sorted_arr = relative_sort(arr, n) results.append(' '.join(map(str, sorted_arr))) return 'n'.join(results)"},{"question":"def product_except_self(arr): Returns an array such that each element at index 'i' of the array is the product of all the elements in the original array except 'arr[i]'. >>> product_except_self([1, 2, 3]) == [6, 3, 2] >>> product_except_self([4, 2, 1, 5]) == [10, 20, 40, 8] pass def solve(t, test_cases): For each test case, computes and prints the product array based on the given criteria. >>> t = 2 >>> test_cases = [(3, [1, 2, 3]), (4, [4, 2, 1, 5])] >>> solve(t, test_cases) == ['6 3 2', '10 20 40 8'] >>> t = 1 >>> test_cases = [(5, [10, 3, 5, 6, 2])] >>> solve(t, test_cases) == ['180 600 360 300 900'] pass","solution":"def product_except_self(arr): Returns an array such that each element at index 'i' of the array is the product of all the elements in the original array except 'arr[i]'. n = len(arr) result = [1] * n # Compute products of all elements to the left of each index left_products = 1 for i in range(n): result[i] = left_products left_products *= arr[i] # Compute products of all elements to the right of each index right_products = 1 for i in range(n-1, -1, -1): result[i] *= right_products right_products *= arr[i] return result def solve(t, test_cases): For each test case, computes and prints the product array based on the given criteria. results = [] for i in range(t): n, arr = test_cases[i] result = product_except_self(arr) results.append(\\" \\".join(map(str, result))) return results"},{"question":"def distribute_books(shelves, books): Determines if it's possible to distribute a given number of books across shelves such that each shelf is either completely filled or left empty. shelves: List[int] - List of integers representing the capacities of the shelves. books: int - Total number of books to distribute. return: bool - True if it is possible to distribute the books accordingly, otherwise False. Examples: >>> distribute_books([5, 10, 20], 25) True >>> distribute_books([5, 10, 20], 23) False pass from solution import distribute_books def test_distribute_books_example_cases(): assert distribute_books([5, 10, 20], 25) == True assert distribute_books([5, 10, 20], 23) == False def test_distribute_books_single_shelf_case(): assert distribute_books([30], 30) == True assert distribute_books([30], 31) == False def test_distribute_books_no_shelves(): assert distribute_books([], 10) == False assert distribute_books([], 0) == True def test_distribute_books_zero_books(): assert distribute_books([1, 10, 20], 0) == True def test_distribute_books_large_input(): assert distribute_books([1, 2, 5, 10, 20, 50, 100], 77) == True assert distribute_books([1, 2, 5, 10, 20, 50, 100], 99) == False","solution":"def distribute_books(shelves, books): Determines if it's possible to distribute a given number of books across shelves such that each shelf is either completely filled or left empty. shelves: List[int] - List of integers representing the capacities of the shelves. books: int - Total number of books to distribute. return: bool - True if it is possible to distribute the books accordingly, otherwise False. dp = [False] * (books + 1) dp[0] = True for shelf in shelves: for b in range(books, shelf - 1, -1): if dp[b - shelf]: dp[b] = True return dp[books]"},{"question":"def minimum_cuts_to_adjust_tree_heights(n, heights): Returns the minimum number of cuts required to adjust the heights of trees such that no two adjacent trees have a height difference greater than 1. :param int n: Number of trees. :param list heights: Heights of the trees. :return: Minimum number of cuts required. :rtype: int pass from solution import minimum_cuts_to_adjust_tree_heights def test_example_1(): assert minimum_cuts_to_adjust_tree_heights(6, [5, 7, 3, 6, 5, 8]) == 5 def test_example_2(): assert minimum_cuts_to_adjust_tree_heights(4, [1, 2, 3, 4]) == 0 def test_one_tree(): assert minimum_cuts_to_adjust_tree_heights(1, [10]) == 0 def test_two_trees(): assert minimum_cuts_to_adjust_tree_heights(2, [5, 10]) == 4 assert minimum_cuts_to_adjust_tree_heights(2, [10, 5]) == 4 def test_all_trees_same_height(): assert minimum_cuts_to_adjust_tree_heights(5, [4, 4, 4, 4, 4]) == 0 def test_alternating_heights(): assert minimum_cuts_to_adjust_tree_heights(5, [3, 10, 3, 10, 3]) == 12","solution":"def minimum_cuts_to_adjust_tree_heights(n, heights): Returns the minimum number of cuts required to adjust the heights of trees such that no two adjacent trees have a height difference greater than 1. :param int n: Number of trees. :param list heights: Heights of the trees. :return: Minimum number of cuts required. :rtype: int cuts = 0 for i in range(1, n): if abs(heights[i] - heights[i - 1]) > 1: cuts += abs(heights[i] - heights[i - 1]) - 1 heights[i] = heights[i - 1] + 1 if heights[i] > heights[i - 1] else heights[i - 1] - 1 return cuts"},{"question":"def generate_grid(m, n): Generates a grid of size m x n filled with non-negative integers such that any two adjacent cells (vertically or horizontally) are not equal. Args: m (int): number of rows. n (int): number of columns. Returns: List[List[int]]: A grid satisfying the given conditions. Examples: >>> generate_grid(3, 3) [[1, 2, 1], [2, 1, 2], [1, 2, 1]] >>> generate_grid(2, 4) [[1, 2, 1, 2], [2, 1, 2, 1]] from typing import List def test_generate_grid_3x3(): expected = [ [1, 2, 1], [2, 1, 2], [1, 2, 1], ] assert generate_grid(3, 3) == expected def test_generate_grid_2x4(): expected = [ [1, 2, 1, 2], [2, 1, 2, 1], ] assert generate_grid(2, 4) == expected def test_generate_grid_1x1(): expected = [[1]] assert generate_grid(1, 1) == expected def test_generate_grid_4x4(): expected = [ [1, 2, 1, 2], [2, 1, 2, 1], [1, 2, 1, 2], [2, 1, 2, 1], ] assert generate_grid(4, 4) == expected def test_generate_grid_4x3(): expected = [ [1, 2, 1], [2, 1, 2], [1, 2, 1], [2, 1, 2], ] assert generate_grid(4, 3) == expected def test_generate_grid_2x2(): expected = [ [1, 2], [2, 1], ] assert generate_grid(2, 2) == expected","solution":"def generate_grid(m, n): Generates a grid of size m x n filled with non-negative integers such that any two adjacent cells (vertically or horizontally) are not equal. grid = [] for i in range(m): row = [] for j in range(n): if (i + j) % 2 == 0: row.append(1) else: row.append(2) grid.append(row) return grid"},{"question":"def can_distribute_packages(num_cases, cases): Determine if the packages can be distributed among the trucks without exceeding the maximum carrying capacity of any truck. Args: num_cases: int - The number of test cases. cases: List[Tuple[int, int, List[int], List[int]]] - A list of tuples where each tuple contains: M: int - The number of trucks. P: int - The number of packages. capacities: List[int] - A list of integers representing the maximum carrying capacity of each truck. weights: List[int] - A list of integers representing the weight of each package. Returns: List[str]: A list of strings \\"Possible\\" or \\"Not Possible\\" for each test case. pass def process_input(input_data): Process the input data to extract the number of cases and their respective parameters. Args: input_data: str - The input data as a string. Returns: Tuple[int, List[Tuple[int, int, List[int], List[int]]]]: A tuple containing the number of test cases and a list of tuples for each test case. pass def main(input_data): Main function to process the input data and determine the results for each test case. Args: input_data: str - The input data as a string. Returns: str: The results for each test case, either \\"Possible\\" or \\"Not Possible\\", separated by new lines. pass","solution":"def can_distribute_packages(num_cases, cases): results = [] for case in cases: M, P, capacities, weights = case capacities.sort(reverse=True) weights.sort(reverse=True) if sum(weights) > sum(capacities): results.append(\\"Not Possible\\") continue j = 0 for weight in weights: if j < M and capacities[j] >= weight: capacities[j] -= weight capacities.sort(reverse=True) else: results.append(\\"Not Possible\\") break else: results.append(\\"Possible\\") return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) cases = [] line_index = 1 for _ in range(T): M, P = map(int, lines[line_index].split()) capacities = list(map(int, lines[line_index+1].split())) weights = list(map(int, lines[line_index+2].split())) cases.append((M, P, capacities, weights)) line_index += 3 return T, cases def main(input_data): T, cases = process_input(input_data) results = can_distribute_packages(T, cases) return \\"n\\".join(results)"},{"question":"def longest_non_decreasing_subsequence_length(arr): Finds the length of the longest non-decreasing subsequence in a given list of integers. >>> longest_non_decreasing_subsequence_length([1, 2, 3, 4]) 4 >>> longest_non_decreasing_subsequence_length([4, 3, 2, 1]) 1 >>> longest_non_decreasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 pass def process_input(input_lines): Processes the input lines, finding the length of the longest non-decreasing subsequence for each list of integers. >>> input_lines = [ ... \\"1 2 3 4\\", ... \\"4 3 2 1\\", ... \\"10 22 9 33 21 50 41 60 80\\", ... \\"0\\" ... ] >>> process_input(input_lines) [4, 1, 6] pass","solution":"def longest_non_decreasing_subsequence_length(arr): if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_input(input_lines): results = [] for line in input_lines: if line.strip() == '0': break arr = list(map(int, line.strip().split())) results.append(longest_non_decreasing_subsequence_length(arr)) return results"},{"question":"from typing import List, Tuple def can_reach_with_energy(N: int, M: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int, int]]) -> List[str]: Determines whether there exists a path between stones U and V such that the sum of the magical energy values of the paths in this path is at least W. Args: N: Number of stones. M: Number of magical paths. edges: A list of tuples, where each tuple contains three integers A, B, and E representing a magical path between stone A and stone B with energy value E. queries: A list of tuples, where each tuple contains three integers U, V, and W representing a query for the existence of a path between stone U and stone V with at least W total magical energy. Returns: A list of strings with \\"YES\\" if such a path exists, otherwise \\"NO\\". >>> edges = [(1, 2, 4), (2, 3, 5), (3, 4, 10), (4, 5, 1), (5, 6, 3), (1, 6, 7), (2, 5, 9)] >>> queries = [(1, 5, 15), (2, 6, 8), (4, 1, 10)] >>> can_reach_with_energy(6, 7, edges, queries) ['NO', 'YES', 'YES'] >>> edges = [(1, 2, 4), (2, 3, 5)] >>> queries = [(1, 4, 1)] >>> can_reach_with_energy(4, 2, edges, queries) ['NO'] >>> edges = [(1, 2, 4), (2, 3, 5)] >>> queries = [(1, 2, 4), (1, 2, 3), (2, 3, 6)] >>> can_reach_with_energy(4, 2, edges, queries) ['YES', 'YES', 'NO'] >>> edges = [(1, 2, 4), (2, 3, 5), (3, 4, 7), (1, 4, 15)] >>> queries = [(1, 4, 10), (1, 3, 6), (3, 4, 8)] >>> can_reach_with_energy(4, 4, edges, queries) ['YES', 'YES', 'NO']","solution":"from collections import defaultdict, deque def can_reach_with_energy(N, M, edges, queries): graph = defaultdict(list) for A, B, E in edges: graph[A].append((B, E)) graph[B].append((A, E)) def bfs(U, V, W): queue = deque([(U, 0)]) visited = set([U]) while queue: node, total_energy = queue.popleft() if node == V and total_energy >= W: return \\"YES\\" for neighbor, energy in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, total_energy + energy)) return \\"NO\\" results = [] for U, V, W in queries: visited_queries = set() if (U, V, W) not in visited_queries: visited_queries.add((U, V, W)) results.append(bfs(U, V, W)) return results # Example usage: # edges = [(1, 2, 4), (2, 3, 5), (3, 4, 10), (4, 5, 1), (5, 6, 3), (1, 6, 7), (2, 5, 9)] # queries = [(1, 5, 15), (2, 6, 8), (4, 1, 10)] # N, M = 6, 7 # print(can_reach_with_energy(N, M, edges, queries)) # Output: ['NO', 'YES', 'YES']"},{"question":"def find_missing_number(reg_numbers): Returns the smallest missing registration number from the list. Args: reg_numbers: List of integers representing registration numbers. Returns: An integer, the smallest missing registration number. pass # Examples to illustrate the expected usage # find_missing_number([1, 2, 3, 5]) --> 4 # find_missing_number([2, 3, 4, 7]) --> 1 # find_missing_number([1, 2, 3, 4, 5]) --> 6 # Unit tests def test_find_missing_number(): assert find_missing_number([1, 2, 3, 5]) == 4 assert find_missing_number([2, 3, 4, 7]) == 1 assert find_missing_number([1, 2, 3, 4, 5]) == 6 assert find_missing_number([]) == 1 assert find_missing_number([1, 1, 1]) == 2 assert find_missing_number([3, 4, 5, 6]) == 1 assert find_missing_number([1, 3, 6, 4, 1, 2]) == 5 assert find_missing_number([2]) == 1 assert find_missing_number([1]) == 2","solution":"def find_missing_number(reg_numbers): Returns the smallest missing registration number from the list. Args: reg_numbers: List of integers representing registration numbers. Returns: An integer, the smallest missing registration number. n = len(reg_numbers) reg_numbers_set = set(reg_numbers) for i in range(1, n + 2): # from 1 to n+1 if i not in reg_numbers_set: return i"},{"question":"def form_groups(N: int, M: int, G: int, P: List[List[int]], S: List[List[int]]) -> int: Returns the maximum number of groups that can be formed given the number of students, number of groups, minimum group size, preferences matrix and schedule matrix. Args: N (int): number of students (1 ≤ N ≤ 200) M (int): number of groups (1 ≤ M ≤ 50) G (int): minimum number of students required in each group (1 ≤ G ≤ 5) P (List[List[int]]): matrix of size N x N where P[i][j] = 1 indicates student i can work with student j and 0 otherwise S (List[List[int]]): matrix of size N x M where S[i][k] = 1 indicates student i can work in group k's time slot and 0 otherwise Returns: int: the maximum number of groups that can be formed pass # Example Unit Tests: def test_example_case_1(): N = 5 M = 3 G = 2 P = [ [1, 1, 0, 1, 1], [1, 1, 1, 1, 0], [0, 1, 1, 0, 0], [1, 1, 0, 1, 1], [1, 0, 0, 1, 1], ] S = [ [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 0], ] assert form_groups(N, M, G, P, S) == 2 def test_example_case_2(): N = 4 M = 2 G = 2 P = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], ] S = [ [1, 0], [1, 0], [0, 1], [0, 1], ] assert form_groups(N, M, G, P, S) == 2 def test_no_group_possible(): N = 2 M = 2 G = 2 P = [ [1, 0], [0, 1], ] S = [ [1, 0], [0, 1], ] assert form_groups(N, M, G, P, S) == 0 def test_all_students_in_one_group(): N = 5 M = 1 G = 5 P = [ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], ] S = [ [1], [1], [1], [1], [1], ] assert form_groups(N, M, G, P, S) == 1 def test_complex_case(): N = 6 M = 2 G = 3 P = [ [1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 1], [1, 0, 0, 1, 1, 0], [0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1], ] S = [ [1, 0], [0, 1], [1, 1], [0, 0], [1, 1], [0, 1], ] assert form_groups(N, M, G, P, S) == 1","solution":"def form_groups(N, M, G, P, S): Returns the maximum number of groups that can be formed # Step 1: Initialize the count of groups groups_formed = 0 # Step 2: Initialize list to check if a student is already used in a group used_students = [False] * N # Step 3: Iterate over each group slot for k in range(M): # Find all students who can work in this group time slot possible_students = [i for i in range(N) if S[i][k] == 1] # Construct potential group list group_candidates = [] # Step 4: Check for each combination of students if they can form a group for i in range(len(possible_students)): for j in range(i + 1, len(possible_students)): student1 = possible_students[i] student2 = possible_students[j] if (P[student1][student2] == 1 and not used_students[student1] and not used_students[student2]): group_candidates.append((student1, student2)) # Step 5: If we have enough candidates to form the required size group if len(group_candidates) >= G / 2: groups_formed += 1 # Mark all used students to not consider them again for (student1, student2) in group_candidates: used_students[student1] = True used_students[student2] = True # Return the maximum number of groups formed return groups_formed # Read input data as described in the problem statement # Example usage (should be replaced in actual use with dynamic input reading): N = 5 M = 3 G = 2 P = [ [1, 1, 0, 1, 1], [1, 1, 1, 1, 0], [0, 1, 1, 0, 0], [1, 1, 0, 1, 1], [1, 0, 0, 1, 1], ] S = [ [1, 1, 0], [0, 1, 1], [1, 0, 1], [0, 1, 1], [1, 1, 0], ] # Example Output print(form_groups(N, M, G, P, S)) # Output should be 2"},{"question":"def reorder_array(arr): Reorders elems in the array such that even numbers come first while maintaining the relative order. Parameters: arr (list of int): The input array Returns: list of int: The reordered array pass # Your code goes here def process_test_cases(test_cases): Process multiple test cases and return reordered arrays. Parameters: test_cases (list of tuples): Each tuple contains number of elements in the array and the array itself. Returns: list of list of int: List of reordered arrays for each test case pass # Your code goes here def main(input_data): Parse input data, call process_test_cases and format the output. Parameters: input_data (str): Input data as a multiline string pass # Your code goes here # Unit Tests def test_reorder_array_mixed(): assert reorder_array([1, 2, 3, 4, 5]) == [2, 4, 1, 3, 5] def test_reorder_array_already_even_odd(): assert reorder_array([2, 4, 6, 1, 3, 5]) == [2, 4, 6, 1, 3, 5] def test_reorder_array_all_even(): assert reorder_array([2, 4, 6, 8]) == [2, 4, 6, 8] def test_reorder_array_all_odd(): assert reorder_array([1, 3, 5, 7]) == [1, 3, 5, 7] def test_process_test_cases(): test_cases = [(5, [1, 2, 3, 4, 5]), (4, [10, 3, 14, 11])] results = process_test_cases(test_cases) assert results == [[2, 4, 1, 3, 5], [10, 14, 3, 11]] def test_main(capsys): input_data = \\"2n5n1 2 3 4 5n4n10 3 14 11n\\" main(input_data) captured = capsys.readouterr() output = captured.out.strip().split(\\"n\\") assert output == [\\"2 4 1 3 5\\", \\"10 14 3 11\\"]","solution":"def reorder_array(arr): Reorders elems in the array such that even numbers come first while maintaining the relative order. Parameters: arr (list of int): The input array Returns: list of int: The reordered array evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds def process_test_cases(test_cases): Process multiple test cases and return reordered arrays. Parameters: test_cases (list of tuples): Each tuple contains number of elements in the array and the array itself. Returns: list of list of int: List of reordered arrays for each test case results = [] for n, arr in test_cases: results.append(reorder_array(arr)) return results def main(input_data): Parse input data, call process_test_cases and format the output. Parameters: input_data (str): Input data as a multiline string lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 results = process_test_cases(test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"from typing import List, Optional def nth_most_frequent_word(words: List[str], n: int) -> Optional[str]: Returns the nth most frequently occurring word in the list. If multiple words have the same frequency, returns the lexicographically smallest word among them. If n is greater than the number of distinct words, returns None. >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 1) 'apple' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) 'banana' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 3) 'orange' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 4) None >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\"], 1) 'apple' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\"], 2) 'banana' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\"], 3) 'orange' >>> nth_most_frequent_word([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\"], 4) None pass","solution":"from collections import Counter def nth_most_frequent_word(words, n): Returns the nth most frequently occurring word in the list. If multiple words have the same frequency, returns the lexicographically smallest word among them. If n is greater than the number of distinct words in the list, returns None. if not words or n <= 0: return None # Count frequency of each word word_count = Counter(words) # Create a sorted list of words based on frequency first, and lexicographically next sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Check if n is within the length of distinct words if n > len(sorted_words): return None return sorted_words[n - 1][0]"},{"question":"def minimum_delivery_routes(N: int, K: int, addresses: List[int]) -> int: Write a program to simulate the delivery of packages to multiple addresses. Each delivery route must cover all designated addresses exactly once, and each route can deliver to a maximum of \`K\` addresses. The goal is to minimize the total number of delivery routes while ensuring all addresses receive their package. ------ Input ------ - The first line contains two integers, \`N\` and \`K\`, where \`N\` is the number of addresses and \`K\` is the maximum number of addresses a single route can cover. - The second line contains \`N\` space-separated integers, representing the unique identifiers for each address. ------ Output ------ - Print a single integer representing the minimum number of delivery routes required. ------ Constraints ------ - 1 ≤ N ≤ 10,000 - 1 ≤ K ≤ 100 - Each address identifier will be a unique integer and range between 1 and 100,000. ----- Sample Input 1 ------ 10 3 101 102 103 104 105 106 107 108 109 110 ----- Sample Output 1 ------ 4 ----- Sample Input 2 ------ 15 5 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 ----- Sample Output 2 ------ 3 ----- Explanation 1 ------ Example case 1: With 10 addresses and a maximum of 3 addresses per route, we need 4 routes to cover all addresses (3 routes covering 3 addresses each, and 1 route covering the last address). Example case 2: With 15 addresses and a maximum of 5 addresses per route, we need 3 routes to cover all addresses (each covering exactly 5 addresses). >>> minimum_delivery_routes(10, 3, [101, 102, 103, 104, 105, 106, 107, 108, 109, 110]) 4 >>> minimum_delivery_routes(15, 5, [201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215]) 3 >>> minimum_delivery_routes(1, 1, [20]) 1 >>> minimum_delivery_routes(1, 10, [30]) 1 >>> minimum_delivery_routes(10, 10, [i for i in range(1, 11)]) 1 >>> minimum_delivery_routes(100, 200, [i for i in range(1, 101)]) 1 >>> minimum_delivery_routes(50, 99, [i for i in range(50)]) 1 >>> minimum_delivery_routes(9999, 99, [i for i in range(1, 9999 + 1)]) 101 >>> minimum_delivery_routes(10000, 100, [i for i in range(1, 10001)]) 100","solution":"def minimum_delivery_routes(N, K, addresses): Function to determine minimum delivery routes required. Parameters: - N (int): Number of addresses. - K (int): Maximum number of addresses a single route can cover. - addresses (list): List of address identifiers. Returns: - int: Minimum number of delivery routes required. # Calculate the minimum number of routes needed by dividing the number of addresses by the max addresses per route. return (N // K) + (1 if N % K != 0 else 0)"},{"question":"from typing import List def canFormPalindrome(s: str) -> bool: Determines whether a given string can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase English characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False import pytest def test_canFormPalindrome_even_length_palindrome(): assert canFormPalindrome(\\"abccba\\") == True def test_canFormPalindrome_odd_length_palindrome(): assert canFormPalindrome(\\"racecar\\") == True def test_canFormPalindrome_even_length_non_palindrome(): assert canFormPalindrome(\\"abcdef\\") == False def test_canFormPalindrome_odd_length_non_palindrome(): assert canFormPalindrome(\\"abcdefgh\\") == False def test_canFormPalindrome_single_character(): assert canFormPalindrome(\\"a\\") == True def test_canFormPalindrome_two_different_characters(): assert canFormPalindrome(\\"ab\\") == False def test_canFormPalindrome_with_spaces(): assert canFormPalindrome(\\"a man a plan a canal panama\\".replace(\\" \\", \\"\\")) == True def test_canFormPalindrome_all_same_characters(): assert canFormPalindrome(\\"aaaa\\") == True def test_canFormPalindrome_mixed_characters(): assert canFormPalindrome(\\"ivicc\\") == True assert canFormPalindrome(\\"civic\\") == True assert canFormPalindrome(\\"hello\\") == False def test_canFormPalindrome_large_input(): large_string = \\"a\\"*500000 + \\"b\\"*500000 assert canFormPalindrome(large_string) == True def test_canFormPalindrome_large_input_with_one_odd_char(): large_string = \\"a\\"*500000 + \\"b\\"*500000 + \\"c\\"*1 assert canFormPalindrome(large_string) == True def test_canFormPalindrome_large_input_with_two_odd_chars(): large_string = \\"a\\"*500000 + \\"b\\"*500000 + \\"c\\"*1 + \\"d\\"*1 assert canFormPalindrome(large_string) == False","solution":"from collections import Counter def canFormPalindrome(s): Determines whether a given string can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase English characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. # Count the frequency of each character in the string char_count = Counter(s) # Check how many characters have an odd frequency count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency count return odd_count <= 1"},{"question":"def encrypt(s: str) -> str: Encrypt the given string using the described algorithm. For a given string, each character is replaced by the character that is the same distance from the end of the alphabet as the original character is from the beginning. >>> encrypt('abcz') 'zyxa' >>> encrypt('hello') 'svool'","solution":"def encrypt(s): Encrypts the given string using the described algorithm. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The encrypted string. # Mapping each letter to its 'mirrored' counterpart encrypted = ''.join(chr(219 - ord(char)) for char in s) return encrypted"},{"question":"def filter_and_sort_employees(employees): Filters out inactive employees and sorts the list of active employees by their employee ID. Parameters: employees (list of dict): The list of employees. Returns: list of dict: A list of active employees sorted by their employee ID. Examples: >>> filter_and_sort_employees([ ... {\\"name\\": \\"John Doe\\", \\"employee_id\\": 3, \\"is_active\\": False}, ... {\\"name\\": \\"Jane Smith\\", \\"employee_id\\": 1, \\"is_active\\": True}, ... {\\"name\\": \\"Alice Brown\\", \\"employee_id\\": 2, \\"is_active\\": True} ... ]) [{\\"name\\": \\"Jane Smith\\", \\"employee_id\\": 1, \\"is_active\\": True}, {\\"name\\": \\"Alice Brown\\", \\"employee_id\\": 2, \\"is_active\\": True}] >>> filter_and_sort_employees([ ... {\\"name\\": \\"John Doe\\", \\"employee_id\\": 3, \\"is_active\\": False}, ... {\\"name\\": \\"Jane Smith\\", \\"employee_id\\": 1, \\"is_active\\": False}, ... {\\"name\\": \\"Alice Brown\\", \\"employee_id\\": 2, \\"is_active\\": False} ... ]) []","solution":"def filter_and_sort_employees(employees): Filters out inactive employees and sorts the list of active employees by their employee ID. Parameters: employees (list of dict): The list of employees. Returns: list of dict: A list of active employees sorted by their employee ID. active_employees = [employee for employee in employees if employee['is_active']] active_employees_sorted = sorted(active_employees, key=lambda x: x['employee_id']) return active_employees_sorted"},{"question":"def strictAnagram(s1: str, s2: str) -> bool: Determine if two strings are strict anagrams. :param s1: the first string :param s2: the second string :return: true if the strings are strict anagrams, false otherwise","solution":"def strictAnagram(s1, s2): Determine if two strings are strict anagrams. :param s1: the first string :param s2: the second string :return: true if the strings are strict anagrams, false otherwise if s1 == s2 or sorted(s1) != sorted(s2): return False diff_indices = [i for i in range(len(s1)) if s1[i] != s2[i]] if len(diff_indices) == 2: # Check if by swapping these two indices we get matching strings i, j = diff_indices return s1[i] == s2[j] and s1[j] == s2[i] return False"},{"question":"def min_operations_to_arithmetic_sequence(arr): Determine if a given unsorted array is an arithmetic sequence and, if not, return the minimum number of operations required to make it an arithmetic sequence. An operation consists of changing a single element of the array to any integer value. >>> min_operations_to_arithmetic_sequence([1, 3, 5, 7, 9]) 0 >>> min_operations_to_arithmetic_sequence([2, 4, 6, 8, 12]) 1","solution":"def is_arithmetic_sequence(arr): Helper function to determine if an array is already an arithmetic sequence. if len(arr) <= 1: return True common_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - arr[i - 1] != common_diff: return False return True def min_operations_to_arithmetic_sequence(arr): Returns the minimum number of operations needed to make arr an arithmetic sequence. if is_arithmetic_sequence(arr): return 0 min_operations = float('inf') n = len(arr) for i in range(n): for j in range(i + 1, n): potential_diff = (arr[j] - arr[i]) / (j - i) if potential_diff != int(potential_diff): continue potential_diff = int(potential_diff) operations = 0 for k in range(n): expected_value = arr[i] + (k - i) * potential_diff if arr[k] != expected_value: operations += 1 min_operations = min(min_operations, operations) return min_operations"},{"question":"def rotate_image(matrix): Rotates the input square matrix by 90 degrees clockwise and returns the new matrix. You are not allowed to use any of the built-in functions that directly accomplish the rotation. >>> rotate_image([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_image([[1]]) [[1]] >>> rotate_image([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_image([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_image([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]","solution":"def rotate_image(matrix): Rotates the input square matrix by 90 degrees clockwise and returns the new matrix. n = len(matrix) # Create a new matrix of the same size new_matrix = [[None] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - i - 1] = matrix[i][j] return new_matrix"},{"question":"def isPowerOfFour(binary_string: str) -> bool: Determines if a binary string represents a number that is a power of four. Args: binary_string (str): A string representing a binary number. Returns: bool: True if the number is a power of four, False otherwise. Examples: >>> isPowerOfFour('100') True >>> isPowerOfFour('1000') False >>> isPowerOfFour('10000') True >>> isPowerOfFour('10') False","solution":"def isPowerOfFour(binary_string): Determines if a binary string represents a number that is a power of four. Args: binary_string (str): A string representing a binary number. Returns: bool: True if the number is a power of four, False otherwise. # Convert binary string to integer num = int(binary_string, 2) # Check if the number is zero if num == 0: return False # Check if the number is a power of two by ensuring it has exactly one '1' bit if (num & (num - 1)) != 0: return False # Check if the number of trailing zeroes in binary representation is even # This will confirm if it is a power of four return (num.bit_length() - 1) % 2 == 0"},{"question":"from typing import List def leastInterval(tasks: List[str], n: int) -> int: Returns the least number of units of time that the CPU will take to finish all the given tasks. >>> leastInterval([\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\"], 2) 8 >>> leastInterval([\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\"], 0) 6 >>> leastInterval([\\"A\\",\\"A\\",\\"A\\",\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"C\\",\\"D\\",\\"E\\",\\"F\\",\\"G\\"], 2) 16","solution":"from collections import Counter import heapq def leastInterval(tasks, n): Returns the least number of units of time that the CPU will take to finish all the given tasks. task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: i, temp = 0, [] while i <= n: if max_heap: count = heapq.heappop(max_heap) if count < -1: temp.append(count + 1) time += 1 if not max_heap and not temp: break i += 1 for item in temp: heapq.heappush(max_heap, item) return time"},{"question":"from typing import List def find_frequent_elements(nums: List[int], k: int) -> List[int]: Write a function \`find_frequent_elements(nums, k)\` that takes a list of integers \`nums\` and an integer \`k\` as arguments and returns the \`k\` most frequent elements in the list. If there are multiple elements with the same frequency, return the larger elements first. Constraints: - The length of \`nums\` will be in the range \`[1, 10^5]\`. - The elements of \`nums\` can be positive or negative integers, and will be in the range \`[-10^4, 10^4]\`. - The value of \`k\` will be in the range \`[1, 10^5]\`. >>> find_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> find_frequent_elements([4, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9], 3) [7, 8, 4] >>> find_frequent_elements([5, 4, 3, 2, 1], 3) [5, 4, 3] >>> find_frequent_elements([1, 2, 2, 3, 3, 4, 4], 2) [4, 3] >>> find_frequent_elements([-1, -1, -2, -2, -3, -3, -3], 2) [-3, -1] pass","solution":"from collections import Counter import heapq def find_frequent_elements(nums, k): Returns the k most frequent elements in the list nums. If there are multiple elements with the same frequency, return the larger numbers first. # Count the frequency of each element count = Counter(nums) # Use a heap to keep track of the top k elements heap = [] for num, freq in count.items(): # Create a tuple with (-freq, -num) to use max-heap by frequency heapq.heappush(heap, (-freq, -num)) # Extract the top k most frequent elements result = [] for _ in range(k): freq, num = heapq.heappop(heap) result.append(-num) # We negate again to get the original number return result"},{"question":"def count_wins(): For each dataset of player's performance in a chess tournament, determine the total number of wins. Input: - Multiple datasets are given as input. - Each dataset starts with an integer n, representing the number of rounds a player participated in, followed by n strings where each string is either \\"Win\\" or \\"Loss\\". - When the input integer n is 0, it indicates the end of input. Do not output anything for this input. Output: - For each dataset, print the total number of wins for that player on one line. Example: Input: 5 Win Loss Win Win Loss 3 Loss Win Win 0 Output: 3 2 import io import sys def test_count_wins_same_number_of_rounds(): import contextlib input_data = \\"5nWinnLossnWinnWinnLossn0n\\" expected_output = \\"3n\\" stdin = sys.stdin stdout = sys.stdout sys.stdin = io.StringIO(input_data) sys.stdout = io.StringIO() with contextlib.redirect_stdout(sys.stdout): count_wins() output = sys.stdout.getvalue() assert output == expected_output sys.stdin = stdin sys.stdout = stdout def test_count_wins_different_number_of_rounds(): import contextlib input_data = \\"5nWinnLossnWinnWinnLossn3nLossnWinnWinn0n\\" expected_output = \\"3n2n\\" stdin = sys.stdin stdout = sys.stdout sys.stdin = io.StringIO(input_data) sys.stdout = io.StringIO() with contextlib.redirect_stdout(sys.stdout): count_wins() output = sys.stdout.getvalue() assert output == expected_output sys.stdin = stdin sys.stdout = stdout def test_count_wins_only_losses(): import contextlib input_data = \\"3nLossnLossnLossn0n\\" expected_output = \\"0n\\" stdin = sys.stdin stdout = sys.stdout sys.stdin = io.StringIO(input_data) sys.stdout = io.StringIO() with contextlib.redirect_stdout(sys.stdout): count_wins() output = sys.stdout.getvalue() assert output == expected_output sys.stdin = stdin sys.stdout = stdout def test_count_wins_only_wins(): import contextlib input_data = \\"4nWinnWinnWinnWinn0n\\" expected_output = \\"4n\\" stdin = sys.stdin stdout = sys.stdout sys.stdin = io.StringIO(input_data) sys.stdout = io.StringIO() with contextlib.redirect_stdout(sys.stdout): count_wins() output = sys.stdout.getvalue() assert output == expected_output sys.stdin = stdin sys.stdout = stdout","solution":"def count_wins(): import sys input = sys.stdin.read data = input().strip().split('n') index = 0 results = [] while index < len(data): n = int(data[index]) if n == 0: break index += 1 wins = 0 for _ in range(n): if data[index] == \\"Win\\": wins += 1 index += 1 results.append(wins) for result in results: print(result) # This function will read from stdin, process data and print the results # Since we can't run it directly here because of stdin, testing will be purely functional."},{"question":"def find_ap_properties(T, test_cases): Given the first term A, common difference D, and the number of terms N of an arithmetic progression (AP), the function calculates the Nth term and the sum of the first N terms of the AP for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains three integers (A, D, N). Returns: list of tuples: Each tuple contains two integers - the Nth term and the sum of the first N terms of the AP. pass from find_ap_properties import find_ap_properties def test_find_ap_properties_case_1(): T = 1 test_cases = [(1, 1, 5)] result = find_ap_properties(T, test_cases) assert result == [(5, 15)] def test_find_ap_properties_case_2(): T = 1 test_cases = [(2, 3, 4)] result = find_ap_properties(T, test_cases) assert result == [(11, 26)] def test_find_ap_properties_case_3(): T = 1 test_cases = [(-1, -2, 3)] result = find_ap_properties(T, test_cases) assert result == [(-5, -9)] def test_find_ap_properties_edge_case(): T = 1 test_cases = [(0, 0, 1)] result = find_ap_properties(T, test_cases) assert result == [(0, 0)] def test_find_ap_properties_multiple_cases(): T = 3 test_cases = [(1, 1, 5), (2, 3, 4), (-1, -2, 3)] result = find_ap_properties(T, test_cases) assert result == [(5, 15), (11, 26), (-5, -9)]","solution":"def find_ap_properties(T, test_cases): Given the first term A, common difference D, and the number of terms N of an arithmetic progression (AP), the function calculates the Nth term and the sum of the first N terms of the AP for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains three integers (A, D, N). Returns: list of tuples: Each tuple contains two integers - the Nth term and the sum of the first N terms of the AP. results = [] for case in test_cases: A, D, N = case Nth_term = A + (N-1) * D sum_of_first_N_terms = (N * (2 * A + (N - 1) * D)) // 2 results.append((Nth_term, sum_of_first_N_terms)) return results"},{"question":"def has_three_consecutive_days_above_threshold(temperatures: List[int], threshold: int) -> bool: Returns True if there are three consecutive days with temperatures above the given threshold, otherwise returns False. >>> has_three_consecutive_days_above_threshold([73, 74, 75, 71, 69, 72, 76, 73], 70) True >>> has_three_consecutive_days_above_threshold([60, 61, 62, 63, 65, 60, 61, 62], 66) False","solution":"def has_three_consecutive_days_above_threshold(temperatures, threshold): Returns True if there are three consecutive days with temperatures above the given threshold, otherwise returns False. count = 0 # To count consecutive days above threshold for temp in temperatures: if temp > threshold: count += 1 if count == 3: return True else: count = 0 # Reset count if temperature is not above threshold return False"},{"question":"def is_magical(s: str, i: int, j: int) -> str: Check if the substring s[i:j+1] is magical. >>> is_magical(\\"abcdefg\\", 0, 4) \\"Yes\\" >>> is_magical(\\"abcdefg\\", 2, 6) \\"Yes\\" >>> is_magical(\\"abcdefg\\", 0, 6) \\"Yes\\" >>> is_magical(\\"zxyab\\", 0, 2) \\"No\\" >>> is_magical(\\"zxyab\\", 1, 4) \\"No\\" def process_test_cases(t: int, test_cases: list) -> list: Process multiple test cases to determine if the given substrings are magical. >>> test_cases = [ ... {'string': 'abcdefg', 'queries': [(1, 5), (3, 7), (1, 7)]}, ... {'string': 'zxyab', 'queries': [(1, 3), (2, 5)]} ... ] >>> process_test_cases(2, test_cases) [['Yes', 'Yes', 'Yes'], ['No', 'No']] import pytest def test_is_magical(): assert is_magical(\\"abcdefg\\", 0, 4) == \\"Yes\\" assert is_magical(\\"abcdefg\\", 2, 6) == \\"Yes\\" assert is_magical(\\"abcdefg\\", 0, 6) == \\"Yes\\" assert is_magical(\\"zxyab\\", 0, 2) == \\"No\\" assert is_magical(\\"zxyab\\", 1, 4) == \\"No\\" def test_process_test_cases(): test_cases = [ { 'string': 'abcdefg', 'queries': [(1, 5), (3, 7), (1, 7)] }, { 'string': 'zxyab', 'queries': [(1, 3), (2, 5)] } ] expected_output = [ [\\"Yes\\", \\"Yes\\", \\"Yes\\"], [\\"No\\", \\"No\\"] ] assert process_test_cases(2, test_cases) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def is_magical(s, i, j): Check if the substring s[i:j+1] is magical. for k in range(i, j): if abs(ord(s[k]) - ord(s[k + 1])) > 1: return \\"No\\" return \\"Yes\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: s, queries = case['string'], case['queries'] res = [] for (start, end) in queries: res.append(is_magical(s, start-1, end-1)) results.append(res) return results"},{"question":"def largest_valid_integer(s: str) -> str: Returns the largest valid integer that can be formed from the string s. If it is not possible to form any valid integer, returns \\"0\\". >>> largest_valid_integer(\\"abc123\\") \\"321\\" >>> largest_valid_integer(\\"abcd\\") \\"0\\" >>> largest_valid_integer(\\"0\\") \\"0\\" >>> largest_valid_integer(\\"a0b12c3\\") \\"3210\\" >>> largest_valid_integer(\\"a9b8c7d2\\") \\"9872\\" >>> largest_valid_integer(\\"a00000b\\") \\"0\\" >>> largest_valid_integer(\\"a123bc456\\") \\"654321\\" >>> largest_valid_integer(\\"aaa111\\") \\"111\\" >>> largest_valid_integer(\\"a0a1a2a3\\") \\"3210\\" from typing import List def test_largest_valid_integer(): assert largest_valid_integer(\\"abc123\\") == \\"321\\" assert largest_valid_integer(\\"abcd\\") == \\"0\\" assert largest_valid_integer(\\"0\\") == \\"0\\" assert largest_valid_integer(\\"a0b12c3\\") == \\"3210\\" assert largest_valid_integer(\\"a9b8c7d2\\") == \\"9872\\" assert largest_valid_integer(\\"a00000b\\") == \\"0\\" assert largest_valid_integer(\\"a123bc456\\") == \\"654321\\" assert largest_valid_integer(\\"aaa111\\") == \\"111\\" assert largest_valid_integer(\\"a0a1a2a3\\") == \\"3210\\"","solution":"def largest_valid_integer(s): Returns the largest valid integer that can be formed from the string s. If it is not possible to form any valid integer, returns \\"0\\". digits = sorted([ch for ch in s if ch.isdigit()], reverse=True) if not digits: return \\"0\\" result = ''.join(digits) # Remove leading zeroes if there are any if result[0] == '0': # If the largest digit is zero, then all digits are zero return \\"0\\" return result"},{"question":"def count_valid_words(N: int, L: int) -> int: Calculate the total number of distinct valid words of a given length L that can be formed using an alphabet of size N. A valid word is of length L and composed of strictly increasing ranks. >>> count_valid_words(4, 2) 6 >>> count_valid_words(5, 3) 10 >>> count_valid_words(1, 1) 1 >>> count_valid_words(4, 4) 1 >>> count_valid_words(10, 1) 10 >>> count_valid_words(50, 25) 126410606437752 >>> count_valid_words(50, 50) 1","solution":"from math import comb def count_valid_words(N, L): Returns the number of distinct valid words of length L that be formed using an alphabet of size N. Valid words must be in strictly increasing rank order. return comb(N, L)"},{"question":"def can_collect_odd_coins(grid: List[List[int]]) -> str: Determines if Alice can collect an odd number of coins by the time she reaches the bottom-right corner. Alice moves in such a way to collect coins in each cell only once and tries to end up with an odd number. >>> can_collect_odd_coins([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"Yes\\" >>> can_collect_odd_coins([[2, 4], [6, 8]]) \\"No\\"","solution":"def can_collect_odd_coins(grid): Determines if Alice can collect an odd number of coins by the time she reaches the bottom-right corner. M = len(grid) N = len(grid[0]) # Sum all the coins in the grid for precursory odd/even check. total_coins = sum(sum(row) for row in grid) if total_coins % 2 == 1: return \\"Yes\\" return \\"No\\""},{"question":"def are_anagrams(str1, str2): Determines if two strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: str: \\"Yes\\" if the strings are anagrams, otherwise \\"No\\". Example: >>> are_anagrams(\\"listen\\", \\"silent\\") \\"Yes\\" >>> are_anagrams(\\"hello\\", \\"world\\") \\"No\\"","solution":"def are_anagrams(str1, str2): Determines if two strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: str: \\"Yes\\" if the strings are anagrams, otherwise \\"No\\". # Early exit if lengths are not the same if len(str1) != len(str2): return \\"No\\" # Count frequencies of each character in both strings from collections import Counter return \\"Yes\\" if Counter(str1) == Counter(str2) else \\"No\\""},{"question":"def sum_divisible_by_d(arr, d): Returns the sum of all integers in the array that are divisible by d. If no such elements exist, returns 0. >>> sum_divisible_by_d([1, 2, 3, 4, 6], 3) 9 >>> sum_divisible_by_d([10, 15, 20, 25], 5) 70 >>> sum_divisible_by_d([1, 2, 3], 7) 0","solution":"def sum_divisible_by_d(arr, d): total_sum = 0 for num in arr: # Find out if num is divisible by d if num % d == 0: total_sum += num return total_sum"},{"question":"def longestSharedPrefix(strs): Complete the \`longestSharedPrefix\` function to identify the longest common prefix among an array of strings. If there is no common prefix, return an empty string. Example: >>> longestSharedPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longestSharedPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\"","solution":"def longestSharedPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start by assuming the whole first string is the common prefix prefix = strs[0] for s in strs[1:]: while s[:len(prefix)] != prefix and prefix: # Reduce the prefix by one character at the time prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"def minimal_communication_cost(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimal total communication cost to connect all planets through the Minimum Spanning Tree (MST) of the network. Args: n (int): The number of planets. m (int): The number of bidirectional communication channels. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers a, b, and c, indicating there is a communication channel between planet a and planet b with cost c. Returns: int: The minimal total communication cost to connect all planets. Examples: >>> minimal_communication_cost(4, 5, [(1, 2, 1), (2, 3, 4), (3, 4, 3), (1, 3, 5), (1, 4, 2)]) 6 >>> minimal_communication_cost(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 1)]) 3 pass def test_mst_case1(): n = 4 m = 5 edges = [(1, 2, 1), (2, 3, 4), (3, 4, 3), (1, 3, 5), (1, 4, 2)] assert minimal_communication_cost(n, m, edges) == 6 def test_mst_case2(): n = 3 m = 3 edges = [(1, 2, 2), (2, 3, 3), (1, 3, 1)] assert minimal_communication_cost(n, m, edges) == 3 def test_mst_case3_no_edges(): n = 1 m = 0 edges = [] assert minimal_communication_cost(n, m, edges) == 0 def test_mst_case4_single_edge(): n = 2 m = 1 edges = [(1, 2, 10)] assert minimal_communication_cost(n, m, edges) == 10 def test_mst_case5(): n = 6 m = 8 edges = [(1, 2, 2), (2, 3, 3), (1, 4, 6), (4, 5, 1), (5, 6, 3), (2, 5, 2), (3, 6, 1), (1, 6, 5)] assert minimal_communication_cost(n, m, edges) == 9","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 e = 0 i = 0 while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 mst_cost += w union(parent, rank, x, y) return mst_cost def minimal_communication_cost(n, m, edges): return kruskal_mst(n, edges)"},{"question":"def rotateMatrix(matrix): Rotates the input matrix 90 degrees clockwise in-place. Parameters: matrix (list of list of ints): The square matrix to rotate. Returns: None Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] from test_rotateMatrix import test_rotateMatrix_3x3, test_rotateMatrix_4x4, test_rotateMatrix_1x1, test_rotateMatrix_2x2, test_rotateMatrix_5x5 def run_tests(): test_rotateMatrix_3x3() test_rotateMatrix_4x4() test_rotateMatrix_1x1() test_rotateMatrix_2x2() test_rotateMatrix_5x5() run_tests()","solution":"def rotateMatrix(matrix): Rotates the input matrix 90 degrees clockwise in-place. Parameters: matrix (list of list of ints): The square matrix to rotate. Returns: None n = len(matrix) for layer in range(n // 2): first, last = layer, n - layer - 1 for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"def common_words(sentences: List[str]) -> List[str]: Takes a list of strings representing sentences and returns a list of words that are common to all sentences in the order they first appear in the first sentence. >>> common_words([\\"hello world\\", \\"hello there\\", \\"hello hello world\\"]) [\\"hello\\"] >>> common_words([\\"what a beautiful day\\", \\"a beautiful evening\\", \\"the day is beautiful\\"]) [\\"beautiful\\"] >>> common_words([\\"apple orange banana\\", \\"grape banana apple\\", \\"berry apple\\"]) [\\"apple\\"]","solution":"def common_words(sentences): Takes a list of strings representing sentences and returns a list of words that are common to all sentences in the order they first appear in the first sentence. if not sentences: return [] # Split the first sentence into words first_sentence_words = sentences[0].split() # Create a set of common words which initially contains all words from the first sentence common_set = set(first_sentence_words) # Iterate through the remaining sentences for sentence in sentences[1:]: # Update common_set to keep only words that are in the current sentence common_set &= set(sentence.split()) # Filter words from the first sentence in the order they first appeared return [word for word in first_sentence_words if word in common_set]"},{"question":"def count_strictly_increasing_triplets(arr): Returns the number of contiguous subarrays of length 3 with strictly increasing integers. >>> count_strictly_increasing_triplets([1, 2, 3, 1, 2, 3, 4]) 3 >>> count_strictly_increasing_triplets([4, 5, 6, 7]) 2 >>> count_strictly_increasing_triplets([7, 7, 7, 7, 7]) 0","solution":"def count_strictly_increasing_triplets(arr): Returns the number of contiguous subarrays of length 3 with strictly increasing integers. n = len(arr) count = 0 for i in range(n - 2): if arr[i] < arr[i + 1] < arr[i + 2]: count += 1 return count"},{"question":"def max_snippet_value(n: int, a: List[int]) -> int: Finds the maximum value of any snippet of the array, where a snippet is defined by the sum of its distinct elements. :param n: int - Number of elements in the array a. :param a: list of int - The array of integers. :return: int - The maximum value of any snippet. Examples: >>> max_snippet_value(6, [1, 2, 1, 3, 4, 2]) 10 >>> max_snippet_value(5, [5, 5, 5, 5, 5]) 5 >>> max_snippet_value(4, [1, 2, 3, 4]) 10","solution":"def max_snippet_value(n, a): Finds the maximum value of any snippet of the array, where a snippet is defined by the sum of its distinct elements. :param n: int - Number of elements in the array a. :param a: list of int - The array of integers. :return: int - The maximum value of any snippet. if n == 0: return 0 # Using a sliding window to find the maximum sum of distinct elements in a snippet seen = set() # To store distinct elements within the current window left = 0 current_sum = 0 max_sum = 0 for right in range(n): while a[right] in seen: seen.remove(a[left]) current_sum -= a[left] left += 1 seen.add(a[right]) current_sum += a[right] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_outbreak_days(data): Identify the outbreak days based on daily infection counts for each location. Parameters: data (list of list of int): A 2D list where each sublist contains infection counts of a location. Returns: list of int: List of first outbreak days (1-based index) for each location or -1 if no outbreak day exists.","solution":"def find_outbreak_days(data): Identify the outbreak days based on daily infection counts for each location. Parameters: data (list of list of int): A 2D list where each sublist contains infection counts of a location. Returns: list of int: List of first outbreak days (1-based index) for each location or -1 if no outbreak day exists. outbreak_days = [] for infection_counts in data: max_so_far = -1 outbreak_day = -1 for day, count in enumerate(infection_counts): if count > max_so_far: if day > 0: # Outbreak day can't be the first day outbreak_day = day + 1 # Convert 0-based index to 1-based index break max_so_far = count outbreak_days.append(outbreak_day) return outbreak_days"},{"question":"from typing import List def min_coins(coins: List[int], amount: int) -> int: A function that calculates the minimum number of coins needed to make change for a given amount using a specified set of coin denominations. If it is not possible to make change for the given amount using the provided denominations, returns -1. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1, 2, 3], 6) 2 >>> min_coins([1, 5, 10, 25], 30) 2 >>> min_coins([1, 3, 4], 6) 2","solution":"def min_coins(coins, amount): Returns the minimum number of coins needed to make the given amount using the given coin denominations. If it is not possible to make the amount with the given denominations, returns -1. # Create a list to store the minimum coins needed to make each amount from 0 to amount dp = [float('inf')] * (amount + 1) # Base case: no coins are needed to make an amount of 0 dp[0] = 0 # Iterate through each amount from 1 to amount for a in range(1, amount + 1): # Iterate through each coin denomination for coin in coins: if a - coin >= 0: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still float('inf'), it means it's not possible to make the amount with the given denominations return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def minimal_prep_time_for_ingredients(t: int, test_cases: List[str]) -> List[Tuple[int, str]]: Calculate the minimal preparation time and the corresponding subsequence of ingredients chosen. >>> minimal_prep_time_for_ingredients(3, [\\"abcd\\", \\"bcde\\", \\"aabbccdd\\"]) [(10, \\"abcd\\"), (14, \\"bcde\\"), (10, \\"abcd\\")] >>> minimal_prep_time_for_ingredients(1, [\\"zzz\\"]) [(26, \\"z\\")]","solution":"def minimal_prep_time_for_ingredients(t, test_cases): results = [] for s in test_cases: unique_ingredients = sorted(set(s)) total_prep_time = sum((ord(c) - ord('a') + 1) for c in unique_ingredients) results.append((total_prep_time, ''.join(unique_ingredients))) return results"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},P={key:0,class:"empty-state"},I=["disabled"],C={key:0},F={key:1};function z(i,e,u,m,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),n(y,null,x(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",F,"Loading...")):(s(),n("span",C,"See more"))],8,I)):l("",!0)])}const M=c(E,[["render",z],["__scopeId","data-v-279d68ed"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/40.md","filePath":"library/40.md"}'),Y={name:"library/40.md"},G=Object.assign(Y,{setup(i){return(e,u)=>(s(),n("div",null,[v(M)]))}});export{B as __pageData,G as default};
